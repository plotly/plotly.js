/**
* plotly.js (gl3d) v2.27.1
* Copyright 2012-2023, Plotly, Inc.
* All rights reserved.
* Licensed under the MIT license
*/
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Plotly"] = factory();
	else
		root["Plotly"] = factory();
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 8847:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var rules = {
  "X,X div": "direction:ltr;font-family:\"Open Sans\",verdana,arial,sans-serif;margin:0;padding:0;",
  "X input,X button": "font-family:\"Open Sans\",verdana,arial,sans-serif;",
  "X input:focus,X button:focus": "outline:none;",
  "X a": "text-decoration:none;",
  "X a:hover": "text-decoration:none;",
  "X .crisp": "shape-rendering:crispEdges;",
  "X .user-select-none": "-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none;",
  "X svg": "overflow:hidden;",
  "X svg a": "fill:#447adb;",
  "X svg a:hover": "fill:#3c6dc5;",
  "X .main-svg": "position:absolute;top:0;left:0;pointer-events:none;",
  "X .main-svg .draglayer": "pointer-events:all;",
  "X .cursor-default": "cursor:default;",
  "X .cursor-pointer": "cursor:pointer;",
  "X .cursor-crosshair": "cursor:crosshair;",
  "X .cursor-move": "cursor:move;",
  "X .cursor-col-resize": "cursor:col-resize;",
  "X .cursor-row-resize": "cursor:row-resize;",
  "X .cursor-ns-resize": "cursor:ns-resize;",
  "X .cursor-ew-resize": "cursor:ew-resize;",
  "X .cursor-sw-resize": "cursor:sw-resize;",
  "X .cursor-s-resize": "cursor:s-resize;",
  "X .cursor-se-resize": "cursor:se-resize;",
  "X .cursor-w-resize": "cursor:w-resize;",
  "X .cursor-e-resize": "cursor:e-resize;",
  "X .cursor-nw-resize": "cursor:nw-resize;",
  "X .cursor-n-resize": "cursor:n-resize;",
  "X .cursor-ne-resize": "cursor:ne-resize;",
  "X .cursor-grab": "cursor:-webkit-grab;cursor:grab;",
  "X .modebar": "position:absolute;top:2px;right:2px;",
  "X .ease-bg": "-webkit-transition:background-color .3s ease 0s;-moz-transition:background-color .3s ease 0s;-ms-transition:background-color .3s ease 0s;-o-transition:background-color .3s ease 0s;transition:background-color .3s ease 0s;",
  "X .modebar--hover>:not(.watermark)": "opacity:0;-webkit-transition:opacity .3s ease 0s;-moz-transition:opacity .3s ease 0s;-ms-transition:opacity .3s ease 0s;-o-transition:opacity .3s ease 0s;transition:opacity .3s ease 0s;",
  "X:hover .modebar--hover .modebar-group": "opacity:1;",
  "X .modebar-group": "float:left;display:inline-block;box-sizing:border-box;padding-left:8px;position:relative;vertical-align:middle;white-space:nowrap;",
  "X .modebar-btn": "position:relative;font-size:16px;padding:3px 4px;height:22px;cursor:pointer;line-height:normal;box-sizing:border-box;",
  "X .modebar-btn svg": "position:relative;top:2px;",
  "X .modebar.vertical": "display:flex;flex-direction:column;flex-wrap:wrap;align-content:flex-end;max-height:100%;",
  "X .modebar.vertical svg": "top:-1px;",
  "X .modebar.vertical .modebar-group": "display:block;float:none;padding-left:0px;padding-bottom:8px;",
  "X .modebar.vertical .modebar-group .modebar-btn": "display:block;text-align:center;",
  "X [data-title]:before,X [data-title]:after": "position:absolute;-webkit-transform:translate3d(0, 0, 0);-moz-transform:translate3d(0, 0, 0);-ms-transform:translate3d(0, 0, 0);-o-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);display:none;opacity:0;z-index:1001;pointer-events:none;top:110%;right:50%;",
  "X [data-title]:hover:before,X [data-title]:hover:after": "display:block;opacity:1;",
  "X [data-title]:before": "content:\"\";position:absolute;background:rgba(0,0,0,0);border:6px solid rgba(0,0,0,0);z-index:1002;margin-top:-12px;border-bottom-color:#69738a;margin-right:-6px;",
  "X [data-title]:after": "content:attr(data-title);background:#69738a;color:#fff;padding:8px 10px;font-size:12px;line-height:12px;white-space:nowrap;margin-right:-18px;border-radius:2px;",
  "X .vertical [data-title]:before,X .vertical [data-title]:after": "top:0%;right:200%;",
  "X .vertical [data-title]:before": "border:6px solid rgba(0,0,0,0);border-left-color:#69738a;margin-top:8px;margin-right:-30px;",
  Y: "font-family:\"Open Sans\",verdana,arial,sans-serif;position:fixed;top:50px;right:20px;z-index:10000;font-size:10pt;max-width:180px;",
  "Y p": "margin:0;",
  "Y .notifier-note": "min-width:180px;max-width:250px;border:1px solid #fff;z-index:3000;margin:0;background-color:#8c97af;background-color:rgba(140,151,175,.9);color:#fff;padding:10px;overflow-wrap:break-word;word-wrap:break-word;-ms-hyphens:auto;-webkit-hyphens:auto;hyphens:auto;",
  "Y .notifier-close": "color:#fff;opacity:.8;float:right;padding:0 5px;background:none;border:none;font-size:20px;font-weight:bold;line-height:20px;",
  "Y .notifier-close:hover": "color:#444;text-decoration:none;cursor:pointer;"
};
for (var selector in rules) {
  var fullSelector = selector.replace(/^,/, ' ,').replace(/X/g, '.js-plotly-plot .plotly').replace(/Y/g, '.plotly-notifier');
  Lib.addStyleRule(fullSelector, rules[selector]);
}

/***/ }),

/***/ 8222:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(2887);

/***/ }),

/***/ 9509:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(2201);

/***/ }),

/***/ 940:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(8128);

/***/ }),

/***/ 9548:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(8729);

/***/ }),

/***/ 1039:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(4382);

/***/ }),

/***/ 4296:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(3102);

/***/ }),

/***/ 432:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Plotly = __webpack_require__(9548);
Plotly.register([
// traces
__webpack_require__(3043), __webpack_require__(3005), __webpack_require__(6881), __webpack_require__(4534), __webpack_require__(581), __webpack_require__(940), __webpack_require__(7900),
// transforms
__webpack_require__(8222), __webpack_require__(1039), __webpack_require__(4296), __webpack_require__(6398),
// components
__webpack_require__(9509)]);
module.exports = Plotly;

/***/ }),

/***/ 6881:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(4943);

/***/ }),

/***/ 581:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(1164);

/***/ }),

/***/ 3043:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(3551);

/***/ }),

/***/ 6398:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(2275);

/***/ }),

/***/ 7900:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(1510);

/***/ }),

/***/ 3005:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(3601);

/***/ }),

/***/ 4534:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(1410);

/***/ }),

/***/ 2884:
/***/ (function(module) {

"use strict";


/**
 * All paths are tuned for maximum scalability of the arrowhead,
 * ie throughout arrowwidth=0.3..3 the head is joined smoothly
 * to the line, with the line coming from the left and ending at (0, 0).
 *
 * `backoff` is the distance to move the arrowhead and the end of the line,
 * in order that the arrowhead points to the desired place, either at
 * the tip of the arrow or (in the case of circle or square)
 * the center of the symbol.
 *
 * `noRotate`, if truthy, says that this arrowhead should not rotate with the
 * arrow. That's the case for squares, which should always be straight, and
 * circles, for which it's irrelevant.
 */
module.exports = [
// no arrow
{
  path: '',
  backoff: 0
},
// wide with flat back
{
  path: 'M-2.4,-3V3L0.6,0Z',
  backoff: 0.6
},
// narrower with flat back
{
  path: 'M-3.7,-2.5V2.5L1.3,0Z',
  backoff: 1.3
},
// barbed
{
  path: 'M-4.45,-3L-1.65,-0.2V0.2L-4.45,3L1.55,0Z',
  backoff: 1.55
},
// wide line-drawn
{
  path: 'M-2.2,-2.2L-0.2,-0.2V0.2L-2.2,2.2L-1.4,3L1.6,0L-1.4,-3Z',
  backoff: 1.6
},
// narrower line-drawn
{
  path: 'M-4.4,-2.1L-0.6,-0.2V0.2L-4.4,2.1L-4,3L2,0L-4,-3Z',
  backoff: 2
},
// circle
{
  path: 'M2,0A2,2 0 1,1 0,-2A2,2 0 0,1 2,0Z',
  backoff: 0,
  noRotate: true
},
// square
{
  path: 'M2,2V-2H-2V2Z',
  backoff: 0,
  noRotate: true
}];

/***/ }),

/***/ 215:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var ARROWPATHS = __webpack_require__(2884);
var fontAttrs = __webpack_require__(1940);
var cartesianConstants = __webpack_require__(5555);
var templatedArray = (__webpack_require__(4467).templatedArray);
var axisPlaceableObjs = __webpack_require__(4695);
function arrowAxisRefDescription(axis) {
  return ['In order for absolute positioning of the arrow to work, *a' + axis + 'ref* must be exactly the same as *' + axis + 'ref*, otherwise *a' + axis + 'ref* will revert to *pixel* (explained next).', 'For relative positioning, *a' + axis + 'ref* can be set to *pixel*,', 'in which case the *a' + axis + '* value is specified in pixels', 'relative to *' + axis + '*.', 'Absolute positioning is useful', 'for trendline annotations which should continue to indicate', 'the correct trend when zoomed. Relative positioning is useful', 'for specifying the text offset for an annotated point.'].join(' ');
}
function arrowCoordinateDescription(axis, lower, upper) {
  return ['Sets the', axis, 'component of the arrow tail about the arrow head.', 'If `a' + axis + 'ref` is `pixel`, a positive (negative)', 'component corresponds to an arrow pointing', 'from', upper, 'to', lower, '(' + lower, 'to', upper + ').', 'If `a' + axis + 'ref` is not `pixel` and is exactly the same as `' + axis + 'ref`,', 'this is an absolute value on that axis,', 'like `' + axis + '`, specified in the same coordinates as `' + axis + 'ref`.'].join(' ');
}
module.exports = templatedArray('annotation', {
  visible: {
    valType: 'boolean',
    dflt: true,
    editType: 'calc+arraydraw'
  },
  text: {
    valType: 'string',
    editType: 'calc+arraydraw'
  },
  textangle: {
    valType: 'angle',
    dflt: 0,
    editType: 'calc+arraydraw'
  },
  font: fontAttrs({
    editType: 'calc+arraydraw',
    colorEditType: 'arraydraw'
  }),
  width: {
    valType: 'number',
    min: 1,
    dflt: null,
    editType: 'calc+arraydraw'
  },
  height: {
    valType: 'number',
    min: 1,
    dflt: null,
    editType: 'calc+arraydraw'
  },
  opacity: {
    valType: 'number',
    min: 0,
    max: 1,
    dflt: 1,
    editType: 'arraydraw'
  },
  align: {
    valType: 'enumerated',
    values: ['left', 'center', 'right'],
    dflt: 'center',
    editType: 'arraydraw'
  },
  valign: {
    valType: 'enumerated',
    values: ['top', 'middle', 'bottom'],
    dflt: 'middle',
    editType: 'arraydraw'
  },
  bgcolor: {
    valType: 'color',
    dflt: 'rgba(0,0,0,0)',
    editType: 'arraydraw'
  },
  bordercolor: {
    valType: 'color',
    dflt: 'rgba(0,0,0,0)',
    editType: 'arraydraw'
  },
  borderpad: {
    valType: 'number',
    min: 0,
    dflt: 1,
    editType: 'calc+arraydraw'
  },
  borderwidth: {
    valType: 'number',
    min: 0,
    dflt: 1,
    editType: 'calc+arraydraw'
  },
  // arrow
  showarrow: {
    valType: 'boolean',
    dflt: true,
    editType: 'calc+arraydraw'
  },
  arrowcolor: {
    valType: 'color',
    editType: 'arraydraw'
  },
  arrowhead: {
    valType: 'integer',
    min: 0,
    max: ARROWPATHS.length,
    dflt: 1,
    editType: 'arraydraw'
  },
  startarrowhead: {
    valType: 'integer',
    min: 0,
    max: ARROWPATHS.length,
    dflt: 1,
    editType: 'arraydraw'
  },
  arrowside: {
    valType: 'flaglist',
    flags: ['end', 'start'],
    extras: ['none'],
    dflt: 'end',
    editType: 'arraydraw'
  },
  arrowsize: {
    valType: 'number',
    min: 0.3,
    dflt: 1,
    editType: 'calc+arraydraw'
  },
  startarrowsize: {
    valType: 'number',
    min: 0.3,
    dflt: 1,
    editType: 'calc+arraydraw'
  },
  arrowwidth: {
    valType: 'number',
    min: 0.1,
    editType: 'calc+arraydraw'
  },
  standoff: {
    valType: 'number',
    min: 0,
    dflt: 0,
    editType: 'calc+arraydraw'
  },
  startstandoff: {
    valType: 'number',
    min: 0,
    dflt: 0,
    editType: 'calc+arraydraw'
  },
  ax: {
    valType: 'any',
    editType: 'calc+arraydraw'
  },
  ay: {
    valType: 'any',
    editType: 'calc+arraydraw'
  },
  axref: {
    valType: 'enumerated',
    dflt: 'pixel',
    values: ['pixel', cartesianConstants.idRegex.x.toString()],
    editType: 'calc'
  },
  ayref: {
    valType: 'enumerated',
    dflt: 'pixel',
    values: ['pixel', cartesianConstants.idRegex.y.toString()],
    editType: 'calc'
  },
  // positioning
  xref: {
    valType: 'enumerated',
    values: ['paper', cartesianConstants.idRegex.x.toString()],
    editType: 'calc'
  },
  x: {
    valType: 'any',
    editType: 'calc+arraydraw'
  },
  xanchor: {
    valType: 'enumerated',
    values: ['auto', 'left', 'center', 'right'],
    dflt: 'auto',
    editType: 'calc+arraydraw'
  },
  xshift: {
    valType: 'number',
    dflt: 0,
    editType: 'calc+arraydraw'
  },
  yref: {
    valType: 'enumerated',
    values: ['paper', cartesianConstants.idRegex.y.toString()],
    editType: 'calc'
  },
  y: {
    valType: 'any',
    editType: 'calc+arraydraw'
  },
  yanchor: {
    valType: 'enumerated',
    values: ['auto', 'top', 'middle', 'bottom'],
    dflt: 'auto',
    editType: 'calc+arraydraw'
  },
  yshift: {
    valType: 'number',
    dflt: 0,
    editType: 'calc+arraydraw'
  },
  clicktoshow: {
    valType: 'enumerated',
    values: [false, 'onoff', 'onout'],
    dflt: false,
    editType: 'arraydraw'
  },
  xclick: {
    valType: 'any',
    editType: 'arraydraw'
  },
  yclick: {
    valType: 'any',
    editType: 'arraydraw'
  },
  hovertext: {
    valType: 'string',
    editType: 'arraydraw'
  },
  hoverlabel: {
    bgcolor: {
      valType: 'color',
      editType: 'arraydraw'
    },
    bordercolor: {
      valType: 'color',
      editType: 'arraydraw'
    },
    font: fontAttrs({
      editType: 'arraydraw'
    }),
    editType: 'arraydraw'
  },
  captureevents: {
    valType: 'boolean',
    editType: 'arraydraw'
  },
  editType: 'calc',
  _deprecated: {
    ref: {
      valType: 'string',
      editType: 'calc'
    }
  }
});

/***/ }),

/***/ 3749:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Axes = __webpack_require__(9298);
var draw = (__webpack_require__(2605).draw);
module.exports = function calcAutorange(gd) {
  var fullLayout = gd._fullLayout;
  var annotationList = Lib.filterVisible(fullLayout.annotations);
  if (annotationList.length && gd._fullData.length) {
    return Lib.syncOrAsync([draw, annAutorange], gd);
  }
};
function annAutorange(gd) {
  var fullLayout = gd._fullLayout;

  // find the bounding boxes for each of these annotations'
  // relative to their anchor points
  // use the arrow and the text bg rectangle,
  // as the whole anno may include hidden text in its bbox
  Lib.filterVisible(fullLayout.annotations).forEach(function (ann) {
    var xa = Axes.getFromId(gd, ann.xref);
    var ya = Axes.getFromId(gd, ann.yref);
    var xRefType = Axes.getRefType(ann.xref);
    var yRefType = Axes.getRefType(ann.yref);
    ann._extremes = {};
    if (xRefType === 'range') calcAxisExpansion(ann, xa);
    if (yRefType === 'range') calcAxisExpansion(ann, ya);
  });
}
function calcAxisExpansion(ann, ax) {
  var axId = ax._id;
  var letter = axId.charAt(0);
  var pos = ann[letter];
  var apos = ann['a' + letter];
  var ref = ann[letter + 'ref'];
  var aref = ann['a' + letter + 'ref'];
  var padplus = ann['_' + letter + 'padplus'];
  var padminus = ann['_' + letter + 'padminus'];
  var shift = {
    x: 1,
    y: -1
  }[letter] * ann[letter + 'shift'];
  var headSize = 3 * ann.arrowsize * ann.arrowwidth || 0;
  var headPlus = headSize + shift;
  var headMinus = headSize - shift;
  var startHeadSize = 3 * ann.startarrowsize * ann.arrowwidth || 0;
  var startHeadPlus = startHeadSize + shift;
  var startHeadMinus = startHeadSize - shift;
  var extremes;
  if (aref === ref) {
    // expand for the arrowhead (padded by arrowhead)
    var extremeArrowHead = Axes.findExtremes(ax, [ax.r2c(pos)], {
      ppadplus: headPlus,
      ppadminus: headMinus
    });
    // again for the textbox (padded by textbox)
    var extremeText = Axes.findExtremes(ax, [ax.r2c(apos)], {
      ppadplus: Math.max(padplus, startHeadPlus),
      ppadminus: Math.max(padminus, startHeadMinus)
    });
    extremes = {
      min: [extremeArrowHead.min[0], extremeText.min[0]],
      max: [extremeArrowHead.max[0], extremeText.max[0]]
    };
  } else {
    startHeadPlus = apos ? startHeadPlus + apos : startHeadPlus;
    startHeadMinus = apos ? startHeadMinus - apos : startHeadMinus;
    extremes = Axes.findExtremes(ax, [ax.r2c(pos)], {
      ppadplus: Math.max(padplus, headPlus, startHeadPlus),
      ppadminus: Math.max(padminus, headMinus, startHeadMinus)
    });
  }
  ann._extremes[axId] = extremes;
}

/***/ }),

/***/ 4317:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Registry = __webpack_require__(3972);
var arrayEditor = (__webpack_require__(4467).arrayEditor);
module.exports = {
  hasClickToShow: hasClickToShow,
  onClick: onClick
};

/*
 * hasClickToShow: does the given hoverData have ANY annotations which will
 * turn ON if we click here? (used by hover events to set cursor)
 *
 * gd: graphDiv
 * hoverData: a hoverData array, as included with the *plotly_hover* or
 *     *plotly_click* events in the `points` attribute
 *
 * returns: boolean
 */
function hasClickToShow(gd, hoverData) {
  var sets = getToggleSets(gd, hoverData);
  return sets.on.length > 0 || sets.explicitOff.length > 0;
}

/*
 * onClick: perform the toggling (via Plotly.update) implied by clicking
 * at this hoverData
 *
 * gd: graphDiv
 * hoverData: a hoverData array, as included with the *plotly_hover* or
 *     *plotly_click* events in the `points` attribute
 *
 * returns: Promise that the update is complete
 */
function onClick(gd, hoverData) {
  var toggleSets = getToggleSets(gd, hoverData);
  var onSet = toggleSets.on;
  var offSet = toggleSets.off.concat(toggleSets.explicitOff);
  var update = {};
  var annotationsOut = gd._fullLayout.annotations;
  var i, editHelpers;
  if (!(onSet.length || offSet.length)) return;
  for (i = 0; i < onSet.length; i++) {
    editHelpers = arrayEditor(gd.layout, 'annotations', annotationsOut[onSet[i]]);
    editHelpers.modifyItem('visible', true);
    Lib.extendFlat(update, editHelpers.getUpdateObj());
  }
  for (i = 0; i < offSet.length; i++) {
    editHelpers = arrayEditor(gd.layout, 'annotations', annotationsOut[offSet[i]]);
    editHelpers.modifyItem('visible', false);
    Lib.extendFlat(update, editHelpers.getUpdateObj());
  }
  return Registry.call('update', gd, {}, update);
}

/*
 * getToggleSets: find the annotations which will turn on or off at this
 * hoverData
 *
 * gd: graphDiv
 * hoverData: a hoverData array, as included with the *plotly_hover* or
 *     *plotly_click* events in the `points` attribute
 *
 * returns: {
 *   on: Array (indices of annotations to turn on),
 *   off: Array (indices to turn off because you're not hovering on them),
 *   explicitOff: Array (indices to turn off because you *are* hovering on them)
 * }
 */
function getToggleSets(gd, hoverData) {
  var annotations = gd._fullLayout.annotations;
  var onSet = [];
  var offSet = [];
  var explicitOffSet = [];
  var hoverLen = (hoverData || []).length;
  var i, j, anni, showMode, pointj, xa, ya, toggleType;
  for (i = 0; i < annotations.length; i++) {
    anni = annotations[i];
    showMode = anni.clicktoshow;
    if (showMode) {
      for (j = 0; j < hoverLen; j++) {
        pointj = hoverData[j];
        xa = pointj.xaxis;
        ya = pointj.yaxis;
        if (xa._id === anni.xref && ya._id === anni.yref && xa.d2r(pointj.x) === clickData2r(anni._xclick, xa) && ya.d2r(pointj.y) === clickData2r(anni._yclick, ya)) {
          // match! toggle this annotation
          // regardless of its clicktoshow mode
          // but if it's onout mode, off is implicit
          if (anni.visible) {
            if (showMode === 'onout') toggleType = offSet;else toggleType = explicitOffSet;
          } else {
            toggleType = onSet;
          }
          toggleType.push(i);
          break;
        }
      }
      if (j === hoverLen) {
        // no match - only turn this annotation OFF, and only if
        // showmode is 'onout'
        if (anni.visible && showMode === 'onout') offSet.push(i);
      }
    }
  }
  return {
    on: onSet,
    off: offSet,
    explicitOff: explicitOffSet
  };
}

// to handle log axes until v3
function clickData2r(d, ax) {
  return ax.type === 'log' ? ax.l2r(d) : ax.d2r(d);
}

/***/ }),

/***/ 5625:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Color = __webpack_require__(7901);

// defaults common to 'annotations' and 'annotations3d'
module.exports = function handleAnnotationCommonDefaults(annIn, annOut, fullLayout, coerce) {
  coerce('opacity');
  var bgColor = coerce('bgcolor');
  var borderColor = coerce('bordercolor');
  var borderOpacity = Color.opacity(borderColor);
  coerce('borderpad');
  var borderWidth = coerce('borderwidth');
  var showArrow = coerce('showarrow');
  coerce('text', showArrow ? ' ' : fullLayout._dfltTitle.annotation);
  coerce('textangle');
  Lib.coerceFont(coerce, 'font', fullLayout.font);
  coerce('width');
  coerce('align');
  var h = coerce('height');
  if (h) coerce('valign');
  if (showArrow) {
    var arrowside = coerce('arrowside');
    var arrowhead;
    var arrowsize;
    if (arrowside.indexOf('end') !== -1) {
      arrowhead = coerce('arrowhead');
      arrowsize = coerce('arrowsize');
    }
    if (arrowside.indexOf('start') !== -1) {
      coerce('startarrowhead', arrowhead);
      coerce('startarrowsize', arrowsize);
    }
    coerce('arrowcolor', borderOpacity ? annOut.bordercolor : Color.defaultLine);
    coerce('arrowwidth', (borderOpacity && borderWidth || 1) * 2);
    coerce('standoff');
    coerce('startstandoff');
  }
  var hoverText = coerce('hovertext');
  var globalHoverLabel = fullLayout.hoverlabel || {};
  if (hoverText) {
    var hoverBG = coerce('hoverlabel.bgcolor', globalHoverLabel.bgcolor || (Color.opacity(bgColor) ? Color.rgb(bgColor) : Color.defaultLine));
    var hoverBorder = coerce('hoverlabel.bordercolor', globalHoverLabel.bordercolor || Color.contrast(hoverBG));
    Lib.coerceFont(coerce, 'hoverlabel.font', {
      family: globalHoverLabel.font.family,
      size: globalHoverLabel.font.size,
      color: globalHoverLabel.font.color || hoverBorder
    });
  }
  coerce('captureevents', !!hoverText);
};

/***/ }),

/***/ 4128:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var toLogRange = __webpack_require__(8163);

/*
 * convertCoords: when converting an axis between log and linear
 * you need to alter any annotations on that axis to keep them
 * pointing at the same data point.
 * In v3.0 this will become obsolete
 *
 * gd: the plot div
 * ax: the axis being changed
 * newType: the type it's getting
 * doExtra: function(attr, val) from inside relayout that sets the attribute.
 *     Use this to make the changes as it's aware if any other changes in the
 *     same relayout call should override this conversion.
 */
module.exports = function convertCoords(gd, ax, newType, doExtra) {
  ax = ax || {};
  var toLog = newType === 'log' && ax.type === 'linear';
  var fromLog = newType === 'linear' && ax.type === 'log';
  if (!(toLog || fromLog)) return;
  var annotations = gd._fullLayout.annotations;
  var axLetter = ax._id.charAt(0);
  var ann;
  var attrPrefix;
  function convert(attr) {
    var currentVal = ann[attr];
    var newVal = null;
    if (toLog) newVal = toLogRange(currentVal, ax.range);else newVal = Math.pow(10, currentVal);

    // if conversion failed, delete the value so it gets a default value
    if (!isNumeric(newVal)) newVal = null;
    doExtra(attrPrefix + attr, newVal);
  }
  for (var i = 0; i < annotations.length; i++) {
    ann = annotations[i];
    attrPrefix = 'annotations[' + i + '].';
    if (ann[axLetter + 'ref'] === ax._id) convert(axLetter);
    if (ann['a' + axLetter + 'ref'] === ax._id) convert('a' + axLetter);
  }
};

/***/ }),

/***/ 4046:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Axes = __webpack_require__(9298);
var handleArrayContainerDefaults = __webpack_require__(5501);
var handleAnnotationCommonDefaults = __webpack_require__(5625);
var attributes = __webpack_require__(215);
module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
  handleArrayContainerDefaults(layoutIn, layoutOut, {
    name: 'annotations',
    handleItemDefaults: handleAnnotationDefaults
  });
};
function handleAnnotationDefaults(annIn, annOut, fullLayout) {
  function coerce(attr, dflt) {
    return Lib.coerce(annIn, annOut, attributes, attr, dflt);
  }
  var visible = coerce('visible');
  var clickToShow = coerce('clicktoshow');
  if (!(visible || clickToShow)) return;
  handleAnnotationCommonDefaults(annIn, annOut, fullLayout, coerce);
  var showArrow = annOut.showarrow;

  // positioning
  var axLetters = ['x', 'y'];
  var arrowPosDflt = [-10, -30];
  var gdMock = {
    _fullLayout: fullLayout
  };
  for (var i = 0; i < 2; i++) {
    var axLetter = axLetters[i];

    // xref, yref
    var axRef = Axes.coerceRef(annIn, annOut, gdMock, axLetter, '', 'paper');
    if (axRef !== 'paper') {
      var ax = Axes.getFromId(gdMock, axRef);
      ax._annIndices.push(annOut._index);
    }

    // x, y
    Axes.coercePosition(annOut, gdMock, coerce, axRef, axLetter, 0.5);
    if (showArrow) {
      var arrowPosAttr = 'a' + axLetter;
      // axref, ayref
      var aaxRef = Axes.coerceRef(annIn, annOut, gdMock, arrowPosAttr, 'pixel', ['pixel', 'paper']);

      // for now the arrow can only be on the same axis or specified as pixels
      // TODO: sometime it might be interesting to allow it to be on *any* axis
      // but that would require updates to drawing & autorange code and maybe more
      if (aaxRef !== 'pixel' && aaxRef !== axRef) {
        aaxRef = annOut[arrowPosAttr] = 'pixel';
      }

      // ax, ay
      var aDflt = aaxRef === 'pixel' ? arrowPosDflt[i] : 0.4;
      Axes.coercePosition(annOut, gdMock, coerce, aaxRef, arrowPosAttr, aDflt);
    }

    // xanchor, yanchor
    coerce(axLetter + 'anchor');

    // xshift, yshift
    coerce(axLetter + 'shift');
  }

  // if you have one coordinate you should have both
  Lib.noneOrAll(annIn, annOut, ['x', 'y']);

  // if you have one part of arrow length you should have both
  if (showArrow) {
    Lib.noneOrAll(annIn, annOut, ['ax', 'ay']);
  }
  if (clickToShow) {
    var xClick = coerce('xclick');
    var yClick = coerce('yclick');

    // put the actual click data to bind to into private attributes
    // so we don't have to do this little bit of logic on every hover event
    annOut._xclick = xClick === undefined ? annOut.x : Axes.cleanPosition(xClick, gdMock, annOut.xref);
    annOut._yclick = yClick === undefined ? annOut.y : Axes.cleanPosition(yClick, gdMock, annOut.yref);
  }
}

/***/ }),

/***/ 2605:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Registry = __webpack_require__(3972);
var Plots = __webpack_require__(4875);
var Lib = __webpack_require__(1828);
var strTranslate = Lib.strTranslate;
var Axes = __webpack_require__(9298);
var Color = __webpack_require__(7901);
var Drawing = __webpack_require__(1424);
var Fx = __webpack_require__(211);
var svgTextUtils = __webpack_require__(3893);
var setCursor = __webpack_require__(6964);
var dragElement = __webpack_require__(8569);
var arrayEditor = (__webpack_require__(4467).arrayEditor);
var drawArrowHead = __webpack_require__(3011);

// Annotations are stored in gd.layout.annotations, an array of objects
// index can point to one item in this array,
//  or non-numeric to simply add a new one
//  or -1 to modify all existing
// opt can be the full options object, or one key (to be set to value)
//  or undefined to simply redraw
// if opt is blank, val can be 'add' or a full options object to add a new
//  annotation at that point in the array, or 'remove' to delete this one

module.exports = {
  draw: draw,
  drawOne: drawOne,
  drawRaw: drawRaw
};

/*
 * draw: draw all annotations without any new modifications
 */
function draw(gd) {
  var fullLayout = gd._fullLayout;
  fullLayout._infolayer.selectAll('.annotation').remove();
  for (var i = 0; i < fullLayout.annotations.length; i++) {
    if (fullLayout.annotations[i].visible) {
      drawOne(gd, i);
    }
  }
  return Plots.previousPromises(gd);
}

/*
 * drawOne: draw a single cartesian or paper-ref annotation, potentially with modifications
 *
 * index (int): the annotation to draw
 */
function drawOne(gd, index) {
  var fullLayout = gd._fullLayout;
  var options = fullLayout.annotations[index] || {};
  var xa = Axes.getFromId(gd, options.xref);
  var ya = Axes.getFromId(gd, options.yref);
  if (xa) xa.setScale();
  if (ya) ya.setScale();
  drawRaw(gd, options, index, false, xa, ya);
}

// Convert pixels to the coordinates relevant for the axis referred to. For
// example, for paper it would convert to a value normalized by the dimension of
// the plot.
// axDomainRef: if true and axa defined, draws relative to axis domain,
// otherwise draws relative to data (if axa defined) or paper (if not).
function shiftPosition(axa, dAx, axLetter, gs, options) {
  var optAx = options[axLetter];
  var axRef = options[axLetter + 'ref'];
  var vertical = axLetter.indexOf('y') !== -1;
  var axDomainRef = Axes.getRefType(axRef) === 'domain';
  var gsDim = vertical ? gs.h : gs.w;
  if (axa) {
    if (axDomainRef) {
      // here optAx normalized to length of axis (e.g., normally in range
      // 0 to 1). But dAx is in pixels. So we normalize dAx to length of
      // axis before doing the math.
      return optAx + (vertical ? -dAx : dAx) / axa._length;
    } else {
      return axa.p2r(axa.r2p(optAx) + dAx);
    }
  } else {
    return optAx + (vertical ? -dAx : dAx) / gsDim;
  }
}

/**
 * drawRaw: draw a single annotation, potentially with modifications
 *
 * @param {DOM element} gd
 * @param {object} options : this annotation's fullLayout options
 * @param {integer} index : index in 'annotations' container of the annotation to draw
 * @param {string} subplotId : id of the annotation's subplot
 *  - use false for 2d (i.e. cartesian or paper-ref) annotations
 * @param {object | undefined} xa : full x-axis object to compute subplot pos-to-px
 * @param {object | undefined} ya : ... y-axis
 */
function drawRaw(gd, options, index, subplotId, xa, ya) {
  var fullLayout = gd._fullLayout;
  var gs = gd._fullLayout._size;
  var edits = gd._context.edits;
  var className, containerStr;
  if (subplotId) {
    className = 'annotation-' + subplotId;
    containerStr = subplotId + '.annotations';
  } else {
    className = 'annotation';
    containerStr = 'annotations';
  }
  var editHelpers = arrayEditor(gd.layout, containerStr, options);
  var modifyBase = editHelpers.modifyBase;
  var modifyItem = editHelpers.modifyItem;
  var getUpdateObj = editHelpers.getUpdateObj;

  // remove the existing annotation if there is one
  fullLayout._infolayer.selectAll('.' + className + '[data-index="' + index + '"]').remove();
  var annClipID = 'clip' + fullLayout._uid + '_ann' + index;

  // this annotation is gone - quit now after deleting it
  // TODO: use d3 idioms instead of deleting and redrawing every time
  if (!options._input || options.visible === false) {
    d3.selectAll('#' + annClipID).remove();
    return;
  }

  // calculated pixel positions
  // x & y each will get text, head, and tail as appropriate
  var annPosPx = {
    x: {},
    y: {}
  };
  var textangle = +options.textangle || 0;

  // create the components
  // made a single group to contain all, so opacity can work right
  // with border/arrow together this could handle a whole bunch of
  // cleanup at this point, but works for now
  var annGroup = fullLayout._infolayer.append('g').classed(className, true).attr('data-index', String(index)).style('opacity', options.opacity);

  // another group for text+background so that they can rotate together
  var annTextGroup = annGroup.append('g').classed('annotation-text-g', true);
  var editTextPosition = edits[options.showarrow ? 'annotationTail' : 'annotationPosition'];
  var textEvents = options.captureevents || edits.annotationText || editTextPosition;
  function makeEventData(initialEvent) {
    var eventData = {
      index: index,
      annotation: options._input,
      fullAnnotation: options,
      event: initialEvent
    };
    if (subplotId) {
      eventData.subplotId = subplotId;
    }
    return eventData;
  }
  var annTextGroupInner = annTextGroup.append('g').style('pointer-events', textEvents ? 'all' : null).call(setCursor, 'pointer').on('click', function () {
    gd._dragging = false;
    gd.emit('plotly_clickannotation', makeEventData(d3.event));
  });
  if (options.hovertext) {
    annTextGroupInner.on('mouseover', function () {
      var hoverOptions = options.hoverlabel;
      var hoverFont = hoverOptions.font;
      var bBox = this.getBoundingClientRect();
      var bBoxRef = gd.getBoundingClientRect();
      Fx.loneHover({
        x0: bBox.left - bBoxRef.left,
        x1: bBox.right - bBoxRef.left,
        y: (bBox.top + bBox.bottom) / 2 - bBoxRef.top,
        text: options.hovertext,
        color: hoverOptions.bgcolor,
        borderColor: hoverOptions.bordercolor,
        fontFamily: hoverFont.family,
        fontSize: hoverFont.size,
        fontColor: hoverFont.color
      }, {
        container: fullLayout._hoverlayer.node(),
        outerContainer: fullLayout._paper.node(),
        gd: gd
      });
    }).on('mouseout', function () {
      Fx.loneUnhover(fullLayout._hoverlayer.node());
    });
  }
  var borderwidth = options.borderwidth;
  var borderpad = options.borderpad;
  var borderfull = borderwidth + borderpad;
  var annTextBG = annTextGroupInner.append('rect').attr('class', 'bg').style('stroke-width', borderwidth + 'px').call(Color.stroke, options.bordercolor).call(Color.fill, options.bgcolor);
  var isSizeConstrained = options.width || options.height;
  var annTextClip = fullLayout._topclips.selectAll('#' + annClipID).data(isSizeConstrained ? [0] : []);
  annTextClip.enter().append('clipPath').classed('annclip', true).attr('id', annClipID).append('rect');
  annTextClip.exit().remove();
  var font = options.font;
  var text = fullLayout._meta ? Lib.templateString(options.text, fullLayout._meta) : options.text;
  var annText = annTextGroupInner.append('text').classed('annotation-text', true).text(text);
  function textLayout(s) {
    s.call(Drawing.font, font).attr({
      'text-anchor': {
        left: 'start',
        right: 'end'
      }[options.align] || 'middle'
    });
    svgTextUtils.convertToTspans(s, gd, drawGraphicalElements);
    return s;
  }
  function drawGraphicalElements() {
    // if the text has *only* a link, make the whole box into a link
    var anchor3 = annText.selectAll('a');
    if (anchor3.size() === 1 && anchor3.text() === annText.text()) {
      var wholeLink = annTextGroupInner.insert('a', ':first-child').attr({
        'xlink:xlink:href': anchor3.attr('xlink:href'),
        'xlink:xlink:show': anchor3.attr('xlink:show')
      }).style({
        cursor: 'pointer'
      });
      wholeLink.node().appendChild(annTextBG.node());
    }
    var mathjaxGroup = annTextGroupInner.select('.annotation-text-math-group');
    var hasMathjax = !mathjaxGroup.empty();
    var anntextBB = Drawing.bBox((hasMathjax ? mathjaxGroup : annText).node());
    var textWidth = anntextBB.width;
    var textHeight = anntextBB.height;
    var annWidth = options.width || textWidth;
    var annHeight = options.height || textHeight;
    var outerWidth = Math.round(annWidth + 2 * borderfull);
    var outerHeight = Math.round(annHeight + 2 * borderfull);
    function shiftFraction(v, anchor) {
      if (anchor === 'auto') {
        if (v < 1 / 3) anchor = 'left';else if (v > 2 / 3) anchor = 'right';else anchor = 'center';
      }
      return {
        center: 0,
        middle: 0,
        left: 0.5,
        bottom: -0.5,
        right: -0.5,
        top: 0.5
      }[anchor];
    }
    var annotationIsOffscreen = false;
    var letters = ['x', 'y'];
    for (var i = 0; i < letters.length; i++) {
      var axLetter = letters[i];
      var axRef = options[axLetter + 'ref'] || axLetter;
      var tailRef = options['a' + axLetter + 'ref'];
      var ax = {
        x: xa,
        y: ya
      }[axLetter];
      var dimAngle = (textangle + (axLetter === 'x' ? 0 : -90)) * Math.PI / 180;
      // note that these two can be either positive or negative
      var annSizeFromWidth = outerWidth * Math.cos(dimAngle);
      var annSizeFromHeight = outerHeight * Math.sin(dimAngle);
      // but this one is the positive total size
      var annSize = Math.abs(annSizeFromWidth) + Math.abs(annSizeFromHeight);
      var anchor = options[axLetter + 'anchor'];
      var overallShift = options[axLetter + 'shift'] * (axLetter === 'x' ? 1 : -1);
      var posPx = annPosPx[axLetter];
      var basePx;
      var textPadShift;
      var alignPosition;
      var autoAlignFraction;
      var textShift;
      var axRefType = Axes.getRefType(axRef);

      /*
       * calculate the *primary* pixel position
       * which is the arrowhead if there is one,
       * otherwise the text anchor point
       */
      if (ax && axRefType !== 'domain') {
        // check if annotation is off screen, to bypass DOM manipulations
        var posFraction = ax.r2fraction(options[axLetter]);
        if (posFraction < 0 || posFraction > 1) {
          if (tailRef === axRef) {
            posFraction = ax.r2fraction(options['a' + axLetter]);
            if (posFraction < 0 || posFraction > 1) {
              annotationIsOffscreen = true;
            }
          } else {
            annotationIsOffscreen = true;
          }
        }
        basePx = ax._offset + ax.r2p(options[axLetter]);
        autoAlignFraction = 0.5;
      } else {
        var axRefTypeEqDomain = axRefType === 'domain';
        if (axLetter === 'x') {
          alignPosition = options[axLetter];
          basePx = axRefTypeEqDomain ? ax._offset + ax._length * alignPosition : basePx = gs.l + gs.w * alignPosition;
        } else {
          alignPosition = 1 - options[axLetter];
          basePx = axRefTypeEqDomain ? ax._offset + ax._length * alignPosition : basePx = gs.t + gs.h * alignPosition;
        }
        autoAlignFraction = options.showarrow ? 0.5 : alignPosition;
      }

      // now translate this into pixel positions of head, tail, and text
      // as well as paddings for autorange
      if (options.showarrow) {
        posPx.head = basePx;
        var arrowLength = options['a' + axLetter];

        // with an arrow, the text rotates around the anchor point
        textShift = annSizeFromWidth * shiftFraction(0.5, options.xanchor) - annSizeFromHeight * shiftFraction(0.5, options.yanchor);
        if (tailRef === axRef) {
          // In the case tailRefType is 'domain' or 'paper', the arrow's
          // position is set absolutely, which is consistent with how
          // it behaves when its position is set in data ('range')
          // coordinates.
          var tailRefType = Axes.getRefType(tailRef);
          if (tailRefType === 'domain') {
            if (axLetter === 'y') {
              arrowLength = 1 - arrowLength;
            }
            posPx.tail = ax._offset + ax._length * arrowLength;
          } else if (tailRefType === 'paper') {
            if (axLetter === 'y') {
              arrowLength = 1 - arrowLength;
              posPx.tail = gs.t + gs.h * arrowLength;
            } else {
              posPx.tail = gs.l + gs.w * arrowLength;
            }
          } else {
            // assumed tailRef is range or paper referenced
            posPx.tail = ax._offset + ax.r2p(arrowLength);
          }
          // tail is range- or domain-referenced: autorange pads the
          // text in px from the tail
          textPadShift = textShift;
        } else {
          posPx.tail = basePx + arrowLength;
          // tail is specified in px from head, so autorange also pads vs head
          textPadShift = textShift + arrowLength;
        }
        posPx.text = posPx.tail + textShift;

        // constrain pixel/paper referenced so the draggers are at least
        // partially visible
        var maxPx = fullLayout[axLetter === 'x' ? 'width' : 'height'];
        if (axRef === 'paper') {
          posPx.head = Lib.constrain(posPx.head, 1, maxPx - 1);
        }
        if (tailRef === 'pixel') {
          var shiftPlus = -Math.max(posPx.tail - 3, posPx.text);
          var shiftMinus = Math.min(posPx.tail + 3, posPx.text) - maxPx;
          if (shiftPlus > 0) {
            posPx.tail += shiftPlus;
            posPx.text += shiftPlus;
          } else if (shiftMinus > 0) {
            posPx.tail -= shiftMinus;
            posPx.text -= shiftMinus;
          }
        }
        posPx.tail += overallShift;
        posPx.head += overallShift;
      } else {
        // with no arrow, the text rotates and *then* we put the anchor
        // relative to the new bounding box
        textShift = annSize * shiftFraction(autoAlignFraction, anchor);
        textPadShift = textShift;
        posPx.text = basePx + textShift;
      }
      posPx.text += overallShift;
      textShift += overallShift;
      textPadShift += overallShift;

      // padplus/minus are used by autorange
      options['_' + axLetter + 'padplus'] = annSize / 2 + textPadShift;
      options['_' + axLetter + 'padminus'] = annSize / 2 - textPadShift;

      // size/shift are used during dragging
      options['_' + axLetter + 'size'] = annSize;
      options['_' + axLetter + 'shift'] = textShift;
    }
    if (annotationIsOffscreen) {
      annTextGroupInner.remove();
      return;
    }
    var xShift = 0;
    var yShift = 0;
    if (options.align !== 'left') {
      xShift = (annWidth - textWidth) * (options.align === 'center' ? 0.5 : 1);
    }
    if (options.valign !== 'top') {
      yShift = (annHeight - textHeight) * (options.valign === 'middle' ? 0.5 : 1);
    }
    if (hasMathjax) {
      mathjaxGroup.select('svg').attr({
        x: borderfull + xShift - 1,
        y: borderfull + yShift
      }).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);
    } else {
      var texty = borderfull + yShift - anntextBB.top;
      var textx = borderfull + xShift - anntextBB.left;
      annText.call(svgTextUtils.positionText, textx, texty).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);
    }
    annTextClip.select('rect').call(Drawing.setRect, borderfull, borderfull, annWidth, annHeight);
    annTextBG.call(Drawing.setRect, borderwidth / 2, borderwidth / 2, outerWidth - borderwidth, outerHeight - borderwidth);
    annTextGroupInner.call(Drawing.setTranslate, Math.round(annPosPx.x.text - outerWidth / 2), Math.round(annPosPx.y.text - outerHeight / 2));

    /*
     * rotate text and background
     * we already calculated the text center position *as rotated*
     * because we needed that for autoranging anyway, so now whether
     * we have an arrow or not, we rotate about the text center.
     */
    annTextGroup.attr({
      transform: 'rotate(' + textangle + ',' + annPosPx.x.text + ',' + annPosPx.y.text + ')'
    });

    /*
     * add the arrow
     * uses options[arrowwidth,arrowcolor,arrowhead] for styling
     * dx and dy are normally zero, but when you are dragging the textbox
     * while the head stays put, dx and dy are the pixel offsets
     */
    var drawArrow = function (dx, dy) {
      annGroup.selectAll('.annotation-arrow-g').remove();
      var headX = annPosPx.x.head;
      var headY = annPosPx.y.head;
      var tailX = annPosPx.x.tail + dx;
      var tailY = annPosPx.y.tail + dy;
      var textX = annPosPx.x.text + dx;
      var textY = annPosPx.y.text + dy;

      // find the edge of the text box, where we'll start the arrow:
      // create transform matrix to rotate the text box corners
      var transform = Lib.rotationXYMatrix(textangle, textX, textY);
      var applyTransform = Lib.apply2DTransform(transform);
      var applyTransform2 = Lib.apply2DTransform2(transform);

      // calculate and transform bounding box
      var width = +annTextBG.attr('width');
      var height = +annTextBG.attr('height');
      var xLeft = textX - 0.5 * width;
      var xRight = xLeft + width;
      var yTop = textY - 0.5 * height;
      var yBottom = yTop + height;
      var edges = [[xLeft, yTop, xLeft, yBottom], [xLeft, yBottom, xRight, yBottom], [xRight, yBottom, xRight, yTop], [xRight, yTop, xLeft, yTop]].map(applyTransform2);

      // Remove the line if it ends inside the box.  Use ray
      // casting for rotated boxes: see which edges intersect a
      // line from the arrowhead to far away and reduce with xor
      // to get the parity of the number of intersections.
      if (edges.reduce(function (a, x) {
        return a ^ !!Lib.segmentsIntersect(headX, headY, headX + 1e6, headY + 1e6, x[0], x[1], x[2], x[3]);
      }, false)) {
        // no line or arrow - so quit drawArrow now
        return;
      }
      edges.forEach(function (x) {
        var p = Lib.segmentsIntersect(tailX, tailY, headX, headY, x[0], x[1], x[2], x[3]);
        if (p) {
          tailX = p.x;
          tailY = p.y;
        }
      });
      var strokewidth = options.arrowwidth;
      var arrowColor = options.arrowcolor;
      var arrowSide = options.arrowside;
      var arrowGroup = annGroup.append('g').style({
        opacity: Color.opacity(arrowColor)
      }).classed('annotation-arrow-g', true);
      var arrow = arrowGroup.append('path').attr('d', 'M' + tailX + ',' + tailY + 'L' + headX + ',' + headY).style('stroke-width', strokewidth + 'px').call(Color.stroke, Color.rgb(arrowColor));
      drawArrowHead(arrow, arrowSide, options);

      // the arrow dragger is a small square right at the head, then a line to the tail,
      // all expanded by a stroke width of 6px plus the arrow line width
      if (edits.annotationPosition && arrow.node().parentNode && !subplotId) {
        var arrowDragHeadX = headX;
        var arrowDragHeadY = headY;
        if (options.standoff) {
          var arrowLength = Math.sqrt(Math.pow(headX - tailX, 2) + Math.pow(headY - tailY, 2));
          arrowDragHeadX += options.standoff * (tailX - headX) / arrowLength;
          arrowDragHeadY += options.standoff * (tailY - headY) / arrowLength;
        }
        var arrowDrag = arrowGroup.append('path').classed('annotation-arrow', true).classed('anndrag', true).classed('cursor-move', true).attr({
          d: 'M3,3H-3V-3H3ZM0,0L' + (tailX - arrowDragHeadX) + ',' + (tailY - arrowDragHeadY),
          transform: strTranslate(arrowDragHeadX, arrowDragHeadY)
        }).style('stroke-width', strokewidth + 6 + 'px').call(Color.stroke, 'rgba(0,0,0,0)').call(Color.fill, 'rgba(0,0,0,0)');
        var annx0, anny0;

        // dragger for the arrow & head: translates the whole thing
        // (head/tail/text) all together
        dragElement.init({
          element: arrowDrag.node(),
          gd: gd,
          prepFn: function () {
            var pos = Drawing.getTranslate(annTextGroupInner);
            annx0 = pos.x;
            anny0 = pos.y;
            if (xa && xa.autorange) {
              modifyBase(xa._name + '.autorange', true);
            }
            if (ya && ya.autorange) {
              modifyBase(ya._name + '.autorange', true);
            }
          },
          moveFn: function (dx, dy) {
            var annxy0 = applyTransform(annx0, anny0);
            var xcenter = annxy0[0] + dx;
            var ycenter = annxy0[1] + dy;
            annTextGroupInner.call(Drawing.setTranslate, xcenter, ycenter);
            modifyItem('x', shiftPosition(xa, dx, 'x', gs, options));
            modifyItem('y', shiftPosition(ya, dy, 'y', gs, options));

            // for these 2 calls to shiftPosition, it is assumed xa, ya are
            // defined, so gsDim will not be used, but we put it in
            // anyways for consistency
            if (options.axref === options.xref) {
              modifyItem('ax', shiftPosition(xa, dx, 'ax', gs, options));
            }
            if (options.ayref === options.yref) {
              modifyItem('ay', shiftPosition(ya, dy, 'ay', gs, options));
            }
            arrowGroup.attr('transform', strTranslate(dx, dy));
            annTextGroup.attr({
              transform: 'rotate(' + textangle + ',' + xcenter + ',' + ycenter + ')'
            });
          },
          doneFn: function () {
            Registry.call('_guiRelayout', gd, getUpdateObj());
            var notesBox = document.querySelector('.js-notes-box-panel');
            if (notesBox) notesBox.redraw(notesBox.selectedObj);
          }
        });
      }
    };
    if (options.showarrow) drawArrow(0, 0);

    // user dragging the annotation (text, not arrow)
    if (editTextPosition) {
      var baseTextTransform;

      // dragger for the textbox: if there's an arrow, just drag the
      // textbox and tail, leave the head untouched
      dragElement.init({
        element: annTextGroupInner.node(),
        gd: gd,
        prepFn: function () {
          baseTextTransform = annTextGroup.attr('transform');
        },
        moveFn: function (dx, dy) {
          var csr = 'pointer';
          if (options.showarrow) {
            // for these 2 calls to shiftPosition, it is assumed xa, ya are
            // defined, so gsDim will not be used, but we put it in
            // anyways for consistency
            if (options.axref === options.xref) {
              modifyItem('ax', shiftPosition(xa, dx, 'ax', gs, options));
            } else {
              modifyItem('ax', options.ax + dx);
            }
            if (options.ayref === options.yref) {
              modifyItem('ay', shiftPosition(ya, dy, 'ay', gs.w, options));
            } else {
              modifyItem('ay', options.ay + dy);
            }
            drawArrow(dx, dy);
          } else if (!subplotId) {
            var xUpdate, yUpdate;
            if (xa) {
              // shiftPosition will not execute code where xa was
              // undefined, so we use to calculate xUpdate too
              xUpdate = shiftPosition(xa, dx, 'x', gs, options);
            } else {
              var widthFraction = options._xsize / gs.w;
              var xLeft = options.x + (options._xshift - options.xshift) / gs.w - widthFraction / 2;
              xUpdate = dragElement.align(xLeft + dx / gs.w, widthFraction, 0, 1, options.xanchor);
            }
            if (ya) {
              // shiftPosition will not execute code where ya was
              // undefined, so we use to calculate yUpdate too
              yUpdate = shiftPosition(ya, dy, 'y', gs, options);
            } else {
              var heightFraction = options._ysize / gs.h;
              var yBottom = options.y - (options._yshift + options.yshift) / gs.h - heightFraction / 2;
              yUpdate = dragElement.align(yBottom - dy / gs.h, heightFraction, 0, 1, options.yanchor);
            }
            modifyItem('x', xUpdate);
            modifyItem('y', yUpdate);
            if (!xa || !ya) {
              csr = dragElement.getCursor(xa ? 0.5 : xUpdate, ya ? 0.5 : yUpdate, options.xanchor, options.yanchor);
            }
          } else return;
          annTextGroup.attr({
            transform: strTranslate(dx, dy) + baseTextTransform
          });
          setCursor(annTextGroupInner, csr);
        },
        clickFn: function (_, initialEvent) {
          if (options.captureevents) {
            gd.emit('plotly_clickannotation', makeEventData(initialEvent));
          }
        },
        doneFn: function () {
          setCursor(annTextGroupInner);
          Registry.call('_guiRelayout', gd, getUpdateObj());
          var notesBox = document.querySelector('.js-notes-box-panel');
          if (notesBox) notesBox.redraw(notesBox.selectedObj);
        }
      });
    }
  }
  if (edits.annotationText) {
    annText.call(svgTextUtils.makeEditable, {
      delegate: annTextGroupInner,
      gd: gd
    }).call(textLayout).on('edit', function (_text) {
      options.text = _text;
      this.call(textLayout);
      modifyItem('text', _text);
      if (xa && xa.autorange) {
        modifyBase(xa._name + '.autorange', true);
      }
      if (ya && ya.autorange) {
        modifyBase(ya._name + '.autorange', true);
      }
      Registry.call('_guiRelayout', gd, getUpdateObj());
    });
  } else annText.call(textLayout);
}

/***/ }),

/***/ 3011:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Color = __webpack_require__(7901);
var ARROWPATHS = __webpack_require__(2884);
var Lib = __webpack_require__(1828);
var strScale = Lib.strScale;
var strRotate = Lib.strRotate;
var strTranslate = Lib.strTranslate;

/**
 * Add arrowhead(s) to a path or line element
 *
 * @param {d3.selection} el3: a d3-selected line or path element
 *
 * @param {string} ends: 'none', 'start', 'end', or 'start+end' for which ends get arrowheads
 *
 * @param {object} options: style information. Must have all the following:
 * @param {number} options.arrowhead: end head style - see ./arrow_paths
 * @param {number} options.startarrowhead: start head style - see ./arrow_paths
 * @param {number} options.arrowsize: relative size of the end head vs line width
 * @param {number} options.startarrowsize: relative size of the start head vs line width
 * @param {number} options.standoff: distance in px to move the end arrow point from its target
 * @param {number} options.startstandoff: distance in px to move the start arrow point from its target
 * @param {number} options.arrowwidth: width of the arrow line
 * @param {string} options.arrowcolor: color of the arrow line, for the head to match
 *     Note that the opacity of this color is ignored, as it's assumed the container
 *     of both the line and head has opacity applied to it so there isn't greater opacity
 *     where they overlap.
 */
module.exports = function drawArrowHead(el3, ends, options) {
  var el = el3.node();
  var headStyle = ARROWPATHS[options.arrowhead || 0];
  var startHeadStyle = ARROWPATHS[options.startarrowhead || 0];
  var scale = (options.arrowwidth || 1) * (options.arrowsize || 1);
  var startScale = (options.arrowwidth || 1) * (options.startarrowsize || 1);
  var doStart = ends.indexOf('start') >= 0;
  var doEnd = ends.indexOf('end') >= 0;
  var backOff = headStyle.backoff * scale + options.standoff;
  var startBackOff = startHeadStyle.backoff * startScale + options.startstandoff;
  var start, end, startRot, endRot;
  if (el.nodeName === 'line') {
    start = {
      x: +el3.attr('x1'),
      y: +el3.attr('y1')
    };
    end = {
      x: +el3.attr('x2'),
      y: +el3.attr('y2')
    };
    var dx = start.x - end.x;
    var dy = start.y - end.y;
    startRot = Math.atan2(dy, dx);
    endRot = startRot + Math.PI;
    if (backOff && startBackOff) {
      if (backOff + startBackOff > Math.sqrt(dx * dx + dy * dy)) {
        hideLine();
        return;
      }
    }
    if (backOff) {
      if (backOff * backOff > dx * dx + dy * dy) {
        hideLine();
        return;
      }
      var backOffX = backOff * Math.cos(startRot);
      var backOffY = backOff * Math.sin(startRot);
      end.x += backOffX;
      end.y += backOffY;
      el3.attr({
        x2: end.x,
        y2: end.y
      });
    }
    if (startBackOff) {
      if (startBackOff * startBackOff > dx * dx + dy * dy) {
        hideLine();
        return;
      }
      var startBackOffX = startBackOff * Math.cos(startRot);
      var startbackOffY = startBackOff * Math.sin(startRot);
      start.x -= startBackOffX;
      start.y -= startbackOffY;
      el3.attr({
        x1: start.x,
        y1: start.y
      });
    }
  } else if (el.nodeName === 'path') {
    var pathlen = el.getTotalLength();
    // using dash to hide the backOff region of the path.
    // if we ever allow dash for the arrow we'll have to
    // do better than this hack... maybe just manually
    // combine the two
    var dashArray = '';
    if (pathlen < backOff + startBackOff) {
      hideLine();
      return;
    }
    var start0 = el.getPointAtLength(0);
    var dstart = el.getPointAtLength(0.1);
    startRot = Math.atan2(start0.y - dstart.y, start0.x - dstart.x);
    start = el.getPointAtLength(Math.min(startBackOff, pathlen));
    dashArray = '0px,' + startBackOff + 'px,';
    var end0 = el.getPointAtLength(pathlen);
    var dend = el.getPointAtLength(pathlen - 0.1);
    endRot = Math.atan2(end0.y - dend.y, end0.x - dend.x);
    end = el.getPointAtLength(Math.max(0, pathlen - backOff));
    var shortening = dashArray ? startBackOff + backOff : backOff;
    dashArray += pathlen - shortening + 'px,' + pathlen + 'px';
    el3.style('stroke-dasharray', dashArray);
  }
  function hideLine() {
    el3.style('stroke-dasharray', '0px,100px');
  }
  function drawhead(arrowHeadStyle, p, rot, arrowScale) {
    if (!arrowHeadStyle.path) return;
    if (arrowHeadStyle.noRotate) rot = 0;
    d3.select(el.parentNode).append('path').attr({
      class: el3.attr('class'),
      d: arrowHeadStyle.path,
      transform: strTranslate(p.x, p.y) + strRotate(rot * 180 / Math.PI) + strScale(arrowScale)
    }).style({
      fill: Color.rgb(options.arrowcolor),
      'stroke-width': 0
    });
  }
  if (doStart) drawhead(startHeadStyle, start, startRot, startScale);
  if (doEnd) drawhead(headStyle, end, endRot, scale);
};

/***/ }),

/***/ 2745:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var drawModule = __webpack_require__(2605);
var clickModule = __webpack_require__(4317);
module.exports = {
  moduleType: 'component',
  name: 'annotations',
  layoutAttributes: __webpack_require__(215),
  supplyLayoutDefaults: __webpack_require__(4046),
  includeBasePlot: __webpack_require__(6325)('annotations'),
  calcAutorange: __webpack_require__(3749),
  draw: drawModule.draw,
  drawOne: drawModule.drawOne,
  drawRaw: drawModule.drawRaw,
  hasClickToShow: clickModule.hasClickToShow,
  onClick: clickModule.onClick,
  convertCoords: __webpack_require__(4128)
};

/***/ }),

/***/ 6997:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var annAttrs = __webpack_require__(215);
var overrideAll = (__webpack_require__(962).overrideAll);
var templatedArray = (__webpack_require__(4467).templatedArray);
module.exports = overrideAll(templatedArray('annotation', {
  visible: annAttrs.visible,
  x: {
    valType: 'any'
  },
  y: {
    valType: 'any'
  },
  z: {
    valType: 'any'
  },
  ax: {
    valType: 'number'
  },
  ay: {
    valType: 'number'
  },
  xanchor: annAttrs.xanchor,
  xshift: annAttrs.xshift,
  yanchor: annAttrs.yanchor,
  yshift: annAttrs.yshift,
  text: annAttrs.text,
  textangle: annAttrs.textangle,
  font: annAttrs.font,
  width: annAttrs.width,
  height: annAttrs.height,
  opacity: annAttrs.opacity,
  align: annAttrs.align,
  valign: annAttrs.valign,
  bgcolor: annAttrs.bgcolor,
  bordercolor: annAttrs.bordercolor,
  borderpad: annAttrs.borderpad,
  borderwidth: annAttrs.borderwidth,
  showarrow: annAttrs.showarrow,
  arrowcolor: annAttrs.arrowcolor,
  arrowhead: annAttrs.arrowhead,
  startarrowhead: annAttrs.startarrowhead,
  arrowside: annAttrs.arrowside,
  arrowsize: annAttrs.arrowsize,
  startarrowsize: annAttrs.startarrowsize,
  arrowwidth: annAttrs.arrowwidth,
  standoff: annAttrs.standoff,
  startstandoff: annAttrs.startstandoff,
  hovertext: annAttrs.hovertext,
  hoverlabel: annAttrs.hoverlabel,
  captureevents: annAttrs.captureevents

  // maybes later?
  // clicktoshow: annAttrs.clicktoshow,
  // xclick: annAttrs.xclick,
  // yclick: annAttrs.yclick,

  // not needed!
  // axref: 'pixel'
  // ayref: 'pixel'
  // xref: 'x'
  // yref: 'y
  // zref: 'z'
}), 'calc', 'from-root');

/***/ }),

/***/ 5485:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Axes = __webpack_require__(9298);
module.exports = function convert(scene) {
  var fullSceneLayout = scene.fullSceneLayout;
  var anns = fullSceneLayout.annotations;
  for (var i = 0; i < anns.length; i++) {
    mockAnnAxes(anns[i], scene);
  }
  scene.fullLayout._infolayer.selectAll('.annotation-' + scene.id).remove();
};
function mockAnnAxes(ann, scene) {
  var fullSceneLayout = scene.fullSceneLayout;
  var domain = fullSceneLayout.domain;
  var size = scene.fullLayout._size;
  var base = {
    // this gets fill in on render
    pdata: null,
    // to get setConvert to not execute cleanly
    type: 'linear',
    // don't try to update them on `editable: true`
    autorange: false,
    // set infinite range so that annotation draw routine
    // does not try to remove 'outside-range' annotations,
    // this case is handled in the render loop
    range: [-Infinity, Infinity]
  };
  ann._xa = {};
  Lib.extendFlat(ann._xa, base);
  Axes.setConvert(ann._xa);
  ann._xa._offset = size.l + domain.x[0] * size.w;
  ann._xa.l2p = function () {
    return 0.5 * (1 + ann._pdata[0] / ann._pdata[3]) * size.w * (domain.x[1] - domain.x[0]);
  };
  ann._ya = {};
  Lib.extendFlat(ann._ya, base);
  Axes.setConvert(ann._ya);
  ann._ya._offset = size.t + (1 - domain.y[1]) * size.h;
  ann._ya.l2p = function () {
    return 0.5 * (1 - ann._pdata[1] / ann._pdata[3]) * size.h * (domain.y[1] - domain.y[0]);
  };
}

/***/ }),

/***/ 226:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Axes = __webpack_require__(9298);
var handleArrayContainerDefaults = __webpack_require__(5501);
var handleAnnotationCommonDefaults = __webpack_require__(5625);
var attributes = __webpack_require__(6997);
module.exports = function handleDefaults(sceneLayoutIn, sceneLayoutOut, opts) {
  handleArrayContainerDefaults(sceneLayoutIn, sceneLayoutOut, {
    name: 'annotations',
    handleItemDefaults: handleAnnotationDefaults,
    fullLayout: opts.fullLayout
  });
};
function handleAnnotationDefaults(annIn, annOut, sceneLayout, opts) {
  function coerce(attr, dflt) {
    return Lib.coerce(annIn, annOut, attributes, attr, dflt);
  }
  function coercePosition(axLetter) {
    var axName = axLetter + 'axis';

    // mock in such way that getFromId grabs correct 3D axis
    var gdMock = {
      _fullLayout: {}
    };
    gdMock._fullLayout[axName] = sceneLayout[axName];
    return Axes.coercePosition(annOut, gdMock, coerce, axLetter, axLetter, 0.5);
  }
  var visible = coerce('visible');
  if (!visible) return;
  handleAnnotationCommonDefaults(annIn, annOut, opts.fullLayout, coerce);
  coercePosition('x');
  coercePosition('y');
  coercePosition('z');

  // if you have one coordinate you should all three
  Lib.noneOrAll(annIn, annOut, ['x', 'y', 'z']);

  // hard-set here for completeness
  annOut.xref = 'x';
  annOut.yref = 'y';
  annOut.zref = 'z';
  coerce('xanchor');
  coerce('yanchor');
  coerce('xshift');
  coerce('yshift');
  if (annOut.showarrow) {
    annOut.axref = 'pixel';
    annOut.ayref = 'pixel';

    // TODO maybe default values should be bigger than the 2D case?
    coerce('ax', -10);
    coerce('ay', -30);

    // if you have one part of arrow length you should have both
    Lib.noneOrAll(annIn, annOut, ['ax', 'ay']);
  }
}

/***/ }),

/***/ 2188:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var drawRaw = (__webpack_require__(2605).drawRaw);
var project = __webpack_require__(3538);
var axLetters = ['x', 'y', 'z'];
module.exports = function draw(scene) {
  var fullSceneLayout = scene.fullSceneLayout;
  var dataScale = scene.dataScale;
  var anns = fullSceneLayout.annotations;
  for (var i = 0; i < anns.length; i++) {
    var ann = anns[i];
    var annotationIsOffscreen = false;
    for (var j = 0; j < 3; j++) {
      var axLetter = axLetters[j];
      var pos = ann[axLetter];
      var ax = fullSceneLayout[axLetter + 'axis'];
      var posFraction = ax.r2fraction(pos);
      if (posFraction < 0 || posFraction > 1) {
        annotationIsOffscreen = true;
        break;
      }
    }
    if (annotationIsOffscreen) {
      scene.fullLayout._infolayer.select('.annotation-' + scene.id + '[data-index="' + i + '"]').remove();
    } else {
      ann._pdata = project(scene.glplot.cameraParams, [fullSceneLayout.xaxis.r2l(ann.x) * dataScale[0], fullSceneLayout.yaxis.r2l(ann.y) * dataScale[1], fullSceneLayout.zaxis.r2l(ann.z) * dataScale[2]]);
      drawRaw(scene.graphDiv, ann, i, scene.id, ann._xa, ann._ya);
    }
  }
};

/***/ }),

/***/ 2468:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
module.exports = {
  moduleType: 'component',
  name: 'annotations3d',
  schema: {
    subplots: {
      scene: {
        annotations: __webpack_require__(6997)
      }
    }
  },
  layoutAttributes: __webpack_require__(6997),
  handleDefaults: __webpack_require__(226),
  includeBasePlot: includeGL3D,
  convert: __webpack_require__(5485),
  draw: __webpack_require__(2188)
};
function includeGL3D(layoutIn, layoutOut) {
  var GL3D = Registry.subplotsRegistry.gl3d;
  if (!GL3D) return;
  var attrRegex = GL3D.attrRegex;
  var keys = Object.keys(layoutIn);
  for (var i = 0; i < keys.length; i++) {
    var k = keys[i];
    if (attrRegex.test(k) && (layoutIn[k].annotations || []).length) {
      Lib.pushUnique(layoutOut._basePlotModules, GL3D);
      Lib.pushUnique(layoutOut._subplots.gl3d, k);
    }
  }
}

/***/ }),

/***/ 7561:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


// a trimmed down version of:
// https://github.com/alexcjohnson/world-calendars/blob/master/dist/index.js
module.exports = __webpack_require__(3489);
__webpack_require__(4338);
__webpack_require__(3961);
__webpack_require__(8751);
__webpack_require__(6825);
__webpack_require__(7715);
__webpack_require__(9384);
__webpack_require__(3805);
__webpack_require__(8874);
__webpack_require__(3290);
__webpack_require__(9108);
__webpack_require__(5422);
__webpack_require__(4320);
__webpack_require__(1320);
__webpack_require__(1367);
__webpack_require__(1457);

/***/ }),

/***/ 2201:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var calendars = __webpack_require__(7561);
var Lib = __webpack_require__(1828);
var constants = __webpack_require__(606);
var EPOCHJD = constants.EPOCHJD;
var ONEDAY = constants.ONEDAY;
var attributes = {
  valType: 'enumerated',
  values: Lib.sortObjectKeys(calendars.calendars),
  editType: 'calc',
  dflt: 'gregorian'
};
var handleDefaults = function (contIn, contOut, attr, dflt) {
  var attrs = {};
  attrs[attr] = attributes;
  return Lib.coerce(contIn, contOut, attrs, attr, dflt);
};
var handleTraceDefaults = function (traceIn, traceOut, coords, layout) {
  for (var i = 0; i < coords.length; i++) {
    handleDefaults(traceIn, traceOut, coords[i] + 'calendar', layout.calendar);
  }
};

// each calendar needs its own default canonical tick. I would love to use
// 2000-01-01 (or even 0000-01-01) for them all but they don't necessarily
// all support either of those dates. Instead I'll use the most significant
// number they *do* support, biased toward the present day.
var CANONICAL_TICK = {
  chinese: '2000-01-01',
  coptic: '2000-01-01',
  discworld: '2000-01-01',
  ethiopian: '2000-01-01',
  hebrew: '5000-01-01',
  islamic: '1000-01-01',
  julian: '2000-01-01',
  mayan: '5000-01-01',
  nanakshahi: '1000-01-01',
  nepali: '2000-01-01',
  persian: '1000-01-01',
  jalali: '1000-01-01',
  taiwan: '1000-01-01',
  thai: '2000-01-01',
  ummalqura: '1400-01-01'
};

// Start on a Sunday - for week ticks
// Discworld and Mayan calendars don't have 7-day weeks but we're going to give them
// 7-day week ticks so start on our Sundays.
// If anyone really cares we can customize the auto tick spacings for these calendars.
var CANONICAL_SUNDAY = {
  chinese: '2000-01-02',
  coptic: '2000-01-03',
  discworld: '2000-01-03',
  ethiopian: '2000-01-05',
  hebrew: '5000-01-01',
  islamic: '1000-01-02',
  julian: '2000-01-03',
  mayan: '5000-01-01',
  nanakshahi: '1000-01-05',
  nepali: '2000-01-05',
  persian: '1000-01-01',
  jalali: '1000-01-01',
  taiwan: '1000-01-04',
  thai: '2000-01-04',
  ummalqura: '1400-01-06'
};
var DFLTRANGE = {
  chinese: ['2000-01-01', '2001-01-01'],
  coptic: ['1700-01-01', '1701-01-01'],
  discworld: ['1800-01-01', '1801-01-01'],
  ethiopian: ['2000-01-01', '2001-01-01'],
  hebrew: ['5700-01-01', '5701-01-01'],
  islamic: ['1400-01-01', '1401-01-01'],
  julian: ['2000-01-01', '2001-01-01'],
  mayan: ['5200-01-01', '5201-01-01'],
  nanakshahi: ['0500-01-01', '0501-01-01'],
  nepali: ['2000-01-01', '2001-01-01'],
  persian: ['1400-01-01', '1401-01-01'],
  jalali: ['1400-01-01', '1401-01-01'],
  taiwan: ['0100-01-01', '0101-01-01'],
  thai: ['2500-01-01', '2501-01-01'],
  ummalqura: ['1400-01-01', '1401-01-01']
};

/*
 * convert d3 templates to world-calendars templates, so our users only need
 * to know d3's specifiers. Map space padding to no padding, and unknown fields
 * to an ugly placeholder
 */
var UNKNOWN = '##';
var d3ToWorldCalendars = {
  d: {
    0: 'dd',
    '-': 'd'
  },
  // 2-digit or unpadded day of month
  e: {
    0: 'd',
    '-': 'd'
  },
  // alternate, always unpadded day of month
  a: {
    0: 'D',
    '-': 'D'
  },
  // short weekday name
  A: {
    0: 'DD',
    '-': 'DD'
  },
  // full weekday name
  j: {
    0: 'oo',
    '-': 'o'
  },
  // 3-digit or unpadded day of the year
  W: {
    0: 'ww',
    '-': 'w'
  },
  // 2-digit or unpadded week of the year (Monday first)
  m: {
    0: 'mm',
    '-': 'm'
  },
  // 2-digit or unpadded month number
  b: {
    0: 'M',
    '-': 'M'
  },
  // short month name
  B: {
    0: 'MM',
    '-': 'MM'
  },
  // full month name
  y: {
    0: 'yy',
    '-': 'yy'
  },
  // 2-digit year (map unpadded to zero-padded)
  Y: {
    0: 'yyyy',
    '-': 'yyyy'
  },
  // 4-digit year (map unpadded to zero-padded)
  U: UNKNOWN,
  // Sunday-first week of the year
  w: UNKNOWN,
  // day of the week [0(sunday),6]
  // combined format, we replace the date part with the world-calendar version
  // and the %X stays there for d3 to handle with time parts
  c: {
    0: 'D M d %X yyyy',
    '-': 'D M d %X yyyy'
  },
  x: {
    0: 'mm/dd/yyyy',
    '-': 'mm/dd/yyyy'
  }
};
function worldCalFmt(fmt, x, calendar) {
  var dateJD = Math.floor((x + 0.05) / ONEDAY) + EPOCHJD;
  var cDate = getCal(calendar).fromJD(dateJD);
  var i = 0;
  var modifier, directive, directiveLen, directiveObj, replacementPart;
  while ((i = fmt.indexOf('%', i)) !== -1) {
    modifier = fmt.charAt(i + 1);
    if (modifier === '0' || modifier === '-' || modifier === '_') {
      directiveLen = 3;
      directive = fmt.charAt(i + 2);
      if (modifier === '_') modifier = '-';
    } else {
      directive = modifier;
      modifier = '0';
      directiveLen = 2;
    }
    directiveObj = d3ToWorldCalendars[directive];
    if (!directiveObj) {
      i += directiveLen;
    } else {
      // code is recognized as a date part but world-calendars doesn't support it
      if (directiveObj === UNKNOWN) replacementPart = UNKNOWN;

      // format the cDate according to the translated directive
      else replacementPart = cDate.formatDate(directiveObj[modifier]);
      fmt = fmt.substr(0, i) + replacementPart + fmt.substr(i + directiveLen);
      i += replacementPart.length;
    }
  }
  return fmt;
}

// cache world calendars, so we don't have to reinstantiate
// during each date-time conversion
var allCals = {};
function getCal(calendar) {
  var calendarObj = allCals[calendar];
  if (calendarObj) return calendarObj;
  calendarObj = allCals[calendar] = calendars.instance(calendar);
  return calendarObj;
}
function makeAttrs(description) {
  return Lib.extendFlat({}, attributes, {
    description: description
  });
}
function makeTraceAttrsDescription(coord) {
  return 'Sets the calendar system to use with `' + coord + '` date data.';
}
var xAttrs = {
  xcalendar: makeAttrs(makeTraceAttrsDescription('x'))
};
var xyAttrs = Lib.extendFlat({}, xAttrs, {
  ycalendar: makeAttrs(makeTraceAttrsDescription('y'))
});
var xyzAttrs = Lib.extendFlat({}, xyAttrs, {
  zcalendar: makeAttrs(makeTraceAttrsDescription('z'))
});
var axisAttrs = makeAttrs(['Sets the calendar system to use for `range` and `tick0`', 'if this is a date axis. This does not set the calendar for', 'interpreting data on this axis, that\'s specified in the trace', 'or via the global `layout.calendar`'].join(' '));
module.exports = {
  moduleType: 'component',
  name: 'calendars',
  schema: {
    traces: {
      scatter: xyAttrs,
      bar: xyAttrs,
      box: xyAttrs,
      heatmap: xyAttrs,
      contour: xyAttrs,
      histogram: xyAttrs,
      histogram2d: xyAttrs,
      histogram2dcontour: xyAttrs,
      scatter3d: xyzAttrs,
      surface: xyzAttrs,
      mesh3d: xyzAttrs,
      scattergl: xyAttrs,
      ohlc: xAttrs,
      candlestick: xAttrs
    },
    layout: {
      calendar: makeAttrs(['Sets the default calendar system to use for interpreting and', 'displaying dates throughout the plot.'].join(' '))
    },
    subplots: {
      xaxis: {
        calendar: axisAttrs
      },
      yaxis: {
        calendar: axisAttrs
      },
      scene: {
        xaxis: {
          calendar: axisAttrs
        },
        // TODO: it's actually redundant to include yaxis and zaxis here
        // because in the scene attributes these are the same object so merging
        // into one merges into them all. However, I left them in for parity with
        // cartesian, where yaxis is unused until we Plotschema.get() when we
        // use its presence or absence to determine whether to delete attributes
        // from yaxis if they only apply to x (rangeselector/rangeslider)
        yaxis: {
          calendar: axisAttrs
        },
        zaxis: {
          calendar: axisAttrs
        }
      },
      polar: {
        radialaxis: {
          calendar: axisAttrs
        }
      }
    },
    transforms: {
      filter: {
        valuecalendar: makeAttrs(['WARNING: All transforms are deprecated and may be removed from the API in next major version.', 'Sets the calendar system to use for `value`, if it is a date.'].join(' ')),
        targetcalendar: makeAttrs(['WARNING: All transforms are deprecated and may be removed from the API in next major version.', 'Sets the calendar system to use for `target`, if it is an', 'array of dates. If `target` is a string (eg *x*) we use the', 'corresponding trace attribute (eg `xcalendar`) if it exists,', 'even if `targetcalendar` is provided.'].join(' '))
      }
    }
  },
  layoutAttributes: attributes,
  handleDefaults: handleDefaults,
  handleTraceDefaults: handleTraceDefaults,
  CANONICAL_SUNDAY: CANONICAL_SUNDAY,
  CANONICAL_TICK: CANONICAL_TICK,
  DFLTRANGE: DFLTRANGE,
  getCal: getCal,
  worldCalFmt: worldCalFmt
};

/***/ }),

/***/ 2399:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


// IMPORTANT - default colors should be in hex for compatibility
exports.defaults = ['#1f77b4',
// muted blue
'#ff7f0e',
// safety orange
'#2ca02c',
// cooked asparagus green
'#d62728',
// brick red
'#9467bd',
// muted purple
'#8c564b',
// chestnut brown
'#e377c2',
// raspberry yogurt pink
'#7f7f7f',
// middle gray
'#bcbd22',
// curry yellow-green
'#17becf' // blue-teal
];

exports.defaultLine = '#444';
exports.lightLine = '#eee';
exports.background = '#fff';
exports.borderLine = '#BEC8D9';

// with axis.color and Color.interp we aren't using lightLine
// itself anymore, instead interpolating between axis.color
// and the background color using tinycolor.mix. lightFraction
// gives back exactly lightLine if the other colors are defaults.
exports.lightFraction = 100 * (0xe - 0x4) / (0xf - 0x4);

/***/ }),

/***/ 7901:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var tinycolor = __webpack_require__(4267);
var isNumeric = __webpack_require__(2770);
var isTypedArray = (__webpack_require__(3627).isTypedArray);
var color = module.exports = {};
var colorAttrs = __webpack_require__(2399);
color.defaults = colorAttrs.defaults;
var defaultLine = color.defaultLine = colorAttrs.defaultLine;
color.lightLine = colorAttrs.lightLine;
var background = color.background = colorAttrs.background;

/*
 * tinyRGB: turn a tinycolor into an rgb string, but
 * unlike the built-in tinycolor.toRgbString this never includes alpha
 */
color.tinyRGB = function (tc) {
  var c = tc.toRgb();
  return 'rgb(' + Math.round(c.r) + ', ' + Math.round(c.g) + ', ' + Math.round(c.b) + ')';
};
color.rgb = function (cstr) {
  return color.tinyRGB(tinycolor(cstr));
};
color.opacity = function (cstr) {
  return cstr ? tinycolor(cstr).getAlpha() : 0;
};
color.addOpacity = function (cstr, op) {
  var c = tinycolor(cstr).toRgb();
  return 'rgba(' + Math.round(c.r) + ', ' + Math.round(c.g) + ', ' + Math.round(c.b) + ', ' + op + ')';
};

// combine two colors into one apparent color
// if back has transparency or is missing,
// color.background is assumed behind it
color.combine = function (front, back) {
  var fc = tinycolor(front).toRgb();
  if (fc.a === 1) return tinycolor(front).toRgbString();
  var bc = tinycolor(back || background).toRgb();
  var bcflat = bc.a === 1 ? bc : {
    r: 255 * (1 - bc.a) + bc.r * bc.a,
    g: 255 * (1 - bc.a) + bc.g * bc.a,
    b: 255 * (1 - bc.a) + bc.b * bc.a
  };
  var fcflat = {
    r: bcflat.r * (1 - fc.a) + fc.r * fc.a,
    g: bcflat.g * (1 - fc.a) + fc.g * fc.a,
    b: bcflat.b * (1 - fc.a) + fc.b * fc.a
  };
  return tinycolor(fcflat).toRgbString();
};

/*
 * Create a color that contrasts with cstr.
 *
 * If cstr is a dark color, we lighten it; if it's light, we darken.
 *
 * If lightAmount / darkAmount are used, we adjust by these percentages,
 * otherwise we go all the way to white or black.
 */
color.contrast = function (cstr, lightAmount, darkAmount) {
  var tc = tinycolor(cstr);
  if (tc.getAlpha() !== 1) tc = tinycolor(color.combine(cstr, background));
  var newColor = tc.isDark() ? lightAmount ? tc.lighten(lightAmount) : background : darkAmount ? tc.darken(darkAmount) : defaultLine;
  return newColor.toString();
};
color.stroke = function (s, c) {
  var tc = tinycolor(c);
  s.style({
    stroke: color.tinyRGB(tc),
    'stroke-opacity': tc.getAlpha()
  });
};
color.fill = function (s, c) {
  var tc = tinycolor(c);
  s.style({
    fill: color.tinyRGB(tc),
    'fill-opacity': tc.getAlpha()
  });
};

// search container for colors with the deprecated rgb(fractions) format
// and convert them to rgb(0-255 values)
color.clean = function (container) {
  if (!container || typeof container !== 'object') return;
  var keys = Object.keys(container);
  var i, j, key, val;
  for (i = 0; i < keys.length; i++) {
    key = keys[i];
    val = container[key];
    if (key.substr(key.length - 5) === 'color') {
      // only sanitize keys that end in "color" or "colorscale"

      if (Array.isArray(val)) {
        for (j = 0; j < val.length; j++) val[j] = cleanOne(val[j]);
      } else container[key] = cleanOne(val);
    } else if (key.substr(key.length - 10) === 'colorscale' && Array.isArray(val)) {
      // colorscales have the format [[0, color1], [frac, color2], ... [1, colorN]]

      for (j = 0; j < val.length; j++) {
        if (Array.isArray(val[j])) val[j][1] = cleanOne(val[j][1]);
      }
    } else if (Array.isArray(val)) {
      // recurse into arrays of objects, and plain objects

      var el0 = val[0];
      if (!Array.isArray(el0) && el0 && typeof el0 === 'object') {
        for (j = 0; j < val.length; j++) color.clean(val[j]);
      }
    } else if (val && typeof val === 'object' && !isTypedArray(val)) color.clean(val);
  }
};
function cleanOne(val) {
  if (isNumeric(val) || typeof val !== 'string') return val;
  var valTrim = val.trim();
  if (valTrim.substr(0, 3) !== 'rgb') return val;
  var match = valTrim.match(/^rgba?\s*\(([^()]*)\)$/);
  if (!match) return val;
  var parts = match[1].trim().split(/\s*[\s,]\s*/);
  var rgba = valTrim.charAt(3) === 'a' && parts.length === 4;
  if (!rgba && parts.length !== 3) return val;
  for (var i = 0; i < parts.length; i++) {
    if (!parts[i].length) return val;
    parts[i] = Number(parts[i]);
    if (!(parts[i] >= 0)) {
      // all parts must be non-negative numbers

      return val;
    }
    if (i === 3) {
      // alpha>1 gets clipped to 1

      if (parts[i] > 1) parts[i] = 1;
    } else if (parts[i] >= 1) {
      // r, g, b must be < 1 (ie 1 itself is not allowed)

      return val;
    }
  }
  var rgbStr = Math.round(parts[0] * 255) + ', ' + Math.round(parts[1] * 255) + ', ' + Math.round(parts[2] * 255);
  if (rgba) return 'rgba(' + rgbStr + ', ' + parts[3] + ')';
  return 'rgb(' + rgbStr + ')';
}

/***/ }),

/***/ 3583:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var axesAttrs = __webpack_require__(3838);
var fontAttrs = __webpack_require__(1940);
var extendFlat = (__webpack_require__(1426).extendFlat);
var overrideAll = (__webpack_require__(962).overrideAll);
module.exports = overrideAll({
  orientation: {
    valType: 'enumerated',
    values: ['h', 'v'],
    dflt: 'v'
  },
  thicknessmode: {
    valType: 'enumerated',
    values: ['fraction', 'pixels'],
    dflt: 'pixels'
  },
  thickness: {
    valType: 'number',
    min: 0,
    dflt: 30
  },
  lenmode: {
    valType: 'enumerated',
    values: ['fraction', 'pixels'],
    dflt: 'fraction'
  },
  len: {
    valType: 'number',
    min: 0,
    dflt: 1
  },
  x: {
    valType: 'number'
  },
  xref: {
    valType: 'enumerated',
    dflt: 'paper',
    values: ['container', 'paper'],
    editType: 'layoutstyle'
  },
  xanchor: {
    valType: 'enumerated',
    values: ['left', 'center', 'right']
  },
  xpad: {
    valType: 'number',
    min: 0,
    dflt: 10
  },
  y: {
    valType: 'number'
  },
  yref: {
    valType: 'enumerated',
    dflt: 'paper',
    values: ['container', 'paper'],
    editType: 'layoutstyle'
  },
  yanchor: {
    valType: 'enumerated',
    values: ['top', 'middle', 'bottom']
  },
  ypad: {
    valType: 'number',
    min: 0,
    dflt: 10
  },
  // a possible line around the bar itself
  outlinecolor: axesAttrs.linecolor,
  outlinewidth: axesAttrs.linewidth,
  // Should outlinewidth have {dflt: 0} ?
  // another possible line outside the padding and tick labels
  bordercolor: axesAttrs.linecolor,
  borderwidth: {
    valType: 'number',
    min: 0,
    dflt: 0
  },
  bgcolor: {
    valType: 'color',
    dflt: 'rgba(0,0,0,0)'
  },
  // tick and title properties named and function exactly as in axes
  tickmode: axesAttrs.minor.tickmode,
  nticks: axesAttrs.nticks,
  tick0: axesAttrs.tick0,
  dtick: axesAttrs.dtick,
  tickvals: axesAttrs.tickvals,
  ticktext: axesAttrs.ticktext,
  ticks: extendFlat({}, axesAttrs.ticks, {
    dflt: ''
  }),
  ticklabeloverflow: extendFlat({}, axesAttrs.ticklabeloverflow, {}),
  // ticklabelposition: not used directly, as values depend on orientation
  // left/right options are for x axes, and top/bottom options are for y axes
  ticklabelposition: {
    valType: 'enumerated',
    values: ['outside', 'inside', 'outside top', 'inside top', 'outside left', 'inside left', 'outside right', 'inside right', 'outside bottom', 'inside bottom'],
    dflt: 'outside'
  },
  ticklen: axesAttrs.ticklen,
  tickwidth: axesAttrs.tickwidth,
  tickcolor: axesAttrs.tickcolor,
  ticklabelstep: axesAttrs.ticklabelstep,
  showticklabels: axesAttrs.showticklabels,
  labelalias: axesAttrs.labelalias,
  tickfont: fontAttrs({}),
  tickangle: axesAttrs.tickangle,
  tickformat: axesAttrs.tickformat,
  tickformatstops: axesAttrs.tickformatstops,
  tickprefix: axesAttrs.tickprefix,
  showtickprefix: axesAttrs.showtickprefix,
  ticksuffix: axesAttrs.ticksuffix,
  showticksuffix: axesAttrs.showticksuffix,
  separatethousands: axesAttrs.separatethousands,
  exponentformat: axesAttrs.exponentformat,
  minexponent: axesAttrs.minexponent,
  showexponent: axesAttrs.showexponent,
  title: {
    text: {
      valType: 'string'
    },
    font: fontAttrs({}),
    side: {
      valType: 'enumerated',
      values: ['right', 'top', 'bottom']
    }
  },
  _deprecated: {
    title: {
      valType: 'string'
    },
    titlefont: fontAttrs({}),
    titleside: {
      valType: 'enumerated',
      values: ['right', 'top', 'bottom'],
      dflt: 'top'
    }
  }
}, 'colorbars', 'from-root');

/***/ }),

/***/ 939:
/***/ (function(module) {

"use strict";


module.exports = {
  cn: {
    colorbar: 'colorbar',
    cbbg: 'cbbg',
    cbfill: 'cbfill',
    cbfills: 'cbfills',
    cbline: 'cbline',
    cblines: 'cblines',
    cbaxis: 'cbaxis',
    cbtitleunshift: 'cbtitleunshift',
    cbtitle: 'cbtitle',
    cboutline: 'cboutline',
    crisp: 'crisp',
    jsPlaceholder: 'js-placeholder'
  }
};

/***/ }),

/***/ 2499:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Template = __webpack_require__(4467);
var handleTickValueDefaults = __webpack_require__(6218);
var handleTickMarkDefaults = __webpack_require__(8701);
var handleTickLabelDefaults = __webpack_require__(6115);
var handlePrefixSuffixDefaults = __webpack_require__(9426);
var attributes = __webpack_require__(3583);
module.exports = function colorbarDefaults(containerIn, containerOut, layout) {
  var colorbarOut = Template.newContainer(containerOut, 'colorbar');
  var colorbarIn = containerIn.colorbar || {};
  function coerce(attr, dflt) {
    return Lib.coerce(colorbarIn, colorbarOut, attributes, attr, dflt);
  }
  var margin = layout.margin || {
    t: 0,
    b: 0,
    l: 0,
    r: 0
  };
  var w = layout.width - margin.l - margin.r;
  var h = layout.height - margin.t - margin.b;
  var orientation = coerce('orientation');
  var isVertical = orientation === 'v';
  var thicknessmode = coerce('thicknessmode');
  coerce('thickness', thicknessmode === 'fraction' ? 30 / (isVertical ? w : h) : 30);
  var lenmode = coerce('lenmode');
  coerce('len', lenmode === 'fraction' ? 1 : isVertical ? h : w);
  var yref = coerce('yref');
  var xref = coerce('xref');
  var isPaperY = yref === 'paper';
  var isPaperX = xref === 'paper';
  var defaultX, defaultY, defaultYAnchor;
  var defaultXAnchor = 'left';
  if (isVertical) {
    defaultYAnchor = 'middle';
    defaultXAnchor = isPaperX ? 'left' : 'right';
    defaultX = isPaperX ? 1.02 : 1;
    defaultY = 0.5;
  } else {
    defaultYAnchor = isPaperY ? 'bottom' : 'top';
    defaultXAnchor = 'center';
    defaultX = 0.5;
    defaultY = isPaperY ? 1.02 : 1;
  }
  Lib.coerce(colorbarIn, colorbarOut, {
    x: {
      valType: 'number',
      min: isPaperX ? -2 : 0,
      max: isPaperX ? 3 : 1,
      dflt: defaultX
    }
  }, 'x');
  Lib.coerce(colorbarIn, colorbarOut, {
    y: {
      valType: 'number',
      min: isPaperY ? -2 : 0,
      max: isPaperY ? 3 : 1,
      dflt: defaultY
    }
  }, 'y');
  coerce('xanchor', defaultXAnchor);
  coerce('xpad');
  coerce('yanchor', defaultYAnchor);
  coerce('ypad');
  Lib.noneOrAll(colorbarIn, colorbarOut, ['x', 'y']);
  coerce('outlinecolor');
  coerce('outlinewidth');
  coerce('bordercolor');
  coerce('borderwidth');
  coerce('bgcolor');
  var ticklabelposition = Lib.coerce(colorbarIn, colorbarOut, {
    ticklabelposition: {
      valType: 'enumerated',
      dflt: 'outside',
      values: isVertical ? ['outside', 'inside', 'outside top', 'inside top', 'outside bottom', 'inside bottom'] : ['outside', 'inside', 'outside left', 'inside left', 'outside right', 'inside right']
    }
  }, 'ticklabelposition');
  coerce('ticklabeloverflow', ticklabelposition.indexOf('inside') !== -1 ? 'hide past domain' : 'hide past div');
  handleTickValueDefaults(colorbarIn, colorbarOut, coerce, 'linear');
  var font = layout.font;
  var opts = {
    outerTicks: false,
    font: font
  };
  if (ticklabelposition.indexOf('inside') !== -1) {
    opts.bgColor = 'black'; // could we instead use the average of colors in the scale?
  }

  handlePrefixSuffixDefaults(colorbarIn, colorbarOut, coerce, 'linear', opts);
  handleTickLabelDefaults(colorbarIn, colorbarOut, coerce, 'linear', opts);
  handleTickMarkDefaults(colorbarIn, colorbarOut, coerce, 'linear', opts);
  coerce('title.text', layout._dfltTitle.colorbar);
  var tickFont = colorbarOut.showticklabels ? colorbarOut.tickfont : font;
  var dfltTitleFont = Lib.extendFlat({}, tickFont, {
    color: font.color,
    size: Lib.bigFont(tickFont.size)
  });
  Lib.coerceFont(coerce, 'title.font', dfltTitleFont);
  coerce('title.side', isVertical ? 'top' : 'right');
};

/***/ }),

/***/ 8981:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var tinycolor = __webpack_require__(4267);
var Plots = __webpack_require__(4875);
var Registry = __webpack_require__(3972);
var Axes = __webpack_require__(9298);
var dragElement = __webpack_require__(8569);
var Lib = __webpack_require__(1828);
var strTranslate = Lib.strTranslate;
var extendFlat = (__webpack_require__(1426).extendFlat);
var setCursor = __webpack_require__(6964);
var Drawing = __webpack_require__(1424);
var Color = __webpack_require__(7901);
var Titles = __webpack_require__(2998);
var svgTextUtils = __webpack_require__(3893);
var flipScale = (__webpack_require__(2869).flipScale);
var handleAxisDefaults = __webpack_require__(1453);
var handleAxisPositionDefaults = __webpack_require__(2830);
var axisLayoutAttrs = __webpack_require__(3838);
var alignmentConstants = __webpack_require__(8783);
var LINE_SPACING = alignmentConstants.LINE_SPACING;
var FROM_TL = alignmentConstants.FROM_TL;
var FROM_BR = alignmentConstants.FROM_BR;
var cn = (__webpack_require__(939).cn);
function draw(gd) {
  var fullLayout = gd._fullLayout;
  var colorBars = fullLayout._infolayer.selectAll('g.' + cn.colorbar).data(makeColorBarData(gd), function (opts) {
    return opts._id;
  });
  colorBars.enter().append('g').attr('class', function (opts) {
    return opts._id;
  }).classed(cn.colorbar, true);
  colorBars.each(function (opts) {
    var g = d3.select(this);
    Lib.ensureSingle(g, 'rect', cn.cbbg);
    Lib.ensureSingle(g, 'g', cn.cbfills);
    Lib.ensureSingle(g, 'g', cn.cblines);
    Lib.ensureSingle(g, 'g', cn.cbaxis, function (s) {
      s.classed(cn.crisp, true);
    });
    Lib.ensureSingle(g, 'g', cn.cbtitleunshift, function (s) {
      s.append('g').classed(cn.cbtitle, true);
    });
    Lib.ensureSingle(g, 'rect', cn.cboutline);
    var done = drawColorBar(g, opts, gd);
    if (done && done.then) (gd._promises || []).push(done);
    if (gd._context.edits.colorbarPosition) {
      makeEditable(g, opts, gd);
    }
  });
  colorBars.exit().each(function (opts) {
    Plots.autoMargin(gd, opts._id);
  }).remove();
  colorBars.order();
}
function makeColorBarData(gd) {
  var fullLayout = gd._fullLayout;
  var calcdata = gd.calcdata;
  var out = [];

  // single out item
  var opts;
  // colorbar attr parent container
  var cont;
  // trace attr container
  var trace;
  // colorbar options
  var cbOpt;
  function initOpts(opts) {
    return extendFlat(opts, {
      // fillcolor can be a d3 scale, domain is z values, range is colors
      // or leave it out for no fill,
      // or set to a string constant for single-color fill
      _fillcolor: null,
      // line.color has the same options as fillcolor
      _line: {
        color: null,
        width: null,
        dash: null
      },
      // levels of lines to draw.
      // note that this DOES NOT determine the extent of the bar
      // that's given by the domain of fillcolor
      // (or line.color if no fillcolor domain)
      _levels: {
        start: null,
        end: null,
        size: null
      },
      // separate fill levels (for example, heatmap coloring of a
      // contour map) if this is omitted, fillcolors will be
      // evaluated halfway between levels
      _filllevels: null,
      // for continuous colorscales: fill with a gradient instead of explicit levels
      // value should be the colorscale [[0, c0], [v1, c1], ..., [1, cEnd]]
      _fillgradient: null,
      // when using a gradient, we need the data range specified separately
      _zrange: null
    });
  }
  function calcOpts() {
    if (typeof cbOpt.calc === 'function') {
      cbOpt.calc(gd, trace, opts);
    } else {
      opts._fillgradient = cont.reversescale ? flipScale(cont.colorscale) : cont.colorscale;
      opts._zrange = [cont[cbOpt.min], cont[cbOpt.max]];
    }
  }
  for (var i = 0; i < calcdata.length; i++) {
    var cd = calcdata[i];
    trace = cd[0].trace;
    if (!trace._module) continue;
    var moduleOpts = trace._module.colorbar;
    if (trace.visible === true && moduleOpts) {
      var allowsMultiplotCbs = Array.isArray(moduleOpts);
      var cbOpts = allowsMultiplotCbs ? moduleOpts : [moduleOpts];
      for (var j = 0; j < cbOpts.length; j++) {
        cbOpt = cbOpts[j];
        var contName = cbOpt.container;
        cont = contName ? trace[contName] : trace;
        if (cont && cont.showscale) {
          opts = initOpts(cont.colorbar);
          opts._id = 'cb' + trace.uid + (allowsMultiplotCbs && contName ? '-' + contName : '');
          opts._traceIndex = trace.index;
          opts._propPrefix = (contName ? contName + '.' : '') + 'colorbar.';
          opts._meta = trace._meta;
          calcOpts();
          out.push(opts);
        }
      }
    }
  }
  for (var k in fullLayout._colorAxes) {
    cont = fullLayout[k];
    if (cont.showscale) {
      var colorAxOpts = fullLayout._colorAxes[k];
      opts = initOpts(cont.colorbar);
      opts._id = 'cb' + k;
      opts._propPrefix = k + '.colorbar.';
      opts._meta = fullLayout._meta;
      cbOpt = {
        min: 'cmin',
        max: 'cmax'
      };
      if (colorAxOpts[0] !== 'heatmap') {
        trace = colorAxOpts[1];
        cbOpt.calc = trace._module.colorbar.calc;
      }
      calcOpts();
      out.push(opts);
    }
  }
  return out;
}
function drawColorBar(g, opts, gd) {
  var isVertical = opts.orientation === 'v';
  var len = opts.len;
  var lenmode = opts.lenmode;
  var thickness = opts.thickness;
  var thicknessmode = opts.thicknessmode;
  var outlinewidth = opts.outlinewidth;
  var borderwidth = opts.borderwidth;
  var bgcolor = opts.bgcolor;
  var xanchor = opts.xanchor;
  var yanchor = opts.yanchor;
  var xpad = opts.xpad;
  var ypad = opts.ypad;
  var optsX = opts.x;
  var optsY = isVertical ? opts.y : 1 - opts.y;
  var isPaperY = opts.yref === 'paper';
  var isPaperX = opts.xref === 'paper';
  var fullLayout = gd._fullLayout;
  var gs = fullLayout._size;
  var fillColor = opts._fillcolor;
  var line = opts._line;
  var title = opts.title;
  var titleSide = title.side;
  var zrange = opts._zrange || d3.extent((typeof fillColor === 'function' ? fillColor : line.color).domain());
  var lineColormap = typeof line.color === 'function' ? line.color : function () {
    return line.color;
  };
  var fillColormap = typeof fillColor === 'function' ? fillColor : function () {
    return fillColor;
  };
  var levelsIn = opts._levels;
  var levelsOut = calcLevels(gd, opts, zrange);
  var fillLevels = levelsOut.fill;
  var lineLevels = levelsOut.line;

  // we calculate pixel sizes based on the specified graph size,
  // not the actual (in case something pushed the margins around)
  // which is a little odd but avoids an odd iterative effect
  // when the colorbar itself is pushing the margins.
  // but then the fractional size is calculated based on the
  // actual graph size, so that the axes will size correctly.
  var thickPx = Math.round(thickness * (thicknessmode === 'fraction' ? isVertical ? gs.w : gs.h : 1));
  var thickFrac = thickPx / (isVertical ? gs.w : gs.h);
  var lenPx = Math.round(len * (lenmode === 'fraction' ? isVertical ? gs.h : gs.w : 1));
  var lenFrac = lenPx / (isVertical ? gs.h : gs.w);
  var posW = isPaperX ? gs.w : gd._fullLayout.width;
  var posH = isPaperY ? gs.h : gd._fullLayout.height;

  // x positioning: do it initially just for left anchor,
  // then fix at the end (since we don't know the width yet)
  var uPx = Math.round(isVertical ? optsX * posW + xpad : optsY * posH + ypad);
  var xRatio = {
    center: 0.5,
    right: 1
  }[xanchor] || 0;
  var yRatio = {
    top: 1,
    middle: 0.5
  }[yanchor] || 0;

  // for dragging... this is getting a little muddled...
  var uFrac = isVertical ? optsX - xRatio * thickFrac : optsY - yRatio * thickFrac;

  // y/x positioning (for v/h) we can do correctly from the start
  var vFrac = isVertical ? optsY - yRatio * lenFrac : optsX - xRatio * lenFrac;
  var vPx = Math.round(isVertical ? posH * (1 - vFrac) : posW * vFrac);

  // stash a few things for makeEditable
  opts._lenFrac = lenFrac;
  opts._thickFrac = thickFrac;
  opts._uFrac = uFrac;
  opts._vFrac = vFrac;

  // stash mocked axis for contour label formatting
  var ax = opts._axis = mockColorBarAxis(gd, opts, zrange);

  // position can't go in through supplyDefaults
  // because that restricts it to [0,1]
  ax.position = thickFrac + (isVertical ? optsX + xpad / gs.w : optsY + ypad / gs.h);
  var topOrBottom = ['top', 'bottom'].indexOf(titleSide) !== -1;
  if (isVertical && topOrBottom) {
    ax.title.side = titleSide;
    ax.titlex = optsX + xpad / gs.w;
    ax.titley = vFrac + (title.side === 'top' ? lenFrac - ypad / gs.h : ypad / gs.h);
  }
  if (!isVertical && !topOrBottom) {
    ax.title.side = titleSide;
    ax.titley = optsY + ypad / gs.h;
    ax.titlex = vFrac + xpad / gs.w; // right side
  }

  if (line.color && opts.tickmode === 'auto') {
    ax.tickmode = 'linear';
    ax.tick0 = levelsIn.start;
    var dtick = levelsIn.size;
    // expand if too many contours, so we don't get too many ticks
    var autoNtick = Lib.constrain(lenPx / 50, 4, 15) + 1;
    var dtFactor = (zrange[1] - zrange[0]) / ((opts.nticks || autoNtick) * dtick);
    if (dtFactor > 1) {
      var dtexp = Math.pow(10, Math.floor(Math.log(dtFactor) / Math.LN10));
      dtick *= dtexp * Lib.roundUp(dtFactor / dtexp, [2, 5, 10]);
      // if the contours are at round multiples, reset tick0
      // so they're still at round multiples. Otherwise,
      // keep the first label on the first contour level
      if ((Math.abs(levelsIn.start) / levelsIn.size + 1e-6) % 1 < 2e-6) {
        ax.tick0 = 0;
      }
    }
    ax.dtick = dtick;
  }

  // set domain after init, because we may want to
  // allow it outside [0,1]
  ax.domain = isVertical ? [vFrac + ypad / gs.h, vFrac + lenFrac - ypad / gs.h] : [vFrac + xpad / gs.w, vFrac + lenFrac - xpad / gs.w];
  ax.setScale();
  g.attr('transform', strTranslate(Math.round(gs.l), Math.round(gs.t)));
  var titleCont = g.select('.' + cn.cbtitleunshift).attr('transform', strTranslate(-Math.round(gs.l), -Math.round(gs.t)));
  var ticklabelposition = ax.ticklabelposition;
  var titleFontSize = ax.title.font.size;
  var axLayer = g.select('.' + cn.cbaxis);
  var titleEl;
  var titleHeight = 0;
  var titleWidth = 0;
  function drawTitle(titleClass, titleOpts) {
    var dfltTitleOpts = {
      propContainer: ax,
      propName: opts._propPrefix + 'title',
      traceIndex: opts._traceIndex,
      _meta: opts._meta,
      placeholder: fullLayout._dfltTitle.colorbar,
      containerGroup: g.select('.' + cn.cbtitle)
    };

    // this class-to-rotate thing with convertToTspans is
    // getting hackier and hackier... delete groups with the
    // wrong class (in case earlier the colorbar was drawn on
    // a different side, I think?)
    var otherClass = titleClass.charAt(0) === 'h' ? titleClass.substr(1) : 'h' + titleClass;
    g.selectAll('.' + otherClass + ',.' + otherClass + '-math-group').remove();
    Titles.draw(gd, titleClass, extendFlat(dfltTitleOpts, titleOpts || {}));
  }
  function drawDummyTitle() {
    // draw the title so we know how much room it needs
    // when we squish the axis.
    // On vertical colorbars this only applies to top or bottom titles, not right side.
    // On horizontal colorbars this only applies to right, etc.

    if (isVertical && topOrBottom || !isVertical && !topOrBottom) {
      var x, y;
      if (titleSide === 'top') {
        x = xpad + gs.l + posW * optsX;
        y = ypad + gs.t + posH * (1 - vFrac - lenFrac) + 3 + titleFontSize * 0.75;
      }
      if (titleSide === 'bottom') {
        x = xpad + gs.l + posW * optsX;
        y = ypad + gs.t + posH * (1 - vFrac) - 3 - titleFontSize * 0.25;
      }
      if (titleSide === 'right') {
        y = ypad + gs.t + posH * optsY + 3 + titleFontSize * 0.75;
        x = xpad + gs.l + posW * vFrac;
      }
      drawTitle(ax._id + 'title', {
        attributes: {
          x: x,
          y: y,
          'text-anchor': isVertical ? 'start' : 'middle'
        }
      });
    }
  }
  function drawCbTitle() {
    if (isVertical && !topOrBottom || !isVertical && topOrBottom) {
      var pos = ax.position || 0;
      var mid = ax._offset + ax._length / 2;
      var x, y;
      if (titleSide === 'right') {
        y = mid;
        x = gs.l + posW * pos + 10 + titleFontSize * (ax.showticklabels ? 1 : 0.5);
      } else {
        x = mid;
        if (titleSide === 'bottom') {
          y = gs.t + posH * pos + 10 + (ticklabelposition.indexOf('inside') === -1 ? ax.tickfont.size : 0) + (ax.ticks !== 'intside' ? opts.ticklen || 0 : 0);
        }
        if (titleSide === 'top') {
          var nlines = title.text.split('<br>').length;
          y = gs.t + posH * pos + 10 - thickPx - LINE_SPACING * titleFontSize * nlines;
        }
      }
      drawTitle((isVertical ?
      // the 'h' + is a hack to get around the fact that
      // convertToTspans rotates any 'y...' class by 90 degrees.
      // TODO: find a better way to control this.
      'h' : 'v') + ax._id + 'title', {
        avoid: {
          selection: d3.select(gd).selectAll('g.' + ax._id + 'tick'),
          side: titleSide,
          offsetTop: isVertical ? 0 : gs.t,
          offsetLeft: isVertical ? gs.l : 0,
          maxShift: isVertical ? fullLayout.width : fullLayout.height
        },
        attributes: {
          x: x,
          y: y,
          'text-anchor': 'middle'
        },
        transform: {
          rotate: isVertical ? -90 : 0,
          offset: 0
        }
      });
    }
  }
  function drawAxis() {
    if (!isVertical && !topOrBottom || isVertical && topOrBottom) {
      // squish the axis top to make room for the title
      var titleGroup = g.select('.' + cn.cbtitle);
      var titleText = titleGroup.select('text');
      var titleTrans = [-outlinewidth / 2, outlinewidth / 2];
      var mathJaxNode = titleGroup.select('.h' + ax._id + 'title-math-group').node();
      var lineSize = 15.6;
      if (titleText.node()) {
        lineSize = parseInt(titleText.node().style.fontSize, 10) * LINE_SPACING;
      }
      var bb;
      if (mathJaxNode) {
        bb = Drawing.bBox(mathJaxNode);
        titleWidth = bb.width;
        titleHeight = bb.height;
        if (titleHeight > lineSize) {
          // not entirely sure how mathjax is doing
          // vertical alignment, but this seems to work.
          titleTrans[1] -= (titleHeight - lineSize) / 2;
        }
      } else if (titleText.node() && !titleText.classed(cn.jsPlaceholder)) {
        bb = Drawing.bBox(titleText.node());
        titleWidth = bb.width;
        titleHeight = bb.height;
      }
      if (isVertical) {
        if (titleHeight) {
          // buffer btwn colorbar and title
          // TODO: configurable
          titleHeight += 5;
          if (titleSide === 'top') {
            ax.domain[1] -= titleHeight / gs.h;
            titleTrans[1] *= -1;
          } else {
            ax.domain[0] += titleHeight / gs.h;
            var nlines = svgTextUtils.lineCount(titleText);
            titleTrans[1] += (1 - nlines) * lineSize;
          }
          titleGroup.attr('transform', strTranslate(titleTrans[0], titleTrans[1]));
          ax.setScale();
        }
      } else {
        // horizontal colorbars
        if (titleWidth) {
          if (titleSide === 'right') {
            ax.domain[0] += (titleWidth + titleFontSize / 2) / gs.w;
          }
          titleGroup.attr('transform', strTranslate(titleTrans[0], titleTrans[1]));
          ax.setScale();
        }
      }
    }
    g.selectAll('.' + cn.cbfills + ',.' + cn.cblines).attr('transform', isVertical ? strTranslate(0, Math.round(gs.h * (1 - ax.domain[1]))) : strTranslate(Math.round(gs.w * ax.domain[0]), 0));
    axLayer.attr('transform', isVertical ? strTranslate(0, Math.round(-gs.t)) : strTranslate(Math.round(-gs.l), 0));
    var fills = g.select('.' + cn.cbfills).selectAll('rect.' + cn.cbfill).attr('style', '').data(fillLevels);
    fills.enter().append('rect').classed(cn.cbfill, true).attr('style', '');
    fills.exit().remove();
    var zBounds = zrange.map(ax.c2p).map(Math.round).sort(function (a, b) {
      return a - b;
    });
    fills.each(function (d, i) {
      var z = [i === 0 ? zrange[0] : (fillLevels[i] + fillLevels[i - 1]) / 2, i === fillLevels.length - 1 ? zrange[1] : (fillLevels[i] + fillLevels[i + 1]) / 2].map(ax.c2p).map(Math.round);

      // offset the side adjoining the next rectangle so they
      // overlap, to prevent antialiasing gaps
      if (isVertical) {
        z[1] = Lib.constrain(z[1] + (z[1] > z[0]) ? 1 : -1, zBounds[0], zBounds[1]);
      } /* else {
          // TODO: horizontal case
        } */

      // Colorbar cannot currently support opacities so we
      // use an opaque fill even when alpha channels present
      var fillEl = d3.select(this).attr(isVertical ? 'x' : 'y', uPx).attr(isVertical ? 'y' : 'x', d3.min(z)).attr(isVertical ? 'width' : 'height', Math.max(thickPx, 2)).attr(isVertical ? 'height' : 'width', Math.max(d3.max(z) - d3.min(z), 2));
      if (opts._fillgradient) {
        Drawing.gradient(fillEl, gd, opts._id, isVertical ? 'vertical' : 'horizontalreversed', opts._fillgradient, 'fill');
      } else {
        // tinycolor can't handle exponents and
        // at this scale, removing it makes no difference.
        var colorString = fillColormap(d).replace('e-', '');
        fillEl.attr('fill', tinycolor(colorString).toHexString());
      }
    });
    var lines = g.select('.' + cn.cblines).selectAll('path.' + cn.cbline).data(line.color && line.width ? lineLevels : []);
    lines.enter().append('path').classed(cn.cbline, true);
    lines.exit().remove();
    lines.each(function (d) {
      var a = uPx;
      var b = Math.round(ax.c2p(d)) + line.width / 2 % 1;
      d3.select(this).attr('d', 'M' + (isVertical ? a + ',' + b : b + ',' + a) + (isVertical ? 'h' : 'v') + thickPx).call(Drawing.lineGroupStyle, line.width, lineColormap(d), line.dash);
    });

    // force full redraw of labels and ticks
    axLayer.selectAll('g.' + ax._id + 'tick,path').remove();
    var shift = uPx + thickPx + (outlinewidth || 0) / 2 - (opts.ticks === 'outside' ? 1 : 0);
    var vals = Axes.calcTicks(ax);
    var tickSign = Axes.getTickSigns(ax)[2];
    Axes.drawTicks(gd, ax, {
      vals: ax.ticks === 'inside' ? Axes.clipEnds(ax, vals) : vals,
      layer: axLayer,
      path: Axes.makeTickPath(ax, shift, tickSign),
      transFn: Axes.makeTransTickFn(ax)
    });
    return Axes.drawLabels(gd, ax, {
      vals: vals,
      layer: axLayer,
      transFn: Axes.makeTransTickLabelFn(ax),
      labelFns: Axes.makeLabelFns(ax, shift)
    });
  }

  // wait for the axis & title to finish rendering before
  // continuing positioning
  // TODO: why are we redrawing multiple times now with this?
  // I guess autoMargin doesn't like being post-promise?
  function positionCB() {
    var bb;
    var innerThickness = thickPx + outlinewidth / 2;
    if (ticklabelposition.indexOf('inside') === -1) {
      bb = Drawing.bBox(axLayer.node());
      innerThickness += isVertical ? bb.width : bb.height;
    }
    titleEl = titleCont.select('text');
    var titleWidth = 0;
    var topSideVertical = isVertical && titleSide === 'top';
    var rightSideHorizontal = !isVertical && titleSide === 'right';
    var moveY = 0;
    if (titleEl.node() && !titleEl.classed(cn.jsPlaceholder)) {
      var _titleHeight;
      var mathJaxNode = titleCont.select('.h' + ax._id + 'title-math-group').node();
      if (mathJaxNode && (isVertical && topOrBottom || !isVertical && !topOrBottom)) {
        bb = Drawing.bBox(mathJaxNode);
        titleWidth = bb.width;
        _titleHeight = bb.height;
      } else {
        // note: the formula below works for all title sides,
        // (except for top/bottom mathjax, above)
        // but the weird gs.l is because the titleunshift
        // transform gets removed by Drawing.bBox
        bb = Drawing.bBox(titleCont.node());
        titleWidth = bb.right - gs.l - (isVertical ? uPx : vPx);
        _titleHeight = bb.bottom - gs.t - (isVertical ? vPx : uPx);
        if (!isVertical && titleSide === 'top') {
          innerThickness += bb.height;
          moveY = bb.height;
        }
      }
      if (rightSideHorizontal) {
        titleEl.attr('transform', strTranslate(titleWidth / 2 + titleFontSize / 2, 0));
        titleWidth *= 2;
      }
      innerThickness = Math.max(innerThickness, isVertical ? titleWidth : _titleHeight);
    }
    var outerThickness = (isVertical ? xpad : ypad) * 2 + innerThickness + borderwidth + outlinewidth / 2;
    var hColorbarMoveTitle = 0;
    if (!isVertical && title.text && yanchor === 'bottom' && optsY <= 0) {
      hColorbarMoveTitle = outerThickness / 2;
      outerThickness += hColorbarMoveTitle;
      moveY += hColorbarMoveTitle;
    }
    fullLayout._hColorbarMoveTitle = hColorbarMoveTitle;
    fullLayout._hColorbarMoveCBTitle = moveY;
    var extraW = borderwidth + outlinewidth;

    // TODO - are these the correct positions?
    var lx = (isVertical ? uPx : vPx) - extraW / 2 - (isVertical ? xpad : 0);
    var ly = (isVertical ? vPx : uPx) - (isVertical ? lenPx : ypad + moveY - hColorbarMoveTitle);
    g.select('.' + cn.cbbg).attr('x', lx).attr('y', ly).attr(isVertical ? 'width' : 'height', Math.max(outerThickness - hColorbarMoveTitle, 2)).attr(isVertical ? 'height' : 'width', Math.max(lenPx + extraW, 2)).call(Color.fill, bgcolor).call(Color.stroke, opts.bordercolor).style('stroke-width', borderwidth);
    var moveX = rightSideHorizontal ? Math.max(titleWidth - 10, 0) : 0;
    g.selectAll('.' + cn.cboutline).attr('x', (isVertical ? uPx : vPx + xpad) + moveX).attr('y', (isVertical ? vPx + ypad - lenPx : uPx) + (topSideVertical ? titleHeight : 0)).attr(isVertical ? 'width' : 'height', Math.max(thickPx, 2)).attr(isVertical ? 'height' : 'width', Math.max(lenPx - (isVertical ? 2 * ypad + titleHeight : 2 * xpad + moveX), 2)).call(Color.stroke, opts.outlinecolor).style({
      fill: 'none',
      'stroke-width': outlinewidth
    });
    var xShift = isVertical ? xRatio * outerThickness : 0;
    var yShift = isVertical ? 0 : (1 - yRatio) * outerThickness - moveY;
    xShift = isPaperX ? gs.l - xShift : -xShift;
    yShift = isPaperY ? gs.t - yShift : -yShift;
    g.attr('transform', strTranslate(xShift, yShift));
    if (!isVertical && (borderwidth || tinycolor(bgcolor).getAlpha() && !tinycolor.equals(fullLayout.paper_bgcolor, bgcolor))) {
      // for horizontal colorbars when there is a border line or having different background color
      // hide/adjust x positioning for the first/last tick labels if they go outside the border
      var tickLabels = axLayer.selectAll('text');
      var numTicks = tickLabels[0].length;
      var border = g.select('.' + cn.cbbg).node();
      var oBb = Drawing.bBox(border);
      var oTr = Drawing.getTranslate(g);
      var TEXTPAD = 2;
      tickLabels.each(function (d, i) {
        var first = 0;
        var last = numTicks - 1;
        if (i === first || i === last) {
          var iBb = Drawing.bBox(this);
          var iTr = Drawing.getTranslate(this);
          var deltaX;
          if (i === last) {
            var iRight = iBb.right + iTr.x;
            var oRight = oBb.right + oTr.x + vPx - borderwidth - TEXTPAD + optsX;
            deltaX = oRight - iRight;
            if (deltaX > 0) deltaX = 0;
          } else if (i === first) {
            var iLeft = iBb.left + iTr.x;
            var oLeft = oBb.left + oTr.x + vPx + borderwidth + TEXTPAD;
            deltaX = oLeft - iLeft;
            if (deltaX < 0) deltaX = 0;
          }
          if (deltaX) {
            if (numTicks < 3) {
              // adjust position
              this.setAttribute('transform', 'translate(' + deltaX + ',0) ' + this.getAttribute('transform'));
            } else {
              // hide
              this.setAttribute('visibility', 'hidden');
            }
          }
        }
      });
    }

    // auto margin adjustment
    var marginOpts = {};
    var lFrac = FROM_TL[xanchor];
    var rFrac = FROM_BR[xanchor];
    var tFrac = FROM_TL[yanchor];
    var bFrac = FROM_BR[yanchor];
    var extraThickness = outerThickness - thickPx;
    if (isVertical) {
      if (lenmode === 'pixels') {
        marginOpts.y = optsY;
        marginOpts.t = lenPx * tFrac;
        marginOpts.b = lenPx * bFrac;
      } else {
        marginOpts.t = marginOpts.b = 0;
        marginOpts.yt = optsY + len * tFrac;
        marginOpts.yb = optsY - len * bFrac;
      }
      if (thicknessmode === 'pixels') {
        marginOpts.x = optsX;
        marginOpts.l = outerThickness * lFrac;
        marginOpts.r = outerThickness * rFrac;
      } else {
        marginOpts.l = extraThickness * lFrac;
        marginOpts.r = extraThickness * rFrac;
        marginOpts.xl = optsX - thickness * lFrac;
        marginOpts.xr = optsX + thickness * rFrac;
      }
    } else {
      // horizontal colorbars
      if (lenmode === 'pixels') {
        marginOpts.x = optsX;
        marginOpts.l = lenPx * lFrac;
        marginOpts.r = lenPx * rFrac;
      } else {
        marginOpts.l = marginOpts.r = 0;
        marginOpts.xl = optsX + len * lFrac;
        marginOpts.xr = optsX - len * rFrac;
      }
      if (thicknessmode === 'pixels') {
        marginOpts.y = 1 - optsY;
        marginOpts.t = outerThickness * tFrac;
        marginOpts.b = outerThickness * bFrac;
      } else {
        marginOpts.t = extraThickness * tFrac;
        marginOpts.b = extraThickness * bFrac;
        marginOpts.yt = optsY - thickness * tFrac;
        marginOpts.yb = optsY + thickness * bFrac;
      }
    }
    var sideY = opts.y < 0.5 ? 'b' : 't';
    var sideX = opts.x < 0.5 ? 'l' : 'r';
    gd._fullLayout._reservedMargin[opts._id] = {};
    var possibleReservedMargins = {
      r: fullLayout.width - lx - xShift,
      l: lx + marginOpts.r,
      b: fullLayout.height - ly - yShift,
      t: ly + marginOpts.b
    };
    if (isPaperX && isPaperY) {
      Plots.autoMargin(gd, opts._id, marginOpts);
    } else if (isPaperX) {
      gd._fullLayout._reservedMargin[opts._id][sideY] = possibleReservedMargins[sideY];
    } else if (isPaperY) {
      gd._fullLayout._reservedMargin[opts._id][sideX] = possibleReservedMargins[sideX];
    } else {
      if (isVertical) {
        gd._fullLayout._reservedMargin[opts._id][sideX] = possibleReservedMargins[sideX];
      } else {
        gd._fullLayout._reservedMargin[opts._id][sideY] = possibleReservedMargins[sideY];
      }
    }
  }
  return Lib.syncOrAsync([Plots.previousPromises, drawDummyTitle, drawAxis, drawCbTitle, Plots.previousPromises, positionCB], gd);
}
function makeEditable(g, opts, gd) {
  var isVertical = opts.orientation === 'v';
  var fullLayout = gd._fullLayout;
  var gs = fullLayout._size;
  var t0, xf, yf;
  dragElement.init({
    element: g.node(),
    gd: gd,
    prepFn: function () {
      t0 = g.attr('transform');
      setCursor(g);
    },
    moveFn: function (dx, dy) {
      g.attr('transform', t0 + strTranslate(dx, dy));
      xf = dragElement.align((isVertical ? opts._uFrac : opts._vFrac) + dx / gs.w, isVertical ? opts._thickFrac : opts._lenFrac, 0, 1, opts.xanchor);
      yf = dragElement.align((isVertical ? opts._vFrac : 1 - opts._uFrac) - dy / gs.h, isVertical ? opts._lenFrac : opts._thickFrac, 0, 1, opts.yanchor);
      var csr = dragElement.getCursor(xf, yf, opts.xanchor, opts.yanchor);
      setCursor(g, csr);
    },
    doneFn: function () {
      setCursor(g);
      if (xf !== undefined && yf !== undefined) {
        var update = {};
        update[opts._propPrefix + 'x'] = xf;
        update[opts._propPrefix + 'y'] = yf;
        if (opts._traceIndex !== undefined) {
          Registry.call('_guiRestyle', gd, update, opts._traceIndex);
        } else {
          Registry.call('_guiRelayout', gd, update);
        }
      }
    }
  });
}
function calcLevels(gd, opts, zrange) {
  var levelsIn = opts._levels;
  var lineLevels = [];
  var fillLevels = [];
  var l;
  var i;
  var l0 = levelsIn.end + levelsIn.size / 100;
  var ls = levelsIn.size;
  var zr0 = 1.001 * zrange[0] - 0.001 * zrange[1];
  var zr1 = 1.001 * zrange[1] - 0.001 * zrange[0];
  for (i = 0; i < 1e5; i++) {
    l = levelsIn.start + i * ls;
    if (ls > 0 ? l >= l0 : l <= l0) break;
    if (l > zr0 && l < zr1) lineLevels.push(l);
  }
  if (opts._fillgradient) {
    fillLevels = [0];
  } else if (typeof opts._fillcolor === 'function') {
    var fillLevelsIn = opts._filllevels;
    if (fillLevelsIn) {
      l0 = fillLevelsIn.end + fillLevelsIn.size / 100;
      ls = fillLevelsIn.size;
      for (i = 0; i < 1e5; i++) {
        l = fillLevelsIn.start + i * ls;
        if (ls > 0 ? l >= l0 : l <= l0) break;
        if (l > zrange[0] && l < zrange[1]) fillLevels.push(l);
      }
    } else {
      fillLevels = lineLevels.map(function (v) {
        return v - levelsIn.size / 2;
      });
      fillLevels.push(fillLevels[fillLevels.length - 1] + levelsIn.size);
    }
  } else if (opts._fillcolor && typeof opts._fillcolor === 'string') {
    // doesn't matter what this value is, with a single value
    // we'll make a single fill rect covering the whole bar
    fillLevels = [0];
  }
  if (levelsIn.size < 0) {
    lineLevels.reverse();
    fillLevels.reverse();
  }
  return {
    line: lineLevels,
    fill: fillLevels
  };
}
function mockColorBarAxis(gd, opts, zrange) {
  var fullLayout = gd._fullLayout;
  var isVertical = opts.orientation === 'v';
  var cbAxisIn = {
    type: 'linear',
    range: zrange,
    tickmode: opts.tickmode,
    nticks: opts.nticks,
    tick0: opts.tick0,
    dtick: opts.dtick,
    tickvals: opts.tickvals,
    ticktext: opts.ticktext,
    ticks: opts.ticks,
    ticklen: opts.ticklen,
    tickwidth: opts.tickwidth,
    tickcolor: opts.tickcolor,
    showticklabels: opts.showticklabels,
    labelalias: opts.labelalias,
    ticklabelposition: opts.ticklabelposition,
    ticklabeloverflow: opts.ticklabeloverflow,
    ticklabelstep: opts.ticklabelstep,
    tickfont: opts.tickfont,
    tickangle: opts.tickangle,
    tickformat: opts.tickformat,
    exponentformat: opts.exponentformat,
    minexponent: opts.minexponent,
    separatethousands: opts.separatethousands,
    showexponent: opts.showexponent,
    showtickprefix: opts.showtickprefix,
    tickprefix: opts.tickprefix,
    showticksuffix: opts.showticksuffix,
    ticksuffix: opts.ticksuffix,
    title: opts.title,
    showline: true,
    anchor: 'free',
    side: isVertical ? 'right' : 'bottom',
    position: 1
  };
  var letter = isVertical ? 'y' : 'x';
  var cbAxisOut = {
    type: 'linear',
    _id: letter + opts._id
  };
  var axisOptions = {
    letter: letter,
    font: fullLayout.font,
    noHover: true,
    noTickson: true,
    noTicklabelmode: true,
    noInsideRange: true,
    calendar: fullLayout.calendar // not really necessary (yet?)
  };

  function coerce(attr, dflt) {
    return Lib.coerce(cbAxisIn, cbAxisOut, axisLayoutAttrs, attr, dflt);
  }
  handleAxisDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions, fullLayout);
  handleAxisPositionDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions);
  return cbAxisOut;
}
module.exports = {
  draw: draw
};

/***/ }),

/***/ 6228:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
module.exports = function hasColorbar(container) {
  return Lib.isPlainObject(container.colorbar);
};

/***/ }),

/***/ 2311:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  moduleType: 'component',
  name: 'colorbar',
  attributes: __webpack_require__(3583),
  supplyDefaults: __webpack_require__(2499),
  draw: (__webpack_require__(8981).draw),
  hasColorbar: __webpack_require__(6228)
};

/***/ }),

/***/ 693:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var colorbarAttrs = __webpack_require__(3583);
var counterRegex = (__webpack_require__(587).counter);
var sortObjectKeys = __webpack_require__(8607);
var palettes = (__webpack_require__(3282).scales);
var paletteStr = sortObjectKeys(palettes);
function code(s) {
  return '`' + s + '`';
}

/**
 * Make colorscale attribute declarations for
 *
 * - colorscale,
 * - (c|z)auto, (c|z)min, (c|z)max,
 * - autocolorscale, reversescale,
 * - showscale (optionally)
 * - color (optionally)
 *
 * @param {string} context (dflt: '', i.e. from trace root):
 *     the container this is in ('', *marker*, *marker.line* etc)
 *
 * @param {object} opts:
 *   - cLetter {string} (dflt: 'c'):
 *     leading letter for 'min', 'max and 'auto' attribute (either 'z' or 'c')
 *
 *   - colorAttr {string} (dflt: 'z' if `cLetter: 'z'`, 'color' if `cLetter: 'c'`):
 *     (for descriptions) sets the name of the color attribute that maps to the colorscale.
 *
 *     N.B. if `colorAttr: 'color'`, we include the `color` declaration here.
 *
 *   - onlyIfNumerical {string} (dflt: false' if `cLetter: 'z'`, true if `cLetter: 'c'`):
 *     (for descriptions) set to true if colorscale attribute only
 *
 *   - colorscaleDflt {string}:
 *     overrides the colorscale dflt
 *
 *   - autoColorDflt {boolean} (dflt true):
 *     normally autocolorscale.dflt is `true`, but pass `false` to override
 *
 *   - noScale {boolean} (dflt: true if `context: 'marker.line'`, false otherwise):
 *     set to `false` to not include showscale attribute (e.g. for 'marker.line')
 *
 *   - showScaleDflt {boolean} (dflt: true if `cLetter: 'z'`, false otherwise)
 *
 *   - editTypeOverride {boolean} (dflt: ''):
 *     most of these attributes already require a recalc, but the ones that do not
 *     have editType *style* or *plot* unless you override (presumably with *calc*)
 *
 *   - anim {boolean) (dflt: undefined): is 'color' animatable?
 *
 * @return {object}
 */
module.exports = function colorScaleAttrs(context, opts) {
  context = context || '';
  opts = opts || {};
  var cLetter = opts.cLetter || 'c';
  var onlyIfNumerical = 'onlyIfNumerical' in opts ? opts.onlyIfNumerical : Boolean(context);
  var noScale = 'noScale' in opts ? opts.noScale : context === 'marker.line';
  var showScaleDflt = 'showScaleDflt' in opts ? opts.showScaleDflt : cLetter === 'z';
  var colorscaleDflt = typeof opts.colorscaleDflt === 'string' ? palettes[opts.colorscaleDflt] : null;
  var editTypeOverride = opts.editTypeOverride || '';
  var contextHead = context ? context + '.' : '';
  var colorAttr, colorAttrFull;
  if ('colorAttr' in opts) {
    colorAttr = opts.colorAttr;
    colorAttrFull = opts.colorAttr;
  } else {
    colorAttr = {
      z: 'z',
      c: 'color'
    }[cLetter];
    colorAttrFull = 'in ' + code(contextHead + colorAttr);
  }
  var effectDesc = onlyIfNumerical ? ' Has an effect only if ' + colorAttrFull + ' is set to a numerical array.' : '';
  var auto = cLetter + 'auto';
  var min = cLetter + 'min';
  var max = cLetter + 'max';
  var mid = cLetter + 'mid';
  var autoFull = code(contextHead + auto);
  var minFull = code(contextHead + min);
  var maxFull = code(contextHead + max);
  var minmaxFull = minFull + ' and ' + maxFull;
  var autoImpliedEdits = {};
  autoImpliedEdits[min] = autoImpliedEdits[max] = undefined;
  var minmaxImpliedEdits = {};
  minmaxImpliedEdits[auto] = false;
  var attrs = {};
  if (colorAttr === 'color') {
    attrs.color = {
      valType: 'color',
      arrayOk: true,
      editType: editTypeOverride || 'style'
    };
    if (opts.anim) {
      attrs.color.anim = true;
    }
  }
  attrs[auto] = {
    valType: 'boolean',
    dflt: true,
    editType: 'calc',
    impliedEdits: autoImpliedEdits
  };
  attrs[min] = {
    valType: 'number',
    dflt: null,
    editType: editTypeOverride || 'plot',
    impliedEdits: minmaxImpliedEdits
  };
  attrs[max] = {
    valType: 'number',
    dflt: null,
    editType: editTypeOverride || 'plot',
    impliedEdits: minmaxImpliedEdits
  };
  attrs[mid] = {
    valType: 'number',
    dflt: null,
    editType: 'calc',
    impliedEdits: autoImpliedEdits
  };
  attrs.colorscale = {
    valType: 'colorscale',
    editType: 'calc',
    dflt: colorscaleDflt,
    impliedEdits: {
      autocolorscale: false
    }
  };
  attrs.autocolorscale = {
    valType: 'boolean',
    // gets overrode in 'heatmap' & 'surface' for backwards comp.
    dflt: opts.autoColorDflt === false ? false : true,
    editType: 'calc',
    impliedEdits: {
      colorscale: undefined
    }
  };
  attrs.reversescale = {
    valType: 'boolean',
    dflt: false,
    editType: 'plot'
  };
  if (!noScale) {
    attrs.showscale = {
      valType: 'boolean',
      dflt: showScaleDflt,
      editType: 'calc'
    };
    attrs.colorbar = colorbarAttrs;
  }
  if (!opts.noColorAxis) {
    attrs.coloraxis = {
      valType: 'subplotid',
      regex: counterRegex('coloraxis'),
      dflt: null,
      editType: 'calc'
    };
  }
  return attrs;
};

/***/ }),

/***/ 8803:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var Lib = __webpack_require__(1828);
var extractOpts = (__webpack_require__(2869).extractOpts);
module.exports = function calc(gd, trace, opts) {
  var fullLayout = gd._fullLayout;
  var vals = opts.vals;
  var containerStr = opts.containerStr;
  var container = containerStr ? Lib.nestedProperty(trace, containerStr).get() : trace;
  var cOpts = extractOpts(container);
  var auto = cOpts.auto !== false;
  var min = cOpts.min;
  var max = cOpts.max;
  var mid = cOpts.mid;
  var minVal = function () {
    return Lib.aggNums(Math.min, null, vals);
  };
  var maxVal = function () {
    return Lib.aggNums(Math.max, null, vals);
  };
  if (min === undefined) {
    min = minVal();
  } else if (auto) {
    if (container._colorAx && isNumeric(min)) {
      min = Math.min(min, minVal());
    } else {
      min = minVal();
    }
  }
  if (max === undefined) {
    max = maxVal();
  } else if (auto) {
    if (container._colorAx && isNumeric(max)) {
      max = Math.max(max, maxVal());
    } else {
      max = maxVal();
    }
  }
  if (auto && mid !== undefined) {
    if (max - mid > mid - min) {
      min = mid - (max - mid);
    } else if (max - mid < mid - min) {
      max = mid + (mid - min);
    }
  }
  if (min === max) {
    min -= 0.5;
    max += 0.5;
  }
  cOpts._sync('min', min);
  cOpts._sync('max', max);
  if (cOpts.autocolorscale) {
    var scl;
    if (min * max < 0) scl = fullLayout.colorscale.diverging;else if (min >= 0) scl = fullLayout.colorscale.sequential;else scl = fullLayout.colorscale.sequentialminus;
    cOpts._sync('colorscale', scl);
  }
};

/***/ }),

/***/ 3046:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var hasColorscale = (__webpack_require__(2869).hasColorscale);
var extractOpts = (__webpack_require__(2869).extractOpts);
module.exports = function crossTraceDefaults(fullData, fullLayout) {
  function replace(cont, k) {
    var val = cont['_' + k];
    if (val !== undefined) {
      cont[k] = val;
    }
  }
  function relinkColorAttrs(outerCont, cbOpt) {
    var cont = cbOpt.container ? Lib.nestedProperty(outerCont, cbOpt.container).get() : outerCont;
    if (cont) {
      if (cont.coloraxis) {
        // stash ref to color axis
        cont._colorAx = fullLayout[cont.coloraxis];
      } else {
        var cOpts = extractOpts(cont);
        var isAuto = cOpts.auto;
        if (isAuto || cOpts.min === undefined) {
          replace(cont, cbOpt.min);
        }
        if (isAuto || cOpts.max === undefined) {
          replace(cont, cbOpt.max);
        }
        if (cOpts.autocolorscale) {
          replace(cont, 'colorscale');
        }
      }
    }
  }
  for (var i = 0; i < fullData.length; i++) {
    var trace = fullData[i];
    var cbOpts = trace._module.colorbar;
    if (cbOpts) {
      if (Array.isArray(cbOpts)) {
        for (var j = 0; j < cbOpts.length; j++) {
          relinkColorAttrs(trace, cbOpts[j]);
        }
      } else {
        relinkColorAttrs(trace, cbOpts);
      }
    }
    if (hasColorscale(trace, 'marker.line')) {
      relinkColorAttrs(trace, {
        container: 'marker.line',
        min: 'cmin',
        max: 'cmax'
      });
    }
  }
  for (var k in fullLayout._colorAxes) {
    relinkColorAttrs(fullLayout[k], {
      min: 'cmin',
      max: 'cmax'
    });
  }
};

/***/ }),

/***/ 1586:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var Lib = __webpack_require__(1828);
var hasColorbar = __webpack_require__(6228);
var colorbarDefaults = __webpack_require__(2499);
var isValidScale = (__webpack_require__(3282).isValid);
var traceIs = (__webpack_require__(3972).traceIs);
function npMaybe(parentCont, prefix) {
  var containerStr = prefix.slice(0, prefix.length - 1);
  return prefix ? Lib.nestedProperty(parentCont, containerStr).get() || {} : parentCont;
}

/**
 * Colorscale / colorbar default handler
 *
 * @param {object} parentContIn : user (input) parent container (e.g. trace or layout coloraxis object)
 * @param {object} parentContOut : full parent container
 * @param {object} layout : (full) layout object
 * @param {fn} coerce : Lib.coerce wrapper
 * @param {object} opts :
 * - prefix {string} : attr string prefix to colorscale container from parent root
 * - cLetter {string} : 'c or 'z' color letter
 */
module.exports = function colorScaleDefaults(parentContIn, parentContOut, layout, coerce, opts) {
  var prefix = opts.prefix;
  var cLetter = opts.cLetter;
  var inTrace = ('_module' in parentContOut);
  var containerIn = npMaybe(parentContIn, prefix);
  var containerOut = npMaybe(parentContOut, prefix);
  var template = npMaybe(parentContOut._template || {}, prefix) || {};

  // colorScaleDefaults wrapper called if-ever we need to reset the colorscale
  // attributes for containers that were linked to invalid color axes
  var thisFn = function () {
    delete parentContIn.coloraxis;
    delete parentContOut.coloraxis;
    return colorScaleDefaults(parentContIn, parentContOut, layout, coerce, opts);
  };
  if (inTrace) {
    var colorAxes = layout._colorAxes || {};
    var colorAx = coerce(prefix + 'coloraxis');
    if (colorAx) {
      var colorbarVisuals = traceIs(parentContOut, 'contour') && Lib.nestedProperty(parentContOut, 'contours.coloring').get() || 'heatmap';
      var stash = colorAxes[colorAx];
      if (stash) {
        stash[2].push(thisFn);
        if (stash[0] !== colorbarVisuals) {
          stash[0] = false;
          Lib.warn(['Ignoring coloraxis:', colorAx, 'setting', 'as it is linked to incompatible colorscales.'].join(' '));
        }
      } else {
        // stash:
        // - colorbar visual 'type'
        // - colorbar options to help in Colorbar.draw
        // - list of colorScaleDefaults wrapper functions
        colorAxes[colorAx] = [colorbarVisuals, parentContOut, [thisFn]];
      }
      return;
    }
  }
  var minIn = containerIn[cLetter + 'min'];
  var maxIn = containerIn[cLetter + 'max'];
  var validMinMax = isNumeric(minIn) && isNumeric(maxIn) && minIn < maxIn;
  var auto = coerce(prefix + cLetter + 'auto', !validMinMax);
  if (auto) {
    coerce(prefix + cLetter + 'mid');
  } else {
    coerce(prefix + cLetter + 'min');
    coerce(prefix + cLetter + 'max');
  }

  // handles both the trace case (autocolorscale is false by default) and
  // the marker and marker.line case (autocolorscale is true by default)
  var sclIn = containerIn.colorscale;
  var sclTemplate = template.colorscale;
  var autoColorscaleDflt;
  if (sclIn !== undefined) autoColorscaleDflt = !isValidScale(sclIn);
  if (sclTemplate !== undefined) autoColorscaleDflt = !isValidScale(sclTemplate);
  coerce(prefix + 'autocolorscale', autoColorscaleDflt);
  coerce(prefix + 'colorscale');
  coerce(prefix + 'reversescale');
  if (prefix !== 'marker.line.') {
    // handles both the trace case where the dflt is listed in attributes and
    // the marker case where the dflt is determined by hasColorbar
    var showScaleDflt;
    if (prefix && inTrace) showScaleDflt = hasColorbar(containerIn);
    var showScale = coerce(prefix + 'showscale', showScaleDflt);
    if (showScale) {
      if (prefix && template) containerOut._template = template;
      colorbarDefaults(containerIn, containerOut, layout);
    }
  }
};

/***/ }),

/***/ 2869:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var tinycolor = __webpack_require__(4267);
var isNumeric = __webpack_require__(2770);
var Lib = __webpack_require__(1828);
var Color = __webpack_require__(7901);
var isValidScale = (__webpack_require__(3282).isValid);
function hasColorscale(trace, containerStr, colorKey) {
  var container = containerStr ? Lib.nestedProperty(trace, containerStr).get() || {} : trace;
  var color = container[colorKey || 'color'];
  var isArrayWithOneNumber = false;
  if (Lib.isArrayOrTypedArray(color)) {
    for (var i = 0; i < color.length; i++) {
      if (isNumeric(color[i])) {
        isArrayWithOneNumber = true;
        break;
      }
    }
  }
  return Lib.isPlainObject(container) && (isArrayWithOneNumber || container.showscale === true || isNumeric(container.cmin) && isNumeric(container.cmax) || isValidScale(container.colorscale) || Lib.isPlainObject(container.colorbar));
}
var constantAttrs = ['showscale', 'autocolorscale', 'colorscale', 'reversescale', 'colorbar'];
var letterAttrs = ['min', 'max', 'mid', 'auto'];

/**
 * Extract 'c' / 'z', trace / color axis colorscale options
 *
 * Note that it would be nice to replace all z* with c* equivalents in v3
 *
 * @param {object} cont : attribute container
 * @return {object}:
 *  - min: cmin or zmin
 *  - max: cmax or zmax
 *  - mid: cmid or zmid
 *  - auto: cauto or zauto
 *  - *scale: *scale attrs
 *  - colorbar: colorbar
 *  - _sync: function syncing attr and underscore dual (useful when calc'ing min/max)
 */
function extractOpts(cont) {
  var colorAx = cont._colorAx;
  var cont2 = colorAx ? colorAx : cont;
  var out = {};
  var cLetter;
  var i, k;
  for (i = 0; i < constantAttrs.length; i++) {
    k = constantAttrs[i];
    out[k] = cont2[k];
  }
  if (colorAx) {
    cLetter = 'c';
    for (i = 0; i < letterAttrs.length; i++) {
      k = letterAttrs[i];
      out[k] = cont2['c' + k];
    }
  } else {
    var k2;
    for (i = 0; i < letterAttrs.length; i++) {
      k = letterAttrs[i];
      k2 = 'c' + k;
      if (k2 in cont2) {
        out[k] = cont2[k2];
        continue;
      }
      k2 = 'z' + k;
      if (k2 in cont2) {
        out[k] = cont2[k2];
      }
    }
    cLetter = k2.charAt(0);
  }
  out._sync = function (k, v) {
    var k2 = letterAttrs.indexOf(k) !== -1 ? cLetter + k : k;
    cont2[k2] = cont2['_' + k2] = v;
  };
  return out;
}

/**
 * Extract colorscale into numeric domain and color range.
 *
 * @param {object} cont colorscale container (e.g. trace, marker)
 *  - colorscale {array of arrays}
 *  - cmin/zmin {number}
 *  - cmax/zmax {number}
 *  - reversescale {boolean}
 *
 * @return {object}
 *  - domain {array}
 *  - range {array}
 */
function extractScale(cont) {
  var cOpts = extractOpts(cont);
  var cmin = cOpts.min;
  var cmax = cOpts.max;
  var scl = cOpts.reversescale ? flipScale(cOpts.colorscale) : cOpts.colorscale;
  var N = scl.length;
  var domain = new Array(N);
  var range = new Array(N);
  for (var i = 0; i < N; i++) {
    var si = scl[i];
    domain[i] = cmin + si[0] * (cmax - cmin);
    range[i] = si[1];
  }
  return {
    domain: domain,
    range: range
  };
}
function flipScale(scl) {
  var N = scl.length;
  var sclNew = new Array(N);
  for (var i = N - 1, j = 0; i >= 0; i--, j++) {
    var si = scl[i];
    sclNew[j] = [1 - si[0], si[1]];
  }
  return sclNew;
}

/**
 * General colorscale function generator.
 *
 * @param {object} specs output of Colorscale.extractScale or precomputed domain, range.
 *  - domain {array}
 *  - range {array}
 *
 * @param {object} opts
 *  - noNumericCheck {boolean} if true, scale func bypasses numeric checks
 *  - returnArray {boolean} if true, scale func return 4-item array instead of color strings
 *
 * @return {function}
 */
function makeColorScaleFunc(specs, opts) {
  opts = opts || {};
  var domain = specs.domain;
  var range = specs.range;
  var N = range.length;
  var _range = new Array(N);
  for (var i = 0; i < N; i++) {
    var rgba = tinycolor(range[i]).toRgb();
    _range[i] = [rgba.r, rgba.g, rgba.b, rgba.a];
  }
  var _sclFunc = d3.scale.linear().domain(domain).range(_range).clamp(true);
  var noNumericCheck = opts.noNumericCheck;
  var returnArray = opts.returnArray;
  var sclFunc;
  if (noNumericCheck && returnArray) {
    sclFunc = _sclFunc;
  } else if (noNumericCheck) {
    sclFunc = function (v) {
      return colorArray2rbga(_sclFunc(v));
    };
  } else if (returnArray) {
    sclFunc = function (v) {
      if (isNumeric(v)) return _sclFunc(v);else if (tinycolor(v).isValid()) return v;else return Color.defaultLine;
    };
  } else {
    sclFunc = function (v) {
      if (isNumeric(v)) return colorArray2rbga(_sclFunc(v));else if (tinycolor(v).isValid()) return v;else return Color.defaultLine;
    };
  }

  // colorbar draw looks into the d3 scale closure for domain and range
  sclFunc.domain = _sclFunc.domain;
  sclFunc.range = function () {
    return range;
  };
  return sclFunc;
}
function makeColorScaleFuncFromTrace(trace, opts) {
  return makeColorScaleFunc(extractScale(trace), opts);
}
function colorArray2rbga(colorArray) {
  var colorObj = {
    r: colorArray[0],
    g: colorArray[1],
    b: colorArray[2],
    a: colorArray[3]
  };
  return tinycolor(colorObj).toRgbString();
}
module.exports = {
  hasColorscale: hasColorscale,
  extractOpts: extractOpts,
  extractScale: extractScale,
  flipScale: flipScale,
  makeColorScaleFunc: makeColorScaleFunc,
  makeColorScaleFuncFromTrace: makeColorScaleFuncFromTrace
};

/***/ }),

/***/ 1081:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var scales = __webpack_require__(3282);
var helpers = __webpack_require__(2869);
module.exports = {
  moduleType: 'component',
  name: 'colorscale',
  attributes: __webpack_require__(693),
  layoutAttributes: __webpack_require__(2673),
  supplyLayoutDefaults: __webpack_require__(959),
  handleDefaults: __webpack_require__(1586),
  crossTraceDefaults: __webpack_require__(3046),
  calc: __webpack_require__(8803),
  // ./scales.js is required in lib/coerce.js ;
  // it needs to be a separate module to avoid a circular dependency
  scales: scales.scales,
  defaultScale: scales.defaultScale,
  getScale: scales.get,
  isValidScale: scales.isValid,
  hasColorscale: helpers.hasColorscale,
  extractOpts: helpers.extractOpts,
  extractScale: helpers.extractScale,
  flipScale: helpers.flipScale,
  makeColorScaleFunc: helpers.makeColorScaleFunc,
  makeColorScaleFuncFromTrace: helpers.makeColorScaleFuncFromTrace
};

/***/ }),

/***/ 2673:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var extendFlat = (__webpack_require__(1426).extendFlat);
var colorScaleAttrs = __webpack_require__(693);
var scales = (__webpack_require__(3282).scales);
var msg = 'Note that `autocolorscale` must be true for this attribute to work.';
module.exports = {
  editType: 'calc',
  colorscale: {
    editType: 'calc',
    sequential: {
      valType: 'colorscale',
      dflt: scales.Reds,
      editType: 'calc'
    },
    sequentialminus: {
      valType: 'colorscale',
      dflt: scales.Blues,
      editType: 'calc'
    },
    diverging: {
      valType: 'colorscale',
      dflt: scales.RdBu,
      editType: 'calc'
    }
  },
  coloraxis: extendFlat({
    // not really a 'subplot' attribute container,
    // but this is the flag we use to denote attributes that
    // support yaxis, yaxis2, yaxis3, ... counters
    _isSubplotObj: true,
    editType: 'calc'
  }, colorScaleAttrs('', {
    colorAttr: 'corresponding trace color array(s)',
    noColorAxis: true,
    showScaleDflt: true
  }))
};

/***/ }),

/***/ 959:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Template = __webpack_require__(4467);
var colorScaleAttrs = __webpack_require__(2673);
var colorScaleDefaults = __webpack_require__(1586);
module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
  function coerce(attr, dflt) {
    return Lib.coerce(layoutIn, layoutOut, colorScaleAttrs, attr, dflt);
  }
  coerce('colorscale.sequential');
  coerce('colorscale.sequentialminus');
  coerce('colorscale.diverging');
  var colorAxes = layoutOut._colorAxes;
  var colorAxIn, colorAxOut;
  function coerceAx(attr, dflt) {
    return Lib.coerce(colorAxIn, colorAxOut, colorScaleAttrs.coloraxis, attr, dflt);
  }
  for (var k in colorAxes) {
    var stash = colorAxes[k];
    if (stash[0]) {
      colorAxIn = layoutIn[k] || {};
      colorAxOut = Template.newContainer(layoutOut, k, 'coloraxis');
      colorAxOut._name = k;
      colorScaleDefaults(colorAxIn, colorAxOut, layoutOut, coerceAx, {
        prefix: '',
        cLetter: 'c'
      });
    } else {
      // re-coerce colorscale attributes w/o coloraxis
      for (var i = 0; i < stash[2].length; i++) {
        stash[2][i]();
      }
      delete layoutOut._colorAxes[k];
    }
  }
};

/***/ }),

/***/ 3282:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var tinycolor = __webpack_require__(4267);
var scales = {
  Greys: [[0, 'rgb(0,0,0)'], [1, 'rgb(255,255,255)']],
  YlGnBu: [[0, 'rgb(8,29,88)'], [0.125, 'rgb(37,52,148)'], [0.25, 'rgb(34,94,168)'], [0.375, 'rgb(29,145,192)'], [0.5, 'rgb(65,182,196)'], [0.625, 'rgb(127,205,187)'], [0.75, 'rgb(199,233,180)'], [0.875, 'rgb(237,248,217)'], [1, 'rgb(255,255,217)']],
  Greens: [[0, 'rgb(0,68,27)'], [0.125, 'rgb(0,109,44)'], [0.25, 'rgb(35,139,69)'], [0.375, 'rgb(65,171,93)'], [0.5, 'rgb(116,196,118)'], [0.625, 'rgb(161,217,155)'], [0.75, 'rgb(199,233,192)'], [0.875, 'rgb(229,245,224)'], [1, 'rgb(247,252,245)']],
  YlOrRd: [[0, 'rgb(128,0,38)'], [0.125, 'rgb(189,0,38)'], [0.25, 'rgb(227,26,28)'], [0.375, 'rgb(252,78,42)'], [0.5, 'rgb(253,141,60)'], [0.625, 'rgb(254,178,76)'], [0.75, 'rgb(254,217,118)'], [0.875, 'rgb(255,237,160)'], [1, 'rgb(255,255,204)']],
  Bluered: [[0, 'rgb(0,0,255)'], [1, 'rgb(255,0,0)']],
  // modified RdBu based on
  // http://www.kennethmoreland.com/color-maps/
  RdBu: [[0, 'rgb(5,10,172)'], [0.35, 'rgb(106,137,247)'], [0.5, 'rgb(190,190,190)'], [0.6, 'rgb(220,170,132)'], [0.7, 'rgb(230,145,90)'], [1, 'rgb(178,10,28)']],
  // Scale for non-negative numeric values
  Reds: [[0, 'rgb(220,220,220)'], [0.2, 'rgb(245,195,157)'], [0.4, 'rgb(245,160,105)'], [1, 'rgb(178,10,28)']],
  // Scale for non-positive numeric values
  Blues: [[0, 'rgb(5,10,172)'], [0.35, 'rgb(40,60,190)'], [0.5, 'rgb(70,100,245)'], [0.6, 'rgb(90,120,245)'], [0.7, 'rgb(106,137,247)'], [1, 'rgb(220,220,220)']],
  Picnic: [[0, 'rgb(0,0,255)'], [0.1, 'rgb(51,153,255)'], [0.2, 'rgb(102,204,255)'], [0.3, 'rgb(153,204,255)'], [0.4, 'rgb(204,204,255)'], [0.5, 'rgb(255,255,255)'], [0.6, 'rgb(255,204,255)'], [0.7, 'rgb(255,153,255)'], [0.8, 'rgb(255,102,204)'], [0.9, 'rgb(255,102,102)'], [1, 'rgb(255,0,0)']],
  Rainbow: [[0, 'rgb(150,0,90)'], [0.125, 'rgb(0,0,200)'], [0.25, 'rgb(0,25,255)'], [0.375, 'rgb(0,152,255)'], [0.5, 'rgb(44,255,150)'], [0.625, 'rgb(151,255,0)'], [0.75, 'rgb(255,234,0)'], [0.875, 'rgb(255,111,0)'], [1, 'rgb(255,0,0)']],
  Portland: [[0, 'rgb(12,51,131)'], [0.25, 'rgb(10,136,186)'], [0.5, 'rgb(242,211,56)'], [0.75, 'rgb(242,143,56)'], [1, 'rgb(217,30,30)']],
  Jet: [[0, 'rgb(0,0,131)'], [0.125, 'rgb(0,60,170)'], [0.375, 'rgb(5,255,255)'], [0.625, 'rgb(255,255,0)'], [0.875, 'rgb(250,0,0)'], [1, 'rgb(128,0,0)']],
  Hot: [[0, 'rgb(0,0,0)'], [0.3, 'rgb(230,0,0)'], [0.6, 'rgb(255,210,0)'], [1, 'rgb(255,255,255)']],
  Blackbody: [[0, 'rgb(0,0,0)'], [0.2, 'rgb(230,0,0)'], [0.4, 'rgb(230,210,0)'], [0.7, 'rgb(255,255,255)'], [1, 'rgb(160,200,255)']],
  Earth: [[0, 'rgb(0,0,130)'], [0.1, 'rgb(0,180,180)'], [0.2, 'rgb(40,210,40)'], [0.4, 'rgb(230,230,50)'], [0.6, 'rgb(120,70,20)'], [1, 'rgb(255,255,255)']],
  Electric: [[0, 'rgb(0,0,0)'], [0.15, 'rgb(30,0,100)'], [0.4, 'rgb(120,0,100)'], [0.6, 'rgb(160,90,0)'], [0.8, 'rgb(230,200,0)'], [1, 'rgb(255,250,220)']],
  Viridis: [[0, '#440154'], [0.06274509803921569, '#48186a'], [0.12549019607843137, '#472d7b'], [0.18823529411764706, '#424086'], [0.25098039215686274, '#3b528b'], [0.3137254901960784, '#33638d'], [0.3764705882352941, '#2c728e'], [0.4392156862745098, '#26828e'], [0.5019607843137255, '#21918c'], [0.5647058823529412, '#1fa088'], [0.6274509803921569, '#28ae80'], [0.6901960784313725, '#3fbc73'], [0.7529411764705882, '#5ec962'], [0.8156862745098039, '#84d44b'], [0.8784313725490196, '#addc30'], [0.9411764705882353, '#d8e219'], [1, '#fde725']],
  Cividis: [[0.000000, 'rgb(0,32,76)'], [0.058824, 'rgb(0,42,102)'], [0.117647, 'rgb(0,52,110)'], [0.176471, 'rgb(39,63,108)'], [0.235294, 'rgb(60,74,107)'], [0.294118, 'rgb(76,85,107)'], [0.352941, 'rgb(91,95,109)'], [0.411765, 'rgb(104,106,112)'], [0.470588, 'rgb(117,117,117)'], [0.529412, 'rgb(131,129,120)'], [0.588235, 'rgb(146,140,120)'], [0.647059, 'rgb(161,152,118)'], [0.705882, 'rgb(176,165,114)'], [0.764706, 'rgb(192,177,109)'], [0.823529, 'rgb(209,191,102)'], [0.882353, 'rgb(225,204,92)'], [0.941176, 'rgb(243,219,79)'], [1.000000, 'rgb(255,233,69)']]
};
var defaultScale = scales.RdBu;
function getScale(scl, dflt) {
  if (!dflt) dflt = defaultScale;
  if (!scl) return dflt;
  function parseScale() {
    try {
      scl = scales[scl] || JSON.parse(scl);
    } catch (e) {
      scl = dflt;
    }
  }
  if (typeof scl === 'string') {
    parseScale();
    // occasionally scl is double-JSON encoded...
    if (typeof scl === 'string') parseScale();
  }
  if (!isValidScaleArray(scl)) return dflt;
  return scl;
}
function isValidScaleArray(scl) {
  var highestVal = 0;
  if (!Array.isArray(scl) || scl.length < 2) return false;
  if (!scl[0] || !scl[scl.length - 1]) return false;
  if (+scl[0][0] !== 0 || +scl[scl.length - 1][0] !== 1) return false;
  for (var i = 0; i < scl.length; i++) {
    var si = scl[i];
    if (si.length !== 2 || +si[0] < highestVal || !tinycolor(si[1]).isValid()) {
      return false;
    }
    highestVal = +si[0];
  }
  return true;
}
function isValidScale(scl) {
  if (scales[scl] !== undefined) return true;else return isValidScaleArray(scl);
}
module.exports = {
  scales: scales,
  defaultScale: defaultScale,
  get: getScale,
  isValid: isValidScale
};

/***/ }),

/***/ 2807:
/***/ (function(module) {

"use strict";


// for automatic alignment on dragging, <1/3 means left align,
// >2/3 means right, and between is center. Pick the right fraction
// based on where you are, and return the fraction corresponding to
// that position on the object
module.exports = function align(v, dv, v0, v1, anchor) {
  var vmin = (v - v0) / (v1 - v0);
  var vmax = vmin + dv / (v1 - v0);
  var vc = (vmin + vmax) / 2;

  // explicitly specified anchor
  if (anchor === 'left' || anchor === 'bottom') return vmin;
  if (anchor === 'center' || anchor === 'middle') return vc;
  if (anchor === 'right' || anchor === 'top') return vmax;

  // automatic based on position
  if (vmin < 2 / 3 - vc) return vmin;
  if (vmax > 4 / 3 - vc) return vmax;
  return vc;
};

/***/ }),

/***/ 461:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);

// set cursors pointing toward the closest corner/side,
// to indicate alignment
// x and y are 0-1, fractions of the plot area
var cursorset = [['sw-resize', 's-resize', 'se-resize'], ['w-resize', 'move', 'e-resize'], ['nw-resize', 'n-resize', 'ne-resize']];
module.exports = function getCursor(x, y, xanchor, yanchor) {
  if (xanchor === 'left') x = 0;else if (xanchor === 'center') x = 1;else if (xanchor === 'right') x = 2;else x = Lib.constrain(Math.floor(x * 3), 0, 2);
  if (yanchor === 'bottom') y = 0;else if (yanchor === 'middle') y = 1;else if (yanchor === 'top') y = 2;else y = Lib.constrain(Math.floor(y * 3), 0, 2);
  return cursorset[y][x];
};

/***/ }),

/***/ 4505:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.selectMode = function (dragmode) {
  return dragmode === 'lasso' || dragmode === 'select';
};
exports.drawMode = function (dragmode) {
  return dragmode === 'drawclosedpath' || dragmode === 'drawopenpath' || dragmode === 'drawline' || dragmode === 'drawrect' || dragmode === 'drawcircle';
};
exports.openMode = function (dragmode) {
  return dragmode === 'drawline' || dragmode === 'drawopenpath';
};
exports.rectMode = function (dragmode) {
  return dragmode === 'select' || dragmode === 'drawline' || dragmode === 'drawrect' || dragmode === 'drawcircle';
};
exports.freeMode = function (dragmode) {
  return dragmode === 'lasso' || dragmode === 'drawclosedpath' || dragmode === 'drawopenpath';
};
exports.selectingOrDrawing = function (dragmode) {
  return exports.freeMode(dragmode) || exports.rectMode(dragmode);
};

/***/ }),

/***/ 8569:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var mouseOffset = __webpack_require__(8956);
var hasHover = __webpack_require__(7035);
var supportsPassive = __webpack_require__(8520);
var removeElement = (__webpack_require__(1828).removeElement);
var constants = __webpack_require__(5555);
var dragElement = module.exports = {};
dragElement.align = __webpack_require__(2807);
dragElement.getCursor = __webpack_require__(461);
var unhover = __webpack_require__(6041);
dragElement.unhover = unhover.wrapped;
dragElement.unhoverRaw = unhover.raw;

/**
 * Abstracts click & drag interactions
 *
 * During the interaction, a "coverSlip" element - a transparent
 * div covering the whole page - is created, which has two key effects:
 * - Lets you drag beyond the boundaries of the plot itself without
 *   dropping (but if you drag all the way out of the browser window the
 *   interaction will end)
 * - Freezes the cursor: whatever mouse cursor the drag element had when the
 *   interaction started gets copied to the coverSlip for use until mouseup
 *
 * If the user executes a drag bigger than MINDRAG, callbacks will fire as:
 *      prepFn, moveFn (1 or more times), doneFn
 * If the user does not drag enough, prepFn and clickFn will fire.
 *
 * Note: If you cancel contextmenu, clickFn will fire even with a right click
 * (unlike native events) so you'll get a `plotly_click` event. Cancel context eg:
 *    gd.addEventListener('contextmenu', function(e) { e.preventDefault(); });
 * TODO: we should probably turn this into a `config` parameter, so we can fix it
 * such that if you *don't* cancel contextmenu, we can prevent partial drags, which
 * put you in a weird state.
 *
 * If the user clicks multiple times quickly, clickFn will fire each time
 * but numClicks will increase to help you recognize doubleclicks.
 *
 * @param {object} options with keys:
 *      element (required) the DOM element to drag
 *      prepFn (optional) function(event, startX, startY)
 *          executed on mousedown
 *          startX and startY are the clientX and clientY pixel position
 *          of the mousedown event
 *      moveFn (optional) function(dx, dy)
 *          executed on move, ONLY after we've exceeded MINDRAG
 *          (we keep executing moveFn if you move back to where you started)
 *          dx and dy are the net pixel offset of the drag,
 *          dragged is true/false, has the mouse moved enough to
 *          constitute a drag
 *      doneFn (optional) function(e)
 *          executed on mouseup, ONLY if we exceeded MINDRAG (so you can be
 *          sure that moveFn has been called at least once)
 *          numClicks is how many clicks we've registered within
 *          a doubleclick time
 *          e is the original mouseup event
 *      clickFn (optional) function(numClicks, e)
 *          executed on mouseup if we have NOT exceeded MINDRAG (ie moveFn
 *          has not been called at all)
 *          numClicks is how many clicks we've registered within
 *          a doubleclick time
 *          e is the original mousedown event
 *      clampFn (optional, function(dx, dy) return [dx2, dy2])
 *          Provide custom clamping function for small displacements.
 *          By default, clamping is done using `minDrag` to x and y displacements
 *          independently.
 */
dragElement.init = function init(options) {
  var gd = options.gd;
  var numClicks = 1;
  var doubleClickDelay = gd._context.doubleClickDelay;
  var element = options.element;
  var startX, startY, newMouseDownTime, cursor, dragCover, initialEvent, initialTarget, rightClick;
  if (!gd._mouseDownTime) gd._mouseDownTime = 0;
  element.style.pointerEvents = 'all';
  element.onmousedown = onStart;
  if (!supportsPassive) {
    element.ontouchstart = onStart;
  } else {
    if (element._ontouchstart) {
      element.removeEventListener('touchstart', element._ontouchstart);
    }
    element._ontouchstart = onStart;
    element.addEventListener('touchstart', onStart, {
      passive: false
    });
  }
  function _clampFn(dx, dy, minDrag) {
    if (Math.abs(dx) < minDrag) dx = 0;
    if (Math.abs(dy) < minDrag) dy = 0;
    return [dx, dy];
  }
  var clampFn = options.clampFn || _clampFn;
  function onStart(e) {
    // make dragging and dragged into properties of gd
    // so that others can look at and modify them
    gd._dragged = false;
    gd._dragging = true;
    var offset = pointerOffset(e);
    startX = offset[0];
    startY = offset[1];
    initialTarget = e.target;
    initialEvent = e;
    rightClick = e.buttons === 2 || e.ctrlKey;

    // fix Fx.hover for touch events
    if (typeof e.clientX === 'undefined' && typeof e.clientY === 'undefined') {
      e.clientX = startX;
      e.clientY = startY;
    }
    newMouseDownTime = new Date().getTime();
    if (newMouseDownTime - gd._mouseDownTime < doubleClickDelay) {
      // in a click train
      numClicks += 1;
    } else {
      // new click train
      numClicks = 1;
      gd._mouseDownTime = newMouseDownTime;
    }
    if (options.prepFn) options.prepFn(e, startX, startY);
    if (hasHover && !rightClick) {
      dragCover = coverSlip();
      dragCover.style.cursor = window.getComputedStyle(element).cursor;
    } else if (!hasHover) {
      // document acts as a dragcover for mobile, bc we can't create dragcover dynamically
      dragCover = document;
      cursor = window.getComputedStyle(document.documentElement).cursor;
      document.documentElement.style.cursor = window.getComputedStyle(element).cursor;
    }
    document.addEventListener('mouseup', onDone);
    document.addEventListener('touchend', onDone);
    if (options.dragmode !== false) {
      e.preventDefault();
      document.addEventListener('mousemove', onMove);
      document.addEventListener('touchmove', onMove, {
        passive: false
      });
    }
    return;
  }
  function onMove(e) {
    e.preventDefault();
    var offset = pointerOffset(e);
    var minDrag = options.minDrag || constants.MINDRAG;
    var dxdy = clampFn(offset[0] - startX, offset[1] - startY, minDrag);
    var dx = dxdy[0];
    var dy = dxdy[1];
    if (dx || dy) {
      gd._dragged = true;
      dragElement.unhover(gd, e);
    }
    if (gd._dragged && options.moveFn && !rightClick) {
      gd._dragdata = {
        element: element,
        dx: dx,
        dy: dy
      };
      options.moveFn(dx, dy);
    }
    return;
  }
  function onDone(e) {
    delete gd._dragdata;
    if (options.dragmode !== false) {
      e.preventDefault();
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('touchmove', onMove);
    }
    document.removeEventListener('mouseup', onDone);
    document.removeEventListener('touchend', onDone);
    if (hasHover) {
      removeElement(dragCover);
    } else if (cursor) {
      dragCover.documentElement.style.cursor = cursor;
      cursor = null;
    }
    if (!gd._dragging) {
      gd._dragged = false;
      return;
    }
    gd._dragging = false;

    // don't count as a dblClick unless the mouseUp is also within
    // the dblclick delay
    if (new Date().getTime() - gd._mouseDownTime > doubleClickDelay) {
      numClicks = Math.max(numClicks - 1, 1);
    }
    if (gd._dragged) {
      if (options.doneFn) options.doneFn();
    } else {
      if (options.clickFn) options.clickFn(numClicks, initialEvent);

      // If we haven't dragged, this should be a click. But because of the
      // coverSlip changing the element, the natural system might not generate one,
      // so we need to make our own. But right clicks don't normally generate
      // click events, only contextmenu events, which happen on mousedown.
      if (!rightClick) {
        var e2;
        try {
          e2 = new MouseEvent('click', e);
        } catch (err) {
          var offset = pointerOffset(e);
          e2 = document.createEvent('MouseEvents');
          e2.initMouseEvent('click', e.bubbles, e.cancelable, e.view, e.detail, e.screenX, e.screenY, offset[0], offset[1], e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);
        }
        initialTarget.dispatchEvent(e2);
      }
    }
    gd._dragging = false;
    gd._dragged = false;
    return;
  }
};
function coverSlip() {
  var cover = document.createElement('div');
  cover.className = 'dragcover';
  var cStyle = cover.style;
  cStyle.position = 'fixed';
  cStyle.left = 0;
  cStyle.right = 0;
  cStyle.top = 0;
  cStyle.bottom = 0;
  cStyle.zIndex = 999999999;
  cStyle.background = 'none';
  document.body.appendChild(cover);
  return cover;
}
dragElement.coverSlip = coverSlip;
function pointerOffset(e) {
  return mouseOffset(e.changedTouches ? e.changedTouches[0] : e, document.body);
}

/***/ }),

/***/ 6041:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Events = __webpack_require__(1086);
var throttle = __webpack_require__(9990);
var getGraphDiv = (__webpack_require__(4401).getGraphDiv);
var hoverConstants = __webpack_require__(6675);
var unhover = module.exports = {};
unhover.wrapped = function (gd, evt, subplot) {
  gd = getGraphDiv(gd);

  // Important, clear any queued hovers
  if (gd._fullLayout) {
    throttle.clear(gd._fullLayout._uid + hoverConstants.HOVERID);
  }
  unhover.raw(gd, evt, subplot);
};

// remove hover effects on mouse out, and emit unhover event
unhover.raw = function raw(gd, evt) {
  var fullLayout = gd._fullLayout;
  var oldhoverdata = gd._hoverdata;
  if (!evt) evt = {};
  if (evt.target && !gd._dragged && Events.triggerHandler(gd, 'plotly_beforehover', evt) === false) {
    return;
  }
  fullLayout._hoverlayer.selectAll('g').remove();
  fullLayout._hoverlayer.selectAll('line').remove();
  fullLayout._hoverlayer.selectAll('circle').remove();
  gd._hoverdata = undefined;
  if (evt.target && oldhoverdata) {
    gd.emit('plotly_unhover', {
      event: evt,
      points: oldhoverdata
    });
  }
};

/***/ }),

/***/ 9952:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.P = {
  valType: 'string',
  // string type usually doesn't take values... this one should really be
  // a special type or at least a special coercion function, from the GUI
  // you only get these values but elsewhere the user can supply a list of
  // dash lengths in px, and it will be honored
  values: ['solid', 'dot', 'dash', 'longdash', 'dashdot', 'longdashdot'],
  dflt: 'solid',
  editType: 'style'
};
exports.u = {
  shape: {
    valType: 'enumerated',
    values: ['', '/', '\\', 'x', '-', '|', '+', '.'],
    dflt: '',
    arrayOk: true,
    editType: 'style'
  },
  fillmode: {
    valType: 'enumerated',
    values: ['replace', 'overlay'],
    dflt: 'replace',
    editType: 'style'
  },
  bgcolor: {
    valType: 'color',
    arrayOk: true,
    editType: 'style'
  },
  fgcolor: {
    valType: 'color',
    arrayOk: true,
    editType: 'style'
  },
  fgopacity: {
    valType: 'number',
    editType: 'style',
    min: 0,
    max: 1
  },
  size: {
    valType: 'number',
    min: 0,
    dflt: 8,
    arrayOk: true,
    editType: 'style'
  },
  solidity: {
    valType: 'number',
    min: 0,
    max: 1,
    dflt: 0.3,
    arrayOk: true,
    editType: 'style'
  },
  editType: 'style'
};

/***/ }),

/***/ 1424:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Lib = __webpack_require__(1828);
var numberFormat = Lib.numberFormat;
var isNumeric = __webpack_require__(2770);
var tinycolor = __webpack_require__(4267);
var Registry = __webpack_require__(3972);
var Color = __webpack_require__(7901);
var Colorscale = __webpack_require__(1081);
var strTranslate = Lib.strTranslate;
var svgTextUtils = __webpack_require__(3893);
var xmlnsNamespaces = __webpack_require__(7922);
var alignment = __webpack_require__(8783);
var LINE_SPACING = alignment.LINE_SPACING;
var DESELECTDIM = (__webpack_require__(7822).DESELECTDIM);
var subTypes = __webpack_require__(4098);
var makeBubbleSizeFn = __webpack_require__(9984);
var appendArrayPointValue = (__webpack_require__(3469).appendArrayPointValue);
var drawing = module.exports = {};

// -----------------------------------------------------
// styling functions for plot elements
// -----------------------------------------------------

drawing.font = function (s, family, size, color) {
  // also allow the form font(s, {family, size, color})
  if (Lib.isPlainObject(family)) {
    color = family.color;
    size = family.size;
    family = family.family;
  }
  if (family) s.style('font-family', family);
  if (size + 1) s.style('font-size', size + 'px');
  if (color) s.call(Color.fill, color);
};

/*
 * Positioning helpers
 * Note: do not use `setPosition` with <text> nodes modified by
 * `svgTextUtils.convertToTspans`. Use `svgTextUtils.positionText`
 * instead, so that <tspan.line> elements get updated to match.
 */
drawing.setPosition = function (s, x, y) {
  s.attr('x', x).attr('y', y);
};
drawing.setSize = function (s, w, h) {
  s.attr('width', w).attr('height', h);
};
drawing.setRect = function (s, x, y, w, h) {
  s.call(drawing.setPosition, x, y).call(drawing.setSize, w, h);
};

/** Translate node
 *
 * @param {object} d : calcdata point item
 * @param {sel} sel : d3 selction of node to translate
 * @param {object} xa : corresponding full xaxis object
 * @param {object} ya : corresponding full yaxis object
 *
 * @return {boolean} :
 *  true if selection got translated
 *  false if selection could not get translated
 */
drawing.translatePoint = function (d, sel, xa, ya) {
  var x = xa.c2p(d.x);
  var y = ya.c2p(d.y);
  if (isNumeric(x) && isNumeric(y) && sel.node()) {
    // for multiline text this works better
    if (sel.node().nodeName === 'text') {
      sel.attr('x', x).attr('y', y);
    } else {
      sel.attr('transform', strTranslate(x, y));
    }
  } else {
    return false;
  }
  return true;
};
drawing.translatePoints = function (s, xa, ya) {
  s.each(function (d) {
    var sel = d3.select(this);
    drawing.translatePoint(d, sel, xa, ya);
  });
};
drawing.hideOutsideRangePoint = function (d, sel, xa, ya, xcalendar, ycalendar) {
  sel.attr('display', xa.isPtWithinRange(d, xcalendar) && ya.isPtWithinRange(d, ycalendar) ? null : 'none');
};
drawing.hideOutsideRangePoints = function (traceGroups, subplot) {
  if (!subplot._hasClipOnAxisFalse) return;
  var xa = subplot.xaxis;
  var ya = subplot.yaxis;
  traceGroups.each(function (d) {
    var trace = d[0].trace;
    var xcalendar = trace.xcalendar;
    var ycalendar = trace.ycalendar;
    var selector = Registry.traceIs(trace, 'bar-like') ? '.bartext' : '.point,.textpoint';
    traceGroups.selectAll(selector).each(function (d) {
      drawing.hideOutsideRangePoint(d, d3.select(this), xa, ya, xcalendar, ycalendar);
    });
  });
};
drawing.crispRound = function (gd, lineWidth, dflt) {
  // for lines that disable antialiasing we want to
  // make sure the width is an integer, and at least 1 if it's nonzero

  if (!lineWidth || !isNumeric(lineWidth)) return dflt || 0;

  // but not for static plots - these don't get antialiased anyway.
  if (gd._context.staticPlot) return lineWidth;
  if (lineWidth < 1) return 1;
  return Math.round(lineWidth);
};
drawing.singleLineStyle = function (d, s, lw, lc, ld) {
  s.style('fill', 'none');
  var line = (((d || [])[0] || {}).trace || {}).line || {};
  var lw1 = lw || line.width || 0;
  var dash = ld || line.dash || '';
  Color.stroke(s, lc || line.color);
  drawing.dashLine(s, dash, lw1);
};
drawing.lineGroupStyle = function (s, lw, lc, ld) {
  s.style('fill', 'none').each(function (d) {
    var line = (((d || [])[0] || {}).trace || {}).line || {};
    var lw1 = lw || line.width || 0;
    var dash = ld || line.dash || '';
    d3.select(this).call(Color.stroke, lc || line.color).call(drawing.dashLine, dash, lw1);
  });
};
drawing.dashLine = function (s, dash, lineWidth) {
  lineWidth = +lineWidth || 0;
  dash = drawing.dashStyle(dash, lineWidth);
  s.style({
    'stroke-dasharray': dash,
    'stroke-width': lineWidth + 'px'
  });
};
drawing.dashStyle = function (dash, lineWidth) {
  lineWidth = +lineWidth || 1;
  var dlw = Math.max(lineWidth, 3);
  if (dash === 'solid') dash = '';else if (dash === 'dot') dash = dlw + 'px,' + dlw + 'px';else if (dash === 'dash') dash = 3 * dlw + 'px,' + 3 * dlw + 'px';else if (dash === 'longdash') dash = 5 * dlw + 'px,' + 5 * dlw + 'px';else if (dash === 'dashdot') {
    dash = 3 * dlw + 'px,' + dlw + 'px,' + dlw + 'px,' + dlw + 'px';
  } else if (dash === 'longdashdot') {
    dash = 5 * dlw + 'px,' + 2 * dlw + 'px,' + dlw + 'px,' + 2 * dlw + 'px';
  }
  // otherwise user wrote the dasharray themselves - leave it be

  return dash;
};
function setFillStyle(sel, trace, gd) {
  var markerPattern = trace.fillpattern;
  var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, 0, '');
  if (patternShape) {
    var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, 0, null);
    var patternFGColor = drawing.getPatternAttr(markerPattern.fgcolor, 0, null);
    var patternFGOpacity = markerPattern.fgopacity;
    var patternSize = drawing.getPatternAttr(markerPattern.size, 0, 8);
    var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, 0, 0.3);
    var patternID = trace.uid;
    drawing.pattern(sel, 'point', gd, patternID, patternShape, patternSize, patternSolidity, undefined, markerPattern.fillmode, patternBGColor, patternFGColor, patternFGOpacity);
  } else if (trace.fillcolor) {
    sel.call(Color.fill, trace.fillcolor);
  }
}

// Same as fillGroupStyle, except in this case the selection may be a transition
drawing.singleFillStyle = function (sel, gd) {
  var node = d3.select(sel.node());
  var data = node.data();
  var trace = ((data[0] || [])[0] || {}).trace || {};
  setFillStyle(sel, trace, gd);
};
drawing.fillGroupStyle = function (s, gd) {
  s.style('stroke-width', 0).each(function (d) {
    var shape = d3.select(this);
    // N.B. 'd' won't be a calcdata item when
    // fill !== 'none' on a segment-less and marker-less trace
    if (d[0].trace) {
      setFillStyle(shape, d[0].trace, gd);
    }
  });
};
var SYMBOLDEFS = __webpack_require__(998);
drawing.symbolNames = [];
drawing.symbolFuncs = [];
drawing.symbolBackOffs = [];
drawing.symbolNeedLines = {};
drawing.symbolNoDot = {};
drawing.symbolNoFill = {};
drawing.symbolList = [];
Object.keys(SYMBOLDEFS).forEach(function (k) {
  var symDef = SYMBOLDEFS[k];
  var n = symDef.n;
  drawing.symbolList.push(n, String(n), k, n + 100, String(n + 100), k + '-open');
  drawing.symbolNames[n] = k;
  drawing.symbolFuncs[n] = symDef.f;
  drawing.symbolBackOffs[n] = symDef.backoff || 0;
  if (symDef.needLine) {
    drawing.symbolNeedLines[n] = true;
  }
  if (symDef.noDot) {
    drawing.symbolNoDot[n] = true;
  } else {
    drawing.symbolList.push(n + 200, String(n + 200), k + '-dot', n + 300, String(n + 300), k + '-open-dot');
  }
  if (symDef.noFill) {
    drawing.symbolNoFill[n] = true;
  }
});
var MAXSYMBOL = drawing.symbolNames.length;
// add a dot in the middle of the symbol
var DOTPATH = 'M0,0.5L0.5,0L0,-0.5L-0.5,0Z';
drawing.symbolNumber = function (v) {
  if (isNumeric(v)) {
    v = +v;
  } else if (typeof v === 'string') {
    var vbase = 0;
    if (v.indexOf('-open') > 0) {
      vbase = 100;
      v = v.replace('-open', '');
    }
    if (v.indexOf('-dot') > 0) {
      vbase += 200;
      v = v.replace('-dot', '');
    }
    v = drawing.symbolNames.indexOf(v);
    if (v >= 0) {
      v += vbase;
    }
  }
  return v % 100 >= MAXSYMBOL || v >= 400 ? 0 : Math.floor(Math.max(v, 0));
};
function makePointPath(symbolNumber, r, t, s) {
  var base = symbolNumber % 100;
  return drawing.symbolFuncs[base](r, t, s) + (symbolNumber >= 200 ? DOTPATH : '');
}
var HORZGRADIENT = {
  x1: 1,
  x2: 0,
  y1: 0,
  y2: 0
};
var VERTGRADIENT = {
  x1: 0,
  x2: 0,
  y1: 1,
  y2: 0
};
var stopFormatter = numberFormat('~f');
var gradientInfo = {
  radial: {
    node: 'radialGradient'
  },
  radialreversed: {
    node: 'radialGradient',
    reversed: true
  },
  horizontal: {
    node: 'linearGradient',
    attrs: HORZGRADIENT
  },
  horizontalreversed: {
    node: 'linearGradient',
    attrs: HORZGRADIENT,
    reversed: true
  },
  vertical: {
    node: 'linearGradient',
    attrs: VERTGRADIENT
  },
  verticalreversed: {
    node: 'linearGradient',
    attrs: VERTGRADIENT,
    reversed: true
  }
};

/**
 * gradient: create and apply a gradient fill
 *
 * @param {object} sel: d3 selection to apply this gradient to
 *     You can use `selection.call(Drawing.gradient, ...)`
 * @param {DOM element} gd: the graph div `sel` is part of
 * @param {string} gradientID: a unique (within this plot) identifier
 *     for this gradient, so that we don't create unnecessary definitions
 * @param {string} type: 'radial', 'horizontal', or 'vertical', optionally with
 *     'reversed' at the end. Normally radial goes center to edge,
 *     horizontal goes right to left, and vertical goes bottom to top
 * @param {array} colorscale: as in attribute values, [[fraction, color], ...]
 * @param {string} prop: the property to apply to, 'fill' or 'stroke'
 */
drawing.gradient = function (sel, gd, gradientID, type, colorscale, prop) {
  var len = colorscale.length;
  var info = gradientInfo[type];
  var colorStops = new Array(len);
  for (var i = 0; i < len; i++) {
    if (info.reversed) {
      colorStops[len - 1 - i] = [stopFormatter((1 - colorscale[i][0]) * 100), colorscale[i][1]];
    } else {
      colorStops[i] = [stopFormatter(colorscale[i][0] * 100), colorscale[i][1]];
    }
  }
  var fullLayout = gd._fullLayout;
  var fullID = 'g' + fullLayout._uid + '-' + gradientID;
  var gradient = fullLayout._defs.select('.gradients').selectAll('#' + fullID).data([type + colorStops.join(';')], Lib.identity);
  gradient.exit().remove();
  gradient.enter().append(info.node).each(function () {
    var el = d3.select(this);
    if (info.attrs) el.attr(info.attrs);
    el.attr('id', fullID);
    var stops = el.selectAll('stop').data(colorStops);
    stops.exit().remove();
    stops.enter().append('stop');
    stops.each(function (d) {
      var tc = tinycolor(d[1]);
      d3.select(this).attr({
        offset: d[0] + '%',
        'stop-color': Color.tinyRGB(tc),
        'stop-opacity': tc.getAlpha()
      });
    });
  });
  sel.style(prop, getFullUrl(fullID, gd)).style(prop + '-opacity', null);
  sel.classed('gradient_filled', true);
};

/**
 * pattern: create and apply a pattern fill
 *
 * @param {object} sel: d3 selection to apply this pattern to
 *     You can use `selection.call(Drawing.pattern, ...)`
 * @param {string} calledBy: option to know the caller component
 * @param {DOM element} gd: the graph div `sel` is part of
 * @param {string} patternID: a unique (within this plot) identifier
 *     for this pattern, so that we don't create unnecessary definitions
 * @param {number} size: size of unit squares for repetition of this pattern
 * @param {number} solidity: how solid lines of this pattern are
 * @param {string} mcc: color when painted with colorscale
 * @param {string} fillmode: fillmode for this pattern
 * @param {string} bgcolor: background color for this pattern
 * @param {string} fgcolor: foreground color for this pattern
 * @param {number} fgopacity: foreground opacity for this pattern
 */
drawing.pattern = function (sel, calledBy, gd, patternID, shape, size, solidity, mcc, fillmode, bgcolor, fgcolor, fgopacity) {
  var isLegend = calledBy === 'legend';
  if (mcc) {
    if (fillmode === 'overlay') {
      bgcolor = mcc;
      fgcolor = Color.contrast(bgcolor);
    } else {
      bgcolor = undefined;
      fgcolor = mcc;
    }
  }
  var fullLayout = gd._fullLayout;
  var fullID = 'p' + fullLayout._uid + '-' + patternID;
  var width, height;

  // linear interpolation
  var linearFn = function (x, x0, x1, y0, y1) {
    return y0 + (y1 - y0) * (x - x0) / (x1 - x0);
  };
  var path, linewidth, radius;
  var patternTag;
  var patternAttrs = {};
  var fgC = tinycolor(fgcolor);
  var fgRGB = Color.tinyRGB(fgC);
  var fgAlpha = fgC.getAlpha();
  var opacity = fgopacity * fgAlpha;
  switch (shape) {
    case '/':
      width = size * Math.sqrt(2);
      height = size * Math.sqrt(2);
      path = 'M-' + width / 4 + ',' + height / 4 + 'l' + width / 2 + ',-' + height / 2 + 'M0,' + height + 'L' + width + ',0' + 'M' + width / 4 * 3 + ',' + height / 4 * 5 + 'l' + width / 2 + ',-' + height / 2;
      linewidth = solidity * size;
      patternTag = 'path';
      patternAttrs = {
        d: path,
        opacity: opacity,
        stroke: fgRGB,
        'stroke-width': linewidth + 'px'
      };
      break;
    case '\\':
      width = size * Math.sqrt(2);
      height = size * Math.sqrt(2);
      path = 'M' + width / 4 * 3 + ',-' + height / 4 + 'l' + width / 2 + ',' + height / 2 + 'M0,0L' + width + ',' + height + 'M-' + width / 4 + ',' + height / 4 * 3 + 'l' + width / 2 + ',' + height / 2;
      linewidth = solidity * size;
      patternTag = 'path';
      patternAttrs = {
        d: path,
        opacity: opacity,
        stroke: fgRGB,
        'stroke-width': linewidth + 'px'
      };
      break;
    case 'x':
      width = size * Math.sqrt(2);
      height = size * Math.sqrt(2);
      path = 'M-' + width / 4 + ',' + height / 4 + 'l' + width / 2 + ',-' + height / 2 + 'M0,' + height + 'L' + width + ',0' + 'M' + width / 4 * 3 + ',' + height / 4 * 5 + 'l' + width / 2 + ',-' + height / 2 + 'M' + width / 4 * 3 + ',-' + height / 4 + 'l' + width / 2 + ',' + height / 2 + 'M0,0L' + width + ',' + height + 'M-' + width / 4 + ',' + height / 4 * 3 + 'l' + width / 2 + ',' + height / 2;
      linewidth = size - size * Math.sqrt(1.0 - solidity);
      patternTag = 'path';
      patternAttrs = {
        d: path,
        opacity: opacity,
        stroke: fgRGB,
        'stroke-width': linewidth + 'px'
      };
      break;
    case '|':
      width = size;
      height = size;
      patternTag = 'path';
      path = 'M' + width / 2 + ',0L' + width / 2 + ',' + height;
      linewidth = solidity * size;
      patternTag = 'path';
      patternAttrs = {
        d: path,
        opacity: opacity,
        stroke: fgRGB,
        'stroke-width': linewidth + 'px'
      };
      break;
    case '-':
      width = size;
      height = size;
      patternTag = 'path';
      path = 'M0,' + height / 2 + 'L' + width + ',' + height / 2;
      linewidth = solidity * size;
      patternTag = 'path';
      patternAttrs = {
        d: path,
        opacity: opacity,
        stroke: fgRGB,
        'stroke-width': linewidth + 'px'
      };
      break;
    case '+':
      width = size;
      height = size;
      patternTag = 'path';
      path = 'M' + width / 2 + ',0L' + width / 2 + ',' + height + 'M0,' + height / 2 + 'L' + width + ',' + height / 2;
      linewidth = size - size * Math.sqrt(1.0 - solidity);
      patternTag = 'path';
      patternAttrs = {
        d: path,
        opacity: opacity,
        stroke: fgRGB,
        'stroke-width': linewidth + 'px'
      };
      break;
    case '.':
      width = size;
      height = size;
      if (solidity < Math.PI / 4) {
        radius = Math.sqrt(solidity * size * size / Math.PI);
      } else {
        radius = linearFn(solidity, Math.PI / 4, 1.0, size / 2, size / Math.sqrt(2));
      }
      patternTag = 'circle';
      patternAttrs = {
        cx: width / 2,
        cy: height / 2,
        r: radius,
        opacity: opacity,
        fill: fgRGB
      };
      break;
  }
  var str = [shape || 'noSh', bgcolor || 'noBg', fgcolor || 'noFg', size, solidity].join(';');
  var pattern = fullLayout._defs.select('.patterns').selectAll('#' + fullID).data([str], Lib.identity);
  pattern.exit().remove();
  pattern.enter().append('pattern').each(function () {
    var el = d3.select(this);
    el.attr({
      id: fullID,
      width: width + 'px',
      height: height + 'px',
      patternUnits: 'userSpaceOnUse',
      // for legends scale down patterns just a bit so that default size (i.e 8) nicely fit in small icons
      patternTransform: isLegend ? 'scale(0.8)' : ''
    });
    if (bgcolor) {
      var bgC = tinycolor(bgcolor);
      var bgRGB = Color.tinyRGB(bgC);
      var bgAlpha = bgC.getAlpha();
      var rects = el.selectAll('rect').data([0]);
      rects.exit().remove();
      rects.enter().append('rect').attr({
        width: width + 'px',
        height: height + 'px',
        fill: bgRGB,
        'fill-opacity': bgAlpha
      });
    }
    var patterns = el.selectAll(patternTag).data([0]);
    patterns.exit().remove();
    patterns.enter().append(patternTag).attr(patternAttrs);
  });
  sel.style('fill', getFullUrl(fullID, gd)).style('fill-opacity', null);
  sel.classed('pattern_filled', true);
};

/*
 * Make the gradients container and clear out any previous gradients.
 * We never collect all the gradients we need in one place,
 * so we can't ever remove gradients that have stopped being useful,
 * except all at once before a full redraw.
 * The upside of this is arbitrary points can share gradient defs
 */
drawing.initGradients = function (gd) {
  var fullLayout = gd._fullLayout;
  var gradientsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'gradients');
  gradientsGroup.selectAll('linearGradient,radialGradient').remove();
  d3.select(gd).selectAll('.gradient_filled').classed('gradient_filled', false);
};
drawing.initPatterns = function (gd) {
  var fullLayout = gd._fullLayout;
  var patternsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'patterns');
  patternsGroup.selectAll('pattern').remove();
  d3.select(gd).selectAll('.pattern_filled').classed('pattern_filled', false);
};
drawing.getPatternAttr = function (mp, i, dflt) {
  if (mp && Lib.isArrayOrTypedArray(mp)) {
    return i < mp.length ? mp[i] : dflt;
  }
  return mp;
};
drawing.pointStyle = function (s, trace, gd, pt) {
  if (!s.size()) return;
  var fns = drawing.makePointStyleFns(trace);
  s.each(function (d) {
    drawing.singlePointStyle(d, d3.select(this), trace, fns, gd, pt);
  });
};
drawing.singlePointStyle = function (d, sel, trace, fns, gd, pt) {
  var marker = trace.marker;
  var markerLine = marker.line;
  if (pt && pt.i >= 0 && d.i === undefined) d.i = pt.i;
  sel.style('opacity', fns.selectedOpacityFn ? fns.selectedOpacityFn(d) : d.mo === undefined ? marker.opacity : d.mo);
  if (fns.ms2mrc) {
    var r;

    // handle multi-trace graph edit case
    if (d.ms === 'various' || marker.size === 'various') {
      r = 3;
    } else {
      r = fns.ms2mrc(d.ms);
    }

    // store the calculated size so hover can use it
    d.mrc = r;
    if (fns.selectedSizeFn) {
      r = d.mrc = fns.selectedSizeFn(d);
    }

    // turn the symbol into a sanitized number
    var x = drawing.symbolNumber(d.mx || marker.symbol) || 0;

    // save if this marker is open
    // because that impacts how to handle colors
    d.om = x % 200 >= 100;
    var angle = getMarkerAngle(d, trace);
    var standoff = getMarkerStandoff(d, trace);
    sel.attr('d', makePointPath(x, r, angle, standoff));
  }
  var perPointGradient = false;
  var fillColor, lineColor, lineWidth;

  // 'so' is suspected outliers, for box plots
  if (d.so) {
    lineWidth = markerLine.outlierwidth;
    lineColor = markerLine.outliercolor;
    fillColor = marker.outliercolor;
  } else {
    var markerLineWidth = (markerLine || {}).width;
    lineWidth = (d.mlw + 1 || markerLineWidth + 1 ||
    // TODO: we need the latter for legends... can we get rid of it?
    (d.trace ? (d.trace.marker.line || {}).width : 0) + 1) - 1 || 0;
    if ('mlc' in d) lineColor = d.mlcc = fns.lineScale(d.mlc);
    // weird case: array wasn't long enough to apply to every point
    else if (Lib.isArrayOrTypedArray(markerLine.color)) lineColor = Color.defaultLine;else lineColor = markerLine.color;
    if (Lib.isArrayOrTypedArray(marker.color)) {
      fillColor = Color.defaultLine;
      perPointGradient = true;
    }
    if ('mc' in d) {
      fillColor = d.mcc = fns.markerScale(d.mc);
    } else {
      fillColor = marker.color || marker.colors || 'rgba(0,0,0,0)';
    }
    if (fns.selectedColorFn) {
      fillColor = fns.selectedColorFn(d);
    }
  }
  if (d.om) {
    // open markers can't have zero linewidth, default to 1px,
    // and use fill color as stroke color
    sel.call(Color.stroke, fillColor).style({
      'stroke-width': (lineWidth || 1) + 'px',
      fill: 'none'
    });
  } else {
    sel.style('stroke-width', (d.isBlank ? 0 : lineWidth) + 'px');
    var markerGradient = marker.gradient;
    var gradientType = d.mgt;
    if (gradientType) perPointGradient = true;else gradientType = markerGradient && markerGradient.type;

    // for legend - arrays will propagate through here, but we don't need
    // to treat it as per-point.
    if (Lib.isArrayOrTypedArray(gradientType)) {
      gradientType = gradientType[0];
      if (!gradientInfo[gradientType]) gradientType = 0;
    }
    var markerPattern = marker.pattern;
    var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, d.i, '');
    if (gradientType && gradientType !== 'none') {
      var gradientColor = d.mgc;
      if (gradientColor) perPointGradient = true;else gradientColor = markerGradient.color;
      var gradientID = trace.uid;
      if (perPointGradient) gradientID += '-' + d.i;
      drawing.gradient(sel, gd, gradientID, gradientType, [[0, gradientColor], [1, fillColor]], 'fill');
    } else if (patternShape) {
      var perPointPattern = false;
      var fgcolor = markerPattern.fgcolor;
      if (!fgcolor && pt && pt.color) {
        fgcolor = pt.color;
        perPointPattern = true;
      }
      var patternFGColor = drawing.getPatternAttr(fgcolor, d.i, pt && pt.color || null);
      var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, d.i, null);
      var patternFGOpacity = markerPattern.fgopacity;
      var patternSize = drawing.getPatternAttr(markerPattern.size, d.i, 8);
      var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, d.i, 0.3);
      perPointPattern = perPointPattern || d.mcc || Lib.isArrayOrTypedArray(markerPattern.shape) || Lib.isArrayOrTypedArray(markerPattern.bgcolor) || Lib.isArrayOrTypedArray(markerPattern.fgcolor) || Lib.isArrayOrTypedArray(markerPattern.size) || Lib.isArrayOrTypedArray(markerPattern.solidity);
      var patternID = trace.uid;
      if (perPointPattern) patternID += '-' + d.i;
      drawing.pattern(sel, 'point', gd, patternID, patternShape, patternSize, patternSolidity, d.mcc, markerPattern.fillmode, patternBGColor, patternFGColor, patternFGOpacity);
    } else {
      Lib.isArrayOrTypedArray(fillColor) ? Color.fill(sel, fillColor[d.i]) : Color.fill(sel, fillColor);
    }
    if (lineWidth) {
      Color.stroke(sel, lineColor);
    }
  }
};
drawing.makePointStyleFns = function (trace) {
  var out = {};
  var marker = trace.marker;

  // allow array marker and marker line colors to be
  // scaled by given max and min to colorscales
  out.markerScale = drawing.tryColorscale(marker, '');
  out.lineScale = drawing.tryColorscale(marker, 'line');
  if (Registry.traceIs(trace, 'symbols')) {
    out.ms2mrc = subTypes.isBubble(trace) ? makeBubbleSizeFn(trace) : function () {
      return (marker.size || 6) / 2;
    };
  }
  if (trace.selectedpoints) {
    Lib.extendFlat(out, drawing.makeSelectedPointStyleFns(trace));
  }
  return out;
};
drawing.makeSelectedPointStyleFns = function (trace) {
  var out = {};
  var selectedAttrs = trace.selected || {};
  var unselectedAttrs = trace.unselected || {};
  var marker = trace.marker || {};
  var selectedMarker = selectedAttrs.marker || {};
  var unselectedMarker = unselectedAttrs.marker || {};
  var mo = marker.opacity;
  var smo = selectedMarker.opacity;
  var usmo = unselectedMarker.opacity;
  var smoIsDefined = smo !== undefined;
  var usmoIsDefined = usmo !== undefined;
  if (Lib.isArrayOrTypedArray(mo) || smoIsDefined || usmoIsDefined) {
    out.selectedOpacityFn = function (d) {
      var base = d.mo === undefined ? marker.opacity : d.mo;
      if (d.selected) {
        return smoIsDefined ? smo : base;
      } else {
        return usmoIsDefined ? usmo : DESELECTDIM * base;
      }
    };
  }
  var mc = marker.color;
  var smc = selectedMarker.color;
  var usmc = unselectedMarker.color;
  if (smc || usmc) {
    out.selectedColorFn = function (d) {
      var base = d.mcc || mc;
      if (d.selected) {
        return smc || base;
      } else {
        return usmc || base;
      }
    };
  }
  var ms = marker.size;
  var sms = selectedMarker.size;
  var usms = unselectedMarker.size;
  var smsIsDefined = sms !== undefined;
  var usmsIsDefined = usms !== undefined;
  if (Registry.traceIs(trace, 'symbols') && (smsIsDefined || usmsIsDefined)) {
    out.selectedSizeFn = function (d) {
      var base = d.mrc || ms / 2;
      if (d.selected) {
        return smsIsDefined ? sms / 2 : base;
      } else {
        return usmsIsDefined ? usms / 2 : base;
      }
    };
  }
  return out;
};
drawing.makeSelectedTextStyleFns = function (trace) {
  var out = {};
  var selectedAttrs = trace.selected || {};
  var unselectedAttrs = trace.unselected || {};
  var textFont = trace.textfont || {};
  var selectedTextFont = selectedAttrs.textfont || {};
  var unselectedTextFont = unselectedAttrs.textfont || {};
  var tc = textFont.color;
  var stc = selectedTextFont.color;
  var utc = unselectedTextFont.color;
  out.selectedTextColorFn = function (d) {
    var base = d.tc || tc;
    if (d.selected) {
      return stc || base;
    } else {
      if (utc) return utc;else return stc ? base : Color.addOpacity(base, DESELECTDIM);
    }
  };
  return out;
};
drawing.selectedPointStyle = function (s, trace) {
  if (!s.size() || !trace.selectedpoints) return;
  var fns = drawing.makeSelectedPointStyleFns(trace);
  var marker = trace.marker || {};
  var seq = [];
  if (fns.selectedOpacityFn) {
    seq.push(function (pt, d) {
      pt.style('opacity', fns.selectedOpacityFn(d));
    });
  }
  if (fns.selectedColorFn) {
    seq.push(function (pt, d) {
      Color.fill(pt, fns.selectedColorFn(d));
    });
  }
  if (fns.selectedSizeFn) {
    seq.push(function (pt, d) {
      var mx = d.mx || marker.symbol || 0;
      var mrc2 = fns.selectedSizeFn(d);
      pt.attr('d', makePointPath(drawing.symbolNumber(mx), mrc2, getMarkerAngle(d, trace), getMarkerStandoff(d, trace)));

      // save for Drawing.selectedTextStyle
      d.mrc2 = mrc2;
    });
  }
  if (seq.length) {
    s.each(function (d) {
      var pt = d3.select(this);
      for (var i = 0; i < seq.length; i++) {
        seq[i](pt, d);
      }
    });
  }
};
drawing.tryColorscale = function (marker, prefix) {
  var cont = prefix ? Lib.nestedProperty(marker, prefix).get() : marker;
  if (cont) {
    var colorArray = cont.color;
    if ((cont.colorscale || cont._colorAx) && Lib.isArrayOrTypedArray(colorArray)) {
      return Colorscale.makeColorScaleFuncFromTrace(cont);
    }
  }
  return Lib.identity;
};
var TEXTOFFSETSIGN = {
  start: 1,
  end: -1,
  middle: 0,
  bottom: 1,
  top: -1
};
function textPointPosition(s, textPosition, fontSize, markerRadius, dontTouchParent) {
  var group = d3.select(s.node().parentNode);
  var v = textPosition.indexOf('top') !== -1 ? 'top' : textPosition.indexOf('bottom') !== -1 ? 'bottom' : 'middle';
  var h = textPosition.indexOf('left') !== -1 ? 'end' : textPosition.indexOf('right') !== -1 ? 'start' : 'middle';

  // if markers are shown, offset a little more than
  // the nominal marker size
  // ie 2/1.6 * nominal, bcs some markers are a bit bigger
  var r = markerRadius ? markerRadius / 0.8 + 1 : 0;
  var numLines = (svgTextUtils.lineCount(s) - 1) * LINE_SPACING + 1;
  var dx = TEXTOFFSETSIGN[h] * r;
  var dy = fontSize * 0.75 + TEXTOFFSETSIGN[v] * r + (TEXTOFFSETSIGN[v] - 1) * numLines * fontSize / 2;

  // fix the overall text group position
  s.attr('text-anchor', h);
  if (!dontTouchParent) {
    group.attr('transform', strTranslate(dx, dy));
  }
}
function extracTextFontSize(d, trace) {
  var fontSize = d.ts || trace.textfont.size;
  return isNumeric(fontSize) && fontSize > 0 ? fontSize : 0;
}

// draw text at points
drawing.textPointStyle = function (s, trace, gd) {
  if (!s.size()) return;
  var selectedTextColorFn;
  if (trace.selectedpoints) {
    var fns = drawing.makeSelectedTextStyleFns(trace);
    selectedTextColorFn = fns.selectedTextColorFn;
  }
  var texttemplate = trace.texttemplate;
  var fullLayout = gd._fullLayout;
  s.each(function (d) {
    var p = d3.select(this);
    var text = texttemplate ? Lib.extractOption(d, trace, 'txt', 'texttemplate') : Lib.extractOption(d, trace, 'tx', 'text');
    if (!text && text !== 0) {
      p.remove();
      return;
    }
    if (texttemplate) {
      var fn = trace._module.formatLabels;
      var labels = fn ? fn(d, trace, fullLayout) : {};
      var pointValues = {};
      appendArrayPointValue(pointValues, trace, d.i);
      var meta = trace._meta || {};
      text = Lib.texttemplateString(text, labels, fullLayout._d3locale, pointValues, d, meta);
    }
    var pos = d.tp || trace.textposition;
    var fontSize = extracTextFontSize(d, trace);
    var fontColor = selectedTextColorFn ? selectedTextColorFn(d) : d.tc || trace.textfont.color;
    p.call(drawing.font, d.tf || trace.textfont.family, fontSize, fontColor).text(text).call(svgTextUtils.convertToTspans, gd).call(textPointPosition, pos, fontSize, d.mrc);
  });
};
drawing.selectedTextStyle = function (s, trace) {
  if (!s.size() || !trace.selectedpoints) return;
  var fns = drawing.makeSelectedTextStyleFns(trace);
  s.each(function (d) {
    var tx = d3.select(this);
    var tc = fns.selectedTextColorFn(d);
    var tp = d.tp || trace.textposition;
    var fontSize = extracTextFontSize(d, trace);
    Color.fill(tx, tc);
    var dontTouchParent = Registry.traceIs(trace, 'bar-like');
    textPointPosition(tx, tp, fontSize, d.mrc2 || d.mrc, dontTouchParent);
  });
};

// generalized Catmull-Rom splines, per
// http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
var CatmullRomExp = 0.5;
drawing.smoothopen = function (pts, smoothness) {
  if (pts.length < 3) {
    return 'M' + pts.join('L');
  }
  var path = 'M' + pts[0];
  var tangents = [];
  var i;
  for (i = 1; i < pts.length - 1; i++) {
    tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));
  }
  path += 'Q' + tangents[0][0] + ' ' + pts[1];
  for (i = 2; i < pts.length - 1; i++) {
    path += 'C' + tangents[i - 2][1] + ' ' + tangents[i - 1][0] + ' ' + pts[i];
  }
  path += 'Q' + tangents[pts.length - 3][1] + ' ' + pts[pts.length - 1];
  return path;
};
drawing.smoothclosed = function (pts, smoothness) {
  if (pts.length < 3) {
    return 'M' + pts.join('L') + 'Z';
  }
  var path = 'M' + pts[0];
  var pLast = pts.length - 1;
  var tangents = [makeTangent(pts[pLast], pts[0], pts[1], smoothness)];
  var i;
  for (i = 1; i < pLast; i++) {
    tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));
  }
  tangents.push(makeTangent(pts[pLast - 1], pts[pLast], pts[0], smoothness));
  for (i = 1; i <= pLast; i++) {
    path += 'C' + tangents[i - 1][1] + ' ' + tangents[i][0] + ' ' + pts[i];
  }
  path += 'C' + tangents[pLast][1] + ' ' + tangents[0][0] + ' ' + pts[0] + 'Z';
  return path;
};
var lastDrawnX, lastDrawnY;
function roundEnd(pt, isY, isLastPoint) {
  if (isLastPoint) pt = applyBackoff(pt);
  return isY ? roundY(pt[1]) : roundX(pt[0]);
}
function roundX(p) {
  var v = d3.round(p, 2);
  lastDrawnX = v;
  return v;
}
function roundY(p) {
  var v = d3.round(p, 2);
  lastDrawnY = v;
  return v;
}
function makeTangent(prevpt, thispt, nextpt, smoothness) {
  var d1x = prevpt[0] - thispt[0];
  var d1y = prevpt[1] - thispt[1];
  var d2x = nextpt[0] - thispt[0];
  var d2y = nextpt[1] - thispt[1];
  var d1a = Math.pow(d1x * d1x + d1y * d1y, CatmullRomExp / 2);
  var d2a = Math.pow(d2x * d2x + d2y * d2y, CatmullRomExp / 2);
  var numx = (d2a * d2a * d1x - d1a * d1a * d2x) * smoothness;
  var numy = (d2a * d2a * d1y - d1a * d1a * d2y) * smoothness;
  var denom1 = 3 * d2a * (d1a + d2a);
  var denom2 = 3 * d1a * (d1a + d2a);
  return [[roundX(thispt[0] + (denom1 && numx / denom1)), roundY(thispt[1] + (denom1 && numy / denom1))], [roundX(thispt[0] - (denom2 && numx / denom2)), roundY(thispt[1] - (denom2 && numy / denom2))]];
}

// step paths - returns a generator function for paths
// with the given step shape
var STEPPATH = {
  hv: function (p0, p1, isLastPoint) {
    return 'H' + roundX(p1[0]) + 'V' + roundEnd(p1, 1, isLastPoint);
  },
  vh: function (p0, p1, isLastPoint) {
    return 'V' + roundY(p1[1]) + 'H' + roundEnd(p1, 0, isLastPoint);
  },
  hvh: function (p0, p1, isLastPoint) {
    return 'H' + roundX((p0[0] + p1[0]) / 2) + 'V' + roundY(p1[1]) + 'H' + roundEnd(p1, 0, isLastPoint);
  },
  vhv: function (p0, p1, isLastPoint) {
    return 'V' + roundY((p0[1] + p1[1]) / 2) + 'H' + roundX(p1[0]) + 'V' + roundEnd(p1, 1, isLastPoint);
  }
};
var STEPLINEAR = function (p0, p1, isLastPoint) {
  return 'L' + roundEnd(p1, 0, isLastPoint) + ',' + roundEnd(p1, 1, isLastPoint);
};
drawing.steps = function (shape) {
  var onestep = STEPPATH[shape] || STEPLINEAR;
  return function (pts) {
    var path = 'M' + roundX(pts[0][0]) + ',' + roundY(pts[0][1]);
    var len = pts.length;
    for (var i = 1; i < len; i++) {
      path += onestep(pts[i - 1], pts[i], i === len - 1);
    }
    return path;
  };
};
function applyBackoff(pt, start) {
  var backoff = pt.backoff;
  var trace = pt.trace;
  var d = pt.d;
  var i = pt.i;
  if (backoff && trace && trace.marker && trace.marker.angle % 360 === 0 && trace.line && trace.line.shape !== 'spline') {
    var arrayBackoff = Lib.isArrayOrTypedArray(backoff);
    var end = pt;
    var x1 = start ? start[0] : lastDrawnX || 0;
    var y1 = start ? start[1] : lastDrawnY || 0;
    var x2 = end[0];
    var y2 = end[1];
    var dx = x2 - x1;
    var dy = y2 - y1;
    var t = Math.atan2(dy, dx);
    var b = arrayBackoff ? backoff[i] : backoff;
    if (b === 'auto') {
      var endI = end.i;
      if (trace.type === 'scatter') endI--; // Why we need this hack?

      var endMarker = end.marker;
      var endMarkerSymbol = endMarker.symbol;
      if (Lib.isArrayOrTypedArray(endMarkerSymbol)) endMarkerSymbol = endMarkerSymbol[endI];
      var endMarkerSize = endMarker.size;
      if (Lib.isArrayOrTypedArray(endMarkerSize)) endMarkerSize = endMarkerSize[endI];
      b = endMarker ? drawing.symbolBackOffs[drawing.symbolNumber(endMarkerSymbol)] * endMarkerSize : 0;
      b += drawing.getMarkerStandoff(d[endI], trace) || 0;
    }
    var x = x2 - b * Math.cos(t);
    var y = y2 - b * Math.sin(t);
    if ((x <= x2 && x >= x1 || x >= x2 && x <= x1) && (y <= y2 && y >= y1 || y >= y2 && y <= y1)) {
      pt = [x, y];
    }
  }
  return pt;
}
drawing.applyBackoff = applyBackoff;

// off-screen svg render testing element, shared by the whole page
// uses the id 'js-plotly-tester' and stores it in drawing.tester
drawing.makeTester = function () {
  var tester = Lib.ensureSingleById(d3.select('body'), 'svg', 'js-plotly-tester', function (s) {
    s.attr(xmlnsNamespaces.svgAttrs).style({
      position: 'absolute',
      left: '-10000px',
      top: '-10000px',
      width: '9000px',
      height: '9000px',
      'z-index': '1'
    });
  });

  // browsers differ on how they describe the bounding rect of
  // the svg if its contents spill over... so make a 1x1px
  // reference point we can measure off of.
  var testref = Lib.ensureSingle(tester, 'path', 'js-reference-point', function (s) {
    s.attr('d', 'M0,0H1V1H0Z').style({
      'stroke-width': 0,
      fill: 'black'
    });
  });
  drawing.tester = tester;
  drawing.testref = testref;
};

/*
 * use our offscreen tester to get a clientRect for an element,
 * in a reference frame where it isn't translated (or transformed) and
 * its anchor point is at (0,0)
 * always returns a copy of the bbox, so the caller can modify it safely
 *
 * @param {SVGElement} node: the element to measure. If possible this should be
 *   a <text> or MathJax <g> element that's already passed through
 *   `convertToTspans` because in that case we can cache the results, but it's
 *   possible to pass in any svg element.
 *
 * @param {boolean} inTester: is this element already in `drawing.tester`?
 *   If you are measuring a dummy element, rather than one you really intend
 *   to use on the plot, making it in `drawing.tester` in the first place
 *   allows us to test faster because it cuts out cloning and appending it.
 *
 * @param {string} hash: for internal use only, if we already know the cache key
 *   for this element beforehand.
 *
 * @return {object}: a plain object containing the width, height, left, right,
 *   top, and bottom of `node`
 */
drawing.savedBBoxes = {};
var savedBBoxesCount = 0;
var maxSavedBBoxes = 10000;
drawing.bBox = function (node, inTester, hash) {
  /*
   * Cache elements we've already measured so we don't have to
   * remeasure the same thing many times
   * We have a few bBox callers though who pass a node larger than
   * a <text> or a MathJax <g>, such as an axis group containing many labels.
   * These will not generate a hash (unless we figure out an appropriate
   * hash key for them) and thus we will not hash them.
   */
  if (!hash) hash = nodeHash(node);
  var out;
  if (hash) {
    out = drawing.savedBBoxes[hash];
    if (out) return Lib.extendFlat({}, out);
  } else if (node.childNodes.length === 1) {
    /*
     * If we have only one child element, which is itself hashable, make
     * a new hash from this element plus its x,y,transform
     * These bounding boxes *include* x,y,transform - mostly for use by
     * callers trying to avoid overlaps (ie titles)
     */
    var innerNode = node.childNodes[0];
    hash = nodeHash(innerNode);
    if (hash) {
      var x = +innerNode.getAttribute('x') || 0;
      var y = +innerNode.getAttribute('y') || 0;
      var transform = innerNode.getAttribute('transform');
      if (!transform) {
        // in this case, just varying x and y, don't bother caching
        // the final bBox because the alteration is quick.
        var innerBB = drawing.bBox(innerNode, false, hash);
        if (x) {
          innerBB.left += x;
          innerBB.right += x;
        }
        if (y) {
          innerBB.top += y;
          innerBB.bottom += y;
        }
        return innerBB;
      }
      /*
       * else we have a transform - rather than make a complicated
       * (and error-prone and probably slow) transform parser/calculator,
       * just continue on calculating the boundingClientRect of the group
       * and use the new composite hash to cache it.
       * That said, `innerNode.transform.baseVal` is an array of
       * `SVGTransform` objects, that *do* seem to have a nice matrix
       * multiplication interface that we could use to avoid making
       * another getBoundingClientRect call...
       */
      hash += '~' + x + '~' + y + '~' + transform;
      out = drawing.savedBBoxes[hash];
      if (out) return Lib.extendFlat({}, out);
    }
  }
  var testNode, tester;
  if (inTester) {
    testNode = node;
  } else {
    tester = drawing.tester.node();

    // copy the node to test into the tester
    testNode = node.cloneNode(true);
    tester.appendChild(testNode);
  }

  // standardize its position (and newline tspans if any)
  d3.select(testNode).attr('transform', null).call(svgTextUtils.positionText, 0, 0);
  var testRect = testNode.getBoundingClientRect();
  var refRect = drawing.testref.node().getBoundingClientRect();
  if (!inTester) tester.removeChild(testNode);
  var bb = {
    height: testRect.height,
    width: testRect.width,
    left: testRect.left - refRect.left,
    top: testRect.top - refRect.top,
    right: testRect.right - refRect.left,
    bottom: testRect.bottom - refRect.top
  };

  // make sure we don't have too many saved boxes,
  // or a long session could overload on memory
  // by saving boxes for long-gone elements
  if (savedBBoxesCount >= maxSavedBBoxes) {
    drawing.savedBBoxes = {};
    savedBBoxesCount = 0;
  }

  // cache this bbox
  if (hash) drawing.savedBBoxes[hash] = bb;
  savedBBoxesCount++;
  return Lib.extendFlat({}, bb);
};

// capture everything about a node (at least in our usage) that
// impacts its bounding box, given that bBox clears x, y, and transform
function nodeHash(node) {
  var inputText = node.getAttribute('data-unformatted');
  if (inputText === null) return;
  return inputText + node.getAttribute('data-math') + node.getAttribute('text-anchor') + node.getAttribute('style');
}

/**
 * Set clipPath URL in a way that work for all situations.
 *
 * In details, graphs on pages with <base> HTML tags need to prepend
 * the clip path ids with the page's base url EXCEPT during toImage exports.
 *
 * @param {d3 selection} s : node to add clip-path attribute
 * @param {string} localId : local clip-path (w/o base url) id
 * @param {DOM element || object} gd
 * - context._baseUrl {string}
 * - context._exportedPlot {boolean}
 */
drawing.setClipUrl = function (s, localId, gd) {
  s.attr('clip-path', getFullUrl(localId, gd));
};
function getFullUrl(localId, gd) {
  if (!localId) return null;
  var context = gd._context;
  var baseUrl = context._exportedPlot ? '' : context._baseUrl || '';
  return baseUrl ? 'url(\'' + baseUrl + '#' + localId + '\')' : 'url(#' + localId + ')';
}
drawing.getTranslate = function (element) {
  // Note the separator [^\d] between x and y in this regex
  // We generally use ',' but IE will convert it to ' '
  var re = /.*\btranslate\((-?\d*\.?\d*)[^-\d]*(-?\d*\.?\d*)[^\d].*/;
  var getter = element.attr ? 'attr' : 'getAttribute';
  var transform = element[getter]('transform') || '';
  var translate = transform.replace(re, function (match, p1, p2) {
    return [p1, p2].join(' ');
  }).split(' ');
  return {
    x: +translate[0] || 0,
    y: +translate[1] || 0
  };
};
drawing.setTranslate = function (element, x, y) {
  var re = /(\btranslate\(.*?\);?)/;
  var getter = element.attr ? 'attr' : 'getAttribute';
  var setter = element.attr ? 'attr' : 'setAttribute';
  var transform = element[getter]('transform') || '';
  x = x || 0;
  y = y || 0;
  transform = transform.replace(re, '').trim();
  transform += strTranslate(x, y);
  transform = transform.trim();
  element[setter]('transform', transform);
  return transform;
};
drawing.getScale = function (element) {
  var re = /.*\bscale\((\d*\.?\d*)[^\d]*(\d*\.?\d*)[^\d].*/;
  var getter = element.attr ? 'attr' : 'getAttribute';
  var transform = element[getter]('transform') || '';
  var translate = transform.replace(re, function (match, p1, p2) {
    return [p1, p2].join(' ');
  }).split(' ');
  return {
    x: +translate[0] || 1,
    y: +translate[1] || 1
  };
};
drawing.setScale = function (element, x, y) {
  var re = /(\bscale\(.*?\);?)/;
  var getter = element.attr ? 'attr' : 'getAttribute';
  var setter = element.attr ? 'attr' : 'setAttribute';
  var transform = element[getter]('transform') || '';
  x = x || 1;
  y = y || 1;
  transform = transform.replace(re, '').trim();
  transform += 'scale(' + x + ',' + y + ')';
  transform = transform.trim();
  element[setter]('transform', transform);
  return transform;
};
var SCALE_RE = /\s*sc.*/;
drawing.setPointGroupScale = function (selection, xScale, yScale) {
  xScale = xScale || 1;
  yScale = yScale || 1;
  if (!selection) return;

  // The same scale transform for every point:
  var scale = xScale === 1 && yScale === 1 ? '' : 'scale(' + xScale + ',' + yScale + ')';
  selection.each(function () {
    var t = (this.getAttribute('transform') || '').replace(SCALE_RE, '');
    t += scale;
    t = t.trim();
    this.setAttribute('transform', t);
  });
};
var TEXT_POINT_LAST_TRANSLATION_RE = /translate\([^)]*\)\s*$/;
drawing.setTextPointsScale = function (selection, xScale, yScale) {
  if (!selection) return;
  selection.each(function () {
    var transforms;
    var el = d3.select(this);
    var text = el.select('text');
    if (!text.node()) return;
    var x = parseFloat(text.attr('x') || 0);
    var y = parseFloat(text.attr('y') || 0);
    var existingTransform = (el.attr('transform') || '').match(TEXT_POINT_LAST_TRANSLATION_RE);
    if (xScale === 1 && yScale === 1) {
      transforms = [];
    } else {
      transforms = [strTranslate(x, y), 'scale(' + xScale + ',' + yScale + ')', strTranslate(-x, -y)];
    }
    if (existingTransform) {
      transforms.push(existingTransform);
    }
    el.attr('transform', transforms.join(''));
  });
};
function getMarkerStandoff(d, trace) {
  var standoff;
  if (d) standoff = d.mf;
  if (standoff === undefined) {
    standoff = trace.marker ? trace.marker.standoff || 0 : 0;
  }
  if (!trace._geo && !trace._xA) {
    // case of legends
    return -standoff;
  }
  return standoff;
}
drawing.getMarkerStandoff = getMarkerStandoff;
var atan2 = Math.atan2;
var cos = Math.cos;
var sin = Math.sin;
function rotate(t, xy) {
  var x = xy[0];
  var y = xy[1];
  return [x * cos(t) - y * sin(t), x * sin(t) + y * cos(t)];
}
var previousLon;
var previousLat;
var previousX;
var previousY;
var previousI;
var previousTraceUid;
function getMarkerAngle(d, trace) {
  var angle = d.ma;
  if (angle === undefined) {
    angle = trace.marker.angle || 0;
  }
  var x, y;
  var ref = trace.marker.angleref;
  if (ref === 'previous' || ref === 'north') {
    if (trace._geo) {
      var p = trace._geo.project(d.lonlat);
      x = p[0];
      y = p[1];
    } else {
      var xa = trace._xA;
      var ya = trace._yA;
      if (xa && ya) {
        x = xa.c2p(d.x);
        y = ya.c2p(d.y);
      } else {
        // case of legends
        return 90;
      }
    }
    if (trace._geo) {
      var lon = d.lonlat[0];
      var lat = d.lonlat[1];
      var north = trace._geo.project([lon, lat + 1e-5 // epsilon
      ]);

      var east = trace._geo.project([lon + 1e-5,
      // epsilon
      lat]);
      var u = atan2(east[1] - y, east[0] - x);
      var v = atan2(north[1] - y, north[0] - x);
      var t;
      if (ref === 'north') {
        t = angle / 180 * Math.PI;
        // To use counter-clockwise angles i.e.
        // East: 90, West: -90
        // to facilitate wind visualisations
        // in future we should use t = -t here.
      } else if (ref === 'previous') {
        var lon1 = lon / 180 * Math.PI;
        var lat1 = lat / 180 * Math.PI;
        var lon2 = previousLon / 180 * Math.PI;
        var lat2 = previousLat / 180 * Math.PI;
        var dLon = lon2 - lon1;
        var deltaY = cos(lat2) * sin(dLon);
        var deltaX = sin(lat2) * cos(lat1) - cos(lat2) * sin(lat1) * cos(dLon);
        t = -atan2(deltaY, deltaX) - Math.PI;
        previousLon = lon;
        previousLat = lat;
      }
      var A = rotate(u, [cos(t), 0]);
      var B = rotate(v, [sin(t), 0]);
      angle = atan2(A[1] + B[1], A[0] + B[0]) / Math.PI * 180;
      if (ref === 'previous' && !(previousTraceUid === trace.uid && d.i === previousI + 1)) {
        angle = null;
      }
    }
    if (ref === 'previous' && !trace._geo) {
      if (previousTraceUid === trace.uid && d.i === previousI + 1 && isNumeric(x) && isNumeric(y)) {
        var dX = x - previousX;
        var dY = y - previousY;
        var shape = trace.line ? trace.line.shape || '' : '';
        var lastShapeChar = shape.slice(shape.length - 1);
        if (lastShapeChar === 'h') dY = 0;
        if (lastShapeChar === 'v') dX = 0;
        angle += atan2(dY, dX) / Math.PI * 180 + 90;
      } else {
        angle = null;
      }
    }
  }
  previousX = x;
  previousY = y;
  previousI = d.i;
  previousTraceUid = trace.uid;
  return angle;
}
drawing.getMarkerAngle = getMarkerAngle;

/***/ }),

/***/ 998:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var parseSvgPath = __webpack_require__(5616);
var round = (__webpack_require__(9898).round);

/** Marker symbol definitions
 * users can specify markers either by number or name
 * add 100 (or '-open') and you get an open marker
 *  open markers have no fill and use line color as the stroke color
 * add 200 (or '-dot') and you get a dot in the middle
 * add both and you get both
 */

var emptyPath = 'M0,0Z';
var sqrt2 = Math.sqrt(2);
var sqrt3 = Math.sqrt(3);
var PI = Math.PI;
var cos = Math.cos;
var sin = Math.sin;
module.exports = {
  circle: {
    n: 0,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rs = round(r, 2);
      var circle = 'M' + rs + ',0A' + rs + ',' + rs + ' 0 1,1 0,-' + rs + 'A' + rs + ',' + rs + ' 0 0,1 ' + rs + ',0Z';
      return standoff ? align(angle, standoff, circle) : circle;
    }
  },
  square: {
    n: 1,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rs = round(r, 2);
      return align(angle, standoff, 'M' + rs + ',' + rs + 'H-' + rs + 'V-' + rs + 'H' + rs + 'Z');
    }
  },
  diamond: {
    n: 2,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rd = round(r * 1.3, 2);
      return align(angle, standoff, 'M' + rd + ',0L0,' + rd + 'L-' + rd + ',0L0,-' + rd + 'Z');
    }
  },
  cross: {
    n: 3,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rc = round(r * 0.4, 2);
      var rc2 = round(r * 1.2, 2);
      return align(angle, standoff, 'M' + rc2 + ',' + rc + 'H' + rc + 'V' + rc2 + 'H-' + rc + 'V' + rc + 'H-' + rc2 + 'V-' + rc + 'H-' + rc + 'V-' + rc2 + 'H' + rc + 'V-' + rc + 'H' + rc2 + 'Z');
    }
  },
  x: {
    n: 4,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rx = round(r * 0.8 / sqrt2, 2);
      var ne = 'l' + rx + ',' + rx;
      var se = 'l' + rx + ',-' + rx;
      var sw = 'l-' + rx + ',-' + rx;
      var nw = 'l-' + rx + ',' + rx;
      return align(angle, standoff, 'M0,' + rx + ne + se + sw + se + sw + nw + sw + nw + ne + nw + ne + 'Z');
    }
  },
  'triangle-up': {
    n: 5,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rt = round(r * 2 / sqrt3, 2);
      var r2 = round(r / 2, 2);
      var rs = round(r, 2);
      return align(angle, standoff, 'M-' + rt + ',' + r2 + 'H' + rt + 'L0,-' + rs + 'Z');
    }
  },
  'triangle-down': {
    n: 6,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rt = round(r * 2 / sqrt3, 2);
      var r2 = round(r / 2, 2);
      var rs = round(r, 2);
      return align(angle, standoff, 'M-' + rt + ',-' + r2 + 'H' + rt + 'L0,' + rs + 'Z');
    }
  },
  'triangle-left': {
    n: 7,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rt = round(r * 2 / sqrt3, 2);
      var r2 = round(r / 2, 2);
      var rs = round(r, 2);
      return align(angle, standoff, 'M' + r2 + ',-' + rt + 'V' + rt + 'L-' + rs + ',0Z');
    }
  },
  'triangle-right': {
    n: 8,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rt = round(r * 2 / sqrt3, 2);
      var r2 = round(r / 2, 2);
      var rs = round(r, 2);
      return align(angle, standoff, 'M-' + r2 + ',-' + rt + 'V' + rt + 'L' + rs + ',0Z');
    }
  },
  'triangle-ne': {
    n: 9,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var r1 = round(r * 0.6, 2);
      var r2 = round(r * 1.2, 2);
      return align(angle, standoff, 'M-' + r2 + ',-' + r1 + 'H' + r1 + 'V' + r2 + 'Z');
    }
  },
  'triangle-se': {
    n: 10,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var r1 = round(r * 0.6, 2);
      var r2 = round(r * 1.2, 2);
      return align(angle, standoff, 'M' + r1 + ',-' + r2 + 'V' + r1 + 'H-' + r2 + 'Z');
    }
  },
  'triangle-sw': {
    n: 11,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var r1 = round(r * 0.6, 2);
      var r2 = round(r * 1.2, 2);
      return align(angle, standoff, 'M' + r2 + ',' + r1 + 'H-' + r1 + 'V-' + r2 + 'Z');
    }
  },
  'triangle-nw': {
    n: 12,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var r1 = round(r * 0.6, 2);
      var r2 = round(r * 1.2, 2);
      return align(angle, standoff, 'M-' + r1 + ',' + r2 + 'V-' + r1 + 'H' + r2 + 'Z');
    }
  },
  pentagon: {
    n: 13,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var x1 = round(r * 0.951, 2);
      var x2 = round(r * 0.588, 2);
      var y0 = round(-r, 2);
      var y1 = round(r * -0.309, 2);
      var y2 = round(r * 0.809, 2);
      return align(angle, standoff, 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2 + 'H-' + x2 + 'L-' + x1 + ',' + y1 + 'L0,' + y0 + 'Z');
    }
  },
  hexagon: {
    n: 14,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var y0 = round(r, 2);
      var y1 = round(r / 2, 2);
      var x = round(r * sqrt3 / 2, 2);
      return align(angle, standoff, 'M' + x + ',-' + y1 + 'V' + y1 + 'L0,' + y0 + 'L-' + x + ',' + y1 + 'V-' + y1 + 'L0,-' + y0 + 'Z');
    }
  },
  hexagon2: {
    n: 15,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var x0 = round(r, 2);
      var x1 = round(r / 2, 2);
      var y = round(r * sqrt3 / 2, 2);
      return align(angle, standoff, 'M-' + x1 + ',' + y + 'H' + x1 + 'L' + x0 + ',0L' + x1 + ',-' + y + 'H-' + x1 + 'L-' + x0 + ',0Z');
    }
  },
  octagon: {
    n: 16,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var a = round(r * 0.924, 2);
      var b = round(r * 0.383, 2);
      return align(angle, standoff, 'M-' + b + ',-' + a + 'H' + b + 'L' + a + ',-' + b + 'V' + b + 'L' + b + ',' + a + 'H-' + b + 'L-' + a + ',' + b + 'V-' + b + 'Z');
    }
  },
  star: {
    n: 17,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rs = r * 1.4;
      var x1 = round(rs * 0.225, 2);
      var x2 = round(rs * 0.951, 2);
      var x3 = round(rs * 0.363, 2);
      var x4 = round(rs * 0.588, 2);
      var y0 = round(-rs, 2);
      var y1 = round(rs * -0.309, 2);
      var y3 = round(rs * 0.118, 2);
      var y4 = round(rs * 0.809, 2);
      var y5 = round(rs * 0.382, 2);
      return align(angle, standoff, 'M' + x1 + ',' + y1 + 'H' + x2 + 'L' + x3 + ',' + y3 + 'L' + x4 + ',' + y4 + 'L0,' + y5 + 'L-' + x4 + ',' + y4 + 'L-' + x3 + ',' + y3 + 'L-' + x2 + ',' + y1 + 'H-' + x1 + 'L0,' + y0 + 'Z');
    }
  },
  hexagram: {
    n: 18,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var y = round(r * 0.66, 2);
      var x1 = round(r * 0.38, 2);
      var x2 = round(r * 0.76, 2);
      return align(angle, standoff, 'M-' + x2 + ',0l-' + x1 + ',-' + y + 'h' + x2 + 'l' + x1 + ',-' + y + 'l' + x1 + ',' + y + 'h' + x2 + 'l-' + x1 + ',' + y + 'l' + x1 + ',' + y + 'h-' + x2 + 'l-' + x1 + ',' + y + 'l-' + x1 + ',-' + y + 'h-' + x2 + 'Z');
    }
  },
  'star-triangle-up': {
    n: 19,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var x = round(r * sqrt3 * 0.8, 2);
      var y1 = round(r * 0.8, 2);
      var y2 = round(r * 1.6, 2);
      var rc = round(r * 4, 2);
      var aPart = 'A ' + rc + ',' + rc + ' 0 0 1 ';
      return align(angle, standoff, 'M-' + x + ',' + y1 + aPart + x + ',' + y1 + aPart + '0,-' + y2 + aPart + '-' + x + ',' + y1 + 'Z');
    }
  },
  'star-triangle-down': {
    n: 20,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var x = round(r * sqrt3 * 0.8, 2);
      var y1 = round(r * 0.8, 2);
      var y2 = round(r * 1.6, 2);
      var rc = round(r * 4, 2);
      var aPart = 'A ' + rc + ',' + rc + ' 0 0 1 ';
      return align(angle, standoff, 'M' + x + ',-' + y1 + aPart + '-' + x + ',-' + y1 + aPart + '0,' + y2 + aPart + x + ',-' + y1 + 'Z');
    }
  },
  'star-square': {
    n: 21,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rp = round(r * 1.1, 2);
      var rc = round(r * 2, 2);
      var aPart = 'A ' + rc + ',' + rc + ' 0 0 1 ';
      return align(angle, standoff, 'M-' + rp + ',-' + rp + aPart + '-' + rp + ',' + rp + aPart + rp + ',' + rp + aPart + rp + ',-' + rp + aPart + '-' + rp + ',-' + rp + 'Z');
    }
  },
  'star-diamond': {
    n: 22,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rp = round(r * 1.4, 2);
      var rc = round(r * 1.9, 2);
      var aPart = 'A ' + rc + ',' + rc + ' 0 0 1 ';
      return align(angle, standoff, 'M-' + rp + ',0' + aPart + '0,' + rp + aPart + rp + ',0' + aPart + '0,-' + rp + aPart + '-' + rp + ',0' + 'Z');
    }
  },
  'diamond-tall': {
    n: 23,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var x = round(r * 0.7, 2);
      var y = round(r * 1.4, 2);
      return align(angle, standoff, 'M0,' + y + 'L' + x + ',0L0,-' + y + 'L-' + x + ',0Z');
    }
  },
  'diamond-wide': {
    n: 24,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var x = round(r * 1.4, 2);
      var y = round(r * 0.7, 2);
      return align(angle, standoff, 'M0,' + y + 'L' + x + ',0L0,-' + y + 'L-' + x + ',0Z');
    }
  },
  hourglass: {
    n: 25,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rs = round(r, 2);
      return align(angle, standoff, 'M' + rs + ',' + rs + 'H-' + rs + 'L' + rs + ',-' + rs + 'H-' + rs + 'Z');
    },
    noDot: true
  },
  bowtie: {
    n: 26,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rs = round(r, 2);
      return align(angle, standoff, 'M' + rs + ',' + rs + 'V-' + rs + 'L-' + rs + ',' + rs + 'V-' + rs + 'Z');
    },
    noDot: true
  },
  'circle-cross': {
    n: 27,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rs = round(r, 2);
      return align(angle, standoff, 'M0,' + rs + 'V-' + rs + 'M' + rs + ',0H-' + rs + 'M' + rs + ',0A' + rs + ',' + rs + ' 0 1,1 0,-' + rs + 'A' + rs + ',' + rs + ' 0 0,1 ' + rs + ',0Z');
    },
    needLine: true,
    noDot: true
  },
  'circle-x': {
    n: 28,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rs = round(r, 2);
      var rc = round(r / sqrt2, 2);
      return align(angle, standoff, 'M' + rc + ',' + rc + 'L-' + rc + ',-' + rc + 'M' + rc + ',-' + rc + 'L-' + rc + ',' + rc + 'M' + rs + ',0A' + rs + ',' + rs + ' 0 1,1 0,-' + rs + 'A' + rs + ',' + rs + ' 0 0,1 ' + rs + ',0Z');
    },
    needLine: true,
    noDot: true
  },
  'square-cross': {
    n: 29,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rs = round(r, 2);
      return align(angle, standoff, 'M0,' + rs + 'V-' + rs + 'M' + rs + ',0H-' + rs + 'M' + rs + ',' + rs + 'H-' + rs + 'V-' + rs + 'H' + rs + 'Z');
    },
    needLine: true,
    noDot: true
  },
  'square-x': {
    n: 30,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rs = round(r, 2);
      return align(angle, standoff, 'M' + rs + ',' + rs + 'L-' + rs + ',-' + rs + 'M' + rs + ',-' + rs + 'L-' + rs + ',' + rs + 'M' + rs + ',' + rs + 'H-' + rs + 'V-' + rs + 'H' + rs + 'Z');
    },
    needLine: true,
    noDot: true
  },
  'diamond-cross': {
    n: 31,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rd = round(r * 1.3, 2);
      return align(angle, standoff, 'M' + rd + ',0L0,' + rd + 'L-' + rd + ',0L0,-' + rd + 'Z' + 'M0,-' + rd + 'V' + rd + 'M-' + rd + ',0H' + rd);
    },
    needLine: true,
    noDot: true
  },
  'diamond-x': {
    n: 32,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rd = round(r * 1.3, 2);
      var r2 = round(r * 0.65, 2);
      return align(angle, standoff, 'M' + rd + ',0L0,' + rd + 'L-' + rd + ',0L0,-' + rd + 'Z' + 'M-' + r2 + ',-' + r2 + 'L' + r2 + ',' + r2 + 'M-' + r2 + ',' + r2 + 'L' + r2 + ',-' + r2);
    },
    needLine: true,
    noDot: true
  },
  'cross-thin': {
    n: 33,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rc = round(r * 1.4, 2);
      return align(angle, standoff, 'M0,' + rc + 'V-' + rc + 'M' + rc + ',0H-' + rc);
    },
    needLine: true,
    noDot: true,
    noFill: true
  },
  'x-thin': {
    n: 34,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rx = round(r, 2);
      return align(angle, standoff, 'M' + rx + ',' + rx + 'L-' + rx + ',-' + rx + 'M' + rx + ',-' + rx + 'L-' + rx + ',' + rx);
    },
    needLine: true,
    noDot: true,
    noFill: true
  },
  asterisk: {
    n: 35,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rc = round(r * 1.2, 2);
      var rs = round(r * 0.85, 2);
      return align(angle, standoff, 'M0,' + rc + 'V-' + rc + 'M' + rc + ',0H-' + rc + 'M' + rs + ',' + rs + 'L-' + rs + ',-' + rs + 'M' + rs + ',-' + rs + 'L-' + rs + ',' + rs);
    },
    needLine: true,
    noDot: true,
    noFill: true
  },
  hash: {
    n: 36,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var r1 = round(r / 2, 2);
      var r2 = round(r, 2);
      return align(angle, standoff, 'M' + r1 + ',' + r2 + 'V-' + r2 + 'M' + (r1 - r2) + ',-' + r2 + 'V' + r2 + 'M' + r2 + ',' + r1 + 'H-' + r2 + 'M-' + r2 + ',' + (r1 - r2) + 'H' + r2);
    },
    needLine: true,
    noFill: true
  },
  'y-up': {
    n: 37,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var x = round(r * 1.2, 2);
      var y0 = round(r * 1.6, 2);
      var y1 = round(r * 0.8, 2);
      return align(angle, standoff, 'M-' + x + ',' + y1 + 'L0,0M' + x + ',' + y1 + 'L0,0M0,-' + y0 + 'L0,0');
    },
    needLine: true,
    noDot: true,
    noFill: true
  },
  'y-down': {
    n: 38,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var x = round(r * 1.2, 2);
      var y0 = round(r * 1.6, 2);
      var y1 = round(r * 0.8, 2);
      return align(angle, standoff, 'M-' + x + ',-' + y1 + 'L0,0M' + x + ',-' + y1 + 'L0,0M0,' + y0 + 'L0,0');
    },
    needLine: true,
    noDot: true,
    noFill: true
  },
  'y-left': {
    n: 39,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var y = round(r * 1.2, 2);
      var x0 = round(r * 1.6, 2);
      var x1 = round(r * 0.8, 2);
      return align(angle, standoff, 'M' + x1 + ',' + y + 'L0,0M' + x1 + ',-' + y + 'L0,0M-' + x0 + ',0L0,0');
    },
    needLine: true,
    noDot: true,
    noFill: true
  },
  'y-right': {
    n: 40,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var y = round(r * 1.2, 2);
      var x0 = round(r * 1.6, 2);
      var x1 = round(r * 0.8, 2);
      return align(angle, standoff, 'M-' + x1 + ',' + y + 'L0,0M-' + x1 + ',-' + y + 'L0,0M' + x0 + ',0L0,0');
    },
    needLine: true,
    noDot: true,
    noFill: true
  },
  'line-ew': {
    n: 41,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rc = round(r * 1.4, 2);
      return align(angle, standoff, 'M' + rc + ',0H-' + rc);
    },
    needLine: true,
    noDot: true,
    noFill: true
  },
  'line-ns': {
    n: 42,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rc = round(r * 1.4, 2);
      return align(angle, standoff, 'M0,' + rc + 'V-' + rc);
    },
    needLine: true,
    noDot: true,
    noFill: true
  },
  'line-ne': {
    n: 43,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rx = round(r, 2);
      return align(angle, standoff, 'M' + rx + ',-' + rx + 'L-' + rx + ',' + rx);
    },
    needLine: true,
    noDot: true,
    noFill: true
  },
  'line-nw': {
    n: 44,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rx = round(r, 2);
      return align(angle, standoff, 'M' + rx + ',' + rx + 'L-' + rx + ',-' + rx);
    },
    needLine: true,
    noDot: true,
    noFill: true
  },
  'arrow-up': {
    n: 45,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rx = round(r, 2);
      var ry = round(r * 2, 2);
      return align(angle, standoff, 'M0,0L-' + rx + ',' + ry + 'H' + rx + 'Z');
    },
    backoff: 1,
    noDot: true
  },
  'arrow-down': {
    n: 46,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rx = round(r, 2);
      var ry = round(r * 2, 2);
      return align(angle, standoff, 'M0,0L-' + rx + ',-' + ry + 'H' + rx + 'Z');
    },
    noDot: true
  },
  'arrow-left': {
    n: 47,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rx = round(r * 2, 2);
      var ry = round(r, 2);
      return align(angle, standoff, 'M0,0L' + rx + ',-' + ry + 'V' + ry + 'Z');
    },
    noDot: true
  },
  'arrow-right': {
    n: 48,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rx = round(r * 2, 2);
      var ry = round(r, 2);
      return align(angle, standoff, 'M0,0L-' + rx + ',-' + ry + 'V' + ry + 'Z');
    },
    noDot: true
  },
  'arrow-bar-up': {
    n: 49,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rx = round(r, 2);
      var ry = round(r * 2, 2);
      return align(angle, standoff, 'M-' + rx + ',0H' + rx + 'M0,0L-' + rx + ',' + ry + 'H' + rx + 'Z');
    },
    backoff: 1,
    needLine: true,
    noDot: true
  },
  'arrow-bar-down': {
    n: 50,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rx = round(r, 2);
      var ry = round(r * 2, 2);
      return align(angle, standoff, 'M-' + rx + ',0H' + rx + 'M0,0L-' + rx + ',-' + ry + 'H' + rx + 'Z');
    },
    needLine: true,
    noDot: true
  },
  'arrow-bar-left': {
    n: 51,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rx = round(r * 2, 2);
      var ry = round(r, 2);
      return align(angle, standoff, 'M0,-' + ry + 'V' + ry + 'M0,0L' + rx + ',-' + ry + 'V' + ry + 'Z');
    },
    needLine: true,
    noDot: true
  },
  'arrow-bar-right': {
    n: 52,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var rx = round(r * 2, 2);
      var ry = round(r, 2);
      return align(angle, standoff, 'M0,-' + ry + 'V' + ry + 'M0,0L-' + rx + ',-' + ry + 'V' + ry + 'Z');
    },
    needLine: true,
    noDot: true
  },
  arrow: {
    n: 53,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var headAngle = PI / 2.5; // 36 degrees - golden ratio
      var x = 2 * r * cos(headAngle);
      var y = 2 * r * sin(headAngle);
      return align(angle, standoff, 'M0,0' + 'L' + -x + ',' + y + 'L' + x + ',' + y + 'Z');
    },
    backoff: 0.9,
    noDot: true
  },
  'arrow-wide': {
    n: 54,
    f: function (r, angle, standoff) {
      if (skipAngle(angle)) return emptyPath;
      var headAngle = PI / 4; // 90 degrees
      var x = 2 * r * cos(headAngle);
      var y = 2 * r * sin(headAngle);
      return align(angle, standoff, 'M0,0' + 'L' + -x + ',' + y + 'A ' + 2 * r + ',' + 2 * r + ' 0 0 1 ' + x + ',' + y + 'Z');
    },
    backoff: 0.4,
    noDot: true
  }
};
function skipAngle(angle) {
  return angle === null;
}
var lastPathIn, lastPathOut;
var lastAngle, lastStandoff;
function align(angle, standoff, path) {
  if ((!angle || angle % 360 === 0) && !standoff) return path;
  if (lastAngle === angle && lastStandoff === standoff && lastPathIn === path) return lastPathOut;
  lastAngle = angle;
  lastStandoff = standoff;
  lastPathIn = path;
  function rotate(t, xy) {
    var cosT = cos(t);
    var sinT = sin(t);
    var x = xy[0];
    var y = xy[1] + (standoff || 0);
    return [x * cosT - y * sinT, x * sinT + y * cosT];
  }
  var t = angle / 180 * PI;
  var x = 0;
  var y = 0;
  var cmd = parseSvgPath(path);
  var str = '';
  for (var i = 0; i < cmd.length; i++) {
    var cmdI = cmd[i];
    var op = cmdI[0];
    var x0 = x;
    var y0 = y;
    if (op === 'M' || op === 'L') {
      x = +cmdI[1];
      y = +cmdI[2];
    } else if (op === 'm' || op === 'l') {
      x += +cmdI[1];
      y += +cmdI[2];
    } else if (op === 'H') {
      x = +cmdI[1];
    } else if (op === 'h') {
      x += +cmdI[1];
    } else if (op === 'V') {
      y = +cmdI[1];
    } else if (op === 'v') {
      y += +cmdI[1];
    } else if (op === 'A') {
      x = +cmdI[1];
      y = +cmdI[2];
      var E = rotate(t, [+cmdI[6], +cmdI[7]]);
      cmdI[6] = E[0];
      cmdI[7] = E[1];
      cmdI[3] = +cmdI[3] + angle;
    }

    // change from H, V, h, v to L or l
    if (op === 'H' || op === 'V') op = 'L';
    if (op === 'h' || op === 'v') op = 'l';
    if (op === 'm' || op === 'l') {
      x -= x0;
      y -= y0;
    }
    var B = rotate(t, [x, y]);
    if (op === 'H' || op === 'V') op = 'L';
    if (op === 'M' || op === 'L' || op === 'm' || op === 'l') {
      cmdI[1] = B[0];
      cmdI[2] = B[1];
    }
    cmdI[0] = op;
    str += cmdI[0] + cmdI.slice(1).join(',');
  }
  lastPathOut = str;
  return str;
}

/***/ }),

/***/ 5673:
/***/ (function(module) {

"use strict";


module.exports = {
  visible: {
    valType: 'boolean',
    editType: 'calc'
  },
  type: {
    valType: 'enumerated',
    values: ['percent', 'constant', 'sqrt', 'data'],
    editType: 'calc'
  },
  symmetric: {
    valType: 'boolean',
    editType: 'calc'
  },
  array: {
    valType: 'data_array',
    editType: 'calc'
  },
  arrayminus: {
    valType: 'data_array',
    editType: 'calc'
  },
  value: {
    valType: 'number',
    min: 0,
    dflt: 10,
    editType: 'calc'
  },
  valueminus: {
    valType: 'number',
    min: 0,
    dflt: 10,
    editType: 'calc'
  },
  traceref: {
    valType: 'integer',
    min: 0,
    dflt: 0,
    editType: 'style'
  },
  tracerefminus: {
    valType: 'integer',
    min: 0,
    dflt: 0,
    editType: 'style'
  },
  copy_ystyle: {
    valType: 'boolean',
    editType: 'plot'
  },
  copy_zstyle: {
    valType: 'boolean',
    editType: 'style'
  },
  color: {
    valType: 'color',
    editType: 'style'
  },
  thickness: {
    valType: 'number',
    min: 0,
    dflt: 2,
    editType: 'style'
  },
  width: {
    valType: 'number',
    min: 0,
    editType: 'plot'
  },
  editType: 'calc',
  _deprecated: {
    opacity: {
      valType: 'number',
      editType: 'style'
    }
  }
};

/***/ }),

/***/ 4532:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var Registry = __webpack_require__(3972);
var Axes = __webpack_require__(9298);
var Lib = __webpack_require__(1828);
var makeComputeError = __webpack_require__(5827);
module.exports = function calc(gd) {
  var calcdata = gd.calcdata;
  for (var i = 0; i < calcdata.length; i++) {
    var calcTrace = calcdata[i];
    var trace = calcTrace[0].trace;
    if (trace.visible === true && Registry.traceIs(trace, 'errorBarsOK')) {
      var xa = Axes.getFromId(gd, trace.xaxis);
      var ya = Axes.getFromId(gd, trace.yaxis);
      calcOneAxis(calcTrace, trace, xa, 'x');
      calcOneAxis(calcTrace, trace, ya, 'y');
    }
  }
};
function calcOneAxis(calcTrace, trace, axis, coord) {
  var opts = trace['error_' + coord] || {};
  var isVisible = opts.visible && ['linear', 'log'].indexOf(axis.type) !== -1;
  var vals = [];
  if (!isVisible) return;
  var computeError = makeComputeError(opts);
  for (var i = 0; i < calcTrace.length; i++) {
    var calcPt = calcTrace[i];
    var iIn = calcPt.i;

    // for types that don't include `i` in each calcdata point
    if (iIn === undefined) iIn = i;

    // for stacked area inserted points
    // TODO: errorbars have been tested cursorily with stacked area,
    // but not thoroughly. It's not even really clear what you want to do:
    // Should it just be calculated based on that trace's size data?
    // Should you add errors from below in quadrature?
    // And what about normalization, where in principle the errors shrink
    // again when you get up to the top end?
    // One option would be to forbid errorbars with stacking until we
    // decide how to handle these questions.
    else if (iIn === null) continue;
    var calcCoord = calcPt[coord];
    if (!isNumeric(axis.c2l(calcCoord))) continue;
    var errors = computeError(calcCoord, iIn);
    if (isNumeric(errors[0]) && isNumeric(errors[1])) {
      var shoe = calcPt[coord + 's'] = calcCoord - errors[0];
      var hat = calcPt[coord + 'h'] = calcCoord + errors[1];
      vals.push(shoe, hat);
    }
  }
  var axId = axis._id;
  var baseExtremes = trace._extremes[axId];
  var extremes = Axes.findExtremes(axis, vals, Lib.extendFlat({
    tozero: baseExtremes.opts.tozero
  }, {
    padded: true
  }));
  baseExtremes.min = baseExtremes.min.concat(extremes.min);
  baseExtremes.max = baseExtremes.max.concat(extremes.max);
}

/***/ }),

/***/ 5827:
/***/ (function(module) {

"use strict";


/**
 * Error bar computing function generator
 *
 * N.B. The generated function does not clean the dataPt entries. Non-numeric
 * entries result in undefined error magnitudes.
 *
 * @param {object} opts error bar attributes
 *
 * @return {function} :
 *      @param {numeric} dataPt data point from where to compute the error magnitude
 *      @param {number} index index of dataPt in its corresponding data array
 *      @return {array}
 *        - error[0] : error magnitude in the negative direction
 *        - error[1] : " " " " positive "
 */
module.exports = function makeComputeError(opts) {
  var type = opts.type;
  var symmetric = opts.symmetric;
  if (type === 'data') {
    var array = opts.array || [];
    if (symmetric) {
      return function computeError(dataPt, index) {
        var val = +array[index];
        return [val, val];
      };
    } else {
      var arrayminus = opts.arrayminus || [];
      return function computeError(dataPt, index) {
        var val = +array[index];
        var valMinus = +arrayminus[index];
        // in case one is present and the other is missing, fill in 0
        // so we still see the present one. Mostly useful during manual
        // data entry.
        if (!isNaN(val) || !isNaN(valMinus)) {
          return [valMinus || 0, val || 0];
        }
        return [NaN, NaN];
      };
    }
  } else {
    var computeErrorValue = makeComputeErrorValue(type, opts.value);
    var computeErrorValueMinus = makeComputeErrorValue(type, opts.valueminus);
    if (symmetric || opts.valueminus === undefined) {
      return function computeError(dataPt) {
        var val = computeErrorValue(dataPt);
        return [val, val];
      };
    } else {
      return function computeError(dataPt) {
        return [computeErrorValueMinus(dataPt), computeErrorValue(dataPt)];
      };
    }
  }
};

/**
 * Compute error bar magnitude (for all types except data)
 *
 * @param {string} type error bar type
 * @param {numeric} value error bar value
 *
 * @return {function} :
 *      @param {numeric} dataPt
 */
function makeComputeErrorValue(type, value) {
  if (type === 'percent') {
    return function (dataPt) {
      return Math.abs(dataPt * value / 100);
    };
  }
  if (type === 'constant') {
    return function () {
      return Math.abs(value);
    };
  }
  if (type === 'sqrt') {
    return function (dataPt) {
      return Math.sqrt(Math.abs(dataPt));
    };
  }
}

/***/ }),

/***/ 7587:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var Template = __webpack_require__(4467);
var attributes = __webpack_require__(5673);
module.exports = function (traceIn, traceOut, defaultColor, opts) {
  var objName = 'error_' + opts.axis;
  var containerOut = Template.newContainer(traceOut, objName);
  var containerIn = traceIn[objName] || {};
  function coerce(attr, dflt) {
    return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
  }
  var hasErrorBars = containerIn.array !== undefined || containerIn.value !== undefined || containerIn.type === 'sqrt';
  var visible = coerce('visible', hasErrorBars);
  if (visible === false) return;
  var type = coerce('type', 'array' in containerIn ? 'data' : 'percent');
  var symmetric = true;
  if (type !== 'sqrt') {
    symmetric = coerce('symmetric', !((type === 'data' ? 'arrayminus' : 'valueminus') in containerIn));
  }
  if (type === 'data') {
    coerce('array');
    coerce('traceref');
    if (!symmetric) {
      coerce('arrayminus');
      coerce('tracerefminus');
    }
  } else if (type === 'percent' || type === 'constant') {
    coerce('value');
    if (!symmetric) coerce('valueminus');
  }
  var copyAttr = 'copy_' + opts.inherit + 'style';
  if (opts.inherit) {
    var inheritObj = traceOut['error_' + opts.inherit];
    if ((inheritObj || {}).visible) {
      coerce(copyAttr, !(containerIn.color || isNumeric(containerIn.thickness) || isNumeric(containerIn.width)));
    }
  }
  if (!opts.inherit || !containerOut[copyAttr]) {
    coerce('color', defaultColor);
    coerce('thickness');
    coerce('width', Registry.traceIs(traceOut, 'gl3d') ? 0 : 4);
  }
};

/***/ }),

/***/ 7369:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var overrideAll = (__webpack_require__(962).overrideAll);
var attributes = __webpack_require__(5673);
var xyAttrs = {
  error_x: Lib.extendFlat({}, attributes),
  error_y: Lib.extendFlat({}, attributes)
};
delete xyAttrs.error_x.copy_zstyle;
delete xyAttrs.error_y.copy_zstyle;
delete xyAttrs.error_y.copy_ystyle;
var xyzAttrs = {
  error_x: Lib.extendFlat({}, attributes),
  error_y: Lib.extendFlat({}, attributes),
  error_z: Lib.extendFlat({}, attributes)
};
delete xyzAttrs.error_x.copy_ystyle;
delete xyzAttrs.error_y.copy_ystyle;
delete xyzAttrs.error_z.copy_ystyle;
delete xyzAttrs.error_z.copy_zstyle;
module.exports = {
  moduleType: 'component',
  name: 'errorbars',
  schema: {
    traces: {
      scatter: xyAttrs,
      bar: xyAttrs,
      histogram: xyAttrs,
      scatter3d: overrideAll(xyzAttrs, 'calc', 'nested'),
      scattergl: overrideAll(xyAttrs, 'calc', 'nested')
    }
  },
  supplyDefaults: __webpack_require__(7587),
  calc: __webpack_require__(4532),
  makeComputeError: __webpack_require__(5827),
  plot: __webpack_require__(9398),
  style: __webpack_require__(2662),
  hoverInfo: hoverInfo
};
function hoverInfo(calcPoint, trace, hoverPoint) {
  if ((trace.error_y || {}).visible) {
    hoverPoint.yerr = calcPoint.yh - calcPoint.y;
    if (!trace.error_y.symmetric) hoverPoint.yerrneg = calcPoint.y - calcPoint.ys;
  }
  if ((trace.error_x || {}).visible) {
    hoverPoint.xerr = calcPoint.xh - calcPoint.x;
    if (!trace.error_x.symmetric) hoverPoint.xerrneg = calcPoint.x - calcPoint.xs;
  }
}

/***/ }),

/***/ 9398:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var isNumeric = __webpack_require__(2770);
var Drawing = __webpack_require__(1424);
var subTypes = __webpack_require__(4098);
module.exports = function plot(gd, traces, plotinfo, transitionOpts) {
  var isNew;
  var xa = plotinfo.xaxis;
  var ya = plotinfo.yaxis;
  var hasAnimation = transitionOpts && transitionOpts.duration > 0;
  var isStatic = gd._context.staticPlot;
  traces.each(function (d) {
    var trace = d[0].trace;
    // || {} is in case the trace (specifically scatterternary)
    // doesn't support error bars at all, but does go through
    // the scatter.plot mechanics, which calls ErrorBars.plot
    // internally
    var xObj = trace.error_x || {};
    var yObj = trace.error_y || {};
    var keyFunc;
    if (trace.ids) {
      keyFunc = function (d) {
        return d.id;
      };
    }
    var sparse = subTypes.hasMarkers(trace) && trace.marker.maxdisplayed > 0;
    if (!yObj.visible && !xObj.visible) d = [];
    var errorbars = d3.select(this).selectAll('g.errorbar').data(d, keyFunc);
    errorbars.exit().remove();
    if (!d.length) return;
    if (!xObj.visible) errorbars.selectAll('path.xerror').remove();
    if (!yObj.visible) errorbars.selectAll('path.yerror').remove();
    errorbars.style('opacity', 1);
    var enter = errorbars.enter().append('g').classed('errorbar', true);
    if (hasAnimation) {
      enter.style('opacity', 0).transition().duration(transitionOpts.duration).style('opacity', 1);
    }
    Drawing.setClipUrl(errorbars, plotinfo.layerClipId, gd);
    errorbars.each(function (d) {
      var errorbar = d3.select(this);
      var coords = errorCoords(d, xa, ya);
      if (sparse && !d.vis) return;
      var path;
      var yerror = errorbar.select('path.yerror');
      if (yObj.visible && isNumeric(coords.x) && isNumeric(coords.yh) && isNumeric(coords.ys)) {
        var yw = yObj.width;
        path = 'M' + (coords.x - yw) + ',' + coords.yh + 'h' + 2 * yw +
        // hat
        'm-' + yw + ',0V' + coords.ys; // bar

        if (!coords.noYS) path += 'm-' + yw + ',0h' + 2 * yw; // shoe

        isNew = !yerror.size();
        if (isNew) {
          yerror = errorbar.append('path').style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke').classed('yerror', true);
        } else if (hasAnimation) {
          yerror = yerror.transition().duration(transitionOpts.duration).ease(transitionOpts.easing);
        }
        yerror.attr('d', path);
      } else yerror.remove();
      var xerror = errorbar.select('path.xerror');
      if (xObj.visible && isNumeric(coords.y) && isNumeric(coords.xh) && isNumeric(coords.xs)) {
        var xw = (xObj.copy_ystyle ? yObj : xObj).width;
        path = 'M' + coords.xh + ',' + (coords.y - xw) + 'v' + 2 * xw +
        // hat
        'm0,-' + xw + 'H' + coords.xs; // bar

        if (!coords.noXS) path += 'm0,-' + xw + 'v' + 2 * xw; // shoe

        isNew = !xerror.size();
        if (isNew) {
          xerror = errorbar.append('path').style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke').classed('xerror', true);
        } else if (hasAnimation) {
          xerror = xerror.transition().duration(transitionOpts.duration).ease(transitionOpts.easing);
        }
        xerror.attr('d', path);
      } else xerror.remove();
    });
  });
};

// compute the coordinates of the error-bar objects
function errorCoords(d, xa, ya) {
  var out = {
    x: xa.c2p(d.x),
    y: ya.c2p(d.y)
  };

  // calculate the error bar size and hat and shoe locations
  if (d.yh !== undefined) {
    out.yh = ya.c2p(d.yh);
    out.ys = ya.c2p(d.ys);

    // if the shoes go off-scale (ie log scale, error bars past zero)
    // clip the bar and hide the shoes
    if (!isNumeric(out.ys)) {
      out.noYS = true;
      out.ys = ya.c2p(d.ys, true);
    }
  }
  if (d.xh !== undefined) {
    out.xh = xa.c2p(d.xh);
    out.xs = xa.c2p(d.xs);
    if (!isNumeric(out.xs)) {
      out.noXS = true;
      out.xs = xa.c2p(d.xs, true);
    }
  }
  return out;
}

/***/ }),

/***/ 2662:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Color = __webpack_require__(7901);
module.exports = function style(traces) {
  traces.each(function (d) {
    var trace = d[0].trace;
    var yObj = trace.error_y || {};
    var xObj = trace.error_x || {};
    var s = d3.select(this);
    s.selectAll('path.yerror').style('stroke-width', yObj.thickness + 'px').call(Color.stroke, yObj.color);
    if (xObj.copy_ystyle) xObj = yObj;
    s.selectAll('path.xerror').style('stroke-width', xObj.thickness + 'px').call(Color.stroke, xObj.color);
  });
};

/***/ }),

/***/ 7914:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var fontAttrs = __webpack_require__(1940);
var hoverLabelAttrs = (__webpack_require__(528).hoverlabel);
var extendFlat = (__webpack_require__(1426).extendFlat);
module.exports = {
  hoverlabel: {
    bgcolor: extendFlat({}, hoverLabelAttrs.bgcolor, {
      arrayOk: true
    }),
    bordercolor: extendFlat({}, hoverLabelAttrs.bordercolor, {
      arrayOk: true
    }),
    font: fontAttrs({
      arrayOk: true,
      editType: 'none'
    }),
    align: extendFlat({}, hoverLabelAttrs.align, {
      arrayOk: true
    }),
    namelength: extendFlat({}, hoverLabelAttrs.namelength, {
      arrayOk: true
    }),
    editType: 'none'
  }
};

/***/ }),

/***/ 732:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Registry = __webpack_require__(3972);
module.exports = function calc(gd) {
  var calcdata = gd.calcdata;
  var fullLayout = gd._fullLayout;
  function makeCoerceHoverInfo(trace) {
    return function (val) {
      return Lib.coerceHoverinfo({
        hoverinfo: val
      }, {
        _module: trace._module
      }, fullLayout);
    };
  }
  for (var i = 0; i < calcdata.length; i++) {
    var cd = calcdata[i];
    var trace = cd[0].trace;

    // don't include hover calc fields for pie traces
    // as calcdata items might be sorted by value and
    // won't match the data array order.
    if (Registry.traceIs(trace, 'pie-like')) continue;
    var fillFn = Registry.traceIs(trace, '2dMap') ? paste : Lib.fillArray;
    fillFn(trace.hoverinfo, cd, 'hi', makeCoerceHoverInfo(trace));
    if (trace.hovertemplate) fillFn(trace.hovertemplate, cd, 'ht');
    if (!trace.hoverlabel) continue;
    fillFn(trace.hoverlabel.bgcolor, cd, 'hbg');
    fillFn(trace.hoverlabel.bordercolor, cd, 'hbc');
    fillFn(trace.hoverlabel.font.size, cd, 'hts');
    fillFn(trace.hoverlabel.font.color, cd, 'htc');
    fillFn(trace.hoverlabel.font.family, cd, 'htf');
    fillFn(trace.hoverlabel.namelength, cd, 'hnl');
    fillFn(trace.hoverlabel.align, cd, 'hta');
  }
};
function paste(traceAttr, cd, cdAttr, fn) {
  fn = fn || Lib.identity;
  if (Array.isArray(traceAttr)) {
    cd[0][cdAttr] = fn(traceAttr);
  }
}

/***/ }),

/***/ 5914:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);
var hover = (__webpack_require__(8335).hover);
module.exports = function click(gd, evt, subplot) {
  var annotationsDone = Registry.getComponentMethod('annotations', 'onClick')(gd, gd._hoverdata);

  // fallback to fail-safe in case the plot type's hover method doesn't pass the subplot.
  // Ternary, for example, didn't, but it was caught because tested.
  if (subplot !== undefined) {
    // The true flag at the end causes it to re-run the hover computation to figure out *which*
    // point is being clicked. Without this, clicking is somewhat unreliable.
    hover(gd, evt, subplot, true);
  }
  function emitClick() {
    gd.emit('plotly_click', {
      points: gd._hoverdata,
      event: evt
    });
  }
  if (gd._hoverdata && evt && evt.target) {
    if (annotationsDone && annotationsDone.then) {
      annotationsDone.then(emitClick);
    } else emitClick();

    // why do we get a double event without this???
    if (evt.stopImmediatePropagation) evt.stopImmediatePropagation();
  }
};

/***/ }),

/***/ 6675:
/***/ (function(module) {

"use strict";


module.exports = {
  // hover labels for multiple horizontal bars get tilted by this angle
  YANGLE: 60,
  // size and display constants for hover text

  // pixel size of hover arrows
  HOVERARROWSIZE: 6,
  // pixels padding around text
  HOVERTEXTPAD: 3,
  // hover font
  HOVERFONTSIZE: 13,
  HOVERFONT: 'Arial, sans-serif',
  // minimum time (msec) between hover calls
  HOVERMINTIME: 50,
  // ID suffix (with fullLayout._uid) for hover events in the throttle cache
  HOVERID: '-hover'
};

/***/ }),

/***/ 4268:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var attributes = __webpack_require__(7914);
var handleHoverLabelDefaults = __webpack_require__(8048);
module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
  function coerce(attr, dflt) {
    return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
  }
  var opts = Lib.extendFlat({}, layout.hoverlabel);
  if (traceOut.hovertemplate) opts.namelength = -1;
  handleHoverLabelDefaults(traceIn, traceOut, coerce, opts);
};

/***/ }),

/***/ 3469:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);

// look for either subplot or xaxis and yaxis attributes
// does not handle splom case
exports.getSubplot = function (trace) {
  return trace.subplot || trace.xaxis + trace.yaxis || trace.geo;
};

// is trace in given list of subplots?
// does handle splom case
exports.isTraceInSubplots = function (trace, subplots) {
  if (trace.type === 'splom') {
    var xaxes = trace.xaxes || [];
    var yaxes = trace.yaxes || [];
    for (var i = 0; i < xaxes.length; i++) {
      for (var j = 0; j < yaxes.length; j++) {
        if (subplots.indexOf(xaxes[i] + yaxes[j]) !== -1) {
          return true;
        }
      }
    }
    return false;
  }
  return subplots.indexOf(exports.getSubplot(trace)) !== -1;
};

// convenience functions for mapping all relevant axes
exports.flat = function (subplots, v) {
  var out = new Array(subplots.length);
  for (var i = 0; i < subplots.length; i++) {
    out[i] = v;
  }
  return out;
};
exports.p2c = function (axArray, v) {
  var out = new Array(axArray.length);
  for (var i = 0; i < axArray.length; i++) {
    out[i] = axArray[i].p2c(v);
  }
  return out;
};
exports.getDistanceFunction = function (mode, dx, dy, dxy) {
  if (mode === 'closest') return dxy || exports.quadrature(dx, dy);
  return mode.charAt(0) === 'x' ? dx : dy;
};
exports.getClosest = function (cd, distfn, pointData) {
  // do we already have a point number? (array mode only)
  if (pointData.index !== false) {
    if (pointData.index >= 0 && pointData.index < cd.length) {
      pointData.distance = 0;
    } else pointData.index = false;
  } else {
    // apply the distance function to each data point
    // this is the longest loop... if this bogs down, we may need
    // to create pre-sorted data (by x or y), not sure how to
    // do this for 'closest'
    for (var i = 0; i < cd.length; i++) {
      var newDistance = distfn(cd[i]);
      if (newDistance <= pointData.distance) {
        pointData.index = i;
        pointData.distance = newDistance;
      }
    }
  }
  return pointData;
};

/*
 * pseudo-distance function for hover effects on areas: inside the region
 * distance is finite (`passVal`), outside it's Infinity.
 *
 * @param {number} v0: signed difference between the current position and the left edge
 * @param {number} v1: signed difference between the current position and the right edge
 * @param {number} passVal: the value to return on success
 */
exports.inbox = function (v0, v1, passVal) {
  return v0 * v1 < 0 || v0 === 0 ? passVal : Infinity;
};
exports.quadrature = function (dx, dy) {
  return function (di) {
    var x = dx(di);
    var y = dy(di);
    return Math.sqrt(x * x + y * y);
  };
};

/** Fill event data point object for hover and selection.
 *  Invokes _module.eventData if present.
 *
 * N.B. note that point 'index' corresponds to input data array index
 *  whereas 'number' is its post-transform version.
 *
 * If the hovered/selected pt corresponds to an multiple input points
 * (e.g. for histogram and transformed traces), 'pointNumbers` and 'pointIndices'
 * are include in the event data.
 *
 * @param {object} pt
 * @param {object} trace
 * @param {object} cd
 * @return {object}
 */
exports.makeEventData = function (pt, trace, cd) {
  // hover uses 'index', select uses 'pointNumber'
  var pointNumber = 'index' in pt ? pt.index : pt.pointNumber;
  var out = {
    data: trace._input,
    fullData: trace,
    curveNumber: trace.index,
    pointNumber: pointNumber
  };
  if (trace._indexToPoints) {
    var pointIndices = trace._indexToPoints[pointNumber];
    if (pointIndices.length === 1) {
      out.pointIndex = pointIndices[0];
    } else {
      out.pointIndices = pointIndices;
    }
  } else {
    out.pointIndex = pointNumber;
  }
  if (trace._module.eventData) {
    out = trace._module.eventData(out, pt, trace, cd, pointNumber);
  } else {
    if ('xVal' in pt) out.x = pt.xVal;else if ('x' in pt) out.x = pt.x;
    if ('yVal' in pt) out.y = pt.yVal;else if ('y' in pt) out.y = pt.y;
    if (pt.xa) out.xaxis = pt.xa;
    if (pt.ya) out.yaxis = pt.ya;
    if (pt.zLabelVal !== undefined) out.z = pt.zLabelVal;
  }
  exports.appendArrayPointValue(out, trace, pointNumber);
  return out;
};

/** Appends values inside array attributes corresponding to given point number
 *
 * @param {object} pointData : point data object (gets mutated here)
 * @param {object} trace : full trace object
 * @param {number|Array(number)} pointNumber : point number. May be a length-2 array
 *     [row, col] to dig into 2D arrays
 */
exports.appendArrayPointValue = function (pointData, trace, pointNumber) {
  var arrayAttrs = trace._arrayAttrs;
  if (!arrayAttrs) {
    return;
  }
  for (var i = 0; i < arrayAttrs.length; i++) {
    var astr = arrayAttrs[i];
    var key = getPointKey(astr);
    if (pointData[key] === undefined) {
      var val = Lib.nestedProperty(trace, astr).get();
      var pointVal = getPointData(val, pointNumber);
      if (pointVal !== undefined) pointData[key] = pointVal;
    }
  }
};

/**
 * Appends values inside array attributes corresponding to given point number array
 * For use when pointData references a plot entity that arose (or potentially arose)
 * from multiple points in the input data
 *
 * @param {object} pointData : point data object (gets mutated here)
 * @param {object} trace : full trace object
 * @param {Array(number)|Array(Array(number))} pointNumbers : Array of point numbers.
 *     Each entry in the array may itself be a length-2 array [row, col] to dig into 2D arrays
 */
exports.appendArrayMultiPointValues = function (pointData, trace, pointNumbers) {
  var arrayAttrs = trace._arrayAttrs;
  if (!arrayAttrs) {
    return;
  }
  for (var i = 0; i < arrayAttrs.length; i++) {
    var astr = arrayAttrs[i];
    var key = getPointKey(astr);
    if (pointData[key] === undefined) {
      var val = Lib.nestedProperty(trace, astr).get();
      var keyVal = new Array(pointNumbers.length);
      for (var j = 0; j < pointNumbers.length; j++) {
        keyVal[j] = getPointData(val, pointNumbers[j]);
      }
      pointData[key] = keyVal;
    }
  }
};
var pointKeyMap = {
  ids: 'id',
  locations: 'location',
  labels: 'label',
  values: 'value',
  'marker.colors': 'color',
  parents: 'parent'
};
function getPointKey(astr) {
  return pointKeyMap[astr] || astr;
}
function getPointData(val, pointNumber) {
  if (Array.isArray(pointNumber)) {
    if (Array.isArray(val) && Array.isArray(val[pointNumber[0]])) {
      return val[pointNumber[0]][pointNumber[1]];
    }
  } else {
    return val[pointNumber];
  }
}
var xyHoverMode = {
  x: true,
  y: true
};
var unifiedHoverMode = {
  'x unified': true,
  'y unified': true
};
exports.isUnifiedHover = function (hovermode) {
  if (typeof hovermode !== 'string') return false;
  return !!unifiedHoverMode[hovermode];
};
exports.isXYhover = function (hovermode) {
  if (typeof hovermode !== 'string') return false;
  return !!xyHoverMode[hovermode];
};

/***/ }),

/***/ 8335:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var isNumeric = __webpack_require__(2770);
var tinycolor = __webpack_require__(4267);
var Lib = __webpack_require__(1828);
var strTranslate = Lib.strTranslate;
var strRotate = Lib.strRotate;
var Events = __webpack_require__(1086);
var svgTextUtils = __webpack_require__(3893);
var overrideCursor = __webpack_require__(9918);
var Drawing = __webpack_require__(1424);
var Color = __webpack_require__(7901);
var dragElement = __webpack_require__(8569);
var Axes = __webpack_require__(9298);
var Registry = __webpack_require__(3972);
var helpers = __webpack_require__(3469);
var constants = __webpack_require__(6675);
var legendSupplyDefaults = __webpack_require__(9017);
var legendDraw = __webpack_require__(3969);

// hover labels for multiple horizontal bars get tilted by some angle,
// then need to be offset differently if they overlap
var YANGLE = constants.YANGLE;
var YA_RADIANS = Math.PI * YANGLE / 180;

// expansion of projected height
var YFACTOR = 1 / Math.sin(YA_RADIANS);

// to make the appropriate post-rotation x offset,
// you need both x and y offsets
var YSHIFTX = Math.cos(YA_RADIANS);
var YSHIFTY = Math.sin(YA_RADIANS);

// size and display constants for hover text
var HOVERARROWSIZE = constants.HOVERARROWSIZE;
var HOVERTEXTPAD = constants.HOVERTEXTPAD;
var multipleHoverPoints = {
  box: true,
  ohlc: true,
  violin: true,
  candlestick: true
};
var cartesianScatterPoints = {
  scatter: true,
  scattergl: true,
  splom: true
};

// fx.hover: highlight data on hover
// evt can be a mousemove event, or an object with data about what points
//   to hover on
//      {xpx,ypx[,hovermode]} - pixel locations from top left
//          (with optional overriding hovermode)
//      {xval,yval[,hovermode]} - data values
//      [{curveNumber,(pointNumber|xval and/or yval)}] -
//              array of specific points to highlight
//          pointNumber is a single integer if gd.data[curveNumber] is 1D,
//              or a two-element array if it's 2D
//          xval and yval are data values,
//              1D data may specify either or both,
//              2D data must specify both
// subplot is an id string (default "xy")
// makes use of gl.hovermode, which can be:
//      x (find the points with the closest x values, ie a column),
//      closest (find the single closest point)
//    internally there are two more that occasionally get used:
//      y (pick out a row - only used for multiple horizontal bar charts)
//      array (used when the user specifies an explicit
//          array of points to hover on)
//
// We wrap the hovers in a timer, to limit their frequency.
// The actual rendering is done by private function _hover.
exports.hover = function hover(gd, evt, subplot, noHoverEvent) {
  gd = Lib.getGraphDiv(gd);
  // The 'target' property changes when bubbling out of Shadow DOM.
  // Throttling can delay reading the target, so we save the current value.
  var eventTarget = evt.target;
  Lib.throttle(gd._fullLayout._uid + constants.HOVERID, constants.HOVERMINTIME, function () {
    _hover(gd, evt, subplot, noHoverEvent, eventTarget);
  });
};

/*
 * Draw a single hover item or an array of hover item in a pre-existing svg container somewhere
 * hoverItem should have keys:
 *    - x and y (or x0, x1, y0, and y1):
 *      the pixel position to mark, relative to opts.container
 *    - xLabel, yLabel, zLabel, text, and name:
 *      info to go in the label
 *    - color:
 *      the background color for the label.
 *    - idealAlign (optional):
 *      'left' or 'right' for which side of the x/y box to try to put this on first
 *    - borderColor (optional):
 *      color for the border, defaults to strongest contrast with color
 *    - fontFamily (optional):
 *      string, the font for this label, defaults to constants.HOVERFONT
 *    - fontSize (optional):
 *      the label font size, defaults to constants.HOVERFONTSIZE
 *    - fontColor (optional):
 *      defaults to borderColor
 * opts should have keys:
 *    - bgColor:
 *      the background color this is against, used if the trace is
 *      non-opaque, and for the name, which goes outside the box
 *    - container:
 *      a <svg> or <g> element to add the hover label to
 *    - outerContainer:
 *      normally a parent of `container`, sets the bounding box to use to
 *      constrain the hover label and determine whether to show it on the left or right
 * opts can have optional keys:
 *    - anchorIndex:
        the index of the hover item used as an anchor for positioning.
        The other hover items will be pushed up or down to prevent overlap.
 */
exports.loneHover = function loneHover(hoverItems, opts) {
  var multiHover = true;
  if (!Array.isArray(hoverItems)) {
    multiHover = false;
    hoverItems = [hoverItems];
  }
  var gd = opts.gd;
  var gTop = getTopOffset(gd);
  var gLeft = getLeftOffset(gd);
  var pointsData = hoverItems.map(function (hoverItem) {
    var _x0 = hoverItem._x0 || hoverItem.x0 || hoverItem.x || 0;
    var _x1 = hoverItem._x1 || hoverItem.x1 || hoverItem.x || 0;
    var _y0 = hoverItem._y0 || hoverItem.y0 || hoverItem.y || 0;
    var _y1 = hoverItem._y1 || hoverItem.y1 || hoverItem.y || 0;
    var eventData = hoverItem.eventData;
    if (eventData) {
      var x0 = Math.min(_x0, _x1);
      var x1 = Math.max(_x0, _x1);
      var y0 = Math.min(_y0, _y1);
      var y1 = Math.max(_y0, _y1);
      var trace = hoverItem.trace;
      if (Registry.traceIs(trace, 'gl3d')) {
        var container = gd._fullLayout[trace.scene]._scene.container;
        var dx = container.offsetLeft;
        var dy = container.offsetTop;
        x0 += dx;
        x1 += dx;
        y0 += dy;
        y1 += dy;
      } // TODO: handle heatmapgl

      eventData.bbox = {
        x0: x0 + gLeft,
        x1: x1 + gLeft,
        y0: y0 + gTop,
        y1: y1 + gTop
      };
      if (opts.inOut_bbox) {
        opts.inOut_bbox.push(eventData.bbox);
      }
    } else {
      eventData = false;
    }
    return {
      color: hoverItem.color || Color.defaultLine,
      x0: hoverItem.x0 || hoverItem.x || 0,
      x1: hoverItem.x1 || hoverItem.x || 0,
      y0: hoverItem.y0 || hoverItem.y || 0,
      y1: hoverItem.y1 || hoverItem.y || 0,
      xLabel: hoverItem.xLabel,
      yLabel: hoverItem.yLabel,
      zLabel: hoverItem.zLabel,
      text: hoverItem.text,
      name: hoverItem.name,
      idealAlign: hoverItem.idealAlign,
      // optional extra bits of styling
      borderColor: hoverItem.borderColor,
      fontFamily: hoverItem.fontFamily,
      fontSize: hoverItem.fontSize,
      fontColor: hoverItem.fontColor,
      nameLength: hoverItem.nameLength,
      textAlign: hoverItem.textAlign,
      // filler to make createHoverText happy
      trace: hoverItem.trace || {
        index: 0,
        hoverinfo: ''
      },
      xa: {
        _offset: 0
      },
      ya: {
        _offset: 0
      },
      index: 0,
      hovertemplate: hoverItem.hovertemplate || false,
      hovertemplateLabels: hoverItem.hovertemplateLabels || false,
      eventData: eventData
    };
  });
  var rotateLabels = false;
  var hoverText = createHoverText(pointsData, {
    gd: gd,
    hovermode: 'closest',
    rotateLabels: rotateLabels,
    bgColor: opts.bgColor || Color.background,
    container: d3.select(opts.container),
    outerContainer: opts.outerContainer || opts.container
  });
  var hoverLabel = hoverText.hoverLabels;

  // Fix vertical overlap
  var tooltipSpacing = 5;
  var lastBottomY = 0;
  var anchor = 0;
  hoverLabel.sort(function (a, b) {
    return a.y0 - b.y0;
  }).each(function (d, i) {
    var topY = d.y0 - d.by / 2;
    if (topY - tooltipSpacing < lastBottomY) {
      d.offset = lastBottomY - topY + tooltipSpacing;
    } else {
      d.offset = 0;
    }
    lastBottomY = topY + d.by + d.offset;
    if (i === opts.anchorIndex || 0) anchor = d.offset;
  }).each(function (d) {
    d.offset -= anchor;
  });
  var scaleX = gd._fullLayout._invScaleX;
  var scaleY = gd._fullLayout._invScaleY;
  alignHoverText(hoverLabel, rotateLabels, scaleX, scaleY);
  return multiHover ? hoverLabel : hoverLabel.node();
};

// The actual implementation is here:
function _hover(gd, evt, subplot, noHoverEvent, eventTarget) {
  if (!subplot) subplot = 'xy';

  // if the user passed in an array of subplots,
  // use those instead of finding overlayed plots
  var subplots = Array.isArray(subplot) ? subplot : [subplot];
  var fullLayout = gd._fullLayout;
  var plots = fullLayout._plots || [];
  var plotinfo = plots[subplot];
  var hasCartesian = fullLayout._has('cartesian');

  // list of all overlaid subplots to look at
  if (plotinfo) {
    var overlayedSubplots = plotinfo.overlays.map(function (pi) {
      return pi.id;
    });
    subplots = subplots.concat(overlayedSubplots);
  }
  var len = subplots.length;
  var xaArray = new Array(len);
  var yaArray = new Array(len);
  var supportsCompare = false;
  for (var i = 0; i < len; i++) {
    var spId = subplots[i];
    if (plots[spId]) {
      // 'cartesian' case
      supportsCompare = true;
      xaArray[i] = plots[spId].xaxis;
      yaArray[i] = plots[spId].yaxis;
    } else if (fullLayout[spId] && fullLayout[spId]._subplot) {
      // other subplot types
      var _subplot = fullLayout[spId]._subplot;
      xaArray[i] = _subplot.xaxis;
      yaArray[i] = _subplot.yaxis;
    } else {
      Lib.warn('Unrecognized subplot: ' + spId);
      return;
    }
  }
  var hovermode = evt.hovermode || fullLayout.hovermode;
  if (hovermode && !supportsCompare) hovermode = 'closest';
  if (['x', 'y', 'closest', 'x unified', 'y unified'].indexOf(hovermode) === -1 || !gd.calcdata || gd.querySelector('.zoombox') || gd._dragging) {
    return dragElement.unhoverRaw(gd, evt);
  }
  var hoverdistance = fullLayout.hoverdistance;
  if (hoverdistance === -1) hoverdistance = Infinity;
  var spikedistance = fullLayout.spikedistance;
  if (spikedistance === -1) spikedistance = Infinity;

  // hoverData: the set of candidate points we've found to highlight
  var hoverData = [];

  // searchData: the data to search in. Mostly this is just a copy of
  // gd.calcdata, filtered to the subplot and overlays we're on
  // but if a point array is supplied it will be a mapping
  // of indicated curves
  var searchData = [];

  // [x|y]valArray: the axis values of the hover event
  // mapped onto each of the currently selected overlaid subplots
  var xvalArray, yvalArray;
  var itemnum, curvenum, cd, trace, subplotId, subploti, _mode, xval, yval, pointData, closedataPreviousLength;

  // spikePoints: the set of candidate points we've found to draw spikes to
  var spikePoints = {
    hLinePoint: null,
    vLinePoint: null
  };

  // does subplot have one (or more) horizontal traces?
  // This is used to determine whether we rotate the labels or not
  var hasOneHorizontalTrace = false;

  // Figure out what we're hovering on:
  // mouse location or user-supplied data

  if (Array.isArray(evt)) {
    // user specified an array of points to highlight
    hovermode = 'array';
    for (itemnum = 0; itemnum < evt.length; itemnum++) {
      cd = gd.calcdata[evt[itemnum].curveNumber || 0];
      if (cd) {
        trace = cd[0].trace;
        if (cd[0].trace.hoverinfo !== 'skip') {
          searchData.push(cd);
          if (trace.orientation === 'h') {
            hasOneHorizontalTrace = true;
          }
        }
      }
    }
  } else {
    for (curvenum = 0; curvenum < gd.calcdata.length; curvenum++) {
      cd = gd.calcdata[curvenum];
      trace = cd[0].trace;
      if (trace.hoverinfo !== 'skip' && helpers.isTraceInSubplots(trace, subplots)) {
        searchData.push(cd);
        if (trace.orientation === 'h') {
          hasOneHorizontalTrace = true;
        }
      }
    }

    // [x|y]px: the pixels (from top left) of the mouse location
    // on the currently selected plot area
    // add pointerX|Y property for drawing the spikes in spikesnap 'cursor' situation
    var hasUserCalledHover = !eventTarget;
    var xpx, ypx;
    if (hasUserCalledHover) {
      if ('xpx' in evt) xpx = evt.xpx;else xpx = xaArray[0]._length / 2;
      if ('ypx' in evt) ypx = evt.ypx;else ypx = yaArray[0]._length / 2;
    } else {
      // fire the beforehover event and quit if it returns false
      // note that we're only calling this on real mouse events, so
      // manual calls to fx.hover will always run.
      if (Events.triggerHandler(gd, 'plotly_beforehover', evt) === false) {
        return;
      }
      var dbb = eventTarget.getBoundingClientRect();
      xpx = evt.clientX - dbb.left;
      ypx = evt.clientY - dbb.top;
      fullLayout._calcInverseTransform(gd);
      var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(xpx, ypx);
      xpx = transformedCoords[0];
      ypx = transformedCoords[1];

      // in case hover was called from mouseout into hovertext,
      // it's possible you're not actually over the plot anymore
      if (xpx < 0 || xpx > xaArray[0]._length || ypx < 0 || ypx > yaArray[0]._length) {
        return dragElement.unhoverRaw(gd, evt);
      }
    }
    evt.pointerX = xpx + xaArray[0]._offset;
    evt.pointerY = ypx + yaArray[0]._offset;
    if ('xval' in evt) xvalArray = helpers.flat(subplots, evt.xval);else xvalArray = helpers.p2c(xaArray, xpx);
    if ('yval' in evt) yvalArray = helpers.flat(subplots, evt.yval);else yvalArray = helpers.p2c(yaArray, ypx);
    if (!isNumeric(xvalArray[0]) || !isNumeric(yvalArray[0])) {
      Lib.warn('Fx.hover failed', evt, gd);
      return dragElement.unhoverRaw(gd, evt);
    }
  }

  // the pixel distance to beat as a matching point
  // in 'x' or 'y' mode this resets for each trace
  var distance = Infinity;

  // find the closest point in each trace
  // this is minimum dx and/or dy, depending on mode
  // and the pixel position for the label (labelXpx, labelYpx)
  function findHoverPoints(customXVal, customYVal) {
    for (curvenum = 0; curvenum < searchData.length; curvenum++) {
      cd = searchData[curvenum];

      // filter out invisible or broken data
      if (!cd || !cd[0] || !cd[0].trace) continue;
      trace = cd[0].trace;
      if (trace.visible !== true || trace._length === 0) continue;

      // Explicitly bail out for these two. I don't know how to otherwise prevent
      // the rest of this function from running and failing
      if (['carpet', 'contourcarpet'].indexOf(trace._module.name) !== -1) continue;
      if (trace.type === 'splom') {
        // splom traces do not generate overlay subplots,
        // it is safe to assume here splom traces correspond to the 0th subplot
        subploti = 0;
        subplotId = subplots[subploti];
      } else {
        subplotId = helpers.getSubplot(trace);
        subploti = subplots.indexOf(subplotId);
      }

      // within one trace mode can sometimes be overridden
      _mode = hovermode;
      if (helpers.isUnifiedHover(_mode)) {
        _mode = _mode.charAt(0);
      }

      // container for new point, also used to pass info into module.hoverPoints
      pointData = {
        // trace properties
        cd: cd,
        trace: trace,
        xa: xaArray[subploti],
        ya: yaArray[subploti],
        // max distances for hover and spikes - for points that want to show but do not
        // want to override other points, set distance/spikeDistance equal to max*Distance
        // and it will not get filtered out but it will be guaranteed to have a greater
        // distance than any point that calculated a real distance.
        maxHoverDistance: hoverdistance,
        maxSpikeDistance: spikedistance,
        // point properties - override all of these
        index: false,
        // point index in trace - only used by plotly.js hoverdata consumers
        distance: Math.min(distance, hoverdistance),
        // pixel distance or pseudo-distance

        // distance/pseudo-distance for spikes. This distance should always be calculated
        // as if in "closest" mode, and should only be set if this point should
        // generate a spike.
        spikeDistance: Infinity,
        // in some cases the spikes have different positioning from the hover label
        // they don't need x0/x1, just one position
        xSpike: undefined,
        ySpike: undefined,
        // where and how to display the hover label
        color: Color.defaultLine,
        // trace color
        name: trace.name,
        x0: undefined,
        x1: undefined,
        y0: undefined,
        y1: undefined,
        xLabelVal: undefined,
        yLabelVal: undefined,
        zLabelVal: undefined,
        text: undefined
      };

      // add ref to subplot object (non-cartesian case)
      if (fullLayout[subplotId]) {
        pointData.subplot = fullLayout[subplotId]._subplot;
      }
      // add ref to splom scene
      if (fullLayout._splomScenes && fullLayout._splomScenes[trace.uid]) {
        pointData.scene = fullLayout._splomScenes[trace.uid];
      }
      closedataPreviousLength = hoverData.length;

      // for a highlighting array, figure out what
      // we're searching for with this element
      if (_mode === 'array') {
        var selection = evt[curvenum];
        if ('pointNumber' in selection) {
          pointData.index = selection.pointNumber;
          _mode = 'closest';
        } else {
          _mode = '';
          if ('xval' in selection) {
            xval = selection.xval;
            _mode = 'x';
          }
          if ('yval' in selection) {
            yval = selection.yval;
            _mode = _mode ? 'closest' : 'y';
          }
        }
      } else if (customXVal !== undefined && customYVal !== undefined) {
        xval = customXVal;
        yval = customYVal;
      } else {
        xval = xvalArray[subploti];
        yval = yvalArray[subploti];
      }

      // Now if there is range to look in, find the points to hover.
      if (hoverdistance !== 0) {
        if (trace._module && trace._module.hoverPoints) {
          var newPoints = trace._module.hoverPoints(pointData, xval, yval, _mode, {
            finiteRange: true,
            hoverLayer: fullLayout._hoverlayer
          });
          if (newPoints) {
            var newPoint;
            for (var newPointNum = 0; newPointNum < newPoints.length; newPointNum++) {
              newPoint = newPoints[newPointNum];
              if (isNumeric(newPoint.x0) && isNumeric(newPoint.y0)) {
                hoverData.push(cleanPoint(newPoint, hovermode));
              }
            }
          }
        } else {
          Lib.log('Unrecognized trace type in hover:', trace);
        }
      }

      // in closest mode, remove any existing (farther) points
      // and don't look any farther than this latest point (or points, some
      // traces like box & violin make multiple hover labels at once)
      if (hovermode === 'closest' && hoverData.length > closedataPreviousLength) {
        hoverData.splice(0, closedataPreviousLength);
        distance = hoverData[0].distance;
      }

      // Now if there is range to look in, find the points to draw the spikelines
      // Do it only if there is no hoverData
      if (hasCartesian && spikedistance !== 0) {
        if (hoverData.length === 0) {
          pointData.distance = spikedistance;
          pointData.index = false;
          var closestPoints = trace._module.hoverPoints(pointData, xval, yval, 'closest', {
            hoverLayer: fullLayout._hoverlayer
          });
          if (closestPoints) {
            closestPoints = closestPoints.filter(function (point) {
              // some hover points, like scatter fills, do not allow spikes,
              // so will generate a hover point but without a valid spikeDistance
              return point.spikeDistance <= spikedistance;
            });
          }
          if (closestPoints && closestPoints.length) {
            var tmpPoint;
            var closestVPoints = closestPoints.filter(function (point) {
              return point.xa.showspikes && point.xa.spikesnap !== 'hovered data';
            });
            if (closestVPoints.length) {
              var closestVPt = closestVPoints[0];
              if (isNumeric(closestVPt.x0) && isNumeric(closestVPt.y0)) {
                tmpPoint = fillSpikePoint(closestVPt);
                if (!spikePoints.vLinePoint || spikePoints.vLinePoint.spikeDistance > tmpPoint.spikeDistance) {
                  spikePoints.vLinePoint = tmpPoint;
                }
              }
            }
            var closestHPoints = closestPoints.filter(function (point) {
              return point.ya.showspikes && point.ya.spikesnap !== 'hovered data';
            });
            if (closestHPoints.length) {
              var closestHPt = closestHPoints[0];
              if (isNumeric(closestHPt.x0) && isNumeric(closestHPt.y0)) {
                tmpPoint = fillSpikePoint(closestHPt);
                if (!spikePoints.hLinePoint || spikePoints.hLinePoint.spikeDistance > tmpPoint.spikeDistance) {
                  spikePoints.hLinePoint = tmpPoint;
                }
              }
            }
          }
        }
      }
    }
  }
  findHoverPoints();
  function selectClosestPoint(pointsData, spikedistance, spikeOnWinning) {
    var resultPoint = null;
    var minDistance = Infinity;
    var thisSpikeDistance;
    for (var i = 0; i < pointsData.length; i++) {
      thisSpikeDistance = pointsData[i].spikeDistance;
      if (spikeOnWinning && i === 0) thisSpikeDistance = -Infinity;
      if (thisSpikeDistance <= minDistance && thisSpikeDistance <= spikedistance) {
        resultPoint = pointsData[i];
        minDistance = thisSpikeDistance;
      }
    }
    return resultPoint;
  }
  function fillSpikePoint(point) {
    if (!point) return null;
    return {
      xa: point.xa,
      ya: point.ya,
      x: point.xSpike !== undefined ? point.xSpike : (point.x0 + point.x1) / 2,
      y: point.ySpike !== undefined ? point.ySpike : (point.y0 + point.y1) / 2,
      distance: point.distance,
      spikeDistance: point.spikeDistance,
      curveNumber: point.trace.index,
      color: point.color,
      pointNumber: point.index
    };
  }
  var spikelineOpts = {
    fullLayout: fullLayout,
    container: fullLayout._hoverlayer,
    event: evt
  };
  var oldspikepoints = gd._spikepoints;
  var newspikepoints = {
    vLinePoint: spikePoints.vLinePoint,
    hLinePoint: spikePoints.hLinePoint
  };
  gd._spikepoints = newspikepoints;
  var sortHoverData = function () {
    hoverData.sort(function (d1, d2) {
      return d1.distance - d2.distance;
    });

    // move period positioned points and box/bar-like traces to the end of the list
    hoverData = orderRangePoints(hoverData, hovermode);
  };
  sortHoverData();
  var axLetter = hovermode.charAt(0);
  var spikeOnWinning = (axLetter === 'x' || axLetter === 'y') && hoverData[0] && cartesianScatterPoints[hoverData[0].trace.type];

  // Now if it is not restricted by spikedistance option, set the points to draw the spikelines
  if (hasCartesian && spikedistance !== 0) {
    if (hoverData.length !== 0) {
      var tmpHPointData = hoverData.filter(function (point) {
        return point.ya.showspikes;
      });
      var tmpHPoint = selectClosestPoint(tmpHPointData, spikedistance, spikeOnWinning);
      spikePoints.hLinePoint = fillSpikePoint(tmpHPoint);
      var tmpVPointData = hoverData.filter(function (point) {
        return point.xa.showspikes;
      });
      var tmpVPoint = selectClosestPoint(tmpVPointData, spikedistance, spikeOnWinning);
      spikePoints.vLinePoint = fillSpikePoint(tmpVPoint);
    }
  }

  // if hoverData is empty check for the spikes to draw and quit if there are none
  if (hoverData.length === 0) {
    var result = dragElement.unhoverRaw(gd, evt);
    if (hasCartesian && (spikePoints.hLinePoint !== null || spikePoints.vLinePoint !== null)) {
      if (spikesChanged(oldspikepoints)) {
        createSpikelines(gd, spikePoints, spikelineOpts);
      }
    }
    return result;
  }
  if (hasCartesian) {
    if (spikesChanged(oldspikepoints)) {
      createSpikelines(gd, spikePoints, spikelineOpts);
    }
  }
  if (helpers.isXYhover(_mode) && hoverData[0].length !== 0 && hoverData[0].trace.type !== 'splom' // TODO: add support for splom
  ) {
    // pick winning point
    var winningPoint = hoverData[0];
    // discard other points
    if (multipleHoverPoints[winningPoint.trace.type]) {
      hoverData = hoverData.filter(function (d) {
        return d.trace.index === winningPoint.trace.index;
      });
    } else {
      hoverData = [winningPoint];
    }
    var initLen = hoverData.length;
    var winX = getCoord('x', winningPoint, fullLayout);
    var winY = getCoord('y', winningPoint, fullLayout);

    // in compare mode, select every point at position
    findHoverPoints(winX, winY);
    var finalPoints = [];
    var seen = {};
    var id = 0;
    var insert = function (newHd) {
      var key = multipleHoverPoints[newHd.trace.type] ? hoverDataKey(newHd) : newHd.trace.index;
      if (!seen[key]) {
        id++;
        seen[key] = id;
        finalPoints.push(newHd);
      } else {
        var oldId = seen[key] - 1;
        var oldHd = finalPoints[oldId];
        if (oldId > 0 && Math.abs(newHd.distance) < Math.abs(oldHd.distance)) {
          // replace with closest
          finalPoints[oldId] = newHd;
        }
      }
    };
    var k;
    // insert the winnig point(s) first
    for (k = 0; k < initLen; k++) {
      insert(hoverData[k]);
    }
    // override from the end
    for (k = hoverData.length - 1; k > initLen - 1; k--) {
      insert(hoverData[k]);
    }
    hoverData = finalPoints;
    sortHoverData();
  }

  // lastly, emit custom hover/unhover events
  var oldhoverdata = gd._hoverdata;
  var newhoverdata = [];
  var gTop = getTopOffset(gd);
  var gLeft = getLeftOffset(gd);

  // pull out just the data that's useful to
  // other people and send it to the event
  for (itemnum = 0; itemnum < hoverData.length; itemnum++) {
    var pt = hoverData[itemnum];
    var eventData = helpers.makeEventData(pt, pt.trace, pt.cd);
    if (pt.hovertemplate !== false) {
      var ht = false;
      if (pt.cd[pt.index] && pt.cd[pt.index].ht) {
        ht = pt.cd[pt.index].ht;
      }
      pt.hovertemplate = ht || pt.trace.hovertemplate || false;
    }
    if (pt.xa && pt.ya) {
      var _x0 = pt.x0 + pt.xa._offset;
      var _x1 = pt.x1 + pt.xa._offset;
      var _y0 = pt.y0 + pt.ya._offset;
      var _y1 = pt.y1 + pt.ya._offset;
      var x0 = Math.min(_x0, _x1);
      var x1 = Math.max(_x0, _x1);
      var y0 = Math.min(_y0, _y1);
      var y1 = Math.max(_y0, _y1);
      eventData.bbox = {
        x0: x0 + gLeft,
        x1: x1 + gLeft,
        y0: y0 + gTop,
        y1: y1 + gTop
      };
    }
    pt.eventData = [eventData];
    newhoverdata.push(eventData);
  }
  gd._hoverdata = newhoverdata;
  var rotateLabels = hovermode === 'y' && (searchData.length > 1 || hoverData.length > 1) || hovermode === 'closest' && hasOneHorizontalTrace && hoverData.length > 1;
  var bgColor = Color.combine(fullLayout.plot_bgcolor || Color.background, fullLayout.paper_bgcolor);
  var hoverText = createHoverText(hoverData, {
    gd: gd,
    hovermode: hovermode,
    rotateLabels: rotateLabels,
    bgColor: bgColor,
    container: fullLayout._hoverlayer,
    outerContainer: fullLayout._paper.node(),
    commonLabelOpts: fullLayout.hoverlabel,
    hoverdistance: fullLayout.hoverdistance
  });
  var hoverLabels = hoverText.hoverLabels;
  if (!helpers.isUnifiedHover(hovermode)) {
    hoverAvoidOverlaps(hoverLabels, rotateLabels, fullLayout, hoverText.commonLabelBoundingBox);
    alignHoverText(hoverLabels, rotateLabels, fullLayout._invScaleX, fullLayout._invScaleY);
  } // TODO: tagName hack is needed to appease geo.js's hack of using eventTarget=true
  // we should improve the "fx" API so other plots can use it without these hack.
  if (eventTarget && eventTarget.tagName) {
    var hasClickToShow = Registry.getComponentMethod('annotations', 'hasClickToShow')(gd, newhoverdata);
    overrideCursor(d3.select(eventTarget), hasClickToShow ? 'pointer' : '');
  }

  // don't emit events if called manually
  if (!eventTarget || noHoverEvent || !hoverChanged(gd, evt, oldhoverdata)) return;
  if (oldhoverdata) {
    gd.emit('plotly_unhover', {
      event: evt,
      points: oldhoverdata
    });
  }
  gd.emit('plotly_hover', {
    event: evt,
    points: gd._hoverdata,
    xaxes: xaArray,
    yaxes: yaArray,
    xvals: xvalArray,
    yvals: yvalArray
  });
}
function hoverDataKey(d) {
  return [d.trace.index, d.index, d.x0, d.y0, d.name, d.attr, d.xa ? d.xa._id : '', d.ya ? d.ya._id : ''].join(',');
}
var EXTRA_STRING_REGEX = /<extra>([\s\S]*)<\/extra>/;
function createHoverText(hoverData, opts) {
  var gd = opts.gd;
  var fullLayout = gd._fullLayout;
  var hovermode = opts.hovermode;
  var rotateLabels = opts.rotateLabels;
  var bgColor = opts.bgColor;
  var container = opts.container;
  var outerContainer = opts.outerContainer;
  var commonLabelOpts = opts.commonLabelOpts || {};
  // Early exit if no labels are drawn
  if (hoverData.length === 0) return [[]];

  // opts.fontFamily/Size are used for the common label
  // and as defaults for each hover label, though the individual labels
  // can override this.
  var fontFamily = opts.fontFamily || constants.HOVERFONT;
  var fontSize = opts.fontSize || constants.HOVERFONTSIZE;
  var c0 = hoverData[0];
  var xa = c0.xa;
  var ya = c0.ya;
  var axLetter = hovermode.charAt(0);
  var axLabel = axLetter + 'Label';
  var t0 = c0[axLabel];

  // search in array for the label
  if (t0 === undefined && xa.type === 'multicategory') {
    for (var q = 0; q < hoverData.length; q++) {
      t0 = hoverData[q][axLabel];
      if (t0 !== undefined) break;
    }
  }
  var outerContainerBB = getBoundingClientRect(gd, outerContainer);
  var outerTop = outerContainerBB.top;
  var outerWidth = outerContainerBB.width;
  var outerHeight = outerContainerBB.height;

  // show the common label, if any, on the axis
  // never show a common label in array mode,
  // even if sometimes there could be one
  var showCommonLabel = t0 !== undefined && c0.distance <= opts.hoverdistance && (hovermode === 'x' || hovermode === 'y');

  // all hover traces hoverinfo must contain the hovermode
  // to have common labels
  if (showCommonLabel) {
    var allHaveZ = true;
    var i, traceHoverinfo;
    for (i = 0; i < hoverData.length; i++) {
      if (allHaveZ && hoverData[i].zLabel === undefined) allHaveZ = false;
      traceHoverinfo = hoverData[i].hoverinfo || hoverData[i].trace.hoverinfo;
      if (traceHoverinfo) {
        var parts = Array.isArray(traceHoverinfo) ? traceHoverinfo : traceHoverinfo.split('+');
        if (parts.indexOf('all') === -1 && parts.indexOf(hovermode) === -1) {
          showCommonLabel = false;
          break;
        }
      }
    }

    // xyz labels put all info in their main label, so have no need of a common label
    if (allHaveZ) showCommonLabel = false;
  }
  var commonLabel = container.selectAll('g.axistext').data(showCommonLabel ? [0] : []);
  commonLabel.enter().append('g').classed('axistext', true);
  commonLabel.exit().remove();

  // set rect (without arrow) behind label below for later collision detection
  var commonLabelRect = {
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0
  };
  commonLabel.each(function () {
    var label = d3.select(this);
    var lpath = Lib.ensureSingle(label, 'path', '', function (s) {
      s.style({
        'stroke-width': '1px'
      });
    });
    var ltext = Lib.ensureSingle(label, 'text', '', function (s) {
      // prohibit tex interpretation until we can handle
      // tex and regular text together
      s.attr('data-notex', 1);
    });
    var commonBgColor = commonLabelOpts.bgcolor || Color.defaultLine;
    var commonStroke = commonLabelOpts.bordercolor || Color.contrast(commonBgColor);
    var contrastColor = Color.contrast(commonBgColor);
    var commonLabelFont = {
      family: commonLabelOpts.font.family || fontFamily,
      size: commonLabelOpts.font.size || fontSize,
      color: commonLabelOpts.font.color || contrastColor
    };
    lpath.style({
      fill: commonBgColor,
      stroke: commonStroke
    });
    ltext.text(t0).call(Drawing.font, commonLabelFont).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);
    label.attr('transform', '');
    var tbb = getBoundingClientRect(gd, ltext.node());
    var lx, ly;
    if (hovermode === 'x') {
      var topsign = xa.side === 'top' ? '-' : '';
      ltext.attr('text-anchor', 'middle').call(svgTextUtils.positionText, 0, xa.side === 'top' ? outerTop - tbb.bottom - HOVERARROWSIZE - HOVERTEXTPAD : outerTop - tbb.top + HOVERARROWSIZE + HOVERTEXTPAD);
      lx = xa._offset + (c0.x0 + c0.x1) / 2;
      ly = ya._offset + (xa.side === 'top' ? 0 : ya._length);
      var halfWidth = tbb.width / 2 + HOVERTEXTPAD;
      if (lx < halfWidth) {
        lx = halfWidth;
        lpath.attr('d', 'M-' + (halfWidth - HOVERARROWSIZE) + ',0' + 'L-' + (halfWidth - HOVERARROWSIZE * 2) + ',' + topsign + HOVERARROWSIZE + 'H' + halfWidth + 'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) + 'H-' + halfWidth + 'V' + topsign + HOVERARROWSIZE + 'Z');
      } else if (lx > fullLayout.width - halfWidth) {
        lx = fullLayout.width - halfWidth;
        lpath.attr('d', 'M' + (halfWidth - HOVERARROWSIZE) + ',0' + 'L' + halfWidth + ',' + topsign + HOVERARROWSIZE + 'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) + 'H-' + halfWidth + 'V' + topsign + HOVERARROWSIZE + 'H' + (halfWidth - HOVERARROWSIZE * 2) + 'Z');
      } else {
        lpath.attr('d', 'M0,0' + 'L' + HOVERARROWSIZE + ',' + topsign + HOVERARROWSIZE + 'H' + halfWidth + 'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) + 'H-' + halfWidth + 'V' + topsign + HOVERARROWSIZE + 'H-' + HOVERARROWSIZE + 'Z');
      }
      commonLabelRect.minX = lx - halfWidth;
      commonLabelRect.maxX = lx + halfWidth;
      if (xa.side === 'top') {
        // label on negative y side
        commonLabelRect.minY = ly - (HOVERTEXTPAD * 2 + tbb.height);
        commonLabelRect.maxY = ly - HOVERTEXTPAD;
      } else {
        commonLabelRect.minY = ly + HOVERTEXTPAD;
        commonLabelRect.maxY = ly + (HOVERTEXTPAD * 2 + tbb.height);
      }
    } else {
      var anchor;
      var sgn;
      var leftsign;
      if (ya.side === 'right') {
        anchor = 'start';
        sgn = 1;
        leftsign = '';
        lx = xa._offset + xa._length;
      } else {
        anchor = 'end';
        sgn = -1;
        leftsign = '-';
        lx = xa._offset;
      }
      ly = ya._offset + (c0.y0 + c0.y1) / 2;
      ltext.attr('text-anchor', anchor);
      lpath.attr('d', 'M0,0' + 'L' + leftsign + HOVERARROWSIZE + ',' + HOVERARROWSIZE + 'V' + (HOVERTEXTPAD + tbb.height / 2) + 'h' + leftsign + (HOVERTEXTPAD * 2 + tbb.width) + 'V-' + (HOVERTEXTPAD + tbb.height / 2) + 'H' + leftsign + HOVERARROWSIZE + 'V-' + HOVERARROWSIZE + 'Z');
      commonLabelRect.minY = ly - (HOVERTEXTPAD + tbb.height / 2);
      commonLabelRect.maxY = ly + (HOVERTEXTPAD + tbb.height / 2);
      if (ya.side === 'right') {
        commonLabelRect.minX = lx + HOVERARROWSIZE;
        commonLabelRect.maxX = lx + HOVERARROWSIZE + (HOVERTEXTPAD * 2 + tbb.width);
      } else {
        // label on negative x side
        commonLabelRect.minX = lx - HOVERARROWSIZE - (HOVERTEXTPAD * 2 + tbb.width);
        commonLabelRect.maxX = lx - HOVERARROWSIZE;
      }
      var halfHeight = tbb.height / 2;
      var lty = outerTop - tbb.top - halfHeight;
      var clipId = 'clip' + fullLayout._uid + 'commonlabel' + ya._id;
      var clipPath;
      if (lx < tbb.width + 2 * HOVERTEXTPAD + HOVERARROWSIZE) {
        clipPath = 'M-' + (HOVERARROWSIZE + HOVERTEXTPAD) + '-' + halfHeight + 'h-' + (tbb.width - HOVERTEXTPAD) + 'V' + halfHeight + 'h' + (tbb.width - HOVERTEXTPAD) + 'Z';
        var ltx = tbb.width - lx + HOVERTEXTPAD;
        svgTextUtils.positionText(ltext, ltx, lty);

        // shift each line (except the longest) so that start-of-line
        // is always visible
        if (anchor === 'end') {
          ltext.selectAll('tspan').each(function () {
            var s = d3.select(this);
            var dummy = Drawing.tester.append('text').text(s.text()).call(Drawing.font, commonLabelFont);
            var dummyBB = getBoundingClientRect(gd, dummy.node());
            if (Math.round(dummyBB.width) < Math.round(tbb.width)) {
              s.attr('x', ltx - dummyBB.width);
            }
            dummy.remove();
          });
        }
      } else {
        svgTextUtils.positionText(ltext, sgn * (HOVERTEXTPAD + HOVERARROWSIZE), lty);
        clipPath = null;
      }
      var textClip = fullLayout._topclips.selectAll('#' + clipId).data(clipPath ? [0] : []);
      textClip.enter().append('clipPath').attr('id', clipId).append('path');
      textClip.exit().remove();
      textClip.select('path').attr('d', clipPath);
      Drawing.setClipUrl(ltext, clipPath ? clipId : null, gd);
    }
    label.attr('transform', strTranslate(lx, ly));
  });

  // Show a single hover label
  if (helpers.isUnifiedHover(hovermode)) {
    // Delete leftover hover labels from other hovermodes
    container.selectAll('g.hovertext').remove();
    var groupedHoverData = hoverData.filter(function (data) {
      return data.hoverinfo !== 'none';
    });
    // Return early if nothing is hovered on
    if (groupedHoverData.length === 0) return [];

    // mock legend
    var hoverlabel = fullLayout.hoverlabel;
    var font = hoverlabel.font;
    var mockLayoutIn = {
      showlegend: true,
      legend: {
        title: {
          text: t0,
          font: font
        },
        font: font,
        bgcolor: hoverlabel.bgcolor,
        bordercolor: hoverlabel.bordercolor,
        borderwidth: 1,
        tracegroupgap: 7,
        traceorder: fullLayout.legend ? fullLayout.legend.traceorder : undefined,
        orientation: 'v'
      }
    };
    var mockLayoutOut = {
      font: font
    };
    legendSupplyDefaults(mockLayoutIn, mockLayoutOut, gd._fullData);
    var mockLegend = mockLayoutOut.legend;

    // prepare items for the legend
    mockLegend.entries = [];
    for (var j = 0; j < groupedHoverData.length; j++) {
      var pt = groupedHoverData[j];
      if (pt.hoverinfo === 'none') continue;
      var texts = getHoverLabelText(pt, true, hovermode, fullLayout, t0);
      var text = texts[0];
      var name = texts[1];
      pt.name = name;
      if (name !== '') {
        pt.text = name + ' : ' + text;
      } else {
        pt.text = text;
      }

      // pass through marker's calcdata to style legend items
      var cd = pt.cd[pt.index];
      if (cd) {
        if (cd.mc) pt.mc = cd.mc;
        if (cd.mcc) pt.mc = cd.mcc;
        if (cd.mlc) pt.mlc = cd.mlc;
        if (cd.mlcc) pt.mlc = cd.mlcc;
        if (cd.mlw) pt.mlw = cd.mlw;
        if (cd.mrc) pt.mrc = cd.mrc;
        if (cd.dir) pt.dir = cd.dir;
      }
      pt._distinct = true;
      mockLegend.entries.push([pt]);
    }
    mockLegend.entries.sort(function (a, b) {
      return a[0].trace.index - b[0].trace.index;
    });
    mockLegend.layer = container;

    // Draw unified hover label
    mockLegend._inHover = true;
    mockLegend._groupTitleFont = hoverlabel.grouptitlefont;
    legendDraw(gd, mockLegend);

    // Position the hover
    var legendContainer = container.select('g.legend');
    var tbb = getBoundingClientRect(gd, legendContainer.node());
    var tWidth = tbb.width + 2 * HOVERTEXTPAD;
    var tHeight = tbb.height + 2 * HOVERTEXTPAD;
    var winningPoint = groupedHoverData[0];
    var avgX = (winningPoint.x0 + winningPoint.x1) / 2;
    var avgY = (winningPoint.y0 + winningPoint.y1) / 2;
    // When a scatter (or e.g. heatmap) point wins, it's OK for the hovelabel to occlude the bar and other points.
    var pointWon = !(Registry.traceIs(winningPoint.trace, 'bar-like') || Registry.traceIs(winningPoint.trace, 'box-violin'));
    var lyBottom, lyTop;
    if (axLetter === 'y') {
      if (pointWon) {
        lyTop = avgY - HOVERTEXTPAD;
        lyBottom = avgY + HOVERTEXTPAD;
      } else {
        lyTop = Math.min.apply(null, groupedHoverData.map(function (c) {
          return Math.min(c.y0, c.y1);
        }));
        lyBottom = Math.max.apply(null, groupedHoverData.map(function (c) {
          return Math.max(c.y0, c.y1);
        }));
      }
    } else {
      lyTop = lyBottom = Lib.mean(groupedHoverData.map(function (c) {
        return (c.y0 + c.y1) / 2;
      })) - tHeight / 2;
    }
    var lxRight, lxLeft;
    if (axLetter === 'x') {
      if (pointWon) {
        lxRight = avgX + HOVERTEXTPAD;
        lxLeft = avgX - HOVERTEXTPAD;
      } else {
        lxRight = Math.max.apply(null, groupedHoverData.map(function (c) {
          return Math.max(c.x0, c.x1);
        }));
        lxLeft = Math.min.apply(null, groupedHoverData.map(function (c) {
          return Math.min(c.x0, c.x1);
        }));
      }
    } else {
      lxRight = lxLeft = Lib.mean(groupedHoverData.map(function (c) {
        return (c.x0 + c.x1) / 2;
      })) - tWidth / 2;
    }
    var xOffset = xa._offset;
    var yOffset = ya._offset;
    lyBottom += yOffset;
    lxRight += xOffset;
    lxLeft += xOffset - tWidth;
    lyTop += yOffset - tHeight;
    var lx, ly; // top and left positions of the hover box

    // horizontal alignment to end up on screen
    if (lxRight + tWidth < outerWidth && lxRight >= 0) {
      lx = lxRight;
    } else if (lxLeft + tWidth < outerWidth && lxLeft >= 0) {
      lx = lxLeft;
    } else if (xOffset + tWidth < outerWidth) {
      lx = xOffset; // subplot left corner
    } else {
      // closest left or right side of the paper
      if (lxRight - avgX < avgX - lxLeft + tWidth) {
        lx = outerWidth - tWidth;
      } else {
        lx = 0;
      }
    }
    lx += HOVERTEXTPAD;

    // vertical alignement to end up on screen
    if (lyBottom + tHeight < outerHeight && lyBottom >= 0) {
      ly = lyBottom;
    } else if (lyTop + tHeight < outerHeight && lyTop >= 0) {
      ly = lyTop;
    } else if (yOffset + tHeight < outerHeight) {
      ly = yOffset; // subplot top corner
    } else {
      // closest top or bottom side of the paper
      if (lyBottom - avgY < avgY - lyTop + tHeight) {
        ly = outerHeight - tHeight;
      } else {
        ly = 0;
      }
    }
    ly += HOVERTEXTPAD;
    legendContainer.attr('transform', strTranslate(lx - 1, ly - 1));
    return legendContainer;
  }

  // show all the individual labels

  // first create the objects
  var hoverLabels = container.selectAll('g.hovertext').data(hoverData, function (d) {
    // N.B. when multiple items have the same result key-function value,
    // only the first of those items in hoverData gets rendered
    return hoverDataKey(d);
  });
  hoverLabels.enter().append('g').classed('hovertext', true).each(function () {
    var g = d3.select(this);
    // trace name label (rect and text.name)
    g.append('rect').call(Color.fill, Color.addOpacity(bgColor, 0.8));
    g.append('text').classed('name', true);
    // trace data label (path and text.nums)
    g.append('path').style('stroke-width', '1px');
    g.append('text').classed('nums', true).call(Drawing.font, fontFamily, fontSize);
  });
  hoverLabels.exit().remove();

  // then put the text in, position the pointer to the data,
  // and figure out sizes
  hoverLabels.each(function (d) {
    var g = d3.select(this).attr('transform', '');
    var dColor = d.color;
    if (Array.isArray(dColor)) {
      dColor = dColor[d.eventData[0].pointNumber];
    }

    // combine possible non-opaque trace color with bgColor
    var color0 = d.bgcolor || dColor;
    // color for 'nums' part of the label
    var numsColor = Color.combine(Color.opacity(color0) ? color0 : Color.defaultLine, bgColor);
    // color for 'name' part of the label
    var nameColor = Color.combine(Color.opacity(dColor) ? dColor : Color.defaultLine, bgColor);
    // find a contrasting color for border and text
    var contrastColor = d.borderColor || Color.contrast(numsColor);
    var texts = getHoverLabelText(d, showCommonLabel, hovermode, fullLayout, t0, g);
    var text = texts[0];
    var name = texts[1];

    // main label
    var tx = g.select('text.nums').call(Drawing.font, d.fontFamily || fontFamily, d.fontSize || fontSize, d.fontColor || contrastColor).text(text).attr('data-notex', 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);
    var tx2 = g.select('text.name');
    var tx2width = 0;
    var tx2height = 0;

    // secondary label for non-empty 'name'
    if (name && name !== text) {
      tx2.call(Drawing.font, d.fontFamily || fontFamily, d.fontSize || fontSize, nameColor).text(name).attr('data-notex', 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);
      var t2bb = getBoundingClientRect(gd, tx2.node());
      tx2width = t2bb.width + 2 * HOVERTEXTPAD;
      tx2height = t2bb.height + 2 * HOVERTEXTPAD;
    } else {
      tx2.remove();
      g.select('rect').remove();
    }
    g.select('path').style({
      fill: numsColor,
      stroke: contrastColor
    });
    var htx = d.xa._offset + (d.x0 + d.x1) / 2;
    var hty = d.ya._offset + (d.y0 + d.y1) / 2;
    var dx = Math.abs(d.x1 - d.x0);
    var dy = Math.abs(d.y1 - d.y0);
    var tbb = getBoundingClientRect(gd, tx.node());
    var tbbWidth = tbb.width / fullLayout._invScaleX;
    var tbbHeight = tbb.height / fullLayout._invScaleY;
    d.ty0 = (outerTop - tbb.top) / fullLayout._invScaleY;
    d.bx = tbbWidth + 2 * HOVERTEXTPAD;
    d.by = Math.max(tbbHeight + 2 * HOVERTEXTPAD, tx2height);
    d.anchor = 'start';
    d.txwidth = tbbWidth;
    d.tx2width = tx2width;
    d.offset = 0;
    var txTotalWidth = (tbbWidth + HOVERARROWSIZE + HOVERTEXTPAD + tx2width) * fullLayout._invScaleX;
    var anchorStartOK, anchorEndOK;
    if (rotateLabels) {
      d.pos = htx;
      anchorStartOK = hty + dy / 2 + txTotalWidth <= outerHeight;
      anchorEndOK = hty - dy / 2 - txTotalWidth >= 0;
      if ((d.idealAlign === 'top' || !anchorStartOK) && anchorEndOK) {
        hty -= dy / 2;
        d.anchor = 'end';
      } else if (anchorStartOK) {
        hty += dy / 2;
        d.anchor = 'start';
      } else {
        d.anchor = 'middle';
      }
      d.crossPos = hty;
    } else {
      d.pos = hty;
      anchorStartOK = htx + dx / 2 + txTotalWidth <= outerWidth;
      anchorEndOK = htx - dx / 2 - txTotalWidth >= 0;
      if ((d.idealAlign === 'left' || !anchorStartOK) && anchorEndOK) {
        htx -= dx / 2;
        d.anchor = 'end';
      } else if (anchorStartOK) {
        htx += dx / 2;
        d.anchor = 'start';
      } else {
        d.anchor = 'middle';
        var txHalfWidth = txTotalWidth / 2;
        var overflowR = htx + txHalfWidth - outerWidth;
        var overflowL = htx - txHalfWidth;
        if (overflowR > 0) htx -= overflowR;
        if (overflowL < 0) htx += -overflowL;
      }
      d.crossPos = htx;
    }
    tx.attr('text-anchor', d.anchor);
    if (tx2width) tx2.attr('text-anchor', d.anchor);
    g.attr('transform', strTranslate(htx, hty) + (rotateLabels ? strRotate(YANGLE) : ''));
  });
  return {
    hoverLabels: hoverLabels,
    commonLabelBoundingBox: commonLabelRect
  };
}
function getHoverLabelText(d, showCommonLabel, hovermode, fullLayout, t0, g) {
  var name = '';
  var text = '';
  // to get custom 'name' labels pass cleanPoint
  if (d.nameOverride !== undefined) d.name = d.nameOverride;
  if (d.name) {
    if (d.trace._meta) {
      d.name = Lib.templateString(d.name, d.trace._meta);
    }
    name = plainText(d.name, d.nameLength);
  }
  var h0 = hovermode.charAt(0);
  var h1 = h0 === 'x' ? 'y' : 'x';
  if (d.zLabel !== undefined) {
    if (d.xLabel !== undefined) text += 'x: ' + d.xLabel + '<br>';
    if (d.yLabel !== undefined) text += 'y: ' + d.yLabel + '<br>';
    if (d.trace.type !== 'choropleth' && d.trace.type !== 'choroplethmapbox') {
      text += (text ? 'z: ' : '') + d.zLabel;
    }
  } else if (showCommonLabel && d[h0 + 'Label'] === t0) {
    text = d[h1 + 'Label'] || '';
  } else if (d.xLabel === undefined) {
    if (d.yLabel !== undefined && d.trace.type !== 'scattercarpet') {
      text = d.yLabel;
    }
  } else if (d.yLabel === undefined) text = d.xLabel;else text = '(' + d.xLabel + ', ' + d.yLabel + ')';
  if ((d.text || d.text === 0) && !Array.isArray(d.text)) {
    text += (text ? '<br>' : '') + d.text;
  }

  // used by other modules (initially just ternary) that
  // manage their own hoverinfo independent of cleanPoint
  // the rest of this will still apply, so such modules
  // can still put things in (x|y|z)Label, text, and name
  // and hoverinfo will still determine their visibility
  if (d.extraText !== undefined) text += (text ? '<br>' : '') + d.extraText;

  // if 'text' is empty at this point,
  // and hovertemplate is not defined,
  // put 'name' in main label and don't show secondary label
  if (g && text === '' && !d.hovertemplate) {
    // if 'name' is also empty, remove entire label
    if (name === '') g.remove();
    text = name;
  }

  // hovertemplate
  var hovertemplate = d.hovertemplate || false;
  if (hovertemplate) {
    var labels = d.hovertemplateLabels || d;
    if (d[h0 + 'Label'] !== t0) {
      labels[h0 + 'other'] = labels[h0 + 'Val'];
      labels[h0 + 'otherLabel'] = labels[h0 + 'Label'];
    }
    text = Lib.hovertemplateString(hovertemplate, labels, fullLayout._d3locale, d.eventData[0] || {}, d.trace._meta);
    text = text.replace(EXTRA_STRING_REGEX, function (match, extra) {
      // assign name for secondary text label
      name = plainText(extra, d.nameLength);
      // remove from main text label
      return '';
    });
  }
  return [text, name];
}

// Make groups of touching points, and within each group
// move each point so that no labels overlap, but the average
// label position is the same as it was before moving. Incidentally,
// this is equivalent to saying all the labels are on equal linear
// springs about their initial position. Initially, each point is
// its own group, but as we find overlaps we will clump the points.
//
// Also, there are hard constraints at the edges of the graphs,
// that push all groups to the middle so they are visible. I don't
// know what happens if the group spans all the way from one edge to
// the other, though it hardly matters - there's just too much
// information then.
function hoverAvoidOverlaps(hoverLabels, rotateLabels, fullLayout, commonLabelBoundingBox) {
  var axKey = rotateLabels ? 'xa' : 'ya';
  var crossAxKey = rotateLabels ? 'ya' : 'xa';
  var nummoves = 0;
  var axSign = 1;
  var nLabels = hoverLabels.size();

  // make groups of touching points
  var pointgroups = new Array(nLabels);
  var k = 0;

  // get extent of axis hover label
  var axisLabelMinX = commonLabelBoundingBox.minX;
  var axisLabelMaxX = commonLabelBoundingBox.maxX;
  var axisLabelMinY = commonLabelBoundingBox.minY;
  var axisLabelMaxY = commonLabelBoundingBox.maxY;
  var pX = function (x) {
    return x * fullLayout._invScaleX;
  };
  var pY = function (y) {
    return y * fullLayout._invScaleY;
  };
  hoverLabels.each(function (d) {
    var ax = d[axKey];
    var crossAx = d[crossAxKey];
    var axIsX = ax._id.charAt(0) === 'x';
    var rng = ax.range;
    if (k === 0 && rng && rng[0] > rng[1] !== axIsX) {
      axSign = -1;
    }
    var pmin = 0;
    var pmax = axIsX ? fullLayout.width : fullLayout.height;
    // in hovermode avoid overlap between hover labels and axis label
    if (fullLayout.hovermode === 'x' || fullLayout.hovermode === 'y') {
      // extent of rect behind hover label on cross axis:
      var offsets = getHoverLabelOffsets(d, rotateLabels);
      var anchor = d.anchor;
      var horzSign = anchor === 'end' ? -1 : 1;
      var labelMin;
      var labelMax;
      if (anchor === 'middle') {
        // use extent of centered rect either on x or y axis depending on current axis
        labelMin = d.crossPos + (axIsX ? pY(offsets.y - d.by / 2) : pX(d.bx / 2 + d.tx2width / 2));
        labelMax = labelMin + (axIsX ? pY(d.by) : pX(d.bx));
      } else {
        // use extend of path (see alignHoverText function) without arrow
        if (axIsX) {
          labelMin = d.crossPos + pY(HOVERARROWSIZE + offsets.y) - pY(d.by / 2 - HOVERARROWSIZE);
          labelMax = labelMin + pY(d.by);
        } else {
          var startX = pX(horzSign * HOVERARROWSIZE + offsets.x);
          var endX = startX + pX(horzSign * d.bx);
          labelMin = d.crossPos + Math.min(startX, endX);
          labelMax = d.crossPos + Math.max(startX, endX);
        }
      }
      if (axIsX) {
        if (axisLabelMinY !== undefined && axisLabelMaxY !== undefined && Math.min(labelMax, axisLabelMaxY) - Math.max(labelMin, axisLabelMinY) > 1) {
          // has at least 1 pixel overlap with axis label
          if (crossAx.side === 'left') {
            pmin = crossAx._mainLinePosition;
            pmax = fullLayout.width;
          } else {
            pmax = crossAx._mainLinePosition;
          }
        }
      } else {
        if (axisLabelMinX !== undefined && axisLabelMaxX !== undefined && Math.min(labelMax, axisLabelMaxX) - Math.max(labelMin, axisLabelMinX) > 1) {
          // has at least 1 pixel overlap with axis label
          if (crossAx.side === 'top') {
            pmin = crossAx._mainLinePosition;
            pmax = fullLayout.height;
          } else {
            pmax = crossAx._mainLinePosition;
          }
        }
      }
    }
    pointgroups[k++] = [{
      datum: d,
      traceIndex: d.trace.index,
      dp: 0,
      pos: d.pos,
      posref: d.posref,
      size: d.by * (axIsX ? YFACTOR : 1) / 2,
      pmin: pmin,
      pmax: pmax
    }];
  });
  pointgroups.sort(function (a, b) {
    return a[0].posref - b[0].posref ||
    // for equal positions, sort trace indices increasing or decreasing
    // depending on whether the axis is reversed or not... so stacked
    // traces will generally keep their order even if one trace adds
    // nothing to the stack.
    axSign * (b[0].traceIndex - a[0].traceIndex);
  });
  var donepositioning, topOverlap, bottomOverlap, i, j, pti, sumdp;
  function constrainGroup(grp) {
    var minPt = grp[0];
    var maxPt = grp[grp.length - 1];

    // overlap with the top - positive vals are overlaps
    topOverlap = minPt.pmin - minPt.pos - minPt.dp + minPt.size;

    // overlap with the bottom - positive vals are overlaps
    bottomOverlap = maxPt.pos + maxPt.dp + maxPt.size - minPt.pmax;

    // check for min overlap first, so that we always
    // see the largest labels
    // allow for .01px overlap, so we don't get an
    // infinite loop from rounding errors
    if (topOverlap > 0.01) {
      for (j = grp.length - 1; j >= 0; j--) grp[j].dp += topOverlap;
      donepositioning = false;
    }
    if (bottomOverlap < 0.01) return;
    if (topOverlap < -0.01) {
      // make sure we're not pushing back and forth
      for (j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;
      donepositioning = false;
    }
    if (!donepositioning) return;

    // no room to fix positioning, delete off-screen points

    // first see how many points we need to delete
    var deleteCount = 0;
    for (i = 0; i < grp.length; i++) {
      pti = grp[i];
      if (pti.pos + pti.dp + pti.size > minPt.pmax) deleteCount++;
    }

    // start by deleting points whose data is off screen
    for (i = grp.length - 1; i >= 0; i--) {
      if (deleteCount <= 0) break;
      pti = grp[i];

      // pos has already been constrained to [pmin,pmax]
      // so look for points close to that to delete
      if (pti.pos > minPt.pmax - 1) {
        pti.del = true;
        deleteCount--;
      }
    }
    for (i = 0; i < grp.length; i++) {
      if (deleteCount <= 0) break;
      pti = grp[i];

      // pos has already been constrained to [pmin,pmax]
      // so look for points close to that to delete
      if (pti.pos < minPt.pmin + 1) {
        pti.del = true;
        deleteCount--;

        // shift the whole group minus into this new space
        bottomOverlap = pti.size * 2;
        for (j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;
      }
    }
    // then delete points that go off the bottom
    for (i = grp.length - 1; i >= 0; i--) {
      if (deleteCount <= 0) break;
      pti = grp[i];
      if (pti.pos + pti.dp + pti.size > minPt.pmax) {
        pti.del = true;
        deleteCount--;
      }
    }
  }

  // loop through groups, combining them if they overlap,
  // until nothing moves
  while (!donepositioning && nummoves <= nLabels) {
    // to avoid infinite loops, don't move more times
    // than there are traces
    nummoves++;

    // assume nothing will move in this iteration,
    // reverse this if it does
    donepositioning = true;
    i = 0;
    while (i < pointgroups.length - 1) {
      // the higher (g0) and lower (g1) point group
      var g0 = pointgroups[i];
      var g1 = pointgroups[i + 1];

      // the lowest point in the higher group (p0)
      // the highest point in the lower group (p1)
      var p0 = g0[g0.length - 1];
      var p1 = g1[0];
      topOverlap = p0.pos + p0.dp + p0.size - p1.pos - p1.dp + p1.size;

      // Only group points that lie on the same axes
      if (topOverlap > 0.01 && p0.pmin === p1.pmin && p0.pmax === p1.pmax) {
        // push the new point(s) added to this group out of the way
        for (j = g1.length - 1; j >= 0; j--) g1[j].dp += topOverlap;

        // add them to the group
        g0.push.apply(g0, g1);
        pointgroups.splice(i + 1, 1);

        // adjust for minimum average movement
        sumdp = 0;
        for (j = g0.length - 1; j >= 0; j--) sumdp += g0[j].dp;
        bottomOverlap = sumdp / g0.length;
        for (j = g0.length - 1; j >= 0; j--) g0[j].dp -= bottomOverlap;
        donepositioning = false;
      } else i++;
    }

    // check if we're going off the plot on either side and fix
    pointgroups.forEach(constrainGroup);
  }

  // now put these offsets into hoverData
  for (i = pointgroups.length - 1; i >= 0; i--) {
    var grp = pointgroups[i];
    for (j = grp.length - 1; j >= 0; j--) {
      var pt = grp[j];
      var hoverPt = pt.datum;
      hoverPt.offset = pt.dp;
      hoverPt.del = pt.del;
    }
  }
}
function getHoverLabelOffsets(hoverLabel, rotateLabels) {
  var offsetX = 0;
  var offsetY = hoverLabel.offset;
  if (rotateLabels) {
    offsetY *= -YSHIFTY;
    offsetX = hoverLabel.offset * YSHIFTX;
  }
  return {
    x: offsetX,
    y: offsetY
  };
}

/**
 * Calculate the shift in x for text and text2 elements
 */
function getTextShiftX(hoverLabel) {
  var alignShift = {
    start: 1,
    end: -1,
    middle: 0
  }[hoverLabel.anchor];
  var textShiftX = alignShift * (HOVERARROWSIZE + HOVERTEXTPAD);
  var text2ShiftX = textShiftX + alignShift * (hoverLabel.txwidth + HOVERTEXTPAD);
  var isMiddle = hoverLabel.anchor === 'middle';
  if (isMiddle) {
    textShiftX -= hoverLabel.tx2width / 2;
    text2ShiftX += hoverLabel.txwidth / 2 + HOVERTEXTPAD;
  }
  return {
    alignShift: alignShift,
    textShiftX: textShiftX,
    text2ShiftX: text2ShiftX
  };
}
function alignHoverText(hoverLabels, rotateLabels, scaleX, scaleY) {
  var pX = function (x) {
    return x * scaleX;
  };
  var pY = function (y) {
    return y * scaleY;
  };

  // finally set the text positioning relative to the data and draw the
  // box around it
  hoverLabels.each(function (d) {
    var g = d3.select(this);
    if (d.del) return g.remove();
    var tx = g.select('text.nums');
    var anchor = d.anchor;
    var horzSign = anchor === 'end' ? -1 : 1;
    var shiftX = getTextShiftX(d);
    var offsets = getHoverLabelOffsets(d, rotateLabels);
    var offsetX = offsets.x;
    var offsetY = offsets.y;
    var isMiddle = anchor === 'middle';
    g.select('path').attr('d', isMiddle ?
    // middle aligned: rect centered on data
    'M-' + pX(d.bx / 2 + d.tx2width / 2) + ',' + pY(offsetY - d.by / 2) + 'h' + pX(d.bx) + 'v' + pY(d.by) + 'h-' + pX(d.bx) + 'Z' :
    // left or right aligned: side rect with arrow to data
    'M0,0L' + pX(horzSign * HOVERARROWSIZE + offsetX) + ',' + pY(HOVERARROWSIZE + offsetY) + 'v' + pY(d.by / 2 - HOVERARROWSIZE) + 'h' + pX(horzSign * d.bx) + 'v-' + pY(d.by) + 'H' + pX(horzSign * HOVERARROWSIZE + offsetX) + 'V' + pY(offsetY - HOVERARROWSIZE) + 'Z');
    var posX = offsetX + shiftX.textShiftX;
    var posY = offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD;
    var textAlign = d.textAlign || 'auto';
    if (textAlign !== 'auto') {
      if (textAlign === 'left' && anchor !== 'start') {
        tx.attr('text-anchor', 'start');
        posX = isMiddle ? -d.bx / 2 - d.tx2width / 2 + HOVERTEXTPAD : -d.bx - HOVERTEXTPAD;
      } else if (textAlign === 'right' && anchor !== 'end') {
        tx.attr('text-anchor', 'end');
        posX = isMiddle ? d.bx / 2 - d.tx2width / 2 - HOVERTEXTPAD : d.bx + HOVERTEXTPAD;
      }
    }
    tx.call(svgTextUtils.positionText, pX(posX), pY(posY));
    if (d.tx2width) {
      g.select('text.name').call(svgTextUtils.positionText, pX(shiftX.text2ShiftX + shiftX.alignShift * HOVERTEXTPAD + offsetX), pY(offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD));
      g.select('rect').call(Drawing.setRect, pX(shiftX.text2ShiftX + (shiftX.alignShift - 1) * d.tx2width / 2 + offsetX), pY(offsetY - d.by / 2 - 1), pX(d.tx2width), pY(d.by + 2));
    }
  });
}
function cleanPoint(d, hovermode) {
  var index = d.index;
  var trace = d.trace || {};
  var cd0 = d.cd[0];
  var cd = d.cd[index] || {};
  function pass(v) {
    return v || isNumeric(v) && v === 0;
  }
  var getVal = Array.isArray(index) ? function (calcKey, traceKey) {
    var v = Lib.castOption(cd0, index, calcKey);
    return pass(v) ? v : Lib.extractOption({}, trace, '', traceKey);
  } : function (calcKey, traceKey) {
    return Lib.extractOption(cd, trace, calcKey, traceKey);
  };
  function fill(key, calcKey, traceKey) {
    var val = getVal(calcKey, traceKey);
    if (pass(val)) d[key] = val;
  }
  fill('hoverinfo', 'hi', 'hoverinfo');
  fill('bgcolor', 'hbg', 'hoverlabel.bgcolor');
  fill('borderColor', 'hbc', 'hoverlabel.bordercolor');
  fill('fontFamily', 'htf', 'hoverlabel.font.family');
  fill('fontSize', 'hts', 'hoverlabel.font.size');
  fill('fontColor', 'htc', 'hoverlabel.font.color');
  fill('nameLength', 'hnl', 'hoverlabel.namelength');
  fill('textAlign', 'hta', 'hoverlabel.align');
  d.posref = hovermode === 'y' || hovermode === 'closest' && trace.orientation === 'h' ? d.xa._offset + (d.x0 + d.x1) / 2 : d.ya._offset + (d.y0 + d.y1) / 2;

  // then constrain all the positions to be on the plot
  d.x0 = Lib.constrain(d.x0, 0, d.xa._length);
  d.x1 = Lib.constrain(d.x1, 0, d.xa._length);
  d.y0 = Lib.constrain(d.y0, 0, d.ya._length);
  d.y1 = Lib.constrain(d.y1, 0, d.ya._length);

  // and convert the x and y label values into formatted text
  if (d.xLabelVal !== undefined) {
    d.xLabel = 'xLabel' in d ? d.xLabel : Axes.hoverLabelText(d.xa, d.xLabelVal, trace.xhoverformat);
    d.xVal = d.xa.c2d(d.xLabelVal);
  }
  if (d.yLabelVal !== undefined) {
    d.yLabel = 'yLabel' in d ? d.yLabel : Axes.hoverLabelText(d.ya, d.yLabelVal, trace.yhoverformat);
    d.yVal = d.ya.c2d(d.yLabelVal);
  }

  // Traces like heatmaps generate the zLabel in their hoverPoints function
  if (d.zLabelVal !== undefined && d.zLabel === undefined) {
    d.zLabel = String(d.zLabelVal);
  }

  // for box means and error bars, add the range to the label
  if (!isNaN(d.xerr) && !(d.xa.type === 'log' && d.xerr <= 0)) {
    var xeText = Axes.tickText(d.xa, d.xa.c2l(d.xerr), 'hover').text;
    if (d.xerrneg !== undefined) {
      d.xLabel += ' +' + xeText + ' / -' + Axes.tickText(d.xa, d.xa.c2l(d.xerrneg), 'hover').text;
    } else d.xLabel += ' ± ' + xeText;

    // small distance penalty for error bars, so that if there are
    // traces with errors and some without, the error bar label will
    // hoist up to the point
    if (hovermode === 'x') d.distance += 1;
  }
  if (!isNaN(d.yerr) && !(d.ya.type === 'log' && d.yerr <= 0)) {
    var yeText = Axes.tickText(d.ya, d.ya.c2l(d.yerr), 'hover').text;
    if (d.yerrneg !== undefined) {
      d.yLabel += ' +' + yeText + ' / -' + Axes.tickText(d.ya, d.ya.c2l(d.yerrneg), 'hover').text;
    } else d.yLabel += ' ± ' + yeText;
    if (hovermode === 'y') d.distance += 1;
  }
  var infomode = d.hoverinfo || d.trace.hoverinfo;
  if (infomode && infomode !== 'all') {
    infomode = Array.isArray(infomode) ? infomode : infomode.split('+');
    if (infomode.indexOf('x') === -1) d.xLabel = undefined;
    if (infomode.indexOf('y') === -1) d.yLabel = undefined;
    if (infomode.indexOf('z') === -1) d.zLabel = undefined;
    if (infomode.indexOf('text') === -1) d.text = undefined;
    if (infomode.indexOf('name') === -1) d.name = undefined;
  }
  return d;
}
function createSpikelines(gd, closestPoints, opts) {
  var container = opts.container;
  var fullLayout = opts.fullLayout;
  var gs = fullLayout._size;
  var evt = opts.event;
  var showY = !!closestPoints.hLinePoint;
  var showX = !!closestPoints.vLinePoint;
  var xa, ya;

  // Remove old spikeline items
  container.selectAll('.spikeline').remove();
  if (!(showX || showY)) return;
  var contrastColor = Color.combine(fullLayout.plot_bgcolor, fullLayout.paper_bgcolor);

  // Horizontal line (to y-axis)
  if (showY) {
    var hLinePoint = closestPoints.hLinePoint;
    var hLinePointX, hLinePointY;
    xa = hLinePoint && hLinePoint.xa;
    ya = hLinePoint && hLinePoint.ya;
    var ySnap = ya.spikesnap;
    if (ySnap === 'cursor') {
      hLinePointX = evt.pointerX;
      hLinePointY = evt.pointerY;
    } else {
      hLinePointX = xa._offset + hLinePoint.x;
      hLinePointY = ya._offset + hLinePoint.y;
    }
    var dfltHLineColor = tinycolor.readability(hLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : hLinePoint.color;
    var yMode = ya.spikemode;
    var yThickness = ya.spikethickness;
    var yColor = ya.spikecolor || dfltHLineColor;
    var xEdge = Axes.getPxPosition(gd, ya);
    var xBase, xEndSpike;
    if (yMode.indexOf('toaxis') !== -1 || yMode.indexOf('across') !== -1) {
      if (yMode.indexOf('toaxis') !== -1) {
        xBase = xEdge;
        xEndSpike = hLinePointX;
      }
      if (yMode.indexOf('across') !== -1) {
        var xAcross0 = ya._counterDomainMin;
        var xAcross1 = ya._counterDomainMax;
        if (ya.anchor === 'free') {
          xAcross0 = Math.min(xAcross0, ya.position);
          xAcross1 = Math.max(xAcross1, ya.position);
        }
        xBase = gs.l + xAcross0 * gs.w;
        xEndSpike = gs.l + xAcross1 * gs.w;
      }

      // Foreground horizontal line (to y-axis)
      container.insert('line', ':first-child').attr({
        x1: xBase,
        x2: xEndSpike,
        y1: hLinePointY,
        y2: hLinePointY,
        'stroke-width': yThickness,
        stroke: yColor,
        'stroke-dasharray': Drawing.dashStyle(ya.spikedash, yThickness)
      }).classed('spikeline', true).classed('crisp', true);

      // Background horizontal Line (to y-axis)
      container.insert('line', ':first-child').attr({
        x1: xBase,
        x2: xEndSpike,
        y1: hLinePointY,
        y2: hLinePointY,
        'stroke-width': yThickness + 2,
        stroke: contrastColor
      }).classed('spikeline', true).classed('crisp', true);
    }
    // Y axis marker
    if (yMode.indexOf('marker') !== -1) {
      container.insert('circle', ':first-child').attr({
        cx: xEdge + (ya.side !== 'right' ? yThickness : -yThickness),
        cy: hLinePointY,
        r: yThickness,
        fill: yColor
      }).classed('spikeline', true);
    }
  }
  if (showX) {
    var vLinePoint = closestPoints.vLinePoint;
    var vLinePointX, vLinePointY;
    xa = vLinePoint && vLinePoint.xa;
    ya = vLinePoint && vLinePoint.ya;
    var xSnap = xa.spikesnap;
    if (xSnap === 'cursor') {
      vLinePointX = evt.pointerX;
      vLinePointY = evt.pointerY;
    } else {
      vLinePointX = xa._offset + vLinePoint.x;
      vLinePointY = ya._offset + vLinePoint.y;
    }
    var dfltVLineColor = tinycolor.readability(vLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : vLinePoint.color;
    var xMode = xa.spikemode;
    var xThickness = xa.spikethickness;
    var xColor = xa.spikecolor || dfltVLineColor;
    var yEdge = Axes.getPxPosition(gd, xa);
    var yBase, yEndSpike;
    if (xMode.indexOf('toaxis') !== -1 || xMode.indexOf('across') !== -1) {
      if (xMode.indexOf('toaxis') !== -1) {
        yBase = yEdge;
        yEndSpike = vLinePointY;
      }
      if (xMode.indexOf('across') !== -1) {
        var yAcross0 = xa._counterDomainMin;
        var yAcross1 = xa._counterDomainMax;
        if (xa.anchor === 'free') {
          yAcross0 = Math.min(yAcross0, xa.position);
          yAcross1 = Math.max(yAcross1, xa.position);
        }
        yBase = gs.t + (1 - yAcross1) * gs.h;
        yEndSpike = gs.t + (1 - yAcross0) * gs.h;
      }

      // Foreground vertical line (to x-axis)
      container.insert('line', ':first-child').attr({
        x1: vLinePointX,
        x2: vLinePointX,
        y1: yBase,
        y2: yEndSpike,
        'stroke-width': xThickness,
        stroke: xColor,
        'stroke-dasharray': Drawing.dashStyle(xa.spikedash, xThickness)
      }).classed('spikeline', true).classed('crisp', true);

      // Background vertical line (to x-axis)
      container.insert('line', ':first-child').attr({
        x1: vLinePointX,
        x2: vLinePointX,
        y1: yBase,
        y2: yEndSpike,
        'stroke-width': xThickness + 2,
        stroke: contrastColor
      }).classed('spikeline', true).classed('crisp', true);
    }

    // X axis marker
    if (xMode.indexOf('marker') !== -1) {
      container.insert('circle', ':first-child').attr({
        cx: vLinePointX,
        cy: yEdge - (xa.side !== 'top' ? xThickness : -xThickness),
        r: xThickness,
        fill: xColor
      }).classed('spikeline', true);
    }
  }
}
function hoverChanged(gd, evt, oldhoverdata) {
  // don't emit any events if nothing changed
  if (!oldhoverdata || oldhoverdata.length !== gd._hoverdata.length) return true;
  for (var i = oldhoverdata.length - 1; i >= 0; i--) {
    var oldPt = oldhoverdata[i];
    var newPt = gd._hoverdata[i];
    if (oldPt.curveNumber !== newPt.curveNumber || String(oldPt.pointNumber) !== String(newPt.pointNumber) || String(oldPt.pointNumbers) !== String(newPt.pointNumbers)) {
      return true;
    }
  }
  return false;
}
function spikesChanged(gd, oldspikepoints) {
  // don't relayout the plot because of new spikelines if spikelines points didn't change
  if (!oldspikepoints) return true;
  if (oldspikepoints.vLinePoint !== gd._spikepoints.vLinePoint || oldspikepoints.hLinePoint !== gd._spikepoints.hLinePoint) return true;
  return false;
}
function plainText(s, len) {
  return svgTextUtils.plainText(s || '', {
    len: len,
    allowedTags: ['br', 'sub', 'sup', 'b', 'i', 'em']
  });
}
function orderRangePoints(hoverData, hovermode) {
  var axLetter = hovermode.charAt(0);
  var first = [];
  var second = [];
  var last = [];
  for (var i = 0; i < hoverData.length; i++) {
    var d = hoverData[i];
    if (Registry.traceIs(d.trace, 'bar-like') || Registry.traceIs(d.trace, 'box-violin')) {
      last.push(d);
    } else if (d.trace[axLetter + 'period']) {
      second.push(d);
    } else {
      first.push(d);
    }
  }
  return first.concat(second).concat(last);
}
function getCoord(axLetter, winningPoint, fullLayout) {
  var ax = winningPoint[axLetter + 'a'];
  var val = winningPoint[axLetter + 'Val'];
  var cd0 = winningPoint.cd[0];
  if (ax.type === 'category' || ax.type === 'multicategory') val = ax._categoriesMap[val];else if (ax.type === 'date') {
    var periodalignment = winningPoint.trace[axLetter + 'periodalignment'];
    if (periodalignment) {
      var d = winningPoint.cd[winningPoint.index];
      var start = d[axLetter + 'Start'];
      if (start === undefined) start = d[axLetter];
      var end = d[axLetter + 'End'];
      if (end === undefined) end = d[axLetter];
      var diff = end - start;
      if (periodalignment === 'end') {
        val += diff;
      } else if (periodalignment === 'middle') {
        val += diff / 2;
      }
    }
    val = ax.d2c(val);
  }
  if (cd0 && cd0.t && cd0.t.posLetter === ax._id) {
    if (fullLayout.boxmode === 'group' || fullLayout.violinmode === 'group') {
      val += cd0.t.dPos;
    }
  }
  return val;
}

// Top/left hover offsets relative to graph div. As long as hover content is
// a sibling of the graph div, it will be positioned correctly relative to
// the offset parent, whatever that may be.
function getTopOffset(gd) {
  return gd.offsetTop + gd.clientTop;
}
function getLeftOffset(gd) {
  return gd.offsetLeft + gd.clientLeft;
}
function getBoundingClientRect(gd, node) {
  var fullLayout = gd._fullLayout;
  var rect = node.getBoundingClientRect();
  var x0 = rect.left;
  var y0 = rect.top;
  var x1 = x0 + rect.width;
  var y1 = y0 + rect.height;
  var A = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);
  var B = Lib.apply3DTransform(fullLayout._invTransform)(x1, y1);
  var Ax = A[0];
  var Ay = A[1];
  var Bx = B[0];
  var By = B[1];
  return {
    x: Ax,
    y: Ay,
    width: Bx - Ax,
    height: By - Ay,
    top: Math.min(Ay, By),
    left: Math.min(Ax, Bx),
    right: Math.max(Ax, Bx),
    bottom: Math.max(Ay, By)
  };
}

/***/ }),

/***/ 8048:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Color = __webpack_require__(7901);
var isUnifiedHover = (__webpack_require__(3469).isUnifiedHover);
module.exports = function handleHoverLabelDefaults(contIn, contOut, coerce, opts) {
  opts = opts || {};
  var hasLegend = contOut.legend;
  function inheritFontAttr(attr) {
    if (!opts.font[attr]) {
      opts.font[attr] = hasLegend ? contOut.legend.font[attr] : contOut.font[attr];
    }
  }

  // In unified hover, inherit from layout.legend if available or layout
  if (contOut && isUnifiedHover(contOut.hovermode)) {
    if (!opts.font) opts.font = {};
    inheritFontAttr('size');
    inheritFontAttr('family');
    inheritFontAttr('color');
    if (hasLegend) {
      if (!opts.bgcolor) opts.bgcolor = Color.combine(contOut.legend.bgcolor, contOut.paper_bgcolor);
      if (!opts.bordercolor) opts.bordercolor = contOut.legend.bordercolor;
    } else {
      if (!opts.bgcolor) opts.bgcolor = contOut.paper_bgcolor;
    }
  }
  coerce('hoverlabel.bgcolor', opts.bgcolor);
  coerce('hoverlabel.bordercolor', opts.bordercolor);
  coerce('hoverlabel.namelength', opts.namelength);
  Lib.coerceFont(coerce, 'hoverlabel.font', opts.font);
  coerce('hoverlabel.align', opts.align);
};

/***/ }),

/***/ 8212:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var layoutAttributes = __webpack_require__(528);
module.exports = function handleHoverModeDefaults(layoutIn, layoutOut) {
  function coerce(attr, dflt) {
    // don't coerce if it is already coerced in other place e.g. in cartesian defaults
    if (layoutOut[attr] !== undefined) return layoutOut[attr];
    return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
  }
  coerce('clickmode');
  return coerce('hovermode');
};

/***/ }),

/***/ 211:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Lib = __webpack_require__(1828);
var dragElement = __webpack_require__(8569);
var helpers = __webpack_require__(3469);
var layoutAttributes = __webpack_require__(528);
var hoverModule = __webpack_require__(8335);
module.exports = {
  moduleType: 'component',
  name: 'fx',
  constants: __webpack_require__(6675),
  schema: {
    layout: layoutAttributes
  },
  attributes: __webpack_require__(7914),
  layoutAttributes: layoutAttributes,
  supplyLayoutGlobalDefaults: __webpack_require__(2774),
  supplyDefaults: __webpack_require__(4268),
  supplyLayoutDefaults: __webpack_require__(4938),
  calc: __webpack_require__(732),
  getDistanceFunction: helpers.getDistanceFunction,
  getClosest: helpers.getClosest,
  inbox: helpers.inbox,
  quadrature: helpers.quadrature,
  appendArrayPointValue: helpers.appendArrayPointValue,
  castHoverOption: castHoverOption,
  castHoverinfo: castHoverinfo,
  hover: hoverModule.hover,
  unhover: dragElement.unhover,
  loneHover: hoverModule.loneHover,
  loneUnhover: loneUnhover,
  click: __webpack_require__(5914)
};
function loneUnhover(containerOrSelection) {
  // duck type whether the arg is a d3 selection because ie9 doesn't
  // handle instanceof like modern browsers do.
  var selection = Lib.isD3Selection(containerOrSelection) ? containerOrSelection : d3.select(containerOrSelection);
  selection.selectAll('g.hovertext').remove();
  selection.selectAll('.spikeline').remove();
}

// helpers for traces that use Fx.loneHover

function castHoverOption(trace, ptNumber, attr) {
  return Lib.castOption(trace, ptNumber, 'hoverlabel.' + attr);
}
function castHoverinfo(trace, fullLayout, ptNumber) {
  function _coerce(val) {
    return Lib.coerceHoverinfo({
      hoverinfo: val
    }, {
      _module: trace._module
    }, fullLayout);
  }
  return Lib.castOption(trace, ptNumber, 'hoverinfo', _coerce);
}

/***/ }),

/***/ 528:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var constants = __webpack_require__(6675);
var fontAttrs = __webpack_require__(1940);
var font = fontAttrs({
  editType: 'none'
});
font.family.dflt = constants.HOVERFONT;
font.size.dflt = constants.HOVERFONTSIZE;
module.exports = {
  clickmode: {
    valType: 'flaglist',
    flags: ['event', 'select'],
    dflt: 'event',
    editType: 'plot',
    extras: ['none']
  },
  dragmode: {
    valType: 'enumerated',
    values: ['zoom', 'pan', 'select', 'lasso', 'drawclosedpath', 'drawopenpath', 'drawline', 'drawrect', 'drawcircle', 'orbit', 'turntable', false],
    dflt: 'zoom',
    editType: 'modebar'
  },
  hovermode: {
    valType: 'enumerated',
    values: ['x', 'y', 'closest', false, 'x unified', 'y unified'],
    dflt: 'closest',
    editType: 'modebar'
  },
  hoverdistance: {
    valType: 'integer',
    min: -1,
    dflt: 20,
    editType: 'none'
  },
  spikedistance: {
    valType: 'integer',
    min: -1,
    dflt: -1,
    editType: 'none'
  },
  hoverlabel: {
    bgcolor: {
      valType: 'color',
      editType: 'none'
    },
    bordercolor: {
      valType: 'color',
      editType: 'none'
    },
    font: font,
    grouptitlefont: fontAttrs({
      editType: 'none'
    }),
    align: {
      valType: 'enumerated',
      values: ['left', 'right', 'auto'],
      dflt: 'auto',
      editType: 'none'
    },
    namelength: {
      valType: 'integer',
      min: -1,
      dflt: 15,
      editType: 'none'
    },
    editType: 'none'
  },
  selectdirection: {
    valType: 'enumerated',
    values: ['h', 'v', 'd', 'any'],
    dflt: 'any',
    editType: 'none'
  }
};

/***/ }),

/***/ 4938:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var layoutAttributes = __webpack_require__(528);
var handleHoverModeDefaults = __webpack_require__(8212);
var handleHoverLabelDefaults = __webpack_require__(8048);
module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
  function coerce(attr, dflt) {
    return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
  }
  var hoverMode = handleHoverModeDefaults(layoutIn, layoutOut);
  if (hoverMode) {
    coerce('hoverdistance');
    coerce('spikedistance');
  }
  var dragMode = coerce('dragmode');
  if (dragMode === 'select') coerce('selectdirection');

  // if only mapbox or geo subplots is present on graph,
  // reset 'zoom' dragmode to 'pan' until 'zoom' is implemented,
  // so that the correct modebar button is active
  var hasMapbox = layoutOut._has('mapbox');
  var hasGeo = layoutOut._has('geo');
  var len = layoutOut._basePlotModules.length;
  if (layoutOut.dragmode === 'zoom' && ((hasMapbox || hasGeo) && len === 1 || hasMapbox && hasGeo && len === 2)) {
    layoutOut.dragmode = 'pan';
  }
  handleHoverLabelDefaults(layoutIn, layoutOut, coerce);
  Lib.coerceFont(coerce, 'hoverlabel.grouptitlefont', layoutOut.hoverlabel.font);
};

/***/ }),

/***/ 2774:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var handleHoverLabelDefaults = __webpack_require__(8048);
var layoutAttributes = __webpack_require__(528);
module.exports = function supplyLayoutGlobalDefaults(layoutIn, layoutOut) {
  function coerce(attr, dflt) {
    return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
  }
  handleHoverLabelDefaults(layoutIn, layoutOut, coerce);
};

/***/ }),

/***/ 3312:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var counterRegex = (__webpack_require__(587).counter);
var domainAttrs = (__webpack_require__(7670)/* .attributes */ .Y);
var cartesianIdRegex = (__webpack_require__(5555).idRegex);
var Template = __webpack_require__(4467);
var gridAttrs = {
  rows: {
    valType: 'integer',
    min: 1,
    editType: 'plot'
  },
  roworder: {
    valType: 'enumerated',
    values: ['top to bottom', 'bottom to top'],
    dflt: 'top to bottom',
    editType: 'plot'
  },
  columns: {
    valType: 'integer',
    min: 1,
    editType: 'plot'
  },
  subplots: {
    valType: 'info_array',
    freeLength: true,
    dimensions: 2,
    items: {
      valType: 'enumerated',
      values: [counterRegex('xy').toString(), ''],
      editType: 'plot'
    },
    editType: 'plot'
  },
  xaxes: {
    valType: 'info_array',
    freeLength: true,
    items: {
      valType: 'enumerated',
      values: [cartesianIdRegex.x.toString(), ''],
      editType: 'plot'
    },
    editType: 'plot'
  },
  yaxes: {
    valType: 'info_array',
    freeLength: true,
    items: {
      valType: 'enumerated',
      values: [cartesianIdRegex.y.toString(), ''],
      editType: 'plot'
    },
    editType: 'plot'
  },
  pattern: {
    valType: 'enumerated',
    values: ['independent', 'coupled'],
    dflt: 'coupled',
    editType: 'plot'
  },
  xgap: {
    valType: 'number',
    min: 0,
    max: 1,
    editType: 'plot'
  },
  ygap: {
    valType: 'number',
    min: 0,
    max: 1,
    editType: 'plot'
  },
  domain: domainAttrs({
    name: 'grid',
    editType: 'plot',
    noGridCell: true
  }, {}),
  xside: {
    valType: 'enumerated',
    values: ['bottom', 'bottom plot', 'top plot', 'top'],
    dflt: 'bottom plot',
    editType: 'plot'
  },
  yside: {
    valType: 'enumerated',
    values: ['left', 'left plot', 'right plot', 'right'],
    dflt: 'left plot',
    editType: 'plot'
  },
  editType: 'plot'
};
function getAxes(layout, grid, axLetter) {
  var gridVal = grid[axLetter + 'axes'];
  var splomVal = Object.keys((layout._splomAxes || {})[axLetter] || {});
  if (Array.isArray(gridVal)) return gridVal;
  if (splomVal.length) return splomVal;
}

// the shape of the grid - this needs to be done BEFORE supplyDataDefaults
// so that non-subplot traces can place themselves in the grid
function sizeDefaults(layoutIn, layoutOut) {
  var gridIn = layoutIn.grid || {};
  var xAxes = getAxes(layoutOut, gridIn, 'x');
  var yAxes = getAxes(layoutOut, gridIn, 'y');
  if (!layoutIn.grid && !xAxes && !yAxes) return;
  var hasSubplotGrid = Array.isArray(gridIn.subplots) && Array.isArray(gridIn.subplots[0]);
  var hasXaxes = Array.isArray(xAxes);
  var hasYaxes = Array.isArray(yAxes);
  var isSplomGenerated = hasXaxes && xAxes !== gridIn.xaxes && hasYaxes && yAxes !== gridIn.yaxes;
  var dfltRows, dfltColumns;
  if (hasSubplotGrid) {
    dfltRows = gridIn.subplots.length;
    dfltColumns = gridIn.subplots[0].length;
  } else {
    if (hasYaxes) dfltRows = yAxes.length;
    if (hasXaxes) dfltColumns = xAxes.length;
  }
  var gridOut = Template.newContainer(layoutOut, 'grid');
  function coerce(attr, dflt) {
    return Lib.coerce(gridIn, gridOut, gridAttrs, attr, dflt);
  }
  var rows = coerce('rows', dfltRows);
  var columns = coerce('columns', dfltColumns);
  if (!(rows * columns > 1)) {
    delete layoutOut.grid;
    return;
  }
  if (!hasSubplotGrid && !hasXaxes && !hasYaxes) {
    var useDefaultSubplots = coerce('pattern') === 'independent';
    if (useDefaultSubplots) hasSubplotGrid = true;
  }
  gridOut._hasSubplotGrid = hasSubplotGrid;
  var rowOrder = coerce('roworder');
  var reversed = rowOrder === 'top to bottom';
  var dfltGapX = hasSubplotGrid ? 0.2 : 0.1;
  var dfltGapY = hasSubplotGrid ? 0.3 : 0.1;
  var dfltSideX, dfltSideY;
  if (isSplomGenerated && layoutOut._splomGridDflt) {
    dfltSideX = layoutOut._splomGridDflt.xside;
    dfltSideY = layoutOut._splomGridDflt.yside;
  }
  gridOut._domains = {
    x: fillGridPositions('x', coerce, dfltGapX, dfltSideX, columns),
    y: fillGridPositions('y', coerce, dfltGapY, dfltSideY, rows, reversed)
  };
}

// coerce x or y sizing attributes and return an array of domains for this direction
function fillGridPositions(axLetter, coerce, dfltGap, dfltSide, len, reversed) {
  var dirGap = coerce(axLetter + 'gap', dfltGap);
  var domain = coerce('domain.' + axLetter);
  coerce(axLetter + 'side', dfltSide);
  var out = new Array(len);
  var start = domain[0];
  var step = (domain[1] - start) / (len - dirGap);
  var cellDomain = step * (1 - dirGap);
  for (var i = 0; i < len; i++) {
    var cellStart = start + step * i;
    out[reversed ? len - 1 - i : i] = [cellStart, cellStart + cellDomain];
  }
  return out;
}

// the (cartesian) contents of the grid - this needs to happen AFTER supplyDataDefaults
// so that we know what cartesian subplots are available
function contentDefaults(layoutIn, layoutOut) {
  var gridOut = layoutOut.grid;
  // make sure we got to the end of handleGridSizing
  if (!gridOut || !gridOut._domains) return;
  var gridIn = layoutIn.grid || {};
  var subplots = layoutOut._subplots;
  var hasSubplotGrid = gridOut._hasSubplotGrid;
  var rows = gridOut.rows;
  var columns = gridOut.columns;
  var useDefaultSubplots = gridOut.pattern === 'independent';
  var i, j, xId, yId, subplotId, subplotsOut, yPos;
  var axisMap = gridOut._axisMap = {};
  if (hasSubplotGrid) {
    var subplotsIn = gridIn.subplots || [];
    subplotsOut = gridOut.subplots = new Array(rows);
    var index = 1;
    for (i = 0; i < rows; i++) {
      var rowOut = subplotsOut[i] = new Array(columns);
      var rowIn = subplotsIn[i] || [];
      for (j = 0; j < columns; j++) {
        if (useDefaultSubplots) {
          subplotId = index === 1 ? 'xy' : 'x' + index + 'y' + index;
          index++;
        } else subplotId = rowIn[j];
        rowOut[j] = '';
        if (subplots.cartesian.indexOf(subplotId) !== -1) {
          yPos = subplotId.indexOf('y');
          xId = subplotId.slice(0, yPos);
          yId = subplotId.slice(yPos);
          if (axisMap[xId] !== undefined && axisMap[xId] !== j || axisMap[yId] !== undefined && axisMap[yId] !== i) {
            continue;
          }
          rowOut[j] = subplotId;
          axisMap[xId] = j;
          axisMap[yId] = i;
        }
      }
    }
  } else {
    var xAxes = getAxes(layoutOut, gridIn, 'x');
    var yAxes = getAxes(layoutOut, gridIn, 'y');
    gridOut.xaxes = fillGridAxes(xAxes, subplots.xaxis, columns, axisMap, 'x');
    gridOut.yaxes = fillGridAxes(yAxes, subplots.yaxis, rows, axisMap, 'y');
  }
  var anchors = gridOut._anchors = {};
  var reversed = gridOut.roworder === 'top to bottom';
  for (var axisId in axisMap) {
    var axLetter = axisId.charAt(0);
    var side = gridOut[axLetter + 'side'];
    var i0, inc, iFinal;
    if (side.length < 8) {
      // grid edge -  ie not "* plot" - make these as free axes
      // since we're not guaranteed to have a subplot there at all
      anchors[axisId] = 'free';
    } else if (axLetter === 'x') {
      if (side.charAt(0) === 't' === reversed) {
        i0 = 0;
        inc = 1;
        iFinal = rows;
      } else {
        i0 = rows - 1;
        inc = -1;
        iFinal = -1;
      }
      if (hasSubplotGrid) {
        var column = axisMap[axisId];
        for (i = i0; i !== iFinal; i += inc) {
          subplotId = subplotsOut[i][column];
          if (!subplotId) continue;
          yPos = subplotId.indexOf('y');
          if (subplotId.slice(0, yPos) === axisId) {
            anchors[axisId] = subplotId.slice(yPos);
            break;
          }
        }
      } else {
        for (i = i0; i !== iFinal; i += inc) {
          yId = gridOut.yaxes[i];
          if (subplots.cartesian.indexOf(axisId + yId) !== -1) {
            anchors[axisId] = yId;
            break;
          }
        }
      }
    } else {
      if (side.charAt(0) === 'l') {
        i0 = 0;
        inc = 1;
        iFinal = columns;
      } else {
        i0 = columns - 1;
        inc = -1;
        iFinal = -1;
      }
      if (hasSubplotGrid) {
        var row = axisMap[axisId];
        for (i = i0; i !== iFinal; i += inc) {
          subplotId = subplotsOut[row][i];
          if (!subplotId) continue;
          yPos = subplotId.indexOf('y');
          if (subplotId.slice(yPos) === axisId) {
            anchors[axisId] = subplotId.slice(0, yPos);
            break;
          }
        }
      } else {
        for (i = i0; i !== iFinal; i += inc) {
          xId = gridOut.xaxes[i];
          if (subplots.cartesian.indexOf(xId + axisId) !== -1) {
            anchors[axisId] = xId;
            break;
          }
        }
      }
    }
  }
}
function fillGridAxes(axesIn, axesAllowed, len, axisMap, axLetter) {
  var out = new Array(len);
  var i;
  function fillOneAxis(i, axisId) {
    if (axesAllowed.indexOf(axisId) !== -1 && axisMap[axisId] === undefined) {
      out[i] = axisId;
      axisMap[axisId] = i;
    } else out[i] = '';
  }
  if (Array.isArray(axesIn)) {
    for (i = 0; i < len; i++) {
      fillOneAxis(i, axesIn[i]);
    }
  } else {
    // default axis list is the first `len` axis ids
    fillOneAxis(0, axLetter);
    for (i = 1; i < len; i++) {
      fillOneAxis(i, axLetter + (i + 1));
    }
  }
  return out;
}
module.exports = {
  moduleType: 'component',
  name: 'grid',
  schema: {
    layout: {
      grid: gridAttrs
    }
  },
  layoutAttributes: gridAttrs,
  sizeDefaults: sizeDefaults,
  contentDefaults: contentDefaults
};

/***/ }),

/***/ 9819:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var cartesianConstants = __webpack_require__(5555);
var templatedArray = (__webpack_require__(4467).templatedArray);
var axisPlaceableObjs = __webpack_require__(4695);
module.exports = templatedArray('image', {
  visible: {
    valType: 'boolean',
    dflt: true,
    editType: 'arraydraw'
  },
  source: {
    valType: 'string',
    editType: 'arraydraw'
  },
  layer: {
    valType: 'enumerated',
    values: ['below', 'above'],
    dflt: 'above',
    editType: 'arraydraw'
  },
  sizex: {
    valType: 'number',
    dflt: 0,
    editType: 'arraydraw'
  },
  sizey: {
    valType: 'number',
    dflt: 0,
    editType: 'arraydraw'
  },
  sizing: {
    valType: 'enumerated',
    values: ['fill', 'contain', 'stretch'],
    dflt: 'contain',
    editType: 'arraydraw'
  },
  opacity: {
    valType: 'number',
    min: 0,
    max: 1,
    dflt: 1,
    editType: 'arraydraw'
  },
  x: {
    valType: 'any',
    dflt: 0,
    editType: 'arraydraw'
  },
  y: {
    valType: 'any',
    dflt: 0,
    editType: 'arraydraw'
  },
  xanchor: {
    valType: 'enumerated',
    values: ['left', 'center', 'right'],
    dflt: 'left',
    editType: 'arraydraw'
  },
  yanchor: {
    valType: 'enumerated',
    values: ['top', 'middle', 'bottom'],
    dflt: 'top',
    editType: 'arraydraw'
  },
  xref: {
    valType: 'enumerated',
    values: ['paper', cartesianConstants.idRegex.x.toString()],
    dflt: 'paper',
    editType: 'arraydraw'
  },
  yref: {
    valType: 'enumerated',
    values: ['paper', cartesianConstants.idRegex.y.toString()],
    dflt: 'paper',
    editType: 'arraydraw'
  },
  editType: 'arraydraw'
});

/***/ }),

/***/ 5378:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var toLogRange = __webpack_require__(8163);

/*
 * convertCoords: when converting an axis between log and linear
 * you need to alter any images on that axis to keep them
 * pointing at the same data point.
 * In v3.0 this will become obsolete (or perhaps size will still need conversion?)
 * we convert size by declaring that the maximum extent *in data units* should be
 * the same, assuming the image is anchored by its center (could remove that restriction
 * if we think it's important) even though the actual left and right values will not be
 * quite the same since the scale becomes nonlinear (and central anchor means the pixel
 * center of the image, not the data units center)
 *
 * gd: the plot div
 * ax: the axis being changed
 * newType: the type it's getting
 * doExtra: function(attr, val) from inside relayout that sets the attribute.
 *     Use this to make the changes as it's aware if any other changes in the
 *     same relayout call should override this conversion.
 */
module.exports = function convertCoords(gd, ax, newType, doExtra) {
  ax = ax || {};
  var toLog = newType === 'log' && ax.type === 'linear';
  var fromLog = newType === 'linear' && ax.type === 'log';
  if (!(toLog || fromLog)) return;
  var images = gd._fullLayout.images;
  var axLetter = ax._id.charAt(0);
  var image;
  var attrPrefix;
  for (var i = 0; i < images.length; i++) {
    image = images[i];
    attrPrefix = 'images[' + i + '].';
    if (image[axLetter + 'ref'] === ax._id) {
      var currentPos = image[axLetter];
      var currentSize = image['size' + axLetter];
      var newPos = null;
      var newSize = null;
      if (toLog) {
        newPos = toLogRange(currentPos, ax.range);

        // this is the inverse of the conversion we do in fromLog below
        // so that the conversion is reversible (notice the fromLog conversion
        // is like sinh, and this one looks like arcsinh)
        var dx = currentSize / Math.pow(10, newPos) / 2;
        newSize = 2 * Math.log(dx + Math.sqrt(1 + dx * dx)) / Math.LN10;
      } else {
        newPos = Math.pow(10, currentPos);
        newSize = newPos * (Math.pow(10, currentSize / 2) - Math.pow(10, -currentSize / 2));
      }

      // if conversion failed, delete the value so it can get a default later on
      if (!isNumeric(newPos)) {
        newPos = null;
        newSize = null;
      } else if (!isNumeric(newSize)) newSize = null;
      doExtra(attrPrefix + axLetter, newPos);
      doExtra(attrPrefix + 'size' + axLetter, newSize);
    }
  }
};

/***/ }),

/***/ 1603:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Axes = __webpack_require__(9298);
var handleArrayContainerDefaults = __webpack_require__(5501);
var attributes = __webpack_require__(9819);
var name = 'images';
module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
  var opts = {
    name: name,
    handleItemDefaults: imageDefaults
  };
  handleArrayContainerDefaults(layoutIn, layoutOut, opts);
};
function imageDefaults(imageIn, imageOut, fullLayout) {
  function coerce(attr, dflt) {
    return Lib.coerce(imageIn, imageOut, attributes, attr, dflt);
  }
  var source = coerce('source');
  var visible = coerce('visible', !!source);
  if (!visible) return imageOut;
  coerce('layer');
  coerce('xanchor');
  coerce('yanchor');
  coerce('sizex');
  coerce('sizey');
  coerce('sizing');
  coerce('opacity');
  var gdMock = {
    _fullLayout: fullLayout
  };
  var axLetters = ['x', 'y'];
  for (var i = 0; i < 2; i++) {
    // 'paper' is the fallback axref
    var axLetter = axLetters[i];
    var axRef = Axes.coerceRef(imageIn, imageOut, gdMock, axLetter, 'paper', undefined);
    if (axRef !== 'paper') {
      var ax = Axes.getFromId(gdMock, axRef);
      ax._imgIndices.push(imageOut._index);
    }
    Axes.coercePosition(imageOut, gdMock, coerce, axRef, axLetter, 0);
  }
  return imageOut;
}

/***/ }),

/***/ 750:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Drawing = __webpack_require__(1424);
var Axes = __webpack_require__(9298);
var axisIds = __webpack_require__(1675);
var xmlnsNamespaces = __webpack_require__(7922);
module.exports = function draw(gd) {
  var fullLayout = gd._fullLayout;
  var imageDataAbove = [];
  var imageDataSubplot = {};
  var imageDataBelow = [];
  var subplot;
  var i;

  // Sort into top, subplot, and bottom layers
  for (i = 0; i < fullLayout.images.length; i++) {
    var img = fullLayout.images[i];
    if (img.visible) {
      if (img.layer === 'below' && img.xref !== 'paper' && img.yref !== 'paper') {
        subplot = axisIds.ref2id(img.xref) + axisIds.ref2id(img.yref);
        var plotinfo = fullLayout._plots[subplot];
        if (!plotinfo) {
          // Fall back to _imageLowerLayer in case the requested subplot doesn't exist.
          // This can happen if you reference the image to an x / y axis combination
          // that doesn't have any data on it (and layer is below)
          imageDataBelow.push(img);
          continue;
        }
        if (plotinfo.mainplot) {
          subplot = plotinfo.mainplot.id;
        }
        if (!imageDataSubplot[subplot]) {
          imageDataSubplot[subplot] = [];
        }
        imageDataSubplot[subplot].push(img);
      } else if (img.layer === 'above') {
        imageDataAbove.push(img);
      } else {
        imageDataBelow.push(img);
      }
    }
  }
  var anchors = {
    x: {
      left: {
        sizing: 'xMin',
        offset: 0
      },
      center: {
        sizing: 'xMid',
        offset: -1 / 2
      },
      right: {
        sizing: 'xMax',
        offset: -1
      }
    },
    y: {
      top: {
        sizing: 'YMin',
        offset: 0
      },
      middle: {
        sizing: 'YMid',
        offset: -1 / 2
      },
      bottom: {
        sizing: 'YMax',
        offset: -1
      }
    }
  };

  // Images must be converted to dataURL's for exporting.
  function setImage(d) {
    var thisImage = d3.select(this);
    if (this._imgSrc === d.source) {
      return;
    }
    thisImage.attr('xmlns', xmlnsNamespaces.svg);
    if (d.source && d.source.slice(0, 5) === 'data:') {
      thisImage.attr('xlink:href', d.source);
      this._imgSrc = d.source;
    } else {
      var imagePromise = new Promise(function (resolve) {
        var img = new Image();
        this.img = img;

        // If not set, a `tainted canvas` error is thrown
        img.setAttribute('crossOrigin', 'anonymous');
        img.onerror = errorHandler;
        img.onload = function () {
          var canvas = document.createElement('canvas');
          canvas.width = this.width;
          canvas.height = this.height;
          var ctx = canvas.getContext('2d', {
            willReadFrequently: true
          });
          ctx.drawImage(this, 0, 0);
          var dataURL = canvas.toDataURL('image/png');
          thisImage.attr('xlink:href', dataURL);

          // resolve promise in onload handler instead of on 'load' to support IE11
          // see https://github.com/plotly/plotly.js/issues/1685
          // for more details
          resolve();
        };
        thisImage.on('error', errorHandler);
        img.src = d.source;
        this._imgSrc = d.source;
        function errorHandler() {
          thisImage.remove();
          resolve();
        }
      }.bind(this));
      gd._promises.push(imagePromise);
    }
  }
  function applyAttributes(d) {
    var thisImage = d3.select(this);

    // Axes if specified
    var xa = Axes.getFromId(gd, d.xref);
    var ya = Axes.getFromId(gd, d.yref);
    var xIsDomain = Axes.getRefType(d.xref) === 'domain';
    var yIsDomain = Axes.getRefType(d.yref) === 'domain';
    var size = fullLayout._size;
    var width, height;
    if (xa !== undefined) {
      width = typeof d.xref === 'string' && xIsDomain ? xa._length * d.sizex : Math.abs(xa.l2p(d.sizex) - xa.l2p(0));
    } else {
      width = d.sizex * size.w;
    }
    if (ya !== undefined) {
      height = typeof d.yref === 'string' && yIsDomain ? ya._length * d.sizey : Math.abs(ya.l2p(d.sizey) - ya.l2p(0));
    } else {
      height = d.sizey * size.h;
    }

    // Offsets for anchor positioning
    var xOffset = width * anchors.x[d.xanchor].offset;
    var yOffset = height * anchors.y[d.yanchor].offset;
    var sizing = anchors.x[d.xanchor].sizing + anchors.y[d.yanchor].sizing;

    // Final positions
    var xPos, yPos;
    if (xa !== undefined) {
      xPos = typeof d.xref === 'string' && xIsDomain ? xa._length * d.x + xa._offset : xa.r2p(d.x) + xa._offset;
    } else {
      xPos = d.x * size.w + size.l;
    }
    xPos += xOffset;
    if (ya !== undefined) {
      yPos = typeof d.yref === 'string' && yIsDomain ?
      // consistent with "paper" yref value, where positive values
      // move up the page
      ya._length * (1 - d.y) + ya._offset : ya.r2p(d.y) + ya._offset;
    } else {
      yPos = size.h - d.y * size.h + size.t;
    }
    yPos += yOffset;

    // Construct the proper aspectRatio attribute
    switch (d.sizing) {
      case 'fill':
        sizing += ' slice';
        break;
      case 'stretch':
        sizing = 'none';
        break;
    }
    thisImage.attr({
      x: xPos,
      y: yPos,
      width: width,
      height: height,
      preserveAspectRatio: sizing,
      opacity: d.opacity
    });

    // Set proper clipping on images
    var xId = xa && Axes.getRefType(d.xref) !== 'domain' ? xa._id : '';
    var yId = ya && Axes.getRefType(d.yref) !== 'domain' ? ya._id : '';
    var clipAxes = xId + yId;
    Drawing.setClipUrl(thisImage, clipAxes ? 'clip' + fullLayout._uid + clipAxes : null, gd);
  }
  var imagesBelow = fullLayout._imageLowerLayer.selectAll('image').data(imageDataBelow);
  var imagesAbove = fullLayout._imageUpperLayer.selectAll('image').data(imageDataAbove);
  imagesBelow.enter().append('image');
  imagesAbove.enter().append('image');
  imagesBelow.exit().remove();
  imagesAbove.exit().remove();
  imagesBelow.each(function (d) {
    setImage.bind(this)(d);
    applyAttributes.bind(this)(d);
  });
  imagesAbove.each(function (d) {
    setImage.bind(this)(d);
    applyAttributes.bind(this)(d);
  });
  var allSubplots = Object.keys(fullLayout._plots);
  for (i = 0; i < allSubplots.length; i++) {
    subplot = allSubplots[i];
    var subplotObj = fullLayout._plots[subplot];

    // filter out overlaid plots (which have their images on the main plot)
    // and gl2d plots (which don't support below images, at least not yet)
    if (!subplotObj.imagelayer) continue;
    var imagesOnSubplot = subplotObj.imagelayer.selectAll('image')
    // even if there are no images on this subplot, we need to run
    // enter and exit in case there were previously
    .data(imageDataSubplot[subplot] || []);
    imagesOnSubplot.enter().append('image');
    imagesOnSubplot.exit().remove();
    imagesOnSubplot.each(function (d) {
      setImage.bind(this)(d);
      applyAttributes.bind(this)(d);
    });
  }
};

/***/ }),

/***/ 8804:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  moduleType: 'component',
  name: 'images',
  layoutAttributes: __webpack_require__(9819),
  supplyLayoutDefaults: __webpack_require__(1603),
  includeBasePlot: __webpack_require__(6325)('images'),
  draw: __webpack_require__(750),
  convertCoords: __webpack_require__(5378)
};

/***/ }),

/***/ 3030:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var fontAttrs = __webpack_require__(1940);
var colorAttrs = __webpack_require__(2399);
module.exports = {
  // not really a 'subplot' attribute container,
  // but this is the flag we use to denote attributes that
  // support yaxis, yaxis2, yaxis3, ... counters
  _isSubplotObj: true,
  visible: {
    valType: 'boolean',
    dflt: true,
    editType: 'legend'
  },
  bgcolor: {
    valType: 'color',
    editType: 'legend'
  },
  bordercolor: {
    valType: 'color',
    dflt: colorAttrs.defaultLine,
    editType: 'legend'
  },
  borderwidth: {
    valType: 'number',
    min: 0,
    dflt: 0,
    editType: 'legend'
  },
  font: fontAttrs({
    editType: 'legend'
  }),
  grouptitlefont: fontAttrs({
    editType: 'legend'
  }),
  orientation: {
    valType: 'enumerated',
    values: ['v', 'h'],
    dflt: 'v',
    editType: 'legend'
  },
  traceorder: {
    valType: 'flaglist',
    flags: ['reversed', 'grouped'],
    extras: ['normal'],
    editType: 'legend'
  },
  tracegroupgap: {
    valType: 'number',
    min: 0,
    dflt: 10,
    editType: 'legend'
  },
  entrywidth: {
    valType: 'number',
    min: 0,
    editType: 'legend'
  },
  entrywidthmode: {
    valType: 'enumerated',
    values: ['fraction', 'pixels'],
    dflt: 'pixels',
    editType: 'legend'
  },
  itemsizing: {
    valType: 'enumerated',
    values: ['trace', 'constant'],
    dflt: 'trace',
    editType: 'legend'
  },
  itemwidth: {
    valType: 'number',
    min: 30,
    dflt: 30,
    editType: 'legend'
  },
  itemclick: {
    valType: 'enumerated',
    values: ['toggle', 'toggleothers', false],
    dflt: 'toggle',
    editType: 'legend'
  },
  itemdoubleclick: {
    valType: 'enumerated',
    values: ['toggle', 'toggleothers', false],
    dflt: 'toggleothers',
    editType: 'legend'
  },
  groupclick: {
    valType: 'enumerated',
    values: ['toggleitem', 'togglegroup'],
    dflt: 'togglegroup',
    editType: 'legend'
  },
  x: {
    valType: 'number',
    editType: 'legend'
  },
  xref: {
    valType: 'enumerated',
    dflt: 'paper',
    values: ['container', 'paper'],
    editType: 'layoutstyle'
  },
  xanchor: {
    valType: 'enumerated',
    values: ['auto', 'left', 'center', 'right'],
    dflt: 'left',
    editType: 'legend'
  },
  y: {
    valType: 'number',
    editType: 'legend'
  },
  yref: {
    valType: 'enumerated',
    dflt: 'paper',
    values: ['container', 'paper'],
    editType: 'layoutstyle'
  },
  yanchor: {
    valType: 'enumerated',
    values: ['auto', 'top', 'middle', 'bottom'],
    editType: 'legend'
  },
  uirevision: {
    valType: 'any',
    editType: 'none'
  },
  valign: {
    valType: 'enumerated',
    values: ['top', 'middle', 'bottom'],
    dflt: 'middle',
    editType: 'legend'
  },
  title: {
    text: {
      valType: 'string',
      dflt: '',
      editType: 'legend'
    },
    font: fontAttrs({
      editType: 'legend'
    }),
    side: {
      valType: 'enumerated',
      values: ['top', 'left', 'top left', 'top center', 'top right'],
      editType: 'legend'
    },
    editType: 'legend'
  },
  editType: 'legend'
};

/***/ }),

/***/ 4928:
/***/ (function(module) {

"use strict";


module.exports = {
  scrollBarWidth: 6,
  scrollBarMinHeight: 20,
  scrollBarColor: '#808BA4',
  scrollBarMargin: 4,
  scrollBarEnterAttrs: {
    rx: 20,
    ry: 3,
    width: 0,
    height: 0
  },
  // number of px between legend title and (left) side of legend (always in x direction and from inner border)
  titlePad: 2,
  // number of px between each legend item (x and/or y direction)
  itemGap: 5
};

/***/ }),

/***/ 9017:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var Template = __webpack_require__(4467);
var plotsAttrs = __webpack_require__(9012);
var attributes = __webpack_require__(3030);
var basePlotLayoutAttributes = __webpack_require__(820);
var helpers = __webpack_require__(130);
function groupDefaults(legendId, layoutIn, layoutOut, fullData) {
  var containerIn = layoutIn[legendId] || {};
  var containerOut = Template.newContainer(layoutOut, legendId);
  function coerce(attr, dflt) {
    return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
  }

  // N.B. unified hover needs to inherit from font, bgcolor & bordercolor even when legend.visible is false
  var itemFont = Lib.coerceFont(coerce, 'font', layoutOut.font);
  coerce('bgcolor', layoutOut.paper_bgcolor);
  coerce('bordercolor');
  var visible = coerce('visible');
  if (!visible) return;
  var trace;
  var traceCoerce = function (attr, dflt) {
    var traceIn = trace._input;
    var traceOut = trace;
    return Lib.coerce(traceIn, traceOut, plotsAttrs, attr, dflt);
  };
  var globalFont = layoutOut.font || {};
  var grouptitlefont = Lib.coerceFont(coerce, 'grouptitlefont', Lib.extendFlat({}, globalFont, {
    size: Math.round(globalFont.size * 1.1)
  }));
  var legendTraceCount = 0;
  var legendReallyHasATrace = false;
  var defaultOrder = 'normal';
  var shapesWithLegend = (layoutOut.shapes || []).filter(function (d) {
    return d.showlegend;
  });
  var allLegendItems = fullData.concat(shapesWithLegend).filter(function (d) {
    return legendId === (d.legend || 'legend');
  });
  for (var i = 0; i < allLegendItems.length; i++) {
    trace = allLegendItems[i];
    if (!trace.visible) continue;
    var isShape = trace._isShape;

    // Note that we explicitly count any trace that is either shown or
    // *would* be shown by default, toward the two traces you need to
    // ensure the legend is shown by default, because this can still help
    // disambiguate.
    if (trace.showlegend || trace._dfltShowLegend && !(trace._module && trace._module.attributes && trace._module.attributes.showlegend && trace._module.attributes.showlegend.dflt === false)) {
      legendTraceCount++;
      if (trace.showlegend) {
        legendReallyHasATrace = true;
        // Always show the legend by default if there's a pie,
        // or if there's only one trace but it's explicitly shown
        if (!isShape && Registry.traceIs(trace, 'pie-like') || trace._input.showlegend === true) {
          legendTraceCount++;
        }
      }
      Lib.coerceFont(traceCoerce, 'legendgrouptitle.font', grouptitlefont);
    }
    if (!isShape && Registry.traceIs(trace, 'bar') && layoutOut.barmode === 'stack' || ['tonextx', 'tonexty'].indexOf(trace.fill) !== -1) {
      defaultOrder = helpers.isGrouped({
        traceorder: defaultOrder
      }) ? 'grouped+reversed' : 'reversed';
    }
    if (trace.legendgroup !== undefined && trace.legendgroup !== '') {
      defaultOrder = helpers.isReversed({
        traceorder: defaultOrder
      }) ? 'reversed+grouped' : 'grouped';
    }
  }
  var showLegend = Lib.coerce(layoutIn, layoutOut, basePlotLayoutAttributes, 'showlegend', legendReallyHasATrace && legendTraceCount > (legendId === 'legend' ? 1 : 0));

  // delete legend
  if (showLegend === false) layoutOut[legendId] = undefined;
  if (showLegend === false && !containerIn.uirevision) return;
  coerce('uirevision', layoutOut.uirevision);
  if (showLegend === false) return;
  coerce('borderwidth');
  var orientation = coerce('orientation');
  var yref = coerce('yref');
  var xref = coerce('xref');
  var isHorizontal = orientation === 'h';
  var isPaperY = yref === 'paper';
  var isPaperX = xref === 'paper';
  var defaultX, defaultY, defaultYAnchor;
  var defaultXAnchor = 'left';
  if (isHorizontal) {
    defaultX = 0;
    if (Registry.getComponentMethod('rangeslider', 'isVisible')(layoutIn.xaxis)) {
      if (isPaperY) {
        defaultY = 1.1;
        defaultYAnchor = 'bottom';
      } else {
        defaultY = 1;
        defaultYAnchor = 'top';
      }
    } else {
      // maybe use y=1.1 / yanchor=bottom as above
      //   to avoid https://github.com/plotly/plotly.js/issues/1199
      //   in v3
      if (isPaperY) {
        defaultY = -0.1;
        defaultYAnchor = 'top';
      } else {
        defaultY = 0;
        defaultYAnchor = 'bottom';
      }
    }
  } else {
    defaultY = 1;
    defaultYAnchor = 'auto';
    if (isPaperX) {
      defaultX = 1.02;
    } else {
      defaultX = 1;
      defaultXAnchor = 'right';
    }
  }
  Lib.coerce(containerIn, containerOut, {
    x: {
      valType: 'number',
      editType: 'legend',
      min: isPaperX ? -2 : 0,
      max: isPaperX ? 3 : 1,
      dflt: defaultX
    }
  }, 'x');
  Lib.coerce(containerIn, containerOut, {
    y: {
      valType: 'number',
      editType: 'legend',
      min: isPaperY ? -2 : 0,
      max: isPaperY ? 3 : 1,
      dflt: defaultY
    }
  }, 'y');
  coerce('traceorder', defaultOrder);
  if (helpers.isGrouped(layoutOut[legendId])) coerce('tracegroupgap');
  coerce('entrywidth');
  coerce('entrywidthmode');
  coerce('itemsizing');
  coerce('itemwidth');
  coerce('itemclick');
  coerce('itemdoubleclick');
  coerce('groupclick');
  coerce('xanchor', defaultXAnchor);
  coerce('yanchor', defaultYAnchor);
  coerce('valign');
  Lib.noneOrAll(containerIn, containerOut, ['x', 'y']);
  var titleText = coerce('title.text');
  if (titleText) {
    coerce('title.side', isHorizontal ? 'left' : 'top');
    var dfltTitleFont = Lib.extendFlat({}, itemFont, {
      size: Lib.bigFont(itemFont.size)
    });
    Lib.coerceFont(coerce, 'title.font', dfltTitleFont);
  }
}
module.exports = function legendDefaults(layoutIn, layoutOut, fullData) {
  var i;
  var allLegendsData = fullData.slice();

  // shapes could also show up in legends
  var shapes = layoutOut.shapes;
  if (shapes) {
    for (i = 0; i < shapes.length; i++) {
      var shape = shapes[i];
      if (!shape.showlegend) continue;
      var mockTrace = {
        _input: shape._input,
        visible: shape.visible,
        showlegend: shape.showlegend,
        legend: shape.legend
      };
      allLegendsData.push(mockTrace);
    }
  }
  var legends = ['legend'];
  for (i = 0; i < allLegendsData.length; i++) {
    Lib.pushUnique(legends, allLegendsData[i].legend);
  }
  layoutOut._legends = [];
  for (i = 0; i < legends.length; i++) {
    var legendId = legends[i];
    groupDefaults(legendId, layoutIn, layoutOut, allLegendsData);
    if (layoutOut[legendId] && layoutOut[legendId].visible) {
      layoutOut[legendId]._id = legendId;
    }
    layoutOut._legends.push(legendId);
  }
};

/***/ }),

/***/ 3969:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Lib = __webpack_require__(1828);
var Plots = __webpack_require__(4875);
var Registry = __webpack_require__(3972);
var Events = __webpack_require__(1086);
var dragElement = __webpack_require__(8569);
var Drawing = __webpack_require__(1424);
var Color = __webpack_require__(7901);
var svgTextUtils = __webpack_require__(3893);
var handleClick = __webpack_require__(5167);
var constants = __webpack_require__(4928);
var alignmentConstants = __webpack_require__(8783);
var LINE_SPACING = alignmentConstants.LINE_SPACING;
var FROM_TL = alignmentConstants.FROM_TL;
var FROM_BR = alignmentConstants.FROM_BR;
var getLegendData = __webpack_require__(2424);
var style = __webpack_require__(3630);
var helpers = __webpack_require__(130);
var MAIN_TITLE = 1;
var LEGEND_PATTERN = /^legend[0-9]*$/;
module.exports = function draw(gd, opts) {
  if (opts) {
    drawOne(gd, opts);
  } else {
    var fullLayout = gd._fullLayout;
    var newLegends = fullLayout._legends;

    // remove old legends that won't stay on the graph
    var oldLegends = fullLayout._infolayer.selectAll('[class^="legend"]');
    oldLegends.each(function () {
      var el = d3.select(this);
      var classes = el.attr('class');
      var cls = classes.split(' ')[0];
      if (cls.match(LEGEND_PATTERN) && newLegends.indexOf(cls) === -1) {
        el.remove();
      }
    });

    // draw/update new legends
    for (var i = 0; i < newLegends.length; i++) {
      var legendId = newLegends[i];
      var legendObj = gd._fullLayout[legendId];
      drawOne(gd, legendObj);
    }
  }
};

// After legend dimensions are calculated the title can be aligned horizontally left, center, right
function horizontalAlignTitle(titleEl, legendObj, bw) {
  if (legendObj.title.side !== 'top center' && legendObj.title.side !== 'top right') return;
  var font = legendObj.title.font;
  var lineHeight = font.size * LINE_SPACING;
  var titleOffset = 0;
  var textNode = titleEl.node();
  var width = Drawing.bBox(textNode).width; // width of the title text

  if (legendObj.title.side === 'top center') {
    titleOffset = 0.5 * (legendObj._width - 2 * bw - 2 * constants.titlePad - width);
  } else if (legendObj.title.side === 'top right') {
    titleOffset = legendObj._width - 2 * bw - 2 * constants.titlePad - width;
  }
  svgTextUtils.positionText(titleEl, bw + constants.titlePad + titleOffset, bw + lineHeight);
}
function drawOne(gd, opts) {
  var legendObj = opts || {};
  var fullLayout = gd._fullLayout;
  var legendId = getId(legendObj);
  var clipId, layer;
  var inHover = legendObj._inHover;
  if (inHover) {
    layer = legendObj.layer;
    clipId = 'hover';
  } else {
    layer = fullLayout._infolayer;
    clipId = legendId;
  }
  if (!layer) return;
  clipId += fullLayout._uid;
  if (!gd._legendMouseDownTime) gd._legendMouseDownTime = 0;
  var legendData;
  if (!inHover) {
    var calcdata = (gd.calcdata || []).slice();
    var shapes = fullLayout.shapes;
    for (var i = 0; i < shapes.length; i++) {
      var shape = shapes[i];
      if (!shape.showlegend) continue;
      var shapeLegend = {
        _isShape: true,
        _fullInput: shape,
        index: shape._index,
        name: shape.name || shape.label.text || 'shape ' + shape._index,
        legend: shape.legend,
        legendgroup: shape.legendgroup,
        legendgrouptitle: shape.legendgrouptitle,
        legendrank: shape.legendrank,
        legendwidth: shape.legendwidth,
        showlegend: shape.showlegend,
        visible: shape.visible,
        opacity: shape.opacity,
        mode: shape.type === 'line' ? 'lines' : 'markers',
        line: shape.line,
        marker: {
          line: shape.line,
          color: shape.fillcolor,
          size: 12,
          symbol: shape.type === 'rect' ? 'square' : shape.type === 'circle' ? 'circle' :
          // case of path
          'hexagon2'
        }
      };
      calcdata.push([{
        trace: shapeLegend
      }]);
    }
    legendData = fullLayout.showlegend && getLegendData(calcdata, legendObj, fullLayout._legends.length > 1);
  } else {
    if (!legendObj.entries) return;
    legendData = getLegendData(legendObj.entries, legendObj);
  }
  var hiddenSlices = fullLayout.hiddenlabels || [];
  if (!inHover && (!fullLayout.showlegend || !legendData.length)) {
    layer.selectAll('.' + legendId).remove();
    fullLayout._topdefs.select('#' + clipId).remove();
    return Plots.autoMargin(gd, legendId);
  }
  var legend = Lib.ensureSingle(layer, 'g', legendId, function (s) {
    if (!inHover) s.attr('pointer-events', 'all');
  });
  var clipPath = Lib.ensureSingleById(fullLayout._topdefs, 'clipPath', clipId, function (s) {
    s.append('rect');
  });
  var bg = Lib.ensureSingle(legend, 'rect', 'bg', function (s) {
    s.attr('shape-rendering', 'crispEdges');
  });
  bg.call(Color.stroke, legendObj.bordercolor).call(Color.fill, legendObj.bgcolor).style('stroke-width', legendObj.borderwidth + 'px');
  var scrollBox = Lib.ensureSingle(legend, 'g', 'scrollbox');
  var title = legendObj.title;
  legendObj._titleWidth = 0;
  legendObj._titleHeight = 0;
  var titleEl;
  if (title.text) {
    titleEl = Lib.ensureSingle(scrollBox, 'text', legendId + 'titletext');
    titleEl.attr('text-anchor', 'start').call(Drawing.font, title.font).text(title.text);
    textLayout(titleEl, scrollBox, gd, legendObj, MAIN_TITLE); // handle mathjax or multi-line text and compute title height
  } else {
    scrollBox.selectAll('.' + legendId + 'titletext').remove();
  }
  var scrollBar = Lib.ensureSingle(legend, 'rect', 'scrollbar', function (s) {
    s.attr(constants.scrollBarEnterAttrs).call(Color.fill, constants.scrollBarColor);
  });
  var groups = scrollBox.selectAll('g.groups').data(legendData);
  groups.enter().append('g').attr('class', 'groups');
  groups.exit().remove();
  var traces = groups.selectAll('g.traces').data(Lib.identity);
  traces.enter().append('g').attr('class', 'traces');
  traces.exit().remove();
  traces.style('opacity', function (d) {
    var trace = d[0].trace;
    if (Registry.traceIs(trace, 'pie-like')) {
      return hiddenSlices.indexOf(d[0].label) !== -1 ? 0.5 : 1;
    } else {
      return trace.visible === 'legendonly' ? 0.5 : 1;
    }
  }).each(function () {
    d3.select(this).call(drawTexts, gd, legendObj);
  }).call(style, gd, legendObj).each(function () {
    if (!inHover) d3.select(this).call(setupTraceToggle, gd, legendId);
  });
  Lib.syncOrAsync([Plots.previousPromises, function () {
    return computeLegendDimensions(gd, groups, traces, legendObj);
  }, function () {
    var gs = fullLayout._size;
    var bw = legendObj.borderwidth;
    var isPaperX = legendObj.xref === 'paper';
    var isPaperY = legendObj.yref === 'paper';

    // re-calculate title position after legend width is derived. To allow for horizontal alignment
    if (title.text) {
      horizontalAlignTitle(titleEl, legendObj, bw);
    }
    if (!inHover) {
      var lx, ly;
      if (isPaperX) {
        lx = gs.l + gs.w * legendObj.x - FROM_TL[getXanchor(legendObj)] * legendObj._width;
      } else {
        lx = fullLayout.width * legendObj.x - FROM_TL[getXanchor(legendObj)] * legendObj._width;
      }
      if (isPaperY) {
        ly = gs.t + gs.h * (1 - legendObj.y) - FROM_TL[getYanchor(legendObj)] * legendObj._effHeight;
      } else {
        ly = fullLayout.height * (1 - legendObj.y) - FROM_TL[getYanchor(legendObj)] * legendObj._effHeight;
      }
      var expMargin = expandMargin(gd, legendId, lx, ly);

      // IF expandMargin return a Promise (which is truthy),
      // we're under a doAutoMargin redraw, so we don't have to
      // draw the remaining pieces below
      if (expMargin) return;
      if (fullLayout.margin.autoexpand) {
        var lx0 = lx;
        var ly0 = ly;
        lx = isPaperX ? Lib.constrain(lx, 0, fullLayout.width - legendObj._width) : lx0;
        ly = isPaperY ? Lib.constrain(ly, 0, fullLayout.height - legendObj._effHeight) : ly0;
        if (lx !== lx0) {
          Lib.log('Constrain ' + legendId + '.x to make legend fit inside graph');
        }
        if (ly !== ly0) {
          Lib.log('Constrain ' + legendId + '.y to make legend fit inside graph');
        }
      }

      // Set size and position of all the elements that make up a legend:
      // legend, background and border, scroll box and scroll bar as well as title
      Drawing.setTranslate(legend, lx, ly);
    }

    // to be safe, remove previous listeners
    scrollBar.on('.drag', null);
    legend.on('wheel', null);
    if (inHover || legendObj._height <= legendObj._maxHeight || gd._context.staticPlot) {
      // if scrollbar should not be shown.
      var height = legendObj._effHeight;

      // if unified hover, let it be its full size
      if (inHover) height = legendObj._height;
      bg.attr({
        width: legendObj._width - bw,
        height: height - bw,
        x: bw / 2,
        y: bw / 2
      });
      Drawing.setTranslate(scrollBox, 0, 0);
      clipPath.select('rect').attr({
        width: legendObj._width - 2 * bw,
        height: height - 2 * bw,
        x: bw,
        y: bw
      });
      Drawing.setClipUrl(scrollBox, clipId, gd);
      Drawing.setRect(scrollBar, 0, 0, 0, 0);
      delete legendObj._scrollY;
    } else {
      var scrollBarHeight = Math.max(constants.scrollBarMinHeight, legendObj._effHeight * legendObj._effHeight / legendObj._height);
      var scrollBarYMax = legendObj._effHeight - scrollBarHeight - 2 * constants.scrollBarMargin;
      var scrollBoxYMax = legendObj._height - legendObj._effHeight;
      var scrollRatio = scrollBarYMax / scrollBoxYMax;
      var scrollBoxY = Math.min(legendObj._scrollY || 0, scrollBoxYMax);

      // increase the background and clip-path width
      // by the scrollbar width and margin
      bg.attr({
        width: legendObj._width - 2 * bw + constants.scrollBarWidth + constants.scrollBarMargin,
        height: legendObj._effHeight - bw,
        x: bw / 2,
        y: bw / 2
      });
      clipPath.select('rect').attr({
        width: legendObj._width - 2 * bw + constants.scrollBarWidth + constants.scrollBarMargin,
        height: legendObj._effHeight - 2 * bw,
        x: bw,
        y: bw + scrollBoxY
      });
      Drawing.setClipUrl(scrollBox, clipId, gd);
      scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);

      // scroll legend by mousewheel or touchpad swipe up/down
      legend.on('wheel', function () {
        scrollBoxY = Lib.constrain(legendObj._scrollY + d3.event.deltaY / scrollBarYMax * scrollBoxYMax, 0, scrollBoxYMax);
        scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);
        if (scrollBoxY !== 0 && scrollBoxY !== scrollBoxYMax) {
          d3.event.preventDefault();
        }
      });
      var eventY0, eventY1, scrollBoxY0;
      var getScrollBarDragY = function (scrollBoxY0, eventY0, eventY1) {
        var y = (eventY1 - eventY0) / scrollRatio + scrollBoxY0;
        return Lib.constrain(y, 0, scrollBoxYMax);
      };
      var getNaturalDragY = function (scrollBoxY0, eventY0, eventY1) {
        var y = (eventY0 - eventY1) / scrollRatio + scrollBoxY0;
        return Lib.constrain(y, 0, scrollBoxYMax);
      };

      // scroll legend by dragging scrollBAR
      var scrollBarDrag = d3.behavior.drag().on('dragstart', function () {
        var e = d3.event.sourceEvent;
        if (e.type === 'touchstart') {
          eventY0 = e.changedTouches[0].clientY;
        } else {
          eventY0 = e.clientY;
        }
        scrollBoxY0 = scrollBoxY;
      }).on('drag', function () {
        var e = d3.event.sourceEvent;
        if (e.buttons === 2 || e.ctrlKey) return;
        if (e.type === 'touchmove') {
          eventY1 = e.changedTouches[0].clientY;
        } else {
          eventY1 = e.clientY;
        }
        scrollBoxY = getScrollBarDragY(scrollBoxY0, eventY0, eventY1);
        scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);
      });
      scrollBar.call(scrollBarDrag);

      // scroll legend by touch-dragging scrollBOX
      var scrollBoxTouchDrag = d3.behavior.drag().on('dragstart', function () {
        var e = d3.event.sourceEvent;
        if (e.type === 'touchstart') {
          eventY0 = e.changedTouches[0].clientY;
          scrollBoxY0 = scrollBoxY;
        }
      }).on('drag', function () {
        var e = d3.event.sourceEvent;
        if (e.type === 'touchmove') {
          eventY1 = e.changedTouches[0].clientY;
          scrollBoxY = getNaturalDragY(scrollBoxY0, eventY0, eventY1);
          scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);
        }
      });
      scrollBox.call(scrollBoxTouchDrag);
    }
    function scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio) {
      legendObj._scrollY = gd._fullLayout[legendId]._scrollY = scrollBoxY;
      Drawing.setTranslate(scrollBox, 0, -scrollBoxY);
      Drawing.setRect(scrollBar, legendObj._width, constants.scrollBarMargin + scrollBoxY * scrollRatio, constants.scrollBarWidth, scrollBarHeight);
      clipPath.select('rect').attr('y', bw + scrollBoxY);
    }
    if (gd._context.edits.legendPosition) {
      var xf, yf, x0, y0;
      legend.classed('cursor-move', true);
      dragElement.init({
        element: legend.node(),
        gd: gd,
        prepFn: function () {
          var transform = Drawing.getTranslate(legend);
          x0 = transform.x;
          y0 = transform.y;
        },
        moveFn: function (dx, dy) {
          var newX = x0 + dx;
          var newY = y0 + dy;
          Drawing.setTranslate(legend, newX, newY);
          xf = dragElement.align(newX, legendObj._width, gs.l, gs.l + gs.w, legendObj.xanchor);
          yf = dragElement.align(newY + legendObj._height, -legendObj._height, gs.t + gs.h, gs.t, legendObj.yanchor);
        },
        doneFn: function () {
          if (xf !== undefined && yf !== undefined) {
            var obj = {};
            obj[legendId + '.x'] = xf;
            obj[legendId + '.y'] = yf;
            Registry.call('_guiRelayout', gd, obj);
          }
        },
        clickFn: function (numClicks, e) {
          var clickedTrace = layer.selectAll('g.traces').filter(function () {
            var bbox = this.getBoundingClientRect();
            return e.clientX >= bbox.left && e.clientX <= bbox.right && e.clientY >= bbox.top && e.clientY <= bbox.bottom;
          });
          if (clickedTrace.size() > 0) {
            clickOrDoubleClick(gd, legend, clickedTrace, numClicks, e);
          }
        }
      });
    }
  }], gd);
}
function getTraceWidth(d, legendObj, textGap) {
  var legendItem = d[0];
  var legendWidth = legendItem.width;
  var mode = legendObj.entrywidthmode;
  var traceLegendWidth = legendItem.trace.legendwidth || legendObj.entrywidth;
  if (mode === 'fraction') return legendObj._maxWidth * traceLegendWidth;
  return textGap + (traceLegendWidth || legendWidth);
}
function clickOrDoubleClick(gd, legend, legendItem, numClicks, evt) {
  var trace = legendItem.data()[0][0].trace;
  var evtData = {
    event: evt,
    node: legendItem.node(),
    curveNumber: trace.index,
    expandedIndex: trace._expandedIndex,
    data: gd.data,
    layout: gd.layout,
    frames: gd._transitionData._frames,
    config: gd._context,
    fullData: gd._fullData,
    fullLayout: gd._fullLayout
  };
  if (trace._group) {
    evtData.group = trace._group;
  }
  if (Registry.traceIs(trace, 'pie-like')) {
    evtData.label = legendItem.datum()[0].label;
  }
  var clickVal = Events.triggerHandler(gd, 'plotly_legendclick', evtData);
  if (numClicks === 1) {
    if (clickVal === false) return;
    legend._clickTimeout = setTimeout(function () {
      if (!gd._fullLayout) return;
      handleClick(legendItem, gd, numClicks);
    }, gd._context.doubleClickDelay);
  } else if (numClicks === 2) {
    if (legend._clickTimeout) clearTimeout(legend._clickTimeout);
    gd._legendMouseDownTime = 0;
    var dblClickVal = Events.triggerHandler(gd, 'plotly_legenddoubleclick', evtData);
    // Activate default double click behaviour only when both single click and double click values are not false
    if (dblClickVal !== false && clickVal !== false) handleClick(legendItem, gd, numClicks);
  }
}
function drawTexts(g, gd, legendObj) {
  var legendId = getId(legendObj);
  var legendItem = g.data()[0][0];
  var trace = legendItem.trace;
  var isPieLike = Registry.traceIs(trace, 'pie-like');
  var isEditable = !legendObj._inHover && gd._context.edits.legendText && !isPieLike;
  var maxNameLength = legendObj._maxNameLength;
  var name, font;
  if (legendItem.groupTitle) {
    name = legendItem.groupTitle.text;
    font = legendItem.groupTitle.font;
  } else {
    font = legendObj.font;
    if (!legendObj.entries) {
      name = isPieLike ? legendItem.label : trace.name;
      if (trace._meta) {
        name = Lib.templateString(name, trace._meta);
      }
    } else {
      name = legendItem.text;
    }
  }
  var textEl = Lib.ensureSingle(g, 'text', legendId + 'text');
  textEl.attr('text-anchor', 'start').call(Drawing.font, font).text(isEditable ? ensureLength(name, maxNameLength) : name);
  var textGap = legendObj.itemwidth + constants.itemGap * 2;
  svgTextUtils.positionText(textEl, textGap, 0);
  if (isEditable) {
    textEl.call(svgTextUtils.makeEditable, {
      gd: gd,
      text: name
    }).call(textLayout, g, gd, legendObj).on('edit', function (newName) {
      this.text(ensureLength(newName, maxNameLength)).call(textLayout, g, gd, legendObj);
      var fullInput = legendItem.trace._fullInput || {};
      var update = {};
      if (Registry.hasTransform(fullInput, 'groupby')) {
        var groupbyIndices = Registry.getTransformIndices(fullInput, 'groupby');
        var _index = groupbyIndices[groupbyIndices.length - 1];
        var kcont = Lib.keyedContainer(fullInput, 'transforms[' + _index + '].styles', 'target', 'value.name');
        kcont.set(legendItem.trace._group, newName);
        update = kcont.constructUpdate();
      } else {
        update.name = newName;
      }
      if (fullInput._isShape) {
        return Registry.call('_guiRelayout', gd, 'shapes[' + trace.index + '].name', update.name);
      } else {
        return Registry.call('_guiRestyle', gd, update, trace.index);
      }
    });
  } else {
    textLayout(textEl, g, gd, legendObj);
  }
}

/*
 * Make sure we have a reasonably clickable region.
 * If this string is missing or very short, pad it with spaces out to at least
 * 4 characters, up to the max length of other labels, on the assumption that
 * most characters are wider than spaces so a string of spaces will usually be
 * no wider than the real labels.
 */
function ensureLength(str, maxLength) {
  var targetLength = Math.max(4, maxLength);
  if (str && str.trim().length >= targetLength / 2) return str;
  str = str || '';
  for (var i = targetLength - str.length; i > 0; i--) str += ' ';
  return str;
}
function setupTraceToggle(g, gd, legendId) {
  var doubleClickDelay = gd._context.doubleClickDelay;
  var newMouseDownTime;
  var numClicks = 1;
  var traceToggle = Lib.ensureSingle(g, 'rect', legendId + 'toggle', function (s) {
    if (!gd._context.staticPlot) {
      s.style('cursor', 'pointer').attr('pointer-events', 'all');
    }
    s.call(Color.fill, 'rgba(0,0,0,0)');
  });
  if (gd._context.staticPlot) return;
  traceToggle.on('mousedown', function () {
    newMouseDownTime = new Date().getTime();
    if (newMouseDownTime - gd._legendMouseDownTime < doubleClickDelay) {
      // in a click train
      numClicks += 1;
    } else {
      // new click train
      numClicks = 1;
      gd._legendMouseDownTime = newMouseDownTime;
    }
  });
  traceToggle.on('mouseup', function () {
    if (gd._dragged || gd._editing) return;
    var legend = gd._fullLayout[legendId];
    if (new Date().getTime() - gd._legendMouseDownTime > doubleClickDelay) {
      numClicks = Math.max(numClicks - 1, 1);
    }
    clickOrDoubleClick(gd, legend, g, numClicks, d3.event);
  });
}
function textLayout(s, g, gd, legendObj, aTitle) {
  if (legendObj._inHover) s.attr('data-notex', true); // do not process MathJax for unified hover
  svgTextUtils.convertToTspans(s, gd, function () {
    computeTextDimensions(g, gd, legendObj, aTitle);
  });
}
function computeTextDimensions(g, gd, legendObj, aTitle) {
  var legendItem = g.data()[0][0];
  if (!legendObj._inHover && legendItem && !legendItem.trace.showlegend) {
    g.remove();
    return;
  }
  var mathjaxGroup = g.select('g[class*=math-group]');
  var mathjaxNode = mathjaxGroup.node();
  var legendId = getId(legendObj);
  if (!legendObj) {
    legendObj = gd._fullLayout[legendId];
  }
  var bw = legendObj.borderwidth;
  var font;
  if (aTitle === MAIN_TITLE) {
    font = legendObj.title.font;
  } else if (legendItem.groupTitle) {
    font = legendItem.groupTitle.font;
  } else {
    font = legendObj.font;
  }
  var lineHeight = font.size * LINE_SPACING;
  var height, width;
  if (mathjaxNode) {
    var mathjaxBB = Drawing.bBox(mathjaxNode);
    height = mathjaxBB.height;
    width = mathjaxBB.width;
    if (aTitle === MAIN_TITLE) {
      Drawing.setTranslate(mathjaxGroup, bw, bw + height * 0.75);
    } else {
      // legend item
      Drawing.setTranslate(mathjaxGroup, 0, height * 0.25);
    }
  } else {
    var cls = '.' + legendId + (aTitle === MAIN_TITLE ? 'title' : '') + 'text';
    var textEl = g.select(cls);
    var textLines = svgTextUtils.lineCount(textEl);
    var textNode = textEl.node();
    height = lineHeight * textLines;
    width = textNode ? Drawing.bBox(textNode).width : 0;

    // approximation to height offset to center the font
    // to avoid getBoundingClientRect
    if (aTitle === MAIN_TITLE) {
      if (legendObj.title.side === 'left') {
        // add extra space between legend title and itmes
        width += constants.itemGap * 2;
      }
      svgTextUtils.positionText(textEl, bw + constants.titlePad, bw + lineHeight);
    } else {
      // legend item
      var x = constants.itemGap * 2 + legendObj.itemwidth;
      if (legendItem.groupTitle) {
        x = constants.itemGap;
        width -= legendObj.itemwidth;
      }
      svgTextUtils.positionText(textEl, x, -lineHeight * ((textLines - 1) / 2 - 0.3));
    }
  }
  if (aTitle === MAIN_TITLE) {
    legendObj._titleWidth = width;
    legendObj._titleHeight = height;
  } else {
    // legend item
    legendItem.lineHeight = lineHeight;
    legendItem.height = Math.max(height, 16) + 3;
    legendItem.width = width;
  }
}
function getTitleSize(legendObj) {
  var w = 0;
  var h = 0;
  var side = legendObj.title.side;
  if (side) {
    if (side.indexOf('left') !== -1) {
      w = legendObj._titleWidth;
    }
    if (side.indexOf('top') !== -1) {
      h = legendObj._titleHeight;
    }
  }
  return [w, h];
}

/*
 * Computes in fullLayout[legendId]:
 *
 *  - _height: legend height including items past scrollbox height
 *  - _maxHeight: maximum legend height before scrollbox is required
 *  - _effHeight: legend height w/ or w/o scrollbox
 *
 *  - _width: legend width
 *  - _maxWidth (for orientation:h only): maximum width before starting new row
 */
function computeLegendDimensions(gd, groups, traces, legendObj) {
  var fullLayout = gd._fullLayout;
  var legendId = getId(legendObj);
  if (!legendObj) {
    legendObj = fullLayout[legendId];
  }
  var gs = fullLayout._size;
  var isVertical = helpers.isVertical(legendObj);
  var isGrouped = helpers.isGrouped(legendObj);
  var isFraction = legendObj.entrywidthmode === 'fraction';
  var bw = legendObj.borderwidth;
  var bw2 = 2 * bw;
  var itemGap = constants.itemGap;
  var textGap = legendObj.itemwidth + itemGap * 2;
  var endPad = 2 * (bw + itemGap);
  var yanchor = getYanchor(legendObj);
  var isBelowPlotArea = legendObj.y < 0 || legendObj.y === 0 && yanchor === 'top';
  var isAbovePlotArea = legendObj.y > 1 || legendObj.y === 1 && yanchor === 'bottom';
  var traceGroupGap = legendObj.tracegroupgap;
  var legendGroupWidths = {};

  // - if below/above plot area, give it the maximum potential margin-push value
  // - otherwise, extend the height of the plot area
  legendObj._maxHeight = Math.max(isBelowPlotArea || isAbovePlotArea ? fullLayout.height / 2 : gs.h, 30);
  var toggleRectWidth = 0;
  legendObj._width = 0;
  legendObj._height = 0;
  var titleSize = getTitleSize(legendObj);
  if (isVertical) {
    traces.each(function (d) {
      var h = d[0].height;
      Drawing.setTranslate(this, bw + titleSize[0], bw + titleSize[1] + legendObj._height + h / 2 + itemGap);
      legendObj._height += h;
      legendObj._width = Math.max(legendObj._width, d[0].width);
    });
    toggleRectWidth = textGap + legendObj._width;
    legendObj._width += itemGap + textGap + bw2;
    legendObj._height += endPad;
    if (isGrouped) {
      groups.each(function (d, i) {
        Drawing.setTranslate(this, 0, i * legendObj.tracegroupgap);
      });
      legendObj._height += (legendObj._lgroupsLength - 1) * legendObj.tracegroupgap;
    }
  } else {
    var xanchor = getXanchor(legendObj);
    var isLeftOfPlotArea = legendObj.x < 0 || legendObj.x === 0 && xanchor === 'right';
    var isRightOfPlotArea = legendObj.x > 1 || legendObj.x === 1 && xanchor === 'left';
    var isBeyondPlotAreaY = isAbovePlotArea || isBelowPlotArea;
    var hw = fullLayout.width / 2;

    // - if placed within x-margins, extend the width of the plot area
    // - else if below/above plot area and anchored in the margin, extend to opposite margin,
    // - otherwise give it the maximum potential margin-push value
    legendObj._maxWidth = Math.max(isLeftOfPlotArea ? isBeyondPlotAreaY && xanchor === 'left' ? gs.l + gs.w : hw : isRightOfPlotArea ? isBeyondPlotAreaY && xanchor === 'right' ? gs.r + gs.w : hw : gs.w, 2 * textGap);
    var maxItemWidth = 0;
    var combinedItemWidth = 0;
    traces.each(function (d) {
      var w = getTraceWidth(d, legendObj, textGap);
      maxItemWidth = Math.max(maxItemWidth, w);
      combinedItemWidth += w;
    });
    toggleRectWidth = null;
    var maxRowWidth = 0;
    if (isGrouped) {
      var maxGroupHeightInRow = 0;
      var groupOffsetX = 0;
      var groupOffsetY = 0;
      groups.each(function () {
        var maxWidthInGroup = 0;
        var offsetY = 0;
        d3.select(this).selectAll('g.traces').each(function (d) {
          var w = getTraceWidth(d, legendObj, textGap);
          var h = d[0].height;
          Drawing.setTranslate(this, titleSize[0], titleSize[1] + bw + itemGap + h / 2 + offsetY);
          offsetY += h;
          maxWidthInGroup = Math.max(maxWidthInGroup, w);
          legendGroupWidths[d[0].trace.legendgroup] = maxWidthInGroup;
        });
        var next = maxWidthInGroup + itemGap;

        // horizontal_wrapping
        if (
        // not on the first column already
        groupOffsetX > 0 &&
        // goes beyound limit
        next + bw + groupOffsetX > legendObj._maxWidth) {
          maxRowWidth = Math.max(maxRowWidth, groupOffsetX);
          groupOffsetX = 0;
          groupOffsetY += maxGroupHeightInRow + traceGroupGap;
          maxGroupHeightInRow = offsetY;
        } else {
          maxGroupHeightInRow = Math.max(maxGroupHeightInRow, offsetY);
        }
        Drawing.setTranslate(this, groupOffsetX, groupOffsetY);
        groupOffsetX += next;
      });
      legendObj._width = Math.max(maxRowWidth, groupOffsetX) + bw;
      legendObj._height = groupOffsetY + maxGroupHeightInRow + endPad;
    } else {
      var nTraces = traces.size();
      var oneRowLegend = combinedItemWidth + bw2 + (nTraces - 1) * itemGap < legendObj._maxWidth;
      var maxItemHeightInRow = 0;
      var offsetX = 0;
      var offsetY = 0;
      var rowWidth = 0;
      traces.each(function (d) {
        var h = d[0].height;
        var w = getTraceWidth(d, legendObj, textGap, isGrouped);
        var next = oneRowLegend ? w : maxItemWidth;
        if (!isFraction) {
          next += itemGap;
        }
        if (next + bw + offsetX - itemGap >= legendObj._maxWidth) {
          maxRowWidth = Math.max(maxRowWidth, rowWidth);
          offsetX = 0;
          offsetY += maxItemHeightInRow;
          legendObj._height += maxItemHeightInRow;
          maxItemHeightInRow = 0;
        }
        Drawing.setTranslate(this, titleSize[0] + bw + offsetX, titleSize[1] + bw + offsetY + h / 2 + itemGap);
        rowWidth = offsetX + w + itemGap;
        offsetX += next;
        maxItemHeightInRow = Math.max(maxItemHeightInRow, h);
      });
      if (oneRowLegend) {
        legendObj._width = offsetX + bw2;
        legendObj._height = maxItemHeightInRow + endPad;
      } else {
        legendObj._width = Math.max(maxRowWidth, rowWidth) + bw2;
        legendObj._height += maxItemHeightInRow + endPad;
      }
    }
  }
  legendObj._width = Math.ceil(Math.max(legendObj._width + titleSize[0], legendObj._titleWidth + 2 * (bw + constants.titlePad)));
  legendObj._height = Math.ceil(Math.max(legendObj._height + titleSize[1], legendObj._titleHeight + 2 * (bw + constants.itemGap)));
  legendObj._effHeight = Math.min(legendObj._height, legendObj._maxHeight);
  var edits = gd._context.edits;
  var isEditable = edits.legendText || edits.legendPosition;
  traces.each(function (d) {
    var traceToggle = d3.select(this).select('.' + legendId + 'toggle');
    var h = d[0].height;
    var legendgroup = d[0].trace.legendgroup;
    var traceWidth = getTraceWidth(d, legendObj, textGap);
    if (isGrouped && legendgroup !== '') {
      traceWidth = legendGroupWidths[legendgroup];
    }
    var w = isEditable ? textGap : toggleRectWidth || traceWidth;
    if (!isVertical && !isFraction) {
      w += itemGap / 2;
    }
    Drawing.setRect(traceToggle, 0, -h / 2, w, h);
  });
}
function expandMargin(gd, legendId, lx, ly) {
  var fullLayout = gd._fullLayout;
  var legendObj = fullLayout[legendId];
  var xanchor = getXanchor(legendObj);
  var yanchor = getYanchor(legendObj);
  var isPaperX = legendObj.xref === 'paper';
  var isPaperY = legendObj.yref === 'paper';
  gd._fullLayout._reservedMargin[legendId] = {};
  var sideY = legendObj.y < 0.5 ? 'b' : 't';
  var sideX = legendObj.x < 0.5 ? 'l' : 'r';
  var possibleReservedMargins = {
    r: fullLayout.width - lx,
    l: lx + legendObj._width,
    b: fullLayout.height - ly,
    t: ly + legendObj._effHeight
  };
  if (isPaperX && isPaperY) {
    return Plots.autoMargin(gd, legendId, {
      x: legendObj.x,
      y: legendObj.y,
      l: legendObj._width * FROM_TL[xanchor],
      r: legendObj._width * FROM_BR[xanchor],
      b: legendObj._effHeight * FROM_BR[yanchor],
      t: legendObj._effHeight * FROM_TL[yanchor]
    });
  } else if (isPaperX) {
    gd._fullLayout._reservedMargin[legendId][sideY] = possibleReservedMargins[sideY];
  } else if (isPaperY) {
    gd._fullLayout._reservedMargin[legendId][sideX] = possibleReservedMargins[sideX];
  } else {
    if (legendObj.orientation === 'v') {
      gd._fullLayout._reservedMargin[legendId][sideX] = possibleReservedMargins[sideX];
    } else {
      gd._fullLayout._reservedMargin[legendId][sideY] = possibleReservedMargins[sideY];
    }
  }
}
function getXanchor(legendObj) {
  return Lib.isRightAnchor(legendObj) ? 'right' : Lib.isCenterAnchor(legendObj) ? 'center' : 'left';
}
function getYanchor(legendObj) {
  return Lib.isBottomAnchor(legendObj) ? 'bottom' : Lib.isMiddleAnchor(legendObj) ? 'middle' : 'top';
}
function getId(legendObj) {
  return legendObj._id || 'legend';
}

/***/ }),

/***/ 2424:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);
var helpers = __webpack_require__(130);
module.exports = function getLegendData(calcdata, opts, hasMultipleLegends) {
  var inHover = opts._inHover;
  var grouped = helpers.isGrouped(opts);
  var reversed = helpers.isReversed(opts);
  var lgroupToTraces = {};
  var lgroups = [];
  var hasOneNonBlankGroup = false;
  var slicesShown = {};
  var lgroupi = 0;
  var maxNameLength = 0;
  var i, j;
  function addOneItem(legendId, legendGroup, legendItem) {
    if (opts.visible === false) return;
    if (hasMultipleLegends && legendId !== opts._id) return;

    // each '' legend group is treated as a separate group
    if (legendGroup === '' || !helpers.isGrouped(opts)) {
      // TODO: check this against fullData legendgroups?
      var uniqueGroup = '~~i' + lgroupi;
      lgroups.push(uniqueGroup);
      lgroupToTraces[uniqueGroup] = [legendItem];
      lgroupi++;
    } else if (lgroups.indexOf(legendGroup) === -1) {
      lgroups.push(legendGroup);
      hasOneNonBlankGroup = true;
      lgroupToTraces[legendGroup] = [legendItem];
    } else {
      lgroupToTraces[legendGroup].push(legendItem);
    }
  }

  // build an { legendgroup: [cd0, cd0], ... } object
  for (i = 0; i < calcdata.length; i++) {
    var cd = calcdata[i];
    var cd0 = cd[0];
    var trace = cd0.trace;
    var lid = trace.legend;
    var lgroup = trace.legendgroup;
    if (!inHover && (!trace.visible || !trace.showlegend)) continue;
    if (Registry.traceIs(trace, 'pie-like')) {
      if (!slicesShown[lgroup]) slicesShown[lgroup] = {};
      for (j = 0; j < cd.length; j++) {
        var labelj = cd[j].label;
        if (!slicesShown[lgroup][labelj]) {
          addOneItem(lid, lgroup, {
            label: labelj,
            color: cd[j].color,
            i: cd[j].i,
            trace: trace,
            pts: cd[j].pts
          });
          slicesShown[lgroup][labelj] = true;
          maxNameLength = Math.max(maxNameLength, (labelj || '').length);
        }
      }
    } else {
      addOneItem(lid, lgroup, cd0);
      maxNameLength = Math.max(maxNameLength, (trace.name || '').length);
    }
  }

  // won't draw a legend in this case
  if (!lgroups.length) return [];

  // collapse all groups into one if all groups are blank
  var shouldCollapse = !hasOneNonBlankGroup || !grouped;
  var legendData = [];
  for (i = 0; i < lgroups.length; i++) {
    var t = lgroupToTraces[lgroups[i]];
    if (shouldCollapse) {
      legendData.push(t[0]);
    } else {
      legendData.push(t);
    }
  }
  if (shouldCollapse) legendData = [legendData];
  for (i = 0; i < legendData.length; i++) {
    // find minimum rank within group
    var groupMinRank = Infinity;
    for (j = 0; j < legendData[i].length; j++) {
      var rank = legendData[i][j].trace.legendrank;
      if (groupMinRank > rank) groupMinRank = rank;
    }

    // record on first group element
    legendData[i][0]._groupMinRank = groupMinRank;
    legendData[i][0]._preGroupSort = i;
  }
  var orderFn1 = function (a, b) {
    return a[0]._groupMinRank - b[0]._groupMinRank || a[0]._preGroupSort - b[0]._preGroupSort // fallback for old Chrome < 70 https://bugs.chromium.org/p/v8/issues/detail?id=90
    ;
  };

  var orderFn2 = function (a, b) {
    return a.trace.legendrank - b.trace.legendrank || a._preSort - b._preSort // fallback for old Chrome < 70 https://bugs.chromium.org/p/v8/issues/detail?id=90
    ;
  };

  // sort considering minimum group legendrank
  legendData.forEach(function (a, k) {
    a[0]._preGroupSort = k;
  });
  legendData.sort(orderFn1);
  for (i = 0; i < legendData.length; i++) {
    // sort considering trace.legendrank and legend.traceorder
    legendData[i].forEach(function (a, k) {
      a._preSort = k;
    });
    legendData[i].sort(orderFn2);
    var firstItemTrace = legendData[i][0].trace;
    var groupTitle = null;
    // get group title text
    for (j = 0; j < legendData[i].length; j++) {
      var gt = legendData[i][j].trace.legendgrouptitle;
      if (gt && gt.text) {
        groupTitle = gt;
        if (inHover) gt.font = opts._groupTitleFont;
        break;
      }
    }

    // reverse order
    if (reversed) legendData[i].reverse();
    if (groupTitle) {
      var hasPieLike = false;
      for (j = 0; j < legendData[i].length; j++) {
        if (Registry.traceIs(legendData[i][j].trace, 'pie-like')) {
          hasPieLike = true;
          break;
        }
      }

      // set group title text
      legendData[i].unshift({
        i: -1,
        groupTitle: groupTitle,
        noClick: hasPieLike,
        trace: {
          showlegend: firstItemTrace.showlegend,
          legendgroup: firstItemTrace.legendgroup,
          visible: opts.groupclick === 'toggleitem' ? true : firstItemTrace.visible
        }
      });
    }

    // rearrange lgroupToTraces into a d3-friendly array of arrays
    for (j = 0; j < legendData[i].length; j++) {
      legendData[i][j] = [legendData[i][j]];
    }
  }

  // number of legend groups - needed in legend/draw.js
  opts._lgroupsLength = legendData.length;
  // maximum name/label length - needed in legend/draw.js
  opts._maxNameLength = maxNameLength;
  return legendData;
};

/***/ }),

/***/ 5167:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var pushUnique = Lib.pushUnique;
var SHOWISOLATETIP = true;
module.exports = function handleClick(g, gd, numClicks) {
  var fullLayout = gd._fullLayout;
  if (gd._dragged || gd._editing) return;
  var itemClick = fullLayout.legend.itemclick;
  var itemDoubleClick = fullLayout.legend.itemdoubleclick;
  var groupClick = fullLayout.legend.groupclick;
  if (numClicks === 1 && itemClick === 'toggle' && itemDoubleClick === 'toggleothers' && SHOWISOLATETIP && gd.data && gd._context.showTips) {
    Lib.notifier(Lib._(gd, 'Double-click on legend to isolate one trace'), 'long');
    SHOWISOLATETIP = false;
  } else {
    SHOWISOLATETIP = false;
  }
  var mode;
  if (numClicks === 1) mode = itemClick;else if (numClicks === 2) mode = itemDoubleClick;
  if (!mode) return;
  var toggleGroup = groupClick === 'togglegroup';
  var hiddenSlices = fullLayout.hiddenlabels ? fullLayout.hiddenlabels.slice() : [];
  var legendItem = g.data()[0][0];
  if (legendItem.groupTitle && legendItem.noClick) return;
  var fullData = gd._fullData;
  var shapesWithLegend = (fullLayout.shapes || []).filter(function (d) {
    return d.showlegend;
  });
  var allLegendItems = fullData.concat(shapesWithLegend);
  var fullTrace = legendItem.trace;
  if (fullTrace._isShape) {
    fullTrace = fullTrace._fullInput;
  }
  var legendgroup = fullTrace.legendgroup;
  var i, j, kcont, key, keys, val;
  var dataUpdate = {};
  var dataIndices = [];
  var carrs = [];
  var carrIdx = [];
  function insertDataUpdate(traceIndex, value) {
    var attrIndex = dataIndices.indexOf(traceIndex);
    var valueArray = dataUpdate.visible;
    if (!valueArray) {
      valueArray = dataUpdate.visible = [];
    }
    if (dataIndices.indexOf(traceIndex) === -1) {
      dataIndices.push(traceIndex);
      attrIndex = dataIndices.length - 1;
    }
    valueArray[attrIndex] = value;
    return attrIndex;
  }
  var updatedShapes = (fullLayout.shapes || []).map(function (d) {
    return d._input;
  });
  var shapesUpdated = false;
  function insertShapesUpdate(shapeIndex, value) {
    updatedShapes[shapeIndex].visible = value;
    shapesUpdated = true;
  }
  function setVisibility(fullTrace, visibility) {
    if (legendItem.groupTitle && !toggleGroup) return;
    var fullInput = fullTrace._fullInput || fullTrace;
    var isShape = fullInput._isShape;
    var index = fullInput.index;
    if (index === undefined) index = fullInput._index;
    if (Registry.hasTransform(fullInput, 'groupby')) {
      var kcont = carrs[index];
      if (!kcont) {
        var groupbyIndices = Registry.getTransformIndices(fullInput, 'groupby');
        var lastGroupbyIndex = groupbyIndices[groupbyIndices.length - 1];
        kcont = Lib.keyedContainer(fullInput, 'transforms[' + lastGroupbyIndex + '].styles', 'target', 'value.visible');
        carrs[index] = kcont;
      }
      var curState = kcont.get(fullTrace._group);

      // If not specified, assume visible. This happens if there are other style
      // properties set for a group but not the visibility. There are many similar
      // ways to do this (e.g. why not just `curState = fullTrace.visible`??? The
      // answer is: because it breaks other things like groupby trace names in
      // subtle ways.)
      if (curState === undefined) {
        curState = true;
      }
      if (curState !== false) {
        // true -> legendonly. All others toggle to true:
        kcont.set(fullTrace._group, visibility);
      }
      carrIdx[index] = insertDataUpdate(index, fullInput.visible === false ? false : true);
    } else {
      // false -> false (not possible since will not be visible in legend)
      // true -> legendonly
      // legendonly -> true
      var nextVisibility = fullInput.visible === false ? false : visibility;
      if (isShape) {
        insertShapesUpdate(index, nextVisibility);
      } else {
        insertDataUpdate(index, nextVisibility);
      }
    }
  }
  var thisLegend = fullTrace.legend;
  var fullInput = fullTrace._fullInput;
  var isShape = fullInput && fullInput._isShape;
  if (!isShape && Registry.traceIs(fullTrace, 'pie-like')) {
    var thisLabel = legendItem.label;
    var thisLabelIndex = hiddenSlices.indexOf(thisLabel);
    if (mode === 'toggle') {
      if (thisLabelIndex === -1) hiddenSlices.push(thisLabel);else hiddenSlices.splice(thisLabelIndex, 1);
    } else if (mode === 'toggleothers') {
      var changed = thisLabelIndex !== -1;
      var unhideList = [];
      for (i = 0; i < gd.calcdata.length; i++) {
        var cdi = gd.calcdata[i];
        for (j = 0; j < cdi.length; j++) {
          var d = cdi[j];
          var dLabel = d.label;

          // ensure we toggle slices that are in this legend)
          if (thisLegend === cdi[0].trace.legend) {
            if (thisLabel !== dLabel) {
              if (hiddenSlices.indexOf(dLabel) === -1) changed = true;
              pushUnique(hiddenSlices, dLabel);
              unhideList.push(dLabel);
            }
          }
        }
      }
      if (!changed) {
        for (var q = 0; q < unhideList.length; q++) {
          var pos = hiddenSlices.indexOf(unhideList[q]);
          if (pos !== -1) {
            hiddenSlices.splice(pos, 1);
          }
        }
      }
    }
    Registry.call('_guiRelayout', gd, 'hiddenlabels', hiddenSlices);
  } else {
    var hasLegendgroup = legendgroup && legendgroup.length;
    var traceIndicesInGroup = [];
    var tracei;
    if (hasLegendgroup) {
      for (i = 0; i < allLegendItems.length; i++) {
        tracei = allLegendItems[i];
        if (!tracei.visible) continue;
        if (tracei.legendgroup === legendgroup) {
          traceIndicesInGroup.push(i);
        }
      }
    }
    if (mode === 'toggle') {
      var nextVisibility;
      switch (fullTrace.visible) {
        case true:
          nextVisibility = 'legendonly';
          break;
        case false:
          nextVisibility = false;
          break;
        case 'legendonly':
          nextVisibility = true;
          break;
      }
      if (hasLegendgroup) {
        if (toggleGroup) {
          for (i = 0; i < allLegendItems.length; i++) {
            var item = allLegendItems[i];
            if (item.visible !== false && item.legendgroup === legendgroup) {
              setVisibility(item, nextVisibility);
            }
          }
        } else {
          setVisibility(fullTrace, nextVisibility);
        }
      } else {
        setVisibility(fullTrace, nextVisibility);
      }
    } else if (mode === 'toggleothers') {
      // Compute the clicked index. expandedIndex does what we want for expanded traces
      // but also culls hidden traces. That means we have some work to do.
      var isClicked, isInGroup, notInLegend, otherState, _item;
      var isIsolated = true;
      for (i = 0; i < allLegendItems.length; i++) {
        _item = allLegendItems[i];
        isClicked = _item === fullTrace;
        notInLegend = _item.showlegend !== true;
        if (isClicked || notInLegend) continue;
        isInGroup = hasLegendgroup && _item.legendgroup === legendgroup;
        if (!isInGroup && _item.legend === thisLegend && _item.visible === true && !Registry.traceIs(_item, 'notLegendIsolatable')) {
          isIsolated = false;
          break;
        }
      }
      for (i = 0; i < allLegendItems.length; i++) {
        _item = allLegendItems[i];

        // False is sticky; we don't change it. Also ensure we don't change states of itmes in other legend
        if (_item.visible === false || _item.legend !== thisLegend) continue;
        if (Registry.traceIs(_item, 'notLegendIsolatable')) {
          continue;
        }
        switch (fullTrace.visible) {
          case 'legendonly':
            setVisibility(_item, true);
            break;
          case true:
            otherState = isIsolated ? true : 'legendonly';
            isClicked = _item === fullTrace;
            // N.B. consider traces that have a set legendgroup as toggleable
            notInLegend = _item.showlegend !== true && !_item.legendgroup;
            isInGroup = isClicked || hasLegendgroup && _item.legendgroup === legendgroup;
            setVisibility(_item, isInGroup || notInLegend ? true : otherState);
            break;
        }
      }
    }
    for (i = 0; i < carrs.length; i++) {
      kcont = carrs[i];
      if (!kcont) continue;
      var update = kcont.constructUpdate();
      var updateKeys = Object.keys(update);
      for (j = 0; j < updateKeys.length; j++) {
        key = updateKeys[j];
        val = dataUpdate[key] = dataUpdate[key] || [];
        val[carrIdx[i]] = update[key];
      }
    }

    // The length of the value arrays should be equal and any unspecified
    // values should be explicitly undefined for them to get properly culled
    // as updates and not accidentally reset to the default value. This fills
    // out sparse arrays with the required number of undefined values:
    keys = Object.keys(dataUpdate);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      for (j = 0; j < dataIndices.length; j++) {
        // Use hasOwnProperty to protect against falsy values:
        if (!dataUpdate[key].hasOwnProperty(j)) {
          dataUpdate[key][j] = undefined;
        }
      }
    }
    if (shapesUpdated) {
      Registry.call('_guiUpdate', gd, dataUpdate, {
        shapes: updatedShapes
      }, dataIndices);
    } else {
      Registry.call('_guiRestyle', gd, dataUpdate, dataIndices);
    }
  }
};

/***/ }),

/***/ 130:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.isGrouped = function isGrouped(legendLayout) {
  return (legendLayout.traceorder || '').indexOf('grouped') !== -1;
};
exports.isVertical = function isVertical(legendLayout) {
  return legendLayout.orientation !== 'h';
};
exports.isReversed = function isReversed(legendLayout) {
  return (legendLayout.traceorder || '').indexOf('reversed') !== -1;
};

/***/ }),

/***/ 2199:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  moduleType: 'component',
  name: 'legend',
  layoutAttributes: __webpack_require__(3030),
  supplyLayoutDefaults: __webpack_require__(9017),
  draw: __webpack_require__(3969),
  style: __webpack_require__(3630)
};

/***/ }),

/***/ 3630:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var strTranslate = Lib.strTranslate;
var Drawing = __webpack_require__(1424);
var Color = __webpack_require__(7901);
var extractOpts = (__webpack_require__(2869).extractOpts);
var subTypes = __webpack_require__(4098);
var stylePie = __webpack_require__(3463);
var pieCastOption = (__webpack_require__(3581).castOption);
var constants = __webpack_require__(4928);
var CST_MARKER_SIZE = 12;
var CST_LINE_WIDTH = 5;
var CST_MARKER_LINE_WIDTH = 2;
var MAX_LINE_WIDTH = 10;
var MAX_MARKER_LINE_WIDTH = 5;
module.exports = function style(s, gd, legend) {
  var fullLayout = gd._fullLayout;
  if (!legend) legend = fullLayout.legend;
  var constantItemSizing = legend.itemsizing === 'constant';
  var itemWidth = legend.itemwidth;
  var centerPos = (itemWidth + constants.itemGap * 2) / 2;
  var centerTransform = strTranslate(centerPos, 0);
  var boundLineWidth = function (mlw, cont, max, cst) {
    var v;
    if (mlw + 1) {
      v = mlw;
    } else if (cont && cont.width > 0) {
      v = cont.width;
    } else {
      return 0;
    }
    return constantItemSizing ? cst : Math.min(v, max);
  };
  s.each(function (d) {
    var traceGroup = d3.select(this);
    var layers = Lib.ensureSingle(traceGroup, 'g', 'layers');
    layers.style('opacity', d[0].trace.opacity);
    var valign = legend.valign;
    var lineHeight = d[0].lineHeight;
    var height = d[0].height;
    if (valign === 'middle' || !lineHeight || !height) {
      layers.attr('transform', null);
    } else {
      var factor = {
        top: 1,
        bottom: -1
      }[valign];
      var markerOffsetY = factor * (0.5 * (lineHeight - height + 3));
      layers.attr('transform', strTranslate(0, markerOffsetY));
    }
    var fill = layers.selectAll('g.legendfill').data([d]);
    fill.enter().append('g').classed('legendfill', true);
    var line = layers.selectAll('g.legendlines').data([d]);
    line.enter().append('g').classed('legendlines', true);
    var symbol = layers.selectAll('g.legendsymbols').data([d]);
    symbol.enter().append('g').classed('legendsymbols', true);
    symbol.selectAll('g.legendpoints').data([d]).enter().append('g').classed('legendpoints', true);
  }).each(styleSpatial).each(styleWaterfalls).each(styleFunnels).each(styleBars).each(styleBoxes).each(styleFunnelareas).each(stylePies).each(styleLines).each(stylePoints).each(styleCandles).each(styleOHLC);
  function styleLines(d) {
    var styleGuide = getStyleGuide(d);
    var showFill = styleGuide.showFill;
    var showLine = styleGuide.showLine;
    var showGradientLine = styleGuide.showGradientLine;
    var showGradientFill = styleGuide.showGradientFill;
    var anyFill = styleGuide.anyFill;
    var anyLine = styleGuide.anyLine;
    var d0 = d[0];
    var trace = d0.trace;
    var dMod, tMod;
    var cOpts = extractOpts(trace);
    var colorscale = cOpts.colorscale;
    var reversescale = cOpts.reversescale;
    var fillStyle = function (s) {
      if (s.size()) {
        if (showFill) {
          Drawing.fillGroupStyle(s, gd);
        } else {
          var gradientID = 'legendfill-' + trace.uid;
          Drawing.gradient(s, gd, gradientID, getGradientDirection(reversescale), colorscale, 'fill');
        }
      }
    };
    var lineGradient = function (s) {
      if (s.size()) {
        var gradientID = 'legendline-' + trace.uid;
        Drawing.lineGroupStyle(s);
        Drawing.gradient(s, gd, gradientID, getGradientDirection(reversescale), colorscale, 'stroke');
      }
    };

    // with fill and no markers or text, move the line and fill up a bit
    // so it's more centered

    var pathStart = subTypes.hasMarkers(trace) || !anyFill ? 'M5,0' :
    // with a line leave it slightly below center, to leave room for the
    // line thickness and because the line is usually more prominent
    anyLine ? 'M5,-2' : 'M5,-3';
    var this3 = d3.select(this);
    var fill = this3.select('.legendfill').selectAll('path').data(showFill || showGradientFill ? [d] : []);
    fill.enter().append('path').classed('js-fill', true);
    fill.exit().remove();
    fill.attr('d', pathStart + 'h' + itemWidth + 'v6h-' + itemWidth + 'z').call(fillStyle);
    if (showLine || showGradientLine) {
      var lw = boundLineWidth(undefined, trace.line, MAX_LINE_WIDTH, CST_LINE_WIDTH);
      tMod = Lib.minExtend(trace, {
        line: {
          width: lw
        }
      });
      dMod = [Lib.minExtend(d0, {
        trace: tMod
      })];
    }
    var line = this3.select('.legendlines').selectAll('path').data(showLine || showGradientLine ? [dMod] : []);
    line.enter().append('path').classed('js-line', true);
    line.exit().remove();

    // this is ugly... but you can't apply a gradient to a perfectly
    // horizontal or vertical line. Presumably because then
    // the system doesn't know how to scale vertical variation, even
    // though there *is* no vertical variation in this case.
    // so add an invisibly small angle to the line
    // This issue (and workaround) exist across (Mac) Chrome, FF, and Safari
    line.attr('d', pathStart + (showGradientLine ? 'l' + itemWidth + ',0.0001' : 'h' + itemWidth)).call(showLine ? Drawing.lineGroupStyle : lineGradient);
  }
  function stylePoints(d) {
    var styleGuide = getStyleGuide(d);
    var anyFill = styleGuide.anyFill;
    var anyLine = styleGuide.anyLine;
    var showLine = styleGuide.showLine;
    var showMarker = styleGuide.showMarker;
    var d0 = d[0];
    var trace = d0.trace;
    var showText = !showMarker && !anyLine && !anyFill && subTypes.hasText(trace);
    var dMod, tMod;

    // 'scatter3d' don't use gd.calcdata,
    // use d0.trace to infer arrayOk attributes

    function boundVal(attrIn, arrayToValFn, bounds, cst) {
      var valIn = Lib.nestedProperty(trace, attrIn).get();
      var valToBound = Lib.isArrayOrTypedArray(valIn) && arrayToValFn ? arrayToValFn(valIn) : valIn;
      if (constantItemSizing && valToBound && cst !== undefined) {
        valToBound = cst;
      }
      if (bounds) {
        if (valToBound < bounds[0]) return bounds[0];else if (valToBound > bounds[1]) return bounds[1];
      }
      return valToBound;
    }
    function pickFirst(array) {
      if (d0._distinct && d0.index && array[d0.index]) return array[d0.index];
      return array[0];
    }

    // constrain text, markers, etc so they'll fit on the legend
    if (showMarker || showText || showLine) {
      var dEdit = {};
      var tEdit = {};
      if (showMarker) {
        dEdit.mc = boundVal('marker.color', pickFirst);
        dEdit.mx = boundVal('marker.symbol', pickFirst);
        dEdit.mo = boundVal('marker.opacity', Lib.mean, [0.2, 1]);
        dEdit.mlc = boundVal('marker.line.color', pickFirst);
        dEdit.mlw = boundVal('marker.line.width', Lib.mean, [0, 5], CST_MARKER_LINE_WIDTH);
        tEdit.marker = {
          sizeref: 1,
          sizemin: 1,
          sizemode: 'diameter'
        };
        var ms = boundVal('marker.size', Lib.mean, [2, 16], CST_MARKER_SIZE);
        dEdit.ms = ms;
        tEdit.marker.size = ms;
      }
      if (showLine) {
        tEdit.line = {
          width: boundVal('line.width', pickFirst, [0, 10], CST_LINE_WIDTH)
        };
      }
      if (showText) {
        dEdit.tx = 'Aa';
        dEdit.tp = boundVal('textposition', pickFirst);
        dEdit.ts = 10;
        dEdit.tc = boundVal('textfont.color', pickFirst);
        dEdit.tf = boundVal('textfont.family', pickFirst);
      }
      dMod = [Lib.minExtend(d0, dEdit)];
      tMod = Lib.minExtend(trace, tEdit);

      // always show legend items in base state
      tMod.selectedpoints = null;

      // never show texttemplate
      tMod.texttemplate = null;
    }
    var ptgroup = d3.select(this).select('g.legendpoints');
    var pts = ptgroup.selectAll('path.scatterpts').data(showMarker ? dMod : []);
    // make sure marker is on the bottom, in case it enters after text
    pts.enter().insert('path', ':first-child').classed('scatterpts', true).attr('transform', centerTransform);
    pts.exit().remove();
    pts.call(Drawing.pointStyle, tMod, gd);

    // 'mrc' is set in pointStyle and used in textPointStyle:
    // constrain it here
    if (showMarker) dMod[0].mrc = 3;
    var txt = ptgroup.selectAll('g.pointtext').data(showText ? dMod : []);
    txt.enter().append('g').classed('pointtext', true).append('text').attr('transform', centerTransform);
    txt.exit().remove();
    txt.selectAll('text').call(Drawing.textPointStyle, tMod, gd);
  }
  function styleWaterfalls(d) {
    var trace = d[0].trace;
    var isWaterfall = trace.type === 'waterfall';
    if (d[0]._distinct && isWaterfall) {
      var cont = d[0].trace[d[0].dir].marker;
      d[0].mc = cont.color;
      d[0].mlw = cont.line.width;
      d[0].mlc = cont.line.color;
      return styleBarLike(d, this, 'waterfall');
    }
    var ptsData = [];
    if (trace.visible && isWaterfall) {
      ptsData = d[0].hasTotals ? [['increasing', 'M-6,-6V6H0Z'], ['totals', 'M6,6H0L-6,-6H-0Z'], ['decreasing', 'M6,6V-6H0Z']] : [['increasing', 'M-6,-6V6H6Z'], ['decreasing', 'M6,6V-6H-6Z']];
    }
    var pts = d3.select(this).select('g.legendpoints').selectAll('path.legendwaterfall').data(ptsData);
    pts.enter().append('path').classed('legendwaterfall', true).attr('transform', centerTransform).style('stroke-miterlimit', 1);
    pts.exit().remove();
    pts.each(function (dd) {
      var pt = d3.select(this);
      var cont = trace[dd[0]].marker;
      var lw = boundLineWidth(undefined, cont.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
      pt.attr('d', dd[1]).style('stroke-width', lw + 'px').call(Color.fill, cont.color);
      if (lw) {
        pt.call(Color.stroke, cont.line.color);
      }
    });
  }
  function styleBars(d) {
    styleBarLike(d, this);
  }
  function styleFunnels(d) {
    styleBarLike(d, this, 'funnel');
  }
  function styleBarLike(d, lThis, desiredType) {
    var trace = d[0].trace;
    var marker = trace.marker || {};
    var markerLine = marker.line || {};
    var isVisible = !desiredType ? Registry.traceIs(trace, 'bar') : trace.visible && trace.type === desiredType;
    var barpath = d3.select(lThis).select('g.legendpoints').selectAll('path.legend' + desiredType).data(isVisible ? [d] : []);
    barpath.enter().append('path').classed('legend' + desiredType, true).attr('d', 'M6,6H-6V-6H6Z').attr('transform', centerTransform);
    barpath.exit().remove();
    barpath.each(function (d) {
      var p = d3.select(this);
      var d0 = d[0];
      var w = boundLineWidth(d0.mlw, marker.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
      p.style('stroke-width', w + 'px');
      var mcc = d0.mcc;
      if (!legend._inHover && 'mc' in d0) {
        // not in unified hover but
        // for legend use the color in the middle of scale
        var cOpts = extractOpts(marker);
        var mid = cOpts.mid;
        if (mid === undefined) mid = (cOpts.max + cOpts.min) / 2;
        mcc = Drawing.tryColorscale(marker, '')(mid);
      }
      var fillColor = mcc || d0.mc || marker.color;
      var markerPattern = marker.pattern;
      var patternShape = markerPattern && Drawing.getPatternAttr(markerPattern.shape, 0, '');
      if (patternShape) {
        var patternBGColor = Drawing.getPatternAttr(markerPattern.bgcolor, 0, null);
        var patternFGColor = Drawing.getPatternAttr(markerPattern.fgcolor, 0, null);
        var patternFGOpacity = markerPattern.fgopacity;
        var patternSize = dimAttr(markerPattern.size, 8, 10);
        var patternSolidity = dimAttr(markerPattern.solidity, 0.5, 1);
        var patternID = 'legend-' + trace.uid;
        p.call(Drawing.pattern, 'legend', gd, patternID, patternShape, patternSize, patternSolidity, mcc, markerPattern.fillmode, patternBGColor, patternFGColor, patternFGOpacity);
      } else {
        p.call(Color.fill, fillColor);
      }
      if (w) Color.stroke(p, d0.mlc || markerLine.color);
    });
  }
  function styleBoxes(d) {
    var trace = d[0].trace;
    var pts = d3.select(this).select('g.legendpoints').selectAll('path.legendbox').data(trace.visible && Registry.traceIs(trace, 'box-violin') ? [d] : []);
    pts.enter().append('path').classed('legendbox', true)
    // if we want the median bar, prepend M6,0H-6
    .attr('d', 'M6,6H-6V-6H6Z').attr('transform', centerTransform);
    pts.exit().remove();
    pts.each(function () {
      var p = d3.select(this);
      if ((trace.boxpoints === 'all' || trace.points === 'all') && Color.opacity(trace.fillcolor) === 0 && Color.opacity((trace.line || {}).color) === 0) {
        var tMod = Lib.minExtend(trace, {
          marker: {
            size: constantItemSizing ? CST_MARKER_SIZE : Lib.constrain(trace.marker.size, 2, 16),
            sizeref: 1,
            sizemin: 1,
            sizemode: 'diameter'
          }
        });
        pts.call(Drawing.pointStyle, tMod, gd);
      } else {
        var w = boundLineWidth(undefined, trace.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
        p.style('stroke-width', w + 'px').call(Color.fill, trace.fillcolor);
        if (w) Color.stroke(p, trace.line.color);
      }
    });
  }
  function styleCandles(d) {
    var trace = d[0].trace;
    var pts = d3.select(this).select('g.legendpoints').selectAll('path.legendcandle').data(trace.visible && trace.type === 'candlestick' ? [d, d] : []);
    pts.enter().append('path').classed('legendcandle', true).attr('d', function (_, i) {
      if (i) return 'M-15,0H-8M-8,6V-6H8Z'; // increasing
      return 'M15,0H8M8,-6V6H-8Z'; // decreasing
    }).attr('transform', centerTransform).style('stroke-miterlimit', 1);
    pts.exit().remove();
    pts.each(function (_, i) {
      var p = d3.select(this);
      var cont = trace[i ? 'increasing' : 'decreasing'];
      var w = boundLineWidth(undefined, cont.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
      p.style('stroke-width', w + 'px').call(Color.fill, cont.fillcolor);
      if (w) Color.stroke(p, cont.line.color);
    });
  }
  function styleOHLC(d) {
    var trace = d[0].trace;
    var pts = d3.select(this).select('g.legendpoints').selectAll('path.legendohlc').data(trace.visible && trace.type === 'ohlc' ? [d, d] : []);
    pts.enter().append('path').classed('legendohlc', true).attr('d', function (_, i) {
      if (i) return 'M-15,0H0M-8,-6V0'; // increasing
      return 'M15,0H0M8,6V0'; // decreasing
    }).attr('transform', centerTransform).style('stroke-miterlimit', 1);
    pts.exit().remove();
    pts.each(function (_, i) {
      var p = d3.select(this);
      var cont = trace[i ? 'increasing' : 'decreasing'];
      var w = boundLineWidth(undefined, cont.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
      p.style('fill', 'none').call(Drawing.dashLine, cont.line.dash, w);
      if (w) Color.stroke(p, cont.line.color);
    });
  }
  function stylePies(d) {
    stylePieLike(d, this, 'pie');
  }
  function styleFunnelareas(d) {
    stylePieLike(d, this, 'funnelarea');
  }
  function stylePieLike(d, lThis, desiredType) {
    var d0 = d[0];
    var trace = d0.trace;
    var isVisible = !desiredType ? Registry.traceIs(trace, desiredType) : trace.visible && trace.type === desiredType;
    var pts = d3.select(lThis).select('g.legendpoints').selectAll('path.legend' + desiredType).data(isVisible ? [d] : []);
    pts.enter().append('path').classed('legend' + desiredType, true).attr('d', 'M6,6H-6V-6H6Z').attr('transform', centerTransform);
    pts.exit().remove();
    if (pts.size()) {
      var cont = trace.marker || {};
      var lw = boundLineWidth(pieCastOption(cont.line.width, d0.pts), cont.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
      var opt = 'pieLike';
      var tMod = Lib.minExtend(trace, {
        marker: {
          line: {
            width: lw
          }
        }
      }, opt);
      var d0Mod = Lib.minExtend(d0, {
        trace: tMod
      }, opt);
      stylePie(pts, d0Mod, tMod, gd);
    }
  }
  function styleSpatial(d) {
    // i.e. maninly traces having z and colorscale
    var trace = d[0].trace;
    var useGradient;
    var ptsData = [];
    if (trace.visible) {
      switch (trace.type) {
        case 'histogram2d':
        case 'heatmap':
          ptsData = [['M-15,-2V4H15V-2Z'] // similar to contour
          ];

          useGradient = true;
          break;
        case 'choropleth':
        case 'choroplethmapbox':
          ptsData = [['M-6,-6V6H6V-6Z']];
          useGradient = true;
          break;
        case 'densitymapbox':
          ptsData = [['M-6,0 a6,6 0 1,0 12,0 a 6,6 0 1,0 -12,0']];
          useGradient = 'radial';
          break;
        case 'cone':
          ptsData = [['M-6,2 A2,2 0 0,0 -6,6 V6L6,4Z'], ['M-6,-6 A2,2 0 0,0 -6,-2 L6,-4Z'], ['M-6,-2 A2,2 0 0,0 -6,2 L6,0Z']];
          useGradient = false;
          break;
        case 'streamtube':
          ptsData = [['M-6,2 A2,2 0 0,0 -6,6 H6 A2,2 0 0,1 6,2 Z'], ['M-6,-6 A2,2 0 0,0 -6,-2 H6 A2,2 0 0,1 6,-6 Z'], ['M-6,-2 A2,2 0 0,0 -6,2 H6 A2,2 0 0,1 6,-2 Z']];
          useGradient = false;
          break;
        case 'surface':
          ptsData = [['M-6,-6 A2,3 0 0,0 -6,0 H6 A2,3 0 0,1 6,-6 Z'], ['M-6,1 A2,3 0 0,1 -6,6 H6 A2,3 0 0,0 6,0 Z']];
          useGradient = true;
          break;
        case 'mesh3d':
          ptsData = [['M-6,6H0L-6,-6Z'], ['M6,6H0L6,-6Z'], ['M-6,-6H6L0,6Z']];
          useGradient = false;
          break;
        case 'volume':
          ptsData = [['M-6,6H0L-6,-6Z'], ['M6,6H0L6,-6Z'], ['M-6,-6H6L0,6Z']];
          useGradient = true;
          break;
        case 'isosurface':
          ptsData = [['M-6,6H0L-6,-6Z'], ['M6,6H0L6,-6Z'], ['M-6,-6 A12,24 0 0,0 6,-6 L0,6Z']];
          useGradient = false;
          break;
      }
    }
    var pts = d3.select(this).select('g.legendpoints').selectAll('path.legend3dandfriends').data(ptsData);
    pts.enter().append('path').classed('legend3dandfriends', true).attr('transform', centerTransform).style('stroke-miterlimit', 1);
    pts.exit().remove();
    pts.each(function (dd, i) {
      var pt = d3.select(this);
      var cOpts = extractOpts(trace);
      var colorscale = cOpts.colorscale;
      var reversescale = cOpts.reversescale;
      var fillGradient = function (s) {
        if (s.size()) {
          var gradientID = 'legendfill-' + trace.uid;
          Drawing.gradient(s, gd, gradientID, getGradientDirection(reversescale, useGradient === 'radial'), colorscale, 'fill');
        }
      };
      var fillColor;
      if (!colorscale) {
        var color = trace.vertexcolor || trace.facecolor || trace.color;
        fillColor = Lib.isArrayOrTypedArray(color) ? color[i] || color[0] : color;
      } else {
        if (!useGradient) {
          var len = colorscale.length;
          fillColor = i === 0 ? colorscale[reversescale ? len - 1 : 0][1] :
          // minimum
          i === 1 ? colorscale[reversescale ? 0 : len - 1][1] :
          // maximum
          colorscale[Math.floor((len - 1) / 2)][1]; // middle
        }
      }

      pt.attr('d', dd[0]);
      if (fillColor) {
        pt.call(Color.fill, fillColor);
      } else {
        pt.call(fillGradient);
      }
    });
  }
};
function getGradientDirection(reversescale, isRadial) {
  var str = isRadial ? 'radial' : 'horizontal';
  return str + (reversescale ? '' : 'reversed');
}
function getStyleGuide(d) {
  var trace = d[0].trace;
  var contours = trace.contours;
  var showLine = subTypes.hasLines(trace);
  var showMarker = subTypes.hasMarkers(trace);
  var showFill = trace.visible && trace.fill && trace.fill !== 'none';
  var showGradientLine = false;
  var showGradientFill = false;
  if (contours) {
    var coloring = contours.coloring;
    if (coloring === 'lines') {
      showGradientLine = true;
    } else {
      showLine = coloring === 'none' || coloring === 'heatmap' || contours.showlines;
    }
    if (contours.type === 'constraint') {
      showFill = contours._operation !== '=';
    } else if (coloring === 'fill' || coloring === 'heatmap') {
      showGradientFill = true;
    }
  }
  return {
    showMarker: showMarker,
    showLine: showLine,
    showFill: showFill,
    showGradientLine: showGradientLine,
    showGradientFill: showGradientFill,
    anyLine: showLine || showGradientLine,
    anyFill: showFill || showGradientFill
  };
}
function dimAttr(v, dflt, max) {
  if (v && Lib.isArrayOrTypedArray(v)) return dflt;
  if (v > max) return max;
  return v;
}

/***/ }),

/***/ 2068:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var constants = __webpack_require__(3348);
module.exports = {
  editType: 'modebar',
  orientation: {
    valType: 'enumerated',
    values: ['v', 'h'],
    dflt: 'h',
    editType: 'modebar'
  },
  bgcolor: {
    valType: 'color',
    editType: 'modebar'
  },
  color: {
    valType: 'color',
    editType: 'modebar'
  },
  activecolor: {
    valType: 'color',
    editType: 'modebar'
  },
  uirevision: {
    valType: 'any',
    editType: 'none'
  },
  add: {
    valType: 'string',
    arrayOk: true,
    dflt: '',
    editType: 'modebar'
  },
  remove: {
    valType: 'string',
    arrayOk: true,
    dflt: '',
    editType: 'modebar'
  }
};

/***/ }),

/***/ 6023:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);
var Plots = __webpack_require__(4875);
var axisIds = __webpack_require__(1675);
var Icons = __webpack_require__(4255);
var eraseActiveShape = (__webpack_require__(4031).eraseActiveShape);
var Lib = __webpack_require__(1828);
var _ = Lib._;
var modeBarButtons = module.exports = {};

/**
 * ModeBar buttons configuration
 *
 * @param {string} name
 *      name / id of the buttons (for tracking)
 * @param {string} title
 *      text that appears while hovering over the button,
 *      enter null, false or '' for no hover text
 * @param {string} icon
 *      svg icon object associated with the button
 *      can be linked to Plotly.Icons to use the default plotly icons
 * @param {string} [gravity]
 *      icon positioning
 * @param {function} click
 *      click handler associated with the button, a function of
 *      'gd' (the main graph object) and
 *      'ev' (the event object)
 * @param {string} [attr]
 *      attribute associated with button,
 *      use this with 'val' to keep track of the state
 * @param {*} [val]
 *      initial 'attr' value, can be a function of gd
 * @param {boolean} [toggle]
 *      is the button a toggle button?
 */
modeBarButtons.toImage = {
  name: 'toImage',
  title: function (gd) {
    var opts = gd._context.toImageButtonOptions || {};
    var format = opts.format || 'png';
    return format === 'png' ? _(gd, 'Download plot as a png') :
    // legacy text
    _(gd, 'Download plot'); // generic non-PNG text
  },

  icon: Icons.camera,
  click: function (gd) {
    var toImageButtonOptions = gd._context.toImageButtonOptions;
    var opts = {
      format: toImageButtonOptions.format || 'png'
    };
    Lib.notifier(_(gd, 'Taking snapshot - this may take a few seconds'), 'long');
    if (opts.format !== 'svg' && Lib.isIE()) {
      Lib.notifier(_(gd, 'IE only supports svg.  Changing format to svg.'), 'long');
      opts.format = 'svg';
    }
    ['filename', 'width', 'height', 'scale'].forEach(function (key) {
      if (key in toImageButtonOptions) {
        opts[key] = toImageButtonOptions[key];
      }
    });
    Registry.call('downloadImage', gd, opts).then(function (filename) {
      Lib.notifier(_(gd, 'Snapshot succeeded') + ' - ' + filename, 'long');
    }).catch(function () {
      Lib.notifier(_(gd, 'Sorry, there was a problem downloading your snapshot!'), 'long');
    });
  }
};
modeBarButtons.sendDataToCloud = {
  name: 'sendDataToCloud',
  title: function (gd) {
    return _(gd, 'Edit in Chart Studio');
  },
  icon: Icons.disk,
  click: function (gd) {
    Plots.sendDataToCloud(gd);
  }
};
modeBarButtons.editInChartStudio = {
  name: 'editInChartStudio',
  title: function (gd) {
    return _(gd, 'Edit in Chart Studio');
  },
  icon: Icons.pencil,
  click: function (gd) {
    Plots.sendDataToCloud(gd);
  }
};
modeBarButtons.zoom2d = {
  name: 'zoom2d',
  _cat: 'zoom',
  title: function (gd) {
    return _(gd, 'Zoom');
  },
  attr: 'dragmode',
  val: 'zoom',
  icon: Icons.zoombox,
  click: handleCartesian
};
modeBarButtons.pan2d = {
  name: 'pan2d',
  _cat: 'pan',
  title: function (gd) {
    return _(gd, 'Pan');
  },
  attr: 'dragmode',
  val: 'pan',
  icon: Icons.pan,
  click: handleCartesian
};
modeBarButtons.select2d = {
  name: 'select2d',
  _cat: 'select',
  title: function (gd) {
    return _(gd, 'Box Select');
  },
  attr: 'dragmode',
  val: 'select',
  icon: Icons.selectbox,
  click: handleCartesian
};
modeBarButtons.lasso2d = {
  name: 'lasso2d',
  _cat: 'lasso',
  title: function (gd) {
    return _(gd, 'Lasso Select');
  },
  attr: 'dragmode',
  val: 'lasso',
  icon: Icons.lasso,
  click: handleCartesian
};
modeBarButtons.drawclosedpath = {
  name: 'drawclosedpath',
  title: function (gd) {
    return _(gd, 'Draw closed freeform');
  },
  attr: 'dragmode',
  val: 'drawclosedpath',
  icon: Icons.drawclosedpath,
  click: handleCartesian
};
modeBarButtons.drawopenpath = {
  name: 'drawopenpath',
  title: function (gd) {
    return _(gd, 'Draw open freeform');
  },
  attr: 'dragmode',
  val: 'drawopenpath',
  icon: Icons.drawopenpath,
  click: handleCartesian
};
modeBarButtons.drawline = {
  name: 'drawline',
  title: function (gd) {
    return _(gd, 'Draw line');
  },
  attr: 'dragmode',
  val: 'drawline',
  icon: Icons.drawline,
  click: handleCartesian
};
modeBarButtons.drawrect = {
  name: 'drawrect',
  title: function (gd) {
    return _(gd, 'Draw rectangle');
  },
  attr: 'dragmode',
  val: 'drawrect',
  icon: Icons.drawrect,
  click: handleCartesian
};
modeBarButtons.drawcircle = {
  name: 'drawcircle',
  title: function (gd) {
    return _(gd, 'Draw circle');
  },
  attr: 'dragmode',
  val: 'drawcircle',
  icon: Icons.drawcircle,
  click: handleCartesian
};
modeBarButtons.eraseshape = {
  name: 'eraseshape',
  title: function (gd) {
    return _(gd, 'Erase active shape');
  },
  icon: Icons.eraseshape,
  click: eraseActiveShape
};
modeBarButtons.zoomIn2d = {
  name: 'zoomIn2d',
  _cat: 'zoomin',
  title: function (gd) {
    return _(gd, 'Zoom in');
  },
  attr: 'zoom',
  val: 'in',
  icon: Icons.zoom_plus,
  click: handleCartesian
};
modeBarButtons.zoomOut2d = {
  name: 'zoomOut2d',
  _cat: 'zoomout',
  title: function (gd) {
    return _(gd, 'Zoom out');
  },
  attr: 'zoom',
  val: 'out',
  icon: Icons.zoom_minus,
  click: handleCartesian
};
modeBarButtons.autoScale2d = {
  name: 'autoScale2d',
  _cat: 'autoscale',
  title: function (gd) {
    return _(gd, 'Autoscale');
  },
  attr: 'zoom',
  val: 'auto',
  icon: Icons.autoscale,
  click: handleCartesian
};
modeBarButtons.resetScale2d = {
  name: 'resetScale2d',
  _cat: 'resetscale',
  title: function (gd) {
    return _(gd, 'Reset axes');
  },
  attr: 'zoom',
  val: 'reset',
  icon: Icons.home,
  click: handleCartesian
};
modeBarButtons.hoverClosestCartesian = {
  name: 'hoverClosestCartesian',
  _cat: 'hoverclosest',
  title: function (gd) {
    return _(gd, 'Show closest data on hover');
  },
  attr: 'hovermode',
  val: 'closest',
  icon: Icons.tooltip_basic,
  gravity: 'ne',
  click: handleCartesian
};
modeBarButtons.hoverCompareCartesian = {
  name: 'hoverCompareCartesian',
  _cat: 'hoverCompare',
  title: function (gd) {
    return _(gd, 'Compare data on hover');
  },
  attr: 'hovermode',
  val: function (gd) {
    return gd._fullLayout._isHoriz ? 'y' : 'x';
  },
  icon: Icons.tooltip_compare,
  gravity: 'ne',
  click: handleCartesian
};
function handleCartesian(gd, ev) {
  var button = ev.currentTarget;
  var astr = button.getAttribute('data-attr');
  var val = button.getAttribute('data-val') || true;
  var fullLayout = gd._fullLayout;
  var aobj = {};
  var axList = axisIds.list(gd, null, true);
  var allSpikesEnabled = fullLayout._cartesianSpikesEnabled;
  var ax, i;
  if (astr === 'zoom') {
    var mag = val === 'in' ? 0.5 : 2;
    var r0 = (1 + mag) / 2;
    var r1 = (1 - mag) / 2;
    var axName;
    for (i = 0; i < axList.length; i++) {
      ax = axList[i];
      if (!ax.fixedrange) {
        axName = ax._name;
        if (val === 'auto') {
          aobj[axName + '.autorange'] = true;
        } else if (val === 'reset') {
          if (ax._rangeInitial0 === undefined && ax._rangeInitial1 === undefined) {
            aobj[axName + '.autorange'] = true;
          } else if (ax._rangeInitial0 === undefined) {
            aobj[axName + '.autorange'] = ax._autorangeInitial;
            aobj[axName + '.range'] = [null, ax._rangeInitial1];
          } else if (ax._rangeInitial1 === undefined) {
            aobj[axName + '.range'] = [ax._rangeInitial0, null];
            aobj[axName + '.autorange'] = ax._autorangeInitial;
          } else {
            aobj[axName + '.range'] = [ax._rangeInitial0, ax._rangeInitial1];
          }

          // N.B. "reset" also resets showspikes
          if (ax._showSpikeInitial !== undefined) {
            aobj[axName + '.showspikes'] = ax._showSpikeInitial;
            if (allSpikesEnabled === 'on' && !ax._showSpikeInitial) {
              allSpikesEnabled = 'off';
            }
          }
        } else {
          var rangeNow = [ax.r2l(ax.range[0]), ax.r2l(ax.range[1])];
          var rangeNew = [r0 * rangeNow[0] + r1 * rangeNow[1], r0 * rangeNow[1] + r1 * rangeNow[0]];
          aobj[axName + '.range[0]'] = ax.l2r(rangeNew[0]);
          aobj[axName + '.range[1]'] = ax.l2r(rangeNew[1]);
        }
      }
    }
  } else {
    // if ALL traces have orientation 'h', 'hovermode': 'x' otherwise: 'y'
    if (astr === 'hovermode' && (val === 'x' || val === 'y')) {
      val = fullLayout._isHoriz ? 'y' : 'x';
      button.setAttribute('data-val', val);
    }
    aobj[astr] = val;
  }
  fullLayout._cartesianSpikesEnabled = allSpikesEnabled;
  Registry.call('_guiRelayout', gd, aobj);
}
modeBarButtons.zoom3d = {
  name: 'zoom3d',
  _cat: 'zoom',
  title: function (gd) {
    return _(gd, 'Zoom');
  },
  attr: 'scene.dragmode',
  val: 'zoom',
  icon: Icons.zoombox,
  click: handleDrag3d
};
modeBarButtons.pan3d = {
  name: 'pan3d',
  _cat: 'pan',
  title: function (gd) {
    return _(gd, 'Pan');
  },
  attr: 'scene.dragmode',
  val: 'pan',
  icon: Icons.pan,
  click: handleDrag3d
};
modeBarButtons.orbitRotation = {
  name: 'orbitRotation',
  title: function (gd) {
    return _(gd, 'Orbital rotation');
  },
  attr: 'scene.dragmode',
  val: 'orbit',
  icon: Icons['3d_rotate'],
  click: handleDrag3d
};
modeBarButtons.tableRotation = {
  name: 'tableRotation',
  title: function (gd) {
    return _(gd, 'Turntable rotation');
  },
  attr: 'scene.dragmode',
  val: 'turntable',
  icon: Icons['z-axis'],
  click: handleDrag3d
};
function handleDrag3d(gd, ev) {
  var button = ev.currentTarget;
  var attr = button.getAttribute('data-attr');
  var val = button.getAttribute('data-val') || true;
  var sceneIds = gd._fullLayout._subplots.gl3d || [];
  var layoutUpdate = {};
  var parts = attr.split('.');
  for (var i = 0; i < sceneIds.length; i++) {
    layoutUpdate[sceneIds[i] + '.' + parts[1]] = val;
  }

  // for multi-type subplots
  var val2d = val === 'pan' ? val : 'zoom';
  layoutUpdate.dragmode = val2d;
  Registry.call('_guiRelayout', gd, layoutUpdate);
}
modeBarButtons.resetCameraDefault3d = {
  name: 'resetCameraDefault3d',
  _cat: 'resetCameraDefault',
  title: function (gd) {
    return _(gd, 'Reset camera to default');
  },
  attr: 'resetDefault',
  icon: Icons.home,
  click: handleCamera3d
};
modeBarButtons.resetCameraLastSave3d = {
  name: 'resetCameraLastSave3d',
  _cat: 'resetCameraLastSave',
  title: function (gd) {
    return _(gd, 'Reset camera to last save');
  },
  attr: 'resetLastSave',
  icon: Icons.movie,
  click: handleCamera3d
};
function handleCamera3d(gd, ev) {
  var button = ev.currentTarget;
  var attr = button.getAttribute('data-attr');
  var resetLastSave = attr === 'resetLastSave';
  var resetDefault = attr === 'resetDefault';
  var fullLayout = gd._fullLayout;
  var sceneIds = fullLayout._subplots.gl3d || [];
  var aobj = {};
  for (var i = 0; i < sceneIds.length; i++) {
    var sceneId = sceneIds[i];
    var camera = sceneId + '.camera';
    var aspectratio = sceneId + '.aspectratio';
    var aspectmode = sceneId + '.aspectmode';
    var scene = fullLayout[sceneId]._scene;
    var didUpdate;
    if (resetLastSave) {
      aobj[camera + '.up'] = scene.viewInitial.up;
      aobj[camera + '.eye'] = scene.viewInitial.eye;
      aobj[camera + '.center'] = scene.viewInitial.center;
      didUpdate = true;
    } else if (resetDefault) {
      aobj[camera + '.up'] = null;
      aobj[camera + '.eye'] = null;
      aobj[camera + '.center'] = null;
      didUpdate = true;
    }
    if (didUpdate) {
      aobj[aspectratio + '.x'] = scene.viewInitial.aspectratio.x;
      aobj[aspectratio + '.y'] = scene.viewInitial.aspectratio.y;
      aobj[aspectratio + '.z'] = scene.viewInitial.aspectratio.z;
      aobj[aspectmode] = scene.viewInitial.aspectmode;
    }
  }
  Registry.call('_guiRelayout', gd, aobj);
}
modeBarButtons.hoverClosest3d = {
  name: 'hoverClosest3d',
  _cat: 'hoverclosest',
  title: function (gd) {
    return _(gd, 'Toggle show closest data on hover');
  },
  attr: 'hovermode',
  val: null,
  toggle: true,
  icon: Icons.tooltip_basic,
  gravity: 'ne',
  click: handleHover3d
};
function getNextHover3d(gd, ev) {
  var button = ev.currentTarget;
  var val = button._previousVal;
  var fullLayout = gd._fullLayout;
  var sceneIds = fullLayout._subplots.gl3d || [];
  var axes = ['xaxis', 'yaxis', 'zaxis'];

  // initialize 'current spike' object to be stored in the DOM
  var currentSpikes = {};
  var layoutUpdate = {};
  if (val) {
    layoutUpdate = val;
    button._previousVal = null;
  } else {
    for (var i = 0; i < sceneIds.length; i++) {
      var sceneId = sceneIds[i];
      var sceneLayout = fullLayout[sceneId];
      var hovermodeAStr = sceneId + '.hovermode';
      currentSpikes[hovermodeAStr] = sceneLayout.hovermode;
      layoutUpdate[hovermodeAStr] = false;

      // copy all the current spike attrs
      for (var j = 0; j < 3; j++) {
        var axis = axes[j];
        var spikeAStr = sceneId + '.' + axis + '.showspikes';
        layoutUpdate[spikeAStr] = false;
        currentSpikes[spikeAStr] = sceneLayout[axis].showspikes;
      }
    }
    button._previousVal = currentSpikes;
  }
  return layoutUpdate;
}
function handleHover3d(gd, ev) {
  var layoutUpdate = getNextHover3d(gd, ev);
  Registry.call('_guiRelayout', gd, layoutUpdate);
}
modeBarButtons.zoomInGeo = {
  name: 'zoomInGeo',
  _cat: 'zoomin',
  title: function (gd) {
    return _(gd, 'Zoom in');
  },
  attr: 'zoom',
  val: 'in',
  icon: Icons.zoom_plus,
  click: handleGeo
};
modeBarButtons.zoomOutGeo = {
  name: 'zoomOutGeo',
  _cat: 'zoomout',
  title: function (gd) {
    return _(gd, 'Zoom out');
  },
  attr: 'zoom',
  val: 'out',
  icon: Icons.zoom_minus,
  click: handleGeo
};
modeBarButtons.resetGeo = {
  name: 'resetGeo',
  _cat: 'reset',
  title: function (gd) {
    return _(gd, 'Reset');
  },
  attr: 'reset',
  val: null,
  icon: Icons.autoscale,
  click: handleGeo
};
modeBarButtons.hoverClosestGeo = {
  name: 'hoverClosestGeo',
  _cat: 'hoverclosest',
  title: function (gd) {
    return _(gd, 'Toggle show closest data on hover');
  },
  attr: 'hovermode',
  val: null,
  toggle: true,
  icon: Icons.tooltip_basic,
  gravity: 'ne',
  click: toggleHover
};
function handleGeo(gd, ev) {
  var button = ev.currentTarget;
  var attr = button.getAttribute('data-attr');
  var val = button.getAttribute('data-val') || true;
  var fullLayout = gd._fullLayout;
  var geoIds = fullLayout._subplots.geo || [];
  for (var i = 0; i < geoIds.length; i++) {
    var id = geoIds[i];
    var geoLayout = fullLayout[id];
    if (attr === 'zoom') {
      var scale = geoLayout.projection.scale;
      var newScale = val === 'in' ? 2 * scale : 0.5 * scale;
      Registry.call('_guiRelayout', gd, id + '.projection.scale', newScale);
    }
  }
  if (attr === 'reset') {
    resetView(gd, 'geo');
  }
}
modeBarButtons.hoverClosestGl2d = {
  name: 'hoverClosestGl2d',
  _cat: 'hoverclosest',
  title: function (gd) {
    return _(gd, 'Toggle show closest data on hover');
  },
  attr: 'hovermode',
  val: null,
  toggle: true,
  icon: Icons.tooltip_basic,
  gravity: 'ne',
  click: toggleHover
};
modeBarButtons.hoverClosestPie = {
  name: 'hoverClosestPie',
  _cat: 'hoverclosest',
  title: function (gd) {
    return _(gd, 'Toggle show closest data on hover');
  },
  attr: 'hovermode',
  val: 'closest',
  icon: Icons.tooltip_basic,
  gravity: 'ne',
  click: toggleHover
};
function getNextHover(gd) {
  var fullLayout = gd._fullLayout;
  if (fullLayout.hovermode) return false;
  if (fullLayout._has('cartesian')) {
    return fullLayout._isHoriz ? 'y' : 'x';
  }
  return 'closest';
}
function toggleHover(gd) {
  var newHover = getNextHover(gd);
  Registry.call('_guiRelayout', gd, 'hovermode', newHover);
}
modeBarButtons.resetViewSankey = {
  name: 'resetSankeyGroup',
  title: function (gd) {
    return _(gd, 'Reset view');
  },
  icon: Icons.home,
  click: function (gd) {
    var aObj = {
      'node.groups': [],
      'node.x': [],
      'node.y': []
    };
    for (var i = 0; i < gd._fullData.length; i++) {
      var viewInitial = gd._fullData[i]._viewInitial;
      aObj['node.groups'].push(viewInitial.node.groups.slice());
      aObj['node.x'].push(viewInitial.node.x.slice());
      aObj['node.y'].push(viewInitial.node.y.slice());
    }
    Registry.call('restyle', gd, aObj);
  }
};

// buttons when more then one plot types are present

modeBarButtons.toggleHover = {
  name: 'toggleHover',
  title: function (gd) {
    return _(gd, 'Toggle show closest data on hover');
  },
  attr: 'hovermode',
  val: null,
  toggle: true,
  icon: Icons.tooltip_basic,
  gravity: 'ne',
  click: function (gd, ev) {
    var layoutUpdate = getNextHover3d(gd, ev);
    layoutUpdate.hovermode = getNextHover(gd);
    Registry.call('_guiRelayout', gd, layoutUpdate);
  }
};
modeBarButtons.resetViews = {
  name: 'resetViews',
  title: function (gd) {
    return _(gd, 'Reset views');
  },
  icon: Icons.home,
  click: function (gd, ev) {
    var button = ev.currentTarget;
    button.setAttribute('data-attr', 'zoom');
    button.setAttribute('data-val', 'reset');
    handleCartesian(gd, ev);
    button.setAttribute('data-attr', 'resetLastSave');
    handleCamera3d(gd, ev);
    resetView(gd, 'geo');
    resetView(gd, 'mapbox');
  }
};
modeBarButtons.toggleSpikelines = {
  name: 'toggleSpikelines',
  title: function (gd) {
    return _(gd, 'Toggle Spike Lines');
  },
  icon: Icons.spikeline,
  attr: '_cartesianSpikesEnabled',
  val: 'on',
  click: function (gd) {
    var fullLayout = gd._fullLayout;
    var allSpikesEnabled = fullLayout._cartesianSpikesEnabled;
    fullLayout._cartesianSpikesEnabled = allSpikesEnabled === 'on' ? 'off' : 'on';
    Registry.call('_guiRelayout', gd, setSpikelineVisibility(gd));
  }
};
function setSpikelineVisibility(gd) {
  var fullLayout = gd._fullLayout;
  var areSpikesOn = fullLayout._cartesianSpikesEnabled === 'on';
  var axList = axisIds.list(gd, null, true);
  var aobj = {};
  for (var i = 0; i < axList.length; i++) {
    var ax = axList[i];
    aobj[ax._name + '.showspikes'] = areSpikesOn ? true : ax._showSpikeInitial;
  }
  return aobj;
}
modeBarButtons.resetViewMapbox = {
  name: 'resetViewMapbox',
  _cat: 'resetView',
  title: function (gd) {
    return _(gd, 'Reset view');
  },
  attr: 'reset',
  icon: Icons.home,
  click: function (gd) {
    resetView(gd, 'mapbox');
  }
};
modeBarButtons.zoomInMapbox = {
  name: 'zoomInMapbox',
  _cat: 'zoomin',
  title: function (gd) {
    return _(gd, 'Zoom in');
  },
  attr: 'zoom',
  val: 'in',
  icon: Icons.zoom_plus,
  click: handleMapboxZoom
};
modeBarButtons.zoomOutMapbox = {
  name: 'zoomOutMapbox',
  _cat: 'zoomout',
  title: function (gd) {
    return _(gd, 'Zoom out');
  },
  attr: 'zoom',
  val: 'out',
  icon: Icons.zoom_minus,
  click: handleMapboxZoom
};
function handleMapboxZoom(gd, ev) {
  var button = ev.currentTarget;
  var val = button.getAttribute('data-val');
  var fullLayout = gd._fullLayout;
  var subplotIds = fullLayout._subplots.mapbox || [];
  var scalar = 1.05;
  var aObj = {};
  for (var i = 0; i < subplotIds.length; i++) {
    var id = subplotIds[i];
    var current = fullLayout[id].zoom;
    var next = val === 'in' ? scalar * current : current / scalar;
    aObj[id + '.zoom'] = next;
  }
  Registry.call('_guiRelayout', gd, aObj);
}
function resetView(gd, subplotType) {
  var fullLayout = gd._fullLayout;
  var subplotIds = fullLayout._subplots[subplotType] || [];
  var aObj = {};
  for (var i = 0; i < subplotIds.length; i++) {
    var id = subplotIds[i];
    var subplotObj = fullLayout[id]._subplot;
    var viewInitial = subplotObj.viewInitial;
    var viewKeys = Object.keys(viewInitial);
    for (var j = 0; j < viewKeys.length; j++) {
      var key = viewKeys[j];
      aObj[id + '.' + key] = viewInitial[key];
    }
  }
  Registry.call('_guiRelayout', gd, aObj);
}

/***/ }),

/***/ 3348:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var modeBarButtons = __webpack_require__(6023);
var buttonList = Object.keys(modeBarButtons);
var DRAW_MODES = ['drawline', 'drawopenpath', 'drawclosedpath', 'drawcircle', 'drawrect', 'eraseshape'];
var backButtons = ['v1hovermode', 'hoverclosest', 'hovercompare', 'togglehover', 'togglespikelines'].concat(DRAW_MODES);
var foreButtons = [];
var addToForeButtons = function (b) {
  if (backButtons.indexOf(b._cat || b.name) !== -1) return;
  // for convenience add lowercase shotname e.g. zoomin as well fullname zoomInGeo
  var name = b.name;
  var _cat = (b._cat || b.name).toLowerCase();
  if (foreButtons.indexOf(name) === -1) foreButtons.push(name);
  if (foreButtons.indexOf(_cat) === -1) foreButtons.push(_cat);
};
buttonList.forEach(function (k) {
  addToForeButtons(modeBarButtons[k]);
});
foreButtons.sort();
module.exports = {
  DRAW_MODES: DRAW_MODES,
  backButtons: backButtons,
  foreButtons: foreButtons
};

/***/ }),

/***/ 5750:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Color = __webpack_require__(7901);
var Template = __webpack_require__(4467);
var attributes = __webpack_require__(2068);
module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
  var containerIn = layoutIn.modebar || {};
  var containerOut = Template.newContainer(layoutOut, 'modebar');
  function coerce(attr, dflt) {
    return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
  }
  coerce('orientation');
  coerce('bgcolor', Color.addOpacity(layoutOut.paper_bgcolor, 0.5));
  var defaultColor = Color.contrast(Color.rgb(layoutOut.modebar.bgcolor));
  coerce('color', Color.addOpacity(defaultColor, 0.3));
  coerce('activecolor', Color.addOpacity(defaultColor, 0.7));
  coerce('uirevision', layoutOut.uirevision);
  coerce('add');
  coerce('remove');
};

/***/ }),

/***/ 4168:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  moduleType: 'component',
  name: 'modebar',
  layoutAttributes: __webpack_require__(2068),
  supplyLayoutDefaults: __webpack_require__(5750),
  manage: __webpack_require__(4192)
};

/***/ }),

/***/ 4192:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var axisIds = __webpack_require__(1675);
var scatterSubTypes = __webpack_require__(4098);
var Registry = __webpack_require__(3972);
var isUnifiedHover = (__webpack_require__(3469).isUnifiedHover);
var createModeBar = __webpack_require__(7676);
var modeBarButtons = __webpack_require__(6023);
var DRAW_MODES = (__webpack_require__(3348).DRAW_MODES);
var extendDeep = (__webpack_require__(1828).extendDeep);

/**
 * ModeBar wrapper around 'create' and 'update',
 * chooses buttons to pass to ModeBar constructor based on
 * plot type and plot config.
 *
 * @param {object} gd main plot object
 *
 */
module.exports = function manageModeBar(gd) {
  var fullLayout = gd._fullLayout;
  var context = gd._context;
  var modeBar = fullLayout._modeBar;
  if (!context.displayModeBar && !context.watermark) {
    if (modeBar) {
      modeBar.destroy();
      delete fullLayout._modeBar;
    }
    return;
  }
  if (!Array.isArray(context.modeBarButtonsToRemove)) {
    throw new Error(['*modeBarButtonsToRemove* configuration options', 'must be an array.'].join(' '));
  }
  if (!Array.isArray(context.modeBarButtonsToAdd)) {
    throw new Error(['*modeBarButtonsToAdd* configuration options', 'must be an array.'].join(' '));
  }
  var customButtons = context.modeBarButtons;
  var buttonGroups;
  if (Array.isArray(customButtons) && customButtons.length) {
    buttonGroups = fillCustomButton(customButtons);
  } else if (!context.displayModeBar && context.watermark) {
    buttonGroups = [];
  } else {
    buttonGroups = getButtonGroups(gd);
  }
  if (modeBar) modeBar.update(gd, buttonGroups);else fullLayout._modeBar = createModeBar(gd, buttonGroups);
};

// logic behind which buttons are displayed by default
function getButtonGroups(gd) {
  var fullLayout = gd._fullLayout;
  var fullData = gd._fullData;
  var context = gd._context;
  function match(name, B) {
    if (typeof B === 'string') {
      if (B.toLowerCase() === name.toLowerCase()) return true;
    } else {
      var v0 = B.name;
      var v1 = B._cat || B.name;
      if (v0 === name || v1 === name.toLowerCase()) return true;
    }
    return false;
  }
  var layoutAdd = fullLayout.modebar.add;
  if (typeof layoutAdd === 'string') layoutAdd = [layoutAdd];
  var layoutRemove = fullLayout.modebar.remove;
  if (typeof layoutRemove === 'string') layoutRemove = [layoutRemove];
  var buttonsToAdd = context.modeBarButtonsToAdd.concat(layoutAdd.filter(function (e) {
    for (var i = 0; i < context.modeBarButtonsToRemove.length; i++) {
      if (match(e, context.modeBarButtonsToRemove[i])) return false;
    }
    return true;
  }));
  var buttonsToRemove = context.modeBarButtonsToRemove.concat(layoutRemove.filter(function (e) {
    for (var i = 0; i < context.modeBarButtonsToAdd.length; i++) {
      if (match(e, context.modeBarButtonsToAdd[i])) return false;
    }
    return true;
  }));
  var hasCartesian = fullLayout._has('cartesian');
  var hasGL3D = fullLayout._has('gl3d');
  var hasGeo = fullLayout._has('geo');
  var hasPie = fullLayout._has('pie');
  var hasFunnelarea = fullLayout._has('funnelarea');
  var hasGL2D = fullLayout._has('gl2d');
  var hasTernary = fullLayout._has('ternary');
  var hasMapbox = fullLayout._has('mapbox');
  var hasPolar = fullLayout._has('polar');
  var hasSmith = fullLayout._has('smith');
  var hasSankey = fullLayout._has('sankey');
  var allAxesFixed = areAllAxesFixed(fullLayout);
  var hasUnifiedHoverLabel = isUnifiedHover(fullLayout.hovermode);
  var groups = [];
  function addGroup(newGroup) {
    if (!newGroup.length) return;
    var out = [];
    for (var i = 0; i < newGroup.length; i++) {
      var name = newGroup[i];
      var B = modeBarButtons[name];
      var v0 = B.name.toLowerCase();
      var v1 = (B._cat || B.name).toLowerCase();
      var found = false;
      for (var q = 0; q < buttonsToRemove.length; q++) {
        var t = buttonsToRemove[q].toLowerCase();
        if (t === v0 || t === v1) {
          found = true;
          break;
        }
      }
      if (found) continue;
      out.push(modeBarButtons[name]);
    }
    groups.push(out);
  }

  // buttons common to all plot types
  var commonGroup = ['toImage'];
  if (context.showEditInChartStudio) commonGroup.push('editInChartStudio');else if (context.showSendToCloud) commonGroup.push('sendDataToCloud');
  addGroup(commonGroup);
  var zoomGroup = [];
  var hoverGroup = [];
  var resetGroup = [];
  var dragModeGroup = [];
  if ((hasCartesian || hasGL2D || hasPie || hasFunnelarea || hasTernary) + hasGeo + hasGL3D + hasMapbox + hasPolar + hasSmith > 1) {
    // graphs with more than one plot types get 'union buttons'
    // which reset the view or toggle hover labels across all subplots.
    hoverGroup = ['toggleHover'];
    resetGroup = ['resetViews'];
  } else if (hasGeo) {
    zoomGroup = ['zoomInGeo', 'zoomOutGeo'];
    hoverGroup = ['hoverClosestGeo'];
    resetGroup = ['resetGeo'];
  } else if (hasGL3D) {
    hoverGroup = ['hoverClosest3d'];
    resetGroup = ['resetCameraDefault3d', 'resetCameraLastSave3d'];
  } else if (hasMapbox) {
    zoomGroup = ['zoomInMapbox', 'zoomOutMapbox'];
    hoverGroup = ['toggleHover'];
    resetGroup = ['resetViewMapbox'];
  } else if (hasGL2D) {
    hoverGroup = ['hoverClosestGl2d'];
  } else if (hasPie) {
    hoverGroup = ['hoverClosestPie'];
  } else if (hasSankey) {
    hoverGroup = ['hoverClosestCartesian', 'hoverCompareCartesian'];
    resetGroup = ['resetViewSankey'];
  } else {
    // hasPolar, hasSmith, hasTernary
    // always show at least one hover icon.
    hoverGroup = ['toggleHover'];
  }
  // if we have cartesian, allow switching between closest and compare
  // regardless of what other types are on the plot, since they'll all
  // just treat any truthy hovermode as 'closest'
  if (hasCartesian) {
    hoverGroup = ['toggleSpikelines', 'hoverClosestCartesian', 'hoverCompareCartesian'];
  }
  if (hasNoHover(fullData) || hasUnifiedHoverLabel) {
    hoverGroup = [];
  }
  if ((hasCartesian || hasGL2D) && !allAxesFixed) {
    zoomGroup = ['zoomIn2d', 'zoomOut2d', 'autoScale2d'];
    if (resetGroup[0] !== 'resetViews') resetGroup = ['resetScale2d'];
  }
  if (hasGL3D) {
    dragModeGroup = ['zoom3d', 'pan3d', 'orbitRotation', 'tableRotation'];
  } else if ((hasCartesian || hasGL2D) && !allAxesFixed || hasTernary) {
    dragModeGroup = ['zoom2d', 'pan2d'];
  } else if (hasMapbox || hasGeo) {
    dragModeGroup = ['pan2d'];
  } else if (hasPolar) {
    dragModeGroup = ['zoom2d'];
  }
  if (isSelectable(fullData)) {
    dragModeGroup.push('select2d', 'lasso2d');
  }
  var enabledHoverGroup = [];
  var enableHover = function (a) {
    // return if already added
    if (enabledHoverGroup.indexOf(a) !== -1) return;
    // should be in hoverGroup
    if (hoverGroup.indexOf(a) !== -1) {
      enabledHoverGroup.push(a);
    }
  };
  if (Array.isArray(buttonsToAdd)) {
    var newList = [];
    for (var i = 0; i < buttonsToAdd.length; i++) {
      var b = buttonsToAdd[i];
      if (typeof b === 'string') {
        b = b.toLowerCase();
        if (DRAW_MODES.indexOf(b) !== -1) {
          // accept pre-defined drag modes i.e. shape drawing features as string
          if (fullLayout._has('mapbox') ||
          // draw shapes in paper coordinate (could be improved in future to support data coordinate, when there is no pitch)
          fullLayout._has('cartesian') // draw shapes in data coordinate
          ) {
            dragModeGroup.push(b);
          }
        } else if (b === 'togglespikelines') {
          enableHover('toggleSpikelines');
        } else if (b === 'togglehover') {
          enableHover('toggleHover');
        } else if (b === 'hovercompare') {
          enableHover('hoverCompareCartesian');
        } else if (b === 'hoverclosest') {
          enableHover('hoverClosestCartesian');
          enableHover('hoverClosestGeo');
          enableHover('hoverClosest3d');
          enableHover('hoverClosestGl2d');
          enableHover('hoverClosestPie');
        } else if (b === 'v1hovermode') {
          enableHover('toggleHover');
          enableHover('hoverClosestCartesian');
          enableHover('hoverCompareCartesian');
          enableHover('hoverClosestGeo');
          enableHover('hoverClosest3d');
          enableHover('hoverClosestGl2d');
          enableHover('hoverClosestPie');
        }
      } else newList.push(b);
    }
    buttonsToAdd = newList;
  }
  addGroup(dragModeGroup);
  addGroup(zoomGroup.concat(resetGroup));
  addGroup(enabledHoverGroup);
  return appendButtonsToGroups(groups, buttonsToAdd);
}
function areAllAxesFixed(fullLayout) {
  var axList = axisIds.list({
    _fullLayout: fullLayout
  }, null, true);
  for (var i = 0; i < axList.length; i++) {
    if (!axList[i].fixedrange) {
      return false;
    }
  }
  return true;
}

// look for traces that support selection
// to be updated as we add more selectPoints handlers
function isSelectable(fullData) {
  var selectable = false;
  for (var i = 0; i < fullData.length; i++) {
    if (selectable) break;
    var trace = fullData[i];
    if (!trace._module || !trace._module.selectPoints) continue;
    if (Registry.traceIs(trace, 'scatter-like')) {
      if (scatterSubTypes.hasMarkers(trace) || scatterSubTypes.hasText(trace)) {
        selectable = true;
      }
    } else if (Registry.traceIs(trace, 'box-violin')) {
      if (trace.boxpoints === 'all' || trace.points === 'all') {
        selectable = true;
      }
    } else {
      // assume that in general if the trace module has selectPoints,
      // then it's selectable. Scatter is an exception to this because it must
      // have markers or text, not just be a scatter type.

      selectable = true;
    }
  }
  return selectable;
}

// check whether all trace are 'noHover'
function hasNoHover(fullData) {
  for (var i = 0; i < fullData.length; i++) {
    if (!Registry.traceIs(fullData[i], 'noHover')) return false;
  }
  return true;
}
function appendButtonsToGroups(groups, buttons) {
  if (buttons.length) {
    if (Array.isArray(buttons[0])) {
      for (var i = 0; i < buttons.length; i++) {
        groups.push(buttons[i]);
      }
    } else groups.push(buttons);
  }
  return groups;
}

// fill in custom buttons referring to default mode bar buttons
function fillCustomButton(originalModeBarButtons) {
  var customButtons = extendDeep([], originalModeBarButtons);
  for (var i = 0; i < customButtons.length; i++) {
    var buttonGroup = customButtons[i];
    for (var j = 0; j < buttonGroup.length; j++) {
      var button = buttonGroup[j];
      if (typeof button === 'string') {
        if (modeBarButtons[button] !== undefined) {
          customButtons[i][j] = modeBarButtons[button];
        } else {
          throw new Error(['*modeBarButtons* configuration options', 'invalid button name'].join(' '));
        }
      }
    }
  }
  return customButtons;
}

/***/ }),

/***/ 7676:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var isNumeric = __webpack_require__(2770);
var Lib = __webpack_require__(1828);
var Icons = __webpack_require__(4255);
var version = (__webpack_require__(1506).version);
var Parser = new DOMParser();

/**
 * UI controller for interactive plots
 * @Class
 * @Param {object} opts
 * @Param {object} opts.buttons    nested arrays of grouped buttons config objects
 * @Param {object} opts.container  container div to append modeBar
 * @Param {object} opts.graphInfo  primary plot object containing data and layout
 */
function ModeBar(opts) {
  this.container = opts.container;
  this.element = document.createElement('div');
  this.update(opts.graphInfo, opts.buttons);
  this.container.appendChild(this.element);
}
var proto = ModeBar.prototype;

/**
 * Update modeBar (buttons and logo)
 *
 * @param {object} graphInfo  primary plot object containing data and layout
 * @param {array of arrays} buttons nested arrays of grouped buttons to initialize
 *
 */
proto.update = function (graphInfo, buttons) {
  this.graphInfo = graphInfo;
  var context = this.graphInfo._context;
  var fullLayout = this.graphInfo._fullLayout;
  var modeBarId = 'modebar-' + fullLayout._uid;
  this.element.setAttribute('id', modeBarId);
  this._uid = modeBarId;
  this.element.className = 'modebar';
  if (context.displayModeBar === 'hover') this.element.className += ' modebar--hover ease-bg';
  if (fullLayout.modebar.orientation === 'v') {
    this.element.className += ' vertical';
    buttons = buttons.reverse();
  }
  var style = fullLayout.modebar;
  var bgSelector = context.displayModeBar === 'hover' ? '.js-plotly-plot .plotly:hover ' : '';
  Lib.deleteRelatedStyleRule(modeBarId);
  Lib.addRelatedStyleRule(modeBarId, bgSelector + '#' + modeBarId + ' .modebar-group', 'background-color: ' + style.bgcolor);
  Lib.addRelatedStyleRule(modeBarId, '#' + modeBarId + ' .modebar-btn .icon path', 'fill: ' + style.color);
  Lib.addRelatedStyleRule(modeBarId, '#' + modeBarId + ' .modebar-btn:hover .icon path', 'fill: ' + style.activecolor);
  Lib.addRelatedStyleRule(modeBarId, '#' + modeBarId + ' .modebar-btn.active .icon path', 'fill: ' + style.activecolor);

  // if buttons or logo have changed, redraw modebar interior
  var needsNewButtons = !this.hasButtons(buttons);
  var needsNewLogo = this.hasLogo !== context.displaylogo;
  var needsNewLocale = this.locale !== context.locale;
  this.locale = context.locale;
  if (needsNewButtons || needsNewLogo || needsNewLocale) {
    this.removeAllButtons();
    this.updateButtons(buttons);
    if (context.watermark || context.displaylogo) {
      var logoGroup = this.getLogo();
      if (context.watermark) {
        logoGroup.className = logoGroup.className + ' watermark';
      }
      if (fullLayout.modebar.orientation === 'v') {
        this.element.insertBefore(logoGroup, this.element.childNodes[0]);
      } else {
        this.element.appendChild(logoGroup);
      }
      this.hasLogo = true;
    }
  }
  this.updateActiveButton();
};
proto.updateButtons = function (buttons) {
  var _this = this;
  this.buttons = buttons;
  this.buttonElements = [];
  this.buttonsNames = [];
  this.buttons.forEach(function (buttonGroup) {
    var group = _this.createGroup();
    buttonGroup.forEach(function (buttonConfig) {
      var buttonName = buttonConfig.name;
      if (!buttonName) {
        throw new Error('must provide button \'name\' in button config');
      }
      if (_this.buttonsNames.indexOf(buttonName) !== -1) {
        throw new Error('button name \'' + buttonName + '\' is taken');
      }
      _this.buttonsNames.push(buttonName);
      var button = _this.createButton(buttonConfig);
      _this.buttonElements.push(button);
      group.appendChild(button);
    });
    _this.element.appendChild(group);
  });
};

/**
 * Empty div for containing a group of buttons
 * @Return {HTMLelement}
 */
proto.createGroup = function () {
  var group = document.createElement('div');
  group.className = 'modebar-group';
  return group;
};

/**
 * Create a new button div and set constant and configurable attributes
 * @Param {object} config (see ./buttons.js for more info)
 * @Return {HTMLelement}
 */
proto.createButton = function (config) {
  var _this = this;
  var button = document.createElement('a');
  button.setAttribute('rel', 'tooltip');
  button.className = 'modebar-btn';
  var title = config.title;
  if (title === undefined) title = config.name;
  // for localization: allow title to be a callable that takes gd as arg
  else if (typeof title === 'function') title = title(this.graphInfo);
  if (title || title === 0) button.setAttribute('data-title', title);
  if (config.attr !== undefined) button.setAttribute('data-attr', config.attr);
  var val = config.val;
  if (val !== undefined) {
    if (typeof val === 'function') val = val(this.graphInfo);
    button.setAttribute('data-val', val);
  }
  var click = config.click;
  if (typeof click !== 'function') {
    throw new Error('must provide button \'click\' function in button config');
  } else {
    button.addEventListener('click', function (ev) {
      config.click(_this.graphInfo, ev);

      // only needed for 'hoverClosestGeo' which does not call relayout
      _this.updateActiveButton(ev.currentTarget);
    });
  }
  button.setAttribute('data-toggle', config.toggle || false);
  if (config.toggle) d3.select(button).classed('active', true);
  var icon = config.icon;
  if (typeof icon === 'function') {
    button.appendChild(icon());
  } else {
    button.appendChild(this.createIcon(icon || Icons.question));
  }
  button.setAttribute('data-gravity', config.gravity || 'n');
  return button;
};

/**
 * Add an icon to a button
 * @Param {object} thisIcon
 * @Param {number} thisIcon.width
 * @Param {string} thisIcon.path
 * @Param {string} thisIcon.color
 * @Return {HTMLelement}
 */
proto.createIcon = function (thisIcon) {
  var iconHeight = isNumeric(thisIcon.height) ? Number(thisIcon.height) : thisIcon.ascent - thisIcon.descent;
  var svgNS = 'http://www.w3.org/2000/svg';
  var icon;
  if (thisIcon.path) {
    icon = document.createElementNS(svgNS, 'svg');
    icon.setAttribute('viewBox', [0, 0, thisIcon.width, iconHeight].join(' '));
    icon.setAttribute('class', 'icon');
    var path = document.createElementNS(svgNS, 'path');
    path.setAttribute('d', thisIcon.path);
    if (thisIcon.transform) {
      path.setAttribute('transform', thisIcon.transform);
    } else if (thisIcon.ascent !== undefined) {
      // Legacy icon transform calculation
      path.setAttribute('transform', 'matrix(1 0 0 -1 0 ' + thisIcon.ascent + ')');
    }
    icon.appendChild(path);
  }
  if (thisIcon.svg) {
    var svgDoc = Parser.parseFromString(thisIcon.svg, 'application/xml');
    icon = svgDoc.childNodes[0];
  }
  icon.setAttribute('height', '1em');
  icon.setAttribute('width', '1em');
  return icon;
};

/**
 * Updates active button with attribute specified in layout
 * @Param {object} graphInfo plot object containing data and layout
 * @Return {HTMLelement}
 */
proto.updateActiveButton = function (buttonClicked) {
  var fullLayout = this.graphInfo._fullLayout;
  var dataAttrClicked = buttonClicked !== undefined ? buttonClicked.getAttribute('data-attr') : null;
  this.buttonElements.forEach(function (button) {
    var thisval = button.getAttribute('data-val') || true;
    var dataAttr = button.getAttribute('data-attr');
    var isToggleButton = button.getAttribute('data-toggle') === 'true';
    var button3 = d3.select(button);

    // Use 'data-toggle' and 'buttonClicked' to toggle buttons
    // that have no one-to-one equivalent in fullLayout
    if (isToggleButton) {
      if (dataAttr === dataAttrClicked) {
        button3.classed('active', !button3.classed('active'));
      }
    } else {
      var val = dataAttr === null ? dataAttr : Lib.nestedProperty(fullLayout, dataAttr).get();
      button3.classed('active', val === thisval);
    }
  });
};

/**
 * Check if modeBar is configured as button configuration argument
 *
 * @Param {object} buttons 2d array of grouped button config objects
 * @Return {boolean}
 */
proto.hasButtons = function (buttons) {
  var currentButtons = this.buttons;
  if (!currentButtons) return false;
  if (buttons.length !== currentButtons.length) return false;
  for (var i = 0; i < buttons.length; ++i) {
    if (buttons[i].length !== currentButtons[i].length) return false;
    for (var j = 0; j < buttons[i].length; j++) {
      if (buttons[i][j].name !== currentButtons[i][j].name) return false;
    }
  }
  return true;
};
function jsVersion(str) {
  return str + ' (v' + version + ')';
}

/**
 * @return {HTMLDivElement} The logo image wrapped in a group
 */
proto.getLogo = function () {
  var group = this.createGroup();
  var a = document.createElement('a');
  a.href = 'https://plotly.com/';
  a.target = '_blank';
  a.setAttribute('data-title', jsVersion(Lib._(this.graphInfo, 'Produced with Plotly.js')));
  a.className = 'modebar-btn plotlyjsicon modebar-btn--logo';
  a.appendChild(this.createIcon(Icons.newplotlylogo));
  group.appendChild(a);
  return group;
};
proto.removeAllButtons = function () {
  while (this.element.firstChild) {
    this.element.removeChild(this.element.firstChild);
  }
  this.hasLogo = false;
};
proto.destroy = function () {
  Lib.removeElement(this.container.querySelector('.modebar'));
  Lib.deleteRelatedStyleRule(this._uid);
};
function createModeBar(gd, buttons) {
  var fullLayout = gd._fullLayout;
  var modeBar = new ModeBar({
    graphInfo: gd,
    container: fullLayout._modebardiv.node(),
    buttons: buttons
  });
  if (fullLayout._privateplot) {
    d3.select(modeBar.element).append('span').classed('badge-private float--left', true).text('PRIVATE');
  }
  return modeBar;
}
module.exports = createModeBar;

/***/ }),

/***/ 7113:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var fontAttrs = __webpack_require__(1940);
var colorAttrs = __webpack_require__(2399);
var templatedArray = (__webpack_require__(4467).templatedArray);
var buttonAttrs = templatedArray('button', {
  visible: {
    valType: 'boolean',
    dflt: true,
    editType: 'plot'
  },
  step: {
    valType: 'enumerated',
    values: ['month', 'year', 'day', 'hour', 'minute', 'second', 'all'],
    dflt: 'month',
    editType: 'plot'
  },
  stepmode: {
    valType: 'enumerated',
    values: ['backward', 'todate'],
    dflt: 'backward',
    editType: 'plot'
  },
  count: {
    valType: 'number',
    min: 0,
    dflt: 1,
    editType: 'plot'
  },
  label: {
    valType: 'string',
    editType: 'plot'
  },
  editType: 'plot'
});
module.exports = {
  visible: {
    valType: 'boolean',
    editType: 'plot'
  },
  buttons: buttonAttrs,
  x: {
    valType: 'number',
    min: -2,
    max: 3,
    editType: 'plot'
  },
  xanchor: {
    valType: 'enumerated',
    values: ['auto', 'left', 'center', 'right'],
    dflt: 'left',
    editType: 'plot'
  },
  y: {
    valType: 'number',
    min: -2,
    max: 3,
    editType: 'plot'
  },
  yanchor: {
    valType: 'enumerated',
    values: ['auto', 'top', 'middle', 'bottom'],
    dflt: 'bottom',
    editType: 'plot'
  },
  font: fontAttrs({
    editType: 'plot'
  }),
  bgcolor: {
    valType: 'color',
    dflt: colorAttrs.lightLine,
    editType: 'plot'
  },
  activecolor: {
    valType: 'color',
    editType: 'plot'
  },
  bordercolor: {
    valType: 'color',
    dflt: colorAttrs.defaultLine,
    editType: 'plot'
  },
  borderwidth: {
    valType: 'number',
    min: 0,
    dflt: 0,
    editType: 'plot'
  },
  editType: 'plot'
};

/***/ }),

/***/ 9573:
/***/ (function(module) {

"use strict";


module.exports = {
  // 'y' position pad above counter axis domain
  yPad: 0.02,
  // minimum button width (regardless of text size)
  minButtonWidth: 30,
  // buttons rect radii
  rx: 3,
  ry: 3,
  // light fraction used to compute the 'activecolor' default
  lightAmount: 25,
  darkAmount: 10
};

/***/ }),

/***/ 8674:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Color = __webpack_require__(7901);
var Template = __webpack_require__(4467);
var handleArrayContainerDefaults = __webpack_require__(5501);
var attributes = __webpack_require__(7113);
var constants = __webpack_require__(9573);
module.exports = function handleDefaults(containerIn, containerOut, layout, counterAxes, calendar) {
  var selectorIn = containerIn.rangeselector || {};
  var selectorOut = Template.newContainer(containerOut, 'rangeselector');
  function coerce(attr, dflt) {
    return Lib.coerce(selectorIn, selectorOut, attributes, attr, dflt);
  }
  var buttons = handleArrayContainerDefaults(selectorIn, selectorOut, {
    name: 'buttons',
    handleItemDefaults: buttonDefaults,
    calendar: calendar
  });
  var visible = coerce('visible', buttons.length > 0);
  if (visible) {
    var posDflt = getPosDflt(containerOut, layout, counterAxes);
    coerce('x', posDflt[0]);
    coerce('y', posDflt[1]);
    Lib.noneOrAll(containerIn, containerOut, ['x', 'y']);
    coerce('xanchor');
    coerce('yanchor');
    Lib.coerceFont(coerce, 'font', layout.font);
    var bgColor = coerce('bgcolor');
    coerce('activecolor', Color.contrast(bgColor, constants.lightAmount, constants.darkAmount));
    coerce('bordercolor');
    coerce('borderwidth');
  }
};
function buttonDefaults(buttonIn, buttonOut, selectorOut, opts) {
  var calendar = opts.calendar;
  function coerce(attr, dflt) {
    return Lib.coerce(buttonIn, buttonOut, attributes.buttons, attr, dflt);
  }
  var visible = coerce('visible');
  if (visible) {
    var step = coerce('step');
    if (step !== 'all') {
      if (calendar && calendar !== 'gregorian' && (step === 'month' || step === 'year')) {
        buttonOut.stepmode = 'backward';
      } else {
        coerce('stepmode');
      }
      coerce('count');
    }
    coerce('label');
  }
}
function getPosDflt(containerOut, layout, counterAxes) {
  var anchoredList = counterAxes.filter(function (ax) {
    return layout[ax].anchor === containerOut._id;
  });
  var posY = 0;
  for (var i = 0; i < anchoredList.length; i++) {
    var domain = layout[anchoredList[i]].domain;
    if (domain) posY = Math.max(domain[1], posY);
  }
  return [containerOut.domain[0], posY + constants.yPad];
}

/***/ }),

/***/ 1598:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Registry = __webpack_require__(3972);
var Plots = __webpack_require__(4875);
var Color = __webpack_require__(7901);
var Drawing = __webpack_require__(1424);
var Lib = __webpack_require__(1828);
var strTranslate = Lib.strTranslate;
var svgTextUtils = __webpack_require__(3893);
var axisIds = __webpack_require__(1675);
var alignmentConstants = __webpack_require__(8783);
var LINE_SPACING = alignmentConstants.LINE_SPACING;
var FROM_TL = alignmentConstants.FROM_TL;
var FROM_BR = alignmentConstants.FROM_BR;
var constants = __webpack_require__(9573);
var getUpdateObject = __webpack_require__(7917);
module.exports = function draw(gd) {
  var fullLayout = gd._fullLayout;
  var selectors = fullLayout._infolayer.selectAll('.rangeselector').data(makeSelectorData(gd), selectorKeyFunc);
  selectors.enter().append('g').classed('rangeselector', true);
  selectors.exit().remove();
  selectors.style({
    cursor: 'pointer',
    'pointer-events': 'all'
  });
  selectors.each(function (d) {
    var selector = d3.select(this);
    var axisLayout = d;
    var selectorLayout = axisLayout.rangeselector;
    var buttons = selector.selectAll('g.button').data(Lib.filterVisible(selectorLayout.buttons));
    buttons.enter().append('g').classed('button', true);
    buttons.exit().remove();
    buttons.each(function (d) {
      var button = d3.select(this);
      var update = getUpdateObject(axisLayout, d);
      d._isActive = isActive(axisLayout, d, update);
      button.call(drawButtonRect, selectorLayout, d);
      button.call(drawButtonText, selectorLayout, d, gd);
      button.on('click', function () {
        if (gd._dragged) return;
        Registry.call('_guiRelayout', gd, update);
      });
      button.on('mouseover', function () {
        d._isHovered = true;
        button.call(drawButtonRect, selectorLayout, d);
      });
      button.on('mouseout', function () {
        d._isHovered = false;
        button.call(drawButtonRect, selectorLayout, d);
      });
    });
    reposition(gd, buttons, selectorLayout, axisLayout._name, selector);
  });
};
function makeSelectorData(gd) {
  var axes = axisIds.list(gd, 'x', true);
  var data = [];
  for (var i = 0; i < axes.length; i++) {
    var axis = axes[i];
    if (axis.rangeselector && axis.rangeselector.visible) {
      data.push(axis);
    }
  }
  return data;
}
function selectorKeyFunc(d) {
  return d._id;
}
function isActive(axisLayout, opts, update) {
  if (opts.step === 'all') {
    return axisLayout.autorange === true;
  } else {
    var keys = Object.keys(update);
    return axisLayout.range[0] === update[keys[0]] && axisLayout.range[1] === update[keys[1]];
  }
}
function drawButtonRect(button, selectorLayout, d) {
  var rect = Lib.ensureSingle(button, 'rect', 'selector-rect', function (s) {
    s.attr('shape-rendering', 'crispEdges');
  });
  rect.attr({
    rx: constants.rx,
    ry: constants.ry
  });
  rect.call(Color.stroke, selectorLayout.bordercolor).call(Color.fill, getFillColor(selectorLayout, d)).style('stroke-width', selectorLayout.borderwidth + 'px');
}
function getFillColor(selectorLayout, d) {
  return d._isActive || d._isHovered ? selectorLayout.activecolor : selectorLayout.bgcolor;
}
function drawButtonText(button, selectorLayout, d, gd) {
  function textLayout(s) {
    svgTextUtils.convertToTspans(s, gd);
  }
  var text = Lib.ensureSingle(button, 'text', 'selector-text', function (s) {
    s.attr('text-anchor', 'middle');
  });
  text.call(Drawing.font, selectorLayout.font).text(getLabel(d, gd._fullLayout._meta)).call(textLayout);
}
function getLabel(opts, _meta) {
  if (opts.label) {
    return _meta ? Lib.templateString(opts.label, _meta) : opts.label;
  }
  if (opts.step === 'all') return 'all';
  return opts.count + opts.step.charAt(0);
}
function reposition(gd, buttons, opts, axName, selector) {
  var width = 0;
  var height = 0;
  var borderWidth = opts.borderwidth;
  buttons.each(function () {
    var button = d3.select(this);
    var text = button.select('.selector-text');
    var tHeight = opts.font.size * LINE_SPACING;
    var hEff = Math.max(tHeight * svgTextUtils.lineCount(text), 16) + 3;
    height = Math.max(height, hEff);
  });
  buttons.each(function () {
    var button = d3.select(this);
    var rect = button.select('.selector-rect');
    var text = button.select('.selector-text');
    var tWidth = text.node() && Drawing.bBox(text.node()).width;
    var tHeight = opts.font.size * LINE_SPACING;
    var tLines = svgTextUtils.lineCount(text);
    var wEff = Math.max(tWidth + 10, constants.minButtonWidth);

    // TODO add MathJax support

    // TODO add buttongap attribute

    button.attr('transform', strTranslate(borderWidth + width, borderWidth));
    rect.attr({
      x: 0,
      y: 0,
      width: wEff,
      height: height
    });
    svgTextUtils.positionText(text, wEff / 2, height / 2 - (tLines - 1) * tHeight / 2 + 3);
    width += wEff + 5;
  });
  var graphSize = gd._fullLayout._size;
  var lx = graphSize.l + graphSize.w * opts.x;
  var ly = graphSize.t + graphSize.h * (1 - opts.y);
  var xanchor = 'left';
  if (Lib.isRightAnchor(opts)) {
    lx -= width;
    xanchor = 'right';
  }
  if (Lib.isCenterAnchor(opts)) {
    lx -= width / 2;
    xanchor = 'center';
  }
  var yanchor = 'top';
  if (Lib.isBottomAnchor(opts)) {
    ly -= height;
    yanchor = 'bottom';
  }
  if (Lib.isMiddleAnchor(opts)) {
    ly -= height / 2;
    yanchor = 'middle';
  }
  width = Math.ceil(width);
  height = Math.ceil(height);
  lx = Math.round(lx);
  ly = Math.round(ly);
  Plots.autoMargin(gd, axName + '-range-selector', {
    x: opts.x,
    y: opts.y,
    l: width * FROM_TL[xanchor],
    r: width * FROM_BR[xanchor],
    b: height * FROM_BR[yanchor],
    t: height * FROM_TL[yanchor]
  });
  selector.attr('transform', strTranslate(lx, ly));
}

/***/ }),

/***/ 7917:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3Time = __webpack_require__(1041);
var titleCase = (__webpack_require__(1828).titleCase);
module.exports = function getUpdateObject(axisLayout, buttonLayout) {
  var axName = axisLayout._name;
  var update = {};
  if (buttonLayout.step === 'all') {
    update[axName + '.autorange'] = true;
  } else {
    var xrange = getXRange(axisLayout, buttonLayout);
    update[axName + '.range[0]'] = xrange[0];
    update[axName + '.range[1]'] = xrange[1];
  }
  return update;
};
function getXRange(axisLayout, buttonLayout) {
  var currentRange = axisLayout.range;
  var base = new Date(axisLayout.r2l(currentRange[1]));
  var step = buttonLayout.step;
  var utcStep = d3Time['utc' + titleCase(step)];
  var count = buttonLayout.count;
  var range0;
  switch (buttonLayout.stepmode) {
    case 'backward':
      range0 = axisLayout.l2r(+utcStep.offset(base, -count));
      break;
    case 'todate':
      var base2 = utcStep.offset(base, -count);
      range0 = axisLayout.l2r(+utcStep.ceil(base2));
      break;
  }
  var range1 = currentRange[1];
  return [range0, range1];
}

/***/ }),

/***/ 7218:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  moduleType: 'component',
  name: 'rangeselector',
  schema: {
    subplots: {
      xaxis: {
        rangeselector: __webpack_require__(7113)
      }
    }
  },
  layoutAttributes: __webpack_require__(7113),
  handleDefaults: __webpack_require__(8674),
  draw: __webpack_require__(1598)
};

/***/ }),

/***/ 5148:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var colorAttributes = __webpack_require__(2399);
module.exports = {
  bgcolor: {
    valType: 'color',
    dflt: colorAttributes.background,
    editType: 'plot'
  },
  bordercolor: {
    valType: 'color',
    dflt: colorAttributes.defaultLine,
    editType: 'plot'
  },
  borderwidth: {
    valType: 'integer',
    dflt: 0,
    min: 0,
    editType: 'plot'
  },
  autorange: {
    valType: 'boolean',
    dflt: true,
    editType: 'calc',
    impliedEdits: {
      'range[0]': undefined,
      'range[1]': undefined
    }
  },
  range: {
    valType: 'info_array',
    items: [{
      valType: 'any',
      editType: 'calc',
      impliedEdits: {
        '^autorange': false
      }
    }, {
      valType: 'any',
      editType: 'calc',
      impliedEdits: {
        '^autorange': false
      }
    }],
    editType: 'calc',
    impliedEdits: {
      autorange: false
    }
  },
  thickness: {
    valType: 'number',
    dflt: 0.15,
    min: 0,
    max: 1,
    editType: 'plot'
  },
  visible: {
    valType: 'boolean',
    dflt: true,
    editType: 'calc'
  },
  editType: 'calc'
};

/***/ }),

/***/ 8443:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var listAxes = (__webpack_require__(1675).list);
var getAutoRange = (__webpack_require__(1739).getAutoRange);
var constants = __webpack_require__(3251);
module.exports = function calcAutorange(gd) {
  var axes = listAxes(gd, 'x', true);

  // Compute new slider range using axis autorange if necessary.
  //
  // Copy back range to input range slider container to skip
  // this step in subsequent draw calls.

  for (var i = 0; i < axes.length; i++) {
    var ax = axes[i];
    var opts = ax[constants.name];
    if (opts && opts.visible && opts.autorange) {
      opts._input.autorange = true;
      opts._input.range = opts.range = getAutoRange(gd, ax);
    }
  }
};

/***/ }),

/***/ 3251:
/***/ (function(module) {

"use strict";


module.exports = {
  // attribute container name
  name: 'rangeslider',
  // class names

  containerClassName: 'rangeslider-container',
  bgClassName: 'rangeslider-bg',
  rangePlotClassName: 'rangeslider-rangeplot',
  maskMinClassName: 'rangeslider-mask-min',
  maskMaxClassName: 'rangeslider-mask-max',
  slideBoxClassName: 'rangeslider-slidebox',
  grabberMinClassName: 'rangeslider-grabber-min',
  grabAreaMinClassName: 'rangeslider-grabarea-min',
  handleMinClassName: 'rangeslider-handle-min',
  grabberMaxClassName: 'rangeslider-grabber-max',
  grabAreaMaxClassName: 'rangeslider-grabarea-max',
  handleMaxClassName: 'rangeslider-handle-max',
  maskMinOppAxisClassName: 'rangeslider-mask-min-opp-axis',
  maskMaxOppAxisClassName: 'rangeslider-mask-max-opp-axis',
  // style constants

  maskColor: 'rgba(0,0,0,0.4)',
  maskOppAxisColor: 'rgba(0,0,0,0.2)',
  slideBoxFill: 'transparent',
  slideBoxCursor: 'ew-resize',
  grabAreaFill: 'transparent',
  grabAreaCursor: 'col-resize',
  grabAreaWidth: 10,
  handleWidth: 4,
  handleRadius: 1,
  handleStrokeWidth: 1,
  extraPad: 15
};

/***/ }),

/***/ 6377:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Template = __webpack_require__(4467);
var axisIds = __webpack_require__(1675);
var attributes = __webpack_require__(5148);
var oppAxisAttrs = __webpack_require__(7850);
module.exports = function handleDefaults(layoutIn, layoutOut, axName) {
  var axIn = layoutIn[axName];
  var axOut = layoutOut[axName];
  if (!(axIn.rangeslider || layoutOut._requestRangeslider[axOut._id])) return;

  // not super proud of this (maybe store _ in axis object instead
  if (!Lib.isPlainObject(axIn.rangeslider)) {
    axIn.rangeslider = {};
  }
  var containerIn = axIn.rangeslider;
  var containerOut = Template.newContainer(axOut, 'rangeslider');
  function coerce(attr, dflt) {
    return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
  }
  var rangeContainerIn, rangeContainerOut;
  function coerceRange(attr, dflt) {
    return Lib.coerce(rangeContainerIn, rangeContainerOut, oppAxisAttrs, attr, dflt);
  }
  var visible = coerce('visible');
  if (!visible) return;
  coerce('bgcolor', layoutOut.plot_bgcolor);
  coerce('bordercolor');
  coerce('borderwidth');
  coerce('thickness');
  coerce('autorange', !axOut.isValidRange(containerIn.range));
  coerce('range');
  var subplots = layoutOut._subplots;
  if (subplots) {
    var yIds = subplots.cartesian.filter(function (subplotId) {
      return subplotId.substr(0, subplotId.indexOf('y')) === axisIds.name2id(axName);
    }).map(function (subplotId) {
      return subplotId.substr(subplotId.indexOf('y'), subplotId.length);
    });
    var yNames = Lib.simpleMap(yIds, axisIds.id2name);
    for (var i = 0; i < yNames.length; i++) {
      var yName = yNames[i];
      rangeContainerIn = containerIn[yName] || {};
      rangeContainerOut = Template.newContainer(containerOut, yName, 'yaxis');
      var yAxOut = layoutOut[yName];
      var rangemodeDflt;
      if (rangeContainerIn.range && yAxOut.isValidRange(rangeContainerIn.range)) {
        rangemodeDflt = 'fixed';
      }
      var rangeMode = coerceRange('rangemode', rangemodeDflt);
      if (rangeMode !== 'match') {
        coerceRange('range', yAxOut.range.slice());
      }
    }
  }

  // to map back range slider (auto) range
  containerOut._input = containerIn;
};

/***/ }),

/***/ 2413:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Registry = __webpack_require__(3972);
var Plots = __webpack_require__(4875);
var Lib = __webpack_require__(1828);
var strTranslate = Lib.strTranslate;
var Drawing = __webpack_require__(1424);
var Color = __webpack_require__(7901);
var Titles = __webpack_require__(2998);
var Cartesian = __webpack_require__(3612);
var axisIDs = __webpack_require__(1675);
var dragElement = __webpack_require__(8569);
var setCursor = __webpack_require__(6964);
var constants = __webpack_require__(3251);
module.exports = function (gd) {
  var fullLayout = gd._fullLayout;
  var rangeSliderData = fullLayout._rangeSliderData;
  for (var i = 0; i < rangeSliderData.length; i++) {
    var opts = rangeSliderData[i][constants.name];
    // fullLayout._uid may not exist when we call makeData
    opts._clipId = opts._id + '-' + fullLayout._uid;
  }

  /*
   * <g container />
   *  <rect bg />
   *  < .... range plot />
   *  <rect mask-min />
   *  <rect mask-max />
   *  <rect slidebox />
   *  <g grabber-min />
   *      <rect handle-min />
   *      <rect grabare-min />
   *  <g grabber-max />
   *      <rect handle-max />
   *      <rect grabare-max />
   *
   *  ...
   */

  function keyFunction(axisOpts) {
    return axisOpts._name;
  }
  var rangeSliders = fullLayout._infolayer.selectAll('g.' + constants.containerClassName).data(rangeSliderData, keyFunction);

  // remove exiting sliders and their corresponding clip paths
  rangeSliders.exit().each(function (axisOpts) {
    var opts = axisOpts[constants.name];
    fullLayout._topdefs.select('#' + opts._clipId).remove();
  }).remove();

  // return early if no range slider is visible
  if (rangeSliderData.length === 0) return;
  rangeSliders.enter().append('g').classed(constants.containerClassName, true).attr('pointer-events', 'all');

  // for all present range sliders
  rangeSliders.each(function (axisOpts) {
    var rangeSlider = d3.select(this);
    var opts = axisOpts[constants.name];
    var oppAxisOpts = fullLayout[axisIDs.id2name(axisOpts.anchor)];
    var oppAxisRangeOpts = opts[axisIDs.id2name(axisOpts.anchor)];

    // update range
    // Expand slider range to the axis range
    if (opts.range) {
      var rng = Lib.simpleMap(opts.range, axisOpts.r2l);
      var axRng = Lib.simpleMap(axisOpts.range, axisOpts.r2l);
      var newRng;
      if (axRng[0] < axRng[1]) {
        newRng = [Math.min(rng[0], axRng[0]), Math.max(rng[1], axRng[1])];
      } else {
        newRng = [Math.max(rng[0], axRng[0]), Math.min(rng[1], axRng[1])];
      }
      opts.range = opts._input.range = Lib.simpleMap(newRng, axisOpts.l2r);
    }
    axisOpts.cleanRange('rangeslider.range');

    // update range slider dimensions

    var gs = fullLayout._size;
    var domain = axisOpts.domain;
    opts._width = gs.w * (domain[1] - domain[0]);
    var x = Math.round(gs.l + gs.w * domain[0]);
    var y = Math.round(gs.t + gs.h * (1 - axisOpts._counterDomainMin) + (axisOpts.side === 'bottom' ? axisOpts._depth : 0) + opts._offsetShift + constants.extraPad);
    rangeSlider.attr('transform', strTranslate(x, y));

    // update data <--> pixel coordinate conversion methods

    opts._rl = Lib.simpleMap(opts.range, axisOpts.r2l);
    var rl0 = opts._rl[0];
    var rl1 = opts._rl[1];
    var drl = rl1 - rl0;
    opts.p2d = function (v) {
      return v / opts._width * drl + rl0;
    };
    opts.d2p = function (v) {
      return (v - rl0) / drl * opts._width;
    };
    if (axisOpts.rangebreaks) {
      var rsBreaks = axisOpts.locateBreaks(rl0, rl1);
      if (rsBreaks.length) {
        var j, brk;
        var lBreaks = 0;
        for (j = 0; j < rsBreaks.length; j++) {
          brk = rsBreaks[j];
          lBreaks += brk.max - brk.min;
        }

        // TODO fix for reversed-range axes !!!

        // compute slope and piecewise offsets
        var m2 = opts._width / (rl1 - rl0 - lBreaks);
        var _B = [-m2 * rl0];
        for (j = 0; j < rsBreaks.length; j++) {
          brk = rsBreaks[j];
          _B.push(_B[_B.length - 1] - m2 * (brk.max - brk.min));
        }
        opts.d2p = function (v) {
          var b = _B[0];
          for (var j = 0; j < rsBreaks.length; j++) {
            var brk = rsBreaks[j];
            if (v >= brk.max) b = _B[j + 1];else if (v < brk.min) break;
          }
          return b + m2 * v;
        };

        // fill pixel (i.e. 'p') min/max here,
        // to not have to loop through the _rangebreaks twice during `p2d`
        for (j = 0; j < rsBreaks.length; j++) {
          brk = rsBreaks[j];
          brk.pmin = opts.d2p(brk.min);
          brk.pmax = opts.d2p(brk.max);
        }
        opts.p2d = function (v) {
          var b = _B[0];
          for (var j = 0; j < rsBreaks.length; j++) {
            var brk = rsBreaks[j];
            if (v >= brk.pmax) b = _B[j + 1];else if (v < brk.pmin) break;
          }
          return (v - b) / m2;
        };
      }
    }
    if (oppAxisRangeOpts.rangemode !== 'match') {
      var range0OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[0]);
      var range1OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[1]);
      var distOppAxis = range1OppAxis - range0OppAxis;
      opts.d2pOppAxis = function (v) {
        return (v - range0OppAxis) / distOppAxis * opts._height;
      };
    }

    // update inner nodes

    rangeSlider.call(drawBg, gd, axisOpts, opts).call(addClipPath, gd, axisOpts, opts).call(drawRangePlot, gd, axisOpts, opts).call(drawMasks, gd, axisOpts, opts, oppAxisRangeOpts).call(drawSlideBox, gd, axisOpts, opts).call(drawGrabbers, gd, axisOpts, opts);

    // setup drag element
    setupDragElement(rangeSlider, gd, axisOpts, opts);

    // update current range
    setPixelRange(rangeSlider, gd, axisOpts, opts, oppAxisOpts, oppAxisRangeOpts);

    // title goes next to range slider instead of tick labels, so
    // just take it over and draw it from here
    if (axisOpts.side === 'bottom') {
      Titles.draw(gd, axisOpts._id + 'title', {
        propContainer: axisOpts,
        propName: axisOpts._name + '.title',
        placeholder: fullLayout._dfltTitle.x,
        attributes: {
          x: axisOpts._offset + axisOpts._length / 2,
          y: y + opts._height + opts._offsetShift + 10 + 1.5 * axisOpts.title.font.size,
          'text-anchor': 'middle'
        }
      });
    }
  });
};
function setupDragElement(rangeSlider, gd, axisOpts, opts) {
  if (gd._context.staticPlot) return;
  var slideBox = rangeSlider.select('rect.' + constants.slideBoxClassName).node();
  var grabAreaMin = rangeSlider.select('rect.' + constants.grabAreaMinClassName).node();
  var grabAreaMax = rangeSlider.select('rect.' + constants.grabAreaMaxClassName).node();
  function mouseDownHandler() {
    var event = d3.event;
    var target = event.target;
    var startX = event.clientX || event.touches[0].clientX;
    var offsetX = startX - rangeSlider.node().getBoundingClientRect().left;
    var minVal = opts.d2p(axisOpts._rl[0]);
    var maxVal = opts.d2p(axisOpts._rl[1]);
    var dragCover = dragElement.coverSlip();
    this.addEventListener('touchmove', mouseMove);
    this.addEventListener('touchend', mouseUp);
    dragCover.addEventListener('mousemove', mouseMove);
    dragCover.addEventListener('mouseup', mouseUp);
    function mouseMove(e) {
      var clientX = e.clientX || e.touches[0].clientX;
      var delta = +clientX - startX;
      var pixelMin, pixelMax, cursor;
      switch (target) {
        case slideBox:
          cursor = 'ew-resize';
          if (minVal + delta > axisOpts._length || maxVal + delta < 0) {
            return;
          }
          pixelMin = minVal + delta;
          pixelMax = maxVal + delta;
          break;
        case grabAreaMin:
          cursor = 'col-resize';
          if (minVal + delta > axisOpts._length) {
            return;
          }
          pixelMin = minVal + delta;
          pixelMax = maxVal;
          break;
        case grabAreaMax:
          cursor = 'col-resize';
          if (maxVal + delta < 0) {
            return;
          }
          pixelMin = minVal;
          pixelMax = maxVal + delta;
          break;
        default:
          cursor = 'ew-resize';
          pixelMin = offsetX;
          pixelMax = offsetX + delta;
          break;
      }
      if (pixelMax < pixelMin) {
        var tmp = pixelMax;
        pixelMax = pixelMin;
        pixelMin = tmp;
      }
      opts._pixelMin = pixelMin;
      opts._pixelMax = pixelMax;
      setCursor(d3.select(dragCover), cursor);
      setDataRange(rangeSlider, gd, axisOpts, opts);
    }
    function mouseUp() {
      dragCover.removeEventListener('mousemove', mouseMove);
      dragCover.removeEventListener('mouseup', mouseUp);
      this.removeEventListener('touchmove', mouseMove);
      this.removeEventListener('touchend', mouseUp);
      Lib.removeElement(dragCover);
    }
  }
  rangeSlider.on('mousedown', mouseDownHandler);
  rangeSlider.on('touchstart', mouseDownHandler);
}
function setDataRange(rangeSlider, gd, axisOpts, opts) {
  function clamp(v) {
    return axisOpts.l2r(Lib.constrain(v, opts._rl[0], opts._rl[1]));
  }
  var dataMin = clamp(opts.p2d(opts._pixelMin));
  var dataMax = clamp(opts.p2d(opts._pixelMax));
  window.requestAnimationFrame(function () {
    Registry.call('_guiRelayout', gd, axisOpts._name + '.range', [dataMin, dataMax]);
  });
}
function setPixelRange(rangeSlider, gd, axisOpts, opts, oppAxisOpts, oppAxisRangeOpts) {
  var hw2 = constants.handleWidth / 2;
  function clamp(v) {
    return Lib.constrain(v, 0, opts._width);
  }
  function clampOppAxis(v) {
    return Lib.constrain(v, 0, opts._height);
  }
  function clampHandle(v) {
    return Lib.constrain(v, -hw2, opts._width + hw2);
  }
  var pixelMin = clamp(opts.d2p(axisOpts._rl[0]));
  var pixelMax = clamp(opts.d2p(axisOpts._rl[1]));
  rangeSlider.select('rect.' + constants.slideBoxClassName).attr('x', pixelMin).attr('width', pixelMax - pixelMin);
  rangeSlider.select('rect.' + constants.maskMinClassName).attr('width', pixelMin);
  rangeSlider.select('rect.' + constants.maskMaxClassName).attr('x', pixelMax).attr('width', opts._width - pixelMax);
  if (oppAxisRangeOpts.rangemode !== 'match') {
    var pixelMinOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[1]));
    var pixelMaxOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[0]));
    rangeSlider.select('rect.' + constants.maskMinOppAxisClassName).attr('x', pixelMin).attr('height', pixelMinOppAxis).attr('width', pixelMax - pixelMin);
    rangeSlider.select('rect.' + constants.maskMaxOppAxisClassName).attr('x', pixelMin).attr('y', pixelMaxOppAxis).attr('height', opts._height - pixelMaxOppAxis).attr('width', pixelMax - pixelMin);
    rangeSlider.select('rect.' + constants.slideBoxClassName).attr('y', pixelMinOppAxis).attr('height', pixelMaxOppAxis - pixelMinOppAxis);
  }

  // add offset for crispier corners
  // https://github.com/plotly/plotly.js/pull/1409
  var offset = 0.5;
  var xMin = Math.round(clampHandle(pixelMin - hw2)) - offset;
  var xMax = Math.round(clampHandle(pixelMax - hw2)) + offset;
  rangeSlider.select('g.' + constants.grabberMinClassName).attr('transform', strTranslate(xMin, offset));
  rangeSlider.select('g.' + constants.grabberMaxClassName).attr('transform', strTranslate(xMax, offset));
}
function drawBg(rangeSlider, gd, axisOpts, opts) {
  var bg = Lib.ensureSingle(rangeSlider, 'rect', constants.bgClassName, function (s) {
    s.attr({
      x: 0,
      y: 0,
      'shape-rendering': 'crispEdges'
    });
  });
  var borderCorrect = opts.borderwidth % 2 === 0 ? opts.borderwidth : opts.borderwidth - 1;
  var offsetShift = -opts._offsetShift;
  var lw = Drawing.crispRound(gd, opts.borderwidth);
  bg.attr({
    width: opts._width + borderCorrect,
    height: opts._height + borderCorrect,
    transform: strTranslate(offsetShift, offsetShift),
    'stroke-width': lw
  }).call(Color.stroke, opts.bordercolor).call(Color.fill, opts.bgcolor);
}
function addClipPath(rangeSlider, gd, axisOpts, opts) {
  var fullLayout = gd._fullLayout;
  var clipPath = Lib.ensureSingleById(fullLayout._topdefs, 'clipPath', opts._clipId, function (s) {
    s.append('rect').attr({
      x: 0,
      y: 0
    });
  });
  clipPath.select('rect').attr({
    width: opts._width,
    height: opts._height
  });
}
function drawRangePlot(rangeSlider, gd, axisOpts, opts) {
  var calcData = gd.calcdata;
  var rangePlots = rangeSlider.selectAll('g.' + constants.rangePlotClassName).data(axisOpts._subplotsWith, Lib.identity);
  rangePlots.enter().append('g').attr('class', function (id) {
    return constants.rangePlotClassName + ' ' + id;
  }).call(Drawing.setClipUrl, opts._clipId, gd);
  rangePlots.order();
  rangePlots.exit().remove();
  var mainplotinfo;
  rangePlots.each(function (id, i) {
    var plotgroup = d3.select(this);
    var isMainPlot = i === 0;
    var oppAxisOpts = axisIDs.getFromId(gd, id, 'y');
    var oppAxisName = oppAxisOpts._name;
    var oppAxisRangeOpts = opts[oppAxisName];
    var mockFigure = {
      data: [],
      layout: {
        xaxis: {
          type: axisOpts.type,
          domain: [0, 1],
          range: opts.range.slice(),
          calendar: axisOpts.calendar
        },
        width: opts._width,
        height: opts._height,
        margin: {
          t: 0,
          b: 0,
          l: 0,
          r: 0
        }
      },
      _context: gd._context
    };
    if (axisOpts.rangebreaks) {
      mockFigure.layout.xaxis.rangebreaks = axisOpts.rangebreaks;
    }
    mockFigure.layout[oppAxisName] = {
      type: oppAxisOpts.type,
      domain: [0, 1],
      range: oppAxisRangeOpts.rangemode !== 'match' ? oppAxisRangeOpts.range.slice() : oppAxisOpts.range.slice(),
      calendar: oppAxisOpts.calendar
    };
    if (oppAxisOpts.rangebreaks) {
      mockFigure.layout[oppAxisName].rangebreaks = oppAxisOpts.rangebreaks;
    }
    Plots.supplyDefaults(mockFigure);
    var xa = mockFigure._fullLayout.xaxis;
    var ya = mockFigure._fullLayout[oppAxisName];
    xa.clearCalc();
    xa.setScale();
    ya.clearCalc();
    ya.setScale();
    var plotinfo = {
      id: id,
      plotgroup: plotgroup,
      xaxis: xa,
      yaxis: ya,
      isRangePlot: true
    };
    if (isMainPlot) mainplotinfo = plotinfo;else {
      plotinfo.mainplot = 'xy';
      plotinfo.mainplotinfo = mainplotinfo;
    }
    Cartesian.rangePlot(gd, plotinfo, filterRangePlotCalcData(calcData, id));
  });
}
function filterRangePlotCalcData(calcData, subplotId) {
  var out = [];
  for (var i = 0; i < calcData.length; i++) {
    var calcTrace = calcData[i];
    var trace = calcTrace[0].trace;
    if (trace.xaxis + trace.yaxis === subplotId) {
      out.push(calcTrace);
    }
  }
  return out;
}
function drawMasks(rangeSlider, gd, axisOpts, opts, oppAxisRangeOpts) {
  var maskMin = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMinClassName, function (s) {
    s.attr({
      x: 0,
      y: 0,
      'shape-rendering': 'crispEdges'
    });
  });
  maskMin.attr('height', opts._height).call(Color.fill, constants.maskColor);
  var maskMax = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMaxClassName, function (s) {
    s.attr({
      y: 0,
      'shape-rendering': 'crispEdges'
    });
  });
  maskMax.attr('height', opts._height).call(Color.fill, constants.maskColor);

  // masks used for oppAxis zoom
  if (oppAxisRangeOpts.rangemode !== 'match') {
    var maskMinOppAxis = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMinOppAxisClassName, function (s) {
      s.attr({
        y: 0,
        'shape-rendering': 'crispEdges'
      });
    });
    maskMinOppAxis.attr('width', opts._width).call(Color.fill, constants.maskOppAxisColor);
    var maskMaxOppAxis = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMaxOppAxisClassName, function (s) {
      s.attr({
        y: 0,
        'shape-rendering': 'crispEdges'
      });
    });
    maskMaxOppAxis.attr('width', opts._width).style('border-top', constants.maskOppBorder).call(Color.fill, constants.maskOppAxisColor);
  }
}
function drawSlideBox(rangeSlider, gd, axisOpts, opts) {
  if (gd._context.staticPlot) return;
  var slideBox = Lib.ensureSingle(rangeSlider, 'rect', constants.slideBoxClassName, function (s) {
    s.attr({
      y: 0,
      cursor: constants.slideBoxCursor,
      'shape-rendering': 'crispEdges'
    });
  });
  slideBox.attr({
    height: opts._height,
    fill: constants.slideBoxFill
  });
}
function drawGrabbers(rangeSlider, gd, axisOpts, opts) {
  // <g grabber />
  var grabberMin = Lib.ensureSingle(rangeSlider, 'g', constants.grabberMinClassName);
  var grabberMax = Lib.ensureSingle(rangeSlider, 'g', constants.grabberMaxClassName);

  // <g handle />
  var handleFixAttrs = {
    x: 0,
    width: constants.handleWidth,
    rx: constants.handleRadius,
    fill: Color.background,
    stroke: Color.defaultLine,
    'stroke-width': constants.handleStrokeWidth,
    'shape-rendering': 'crispEdges'
  };
  var handleDynamicAttrs = {
    y: Math.round(opts._height / 4),
    height: Math.round(opts._height / 2)
  };
  var handleMin = Lib.ensureSingle(grabberMin, 'rect', constants.handleMinClassName, function (s) {
    s.attr(handleFixAttrs);
  });
  handleMin.attr(handleDynamicAttrs);
  var handleMax = Lib.ensureSingle(grabberMax, 'rect', constants.handleMaxClassName, function (s) {
    s.attr(handleFixAttrs);
  });
  handleMax.attr(handleDynamicAttrs);

  // <g grabarea />
  var grabAreaFixAttrs = {
    width: constants.grabAreaWidth,
    x: 0,
    y: 0,
    fill: constants.grabAreaFill,
    cursor: !gd._context.staticPlot ? constants.grabAreaCursor : undefined
  };
  var grabAreaMin = Lib.ensureSingle(grabberMin, 'rect', constants.grabAreaMinClassName, function (s) {
    s.attr(grabAreaFixAttrs);
  });
  grabAreaMin.attr('height', opts._height);
  var grabAreaMax = Lib.ensureSingle(grabberMax, 'rect', constants.grabAreaMaxClassName, function (s) {
    s.attr(grabAreaFixAttrs);
  });
  grabAreaMax.attr('height', opts._height);
}

/***/ }),

/***/ 549:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var axisIDs = __webpack_require__(1675);
var svgTextUtils = __webpack_require__(3893);
var constants = __webpack_require__(3251);
var LINE_SPACING = (__webpack_require__(8783).LINE_SPACING);
var name = constants.name;
function isVisible(ax) {
  var rangeSlider = ax && ax[name];
  return rangeSlider && rangeSlider.visible;
}
exports.isVisible = isVisible;
exports.makeData = function (fullLayout) {
  var axes = axisIDs.list({
    _fullLayout: fullLayout
  }, 'x', true);
  var margin = fullLayout.margin;
  var rangeSliderData = [];
  if (!fullLayout._has('gl2d')) {
    for (var i = 0; i < axes.length; i++) {
      var ax = axes[i];
      if (isVisible(ax)) {
        rangeSliderData.push(ax);
        var opts = ax[name];
        opts._id = name + ax._id;
        opts._height = (fullLayout.height - margin.b - margin.t) * opts.thickness;
        opts._offsetShift = Math.floor(opts.borderwidth / 2);
      }
    }
  }
  fullLayout._rangeSliderData = rangeSliderData;
};
exports.autoMarginOpts = function (gd, ax) {
  var fullLayout = gd._fullLayout;
  var opts = ax[name];
  var axLetter = ax._id.charAt(0);
  var bottomDepth = 0;
  var titleHeight = 0;
  if (ax.side === 'bottom') {
    bottomDepth = ax._depth;
    if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {
      // as in rangeslider/draw.js
      titleHeight = 1.5 * ax.title.font.size + 10 + opts._offsetShift;
      // multi-line extra bump
      var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;
      titleHeight += extraLines * ax.title.font.size * LINE_SPACING;
    }
  }
  return {
    x: 0,
    y: ax._counterDomainMin,
    l: 0,
    r: 0,
    t: 0,
    b: opts._height + bottomDepth + Math.max(fullLayout.margin.b, titleHeight),
    pad: constants.extraPad + opts._offsetShift * 2
  };
};

/***/ }),

/***/ 3137:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var attrs = __webpack_require__(5148);
var oppAxisAttrs = __webpack_require__(7850);
var helpers = __webpack_require__(549);
module.exports = {
  moduleType: 'component',
  name: 'rangeslider',
  schema: {
    subplots: {
      xaxis: {
        rangeslider: Lib.extendFlat({}, attrs, {
          yaxis: oppAxisAttrs
        })
      }
    }
  },
  layoutAttributes: __webpack_require__(5148),
  handleDefaults: __webpack_require__(6377),
  calcAutorange: __webpack_require__(8443),
  draw: __webpack_require__(2413),
  isVisible: helpers.isVisible,
  makeData: helpers.makeData,
  autoMarginOpts: helpers.autoMarginOpts
};

/***/ }),

/***/ 7850:
/***/ (function(module) {

"use strict";


module.exports = {
  // not really a 'subplot' attribute container,
  // but this is the flag we use to denote attributes that
  // support yaxis, yaxis2, yaxis3, ... counters
  _isSubplotObj: true,
  rangemode: {
    valType: 'enumerated',
    values: ['auto', 'fixed', 'match'],
    dflt: 'match',
    editType: 'calc'
  },
  range: {
    valType: 'info_array',
    items: [{
      valType: 'any',
      editType: 'plot'
    }, {
      valType: 'any',
      editType: 'plot'
    }],
    editType: 'plot'
  },
  editType: 'calc'
};

/***/ }),

/***/ 8389:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var annAttrs = __webpack_require__(215);
var scatterLineAttrs = (__webpack_require__(2196).line);
var dash = (__webpack_require__(9952)/* .dash */ .P);
var extendFlat = (__webpack_require__(1426).extendFlat);
var overrideAll = (__webpack_require__(962).overrideAll);
var templatedArray = (__webpack_require__(4467).templatedArray);
var axisPlaceableObjs = __webpack_require__(4695);
module.exports = overrideAll(templatedArray('selection', {
  type: {
    valType: 'enumerated',
    values: ['rect', 'path']
  },
  xref: extendFlat({}, annAttrs.xref, {}),
  yref: extendFlat({}, annAttrs.yref, {}),
  x0: {
    valType: 'any'
  },
  x1: {
    valType: 'any'
  },
  y0: {
    valType: 'any'
  },
  y1: {
    valType: 'any'
  },
  path: {
    valType: 'string',
    editType: 'arraydraw'
  },
  opacity: {
    valType: 'number',
    min: 0,
    max: 1,
    dflt: 0.7,
    editType: 'arraydraw'
  },
  line: {
    color: scatterLineAttrs.color,
    width: extendFlat({}, scatterLineAttrs.width, {
      min: 1,
      dflt: 1
    }),
    dash: extendFlat({}, dash, {
      dflt: 'dot'
    })
  }
}), 'arraydraw', 'from-root');

/***/ }),

/***/ 4122:
/***/ (function(module) {

"use strict";


module.exports = {
  // max pixels off straight before a lasso select line counts as bent
  BENDPX: 1.5,
  // smallest dimension allowed for a select box
  MINSELECT: 12,
  // throttling limit (ms) for selectPoints calls
  SELECTDELAY: 100,
  // cache ID suffix for throttle
  SELECTID: '-select'
};

/***/ }),

/***/ 9402:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Axes = __webpack_require__(9298);
var handleArrayContainerDefaults = __webpack_require__(5501);
var attributes = __webpack_require__(8389);
var helpers = __webpack_require__(477);
module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
  handleArrayContainerDefaults(layoutIn, layoutOut, {
    name: 'selections',
    handleItemDefaults: handleSelectionDefaults
  });

  // Drop rect selections with undefined x0, y0, x1, x1 values.
  // In future we may accept partially defined rects e.g.
  // a case with only x0 and x1 may be used to define
  // [-Infinity, +Infinity] range on the y axis, etc.
  var selections = layoutOut.selections;
  for (var i = 0; i < selections.length; i++) {
    var selection = selections[i];
    if (!selection) continue;
    if (selection.path === undefined) {
      if (selection.x0 === undefined || selection.x1 === undefined || selection.y0 === undefined || selection.y1 === undefined) {
        layoutOut.selections[i] = null;
      }
    }
  }
};
function handleSelectionDefaults(selectionIn, selectionOut, fullLayout) {
  function coerce(attr, dflt) {
    return Lib.coerce(selectionIn, selectionOut, attributes, attr, dflt);
  }
  var path = coerce('path');
  var dfltType = path ? 'path' : 'rect';
  var selectionType = coerce('type', dfltType);
  var noPath = selectionType !== 'path';
  if (noPath) delete selectionOut.path;
  coerce('opacity');
  coerce('line.color');
  coerce('line.width');
  coerce('line.dash');

  // positioning
  var axLetters = ['x', 'y'];
  for (var i = 0; i < 2; i++) {
    var axLetter = axLetters[i];
    var gdMock = {
      _fullLayout: fullLayout
    };
    var ax;
    var pos2r;
    var r2pos;

    // xref, yref
    var axRef = Axes.coerceRef(selectionIn, selectionOut, gdMock, axLetter);

    // axRefType is 'range' for selections
    ax = Axes.getFromId(gdMock, axRef);
    ax._selectionIndices.push(selectionOut._index);
    r2pos = helpers.rangeToShapePosition(ax);
    pos2r = helpers.shapePositionToRange(ax);

    // Coerce x0, x1, y0, y1
    if (noPath) {
      // hack until V3.0 when log has regular range behavior - make it look like other
      // ranges to send to coerce, then put it back after
      // this is all to give reasonable default position behavior on log axes, which is
      // a pretty unimportant edge case so we could just ignore this.
      var attr0 = axLetter + '0';
      var attr1 = axLetter + '1';
      var in0 = selectionIn[attr0];
      var in1 = selectionIn[attr1];
      selectionIn[attr0] = pos2r(selectionIn[attr0], true);
      selectionIn[attr1] = pos2r(selectionIn[attr1], true);
      Axes.coercePosition(selectionOut, gdMock, coerce, axRef, attr0);
      Axes.coercePosition(selectionOut, gdMock, coerce, axRef, attr1);
      var p0 = selectionOut[attr0];
      var p1 = selectionOut[attr1];
      if (p0 !== undefined && p1 !== undefined) {
        // hack part 2
        selectionOut[attr0] = r2pos(p0);
        selectionOut[attr1] = r2pos(p1);
        selectionIn[attr0] = in0;
        selectionIn[attr1] = in1;
      }
    }
  }
  if (noPath) {
    Lib.noneOrAll(selectionIn, selectionOut, ['x0', 'x1', 'y0', 'y1']);
  }
}

/***/ }),

/***/ 2485:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var readPaths = (__webpack_require__(165).readPaths);
var displayOutlines = __webpack_require__(2359);
var clearOutlineControllers = (__webpack_require__(1873).clearOutlineControllers);
var Color = __webpack_require__(7901);
var Drawing = __webpack_require__(1424);
var arrayEditor = (__webpack_require__(4467).arrayEditor);
var helpers = __webpack_require__(477);
var getPathString = helpers.getPathString;

// Selections are stored in gd.layout.selections, an array of objects
// index can point to one item in this array,
//  or non-numeric to simply add a new one
//  or -1 to modify all existing
// opt can be the full options object, or one key (to be set to value)
//  or undefined to simply redraw
// if opt is blank, val can be 'add' or a full options object to add a new
//  annotation at that point in the array, or 'remove' to delete this one

module.exports = {
  draw: draw,
  drawOne: drawOne,
  activateLastSelection: activateLastSelection
};
function draw(gd) {
  var fullLayout = gd._fullLayout;
  clearOutlineControllers(gd);

  // Remove previous selections before drawing new selections in fullLayout.selections
  fullLayout._selectionLayer.selectAll('path').remove();
  for (var k in fullLayout._plots) {
    var selectionLayer = fullLayout._plots[k].selectionLayer;
    if (selectionLayer) selectionLayer.selectAll('path').remove();
  }
  for (var i = 0; i < fullLayout.selections.length; i++) {
    drawOne(gd, i);
  }
}
function couldHaveActiveSelection(gd) {
  return gd._context.editSelection;
}
function drawOne(gd, index) {
  // remove the existing selection if there is one.
  // because indices can change, we need to look in all selection layers
  gd._fullLayout._paperdiv.selectAll('.selectionlayer [data-index="' + index + '"]').remove();
  var o = helpers.makeSelectionsOptionsAndPlotinfo(gd, index);
  var options = o.options;
  var plotinfo = o.plotinfo;

  // this selection is gone - quit now after deleting it
  // TODO: use d3 idioms instead of deleting and redrawing every time
  if (!options._input) return;
  drawSelection(gd._fullLayout._selectionLayer);
  function drawSelection(selectionLayer) {
    var d = getPathString(gd, options);
    var attrs = {
      'data-index': index,
      'fill-rule': 'evenodd',
      d: d
    };
    var opacity = options.opacity;
    var fillColor = 'rgba(0,0,0,0)';
    var lineColor = options.line.color || Color.contrast(gd._fullLayout.plot_bgcolor);
    var lineWidth = options.line.width;
    var lineDash = options.line.dash;
    if (!lineWidth) {
      // ensure invisible border to activate the selection
      lineWidth = 5;
      lineDash = 'solid';
    }
    var isActiveSelection = couldHaveActiveSelection(gd) && gd._fullLayout._activeSelectionIndex === index;
    if (isActiveSelection) {
      fillColor = gd._fullLayout.activeselection.fillcolor;
      opacity = gd._fullLayout.activeselection.opacity;
    }
    var allPaths = [];
    for (var sensory = 1; sensory >= 0; sensory--) {
      var path = selectionLayer.append('path').attr(attrs).style('opacity', sensory ? 0.1 : opacity).call(Color.stroke, lineColor).call(Color.fill, fillColor)
      // make it easier to select senory background path
      .call(Drawing.dashLine, sensory ? 'solid' : lineDash, sensory ? 4 + lineWidth : lineWidth);
      setClipPath(path, gd, options);
      if (isActiveSelection) {
        var editHelpers = arrayEditor(gd.layout, 'selections', options);
        path.style({
          cursor: 'move'
        });
        var dragOptions = {
          element: path.node(),
          plotinfo: plotinfo,
          gd: gd,
          editHelpers: editHelpers,
          isActiveSelection: true // i.e. to enable controllers
        };

        var polygons = readPaths(d, gd);
        // display polygons on the screen
        displayOutlines(polygons, path, dragOptions);
      } else {
        path.style('pointer-events', sensory ? 'all' : 'none');
      }
      allPaths[sensory] = path;
    }
    var forePath = allPaths[0];
    var backPath = allPaths[1];
    backPath.node().addEventListener('click', function () {
      return activateSelection(gd, forePath);
    });
  }
}
function setClipPath(selectionPath, gd, selectionOptions) {
  var clipAxes = selectionOptions.xref + selectionOptions.yref;
  Drawing.setClipUrl(selectionPath, 'clip' + gd._fullLayout._uid + clipAxes, gd);
}
function activateSelection(gd, path) {
  if (!couldHaveActiveSelection(gd)) return;
  var element = path.node();
  var id = +element.getAttribute('data-index');
  if (id >= 0) {
    // deactivate if already active
    if (id === gd._fullLayout._activeSelectionIndex) {
      deactivateSelection(gd);
      return;
    }
    gd._fullLayout._activeSelectionIndex = id;
    gd._fullLayout._deactivateSelection = deactivateSelection;
    draw(gd);
  }
}
function activateLastSelection(gd) {
  if (!couldHaveActiveSelection(gd)) return;
  var id = gd._fullLayout.selections.length - 1;
  gd._fullLayout._activeSelectionIndex = id;
  gd._fullLayout._deactivateSelection = deactivateSelection;
  draw(gd);
}
function deactivateSelection(gd) {
  if (!couldHaveActiveSelection(gd)) return;
  var id = gd._fullLayout._activeSelectionIndex;
  if (id >= 0) {
    clearOutlineControllers(gd);
    delete gd._fullLayout._activeSelectionIndex;
    draw(gd);
  }
}

/***/ }),

/***/ 3777:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var dash = (__webpack_require__(9952)/* .dash */ .P);
var extendFlat = (__webpack_require__(1426).extendFlat);
module.exports = {
  newselection: {
    mode: {
      valType: 'enumerated',
      values: ['immediate', 'gradual'],
      dflt: 'immediate',
      editType: 'none'
    },
    line: {
      color: {
        valType: 'color',
        editType: 'none'
      },
      width: {
        valType: 'number',
        min: 1,
        dflt: 1,
        editType: 'none'
      },
      dash: extendFlat({}, dash, {
        dflt: 'dot',
        editType: 'none'
      }),
      editType: 'none'
    },
    // no drawdirection here noting that layout.selectdirection is used instead.

    editType: 'none'
  },
  activeselection: {
    fillcolor: {
      valType: 'color',
      dflt: 'rgba(0,0,0,0)',
      editType: 'none'
    },
    opacity: {
      valType: 'number',
      min: 0,
      max: 1,
      dflt: 0.5,
      editType: 'none'
    },
    editType: 'none'
  }
};

/***/ }),

/***/ 849:
/***/ (function(module) {

"use strict";


module.exports = function supplyDrawNewSelectionDefaults(layoutIn, layoutOut, coerce) {
  coerce('newselection.mode');
  var newselectionLineWidth = coerce('newselection.line.width');
  if (newselectionLineWidth) {
    coerce('newselection.line.color');
    coerce('newselection.line.dash');
  }
  coerce('activeselection.fillcolor');
  coerce('activeselection.opacity');
};

/***/ }),

/***/ 5855:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var dragHelpers = __webpack_require__(4505);
var selectMode = dragHelpers.selectMode;
var handleOutline = __webpack_require__(1873);
var clearOutline = handleOutline.clearOutline;
var helpers = __webpack_require__(165);
var readPaths = helpers.readPaths;
var writePaths = helpers.writePaths;
var fixDatesForPaths = helpers.fixDatesForPaths;
module.exports = function newSelections(outlines, dragOptions) {
  if (!outlines.length) return;
  var e = outlines[0][0]; // pick first
  if (!e) return;
  var d = e.getAttribute('d');
  var gd = dragOptions.gd;
  var newStyle = gd._fullLayout.newselection;
  var plotinfo = dragOptions.plotinfo;
  var xaxis = plotinfo.xaxis;
  var yaxis = plotinfo.yaxis;
  var isActiveSelection = dragOptions.isActiveSelection;
  var dragmode = dragOptions.dragmode;
  var selections = (gd.layout || {}).selections || [];
  if (!selectMode(dragmode) && isActiveSelection !== undefined) {
    var id = gd._fullLayout._activeSelectionIndex;
    if (id < selections.length) {
      switch (gd._fullLayout.selections[id].type) {
        case 'rect':
          dragmode = 'select';
          break;
        case 'path':
          dragmode = 'lasso';
          break;
      }
    }
  }
  var polygons = readPaths(d, gd, plotinfo, isActiveSelection);
  var newSelection = {
    xref: xaxis._id,
    yref: yaxis._id,
    opacity: newStyle.opacity,
    line: {
      color: newStyle.line.color,
      width: newStyle.line.width,
      dash: newStyle.line.dash
    }
  };
  var cell;
  // rect can be in one cell
  // only define cell if there is single cell
  if (polygons.length === 1) cell = polygons[0];
  if (cell && cell.length === 5 &&
  // ensure we only have 4 corners for a rect
  dragmode === 'select') {
    newSelection.type = 'rect';
    newSelection.x0 = cell[0][1];
    newSelection.y0 = cell[0][2];
    newSelection.x1 = cell[2][1];
    newSelection.y1 = cell[2][2];
  } else {
    newSelection.type = 'path';
    if (xaxis && yaxis) fixDatesForPaths(polygons, xaxis, yaxis);
    newSelection.path = writePaths(polygons);
    cell = null;
  }
  clearOutline(gd);
  var editHelpers = dragOptions.editHelpers;
  var modifyItem = (editHelpers || {}).modifyItem;
  var allSelections = [];
  for (var q = 0; q < selections.length; q++) {
    var beforeEdit = gd._fullLayout.selections[q];
    if (!beforeEdit) {
      allSelections[q] = beforeEdit;
      continue;
    }
    allSelections[q] = beforeEdit._input;
    if (isActiveSelection !== undefined && q === gd._fullLayout._activeSelectionIndex) {
      var afterEdit = newSelection;
      switch (beforeEdit.type) {
        case 'rect':
          modifyItem('x0', afterEdit.x0);
          modifyItem('x1', afterEdit.x1);
          modifyItem('y0', afterEdit.y0);
          modifyItem('y1', afterEdit.y1);
          break;
        case 'path':
          modifyItem('path', afterEdit.path);
          break;
      }
    }
  }
  if (isActiveSelection === undefined) {
    allSelections.push(newSelection); // add new selection
    return allSelections;
  }
  return editHelpers ? editHelpers.getUpdateObj() : {};
};

/***/ }),

/***/ 5549:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var strTranslate = (__webpack_require__(1828).strTranslate);

// in v3 (once log ranges are fixed),
// we'll be able to p2r here for all axis types
function p2r(ax, v) {
  switch (ax.type) {
    case 'log':
      return ax.p2d(v);
    case 'date':
      return ax.p2r(v, 0, ax.calendar);
    default:
      return ax.p2r(v);
  }
}
function r2p(ax, v) {
  switch (ax.type) {
    case 'log':
      return ax.d2p(v);
    case 'date':
      return ax.r2p(v, 0, ax.calendar);
    default:
      return ax.r2p(v);
  }
}
function axValue(ax) {
  var index = ax._id.charAt(0) === 'y' ? 1 : 0;
  return function (v) {
    return p2r(ax, v[index]);
  };
}
function getTransform(plotinfo) {
  return strTranslate(plotinfo.xaxis._offset, plotinfo.yaxis._offset);
}
module.exports = {
  p2r: p2r,
  r2p: r2p,
  axValue: axValue,
  getTransform: getTransform
};

/***/ }),

/***/ 7322:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var drawModule = __webpack_require__(2485);
var select = __webpack_require__(3937);
module.exports = {
  moduleType: 'component',
  name: 'selections',
  layoutAttributes: __webpack_require__(8389),
  supplyLayoutDefaults: __webpack_require__(9402),
  supplyDrawNewSelectionDefaults: __webpack_require__(849),
  includeBasePlot: __webpack_require__(6325)('selections'),
  draw: drawModule.draw,
  drawOne: drawModule.drawOne,
  reselect: select.reselect,
  prepSelect: select.prepSelect,
  clearOutline: select.clearOutline,
  clearSelectionsCache: select.clearSelectionsCache,
  selectOnClick: select.selectOnClick
};

/***/ }),

/***/ 3937:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var polybool = __webpack_require__(2142);
var pointInPolygon = __webpack_require__(8258); // could we use contains lib/polygon instead?

var Registry = __webpack_require__(3972);
var dashStyle = (__webpack_require__(1424).dashStyle);
var Color = __webpack_require__(7901);
var Fx = __webpack_require__(211);
var makeEventData = (__webpack_require__(3469).makeEventData);
var dragHelpers = __webpack_require__(4505);
var freeMode = dragHelpers.freeMode;
var rectMode = dragHelpers.rectMode;
var drawMode = dragHelpers.drawMode;
var openMode = dragHelpers.openMode;
var selectMode = dragHelpers.selectMode;
var shapeHelpers = __webpack_require__(477);
var shapeConstants = __webpack_require__(1459);
var displayOutlines = __webpack_require__(2359);
var clearOutline = (__webpack_require__(1873).clearOutline);
var newShapeHelpers = __webpack_require__(165);
var handleEllipse = newShapeHelpers.handleEllipse;
var readPaths = newShapeHelpers.readPaths;
var newShapes = (__webpack_require__(551).newShapes);
var newSelections = __webpack_require__(5855);
var activateLastSelection = (__webpack_require__(2485).activateLastSelection);
var Lib = __webpack_require__(1828);
var ascending = Lib.sorterAsc;
var libPolygon = __webpack_require__(1082);
var throttle = __webpack_require__(9990);
var getFromId = (__webpack_require__(1675).getFromId);
var clearGlCanvases = __webpack_require__(3306);
var redrawReglTraces = (__webpack_require__(1549).redrawReglTraces);
var constants = __webpack_require__(4122);
var MINSELECT = constants.MINSELECT;
var filteredPolygon = libPolygon.filter;
var polygonTester = libPolygon.tester;
var helpers = __webpack_require__(5549);
var p2r = helpers.p2r;
var axValue = helpers.axValue;
var getTransform = helpers.getTransform;
function hasSubplot(dragOptions) {
  // N.B. subplot may be falsy e.g zero sankey index!
  return dragOptions.subplot !== undefined;
}
function prepSelect(evt, startX, startY, dragOptions, mode) {
  var isCartesian = !hasSubplot(dragOptions);
  var isFreeMode = freeMode(mode);
  var isRectMode = rectMode(mode);
  var isOpenMode = openMode(mode);
  var isDrawMode = drawMode(mode);
  var isSelectMode = selectMode(mode);
  var isLine = mode === 'drawline';
  var isEllipse = mode === 'drawcircle';
  var isLineOrEllipse = isLine || isEllipse; // cases with two start & end positions

  var gd = dragOptions.gd;
  var fullLayout = gd._fullLayout;
  var immediateSelect = isSelectMode && fullLayout.newselection.mode === 'immediate' && isCartesian; // N.B. only cartesian subplots have persistent selection

  var zoomLayer = fullLayout._zoomlayer;
  var dragBBox = dragOptions.element.getBoundingClientRect();
  var plotinfo = dragOptions.plotinfo;
  var transform = getTransform(plotinfo);
  var x0 = startX - dragBBox.left;
  var y0 = startY - dragBBox.top;
  fullLayout._calcInverseTransform(gd);
  var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);
  x0 = transformedCoords[0];
  y0 = transformedCoords[1];
  var scaleX = fullLayout._invScaleX;
  var scaleY = fullLayout._invScaleY;
  var x1 = x0;
  var y1 = y0;
  var path0 = 'M' + x0 + ',' + y0;
  var xAxis = dragOptions.xaxes[0];
  var yAxis = dragOptions.yaxes[0];
  var pw = xAxis._length;
  var ph = yAxis._length;
  var subtract = evt.altKey && !(drawMode(mode) && isOpenMode);
  var filterPoly, selectionTesters, mergedPolygons, currentPolygon;
  var i, searchInfo, eventData;
  coerceSelectionsCache(evt, gd, dragOptions);
  if (isFreeMode) {
    filterPoly = filteredPolygon([[x0, y0]], constants.BENDPX);
  }
  var outlines = zoomLayer.selectAll('path.select-outline-' + plotinfo.id).data([1]);
  var newStyle = isDrawMode ? fullLayout.newshape : fullLayout.newselection;
  if (isDrawMode) {
    dragOptions.hasText = newStyle.label.text || newStyle.label.texttemplate;
  }
  var fillC = isDrawMode && !isOpenMode ? newStyle.fillcolor : 'rgba(0,0,0,0)';
  var strokeC = newStyle.line.color || (isCartesian ? Color.contrast(gd._fullLayout.plot_bgcolor) : '#7f7f7f' // non-cartesian subplot
  );

  outlines.enter().append('path').attr('class', 'select-outline select-outline-' + plotinfo.id).style({
    opacity: isDrawMode ? newStyle.opacity / 2 : 1,
    'stroke-dasharray': dashStyle(newStyle.line.dash, newStyle.line.width),
    'stroke-width': newStyle.line.width + 'px',
    'shape-rendering': 'crispEdges'
  }).call(Color.stroke, strokeC).call(Color.fill, fillC).attr('fill-rule', 'evenodd').classed('cursor-move', isDrawMode ? true : false).attr('transform', transform).attr('d', path0 + 'Z');
  var corners = zoomLayer.append('path').attr('class', 'zoombox-corners').style({
    fill: Color.background,
    stroke: Color.defaultLine,
    'stroke-width': 1
  }).attr('transform', transform).attr('d', 'M0,0Z');

  // create & style group for text label
  if (isDrawMode && dragOptions.hasText) {
    var shapeGroup = zoomLayer.select('.label-temp');
    if (shapeGroup.empty()) {
      shapeGroup = zoomLayer.append('g').classed('label-temp', true).classed('select-outline', true).style({
        opacity: 0.8
      });
    }
  }
  var throttleID = fullLayout._uid + constants.SELECTID;
  var selection = [];

  // find the traces to search for selection points
  var searchTraces = determineSearchTraces(gd, dragOptions.xaxes, dragOptions.yaxes, dragOptions.subplot);
  if (immediateSelect && !evt.shiftKey) {
    dragOptions._clearSubplotSelections = function () {
      if (!isCartesian) return;
      var xRef = xAxis._id;
      var yRef = yAxis._id;
      deselectSubplot(gd, xRef, yRef, searchTraces);
      var selections = (gd.layout || {}).selections || [];
      var list = [];
      var selectionErased = false;
      for (var q = 0; q < selections.length; q++) {
        var s = fullLayout.selections[q];
        if (s.xref !== xRef || s.yref !== yRef) {
          list.push(selections[q]);
        } else {
          selectionErased = true;
        }
      }
      if (selectionErased) {
        gd._fullLayout._noEmitSelectedAtStart = true;
        Registry.call('_guiRelayout', gd, {
          selections: list
        });
      }
    };
  }
  var fillRangeItems = getFillRangeItems(dragOptions);
  dragOptions.moveFn = function (dx0, dy0) {
    if (dragOptions._clearSubplotSelections) {
      dragOptions._clearSubplotSelections();
      dragOptions._clearSubplotSelections = undefined;
    }
    x1 = Math.max(0, Math.min(pw, scaleX * dx0 + x0));
    y1 = Math.max(0, Math.min(ph, scaleY * dy0 + y0));
    var dx = Math.abs(x1 - x0);
    var dy = Math.abs(y1 - y0);
    if (isRectMode) {
      var direction;
      var start, end;
      if (isSelectMode) {
        var q = fullLayout.selectdirection;
        if (q === 'any') {
          if (dy < Math.min(dx * 0.6, MINSELECT)) {
            direction = 'h';
          } else if (dx < Math.min(dy * 0.6, MINSELECT)) {
            direction = 'v';
          } else {
            direction = 'd';
          }
        } else {
          direction = q;
        }
        switch (direction) {
          case 'h':
            start = isEllipse ? ph / 2 : 0;
            end = ph;
            break;
          case 'v':
            start = isEllipse ? pw / 2 : 0;
            end = pw;
            break;
        }
      }
      if (isDrawMode) {
        switch (fullLayout.newshape.drawdirection) {
          case 'vertical':
            direction = 'h';
            start = isEllipse ? ph / 2 : 0;
            end = ph;
            break;
          case 'horizontal':
            direction = 'v';
            start = isEllipse ? pw / 2 : 0;
            end = pw;
            break;
          case 'ortho':
            if (dx < dy) {
              direction = 'h';
              start = y0;
              end = y1;
            } else {
              direction = 'v';
              start = x0;
              end = x1;
            }
            break;
          default:
            // i.e. case of 'diagonal'
            direction = 'd';
        }
      }
      if (direction === 'h') {
        // horizontal motion
        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x1, start], [x1, end]) :
        // using x1 instead of x0 allows adjusting the line while drawing
        [[x0, start], [x0, end], [x1, end], [x1, start]]; // make a vertical box

        currentPolygon.xmin = isLineOrEllipse ? x1 : Math.min(x0, x1);
        currentPolygon.xmax = isLineOrEllipse ? x1 : Math.max(x0, x1);
        currentPolygon.ymin = Math.min(start, end);
        currentPolygon.ymax = Math.max(start, end);
        // extras to guide users in keeping a straight selection
        corners.attr('d', 'M' + currentPolygon.xmin + ',' + (y0 - MINSELECT) + 'h-4v' + 2 * MINSELECT + 'h4Z' + 'M' + (currentPolygon.xmax - 1) + ',' + (y0 - MINSELECT) + 'h4v' + 2 * MINSELECT + 'h-4Z');
      } else if (direction === 'v') {
        // vertical motion
        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [start, y1], [end, y1]) :
        // using y1 instead of y0 allows adjusting the line while drawing
        [[start, y0], [start, y1], [end, y1], [end, y0]]; // make a horizontal box

        currentPolygon.xmin = Math.min(start, end);
        currentPolygon.xmax = Math.max(start, end);
        currentPolygon.ymin = isLineOrEllipse ? y1 : Math.min(y0, y1);
        currentPolygon.ymax = isLineOrEllipse ? y1 : Math.max(y0, y1);
        corners.attr('d', 'M' + (x0 - MINSELECT) + ',' + currentPolygon.ymin + 'v-4h' + 2 * MINSELECT + 'v4Z' + 'M' + (x0 - MINSELECT) + ',' + (currentPolygon.ymax - 1) + 'v4h' + 2 * MINSELECT + 'v-4Z');
      } else if (direction === 'd') {
        // diagonal motion
        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x0, y0], [x1, y1]) : [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];
        currentPolygon.xmin = Math.min(x0, x1);
        currentPolygon.xmax = Math.max(x0, x1);
        currentPolygon.ymin = Math.min(y0, y1);
        currentPolygon.ymax = Math.max(y0, y1);
        corners.attr('d', 'M0,0Z');
      }
    } else if (isFreeMode) {
      filterPoly.addPt([x1, y1]);
      currentPolygon = filterPoly.filtered;
    }

    // create outline & tester
    if (dragOptions.selectionDefs && dragOptions.selectionDefs.length) {
      mergedPolygons = mergePolygons(dragOptions.mergedPolygons, currentPolygon, subtract);
      currentPolygon.subtract = subtract;
      selectionTesters = multiTester(dragOptions.selectionDefs.concat([currentPolygon]));
    } else {
      mergedPolygons = [currentPolygon];
      selectionTesters = polygonTester(currentPolygon);
    }

    // display polygons on the screen
    displayOutlines(convertPoly(mergedPolygons, isOpenMode), outlines, dragOptions);
    if (isSelectMode) {
      var _res = reselect(gd, false);
      var extraPoints = _res.eventData ? _res.eventData.points.slice() : [];
      _res = reselect(gd, false, selectionTesters, searchTraces, dragOptions);
      selectionTesters = _res.selectionTesters;
      eventData = _res.eventData;
      var poly;
      if (filterPoly) {
        poly = filterPoly.filtered;
      } else {
        poly = castMultiPolygon(mergedPolygons);
      }
      throttle.throttle(throttleID, constants.SELECTDELAY, function () {
        selection = _doSelect(selectionTesters, searchTraces);
        var newPoints = selection.slice();
        for (var w = 0; w < extraPoints.length; w++) {
          var p = extraPoints[w];
          var found = false;
          for (var u = 0; u < newPoints.length; u++) {
            if (newPoints[u].curveNumber === p.curveNumber && newPoints[u].pointNumber === p.pointNumber) {
              found = true;
              break;
            }
          }
          if (!found) newPoints.push(p);
        }
        if (newPoints.length) {
          if (!eventData) eventData = {};
          eventData.points = newPoints;
        }
        fillRangeItems(eventData, poly);
        emitSelecting(gd, eventData);
      });
    }
  };
  dragOptions.clickFn = function (numClicks, evt) {
    corners.remove();
    if (gd._fullLayout._activeShapeIndex >= 0) {
      gd._fullLayout._deactivateShape(gd);
      return;
    }
    if (isDrawMode) return;
    var clickmode = fullLayout.clickmode;
    throttle.done(throttleID).then(function () {
      throttle.clear(throttleID);
      if (numClicks === 2) {
        // clear selection on doubleclick
        outlines.remove();
        for (i = 0; i < searchTraces.length; i++) {
          searchInfo = searchTraces[i];
          searchInfo._module.selectPoints(searchInfo, false);
        }
        updateSelectedState(gd, searchTraces);
        clearSelectionsCache(dragOptions);
        emitDeselect(gd);
        if (searchTraces.length) {
          var clickedXaxis = searchTraces[0].xaxis;
          var clickedYaxis = searchTraces[0].yaxis;
          if (clickedXaxis && clickedYaxis) {
            // drop selections in the clicked subplot
            var subSelections = [];
            var allSelections = gd._fullLayout.selections;
            for (var k = 0; k < allSelections.length; k++) {
              var s = allSelections[k];
              if (!s) continue; // also drop null selections if any

              if (s.xref !== clickedXaxis._id || s.yref !== clickedYaxis._id) {
                subSelections.push(s);
              }
            }
            if (subSelections.length < allSelections.length) {
              gd._fullLayout._noEmitSelectedAtStart = true;
              Registry.call('_guiRelayout', gd, {
                selections: subSelections
              });
            }
          }
        }
      } else {
        if (clickmode.indexOf('select') > -1) {
          selectOnClick(evt, gd, dragOptions.xaxes, dragOptions.yaxes, dragOptions.subplot, dragOptions, outlines);
        }
        if (clickmode === 'event') {
          // TODO: remove in v3 - this was probably never intended to work as it does,
          // but in case anyone depends on it we don't want to break it now.
          // Note that click-to-select introduced pre v3 also emitts proper
          // event data when clickmode is having 'select' in its flag list.
          emitSelected(gd, undefined);
        }
      }
      Fx.click(gd, evt, plotinfo.id);
    }).catch(Lib.error);
  };
  dragOptions.doneFn = function () {
    corners.remove();
    throttle.done(throttleID).then(function () {
      throttle.clear(throttleID);
      if (!immediateSelect && currentPolygon && dragOptions.selectionDefs) {
        // save last polygons
        currentPolygon.subtract = subtract;
        dragOptions.selectionDefs.push(currentPolygon);

        // we have to keep reference to arrays container
        dragOptions.mergedPolygons.length = 0;
        [].push.apply(dragOptions.mergedPolygons, mergedPolygons);
      }
      if (immediateSelect || isDrawMode) {
        clearSelectionsCache(dragOptions, immediateSelect);
      }
      if (dragOptions.doneFnCompleted) {
        dragOptions.doneFnCompleted(selection);
      }
      if (isSelectMode) {
        emitSelected(gd, eventData);
      }
    }).catch(Lib.error);
  };
}
function selectOnClick(evt, gd, xAxes, yAxes, subplot, dragOptions, polygonOutlines) {
  var hoverData = gd._hoverdata;
  var fullLayout = gd._fullLayout;
  var clickmode = fullLayout.clickmode;
  var sendEvents = clickmode.indexOf('event') > -1;
  var selection = [];
  var searchTraces, searchInfo, currentSelectionDef, selectionTesters, traceSelection;
  var thisTracesSelection, pointOrBinSelected, subtract, eventData, i;
  if (isHoverDataSet(hoverData)) {
    coerceSelectionsCache(evt, gd, dragOptions);
    searchTraces = determineSearchTraces(gd, xAxes, yAxes, subplot);
    var clickedPtInfo = extractClickedPtInfo(hoverData, searchTraces);
    var isBinnedTrace = clickedPtInfo.pointNumbers.length > 0;

    // Note: potentially costly operation isPointOrBinSelected is
    // called as late as possible through the use of an assignment
    // in an if condition.
    if (isBinnedTrace ? isOnlyThisBinSelected(searchTraces, clickedPtInfo) : isOnlyOnePointSelected(searchTraces) && (pointOrBinSelected = isPointOrBinSelected(clickedPtInfo))) {
      if (polygonOutlines) polygonOutlines.remove();
      for (i = 0; i < searchTraces.length; i++) {
        searchInfo = searchTraces[i];
        searchInfo._module.selectPoints(searchInfo, false);
      }
      updateSelectedState(gd, searchTraces);
      clearSelectionsCache(dragOptions);
      if (sendEvents) {
        emitDeselect(gd);
      }
    } else {
      subtract = evt.shiftKey && (pointOrBinSelected !== undefined ? pointOrBinSelected : isPointOrBinSelected(clickedPtInfo));
      currentSelectionDef = newPointSelectionDef(clickedPtInfo.pointNumber, clickedPtInfo.searchInfo, subtract);
      var allSelectionDefs = dragOptions.selectionDefs.concat([currentSelectionDef]);
      selectionTesters = multiTester(allSelectionDefs, selectionTesters);
      for (i = 0; i < searchTraces.length; i++) {
        traceSelection = searchTraces[i]._module.selectPoints(searchTraces[i], selectionTesters);
        thisTracesSelection = fillSelectionItem(traceSelection, searchTraces[i]);
        if (selection.length) {
          for (var j = 0; j < thisTracesSelection.length; j++) {
            selection.push(thisTracesSelection[j]);
          }
        } else selection = thisTracesSelection;
      }
      eventData = {
        points: selection
      };
      updateSelectedState(gd, searchTraces, eventData);
      if (currentSelectionDef && dragOptions) {
        dragOptions.selectionDefs.push(currentSelectionDef);
      }
      if (polygonOutlines) {
        var polygons = dragOptions.mergedPolygons;
        var isOpenMode = openMode(dragOptions.dragmode);

        // display polygons on the screen
        displayOutlines(convertPoly(polygons, isOpenMode), polygonOutlines, dragOptions);
      }
      if (sendEvents) {
        emitSelected(gd, eventData);
      }
    }
  }
}

/**
 * Constructs a new point selection definition object.
 */
function newPointSelectionDef(pointNumber, searchInfo, subtract) {
  return {
    pointNumber: pointNumber,
    searchInfo: searchInfo,
    subtract: !!subtract
  };
}
function isPointSelectionDef(o) {
  return 'pointNumber' in o && 'searchInfo' in o;
}

/*
 * Constructs a new point number tester.
 */
function newPointNumTester(pointSelectionDef) {
  return {
    xmin: 0,
    xmax: 0,
    ymin: 0,
    ymax: 0,
    pts: [],
    contains: function (pt, omitFirstEdge, pointNumber, searchInfo) {
      var idxWantedTrace = pointSelectionDef.searchInfo.cd[0].trace._expandedIndex;
      var idxActualTrace = searchInfo.cd[0].trace._expandedIndex;
      return idxActualTrace === idxWantedTrace && pointNumber === pointSelectionDef.pointNumber;
    },
    isRect: false,
    degenerate: false,
    subtract: !!pointSelectionDef.subtract
  };
}

/**
 * Wraps multiple selection testers.
 *
 * @param {Array} list - An array of selection testers.
 *
 * @return a selection tester object with a contains function
 * that can be called to evaluate a point against all wrapped
 * selection testers that were passed in list.
 */
function multiTester(list) {
  if (!list.length) return;
  var testers = [];
  var xmin = isPointSelectionDef(list[0]) ? 0 : list[0][0][0];
  var xmax = xmin;
  var ymin = isPointSelectionDef(list[0]) ? 0 : list[0][0][1];
  var ymax = ymin;
  for (var i = 0; i < list.length; i++) {
    if (isPointSelectionDef(list[i])) {
      testers.push(newPointNumTester(list[i]));
    } else {
      var tester = polygonTester(list[i]);
      tester.subtract = !!list[i].subtract;
      testers.push(tester);
      xmin = Math.min(xmin, tester.xmin);
      xmax = Math.max(xmax, tester.xmax);
      ymin = Math.min(ymin, tester.ymin);
      ymax = Math.max(ymax, tester.ymax);
    }
  }

  /**
   * Tests if the given point is within this tester.
   *
   * @param {Array} pt - [0] is the x coordinate, [1] is the y coordinate of the point.
   * @param {*} arg - An optional parameter to pass down to wrapped testers.
   * @param {number} pointNumber - The point number of the point within the underlying data array.
   * @param {number} searchInfo - An object identifying the trace the point is contained in.
   *
   * @return {boolean} true if point is considered to be selected, false otherwise.
   */
  function contains(pt, arg, pointNumber, searchInfo) {
    var contained = false;
    for (var i = 0; i < testers.length; i++) {
      if (testers[i].contains(pt, arg, pointNumber, searchInfo)) {
        // if contained by subtract tester - exclude the point
        contained = !testers[i].subtract;
      }
    }
    return contained;
  }
  return {
    xmin: xmin,
    xmax: xmax,
    ymin: ymin,
    ymax: ymax,
    pts: [],
    contains: contains,
    isRect: false,
    degenerate: false
  };
}
function coerceSelectionsCache(evt, gd, dragOptions) {
  var fullLayout = gd._fullLayout;
  var plotinfo = dragOptions.plotinfo;
  var dragmode = dragOptions.dragmode;
  var selectingOnSameSubplot = fullLayout._lastSelectedSubplot && fullLayout._lastSelectedSubplot === plotinfo.id;
  var hasModifierKey = (evt.shiftKey || evt.altKey) && !(drawMode(dragmode) && openMode(dragmode));
  if (selectingOnSameSubplot && hasModifierKey && plotinfo.selection && plotinfo.selection.selectionDefs && !dragOptions.selectionDefs) {
    // take over selection definitions from prev mode, if any
    dragOptions.selectionDefs = plotinfo.selection.selectionDefs;
    dragOptions.mergedPolygons = plotinfo.selection.mergedPolygons;
  } else if (!hasModifierKey || !plotinfo.selection) {
    clearSelectionsCache(dragOptions);
  }

  // clear selection outline when selecting a different subplot
  if (!selectingOnSameSubplot) {
    clearOutline(gd);
    fullLayout._lastSelectedSubplot = plotinfo.id;
  }
}
function hasActiveShape(gd) {
  return gd._fullLayout._activeShapeIndex >= 0;
}
function hasActiveSelection(gd) {
  return gd._fullLayout._activeSelectionIndex >= 0;
}
function clearSelectionsCache(dragOptions, immediateSelect) {
  var dragmode = dragOptions.dragmode;
  var plotinfo = dragOptions.plotinfo;
  var gd = dragOptions.gd;
  if (hasActiveShape(gd)) {
    gd._fullLayout._deactivateShape(gd);
  }
  if (hasActiveSelection(gd)) {
    gd._fullLayout._deactivateSelection(gd);
  }
  var fullLayout = gd._fullLayout;
  var zoomLayer = fullLayout._zoomlayer;
  var isDrawMode = drawMode(dragmode);
  var isSelectMode = selectMode(dragmode);
  if (isDrawMode || isSelectMode) {
    var outlines = zoomLayer.selectAll('.select-outline-' + plotinfo.id);
    if (outlines && gd._fullLayout._outlining) {
      // add shape
      var shapes;
      if (isDrawMode) {
        shapes = newShapes(outlines, dragOptions);
      }
      if (shapes) {
        Registry.call('_guiRelayout', gd, {
          shapes: shapes
        });
      }

      // add selection
      var selections;
      if (isSelectMode && !hasSubplot(dragOptions) // only allow cartesian - no mapbox for now
      ) {
        selections = newSelections(outlines, dragOptions);
      }
      if (selections) {
        gd._fullLayout._noEmitSelectedAtStart = true;
        Registry.call('_guiRelayout', gd, {
          selections: selections
        }).then(function () {
          if (immediateSelect) {
            activateLastSelection(gd);
          }
        });
      }
      gd._fullLayout._outlining = false;
    }
  }
  plotinfo.selection = {};
  plotinfo.selection.selectionDefs = dragOptions.selectionDefs = [];
  plotinfo.selection.mergedPolygons = dragOptions.mergedPolygons = [];
}
function getAxId(ax) {
  return ax._id;
}
function determineSearchTraces(gd, xAxes, yAxes, subplot) {
  if (!gd.calcdata) return [];
  var searchTraces = [];
  var xAxisIds = xAxes.map(getAxId);
  var yAxisIds = yAxes.map(getAxId);
  var cd, trace, i;
  for (i = 0; i < gd.calcdata.length; i++) {
    cd = gd.calcdata[i];
    trace = cd[0].trace;
    if (trace.visible !== true || !trace._module || !trace._module.selectPoints) continue;
    if (hasSubplot({
      subplot: subplot
    }) && (trace.subplot === subplot || trace.geo === subplot)) {
      searchTraces.push(createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]));
    } else if (trace.type === 'splom') {
      // FIXME: make sure we don't have more than single axis for splom
      if (trace._xaxes[xAxisIds[0]] && trace._yaxes[yAxisIds[0]]) {
        var info = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);
        info.scene = gd._fullLayout._splomScenes[trace.uid];
        searchTraces.push(info);
      }
    } else if (trace.type === 'sankey') {
      var sankeyInfo = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);
      searchTraces.push(sankeyInfo);
    } else {
      if (xAxisIds.indexOf(trace.xaxis) === -1) continue;
      if (yAxisIds.indexOf(trace.yaxis) === -1) continue;
      searchTraces.push(createSearchInfo(trace._module, cd, getFromId(gd, trace.xaxis), getFromId(gd, trace.yaxis)));
    }
  }
  return searchTraces;
}
function createSearchInfo(module, calcData, xaxis, yaxis) {
  return {
    _module: module,
    cd: calcData,
    xaxis: xaxis,
    yaxis: yaxis
  };
}
function isHoverDataSet(hoverData) {
  return hoverData && Array.isArray(hoverData) && hoverData[0].hoverOnBox !== true;
}
function extractClickedPtInfo(hoverData, searchTraces) {
  var hoverDatum = hoverData[0];
  var pointNumber = -1;
  var pointNumbers = [];
  var searchInfo, i;
  for (i = 0; i < searchTraces.length; i++) {
    searchInfo = searchTraces[i];
    if (hoverDatum.fullData._expandedIndex === searchInfo.cd[0].trace._expandedIndex) {
      // Special case for box (and violin)
      if (hoverDatum.hoverOnBox === true) {
        break;
      }

      // Hint: in some traces like histogram, one graphical element
      // doesn't correspond to one particular data point, but to
      // bins of data points. Thus, hoverDatum can have a binNumber
      // property instead of pointNumber.
      if (hoverDatum.pointNumber !== undefined) {
        pointNumber = hoverDatum.pointNumber;
      } else if (hoverDatum.binNumber !== undefined) {
        pointNumber = hoverDatum.binNumber;
        pointNumbers = hoverDatum.pointNumbers;
      }
      break;
    }
  }
  return {
    pointNumber: pointNumber,
    pointNumbers: pointNumbers,
    searchInfo: searchInfo
  };
}
function isPointOrBinSelected(clickedPtInfo) {
  var trace = clickedPtInfo.searchInfo.cd[0].trace;
  var ptNum = clickedPtInfo.pointNumber;
  var ptNums = clickedPtInfo.pointNumbers;
  var ptNumsSet = ptNums.length > 0;

  // When pointsNumbers is set (e.g. histogram's binning),
  // it is assumed that when the first point of
  // a bin is selected, all others are as well
  var ptNumToTest = ptNumsSet ? ptNums[0] : ptNum;

  // TODO potential performance improvement
  // Primarily we need this function to determine if a click adds
  // or subtracts from a selection.
  // In cases `trace.selectedpoints` is a huge array, indexOf
  // might be slow. One remedy would be to introduce a hash somewhere.
  return trace.selectedpoints ? trace.selectedpoints.indexOf(ptNumToTest) > -1 : false;
}
function isOnlyThisBinSelected(searchTraces, clickedPtInfo) {
  var tracesWithSelectedPts = [];
  var searchInfo, trace, isSameTrace, i;
  for (i = 0; i < searchTraces.length; i++) {
    searchInfo = searchTraces[i];
    if (searchInfo.cd[0].trace.selectedpoints && searchInfo.cd[0].trace.selectedpoints.length > 0) {
      tracesWithSelectedPts.push(searchInfo);
    }
  }
  if (tracesWithSelectedPts.length === 1) {
    isSameTrace = tracesWithSelectedPts[0] === clickedPtInfo.searchInfo;
    if (isSameTrace) {
      trace = clickedPtInfo.searchInfo.cd[0].trace;
      if (trace.selectedpoints.length === clickedPtInfo.pointNumbers.length) {
        for (i = 0; i < clickedPtInfo.pointNumbers.length; i++) {
          if (trace.selectedpoints.indexOf(clickedPtInfo.pointNumbers[i]) < 0) {
            return false;
          }
        }
        return true;
      }
    }
  }
  return false;
}
function isOnlyOnePointSelected(searchTraces) {
  var len = 0;
  var searchInfo, trace, i;
  for (i = 0; i < searchTraces.length; i++) {
    searchInfo = searchTraces[i];
    trace = searchInfo.cd[0].trace;
    if (trace.selectedpoints) {
      if (trace.selectedpoints.length > 1) return false;
      len += trace.selectedpoints.length;
      if (len > 1) return false;
    }
  }
  return len === 1;
}
function updateSelectedState(gd, searchTraces, eventData) {
  var i;

  // before anything else, update preGUI if necessary
  for (i = 0; i < searchTraces.length; i++) {
    var fullInputTrace = searchTraces[i].cd[0].trace._fullInput;
    var tracePreGUI = gd._fullLayout._tracePreGUI[fullInputTrace.uid] || {};
    if (tracePreGUI.selectedpoints === undefined) {
      tracePreGUI.selectedpoints = fullInputTrace._input.selectedpoints || null;
    }
  }
  var trace;
  if (eventData) {
    var pts = eventData.points || [];
    for (i = 0; i < searchTraces.length; i++) {
      trace = searchTraces[i].cd[0].trace;
      trace._input.selectedpoints = trace._fullInput.selectedpoints = [];
      if (trace._fullInput !== trace) trace.selectedpoints = [];
    }
    for (var k = 0; k < pts.length; k++) {
      var pt = pts[k];
      var data = pt.data;
      var fullData = pt.fullData;
      var pointIndex = pt.pointIndex;
      var pointIndices = pt.pointIndices;
      if (pointIndices) {
        [].push.apply(data.selectedpoints, pointIndices);
        if (trace._fullInput !== trace) {
          [].push.apply(fullData.selectedpoints, pointIndices);
        }
      } else {
        data.selectedpoints.push(pointIndex);
        if (trace._fullInput !== trace) {
          fullData.selectedpoints.push(pointIndex);
        }
      }
    }
  } else {
    for (i = 0; i < searchTraces.length; i++) {
      trace = searchTraces[i].cd[0].trace;
      delete trace.selectedpoints;
      delete trace._input.selectedpoints;
      if (trace._fullInput !== trace) {
        delete trace._fullInput.selectedpoints;
      }
    }
  }
  updateReglSelectedState(gd, searchTraces);
}
function updateReglSelectedState(gd, searchTraces) {
  var hasRegl = false;
  for (var i = 0; i < searchTraces.length; i++) {
    var searchInfo = searchTraces[i];
    var cd = searchInfo.cd;
    if (Registry.traceIs(cd[0].trace, 'regl')) {
      hasRegl = true;
    }
    var _module = searchInfo._module;
    var fn = _module.styleOnSelect || _module.style;
    if (fn) {
      fn(gd, cd, cd[0].node3);
      if (cd[0].nodeRangePlot3) fn(gd, cd, cd[0].nodeRangePlot3);
    }
  }
  if (hasRegl) {
    clearGlCanvases(gd);
    redrawReglTraces(gd);
  }
}
function mergePolygons(list, poly, subtract) {
  var fn = subtract ? polybool.difference : polybool.union;
  var res = fn({
    regions: list
  }, {
    regions: [poly]
  });
  var allPolygons = res.regions.reverse();
  for (var i = 0; i < allPolygons.length; i++) {
    var polygon = allPolygons[i];
    polygon.subtract = getSubtract(polygon, allPolygons.slice(0, i));
  }
  return allPolygons;
}
function fillSelectionItem(selection, searchInfo) {
  if (Array.isArray(selection)) {
    var cd = searchInfo.cd;
    var trace = searchInfo.cd[0].trace;
    for (var i = 0; i < selection.length; i++) {
      selection[i] = makeEventData(selection[i], trace, cd);
    }
  }
  return selection;
}
function convertPoly(polygonsIn, isOpenMode) {
  // add M and L command to draft positions
  var polygonsOut = [];
  for (var i = 0; i < polygonsIn.length; i++) {
    polygonsOut[i] = [];
    for (var j = 0; j < polygonsIn[i].length; j++) {
      polygonsOut[i][j] = [];
      polygonsOut[i][j][0] = j ? 'L' : 'M';
      for (var k = 0; k < polygonsIn[i][j].length; k++) {
        polygonsOut[i][j].push(polygonsIn[i][j][k]);
      }
    }
    if (!isOpenMode) {
      polygonsOut[i].push(['Z', polygonsOut[i][0][1],
      // initial x
      polygonsOut[i][0][2] // initial y
      ]);
    }
  }

  return polygonsOut;
}
function _doSelect(selectionTesters, searchTraces) {
  var allSelections = [];
  var thisSelection;
  var traceSelections = [];
  var traceSelection;
  for (var i = 0; i < searchTraces.length; i++) {
    var searchInfo = searchTraces[i];
    traceSelection = searchInfo._module.selectPoints(searchInfo, selectionTesters);
    traceSelections.push(traceSelection);
    thisSelection = fillSelectionItem(traceSelection, searchInfo);
    allSelections = allSelections.concat(thisSelection);
  }
  return allSelections;
}
function reselect(gd, mayEmitSelected, selectionTesters, searchTraces, dragOptions) {
  var hadSearchTraces = !!searchTraces;
  var plotinfo, xRef, yRef;
  if (dragOptions) {
    plotinfo = dragOptions.plotinfo;
    xRef = dragOptions.xaxes[0]._id;
    yRef = dragOptions.yaxes[0]._id;
  }
  var allSelections = [];
  var allSearchTraces = [];

  // select layout.selection polygons
  var layoutPolygons = getLayoutPolygons(gd);

  // add draft outline polygons to layoutPolygons
  var fullLayout = gd._fullLayout;
  if (plotinfo) {
    var zoomLayer = fullLayout._zoomlayer;
    var mode = fullLayout.dragmode;
    var isDrawMode = drawMode(mode);
    var isSelectMode = selectMode(mode);
    if (isDrawMode || isSelectMode) {
      var xaxis = getFromId(gd, xRef, 'x');
      var yaxis = getFromId(gd, yRef, 'y');
      if (xaxis && yaxis) {
        var outlines = zoomLayer.selectAll('.select-outline-' + plotinfo.id);
        if (outlines && gd._fullLayout._outlining) {
          if (outlines.length) {
            var e = outlines[0][0]; // pick first
            var d = e.getAttribute('d');
            var outlinePolys = readPaths(d, gd, plotinfo);
            var draftPolygons = [];
            for (var u = 0; u < outlinePolys.length; u++) {
              var p = outlinePolys[u];
              var polygon = [];
              for (var t = 0; t < p.length; t++) {
                polygon.push([convert(xaxis, p[t][1]), convert(yaxis, p[t][2])]);
              }
              polygon.xref = xRef;
              polygon.yref = yRef;
              polygon.subtract = getSubtract(polygon, draftPolygons);
              draftPolygons.push(polygon);
            }
            layoutPolygons = layoutPolygons.concat(draftPolygons);
          }
        }
      }
    }
  }
  var subplots = xRef && yRef ? [xRef + yRef] : fullLayout._subplots.cartesian;
  epmtySplomSelectionBatch(gd);
  var seenSplom = {};
  for (var i = 0; i < subplots.length; i++) {
    var subplot = subplots[i];
    var yAt = subplot.indexOf('y');
    var _xRef = subplot.slice(0, yAt);
    var _yRef = subplot.slice(yAt);
    var _selectionTesters = xRef && yRef ? selectionTesters : undefined;
    _selectionTesters = addTester(layoutPolygons, _xRef, _yRef, _selectionTesters);
    if (_selectionTesters) {
      var _searchTraces = searchTraces;
      if (!hadSearchTraces) {
        var _xA = getFromId(gd, _xRef, 'x');
        var _yA = getFromId(gd, _yRef, 'y');
        _searchTraces = determineSearchTraces(gd, [_xA], [_yA], subplot);
        for (var w = 0; w < _searchTraces.length; w++) {
          var s = _searchTraces[w];
          var cd0 = s.cd[0];
          var trace = cd0.trace;
          if (s._module.name === 'scattergl' && !cd0.t.xpx) {
            var x = trace.x;
            var y = trace.y;
            var len = trace._length;
            // generate stash for scattergl
            cd0.t.xpx = [];
            cd0.t.ypx = [];
            for (var j = 0; j < len; j++) {
              cd0.t.xpx[j] = _xA.c2p(x[j]);
              cd0.t.ypx[j] = _yA.c2p(y[j]);
            }
          }
          if (s._module.name === 'splom') {
            if (!seenSplom[trace.uid]) {
              seenSplom[trace.uid] = true;
            }
          }
        }
      }
      var selection = _doSelect(_selectionTesters, _searchTraces);
      allSelections = allSelections.concat(selection);
      allSearchTraces = allSearchTraces.concat(_searchTraces);
    }
  }
  var eventData = {
    points: allSelections
  };
  updateSelectedState(gd, allSearchTraces, eventData);
  var clickmode = fullLayout.clickmode;
  var sendEvents = clickmode.indexOf('event') > -1 && mayEmitSelected;
  if (!plotinfo &&
  // get called from plot_api & plots
  mayEmitSelected) {
    var activePolygons = getLayoutPolygons(gd, true);
    if (activePolygons.length) {
      var xref = activePolygons[0].xref;
      var yref = activePolygons[0].yref;
      if (xref && yref) {
        var poly = castMultiPolygon(activePolygons);
        var fillRangeItems = makeFillRangeItems([getFromId(gd, xref, 'x'), getFromId(gd, yref, 'y')]);
        fillRangeItems(eventData, poly);
      }
    }
    if (gd._fullLayout._noEmitSelectedAtStart) {
      gd._fullLayout._noEmitSelectedAtStart = false;
    } else {
      if (sendEvents) emitSelected(gd, eventData);
    }
    fullLayout._reselect = false;
  }
  if (!plotinfo &&
  // get called from plot_api & plots
  fullLayout._deselect) {
    var deselect = fullLayout._deselect;
    xRef = deselect.xref;
    yRef = deselect.yref;
    if (!subplotSelected(xRef, yRef, allSearchTraces)) {
      deselectSubplot(gd, xRef, yRef, searchTraces);
    }
    if (sendEvents) {
      if (eventData.points.length) {
        emitSelected(gd, eventData);
      } else {
        emitDeselect(gd);
      }
    }
    fullLayout._deselect = false;
  }
  return {
    eventData: eventData,
    selectionTesters: selectionTesters
  };
}
function epmtySplomSelectionBatch(gd) {
  var cd = gd.calcdata;
  if (!cd) return;
  for (var i = 0; i < cd.length; i++) {
    var cd0 = cd[i][0];
    var trace = cd0.trace;
    var splomScenes = gd._fullLayout._splomScenes;
    if (splomScenes) {
      var scene = splomScenes[trace.uid];
      if (scene) {
        scene.selectBatch = [];
      }
    }
  }
}
function subplotSelected(xRef, yRef, searchTraces) {
  for (var i = 0; i < searchTraces.length; i++) {
    var s = searchTraces[i];
    if (s.xaxis && s.xaxis._id === xRef && s.yaxis && s.yaxis._id === yRef) {
      return true;
    }
  }
  return false;
}
function deselectSubplot(gd, xRef, yRef, searchTraces) {
  searchTraces = determineSearchTraces(gd, [getFromId(gd, xRef, 'x')], [getFromId(gd, yRef, 'y')], xRef + yRef);
  for (var k = 0; k < searchTraces.length; k++) {
    var searchInfo = searchTraces[k];
    searchInfo._module.selectPoints(searchInfo, false);
  }
  updateSelectedState(gd, searchTraces);
}
function addTester(layoutPolygons, xRef, yRef, selectionTesters) {
  var mergedPolygons;
  for (var i = 0; i < layoutPolygons.length; i++) {
    var currentPolygon = layoutPolygons[i];
    if (xRef !== currentPolygon.xref || yRef !== currentPolygon.yref) continue;
    if (mergedPolygons) {
      var subtract = !!currentPolygon.subtract;
      mergedPolygons = mergePolygons(mergedPolygons, currentPolygon, subtract);
      selectionTesters = multiTester(mergedPolygons);
    } else {
      mergedPolygons = [currentPolygon];
      selectionTesters = polygonTester(currentPolygon);
    }
  }
  return selectionTesters;
}
function getLayoutPolygons(gd, onlyActiveOnes) {
  var allPolygons = [];
  var fullLayout = gd._fullLayout;
  var allSelections = fullLayout.selections;
  var len = allSelections.length;
  for (var i = 0; i < len; i++) {
    if (onlyActiveOnes && i !== fullLayout._activeSelectionIndex) continue;
    var selection = allSelections[i];
    if (!selection) continue;
    var xref = selection.xref;
    var yref = selection.yref;
    var xaxis = getFromId(gd, xref, 'x');
    var yaxis = getFromId(gd, yref, 'y');
    var xmin, xmax, ymin, ymax;
    var polygon;
    if (selection.type === 'rect') {
      polygon = [];
      var x0 = convert(xaxis, selection.x0);
      var x1 = convert(xaxis, selection.x1);
      var y0 = convert(yaxis, selection.y0);
      var y1 = convert(yaxis, selection.y1);
      polygon = [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];
      xmin = Math.min(x0, x1);
      xmax = Math.max(x0, x1);
      ymin = Math.min(y0, y1);
      ymax = Math.max(y0, y1);
      polygon.xmin = xmin;
      polygon.xmax = xmax;
      polygon.ymin = ymin;
      polygon.ymax = ymax;
      polygon.xref = xref;
      polygon.yref = yref;
      polygon.subtract = false;
      polygon.isRect = true;
      allPolygons.push(polygon);
    } else if (selection.type === 'path') {
      var segments = selection.path.split('Z');
      var multiPolygons = [];
      for (var j = 0; j < segments.length; j++) {
        var path = segments[j];
        if (!path) continue;
        path += 'Z';
        var allX = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsX, 'raw');
        var allY = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsY, 'raw');
        xmin = Infinity;
        xmax = -Infinity;
        ymin = Infinity;
        ymax = -Infinity;
        polygon = [];
        for (var k = 0; k < allX.length; k++) {
          var x = convert(xaxis, allX[k]);
          var y = convert(yaxis, allY[k]);
          polygon.push([x, y]);
          xmin = Math.min(x, xmin);
          xmax = Math.max(x, xmax);
          ymin = Math.min(y, ymin);
          ymax = Math.max(y, ymax);
        }
        polygon.xmin = xmin;
        polygon.xmax = xmax;
        polygon.ymin = ymin;
        polygon.ymax = ymax;
        polygon.xref = xref;
        polygon.yref = yref;
        polygon.subtract = getSubtract(polygon, multiPolygons);
        multiPolygons.push(polygon);
        allPolygons.push(polygon);
      }
    }
  }
  return allPolygons;
}
function getSubtract(polygon, previousPolygons) {
  var subtract = false;
  for (var i = 0; i < previousPolygons.length; i++) {
    var previousPolygon = previousPolygons[i];

    // find out if a point of polygon is inside previous polygons
    for (var k = 0; k < polygon.length; k++) {
      if (pointInPolygon(polygon[k], previousPolygon)) {
        subtract = !subtract;
        break;
      }
    }
  }
  return subtract;
}
function convert(ax, d) {
  if (ax.type === 'date') d = d.replace('_', ' ');
  return ax.type === 'log' ? ax.c2p(d) : ax.r2p(d, null, ax.calendar);
}
function castMultiPolygon(allPolygons) {
  var len = allPolygons.length;

  // descibe multi polygons in one polygon
  var p = [];
  for (var i = 0; i < len; i++) {
    var polygon = allPolygons[i];
    p = p.concat(polygon);

    // add starting vertex to close
    // which indicates next polygon
    p = p.concat([polygon[0]]);
  }
  return computeRectAndRanges(p);
}
function computeRectAndRanges(poly) {
  poly.isRect = poly.length === 5 && poly[0][0] === poly[4][0] && poly[0][1] === poly[4][1] && poly[0][0] === poly[1][0] && poly[2][0] === poly[3][0] && poly[0][1] === poly[3][1] && poly[1][1] === poly[2][1] || poly[0][1] === poly[1][1] && poly[2][1] === poly[3][1] && poly[0][0] === poly[3][0] && poly[1][0] === poly[2][0];
  if (poly.isRect) {
    poly.xmin = Math.min(poly[0][0], poly[2][0]);
    poly.xmax = Math.max(poly[0][0], poly[2][0]);
    poly.ymin = Math.min(poly[0][1], poly[2][1]);
    poly.ymax = Math.max(poly[0][1], poly[2][1]);
  }
  return poly;
}
function makeFillRangeItems(allAxes) {
  return function (eventData, poly) {
    var range;
    var lassoPoints;
    for (var i = 0; i < allAxes.length; i++) {
      var ax = allAxes[i];
      var id = ax._id;
      var axLetter = id.charAt(0);
      if (poly.isRect) {
        if (!range) range = {};
        var min = poly[axLetter + 'min'];
        var max = poly[axLetter + 'max'];
        if (min !== undefined && max !== undefined) {
          range[id] = [p2r(ax, min), p2r(ax, max)].sort(ascending);
        }
      } else {
        if (!lassoPoints) lassoPoints = {};
        lassoPoints[id] = poly.map(axValue(ax));
      }
    }
    if (range) {
      eventData.range = range;
    }
    if (lassoPoints) {
      eventData.lassoPoints = lassoPoints;
    }
  };
}
function getFillRangeItems(dragOptions) {
  var plotinfo = dragOptions.plotinfo;
  return plotinfo.fillRangeItems ||
  // allow subplots (i.e. geo, mapbox, sankey) to override fillRangeItems routine
  makeFillRangeItems(dragOptions.xaxes.concat(dragOptions.yaxes));
}
function emitSelecting(gd, eventData) {
  gd.emit('plotly_selecting', eventData);
}
function emitSelected(gd, eventData) {
  if (eventData) {
    eventData.selections = (gd.layout || {}).selections || [];
  }
  gd.emit('plotly_selected', eventData);
}
function emitDeselect(gd) {
  gd.emit('plotly_deselect', null);
}
module.exports = {
  reselect: reselect,
  prepSelect: prepSelect,
  clearOutline: clearOutline,
  clearSelectionsCache: clearSelectionsCache,
  selectOnClick: selectOnClick
};

/***/ }),

/***/ 9827:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var annAttrs = __webpack_require__(215);
var fontAttrs = __webpack_require__(1940);
var scatterLineAttrs = (__webpack_require__(2196).line);
var dash = (__webpack_require__(9952)/* .dash */ .P);
var extendFlat = (__webpack_require__(1426).extendFlat);
var templatedArray = (__webpack_require__(4467).templatedArray);
var axisPlaceableObjs = __webpack_require__(4695);
var basePlotAttributes = __webpack_require__(9012);
var shapeTexttemplateAttrs = (__webpack_require__(5386)/* .shapeTexttemplateAttrs */ .R);
var shapeLabelTexttemplateVars = __webpack_require__(7281);
module.exports = templatedArray('shape', {
  visible: extendFlat({}, basePlotAttributes.visible, {
    editType: 'calc+arraydraw'
  }),
  showlegend: {
    valType: 'boolean',
    dflt: false,
    editType: 'calc+arraydraw'
  },
  legend: extendFlat({}, basePlotAttributes.legend, {
    editType: 'calc+arraydraw'
  }),
  legendgroup: extendFlat({}, basePlotAttributes.legendgroup, {
    editType: 'calc+arraydraw'
  }),
  legendgrouptitle: {
    text: extendFlat({}, basePlotAttributes.legendgrouptitle.text, {
      editType: 'calc+arraydraw'
    }),
    font: fontAttrs({
      editType: 'calc+arraydraw'
    }),
    editType: 'calc+arraydraw'
  },
  legendrank: extendFlat({}, basePlotAttributes.legendrank, {
    editType: 'calc+arraydraw'
  }),
  legendwidth: extendFlat({}, basePlotAttributes.legendwidth, {
    editType: 'calc+arraydraw'
  }),
  type: {
    valType: 'enumerated',
    values: ['circle', 'rect', 'path', 'line'],
    editType: 'calc+arraydraw'
  },
  layer: {
    valType: 'enumerated',
    values: ['below', 'above'],
    dflt: 'above',
    editType: 'arraydraw'
  },
  xref: extendFlat({}, annAttrs.xref, {}),
  xsizemode: {
    valType: 'enumerated',
    values: ['scaled', 'pixel'],
    dflt: 'scaled',
    editType: 'calc+arraydraw'
  },
  xanchor: {
    valType: 'any',
    editType: 'calc+arraydraw'
  },
  x0: {
    valType: 'any',
    editType: 'calc+arraydraw'
  },
  x1: {
    valType: 'any',
    editType: 'calc+arraydraw'
  },
  yref: extendFlat({}, annAttrs.yref, {}),
  ysizemode: {
    valType: 'enumerated',
    values: ['scaled', 'pixel'],
    dflt: 'scaled',
    editType: 'calc+arraydraw'
  },
  yanchor: {
    valType: 'any',
    editType: 'calc+arraydraw'
  },
  y0: {
    valType: 'any',
    editType: 'calc+arraydraw'
  },
  y1: {
    valType: 'any',
    editType: 'calc+arraydraw'
  },
  path: {
    valType: 'string',
    editType: 'calc+arraydraw'
  },
  opacity: {
    valType: 'number',
    min: 0,
    max: 1,
    dflt: 1,
    editType: 'arraydraw'
  },
  line: {
    color: extendFlat({}, scatterLineAttrs.color, {
      editType: 'arraydraw'
    }),
    width: extendFlat({}, scatterLineAttrs.width, {
      editType: 'calc+arraydraw'
    }),
    dash: extendFlat({}, dash, {
      editType: 'arraydraw'
    }),
    editType: 'calc+arraydraw'
  },
  fillcolor: {
    valType: 'color',
    dflt: 'rgba(0,0,0,0)',
    editType: 'arraydraw'
  },
  fillrule: {
    valType: 'enumerated',
    values: ['evenodd', 'nonzero'],
    dflt: 'evenodd',
    editType: 'arraydraw'
  },
  editable: {
    valType: 'boolean',
    dflt: false,
    editType: 'calc+arraydraw'
  },
  label: {
    text: {
      valType: 'string',
      dflt: '',
      editType: 'arraydraw'
    },
    texttemplate: shapeTexttemplateAttrs({}, {
      keys: Object.keys(shapeLabelTexttemplateVars)
    }),
    font: fontAttrs({
      editType: 'calc+arraydraw',
      colorEditType: 'arraydraw'
    }),
    textposition: {
      valType: 'enumerated',
      values: ['top left', 'top center', 'top right', 'middle left', 'middle center', 'middle right', 'bottom left', 'bottom center', 'bottom right', 'start', 'middle', 'end'],
      editType: 'arraydraw'
    },
    textangle: {
      valType: 'angle',
      dflt: 'auto',
      editType: 'calc+arraydraw'
    },
    xanchor: {
      valType: 'enumerated',
      values: ['auto', 'left', 'center', 'right'],
      dflt: 'auto',
      editType: 'calc+arraydraw'
    },
    yanchor: {
      valType: 'enumerated',
      values: ['top', 'middle', 'bottom'],
      editType: 'calc+arraydraw'
    },
    padding: {
      valType: 'number',
      dflt: 3,
      min: 0,
      editType: 'arraydraw'
    },
    editType: 'arraydraw'
  },
  editType: 'arraydraw'
});

/***/ }),

/***/ 5627:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Axes = __webpack_require__(9298);
var constants = __webpack_require__(1459);
var helpers = __webpack_require__(477);
module.exports = function calcAutorange(gd) {
  var fullLayout = gd._fullLayout;
  var shapeList = Lib.filterVisible(fullLayout.shapes);
  if (!shapeList.length || !gd._fullData.length) return;
  for (var i = 0; i < shapeList.length; i++) {
    var shape = shapeList[i];
    shape._extremes = {};
    var ax;
    var bounds;
    var xRefType = Axes.getRefType(shape.xref);
    var yRefType = Axes.getRefType(shape.yref);

    // paper and axis domain referenced shapes don't affect autorange
    if (shape.xref !== 'paper' && xRefType !== 'domain') {
      var vx0 = shape.xsizemode === 'pixel' ? shape.xanchor : shape.x0;
      var vx1 = shape.xsizemode === 'pixel' ? shape.xanchor : shape.x1;
      ax = Axes.getFromId(gd, shape.xref);
      bounds = shapeBounds(ax, vx0, vx1, shape.path, constants.paramIsX);
      if (bounds) {
        shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcXPaddingOptions(shape));
      }
    }
    if (shape.yref !== 'paper' && yRefType !== 'domain') {
      var vy0 = shape.ysizemode === 'pixel' ? shape.yanchor : shape.y0;
      var vy1 = shape.ysizemode === 'pixel' ? shape.yanchor : shape.y1;
      ax = Axes.getFromId(gd, shape.yref);
      bounds = shapeBounds(ax, vy0, vy1, shape.path, constants.paramIsY);
      if (bounds) {
        shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcYPaddingOptions(shape));
      }
    }
  }
};
function calcXPaddingOptions(shape) {
  return calcPaddingOptions(shape.line.width, shape.xsizemode, shape.x0, shape.x1, shape.path, false);
}
function calcYPaddingOptions(shape) {
  return calcPaddingOptions(shape.line.width, shape.ysizemode, shape.y0, shape.y1, shape.path, true);
}
function calcPaddingOptions(lineWidth, sizeMode, v0, v1, path, isYAxis) {
  var ppad = lineWidth / 2;
  var axisDirectionReverted = isYAxis;
  if (sizeMode === 'pixel') {
    var coords = path ? helpers.extractPathCoords(path, isYAxis ? constants.paramIsY : constants.paramIsX) : [v0, v1];
    var maxValue = Lib.aggNums(Math.max, null, coords);
    var minValue = Lib.aggNums(Math.min, null, coords);
    var beforePad = minValue < 0 ? Math.abs(minValue) + ppad : ppad;
    var afterPad = maxValue > 0 ? maxValue + ppad : ppad;
    return {
      ppad: ppad,
      ppadplus: axisDirectionReverted ? beforePad : afterPad,
      ppadminus: axisDirectionReverted ? afterPad : beforePad
    };
  } else {
    return {
      ppad: ppad
    };
  }
}
function shapeBounds(ax, v0, v1, path, paramsToUse) {
  var convertVal = ax.type === 'category' || ax.type === 'multicategory' ? ax.r2c : ax.d2c;
  if (v0 !== undefined) return [convertVal(v0), convertVal(v1)];
  if (!path) return;
  var min = Infinity;
  var max = -Infinity;
  var segments = path.match(constants.segmentRE);
  var i;
  var segment;
  var drawnParam;
  var params;
  var val;
  if (ax.type === 'date') convertVal = helpers.decodeDate(convertVal);
  for (i = 0; i < segments.length; i++) {
    segment = segments[i];
    drawnParam = paramsToUse[segment.charAt(0)].drawn;
    if (drawnParam === undefined) continue;
    params = segments[i].substr(1).match(constants.paramRE);
    if (!params || params.length < drawnParam) continue;
    val = convertVal(params[drawnParam]);
    if (val < min) min = val;
    if (val > max) max = val;
  }
  if (max >= min) return [min, max];
}

/***/ }),

/***/ 1459:
/***/ (function(module) {

"use strict";


module.exports = {
  segmentRE: /[MLHVQCTSZ][^MLHVQCTSZ]*/g,
  paramRE: /[^\s,]+/g,
  // which numbers in each path segment are x (or y) values
  // drawn is which param is a drawn point, as opposed to a
  // control point (which doesn't count toward autorange.
  // TODO: this means curved paths could extend beyond the
  // autorange bounds. This is a bit tricky to get right
  // unless we revert to bounding boxes, but perhaps there's
  // a calculation we could do...)
  paramIsX: {
    M: {
      0: true,
      drawn: 0
    },
    L: {
      0: true,
      drawn: 0
    },
    H: {
      0: true,
      drawn: 0
    },
    V: {},
    Q: {
      0: true,
      2: true,
      drawn: 2
    },
    C: {
      0: true,
      2: true,
      4: true,
      drawn: 4
    },
    T: {
      0: true,
      drawn: 0
    },
    S: {
      0: true,
      2: true,
      drawn: 2
    },
    // A: {0: true, 5: true},
    Z: {}
  },
  paramIsY: {
    M: {
      1: true,
      drawn: 1
    },
    L: {
      1: true,
      drawn: 1
    },
    H: {},
    V: {
      0: true,
      drawn: 0
    },
    Q: {
      1: true,
      3: true,
      drawn: 3
    },
    C: {
      1: true,
      3: true,
      5: true,
      drawn: 5
    },
    T: {
      1: true,
      drawn: 1
    },
    S: {
      1: true,
      3: true,
      drawn: 5
    },
    // A: {1: true, 6: true},
    Z: {}
  },
  numParams: {
    M: 2,
    L: 2,
    H: 1,
    V: 1,
    Q: 4,
    C: 6,
    T: 2,
    S: 4,
    // A: 7,
    Z: 0
  }
};

/***/ }),

/***/ 4726:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Axes = __webpack_require__(9298);
var handleArrayContainerDefaults = __webpack_require__(5501);
var attributes = __webpack_require__(9827);
var helpers = __webpack_require__(477);
module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
  handleArrayContainerDefaults(layoutIn, layoutOut, {
    name: 'shapes',
    handleItemDefaults: handleShapeDefaults
  });
};
function dfltLabelYanchor(isLine, labelTextPosition) {
  // If shape is a line, default y-anchor is 'bottom' (so that text is above line by default)
  // Otherwise, default y-anchor is equal to y-component of `textposition`
  // (so that text is positioned inside shape bounding box by default)
  return isLine ? 'bottom' : labelTextPosition.indexOf('top') !== -1 ? 'top' : labelTextPosition.indexOf('bottom') !== -1 ? 'bottom' : 'middle';
}
function handleShapeDefaults(shapeIn, shapeOut, fullLayout) {
  function coerce(attr, dflt) {
    return Lib.coerce(shapeIn, shapeOut, attributes, attr, dflt);
  }
  shapeOut._isShape = true;
  var visible = coerce('visible');
  if (!visible) return;
  var showlegend = coerce('showlegend');
  if (showlegend) {
    coerce('legend');
    coerce('legendwidth');
    coerce('legendgroup');
    coerce('legendgrouptitle.text');
    Lib.coerceFont(coerce, 'legendgrouptitle.font');
    coerce('legendrank');
  }
  var path = coerce('path');
  var dfltType = path ? 'path' : 'rect';
  var shapeType = coerce('type', dfltType);
  var noPath = shapeType !== 'path';
  if (noPath) delete shapeOut.path;
  coerce('editable');
  coerce('layer');
  coerce('opacity');
  coerce('fillcolor');
  coerce('fillrule');
  var lineWidth = coerce('line.width');
  if (lineWidth) {
    coerce('line.color');
    coerce('line.dash');
  }
  var xSizeMode = coerce('xsizemode');
  var ySizeMode = coerce('ysizemode');

  // positioning
  var axLetters = ['x', 'y'];
  for (var i = 0; i < 2; i++) {
    var axLetter = axLetters[i];
    var attrAnchor = axLetter + 'anchor';
    var sizeMode = axLetter === 'x' ? xSizeMode : ySizeMode;
    var gdMock = {
      _fullLayout: fullLayout
    };
    var ax;
    var pos2r;
    var r2pos;

    // xref, yref
    var axRef = Axes.coerceRef(shapeIn, shapeOut, gdMock, axLetter, undefined, 'paper');
    var axRefType = Axes.getRefType(axRef);
    if (axRefType === 'range') {
      ax = Axes.getFromId(gdMock, axRef);
      ax._shapeIndices.push(shapeOut._index);
      r2pos = helpers.rangeToShapePosition(ax);
      pos2r = helpers.shapePositionToRange(ax);
    } else {
      pos2r = r2pos = Lib.identity;
    }

    // Coerce x0, x1, y0, y1
    if (noPath) {
      var dflt0 = 0.25;
      var dflt1 = 0.75;

      // hack until V3.0 when log has regular range behavior - make it look like other
      // ranges to send to coerce, then put it back after
      // this is all to give reasonable default position behavior on log axes, which is
      // a pretty unimportant edge case so we could just ignore this.
      var attr0 = axLetter + '0';
      var attr1 = axLetter + '1';
      var in0 = shapeIn[attr0];
      var in1 = shapeIn[attr1];
      shapeIn[attr0] = pos2r(shapeIn[attr0], true);
      shapeIn[attr1] = pos2r(shapeIn[attr1], true);
      if (sizeMode === 'pixel') {
        coerce(attr0, 0);
        coerce(attr1, 10);
      } else {
        Axes.coercePosition(shapeOut, gdMock, coerce, axRef, attr0, dflt0);
        Axes.coercePosition(shapeOut, gdMock, coerce, axRef, attr1, dflt1);
      }

      // hack part 2
      shapeOut[attr0] = r2pos(shapeOut[attr0]);
      shapeOut[attr1] = r2pos(shapeOut[attr1]);
      shapeIn[attr0] = in0;
      shapeIn[attr1] = in1;
    }

    // Coerce xanchor and yanchor
    if (sizeMode === 'pixel') {
      // Hack for log axis described above
      var inAnchor = shapeIn[attrAnchor];
      shapeIn[attrAnchor] = pos2r(shapeIn[attrAnchor], true);
      Axes.coercePosition(shapeOut, gdMock, coerce, axRef, attrAnchor, 0.25);

      // Hack part 2
      shapeOut[attrAnchor] = r2pos(shapeOut[attrAnchor]);
      shapeIn[attrAnchor] = inAnchor;
    }
  }
  if (noPath) {
    Lib.noneOrAll(shapeIn, shapeOut, ['x0', 'x1', 'y0', 'y1']);
  }

  // Label options
  var isLine = shapeType === 'line';
  var labelTextTemplate, labelText;
  if (noPath) {
    labelTextTemplate = coerce('label.texttemplate');
  }
  if (!labelTextTemplate) {
    labelText = coerce('label.text');
  }
  if (labelText || labelTextTemplate) {
    coerce('label.textangle');
    var labelTextPosition = coerce('label.textposition', isLine ? 'middle' : 'middle center');
    coerce('label.xanchor');
    coerce('label.yanchor', dfltLabelYanchor(isLine, labelTextPosition));
    coerce('label.padding');
    Lib.coerceFont(coerce, 'label.font', fullLayout.font);
  }
}

/***/ }),

/***/ 8100:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Axes = __webpack_require__(9298);
var svgTextUtils = __webpack_require__(3893);
var Drawing = __webpack_require__(1424);
var readPaths = (__webpack_require__(165).readPaths);
var helpers = __webpack_require__(477);
var getPathString = helpers.getPathString;
var shapeLabelTexttemplateVars = __webpack_require__(7281);
var FROM_TL = (__webpack_require__(8783).FROM_TL);
module.exports = function drawLabel(gd, index, options, shapeGroup) {
  // Remove existing label
  shapeGroup.selectAll('.shape-label').remove();

  // If no label text or texttemplate, return
  if (!(options.label.text || options.label.texttemplate)) return;

  // Text template overrides text
  var text;
  if (options.label.texttemplate) {
    var templateValues = {};
    if (options.type !== 'path') {
      var _xa = Axes.getFromId(gd, options.xref);
      var _ya = Axes.getFromId(gd, options.yref);
      for (var key in shapeLabelTexttemplateVars) {
        var val = shapeLabelTexttemplateVars[key](options, _xa, _ya);
        if (val !== undefined) templateValues[key] = val;
      }
    }
    text = Lib.texttemplateStringForShapes(options.label.texttemplate, {}, gd._fullLayout._d3locale, templateValues);
  } else {
    text = options.label.text;
  }
  var labelGroupAttrs = {
    'data-index': index
  };
  var font = options.label.font;
  var labelTextAttrs = {
    'data-notex': 1
  };
  var labelGroup = shapeGroup.append('g').attr(labelGroupAttrs).classed('shape-label', true);
  var labelText = labelGroup.append('text').attr(labelTextAttrs).classed('shape-label-text', true).text(text);

  // Get x and y bounds of shape
  var shapex0, shapex1, shapey0, shapey1;
  if (options.path) {
    // If shape is defined as a path, get the
    // min and max bounds across all polygons in path
    var d = getPathString(gd, options);
    var polygons = readPaths(d, gd);
    shapex0 = Infinity;
    shapey0 = Infinity;
    shapex1 = -Infinity;
    shapey1 = -Infinity;
    for (var i = 0; i < polygons.length; i++) {
      for (var j = 0; j < polygons[i].length; j++) {
        var p = polygons[i][j];
        for (var k = 1; k < p.length; k += 2) {
          var _x = p[k];
          var _y = p[k + 1];
          shapex0 = Math.min(shapex0, _x);
          shapex1 = Math.max(shapex1, _x);
          shapey0 = Math.min(shapey0, _y);
          shapey1 = Math.max(shapey1, _y);
        }
      }
    }
  } else {
    // Otherwise, we use the x and y bounds defined in the shape options
    // and convert them to pixel coordinates
    // Setup conversion functions
    var xa = Axes.getFromId(gd, options.xref);
    var xRefType = Axes.getRefType(options.xref);
    var ya = Axes.getFromId(gd, options.yref);
    var yRefType = Axes.getRefType(options.yref);
    var x2p = helpers.getDataToPixel(gd, xa, false, xRefType);
    var y2p = helpers.getDataToPixel(gd, ya, true, yRefType);
    shapex0 = x2p(options.x0);
    shapex1 = x2p(options.x1);
    shapey0 = y2p(options.y0);
    shapey1 = y2p(options.y1);
  }

  // Handle `auto` angle
  var textangle = options.label.textangle;
  if (textangle === 'auto') {
    if (options.type === 'line') {
      // Auto angle for line is same angle as line
      textangle = calcTextAngle(shapex0, shapey0, shapex1, shapey1);
    } else {
      // Auto angle for all other shapes is 0
      textangle = 0;
    }
  }

  // Do an initial render so we can get the text bounding box height
  labelText.call(function (s) {
    s.call(Drawing.font, font).attr({});
    svgTextUtils.convertToTspans(s, gd);
    return s;
  });
  var textBB = Drawing.bBox(labelText.node());

  // Calculate correct (x,y) for text
  // We also determine true xanchor since xanchor depends on position when set to 'auto'
  var textPos = calcTextPosition(shapex0, shapey0, shapex1, shapey1, options, textangle, textBB);
  var textx = textPos.textx;
  var texty = textPos.texty;
  var xanchor = textPos.xanchor;

  // Update (x,y) position, xanchor, and angle
  labelText.attr({
    'text-anchor': {
      left: 'start',
      center: 'middle',
      right: 'end'
    }[xanchor],
    y: texty,
    x: textx,
    transform: 'rotate(' + textangle + ',' + textx + ',' + texty + ')'
  }).call(svgTextUtils.positionText, textx, texty);
};
function calcTextAngle(shapex0, shapey0, shapex1, shapey1) {
  var dy, dx;
  dx = Math.abs(shapex1 - shapex0);
  if (shapex1 >= shapex0) {
    dy = shapey0 - shapey1;
  } else {
    dy = shapey1 - shapey0;
  }
  return -180 / Math.PI * Math.atan2(dy, dx);
}
function calcTextPosition(shapex0, shapey0, shapex1, shapey1, shapeOptions, actualTextAngle, textBB) {
  var textPosition = shapeOptions.label.textposition;
  var textAngle = shapeOptions.label.textangle;
  var textPadding = shapeOptions.label.padding;
  var shapeType = shapeOptions.type;
  var textAngleRad = Math.PI / 180 * actualTextAngle;
  var sinA = Math.sin(textAngleRad);
  var cosA = Math.cos(textAngleRad);
  var xanchor = shapeOptions.label.xanchor;
  var yanchor = shapeOptions.label.yanchor;
  var textx, texty, paddingX, paddingY;

  // Text position functions differently for lines vs. other shapes
  if (shapeType === 'line') {
    // Set base position for start vs. center vs. end of line (default is 'center')
    if (textPosition === 'start') {
      textx = shapex0;
      texty = shapey0;
    } else if (textPosition === 'end') {
      textx = shapex1;
      texty = shapey1;
    } else {
      // Default: center
      textx = (shapex0 + shapex1) / 2;
      texty = (shapey0 + shapey1) / 2;
    }

    // Set xanchor if xanchor is 'auto'
    if (xanchor === 'auto') {
      if (textPosition === 'start') {
        if (textAngle === 'auto') {
          if (shapex1 > shapex0) xanchor = 'left';else if (shapex1 < shapex0) xanchor = 'right';else xanchor = 'center';
        } else {
          if (shapex1 > shapex0) xanchor = 'right';else if (shapex1 < shapex0) xanchor = 'left';else xanchor = 'center';
        }
      } else if (textPosition === 'end') {
        if (textAngle === 'auto') {
          if (shapex1 > shapex0) xanchor = 'right';else if (shapex1 < shapex0) xanchor = 'left';else xanchor = 'center';
        } else {
          if (shapex1 > shapex0) xanchor = 'left';else if (shapex1 < shapex0) xanchor = 'right';else xanchor = 'center';
        }
      } else {
        xanchor = 'center';
      }
    }

    // Special case for padding when angle is 'auto' for lines
    // Padding should be treated as an orthogonal offset in this case
    // Otherwise, padding is just a simple x and y offset
    var paddingConstantsX = {
      left: 1,
      center: 0,
      right: -1
    };
    var paddingConstantsY = {
      bottom: -1,
      middle: 0,
      top: 1
    };
    if (textAngle === 'auto') {
      // Set direction to apply padding (based on `yanchor` only)
      var paddingDirection = paddingConstantsY[yanchor];
      paddingX = -textPadding * sinA * paddingDirection;
      paddingY = textPadding * cosA * paddingDirection;
    } else {
      // Set direction to apply padding (based on `xanchor` and `yanchor`)
      var paddingDirectionX = paddingConstantsX[xanchor];
      var paddingDirectionY = paddingConstantsY[yanchor];
      paddingX = textPadding * paddingDirectionX;
      paddingY = textPadding * paddingDirectionY;
    }
    textx = textx + paddingX;
    texty = texty + paddingY;
  } else {
    // Text position for shapes that are not lines
    // calc horizontal position
    // Horizontal needs a little extra padding to look balanced
    paddingX = textPadding + 3;
    if (textPosition.indexOf('right') !== -1) {
      textx = Math.max(shapex0, shapex1) - paddingX;
      if (xanchor === 'auto') xanchor = 'right';
    } else if (textPosition.indexOf('left') !== -1) {
      textx = Math.min(shapex0, shapex1) + paddingX;
      if (xanchor === 'auto') xanchor = 'left';
    } else {
      // Default: center
      textx = (shapex0 + shapex1) / 2;
      if (xanchor === 'auto') xanchor = 'center';
    }

    // calc vertical position
    if (textPosition.indexOf('top') !== -1) {
      texty = Math.min(shapey0, shapey1);
    } else if (textPosition.indexOf('bottom') !== -1) {
      texty = Math.max(shapey0, shapey1);
    } else {
      texty = (shapey0 + shapey1) / 2;
    }
    // Apply padding
    paddingY = textPadding;
    if (yanchor === 'bottom') {
      texty = texty - paddingY;
    } else if (yanchor === 'top') {
      texty = texty + paddingY;
    }
  }

  // Shift vertical (& horizontal) position according to `yanchor`
  var shiftFraction = FROM_TL[yanchor];
  // Adjust so that text is anchored at top of first line rather than at baseline of first line
  var baselineAdjust = shapeOptions.label.font.size;
  var textHeight = textBB.height;
  var xshift = (textHeight * shiftFraction - baselineAdjust) * sinA;
  var yshift = -(textHeight * shiftFraction - baselineAdjust) * cosA;
  return {
    textx: textx + xshift,
    texty: texty + yshift,
    xanchor: xanchor
  };
}

/***/ }),

/***/ 2359:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var strTranslate = Lib.strTranslate;
var dragElement = __webpack_require__(8569);
var dragHelpers = __webpack_require__(4505);
var drawMode = dragHelpers.drawMode;
var selectMode = dragHelpers.selectMode;
var Registry = __webpack_require__(3972);
var Color = __webpack_require__(7901);
var constants = __webpack_require__(9995);
var i000 = constants.i000;
var i090 = constants.i090;
var i180 = constants.i180;
var i270 = constants.i270;
var handleOutline = __webpack_require__(1873);
var clearOutlineControllers = handleOutline.clearOutlineControllers;
var helpers = __webpack_require__(165);
var pointsOnRectangle = helpers.pointsOnRectangle;
var pointsOnEllipse = helpers.pointsOnEllipse;
var writePaths = helpers.writePaths;
var newShapes = (__webpack_require__(551).newShapes);
var createShapeObj = (__webpack_require__(551).createShapeObj);
var newSelections = __webpack_require__(5855);
var drawLabel = __webpack_require__(8100);
module.exports = function displayOutlines(polygons, outlines, dragOptions, nCalls) {
  if (!nCalls) nCalls = 0;
  var gd = dragOptions.gd;
  function redraw() {
    // recursive call
    displayOutlines(polygons, outlines, dragOptions, nCalls++);
    if (pointsOnEllipse(polygons[0]) || dragOptions.hasText) {
      update({
        redrawing: true
      });
    }
  }
  function update(opts) {
    var updateObject = {};
    if (dragOptions.isActiveShape !== undefined) {
      dragOptions.isActiveShape = false; // i.e. to disable shape controllers
      updateObject = newShapes(outlines, dragOptions);
    }
    if (dragOptions.isActiveSelection !== undefined) {
      dragOptions.isActiveSelection = false; // i.e. to disable selection controllers
      updateObject = newSelections(outlines, dragOptions);
      gd._fullLayout._reselect = true;
    }
    if (Object.keys(updateObject).length) {
      Registry.call((opts || {}).redrawing ? 'relayout' : '_guiRelayout', gd, updateObject);
    }
  }
  var fullLayout = gd._fullLayout;
  var zoomLayer = fullLayout._zoomlayer;
  var dragmode = dragOptions.dragmode;
  var isDrawMode = drawMode(dragmode);
  var isSelectMode = selectMode(dragmode);
  if (isDrawMode || isSelectMode) {
    gd._fullLayout._outlining = true;
  }
  clearOutlineControllers(gd);

  // make outline
  outlines.attr('d', writePaths(polygons));

  // add controllers
  var vertexDragOptions;
  var groupDragOptions;
  var indexI; // cell index
  var indexJ; // vertex or cell-controller index
  var copyPolygons;
  if (!nCalls && (dragOptions.isActiveShape || dragOptions.isActiveSelection)) {
    copyPolygons = recordPositions([], polygons);
    var g = zoomLayer.append('g').attr('class', 'outline-controllers');
    addVertexControllers(g);
    addGroupControllers();
  }

  // draw label
  if (isDrawMode && dragOptions.hasText) {
    var shapeGroup = zoomLayer.select('.label-temp');
    var shapeOptions = createShapeObj(outlines, dragOptions, dragOptions.dragmode);
    drawLabel(gd, 'label-temp', shapeOptions, shapeGroup);
  }
  function startDragVertex(evt) {
    indexI = +evt.srcElement.getAttribute('data-i');
    indexJ = +evt.srcElement.getAttribute('data-j');
    vertexDragOptions[indexI][indexJ].moveFn = moveVertexController;
  }
  function moveVertexController(dx, dy) {
    if (!polygons.length) return;
    var x0 = copyPolygons[indexI][indexJ][1];
    var y0 = copyPolygons[indexI][indexJ][2];
    var cell = polygons[indexI];
    var len = cell.length;
    if (pointsOnRectangle(cell)) {
      var _dx = dx;
      var _dy = dy;
      if (dragOptions.isActiveSelection) {
        // handle an edge contoller for rect selections
        var nextPoint = getNextPoint(cell, indexJ);
        if (nextPoint[1] === cell[indexJ][1]) {
          // a vertical edge
          _dy = 0;
        } else {
          // a horizontal edge
          _dx = 0;
        }
      }
      for (var q = 0; q < len; q++) {
        if (q === indexJ) continue;

        // move other corners of rectangle
        var pos = cell[q];
        if (pos[1] === cell[indexJ][1]) {
          pos[1] = x0 + _dx;
        }
        if (pos[2] === cell[indexJ][2]) {
          pos[2] = y0 + _dy;
        }
      }
      // move the corner
      cell[indexJ][1] = x0 + _dx;
      cell[indexJ][2] = y0 + _dy;
      if (!pointsOnRectangle(cell)) {
        // reject result to rectangles with ensure areas
        for (var j = 0; j < len; j++) {
          for (var k = 0; k < cell[j].length; k++) {
            cell[j][k] = copyPolygons[indexI][j][k];
          }
        }
      }
    } else {
      // other polylines
      cell[indexJ][1] = x0 + dx;
      cell[indexJ][2] = y0 + dy;
    }
    redraw();
  }
  function endDragVertexController() {
    update();
  }
  function removeVertex() {
    if (!polygons.length) return;
    if (!polygons[indexI]) return;
    if (!polygons[indexI].length) return;
    var newPolygon = [];
    for (var j = 0; j < polygons[indexI].length; j++) {
      if (j !== indexJ) {
        newPolygon.push(polygons[indexI][j]);
      }
    }
    if (newPolygon.length > 1 && !(newPolygon.length === 2 && newPolygon[1][0] === 'Z')) {
      if (indexJ === 0) {
        newPolygon[0][0] = 'M';
      }
      polygons[indexI] = newPolygon;
      redraw();
      update();
    }
  }
  function clickVertexController(numClicks, evt) {
    if (numClicks === 2) {
      indexI = +evt.srcElement.getAttribute('data-i');
      indexJ = +evt.srcElement.getAttribute('data-j');
      var cell = polygons[indexI];
      if (!pointsOnRectangle(cell) && !pointsOnEllipse(cell)) {
        removeVertex();
      }
    }
  }
  function addVertexControllers(g) {
    vertexDragOptions = [];
    for (var i = 0; i < polygons.length; i++) {
      var cell = polygons[i];
      var onRect = pointsOnRectangle(cell);
      var onEllipse = !onRect && pointsOnEllipse(cell);
      vertexDragOptions[i] = [];
      var len = cell.length;
      for (var j = 0; j < len; j++) {
        if (cell[j][0] === 'Z') continue;
        if (onEllipse && j !== i000 && j !== i090 && j !== i180 && j !== i270) {
          continue;
        }
        var rectSelection = onRect && dragOptions.isActiveSelection;
        var nextPoint;
        if (rectSelection) nextPoint = getNextPoint(cell, j);
        var x = cell[j][1];
        var y = cell[j][2];
        var vertex = g.append(rectSelection ? 'rect' : 'circle').attr('data-i', i).attr('data-j', j).style({
          fill: Color.background,
          stroke: Color.defaultLine,
          'stroke-width': 1,
          'shape-rendering': 'crispEdges'
        });
        if (rectSelection) {
          // convert a vertex controller to an edge controller for rect selections
          var dx = nextPoint[1] - x;
          var dy = nextPoint[2] - y;
          var width = dy ? 5 : Math.max(Math.min(25, Math.abs(dx) - 5), 5);
          var height = dx ? 5 : Math.max(Math.min(25, Math.abs(dy) - 5), 5);
          vertex.classed(dy ? 'cursor-ew-resize' : 'cursor-ns-resize', true).attr('width', width).attr('height', height).attr('x', x - width / 2).attr('y', y - height / 2).attr('transform', strTranslate(dx / 2, dy / 2));
        } else {
          vertex.classed('cursor-grab', true).attr('r', 5).attr('cx', x).attr('cy', y);
        }
        vertexDragOptions[i][j] = {
          element: vertex.node(),
          gd: gd,
          prepFn: startDragVertex,
          doneFn: endDragVertexController,
          clickFn: clickVertexController
        };
        dragElement.init(vertexDragOptions[i][j]);
      }
    }
  }
  function moveGroup(dx, dy) {
    if (!polygons.length) return;
    for (var i = 0; i < polygons.length; i++) {
      for (var j = 0; j < polygons[i].length; j++) {
        for (var k = 0; k + 2 < polygons[i][j].length; k += 2) {
          polygons[i][j][k + 1] = copyPolygons[i][j][k + 1] + dx;
          polygons[i][j][k + 2] = copyPolygons[i][j][k + 2] + dy;
        }
      }
    }
  }
  function moveGroupController(dx, dy) {
    moveGroup(dx, dy);
    redraw();
  }
  function startDragGroupController(evt) {
    indexI = +evt.srcElement.getAttribute('data-i');
    if (!indexI) indexI = 0; // ensure non-existing move button get zero index

    groupDragOptions[indexI].moveFn = moveGroupController;
  }
  function endDragGroupController() {
    update();
  }
  function clickGroupController(numClicks) {
    if (numClicks === 2) {
      eraseActiveSelection(gd);
    }
  }
  function addGroupControllers() {
    groupDragOptions = [];
    if (!polygons.length) return;
    var i = 0;
    groupDragOptions[i] = {
      element: outlines[0][0],
      gd: gd,
      prepFn: startDragGroupController,
      doneFn: endDragGroupController,
      clickFn: clickGroupController
    };
    dragElement.init(groupDragOptions[i]);
  }
};
function recordPositions(polygonsOut, polygonsIn) {
  for (var i = 0; i < polygonsIn.length; i++) {
    var cell = polygonsIn[i];
    polygonsOut[i] = [];
    for (var j = 0; j < cell.length; j++) {
      polygonsOut[i][j] = [];
      for (var k = 0; k < cell[j].length; k++) {
        polygonsOut[i][j][k] = cell[j][k];
      }
    }
  }
  return polygonsOut;
}
function getNextPoint(cell, j) {
  var x = cell[j][1];
  var y = cell[j][2];
  var len = cell.length;
  var nextJ, nextX, nextY;
  nextJ = (j + 1) % len;
  nextX = cell[nextJ][1];
  nextY = cell[nextJ][2];

  // avoid potential double points (closing points)
  if (nextX === x && nextY === y) {
    nextJ = (j + 2) % len;
    nextX = cell[nextJ][1];
    nextY = cell[nextJ][2];
  }
  return [nextJ, nextX, nextY];
}
function eraseActiveSelection(gd) {
  // Do not allow removal of selections on other dragmodes.
  // This ensures the user could still double click to
  // deselect all trace.selectedpoints,
  // if that's what they wanted.
  // Also double click to zoom back won't result in
  // any surprising selection removal.
  if (!selectMode(gd._fullLayout.dragmode)) return;
  clearOutlineControllers(gd);
  var id = gd._fullLayout._activeSelectionIndex;
  var selections = (gd.layout || {}).selections || [];
  if (id < selections.length) {
    var list = [];
    for (var q = 0; q < selections.length; q++) {
      if (q !== id) {
        list.push(selections[q]);
      }
    }
    delete gd._fullLayout._activeSelectionIndex;
    var erasedSelection = gd._fullLayout.selections[id];
    gd._fullLayout._deselect = {
      xref: erasedSelection.xref,
      yref: erasedSelection.yref
    };
    Registry.call('_guiRelayout', gd, {
      selections: list
    });
  }
}

/***/ }),

/***/ 4031:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var Axes = __webpack_require__(9298);
var readPaths = (__webpack_require__(165).readPaths);
var displayOutlines = __webpack_require__(2359);
var drawLabel = __webpack_require__(8100);
var clearOutlineControllers = (__webpack_require__(1873).clearOutlineControllers);
var Color = __webpack_require__(7901);
var Drawing = __webpack_require__(1424);
var arrayEditor = (__webpack_require__(4467).arrayEditor);
var dragElement = __webpack_require__(8569);
var setCursor = __webpack_require__(6964);
var constants = __webpack_require__(1459);
var helpers = __webpack_require__(477);
var getPathString = helpers.getPathString;

// Shapes are stored in gd.layout.shapes, an array of objects
// index can point to one item in this array,
//  or non-numeric to simply add a new one
//  or -1 to modify all existing
// opt can be the full options object, or one key (to be set to value)
//  or undefined to simply redraw
// if opt is blank, val can be 'add' or a full options object to add a new
//  annotation at that point in the array, or 'remove' to delete this one

module.exports = {
  draw: draw,
  drawOne: drawOne,
  eraseActiveShape: eraseActiveShape,
  drawLabel: drawLabel
};
function draw(gd) {
  var fullLayout = gd._fullLayout;

  // Remove previous shapes before drawing new in shapes in fullLayout.shapes
  fullLayout._shapeUpperLayer.selectAll('path').remove();
  fullLayout._shapeLowerLayer.selectAll('path').remove();
  fullLayout._shapeUpperLayer.selectAll('text').remove();
  fullLayout._shapeLowerLayer.selectAll('text').remove();
  for (var k in fullLayout._plots) {
    var shapelayer = fullLayout._plots[k].shapelayer;
    if (shapelayer) {
      shapelayer.selectAll('path').remove();
      shapelayer.selectAll('text').remove();
    }
  }
  for (var i = 0; i < fullLayout.shapes.length; i++) {
    if (fullLayout.shapes[i].visible === true) {
      drawOne(gd, i);
    }
  }

  // may need to resurrect this if we put text (LaTeX) in shapes
  // return Plots.previousPromises(gd);
}

function shouldSkipEdits(gd) {
  return !!gd._fullLayout._outlining;
}
function couldHaveActiveShape(gd) {
  // for now keep config.editable: true as it was before shape-drawing PR
  return !gd._context.edits.shapePosition;
}
function drawOne(gd, index) {
  // remove the existing shape if there is one.
  // because indices can change, we need to look in all shape layers
  gd._fullLayout._paperdiv.selectAll('.shapelayer [data-index="' + index + '"]').remove();
  var o = helpers.makeShapesOptionsAndPlotinfo(gd, index);
  var options = o.options;
  var plotinfo = o.plotinfo;

  // this shape is gone - quit now after deleting it
  // TODO: use d3 idioms instead of deleting and redrawing every time
  if (!options._input || options.visible !== true) return;
  if (options.layer !== 'below') {
    drawShape(gd._fullLayout._shapeUpperLayer);
  } else if (options.xref === 'paper' || options.yref === 'paper') {
    drawShape(gd._fullLayout._shapeLowerLayer);
  } else {
    if (plotinfo._hadPlotinfo) {
      var mainPlot = plotinfo.mainplotinfo || plotinfo;
      drawShape(mainPlot.shapelayer);
    } else {
      // Fall back to _shapeLowerLayer in case the requested subplot doesn't exist.
      // This can happen if you reference the shape to an x / y axis combination
      // that doesn't have any data on it (and layer is below)
      drawShape(gd._fullLayout._shapeLowerLayer);
    }
  }
  function drawShape(shapeLayer) {
    var d = getPathString(gd, options);
    var attrs = {
      'data-index': index,
      'fill-rule': options.fillrule,
      d: d
    };
    var opacity = options.opacity;
    var fillColor = options.fillcolor;
    var lineColor = options.line.width ? options.line.color : 'rgba(0,0,0,0)';
    var lineWidth = options.line.width;
    var lineDash = options.line.dash;
    if (!lineWidth && options.editable === true) {
      // ensure invisible border to activate the shape
      lineWidth = 5;
      lineDash = 'solid';
    }
    var isOpen = d[d.length - 1] !== 'Z';
    var isActiveShape = couldHaveActiveShape(gd) && options.editable && gd._fullLayout._activeShapeIndex === index;
    if (isActiveShape) {
      fillColor = isOpen ? 'rgba(0,0,0,0)' : gd._fullLayout.activeshape.fillcolor;
      opacity = gd._fullLayout.activeshape.opacity;
    }
    var shapeGroup = shapeLayer.append('g').classed('shape-group', true).attr({
      'data-index': index
    });
    var path = shapeGroup.append('path').attr(attrs).style('opacity', opacity).call(Color.stroke, lineColor).call(Color.fill, fillColor).call(Drawing.dashLine, lineDash, lineWidth);
    setClipPath(shapeGroup, gd, options);

    // Draw or clear the label
    drawLabel(gd, index, options, shapeGroup);
    var editHelpers;
    if (isActiveShape || gd._context.edits.shapePosition) editHelpers = arrayEditor(gd.layout, 'shapes', options);
    if (isActiveShape) {
      path.style({
        cursor: 'move'
      });
      var dragOptions = {
        element: path.node(),
        plotinfo: plotinfo,
        gd: gd,
        editHelpers: editHelpers,
        hasText: options.label.text || options.label.texttemplate,
        isActiveShape: true // i.e. to enable controllers
      };

      var polygons = readPaths(d, gd);
      // display polygons on the screen
      displayOutlines(polygons, path, dragOptions);
    } else {
      if (gd._context.edits.shapePosition) {
        setupDragElement(gd, path, options, index, shapeLayer, editHelpers);
      } else if (options.editable === true) {
        path.style('pointer-events', isOpen || Color.opacity(fillColor) * opacity <= 0.5 ? 'stroke' : 'all');
      }
    }
    path.node().addEventListener('click', function () {
      return activateShape(gd, path);
    });
  }
}
function setClipPath(shapePath, gd, shapeOptions) {
  // note that for layer="below" the clipAxes can be different from the
  // subplot we're drawing this in. This could cause problems if the shape
  // spans two subplots. See https://github.com/plotly/plotly.js/issues/1452
  //
  // if axis is 'paper' or an axis with " domain" appended, then there is no
  // clip axis
  var clipAxes = (shapeOptions.xref + shapeOptions.yref).replace(/paper/g, '').replace(/[xyz][1-9]* *domain/g, '');
  Drawing.setClipUrl(shapePath, clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null, gd);
}
function setupDragElement(gd, shapePath, shapeOptions, index, shapeLayer, editHelpers) {
  var MINWIDTH = 10;
  var MINHEIGHT = 10;
  var xPixelSized = shapeOptions.xsizemode === 'pixel';
  var yPixelSized = shapeOptions.ysizemode === 'pixel';
  var isLine = shapeOptions.type === 'line';
  var isPath = shapeOptions.type === 'path';
  var modifyItem = editHelpers.modifyItem;
  var x0, y0, x1, y1, xAnchor, yAnchor;
  var n0, s0, w0, e0, optN, optS, optW, optE;
  var pathIn;
  var shapeGroup = d3.select(shapePath.node().parentNode);

  // setup conversion functions
  var xa = Axes.getFromId(gd, shapeOptions.xref);
  var xRefType = Axes.getRefType(shapeOptions.xref);
  var ya = Axes.getFromId(gd, shapeOptions.yref);
  var yRefType = Axes.getRefType(shapeOptions.yref);
  var x2p = helpers.getDataToPixel(gd, xa, false, xRefType);
  var y2p = helpers.getDataToPixel(gd, ya, true, yRefType);
  var p2x = helpers.getPixelToData(gd, xa, false, xRefType);
  var p2y = helpers.getPixelToData(gd, ya, true, yRefType);
  var sensoryElement = obtainSensoryElement();
  var dragOptions = {
    element: sensoryElement.node(),
    gd: gd,
    prepFn: startDrag,
    doneFn: endDrag,
    clickFn: abortDrag
  };
  var dragMode;
  dragElement.init(dragOptions);
  sensoryElement.node().onmousemove = updateDragMode;
  function obtainSensoryElement() {
    return isLine ? createLineDragHandles() : shapePath;
  }
  function createLineDragHandles() {
    var minSensoryWidth = 10;
    var sensoryWidth = Math.max(shapeOptions.line.width, minSensoryWidth);

    // Helper shapes group
    // Note that by setting the `data-index` attr, it is ensured that
    // the helper group is purged in this modules `draw` function
    var g = shapeLayer.append('g').attr('data-index', index).attr('drag-helper', true);

    // Helper path for moving
    g.append('path').attr('d', shapePath.attr('d')).style({
      cursor: 'move',
      'stroke-width': sensoryWidth,
      'stroke-opacity': '0' // ensure not visible
    });

    // Helper circles for resizing
    var circleStyle = {
      'fill-opacity': '0' // ensure not visible
    };

    var circleRadius = Math.max(sensoryWidth / 2, minSensoryWidth);
    g.append('circle').attr({
      'data-line-point': 'start-point',
      cx: xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x0 : x2p(shapeOptions.x0),
      cy: yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y0 : y2p(shapeOptions.y0),
      r: circleRadius
    }).style(circleStyle).classed('cursor-grab', true);
    g.append('circle').attr({
      'data-line-point': 'end-point',
      cx: xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x1 : x2p(shapeOptions.x1),
      cy: yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y1 : y2p(shapeOptions.y1),
      r: circleRadius
    }).style(circleStyle).classed('cursor-grab', true);
    return g;
  }
  function updateDragMode(evt) {
    if (shouldSkipEdits(gd)) {
      dragMode = null;
      return;
    }
    if (isLine) {
      if (evt.target.tagName === 'path') {
        dragMode = 'move';
      } else {
        dragMode = evt.target.attributes['data-line-point'].value === 'start-point' ? 'resize-over-start-point' : 'resize-over-end-point';
      }
    } else {
      // element might not be on screen at time of setup,
      // so obtain bounding box here
      var dragBBox = dragOptions.element.getBoundingClientRect();

      // choose 'move' or 'resize'
      // based on initial position of cursor within the drag element
      var w = dragBBox.right - dragBBox.left;
      var h = dragBBox.bottom - dragBBox.top;
      var x = evt.clientX - dragBBox.left;
      var y = evt.clientY - dragBBox.top;
      var cursor = !isPath && w > MINWIDTH && h > MINHEIGHT && !evt.shiftKey ? dragElement.getCursor(x / w, 1 - y / h) : 'move';
      setCursor(shapePath, cursor);

      // possible values 'move', 'sw', 'w', 'se', 'e', 'ne', 'n', 'nw' and 'w'
      dragMode = cursor.split('-')[0];
    }
  }
  function startDrag(evt) {
    if (shouldSkipEdits(gd)) return;

    // setup update strings and initial values
    if (xPixelSized) {
      xAnchor = x2p(shapeOptions.xanchor);
    }
    if (yPixelSized) {
      yAnchor = y2p(shapeOptions.yanchor);
    }
    if (shapeOptions.type === 'path') {
      pathIn = shapeOptions.path;
    } else {
      x0 = xPixelSized ? shapeOptions.x0 : x2p(shapeOptions.x0);
      y0 = yPixelSized ? shapeOptions.y0 : y2p(shapeOptions.y0);
      x1 = xPixelSized ? shapeOptions.x1 : x2p(shapeOptions.x1);
      y1 = yPixelSized ? shapeOptions.y1 : y2p(shapeOptions.y1);
    }
    if (x0 < x1) {
      w0 = x0;
      optW = 'x0';
      e0 = x1;
      optE = 'x1';
    } else {
      w0 = x1;
      optW = 'x1';
      e0 = x0;
      optE = 'x0';
    }

    // For fixed size shapes take opposing direction of y-axis into account.
    // Hint: For data sized shapes this is done by the y2p function.
    if (!yPixelSized && y0 < y1 || yPixelSized && y0 > y1) {
      n0 = y0;
      optN = 'y0';
      s0 = y1;
      optS = 'y1';
    } else {
      n0 = y1;
      optN = 'y1';
      s0 = y0;
      optS = 'y0';
    }

    // setup dragMode and the corresponding handler
    updateDragMode(evt);
    renderVisualCues(shapeLayer, shapeOptions);
    deactivateClipPathTemporarily(shapePath, shapeOptions, gd);
    dragOptions.moveFn = dragMode === 'move' ? moveShape : resizeShape;
    dragOptions.altKey = evt.altKey;
  }
  function endDrag() {
    if (shouldSkipEdits(gd)) return;
    setCursor(shapePath);
    removeVisualCues(shapeLayer);

    // Don't rely on clipPath being activated during re-layout
    setClipPath(shapePath, gd, shapeOptions);
    Registry.call('_guiRelayout', gd, editHelpers.getUpdateObj());
  }
  function abortDrag() {
    if (shouldSkipEdits(gd)) return;
    removeVisualCues(shapeLayer);
  }
  function moveShape(dx, dy) {
    if (shapeOptions.type === 'path') {
      var noOp = function (coord) {
        return coord;
      };
      var moveX = noOp;
      var moveY = noOp;
      if (xPixelSized) {
        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));
      } else {
        moveX = function moveX(x) {
          return p2x(x2p(x) + dx);
        };
        if (xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);
      }
      if (yPixelSized) {
        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));
      } else {
        moveY = function moveY(y) {
          return p2y(y2p(y) + dy);
        };
        if (ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);
      }
      modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));
    } else {
      if (xPixelSized) {
        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));
      } else {
        modifyItem('x0', shapeOptions.x0 = p2x(x0 + dx));
        modifyItem('x1', shapeOptions.x1 = p2x(x1 + dx));
      }
      if (yPixelSized) {
        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));
      } else {
        modifyItem('y0', shapeOptions.y0 = p2y(y0 + dy));
        modifyItem('y1', shapeOptions.y1 = p2y(y1 + dy));
      }
    }
    shapePath.attr('d', getPathString(gd, shapeOptions));
    renderVisualCues(shapeLayer, shapeOptions);
    drawLabel(gd, index, shapeOptions, shapeGroup);
  }
  function resizeShape(dx, dy) {
    if (isPath) {
      // TODO: implement path resize, don't forget to update dragMode code
      var noOp = function (coord) {
        return coord;
      };
      var moveX = noOp;
      var moveY = noOp;
      if (xPixelSized) {
        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));
      } else {
        moveX = function moveX(x) {
          return p2x(x2p(x) + dx);
        };
        if (xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);
      }
      if (yPixelSized) {
        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));
      } else {
        moveY = function moveY(y) {
          return p2y(y2p(y) + dy);
        };
        if (ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);
      }
      modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));
    } else if (isLine) {
      if (dragMode === 'resize-over-start-point') {
        var newX0 = x0 + dx;
        var newY0 = yPixelSized ? y0 - dy : y0 + dy;
        modifyItem('x0', shapeOptions.x0 = xPixelSized ? newX0 : p2x(newX0));
        modifyItem('y0', shapeOptions.y0 = yPixelSized ? newY0 : p2y(newY0));
      } else if (dragMode === 'resize-over-end-point') {
        var newX1 = x1 + dx;
        var newY1 = yPixelSized ? y1 - dy : y1 + dy;
        modifyItem('x1', shapeOptions.x1 = xPixelSized ? newX1 : p2x(newX1));
        modifyItem('y1', shapeOptions.y1 = yPixelSized ? newY1 : p2y(newY1));
      }
    } else {
      var has = function (str) {
        return dragMode.indexOf(str) !== -1;
      };
      var hasN = has('n');
      var hasS = has('s');
      var hasW = has('w');
      var hasE = has('e');
      var newN = hasN ? n0 + dy : n0;
      var newS = hasS ? s0 + dy : s0;
      var newW = hasW ? w0 + dx : w0;
      var newE = hasE ? e0 + dx : e0;
      if (yPixelSized) {
        // Do things in opposing direction for y-axis.
        // Hint: for data-sized shapes the reversal of axis direction is done in p2y.
        if (hasN) newN = n0 - dy;
        if (hasS) newS = s0 - dy;
      }

      // Update shape eventually. Again, be aware of the
      // opposing direction of the y-axis of fixed size shapes.
      if (!yPixelSized && newS - newN > MINHEIGHT || yPixelSized && newN - newS > MINHEIGHT) {
        modifyItem(optN, shapeOptions[optN] = yPixelSized ? newN : p2y(newN));
        modifyItem(optS, shapeOptions[optS] = yPixelSized ? newS : p2y(newS));
      }
      if (newE - newW > MINWIDTH) {
        modifyItem(optW, shapeOptions[optW] = xPixelSized ? newW : p2x(newW));
        modifyItem(optE, shapeOptions[optE] = xPixelSized ? newE : p2x(newE));
      }
    }
    shapePath.attr('d', getPathString(gd, shapeOptions));
    renderVisualCues(shapeLayer, shapeOptions);
    drawLabel(gd, index, shapeOptions, shapeGroup);
  }
  function renderVisualCues(shapeLayer, shapeOptions) {
    if (xPixelSized || yPixelSized) {
      renderAnchor();
    }
    function renderAnchor() {
      var isNotPath = shapeOptions.type !== 'path';

      // d3 join with dummy data to satisfy d3 data-binding
      var visualCues = shapeLayer.selectAll('.visual-cue').data([0]);

      // Enter
      var strokeWidth = 1;
      visualCues.enter().append('path').attr({
        fill: '#fff',
        'fill-rule': 'evenodd',
        stroke: '#000',
        'stroke-width': strokeWidth
      }).classed('visual-cue', true);

      // Update
      var posX = x2p(xPixelSized ? shapeOptions.xanchor : Lib.midRange(isNotPath ? [shapeOptions.x0, shapeOptions.x1] : helpers.extractPathCoords(shapeOptions.path, constants.paramIsX)));
      var posY = y2p(yPixelSized ? shapeOptions.yanchor : Lib.midRange(isNotPath ? [shapeOptions.y0, shapeOptions.y1] : helpers.extractPathCoords(shapeOptions.path, constants.paramIsY)));
      posX = helpers.roundPositionForSharpStrokeRendering(posX, strokeWidth);
      posY = helpers.roundPositionForSharpStrokeRendering(posY, strokeWidth);
      if (xPixelSized && yPixelSized) {
        var crossPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 1 - strokeWidth) + 'h-8v2h8 v8h2v-8 h8v-2h-8 v-8h-2 Z';
        visualCues.attr('d', crossPath);
      } else if (xPixelSized) {
        var vBarPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 9 - strokeWidth) + 'v18 h2 v-18 Z';
        visualCues.attr('d', vBarPath);
      } else {
        var hBarPath = 'M' + (posX - 9 - strokeWidth) + ',' + (posY - 1 - strokeWidth) + 'h18 v2 h-18 Z';
        visualCues.attr('d', hBarPath);
      }
    }
  }
  function removeVisualCues(shapeLayer) {
    shapeLayer.selectAll('.visual-cue').remove();
  }
  function deactivateClipPathTemporarily(shapePath, shapeOptions, gd) {
    var xref = shapeOptions.xref;
    var yref = shapeOptions.yref;
    var xa = Axes.getFromId(gd, xref);
    var ya = Axes.getFromId(gd, yref);
    var clipAxes = '';
    if (xref !== 'paper' && !xa.autorange) clipAxes += xref;
    if (yref !== 'paper' && !ya.autorange) clipAxes += yref;
    Drawing.setClipUrl(shapePath, clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null, gd);
  }
}
function movePath(pathIn, moveX, moveY) {
  return pathIn.replace(constants.segmentRE, function (segment) {
    var paramNumber = 0;
    var segmentType = segment.charAt(0);
    var xParams = constants.paramIsX[segmentType];
    var yParams = constants.paramIsY[segmentType];
    var nParams = constants.numParams[segmentType];
    var paramString = segment.substr(1).replace(constants.paramRE, function (param) {
      if (paramNumber >= nParams) return param;
      if (xParams[paramNumber]) param = moveX(param);else if (yParams[paramNumber]) param = moveY(param);
      paramNumber++;
      return param;
    });
    return segmentType + paramString;
  });
}
function activateShape(gd, path) {
  if (!couldHaveActiveShape(gd)) return;
  var element = path.node();
  var id = +element.getAttribute('data-index');
  if (id >= 0) {
    // deactivate if already active
    if (id === gd._fullLayout._activeShapeIndex) {
      deactivateShape(gd);
      return;
    }
    gd._fullLayout._activeShapeIndex = id;
    gd._fullLayout._deactivateShape = deactivateShape;
    draw(gd);
  }
}
function deactivateShape(gd) {
  if (!couldHaveActiveShape(gd)) return;
  var id = gd._fullLayout._activeShapeIndex;
  if (id >= 0) {
    clearOutlineControllers(gd);
    delete gd._fullLayout._activeShapeIndex;
    draw(gd);
  }
}
function eraseActiveShape(gd) {
  if (!couldHaveActiveShape(gd)) return;
  clearOutlineControllers(gd);
  var id = gd._fullLayout._activeShapeIndex;
  var shapes = (gd.layout || {}).shapes || [];
  if (id < shapes.length) {
    var list = [];
    for (var q = 0; q < shapes.length; q++) {
      if (q !== id) {
        list.push(shapes[q]);
      }
    }
    delete gd._fullLayout._activeShapeIndex;
    return Registry.call('_guiRelayout', gd, {
      shapes: list
    });
  }
}

/***/ }),

/***/ 9241:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var overrideAll = (__webpack_require__(962).overrideAll);
var basePlotAttributes = __webpack_require__(9012);
var fontAttrs = __webpack_require__(1940);
var dash = (__webpack_require__(9952)/* .dash */ .P);
var extendFlat = (__webpack_require__(1426).extendFlat);
var shapeTexttemplateAttrs = (__webpack_require__(5386)/* .shapeTexttemplateAttrs */ .R);
var shapeLabelTexttemplateVars = __webpack_require__(7281);
module.exports = overrideAll({
  newshape: {
    visible: extendFlat({}, basePlotAttributes.visible, {}),
    showlegend: {
      valType: 'boolean',
      dflt: false
    },
    legend: extendFlat({}, basePlotAttributes.legend, {}),
    legendgroup: extendFlat({}, basePlotAttributes.legendgroup, {}),
    legendgrouptitle: {
      text: extendFlat({}, basePlotAttributes.legendgrouptitle.text, {}),
      font: fontAttrs({})
    },
    legendrank: extendFlat({}, basePlotAttributes.legendrank, {}),
    legendwidth: extendFlat({}, basePlotAttributes.legendwidth, {}),
    line: {
      color: {
        valType: 'color'
      },
      width: {
        valType: 'number',
        min: 0,
        dflt: 4
      },
      dash: extendFlat({}, dash, {
        dflt: 'solid'
      })
    },
    fillcolor: {
      valType: 'color',
      dflt: 'rgba(0,0,0,0)'
    },
    fillrule: {
      valType: 'enumerated',
      values: ['evenodd', 'nonzero'],
      dflt: 'evenodd'
    },
    opacity: {
      valType: 'number',
      min: 0,
      max: 1,
      dflt: 1
    },
    layer: {
      valType: 'enumerated',
      values: ['below', 'above'],
      dflt: 'above'
    },
    drawdirection: {
      valType: 'enumerated',
      values: ['ortho', 'horizontal', 'vertical', 'diagonal'],
      dflt: 'diagonal'
    },
    name: extendFlat({}, basePlotAttributes.name, {}),
    label: {
      text: {
        valType: 'string',
        dflt: ''
      },
      texttemplate: shapeTexttemplateAttrs({
        newshape: true
      }, {
        keys: Object.keys(shapeLabelTexttemplateVars)
      }),
      font: fontAttrs({}),
      textposition: {
        valType: 'enumerated',
        values: ['top left', 'top center', 'top right', 'middle left', 'middle center', 'middle right', 'bottom left', 'bottom center', 'bottom right', 'start', 'middle', 'end']
      },
      textangle: {
        valType: 'angle',
        dflt: 'auto'
      },
      xanchor: {
        valType: 'enumerated',
        values: ['auto', 'left', 'center', 'right'],
        dflt: 'auto'
      },
      yanchor: {
        valType: 'enumerated',
        values: ['top', 'middle', 'bottom']
      },
      padding: {
        valType: 'number',
        dflt: 3,
        min: 0
      }
    }
  },
  activeshape: {
    fillcolor: {
      valType: 'color',
      dflt: 'rgb(255,0,255)'
    },
    opacity: {
      valType: 'number',
      min: 0,
      max: 1,
      dflt: 0.5
    }
  }
}, 'none', 'from-root');

/***/ }),

/***/ 9995:
/***/ (function(module) {

"use strict";


var CIRCLE_SIDES = 32; // should be divisible by 4

module.exports = {
  CIRCLE_SIDES: CIRCLE_SIDES,
  i000: 0,
  i090: CIRCLE_SIDES / 4,
  i180: CIRCLE_SIDES / 2,
  i270: CIRCLE_SIDES / 4 * 3,
  cos45: Math.cos(Math.PI / 4),
  sin45: Math.sin(Math.PI / 4),
  SQRT2: Math.sqrt(2)
};

/***/ }),

/***/ 5547:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Color = __webpack_require__(7901);
var Lib = __webpack_require__(1828);
function dfltLabelYanchor(isLine, labelTextPosition) {
  // If shape is a line, default y-anchor is 'bottom' (so that text is above line by default)
  // Otherwise, default y-anchor is equal to y-component of `textposition`
  // (so that text is positioned inside shape bounding box by default)
  return isLine ? 'bottom' : labelTextPosition.indexOf('top') !== -1 ? 'top' : labelTextPosition.indexOf('bottom') !== -1 ? 'bottom' : 'middle';
}
module.exports = function supplyDrawNewShapeDefaults(layoutIn, layoutOut, coerce) {
  coerce('newshape.visible');
  coerce('newshape.name');
  coerce('newshape.showlegend');
  coerce('newshape.legend');
  coerce('newshape.legendwidth');
  coerce('newshape.legendgroup');
  coerce('newshape.legendgrouptitle.text');
  Lib.coerceFont(coerce, 'newshape.legendgrouptitle.font');
  coerce('newshape.legendrank');
  coerce('newshape.drawdirection');
  coerce('newshape.layer');
  coerce('newshape.fillcolor');
  coerce('newshape.fillrule');
  coerce('newshape.opacity');
  var newshapeLineWidth = coerce('newshape.line.width');
  if (newshapeLineWidth) {
    var bgcolor = (layoutIn || {}).plot_bgcolor || '#FFF';
    coerce('newshape.line.color', Color.contrast(bgcolor));
    coerce('newshape.line.dash');
  }
  var isLine = layoutIn.dragmode === 'drawline';
  var labelText = coerce('newshape.label.text');
  var labelTextTemplate = coerce('newshape.label.texttemplate');
  if (labelText || labelTextTemplate) {
    coerce('newshape.label.textangle');
    var labelTextPosition = coerce('newshape.label.textposition', isLine ? 'middle' : 'middle center');
    coerce('newshape.label.xanchor');
    coerce('newshape.label.yanchor', dfltLabelYanchor(isLine, labelTextPosition));
    coerce('newshape.label.padding');
    Lib.coerceFont(coerce, 'newshape.label.font', layoutOut.font);
  }
  coerce('activeshape.fillcolor');
  coerce('activeshape.opacity');
};

/***/ }),

/***/ 165:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var parseSvgPath = __webpack_require__(5616);
var constants = __webpack_require__(9995);
var CIRCLE_SIDES = constants.CIRCLE_SIDES;
var SQRT2 = constants.SQRT2;
var cartesianHelpers = __webpack_require__(5549);
var p2r = cartesianHelpers.p2r;
var r2p = cartesianHelpers.r2p;
var iC = [0, 3, 4, 5, 6, 1, 2];
var iQS = [0, 3, 4, 1, 2];
exports.writePaths = function (polygons) {
  var nI = polygons.length;
  if (!nI) return 'M0,0Z';
  var str = '';
  for (var i = 0; i < nI; i++) {
    var nJ = polygons[i].length;
    for (var j = 0; j < nJ; j++) {
      var w = polygons[i][j][0];
      if (w === 'Z') {
        str += 'Z';
      } else {
        var nK = polygons[i][j].length;
        for (var k = 0; k < nK; k++) {
          var realK = k;
          if (w === 'Q' || w === 'S') {
            realK = iQS[k];
          } else if (w === 'C') {
            realK = iC[k];
          }
          str += polygons[i][j][realK];
          if (k > 0 && k < nK - 1) {
            str += ',';
          }
        }
      }
    }
  }
  return str;
};
exports.readPaths = function (str, gd, plotinfo, isActiveShape) {
  var cmd = parseSvgPath(str);
  var polys = [];
  var n = -1;
  var newPoly = function () {
    n++;
    polys[n] = [];
  };
  var k;
  var x = 0;
  var y = 0;
  var initX;
  var initY;
  var recStart = function () {
    initX = x;
    initY = y;
  };
  recStart();
  for (var i = 0; i < cmd.length; i++) {
    var newPos = [];
    var x1, x2, y1, y2; // i.e. extra params for curves

    var c = cmd[i][0];
    var w = c;
    switch (c) {
      case 'M':
        newPoly();
        x = +cmd[i][1];
        y = +cmd[i][2];
        newPos.push([w, x, y]);
        recStart();
        break;
      case 'Q':
      case 'S':
        x1 = +cmd[i][1];
        y1 = +cmd[i][2];
        x = +cmd[i][3];
        y = +cmd[i][4];
        newPos.push([w, x, y, x1, y1]); // -> iQS order
        break;
      case 'C':
        x1 = +cmd[i][1];
        y1 = +cmd[i][2];
        x2 = +cmd[i][3];
        y2 = +cmd[i][4];
        x = +cmd[i][5];
        y = +cmd[i][6];
        newPos.push([w, x, y, x1, y1, x2, y2]); // -> iC order
        break;
      case 'T':
      case 'L':
        x = +cmd[i][1];
        y = +cmd[i][2];
        newPos.push([w, x, y]);
        break;
      case 'H':
        w = 'L'; // convert to line (for now)
        x = +cmd[i][1];
        newPos.push([w, x, y]);
        break;
      case 'V':
        w = 'L'; // convert to line (for now)
        y = +cmd[i][1];
        newPos.push([w, x, y]);
        break;
      case 'A':
        w = 'L'; // convert to line to handle circle
        var rx = +cmd[i][1];
        var ry = +cmd[i][2];
        if (!+cmd[i][4]) {
          rx = -rx;
          ry = -ry;
        }
        var cenX = x - rx;
        var cenY = y;
        for (k = 1; k <= CIRCLE_SIDES / 2; k++) {
          var t = 2 * Math.PI * k / CIRCLE_SIDES;
          newPos.push([w, cenX + rx * Math.cos(t), cenY + ry * Math.sin(t)]);
        }
        break;
      case 'Z':
        if (x !== initX || y !== initY) {
          x = initX;
          y = initY;
          newPos.push([w, x, y]);
        }
        break;
    }
    var domain = (plotinfo || {}).domain;
    var size = gd._fullLayout._size;
    var xPixelSized = plotinfo && plotinfo.xsizemode === 'pixel';
    var yPixelSized = plotinfo && plotinfo.ysizemode === 'pixel';
    var noOffset = isActiveShape === false;
    for (var j = 0; j < newPos.length; j++) {
      for (k = 0; k + 2 < 7; k += 2) {
        var _x = newPos[j][k + 1];
        var _y = newPos[j][k + 2];
        if (_x === undefined || _y === undefined) continue;
        // keep track of end point for Z
        x = _x;
        y = _y;
        if (plotinfo) {
          if (plotinfo.xaxis && plotinfo.xaxis.p2r) {
            if (noOffset) _x -= plotinfo.xaxis._offset;
            if (xPixelSized) {
              _x = r2p(plotinfo.xaxis, plotinfo.xanchor) + _x;
            } else {
              _x = p2r(plotinfo.xaxis, _x);
            }
          } else {
            if (noOffset) _x -= size.l;
            if (domain) _x = domain.x[0] + _x / size.w;else _x = _x / size.w;
          }
          if (plotinfo.yaxis && plotinfo.yaxis.p2r) {
            if (noOffset) _y -= plotinfo.yaxis._offset;
            if (yPixelSized) {
              _y = r2p(plotinfo.yaxis, plotinfo.yanchor) - _y;
            } else {
              _y = p2r(plotinfo.yaxis, _y);
            }
          } else {
            if (noOffset) _y -= size.t;
            if (domain) _y = domain.y[1] - _y / size.h;else _y = 1 - _y / size.h;
          }
        }
        newPos[j][k + 1] = _x;
        newPos[j][k + 2] = _y;
      }
      polys[n].push(newPos[j].slice());
    }
  }
  return polys;
};
function almostEq(a, b) {
  return Math.abs(a - b) <= 1e-6;
}
function dist(a, b) {
  var dx = b[1] - a[1];
  var dy = b[2] - a[2];
  return Math.sqrt(dx * dx + dy * dy);
}
exports.pointsOnRectangle = function (cell) {
  var len = cell.length;
  if (len !== 5) return false;
  for (var j = 1; j < 3; j++) {
    var e01 = cell[0][j] - cell[1][j];
    var e32 = cell[3][j] - cell[2][j];
    if (!almostEq(e01, e32)) return false;
    var e03 = cell[0][j] - cell[3][j];
    var e12 = cell[1][j] - cell[2][j];
    if (!almostEq(e03, e12)) return false;
  }

  // N.B. rotated rectangles are not valid rects since rotation is not supported in shapes for now.
  if (!almostEq(cell[0][1], cell[1][1]) && !almostEq(cell[0][1], cell[3][1])) return false;

  // reject cases with zero area
  return !!(dist(cell[0], cell[1]) * dist(cell[0], cell[3]));
};
exports.pointsOnEllipse = function (cell) {
  var len = cell.length;
  if (len !== CIRCLE_SIDES + 1) return false;

  // opposite diagonals should be the same
  len = CIRCLE_SIDES;
  for (var i = 0; i < len; i++) {
    var k = (len * 2 - i) % len;
    var k2 = (len / 2 + k) % len;
    var i2 = (len / 2 + i) % len;
    if (!almostEq(dist(cell[i], cell[i2]), dist(cell[k], cell[k2]))) return false;
  }
  return true;
};
exports.handleEllipse = function (isEllipse, start, end) {
  if (!isEllipse) return [start, end]; // i.e. case of line

  var pos = exports.ellipseOver({
    x0: start[0],
    y0: start[1],
    x1: end[0],
    y1: end[1]
  });
  var cx = (pos.x1 + pos.x0) / 2;
  var cy = (pos.y1 + pos.y0) / 2;
  var rx = (pos.x1 - pos.x0) / 2;
  var ry = (pos.y1 - pos.y0) / 2;

  // make a circle when one dimension is zero
  if (!rx) rx = ry = ry / SQRT2;
  if (!ry) ry = rx = rx / SQRT2;
  var cell = [];
  for (var i = 0; i < CIRCLE_SIDES; i++) {
    var t = i * 2 * Math.PI / CIRCLE_SIDES;
    cell.push([cx + rx * Math.cos(t), cy + ry * Math.sin(t)]);
  }
  return cell;
};
exports.ellipseOver = function (pos) {
  var x0 = pos.x0;
  var y0 = pos.y0;
  var x1 = pos.x1;
  var y1 = pos.y1;
  var dx = x1 - x0;
  var dy = y1 - y0;
  x0 -= dx;
  y0 -= dy;
  var cx = (x0 + x1) / 2;
  var cy = (y0 + y1) / 2;
  var scale = SQRT2;
  dx *= scale;
  dy *= scale;
  return {
    x0: cx - dx,
    y0: cy - dy,
    x1: cx + dx,
    y1: cy + dy
  };
};
exports.fixDatesForPaths = function (polygons, xaxis, yaxis) {
  var xIsDate = xaxis.type === 'date';
  var yIsDate = yaxis.type === 'date';
  if (!xIsDate && !yIsDate) return polygons;
  for (var i = 0; i < polygons.length; i++) {
    for (var j = 0; j < polygons[i].length; j++) {
      for (var k = 0; k + 2 < polygons[i][j].length; k += 2) {
        if (xIsDate) polygons[i][j][k + 1] = polygons[i][j][k + 1].replace(' ', '_');
        if (yIsDate) polygons[i][j][k + 2] = polygons[i][j][k + 2].replace(' ', '_');
      }
    }
  }
  return polygons;
};

/***/ }),

/***/ 551:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var dragHelpers = __webpack_require__(4505);
var drawMode = dragHelpers.drawMode;
var openMode = dragHelpers.openMode;
var constants = __webpack_require__(9995);
var i000 = constants.i000;
var i090 = constants.i090;
var i180 = constants.i180;
var i270 = constants.i270;
var cos45 = constants.cos45;
var sin45 = constants.sin45;
var cartesianHelpers = __webpack_require__(5549);
var p2r = cartesianHelpers.p2r;
var r2p = cartesianHelpers.r2p;
var handleOutline = __webpack_require__(1873);
var clearOutline = handleOutline.clearOutline;
var helpers = __webpack_require__(165);
var readPaths = helpers.readPaths;
var writePaths = helpers.writePaths;
var ellipseOver = helpers.ellipseOver;
var fixDatesForPaths = helpers.fixDatesForPaths;
function newShapes(outlines, dragOptions) {
  if (!outlines.length) return;
  var e = outlines[0][0]; // pick first
  if (!e) return;
  var gd = dragOptions.gd;
  var isActiveShape = dragOptions.isActiveShape;
  var dragmode = dragOptions.dragmode;
  var shapes = (gd.layout || {}).shapes || [];
  if (!drawMode(dragmode) && isActiveShape !== undefined) {
    var id = gd._fullLayout._activeShapeIndex;
    if (id < shapes.length) {
      switch (gd._fullLayout.shapes[id].type) {
        case 'rect':
          dragmode = 'drawrect';
          break;
        case 'circle':
          dragmode = 'drawcircle';
          break;
        case 'line':
          dragmode = 'drawline';
          break;
        case 'path':
          var path = shapes[id].path || '';
          if (path[path.length - 1] === 'Z') {
            dragmode = 'drawclosedpath';
          } else {
            dragmode = 'drawopenpath';
          }
          break;
      }
    }
  }
  var newShape = createShapeObj(outlines, dragOptions, dragmode);
  clearOutline(gd);
  var editHelpers = dragOptions.editHelpers;
  var modifyItem = (editHelpers || {}).modifyItem;
  var allShapes = [];
  for (var q = 0; q < shapes.length; q++) {
    var beforeEdit = gd._fullLayout.shapes[q];
    allShapes[q] = beforeEdit._input;
    if (isActiveShape !== undefined && q === gd._fullLayout._activeShapeIndex) {
      var afterEdit = newShape;
      switch (beforeEdit.type) {
        case 'line':
        case 'rect':
        case 'circle':
          modifyItem('x0', afterEdit.x0);
          modifyItem('x1', afterEdit.x1);
          modifyItem('y0', afterEdit.y0);
          modifyItem('y1', afterEdit.y1);
          break;
        case 'path':
          modifyItem('path', afterEdit.path);
          break;
      }
    }
  }
  if (isActiveShape === undefined) {
    allShapes.push(newShape); // add new shape
    return allShapes;
  }
  return editHelpers ? editHelpers.getUpdateObj() : {};
}
function createShapeObj(outlines, dragOptions, dragmode) {
  var e = outlines[0][0]; // pick first outline
  var gd = dragOptions.gd;
  var d = e.getAttribute('d');
  var newStyle = gd._fullLayout.newshape;
  var plotinfo = dragOptions.plotinfo;
  var isActiveShape = dragOptions.isActiveShape;
  var xaxis = plotinfo.xaxis;
  var yaxis = plotinfo.yaxis;
  var xPaper = !!plotinfo.domain || !plotinfo.xaxis;
  var yPaper = !!plotinfo.domain || !plotinfo.yaxis;
  var isOpenMode = openMode(dragmode);
  var polygons = readPaths(d, gd, plotinfo, isActiveShape);
  var newShape = {
    editable: true,
    visible: newStyle.visible,
    name: newStyle.name,
    showlegend: newStyle.showlegend,
    legend: newStyle.legend,
    legendwidth: newStyle.legendwidth,
    legendgroup: newStyle.legendgroup,
    legendgrouptitle: {
      text: newStyle.legendgrouptitle.text,
      font: newStyle.legendgrouptitle.font
    },
    legendrank: newStyle.legendrank,
    label: newStyle.label,
    xref: xPaper ? 'paper' : xaxis._id,
    yref: yPaper ? 'paper' : yaxis._id,
    layer: newStyle.layer,
    opacity: newStyle.opacity,
    line: {
      color: newStyle.line.color,
      width: newStyle.line.width,
      dash: newStyle.line.dash
    }
  };
  if (!isOpenMode) {
    newShape.fillcolor = newStyle.fillcolor;
    newShape.fillrule = newStyle.fillrule;
  }
  var cell;
  // line, rect and circle can be in one cell
  // only define cell if there is single cell
  if (polygons.length === 1) cell = polygons[0];
  if (cell && cell.length === 5 &&
  // ensure we only have 4 corners for a rect
  dragmode === 'drawrect') {
    newShape.type = 'rect';
    newShape.x0 = cell[0][1];
    newShape.y0 = cell[0][2];
    newShape.x1 = cell[2][1];
    newShape.y1 = cell[2][2];
  } else if (cell && dragmode === 'drawline') {
    newShape.type = 'line';
    newShape.x0 = cell[0][1];
    newShape.y0 = cell[0][2];
    newShape.x1 = cell[1][1];
    newShape.y1 = cell[1][2];
  } else if (cell && dragmode === 'drawcircle') {
    newShape.type = 'circle'; // an ellipse!

    var xA = cell[i000][1];
    var xB = cell[i090][1];
    var xC = cell[i180][1];
    var xD = cell[i270][1];
    var yA = cell[i000][2];
    var yB = cell[i090][2];
    var yC = cell[i180][2];
    var yD = cell[i270][2];
    var xDateOrLog = plotinfo.xaxis && (plotinfo.xaxis.type === 'date' || plotinfo.xaxis.type === 'log');
    var yDateOrLog = plotinfo.yaxis && (plotinfo.yaxis.type === 'date' || plotinfo.yaxis.type === 'log');
    if (xDateOrLog) {
      xA = r2p(plotinfo.xaxis, xA);
      xB = r2p(plotinfo.xaxis, xB);
      xC = r2p(plotinfo.xaxis, xC);
      xD = r2p(plotinfo.xaxis, xD);
    }
    if (yDateOrLog) {
      yA = r2p(plotinfo.yaxis, yA);
      yB = r2p(plotinfo.yaxis, yB);
      yC = r2p(plotinfo.yaxis, yC);
      yD = r2p(plotinfo.yaxis, yD);
    }
    var x0 = (xB + xD) / 2;
    var y0 = (yA + yC) / 2;
    var rx = (xD - xB + xC - xA) / 2;
    var ry = (yD - yB + yC - yA) / 2;
    var pos = ellipseOver({
      x0: x0,
      y0: y0,
      x1: x0 + rx * cos45,
      y1: y0 + ry * sin45
    });
    if (xDateOrLog) {
      pos.x0 = p2r(plotinfo.xaxis, pos.x0);
      pos.x1 = p2r(plotinfo.xaxis, pos.x1);
    }
    if (yDateOrLog) {
      pos.y0 = p2r(plotinfo.yaxis, pos.y0);
      pos.y1 = p2r(plotinfo.yaxis, pos.y1);
    }
    newShape.x0 = pos.x0;
    newShape.y0 = pos.y0;
    newShape.x1 = pos.x1;
    newShape.y1 = pos.y1;
  } else {
    newShape.type = 'path';
    if (xaxis && yaxis) fixDatesForPaths(polygons, xaxis, yaxis);
    newShape.path = writePaths(polygons);
    cell = null;
  }
  return newShape;
}
module.exports = {
  newShapes: newShapes,
  createShapeObj: createShapeObj
};

/***/ }),

/***/ 1873:
/***/ (function(module) {

"use strict";


function clearOutlineControllers(gd) {
  var zoomLayer = gd._fullLayout._zoomlayer;
  if (zoomLayer) {
    zoomLayer.selectAll('.outline-controllers').remove();
  }
}
function clearOutline(gd) {
  var zoomLayer = gd._fullLayout._zoomlayer;
  if (zoomLayer) {
    // until we get around to persistent selections, remove the outline
    // here. The selection itself will be removed when the plot redraws
    // at the end.
    zoomLayer.selectAll('.select-outline').remove();
  }
  gd._fullLayout._outlining = false;
}
module.exports = {
  clearOutlineControllers: clearOutlineControllers,
  clearOutline: clearOutline
};

/***/ }),

/***/ 477:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var constants = __webpack_require__(1459);
var Lib = __webpack_require__(1828);
var Axes = __webpack_require__(9298);

// special position conversion functions... category axis positions can't be
// specified by their data values, because they don't make a continuous mapping.
// so these have to be specified in terms of the category serial numbers,
// but can take fractional values. Other axis types we specify position based on
// the actual data values.
// TODO: in V3.0 (when log axis ranges are in data units) range and shape position
// will be identical, so rangeToShapePosition and shapePositionToRange can be
// removed entirely.

exports.rangeToShapePosition = function (ax) {
  return ax.type === 'log' ? ax.r2d : function (v) {
    return v;
  };
};
exports.shapePositionToRange = function (ax) {
  return ax.type === 'log' ? ax.d2r : function (v) {
    return v;
  };
};
exports.decodeDate = function (convertToPx) {
  return function (v) {
    if (v.replace) v = v.replace('_', ' ');
    return convertToPx(v);
  };
};
exports.encodeDate = function (convertToDate) {
  return function (v) {
    return convertToDate(v).replace(' ', '_');
  };
};
exports.extractPathCoords = function (path, paramsToUse, isRaw) {
  var extractedCoordinates = [];
  var segments = path.match(constants.segmentRE);
  segments.forEach(function (segment) {
    var relevantParamIdx = paramsToUse[segment.charAt(0)].drawn;
    if (relevantParamIdx === undefined) return;
    var params = segment.substr(1).match(constants.paramRE);
    if (!params || params.length < relevantParamIdx) return;
    var str = params[relevantParamIdx];
    var pos = isRaw ? str : Lib.cleanNumber(str);
    extractedCoordinates.push(pos);
  });
  return extractedCoordinates;
};
exports.getDataToPixel = function (gd, axis, isVertical, refType) {
  var gs = gd._fullLayout._size;
  var dataToPixel;
  if (axis) {
    if (refType === 'domain') {
      dataToPixel = function (v) {
        return axis._length * (isVertical ? 1 - v : v) + axis._offset;
      };
    } else {
      var d2r = exports.shapePositionToRange(axis);
      dataToPixel = function (v) {
        return axis._offset + axis.r2p(d2r(v, true));
      };
      if (axis.type === 'date') dataToPixel = exports.decodeDate(dataToPixel);
    }
  } else if (isVertical) {
    dataToPixel = function (v) {
      return gs.t + gs.h * (1 - v);
    };
  } else {
    dataToPixel = function (v) {
      return gs.l + gs.w * v;
    };
  }
  return dataToPixel;
};
exports.getPixelToData = function (gd, axis, isVertical, opt) {
  var gs = gd._fullLayout._size;
  var pixelToData;
  if (axis) {
    if (opt === 'domain') {
      pixelToData = function (p) {
        var q = (p - axis._offset) / axis._length;
        return isVertical ? 1 - q : q;
      };
    } else {
      var r2d = exports.rangeToShapePosition(axis);
      pixelToData = function (p) {
        return r2d(axis.p2r(p - axis._offset));
      };
    }
  } else if (isVertical) {
    pixelToData = function (p) {
      return 1 - (p - gs.t) / gs.h;
    };
  } else {
    pixelToData = function (p) {
      return (p - gs.l) / gs.w;
    };
  }
  return pixelToData;
};

/**
 * Based on the given stroke width, rounds the passed
 * position value to represent either a full or half pixel.
 *
 * In case of an odd stroke width (e.g. 1), this measure ensures
 * that a stroke positioned at the returned position isn't rendered
 * blurry due to anti-aliasing.
 *
 * In case of an even stroke width (e.g. 2), this measure ensures
 * that the position value is transformed to a full pixel value
 * so that anti-aliasing doesn't take effect either.
 *
 * @param {number} pos The raw position value to be transformed
 * @param {number} strokeWidth The stroke width
 * @returns {number} either an integer or a .5 decimal number
 */
exports.roundPositionForSharpStrokeRendering = function (pos, strokeWidth) {
  var strokeWidthIsOdd = Math.round(strokeWidth % 2) === 1;
  var posValAsInt = Math.round(pos);
  return strokeWidthIsOdd ? posValAsInt + 0.5 : posValAsInt;
};
exports.makeShapesOptionsAndPlotinfo = function (gd, index) {
  var options = gd._fullLayout.shapes[index] || {};
  var plotinfo = gd._fullLayout._plots[options.xref + options.yref];
  var hasPlotinfo = !!plotinfo;
  if (hasPlotinfo) {
    plotinfo._hadPlotinfo = true;
  } else {
    plotinfo = {};
    if (options.xref && options.xref !== 'paper') plotinfo.xaxis = gd._fullLayout[options.xref + 'axis'];
    if (options.yref && options.yref !== 'paper') plotinfo.yaxis = gd._fullLayout[options.yref + 'axis'];
  }
  plotinfo.xsizemode = options.xsizemode;
  plotinfo.ysizemode = options.ysizemode;
  plotinfo.xanchor = options.xanchor;
  plotinfo.yanchor = options.yanchor;
  return {
    options: options,
    plotinfo: plotinfo
  };
};

// TODO: move to selections helpers?
exports.makeSelectionsOptionsAndPlotinfo = function (gd, index) {
  var options = gd._fullLayout.selections[index] || {};
  var plotinfo = gd._fullLayout._plots[options.xref + options.yref];
  var hasPlotinfo = !!plotinfo;
  if (hasPlotinfo) {
    plotinfo._hadPlotinfo = true;
  } else {
    plotinfo = {};
    if (options.xref) plotinfo.xaxis = gd._fullLayout[options.xref + 'axis'];
    if (options.yref) plotinfo.yaxis = gd._fullLayout[options.yref + 'axis'];
  }
  return {
    options: options,
    plotinfo: plotinfo
  };
};
exports.getPathString = function (gd, options) {
  var type = options.type;
  var xRefType = Axes.getRefType(options.xref);
  var yRefType = Axes.getRefType(options.yref);
  var xa = Axes.getFromId(gd, options.xref);
  var ya = Axes.getFromId(gd, options.yref);
  var gs = gd._fullLayout._size;
  var x2r, x2p, y2r, y2p;
  var x0, x1, y0, y1;
  if (xa) {
    if (xRefType === 'domain') {
      x2p = function (v) {
        return xa._offset + xa._length * v;
      };
    } else {
      x2r = exports.shapePositionToRange(xa);
      x2p = function (v) {
        return xa._offset + xa.r2p(x2r(v, true));
      };
    }
  } else {
    x2p = function (v) {
      return gs.l + gs.w * v;
    };
  }
  if (ya) {
    if (yRefType === 'domain') {
      y2p = function (v) {
        return ya._offset + ya._length * (1 - v);
      };
    } else {
      y2r = exports.shapePositionToRange(ya);
      y2p = function (v) {
        return ya._offset + ya.r2p(y2r(v, true));
      };
    }
  } else {
    y2p = function (v) {
      return gs.t + gs.h * (1 - v);
    };
  }
  if (type === 'path') {
    if (xa && xa.type === 'date') x2p = exports.decodeDate(x2p);
    if (ya && ya.type === 'date') y2p = exports.decodeDate(y2p);
    return convertPath(options, x2p, y2p);
  }
  if (options.xsizemode === 'pixel') {
    var xAnchorPos = x2p(options.xanchor);
    x0 = xAnchorPos + options.x0;
    x1 = xAnchorPos + options.x1;
  } else {
    x0 = x2p(options.x0);
    x1 = x2p(options.x1);
  }
  if (options.ysizemode === 'pixel') {
    var yAnchorPos = y2p(options.yanchor);
    y0 = yAnchorPos - options.y0;
    y1 = yAnchorPos - options.y1;
  } else {
    y0 = y2p(options.y0);
    y1 = y2p(options.y1);
  }
  if (type === 'line') return 'M' + x0 + ',' + y0 + 'L' + x1 + ',' + y1;
  if (type === 'rect') return 'M' + x0 + ',' + y0 + 'H' + x1 + 'V' + y1 + 'H' + x0 + 'Z';

  // circle
  var cx = (x0 + x1) / 2;
  var cy = (y0 + y1) / 2;
  var rx = Math.abs(cx - x0);
  var ry = Math.abs(cy - y0);
  var rArc = 'A' + rx + ',' + ry;
  var rightPt = cx + rx + ',' + cy;
  var topPt = cx + ',' + (cy - ry);
  return 'M' + rightPt + rArc + ' 0 1,1 ' + topPt + rArc + ' 0 0,1 ' + rightPt + 'Z';
};
function convertPath(options, x2p, y2p) {
  var pathIn = options.path;
  var xSizemode = options.xsizemode;
  var ySizemode = options.ysizemode;
  var xAnchor = options.xanchor;
  var yAnchor = options.yanchor;
  return pathIn.replace(constants.segmentRE, function (segment) {
    var paramNumber = 0;
    var segmentType = segment.charAt(0);
    var xParams = constants.paramIsX[segmentType];
    var yParams = constants.paramIsY[segmentType];
    var nParams = constants.numParams[segmentType];
    var paramString = segment.substr(1).replace(constants.paramRE, function (param) {
      if (xParams[paramNumber]) {
        if (xSizemode === 'pixel') param = x2p(xAnchor) + Number(param);else param = x2p(param);
      } else if (yParams[paramNumber]) {
        if (ySizemode === 'pixel') param = y2p(yAnchor) - Number(param);else param = y2p(param);
      }
      paramNumber++;
      if (paramNumber > nParams) param = 'X';
      return param;
    });
    if (paramNumber > nParams) {
      paramString = paramString.replace(/[\s,]*X.*/, '');
      Lib.log('Ignoring extra params in segment ' + segment);
    }
    return segmentType + paramString;
  });
}

/***/ }),

/***/ 9853:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var drawModule = __webpack_require__(4031);
module.exports = {
  moduleType: 'component',
  name: 'shapes',
  layoutAttributes: __webpack_require__(9827),
  supplyLayoutDefaults: __webpack_require__(4726),
  supplyDrawNewShapeDefaults: __webpack_require__(5547),
  includeBasePlot: __webpack_require__(6325)('shapes'),
  calcAutorange: __webpack_require__(5627),
  draw: drawModule.draw,
  drawOne: drawModule.drawOne
};

/***/ }),

/***/ 7281:
/***/ (function(module) {

"use strict";


// Wrapper functions to handle paper-referenced shapes, which have no axis
function d2l(v, axis) {
  return axis ? axis.d2l(v) : v;
}
function l2d(v, axis) {
  return axis ? axis.l2d(v) : v;
}
function x0Fn(shape) {
  return shape.x0;
}
function x1Fn(shape) {
  return shape.x1;
}
function y0Fn(shape) {
  return shape.y0;
}
function y1Fn(shape) {
  return shape.y1;
}
function dxFn(shape, xa) {
  return d2l(shape.x1, xa) - d2l(shape.x0, xa);
}
function dyFn(shape, xa, ya) {
  return d2l(shape.y1, ya) - d2l(shape.y0, ya);
}
function widthFn(shape, xa) {
  return Math.abs(dxFn(shape, xa));
}
function heightFn(shape, xa, ya) {
  return Math.abs(dyFn(shape, xa, ya));
}
function lengthFn(shape, xa, ya) {
  return shape.type !== 'line' ? undefined : Math.sqrt(Math.pow(dxFn(shape, xa), 2) + Math.pow(dyFn(shape, xa, ya), 2));
}
function xcenterFn(shape, xa) {
  return l2d((d2l(shape.x1, xa) + d2l(shape.x0, xa)) / 2, xa);
}
function ycenterFn(shape, xa, ya) {
  return l2d((d2l(shape.y1, ya) + d2l(shape.y0, ya)) / 2, ya);
}
function slopeFn(shape, xa, ya) {
  return shape.type !== 'line' ? undefined : dyFn(shape, xa, ya) / dxFn(shape, xa);
}
module.exports = {
  x0: x0Fn,
  x1: x1Fn,
  y0: y0Fn,
  y1: y1Fn,
  slope: slopeFn,
  dx: dxFn,
  dy: dyFn,
  width: widthFn,
  height: heightFn,
  length: lengthFn,
  xcenter: xcenterFn,
  ycenter: ycenterFn
};

/***/ }),

/***/ 5067:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var fontAttrs = __webpack_require__(1940);
var padAttrs = __webpack_require__(5025);
var extendDeepAll = (__webpack_require__(1426).extendDeepAll);
var overrideAll = (__webpack_require__(962).overrideAll);
var animationAttrs = __webpack_require__(5594);
var templatedArray = (__webpack_require__(4467).templatedArray);
var constants = __webpack_require__(8292);
var stepsAttrs = templatedArray('step', {
  visible: {
    valType: 'boolean',
    dflt: true
  },
  method: {
    valType: 'enumerated',
    values: ['restyle', 'relayout', 'animate', 'update', 'skip'],
    dflt: 'restyle'
  },
  args: {
    valType: 'info_array',
    freeLength: true,
    items: [{
      valType: 'any'
    }, {
      valType: 'any'
    }, {
      valType: 'any'
    }]
  },
  label: {
    valType: 'string'
  },
  value: {
    valType: 'string'
  },
  execute: {
    valType: 'boolean',
    dflt: true
  }
});
module.exports = overrideAll(templatedArray('slider', {
  visible: {
    valType: 'boolean',
    dflt: true
  },
  active: {
    valType: 'number',
    min: 0,
    dflt: 0
  },
  steps: stepsAttrs,
  lenmode: {
    valType: 'enumerated',
    values: ['fraction', 'pixels'],
    dflt: 'fraction'
  },
  len: {
    valType: 'number',
    min: 0,
    dflt: 1
  },
  x: {
    valType: 'number',
    min: -2,
    max: 3,
    dflt: 0
  },
  pad: extendDeepAll(padAttrs({
    editType: 'arraydraw'
  }), {}, {
    t: {
      dflt: 20
    }
  }),
  xanchor: {
    valType: 'enumerated',
    values: ['auto', 'left', 'center', 'right'],
    dflt: 'left'
  },
  y: {
    valType: 'number',
    min: -2,
    max: 3,
    dflt: 0
  },
  yanchor: {
    valType: 'enumerated',
    values: ['auto', 'top', 'middle', 'bottom'],
    dflt: 'top'
  },
  transition: {
    duration: {
      valType: 'number',
      min: 0,
      dflt: 150
    },
    easing: {
      valType: 'enumerated',
      values: animationAttrs.transition.easing.values,
      dflt: 'cubic-in-out'
    }
  },
  currentvalue: {
    visible: {
      valType: 'boolean',
      dflt: true
    },
    xanchor: {
      valType: 'enumerated',
      values: ['left', 'center', 'right'],
      dflt: 'left'
    },
    offset: {
      valType: 'number',
      dflt: 10
    },
    prefix: {
      valType: 'string'
    },
    suffix: {
      valType: 'string'
    },
    font: fontAttrs({})
  },
  font: fontAttrs({}),
  activebgcolor: {
    valType: 'color',
    dflt: constants.gripBgActiveColor
  },
  bgcolor: {
    valType: 'color',
    dflt: constants.railBgColor
  },
  bordercolor: {
    valType: 'color',
    dflt: constants.railBorderColor
  },
  borderwidth: {
    valType: 'number',
    min: 0,
    dflt: constants.railBorderWidth
  },
  ticklen: {
    valType: 'number',
    min: 0,
    dflt: constants.tickLength
  },
  tickcolor: {
    valType: 'color',
    dflt: constants.tickColor
  },
  tickwidth: {
    valType: 'number',
    min: 0,
    dflt: 1
  },
  minorticklen: {
    valType: 'number',
    min: 0,
    dflt: constants.minorTickLength
  }
}), 'arraydraw', 'from-root');

/***/ }),

/***/ 8292:
/***/ (function(module) {

"use strict";


module.exports = {
  // layout attribute name
  name: 'sliders',
  // class names
  containerClassName: 'slider-container',
  groupClassName: 'slider-group',
  inputAreaClass: 'slider-input-area',
  railRectClass: 'slider-rail-rect',
  railTouchRectClass: 'slider-rail-touch-rect',
  gripRectClass: 'slider-grip-rect',
  tickRectClass: 'slider-tick-rect',
  inputProxyClass: 'slider-input-proxy',
  labelsClass: 'slider-labels',
  labelGroupClass: 'slider-label-group',
  labelClass: 'slider-label',
  currentValueClass: 'slider-current-value',
  railHeight: 5,
  // DOM attribute name in button group keeping track
  // of active update menu
  menuIndexAttrName: 'slider-active-index',
  // id root pass to Plots.autoMargin
  autoMarginIdRoot: 'slider-',
  // min item width / height
  minWidth: 30,
  minHeight: 30,
  // padding around item text
  textPadX: 40,
  // arrow offset off right edge
  arrowOffsetX: 4,
  railRadius: 2,
  railWidth: 5,
  railBorder: 4,
  railBorderWidth: 1,
  railBorderColor: '#bec8d9',
  railBgColor: '#f8fafc',
  // The distance of the rail from the edge of the touchable area
  // Slightly less than the step inset because of the curved edges
  // of the rail
  railInset: 8,
  // The distance from the extremal tick marks to the edge of the
  // touchable area. This is basically the same as the grip radius,
  // but for other styles it wouldn't really need to be.
  stepInset: 10,
  gripRadius: 10,
  gripWidth: 20,
  gripHeight: 20,
  gripBorder: 20,
  gripBorderWidth: 1,
  gripBorderColor: '#bec8d9',
  gripBgColor: '#f6f8fa',
  gripBgActiveColor: '#dbdde0',
  labelPadding: 8,
  labelOffset: 0,
  tickWidth: 1,
  tickColor: '#333',
  tickOffset: 25,
  tickLength: 7,
  minorTickOffset: 25,
  minorTickColor: '#333',
  minorTickLength: 4,
  // Extra space below the current value label:
  currentValuePadding: 8,
  currentValueInset: 0
};

/***/ }),

/***/ 2343:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var handleArrayContainerDefaults = __webpack_require__(5501);
var attributes = __webpack_require__(5067);
var constants = __webpack_require__(8292);
var name = constants.name;
var stepAttrs = attributes.steps;
module.exports = function slidersDefaults(layoutIn, layoutOut) {
  handleArrayContainerDefaults(layoutIn, layoutOut, {
    name: name,
    handleItemDefaults: sliderDefaults
  });
};
function sliderDefaults(sliderIn, sliderOut, layoutOut) {
  function coerce(attr, dflt) {
    return Lib.coerce(sliderIn, sliderOut, attributes, attr, dflt);
  }
  var steps = handleArrayContainerDefaults(sliderIn, sliderOut, {
    name: 'steps',
    handleItemDefaults: stepDefaults
  });
  var stepCount = 0;
  for (var i = 0; i < steps.length; i++) {
    if (steps[i].visible) stepCount++;
  }
  var visible;
  // If it has fewer than two options, it's not really a slider
  if (stepCount < 2) visible = sliderOut.visible = false;else visible = coerce('visible');
  if (!visible) return;
  sliderOut._stepCount = stepCount;
  var visSteps = sliderOut._visibleSteps = Lib.filterVisible(steps);
  var active = coerce('active');
  if (!(steps[active] || {}).visible) sliderOut.active = visSteps[0]._index;
  coerce('x');
  coerce('y');
  Lib.noneOrAll(sliderIn, sliderOut, ['x', 'y']);
  coerce('xanchor');
  coerce('yanchor');
  coerce('len');
  coerce('lenmode');
  coerce('pad.t');
  coerce('pad.r');
  coerce('pad.b');
  coerce('pad.l');
  Lib.coerceFont(coerce, 'font', layoutOut.font);
  var currentValueIsVisible = coerce('currentvalue.visible');
  if (currentValueIsVisible) {
    coerce('currentvalue.xanchor');
    coerce('currentvalue.prefix');
    coerce('currentvalue.suffix');
    coerce('currentvalue.offset');
    Lib.coerceFont(coerce, 'currentvalue.font', sliderOut.font);
  }
  coerce('transition.duration');
  coerce('transition.easing');
  coerce('bgcolor');
  coerce('activebgcolor');
  coerce('bordercolor');
  coerce('borderwidth');
  coerce('ticklen');
  coerce('tickwidth');
  coerce('tickcolor');
  coerce('minorticklen');
}
function stepDefaults(valueIn, valueOut) {
  function coerce(attr, dflt) {
    return Lib.coerce(valueIn, valueOut, stepAttrs, attr, dflt);
  }
  var visible;
  if (valueIn.method !== 'skip' && !Array.isArray(valueIn.args)) {
    visible = valueOut.visible = false;
  } else visible = coerce('visible');
  if (visible) {
    coerce('method');
    coerce('args');
    var label = coerce('label', 'step-' + valueOut._index);
    coerce('value', label);
    coerce('execute');
  }
}

/***/ }),

/***/ 4504:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Plots = __webpack_require__(4875);
var Color = __webpack_require__(7901);
var Drawing = __webpack_require__(1424);
var Lib = __webpack_require__(1828);
var strTranslate = Lib.strTranslate;
var svgTextUtils = __webpack_require__(3893);
var arrayEditor = (__webpack_require__(4467).arrayEditor);
var constants = __webpack_require__(8292);
var alignmentConstants = __webpack_require__(8783);
var LINE_SPACING = alignmentConstants.LINE_SPACING;
var FROM_TL = alignmentConstants.FROM_TL;
var FROM_BR = alignmentConstants.FROM_BR;
module.exports = function draw(gd) {
  var staticPlot = gd._context.staticPlot;
  var fullLayout = gd._fullLayout;
  var sliderData = makeSliderData(fullLayout, gd);

  // draw a container for *all* sliders:
  var sliders = fullLayout._infolayer.selectAll('g.' + constants.containerClassName).data(sliderData.length > 0 ? [0] : []);
  sliders.enter().append('g').classed(constants.containerClassName, true).style('cursor', staticPlot ? null : 'ew-resize');
  function clearSlider(sliderOpts) {
    if (sliderOpts._commandObserver) {
      sliderOpts._commandObserver.remove();
      delete sliderOpts._commandObserver;
    }

    // Most components don't need to explicitly remove autoMargin, because
    // marginPushers does this - but slider updates don't go through
    // a full replot so we need to explicitly remove it.
    Plots.autoMargin(gd, autoMarginId(sliderOpts));
  }
  sliders.exit().each(function () {
    d3.select(this).selectAll('g.' + constants.groupClassName).each(clearSlider);
  }).remove();

  // Return early if no menus visible:
  if (sliderData.length === 0) return;
  var sliderGroups = sliders.selectAll('g.' + constants.groupClassName).data(sliderData, keyFunction);
  sliderGroups.enter().append('g').classed(constants.groupClassName, true);
  sliderGroups.exit().each(clearSlider).remove();

  // Find the dimensions of the sliders:
  for (var i = 0; i < sliderData.length; i++) {
    var sliderOpts = sliderData[i];
    findDimensions(gd, sliderOpts);
  }
  sliderGroups.each(function (sliderOpts) {
    var gSlider = d3.select(this);
    computeLabelSteps(sliderOpts);
    Plots.manageCommandObserver(gd, sliderOpts, sliderOpts._visibleSteps, function (data) {
      // NB: Same as below. This is *not* always the same as sliderOpts since
      // if a new set of steps comes in, the reference in this callback would
      // be invalid. We need to refetch it from the slider group, which is
      // the join data that creates this slider. So if this slider still exists,
      // the group should be valid, *to the best of my knowledge.* If not,
      // we'd have to look it up by d3 data join index/key.
      var opts = gSlider.data()[0];
      if (opts.active === data.index) return;
      if (opts._dragging) return;
      setActive(gd, gSlider, opts, data.index, false, true);
    });
    drawSlider(gd, d3.select(this), sliderOpts);
  });
};
function autoMarginId(sliderOpts) {
  return constants.autoMarginIdRoot + sliderOpts._index;
}

// This really only just filters by visibility:
function makeSliderData(fullLayout, gd) {
  var contOpts = fullLayout[constants.name];
  var sliderData = [];
  for (var i = 0; i < contOpts.length; i++) {
    var item = contOpts[i];
    if (!item.visible) continue;
    item._gd = gd;
    sliderData.push(item);
  }
  return sliderData;
}

// This is set in the defaults step:
function keyFunction(opts) {
  return opts._index;
}

// Compute the dimensions (mutates sliderOpts):
function findDimensions(gd, sliderOpts) {
  var sliderLabels = Drawing.tester.selectAll('g.' + constants.labelGroupClass).data(sliderOpts._visibleSteps);
  sliderLabels.enter().append('g').classed(constants.labelGroupClass, true);

  // loop over fake buttons to find width / height
  var maxLabelWidth = 0;
  var labelHeight = 0;
  sliderLabels.each(function (stepOpts) {
    var labelGroup = d3.select(this);
    var text = drawLabel(labelGroup, {
      step: stepOpts
    }, sliderOpts);
    var textNode = text.node();
    if (textNode) {
      var bBox = Drawing.bBox(textNode);
      labelHeight = Math.max(labelHeight, bBox.height);
      maxLabelWidth = Math.max(maxLabelWidth, bBox.width);
    }
  });
  sliderLabels.remove();
  var dims = sliderOpts._dims = {};
  dims.inputAreaWidth = Math.max(constants.railWidth, constants.gripHeight);

  // calculate some overall dimensions - some of these are needed for
  // calculating the currentValue dimensions
  var graphSize = gd._fullLayout._size;
  dims.lx = graphSize.l + graphSize.w * sliderOpts.x;
  dims.ly = graphSize.t + graphSize.h * (1 - sliderOpts.y);
  if (sliderOpts.lenmode === 'fraction') {
    // fraction:
    dims.outerLength = Math.round(graphSize.w * sliderOpts.len);
  } else {
    // pixels:
    dims.outerLength = sliderOpts.len;
  }

  // The length of the rail, *excluding* padding on either end:
  dims.inputAreaStart = 0;
  dims.inputAreaLength = Math.round(dims.outerLength - sliderOpts.pad.l - sliderOpts.pad.r);
  var textableInputLength = dims.inputAreaLength - 2 * constants.stepInset;
  var availableSpacePerLabel = textableInputLength / (sliderOpts._stepCount - 1);
  var computedSpacePerLabel = maxLabelWidth + constants.labelPadding;
  dims.labelStride = Math.max(1, Math.ceil(computedSpacePerLabel / availableSpacePerLabel));
  dims.labelHeight = labelHeight;

  // loop over all possible values for currentValue to find the
  // area we need for it
  dims.currentValueMaxWidth = 0;
  dims.currentValueHeight = 0;
  dims.currentValueTotalHeight = 0;
  dims.currentValueMaxLines = 1;
  if (sliderOpts.currentvalue.visible) {
    // Get the dimensions of the current value label:
    var dummyGroup = Drawing.tester.append('g');
    sliderLabels.each(function (stepOpts) {
      var curValPrefix = drawCurrentValue(dummyGroup, sliderOpts, stepOpts.label);
      var curValSize = curValPrefix.node() && Drawing.bBox(curValPrefix.node()) || {
        width: 0,
        height: 0
      };
      var lines = svgTextUtils.lineCount(curValPrefix);
      dims.currentValueMaxWidth = Math.max(dims.currentValueMaxWidth, Math.ceil(curValSize.width));
      dims.currentValueHeight = Math.max(dims.currentValueHeight, Math.ceil(curValSize.height));
      dims.currentValueMaxLines = Math.max(dims.currentValueMaxLines, lines);
    });
    dims.currentValueTotalHeight = dims.currentValueHeight + sliderOpts.currentvalue.offset;
    dummyGroup.remove();
  }
  dims.height = dims.currentValueTotalHeight + constants.tickOffset + sliderOpts.ticklen + constants.labelOffset + dims.labelHeight + sliderOpts.pad.t + sliderOpts.pad.b;
  var xanchor = 'left';
  if (Lib.isRightAnchor(sliderOpts)) {
    dims.lx -= dims.outerLength;
    xanchor = 'right';
  }
  if (Lib.isCenterAnchor(sliderOpts)) {
    dims.lx -= dims.outerLength / 2;
    xanchor = 'center';
  }
  var yanchor = 'top';
  if (Lib.isBottomAnchor(sliderOpts)) {
    dims.ly -= dims.height;
    yanchor = 'bottom';
  }
  if (Lib.isMiddleAnchor(sliderOpts)) {
    dims.ly -= dims.height / 2;
    yanchor = 'middle';
  }
  dims.outerLength = Math.ceil(dims.outerLength);
  dims.height = Math.ceil(dims.height);
  dims.lx = Math.round(dims.lx);
  dims.ly = Math.round(dims.ly);
  var marginOpts = {
    y: sliderOpts.y,
    b: dims.height * FROM_BR[yanchor],
    t: dims.height * FROM_TL[yanchor]
  };
  if (sliderOpts.lenmode === 'fraction') {
    marginOpts.l = 0;
    marginOpts.xl = sliderOpts.x - sliderOpts.len * FROM_TL[xanchor];
    marginOpts.r = 0;
    marginOpts.xr = sliderOpts.x + sliderOpts.len * FROM_BR[xanchor];
  } else {
    marginOpts.x = sliderOpts.x;
    marginOpts.l = dims.outerLength * FROM_TL[xanchor];
    marginOpts.r = dims.outerLength * FROM_BR[xanchor];
  }
  Plots.autoMargin(gd, autoMarginId(sliderOpts), marginOpts);
}
function drawSlider(gd, sliderGroup, sliderOpts) {
  // This is related to the other long notes in this file regarding what happens
  // when slider steps disappear. This particular fix handles what happens when
  // the *current* slider step is removed. The drawing functions will error out
  // when they fail to find it, so the fix for now is that it will just draw the
  // slider in the first position but will not execute the command.
  if (!(sliderOpts.steps[sliderOpts.active] || {}).visible) {
    sliderOpts.active = sliderOpts._visibleSteps[0]._index;
  }

  // These are carefully ordered for proper z-ordering:
  sliderGroup.call(drawCurrentValue, sliderOpts).call(drawRail, sliderOpts).call(drawLabelGroup, sliderOpts).call(drawTicks, sliderOpts).call(drawTouchRect, gd, sliderOpts).call(drawGrip, gd, sliderOpts);
  var dims = sliderOpts._dims;

  // Position the rectangle:
  Drawing.setTranslate(sliderGroup, dims.lx + sliderOpts.pad.l, dims.ly + sliderOpts.pad.t);
  sliderGroup.call(setGripPosition, sliderOpts, false);
  sliderGroup.call(drawCurrentValue, sliderOpts);
}
function drawCurrentValue(sliderGroup, sliderOpts, valueOverride) {
  if (!sliderOpts.currentvalue.visible) return;
  var dims = sliderOpts._dims;
  var x0, textAnchor;
  switch (sliderOpts.currentvalue.xanchor) {
    case 'right':
      // This is anchored left and adjusted by the width of the longest label
      // so that the prefix doesn't move. The goal of this is to emphasize
      // what's actually changing and make the update less distracting.
      x0 = dims.inputAreaLength - constants.currentValueInset - dims.currentValueMaxWidth;
      textAnchor = 'left';
      break;
    case 'center':
      x0 = dims.inputAreaLength * 0.5;
      textAnchor = 'middle';
      break;
    default:
      x0 = constants.currentValueInset;
      textAnchor = 'left';
  }
  var text = Lib.ensureSingle(sliderGroup, 'text', constants.labelClass, function (s) {
    s.attr({
      'text-anchor': textAnchor,
      'data-notex': 1
    });
  });
  var str = sliderOpts.currentvalue.prefix ? sliderOpts.currentvalue.prefix : '';
  if (typeof valueOverride === 'string') {
    str += valueOverride;
  } else {
    var curVal = sliderOpts.steps[sliderOpts.active].label;
    var _meta = sliderOpts._gd._fullLayout._meta;
    if (_meta) curVal = Lib.templateString(curVal, _meta);
    str += curVal;
  }
  if (sliderOpts.currentvalue.suffix) {
    str += sliderOpts.currentvalue.suffix;
  }
  text.call(Drawing.font, sliderOpts.currentvalue.font).text(str).call(svgTextUtils.convertToTspans, sliderOpts._gd);
  var lines = svgTextUtils.lineCount(text);
  var y0 = (dims.currentValueMaxLines + 1 - lines) * sliderOpts.currentvalue.font.size * LINE_SPACING;
  svgTextUtils.positionText(text, x0, y0);
  return text;
}
function drawGrip(sliderGroup, gd, sliderOpts) {
  var grip = Lib.ensureSingle(sliderGroup, 'rect', constants.gripRectClass, function (s) {
    s.call(attachGripEvents, gd, sliderGroup, sliderOpts).style('pointer-events', 'all');
  });
  grip.attr({
    width: constants.gripWidth,
    height: constants.gripHeight,
    rx: constants.gripRadius,
    ry: constants.gripRadius
  }).call(Color.stroke, sliderOpts.bordercolor).call(Color.fill, sliderOpts.bgcolor).style('stroke-width', sliderOpts.borderwidth + 'px');
}
function drawLabel(item, data, sliderOpts) {
  var text = Lib.ensureSingle(item, 'text', constants.labelClass, function (s) {
    s.attr({
      'text-anchor': 'middle',
      'data-notex': 1
    });
  });
  var tx = data.step.label;
  var _meta = sliderOpts._gd._fullLayout._meta;
  if (_meta) tx = Lib.templateString(tx, _meta);
  text.call(Drawing.font, sliderOpts.font).text(tx).call(svgTextUtils.convertToTspans, sliderOpts._gd);
  return text;
}
function drawLabelGroup(sliderGroup, sliderOpts) {
  var labels = Lib.ensureSingle(sliderGroup, 'g', constants.labelsClass);
  var dims = sliderOpts._dims;
  var labelItems = labels.selectAll('g.' + constants.labelGroupClass).data(dims.labelSteps);
  labelItems.enter().append('g').classed(constants.labelGroupClass, true);
  labelItems.exit().remove();
  labelItems.each(function (d) {
    var item = d3.select(this);
    item.call(drawLabel, d, sliderOpts);
    Drawing.setTranslate(item, normalizedValueToPosition(sliderOpts, d.fraction), constants.tickOffset + sliderOpts.ticklen +
    // position is the baseline of the top line of text only, even
    // if the label spans multiple lines
    sliderOpts.font.size * LINE_SPACING + constants.labelOffset + dims.currentValueTotalHeight);
  });
}
function handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, doTransition) {
  var quantizedPosition = Math.round(normalizedPosition * (sliderOpts._stepCount - 1));
  var quantizedIndex = sliderOpts._visibleSteps[quantizedPosition]._index;
  if (quantizedIndex !== sliderOpts.active) {
    setActive(gd, sliderGroup, sliderOpts, quantizedIndex, true, doTransition);
  }
}
function setActive(gd, sliderGroup, sliderOpts, index, doCallback, doTransition) {
  var previousActive = sliderOpts.active;
  sliderOpts.active = index;

  // due to templating, it's possible this slider doesn't even exist yet
  arrayEditor(gd.layout, constants.name, sliderOpts).applyUpdate('active', index);
  var step = sliderOpts.steps[sliderOpts.active];
  sliderGroup.call(setGripPosition, sliderOpts, doTransition);
  sliderGroup.call(drawCurrentValue, sliderOpts);
  gd.emit('plotly_sliderchange', {
    slider: sliderOpts,
    step: sliderOpts.steps[sliderOpts.active],
    interaction: doCallback,
    previousActive: previousActive
  });
  if (step && step.method && doCallback) {
    if (sliderGroup._nextMethod) {
      // If we've already queued up an update, just overwrite it with the most recent:
      sliderGroup._nextMethod.step = step;
      sliderGroup._nextMethod.doCallback = doCallback;
      sliderGroup._nextMethod.doTransition = doTransition;
    } else {
      sliderGroup._nextMethod = {
        step: step,
        doCallback: doCallback,
        doTransition: doTransition
      };
      sliderGroup._nextMethodRaf = window.requestAnimationFrame(function () {
        var _step = sliderGroup._nextMethod.step;
        if (!_step.method) return;
        if (_step.execute) {
          Plots.executeAPICommand(gd, _step.method, _step.args);
        }
        sliderGroup._nextMethod = null;
        sliderGroup._nextMethodRaf = null;
      });
    }
  }
}
function attachGripEvents(item, gd, sliderGroup) {
  if (gd._context.staticPlot) return;
  var node = sliderGroup.node();
  var $gd = d3.select(gd);

  // NB: This is *not* the same as sliderOpts itself! These callbacks
  // are in a closure so this array won't actually be correct if the
  // steps have changed since this was initialized. The sliderGroup,
  // however, has not changed since that *is* the slider, so it must
  // be present to receive mouse events.
  function getSliderOpts() {
    return sliderGroup.data()[0];
  }
  function mouseDownHandler() {
    var sliderOpts = getSliderOpts();
    gd.emit('plotly_sliderstart', {
      slider: sliderOpts
    });
    var grip = sliderGroup.select('.' + constants.gripRectClass);
    d3.event.stopPropagation();
    d3.event.preventDefault();
    grip.call(Color.fill, sliderOpts.activebgcolor);
    var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);
    handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, true);
    sliderOpts._dragging = true;
    function mouseMoveHandler() {
      var sliderOpts = getSliderOpts();
      var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);
      handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, false);
    }
    $gd.on('mousemove', mouseMoveHandler);
    $gd.on('touchmove', mouseMoveHandler);
    function mouseUpHandler() {
      var sliderOpts = getSliderOpts();
      sliderOpts._dragging = false;
      grip.call(Color.fill, sliderOpts.bgcolor);
      $gd.on('mouseup', null);
      $gd.on('mousemove', null);
      $gd.on('touchend', null);
      $gd.on('touchmove', null);
      gd.emit('plotly_sliderend', {
        slider: sliderOpts,
        step: sliderOpts.steps[sliderOpts.active]
      });
    }
    $gd.on('mouseup', mouseUpHandler);
    $gd.on('touchend', mouseUpHandler);
  }
  item.on('mousedown', mouseDownHandler);
  item.on('touchstart', mouseDownHandler);
}
function drawTicks(sliderGroup, sliderOpts) {
  var tick = sliderGroup.selectAll('rect.' + constants.tickRectClass).data(sliderOpts._visibleSteps);
  var dims = sliderOpts._dims;
  tick.enter().append('rect').classed(constants.tickRectClass, true);
  tick.exit().remove();
  tick.attr({
    width: sliderOpts.tickwidth + 'px',
    'shape-rendering': 'crispEdges'
  });
  tick.each(function (d, i) {
    var isMajor = i % dims.labelStride === 0;
    var item = d3.select(this);
    item.attr({
      height: isMajor ? sliderOpts.ticklen : sliderOpts.minorticklen
    }).call(Color.fill, isMajor ? sliderOpts.tickcolor : sliderOpts.tickcolor);
    Drawing.setTranslate(item, normalizedValueToPosition(sliderOpts, i / (sliderOpts._stepCount - 1)) - 0.5 * sliderOpts.tickwidth, (isMajor ? constants.tickOffset : constants.minorTickOffset) + dims.currentValueTotalHeight);
  });
}
function computeLabelSteps(sliderOpts) {
  var dims = sliderOpts._dims;
  dims.labelSteps = [];
  var nsteps = sliderOpts._stepCount;
  for (var i = 0; i < nsteps; i += dims.labelStride) {
    dims.labelSteps.push({
      fraction: i / (nsteps - 1),
      step: sliderOpts._visibleSteps[i]
    });
  }
}
function setGripPosition(sliderGroup, sliderOpts, doTransition) {
  var grip = sliderGroup.select('rect.' + constants.gripRectClass);
  var quantizedIndex = 0;
  for (var i = 0; i < sliderOpts._stepCount; i++) {
    if (sliderOpts._visibleSteps[i]._index === sliderOpts.active) {
      quantizedIndex = i;
      break;
    }
  }
  var x = normalizedValueToPosition(sliderOpts, quantizedIndex / (sliderOpts._stepCount - 1));

  // If this is true, then *this component* is already invoking its own command
  // and has triggered its own animation.
  if (sliderOpts._invokingCommand) return;
  var el = grip;
  if (doTransition && sliderOpts.transition.duration > 0) {
    el = el.transition().duration(sliderOpts.transition.duration).ease(sliderOpts.transition.easing);
  }

  // Drawing.setTranslate doesn't work here because of the transition duck-typing.
  // It's also not necessary because there are no other transitions to preserve.
  el.attr('transform', strTranslate(x - constants.gripWidth * 0.5, sliderOpts._dims.currentValueTotalHeight));
}

// Convert a number from [0-1] to a pixel position relative to the slider group container:
function normalizedValueToPosition(sliderOpts, normalizedPosition) {
  var dims = sliderOpts._dims;
  return dims.inputAreaStart + constants.stepInset + (dims.inputAreaLength - 2 * constants.stepInset) * Math.min(1, Math.max(0, normalizedPosition));
}

// Convert a position relative to the slider group to a nubmer in [0, 1]
function positionToNormalizedValue(sliderOpts, position) {
  var dims = sliderOpts._dims;
  return Math.min(1, Math.max(0, (position - constants.stepInset - dims.inputAreaStart) / (dims.inputAreaLength - 2 * constants.stepInset - 2 * dims.inputAreaStart)));
}
function drawTouchRect(sliderGroup, gd, sliderOpts) {
  var dims = sliderOpts._dims;
  var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railTouchRectClass, function (s) {
    s.call(attachGripEvents, gd, sliderGroup, sliderOpts).style('pointer-events', 'all');
  });
  rect.attr({
    width: dims.inputAreaLength,
    height: Math.max(dims.inputAreaWidth, constants.tickOffset + sliderOpts.ticklen + dims.labelHeight)
  }).call(Color.fill, sliderOpts.bgcolor).attr('opacity', 0);
  Drawing.setTranslate(rect, 0, dims.currentValueTotalHeight);
}
function drawRail(sliderGroup, sliderOpts) {
  var dims = sliderOpts._dims;
  var computedLength = dims.inputAreaLength - constants.railInset * 2;
  var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railRectClass);
  rect.attr({
    width: computedLength,
    height: constants.railWidth,
    rx: constants.railRadius,
    ry: constants.railRadius,
    'shape-rendering': 'crispEdges'
  }).call(Color.stroke, sliderOpts.bordercolor).call(Color.fill, sliderOpts.bgcolor).style('stroke-width', sliderOpts.borderwidth + 'px');
  Drawing.setTranslate(rect, constants.railInset, (dims.inputAreaWidth - constants.railWidth) * 0.5 + dims.currentValueTotalHeight);
}

/***/ }),

/***/ 3243:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var constants = __webpack_require__(8292);
module.exports = {
  moduleType: 'component',
  name: constants.name,
  layoutAttributes: __webpack_require__(5067),
  supplyLayoutDefaults: __webpack_require__(2343),
  draw: __webpack_require__(4504)
};

/***/ }),

/***/ 2998:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var isNumeric = __webpack_require__(2770);
var Plots = __webpack_require__(4875);
var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var strTranslate = Lib.strTranslate;
var Drawing = __webpack_require__(1424);
var Color = __webpack_require__(7901);
var svgTextUtils = __webpack_require__(3893);
var interactConstants = __webpack_require__(7822);
var OPPOSITE_SIDE = (__webpack_require__(8783).OPPOSITE_SIDE);
var numStripRE = / [XY][0-9]* /;

/**
 * Titles - (re)draw titles on the axes and plot:
 * @param {DOM element} gd - the graphDiv
 * @param {string} titleClass - the css class of this title
 * @param {object} options - how and what to draw
 *      propContainer - the layout object containing `title` and `titlefont`
 *          attributes that apply to this title
 *      propName - the full name of the title property (for Plotly.relayout)
 *      [traceIndex] - include only if this property applies to one trace
 *          (such as a colorbar title) - then editing pipes to Plotly.restyle
 *          instead of Plotly.relayout
 *      placeholder - placeholder text for an empty editable title
 *      [avoid] {object} - include if this title should move to avoid other elements
 *          selection - d3 selection of elements to avoid
 *          side - which direction to move if there is a conflict
 *          [offsetLeft] - if these elements are subject to a translation
 *              wrt the title element
 *          [offsetTop]
 *      attributes {object} - position and alignment attributes
 *          x - pixels
 *          y - pixels
 *          text-anchor - start|middle|end
 *      transform {object} - how to transform the title after positioning
 *          rotate - degrees
 *          offset - shift up/down in the rotated frame (unused?)
 *      containerGroup - if an svg <g> element already exists to hold this
 *          title, include here. Otherwise it will go in fullLayout._infolayer
 *      _meta {object (optional} - meta key-value to for title with
 *          Lib.templateString, default to fullLayout._meta, if not provided
 *
 *  @return {selection} d3 selection of title container group
 */
function draw(gd, titleClass, options) {
  var cont = options.propContainer;
  var prop = options.propName;
  var placeholder = options.placeholder;
  var traceIndex = options.traceIndex;
  var avoid = options.avoid || {};
  var attributes = options.attributes;
  var transform = options.transform;
  var group = options.containerGroup;
  var fullLayout = gd._fullLayout;
  var opacity = 1;
  var isplaceholder = false;
  var title = cont.title;
  var txt = (title && title.text ? title.text : '').trim();
  var font = title && title.font ? title.font : {};
  var fontFamily = font.family;
  var fontSize = font.size;
  var fontColor = font.color;

  // only make this title editable if we positively identify its property
  // as one that has editing enabled.
  var editAttr;
  if (prop === 'title.text') editAttr = 'titleText';else if (prop.indexOf('axis') !== -1) editAttr = 'axisTitleText';else if (prop.indexOf('colorbar' !== -1)) editAttr = 'colorbarTitleText';
  var editable = gd._context.edits[editAttr];
  if (txt === '') opacity = 0;
  // look for placeholder text while stripping out numbers from eg X2, Y3
  // this is just for backward compatibility with the old version that had
  // "Click to enter X2 title" and may have gotten saved in some old plots,
  // we don't want this to show up when these are displayed.
  else if (txt.replace(numStripRE, ' % ') === placeholder.replace(numStripRE, ' % ')) {
    opacity = 0.2;
    isplaceholder = true;
    if (!editable) txt = '';
  }
  if (options._meta) {
    txt = Lib.templateString(txt, options._meta);
  } else if (fullLayout._meta) {
    txt = Lib.templateString(txt, fullLayout._meta);
  }
  var elShouldExist = txt || editable;
  var hColorbarMoveTitle;
  if (!group) {
    group = Lib.ensureSingle(fullLayout._infolayer, 'g', 'g-' + titleClass);
    hColorbarMoveTitle = fullLayout._hColorbarMoveTitle;
  }
  var el = group.selectAll('text').data(elShouldExist ? [0] : []);
  el.enter().append('text');
  el.text(txt)
  // this is hacky, but convertToTspans uses the class
  // to determine whether to rotate mathJax...
  // so we need to clear out any old class and put the
  // correct one (only relevant for colorbars, at least
  // for now) - ie don't use .classed
  .attr('class', titleClass);
  el.exit().remove();
  if (!elShouldExist) return group;
  function titleLayout(titleEl) {
    Lib.syncOrAsync([drawTitle, scootTitle], titleEl);
  }
  function drawTitle(titleEl) {
    var transformVal;
    if (!transform && hColorbarMoveTitle) {
      transform = {};
    }
    if (transform) {
      transformVal = '';
      if (transform.rotate) {
        transformVal += 'rotate(' + [transform.rotate, attributes.x, attributes.y] + ')';
      }
      if (transform.offset || hColorbarMoveTitle) {
        transformVal += strTranslate(0, (transform.offset || 0) - (hColorbarMoveTitle || 0));
      }
    } else {
      transformVal = null;
    }
    titleEl.attr('transform', transformVal);
    titleEl.style({
      'font-family': fontFamily,
      'font-size': d3.round(fontSize, 2) + 'px',
      fill: Color.rgb(fontColor),
      opacity: opacity * Color.opacity(fontColor),
      'font-weight': Plots.fontWeight
    }).attr(attributes).call(svgTextUtils.convertToTspans, gd);
    return Plots.previousPromises(gd);
  }
  function scootTitle(titleElIn) {
    var titleGroup = d3.select(titleElIn.node().parentNode);
    if (avoid && avoid.selection && avoid.side && txt) {
      titleGroup.attr('transform', null);

      // move toward avoid.side (= left, right, top, bottom) if needed
      // can include pad (pixels, default 2)
      var backside = OPPOSITE_SIDE[avoid.side];
      var shiftSign = avoid.side === 'left' || avoid.side === 'top' ? -1 : 1;
      var pad = isNumeric(avoid.pad) ? avoid.pad : 2;
      var titlebb = Drawing.bBox(titleGroup.node());

      // Account for reservedMargins
      var reservedMargins = {
        t: 0,
        b: 0,
        l: 0,
        r: 0
      };
      var margins = gd._fullLayout._reservedMargin;
      for (var key in margins) {
        for (var side in margins[key]) {
          var val = margins[key][side];
          reservedMargins[side] = Math.max(reservedMargins[side], val);
        }
      }
      var paperbb = {
        left: reservedMargins.l,
        top: reservedMargins.t,
        right: fullLayout.width - reservedMargins.r,
        bottom: fullLayout.height - reservedMargins.b
      };
      var maxshift = avoid.maxShift || shiftSign * (paperbb[avoid.side] - titlebb[avoid.side]);
      var shift = 0;

      // Prevent the title going off the paper
      if (maxshift < 0) {
        shift = maxshift;
      } else {
        // so we don't have to offset each avoided element,
        // give the title the opposite offset
        var offsetLeft = avoid.offsetLeft || 0;
        var offsetTop = avoid.offsetTop || 0;
        titlebb.left -= offsetLeft;
        titlebb.right -= offsetLeft;
        titlebb.top -= offsetTop;
        titlebb.bottom -= offsetTop;

        // iterate over a set of elements (avoid.selection)
        // to avoid collisions with
        avoid.selection.each(function () {
          var avoidbb = Drawing.bBox(this);
          if (Lib.bBoxIntersect(titlebb, avoidbb, pad)) {
            shift = Math.max(shift, shiftSign * (avoidbb[avoid.side] - titlebb[backside]) + pad);
          }
        });
        shift = Math.min(maxshift, shift);
        // Keeping track of this for calculation of full axis size if needed
        cont._titleScoot = Math.abs(shift);
      }
      if (shift > 0 || maxshift < 0) {
        var shiftTemplate = {
          left: [-shift, 0],
          right: [shift, 0],
          top: [0, -shift],
          bottom: [0, shift]
        }[avoid.side];
        titleGroup.attr('transform', strTranslate(shiftTemplate[0], shiftTemplate[1]));
      }
    }
  }
  el.call(titleLayout);
  function setPlaceholder() {
    opacity = 0;
    isplaceholder = true;
    el.text(placeholder).on('mouseover.opacity', function () {
      d3.select(this).transition().duration(interactConstants.SHOW_PLACEHOLDER).style('opacity', 1);
    }).on('mouseout.opacity', function () {
      d3.select(this).transition().duration(interactConstants.HIDE_PLACEHOLDER).style('opacity', 0);
    });
  }
  if (editable) {
    if (!txt) setPlaceholder();else el.on('.opacity', null);
    el.call(svgTextUtils.makeEditable, {
      gd: gd
    }).on('edit', function (text) {
      if (traceIndex !== undefined) {
        Registry.call('_guiRestyle', gd, prop, text, traceIndex);
      } else {
        Registry.call('_guiRelayout', gd, prop, text);
      }
    }).on('cancel', function () {
      this.text(this.attr('data-unformatted')).call(titleLayout);
    }).on('input', function (d) {
      this.text(d || ' ').call(svgTextUtils.positionText, attributes.x, attributes.y);
    });
  }
  el.classed('js-placeholder', isplaceholder);
  return group;
}
module.exports = {
  draw: draw
};

/***/ }),

/***/ 7163:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var fontAttrs = __webpack_require__(1940);
var colorAttrs = __webpack_require__(2399);
var extendFlat = (__webpack_require__(1426).extendFlat);
var overrideAll = (__webpack_require__(962).overrideAll);
var padAttrs = __webpack_require__(5025);
var templatedArray = (__webpack_require__(4467).templatedArray);
var buttonsAttrs = templatedArray('button', {
  visible: {
    valType: 'boolean'
  },
  method: {
    valType: 'enumerated',
    values: ['restyle', 'relayout', 'animate', 'update', 'skip'],
    dflt: 'restyle'
  },
  args: {
    valType: 'info_array',
    freeLength: true,
    items: [{
      valType: 'any'
    }, {
      valType: 'any'
    }, {
      valType: 'any'
    }]
  },
  args2: {
    valType: 'info_array',
    freeLength: true,
    items: [{
      valType: 'any'
    }, {
      valType: 'any'
    }, {
      valType: 'any'
    }]
  },
  label: {
    valType: 'string',
    dflt: ''
  },
  execute: {
    valType: 'boolean',
    dflt: true
  }
});
module.exports = overrideAll(templatedArray('updatemenu', {
  _arrayAttrRegexps: [/^updatemenus\[(0|[1-9][0-9]+)\]\.buttons/],
  visible: {
    valType: 'boolean'
  },
  type: {
    valType: 'enumerated',
    values: ['dropdown', 'buttons'],
    dflt: 'dropdown'
  },
  direction: {
    valType: 'enumerated',
    values: ['left', 'right', 'up', 'down'],
    dflt: 'down'
  },
  active: {
    valType: 'integer',
    min: -1,
    dflt: 0
  },
  showactive: {
    valType: 'boolean',
    dflt: true
  },
  buttons: buttonsAttrs,
  x: {
    valType: 'number',
    min: -2,
    max: 3,
    dflt: -0.05
  },
  xanchor: {
    valType: 'enumerated',
    values: ['auto', 'left', 'center', 'right'],
    dflt: 'right'
  },
  y: {
    valType: 'number',
    min: -2,
    max: 3,
    dflt: 1
  },
  yanchor: {
    valType: 'enumerated',
    values: ['auto', 'top', 'middle', 'bottom'],
    dflt: 'top'
  },
  pad: extendFlat(padAttrs({
    editType: 'arraydraw'
  }), {}),
  font: fontAttrs({}),
  bgcolor: {
    valType: 'color'
  },
  bordercolor: {
    valType: 'color',
    dflt: colorAttrs.borderLine
  },
  borderwidth: {
    valType: 'number',
    min: 0,
    dflt: 1,
    editType: 'arraydraw'
  }
}), 'arraydraw', 'from-root');

/***/ }),

/***/ 5909:
/***/ (function(module) {

"use strict";


module.exports = {
  // layout attribute name
  name: 'updatemenus',
  // class names
  containerClassName: 'updatemenu-container',
  headerGroupClassName: 'updatemenu-header-group',
  headerClassName: 'updatemenu-header',
  headerArrowClassName: 'updatemenu-header-arrow',
  dropdownButtonGroupClassName: 'updatemenu-dropdown-button-group',
  dropdownButtonClassName: 'updatemenu-dropdown-button',
  buttonClassName: 'updatemenu-button',
  itemRectClassName: 'updatemenu-item-rect',
  itemTextClassName: 'updatemenu-item-text',
  // DOM attribute name in button group keeping track
  // of active update menu
  menuIndexAttrName: 'updatemenu-active-index',
  // id root pass to Plots.autoMargin
  autoMarginIdRoot: 'updatemenu-',
  // options when 'active: -1'
  blankHeaderOpts: {
    label: '  '
  },
  // min item width / height
  minWidth: 30,
  minHeight: 30,
  // padding around item text
  textPadX: 24,
  arrowPadX: 16,
  // item rect radii
  rx: 2,
  ry: 2,
  // item  text x offset off left edge
  textOffsetX: 12,
  // item  text y offset (w.r.t. middle)
  textOffsetY: 3,
  // arrow offset off right edge
  arrowOffsetX: 4,
  // gap between header and buttons
  gapButtonHeader: 5,
  // gap between between buttons
  gapButton: 2,
  // color given to active buttons
  activeColor: '#F4FAFF',
  // color given to hovered buttons
  hoverColor: '#F4FAFF',
  // symbol for menu open arrow
  arrowSymbol: {
    left: '◄',
    right: '►',
    up: '▲',
    down: '▼'
  }
};

/***/ }),

/***/ 4897:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var handleArrayContainerDefaults = __webpack_require__(5501);
var attributes = __webpack_require__(7163);
var constants = __webpack_require__(5909);
var name = constants.name;
var buttonAttrs = attributes.buttons;
module.exports = function updateMenusDefaults(layoutIn, layoutOut) {
  var opts = {
    name: name,
    handleItemDefaults: menuDefaults
  };
  handleArrayContainerDefaults(layoutIn, layoutOut, opts);
};
function menuDefaults(menuIn, menuOut, layoutOut) {
  function coerce(attr, dflt) {
    return Lib.coerce(menuIn, menuOut, attributes, attr, dflt);
  }
  var buttons = handleArrayContainerDefaults(menuIn, menuOut, {
    name: 'buttons',
    handleItemDefaults: buttonDefaults
  });
  var visible = coerce('visible', buttons.length > 0);
  if (!visible) return;
  coerce('active');
  coerce('direction');
  coerce('type');
  coerce('showactive');
  coerce('x');
  coerce('y');
  Lib.noneOrAll(menuIn, menuOut, ['x', 'y']);
  coerce('xanchor');
  coerce('yanchor');
  coerce('pad.t');
  coerce('pad.r');
  coerce('pad.b');
  coerce('pad.l');
  Lib.coerceFont(coerce, 'font', layoutOut.font);
  coerce('bgcolor', layoutOut.paper_bgcolor);
  coerce('bordercolor');
  coerce('borderwidth');
}
function buttonDefaults(buttonIn, buttonOut) {
  function coerce(attr, dflt) {
    return Lib.coerce(buttonIn, buttonOut, buttonAttrs, attr, dflt);
  }
  var visible = coerce('visible', buttonIn.method === 'skip' || Array.isArray(buttonIn.args));
  if (visible) {
    coerce('method');
    coerce('args');
    coerce('args2');
    coerce('label');
    coerce('execute');
  }
}

/***/ }),

/***/ 3689:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Plots = __webpack_require__(4875);
var Color = __webpack_require__(7901);
var Drawing = __webpack_require__(1424);
var Lib = __webpack_require__(1828);
var svgTextUtils = __webpack_require__(3893);
var arrayEditor = (__webpack_require__(4467).arrayEditor);
var LINE_SPACING = (__webpack_require__(8783).LINE_SPACING);
var constants = __webpack_require__(5909);
var ScrollBox = __webpack_require__(5849);
module.exports = function draw(gd) {
  var fullLayout = gd._fullLayout;
  var menuData = Lib.filterVisible(fullLayout[constants.name]);

  /* Update menu data is bound to the header-group.
   * The items in the header group are always present.
   *
   * Upon clicking on a header its corresponding button
   * data is bound to the button-group.
   *
   * We draw all headers in one group before all buttons
   * so that the buttons *always* appear above the headers.
   *
   * Note that only one set of buttons are visible at once.
   *
   * <g container />
   *
   *     <g header-group />
   *         <g item header />
   *         <text item header-arrow />
   *     <g header-group />
   *         <g item header />
   *         <text item header-arrow />
   *     ...
   *
   *     <g button-group />
   *         <g item button />
   *         <g item button />
   *         ...
   */

  function clearAutoMargin(menuOpts) {
    Plots.autoMargin(gd, autoMarginId(menuOpts));
  }

  // draw update menu container
  var menus = fullLayout._menulayer.selectAll('g.' + constants.containerClassName).data(menuData.length > 0 ? [0] : []);
  menus.enter().append('g').classed(constants.containerClassName, true).style('cursor', 'pointer');
  menus.exit().each(function () {
    // Most components don't need to explicitly remove autoMargin, because
    // marginPushers does this - but updatemenu updates don't go through
    // a full replot so we need to explicitly remove it.
    // This is for removing *all* updatemenus, removing individuals is
    // handled below, in headerGroups.exit
    d3.select(this).selectAll('g.' + constants.headerGroupClassName).each(clearAutoMargin);
  }).remove();

  // return early if no update menus are visible
  if (menuData.length === 0) return;

  // join header group
  var headerGroups = menus.selectAll('g.' + constants.headerGroupClassName).data(menuData, keyFunction);
  headerGroups.enter().append('g').classed(constants.headerGroupClassName, true);

  // draw dropdown button container
  var gButton = Lib.ensureSingle(menus, 'g', constants.dropdownButtonGroupClassName, function (s) {
    s.style('pointer-events', 'all');
  });

  // find dimensions before plotting anything (this mutates menuOpts)
  for (var i = 0; i < menuData.length; i++) {
    var menuOpts = menuData[i];
    findDimensions(gd, menuOpts);
  }

  // setup scrollbox
  var scrollBoxId = 'updatemenus' + fullLayout._uid;
  var scrollBox = new ScrollBox(gd, gButton, scrollBoxId);

  // remove exiting header, remove dropped buttons and reset margins
  if (headerGroups.enter().size()) {
    // make sure gButton is on top of all headers
    gButton.node().parentNode.appendChild(gButton.node());
    gButton.call(removeAllButtons);
  }
  headerGroups.exit().each(function (menuOpts) {
    gButton.call(removeAllButtons);
    clearAutoMargin(menuOpts);
  }).remove();

  // draw headers!
  headerGroups.each(function (menuOpts) {
    var gHeader = d3.select(this);
    var _gButton = menuOpts.type === 'dropdown' ? gButton : null;
    Plots.manageCommandObserver(gd, menuOpts, menuOpts.buttons, function (data) {
      setActive(gd, menuOpts, menuOpts.buttons[data.index], gHeader, _gButton, scrollBox, data.index, true);
    });
    if (menuOpts.type === 'dropdown') {
      drawHeader(gd, gHeader, gButton, scrollBox, menuOpts);

      // if this menu is active, update the dropdown container
      if (isActive(gButton, menuOpts)) {
        drawButtons(gd, gHeader, gButton, scrollBox, menuOpts);
      }
    } else {
      drawButtons(gd, gHeader, null, null, menuOpts);
    }
  });
};

// Note that '_index' is set at the default step,
// it corresponds to the menu index in the user layout update menu container.
// Because a menu can be set invisible,
// this is a more 'consistent' field than the index in the menuData.
function keyFunction(menuOpts) {
  return menuOpts._index;
}
function isFolded(gButton) {
  return +gButton.attr(constants.menuIndexAttrName) === -1;
}
function isActive(gButton, menuOpts) {
  return +gButton.attr(constants.menuIndexAttrName) === menuOpts._index;
}
function setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, buttonIndex, isSilentUpdate) {
  // update 'active' attribute in menuOpts
  menuOpts.active = buttonIndex;

  // due to templating, it's possible this slider doesn't even exist yet
  arrayEditor(gd.layout, constants.name, menuOpts).applyUpdate('active', buttonIndex);
  if (menuOpts.type === 'buttons') {
    drawButtons(gd, gHeader, null, null, menuOpts);
  } else if (menuOpts.type === 'dropdown') {
    // fold up buttons and redraw header
    gButton.attr(constants.menuIndexAttrName, '-1');
    drawHeader(gd, gHeader, gButton, scrollBox, menuOpts);
    if (!isSilentUpdate) {
      drawButtons(gd, gHeader, gButton, scrollBox, menuOpts);
    }
  }
}
function drawHeader(gd, gHeader, gButton, scrollBox, menuOpts) {
  var header = Lib.ensureSingle(gHeader, 'g', constants.headerClassName, function (s) {
    s.style('pointer-events', 'all');
  });
  var dims = menuOpts._dims;
  var active = menuOpts.active;
  var headerOpts = menuOpts.buttons[active] || constants.blankHeaderOpts;
  var posOpts = {
    y: menuOpts.pad.t,
    yPad: 0,
    x: menuOpts.pad.l,
    xPad: 0,
    index: 0
  };
  var positionOverrides = {
    width: dims.headerWidth,
    height: dims.headerHeight
  };
  header.call(drawItem, menuOpts, headerOpts, gd).call(setItemPosition, menuOpts, posOpts, positionOverrides);

  // draw drop arrow at the right edge
  var arrow = Lib.ensureSingle(gHeader, 'text', constants.headerArrowClassName, function (s) {
    s.attr('text-anchor', 'end').call(Drawing.font, menuOpts.font).text(constants.arrowSymbol[menuOpts.direction]);
  });
  arrow.attr({
    x: dims.headerWidth - constants.arrowOffsetX + menuOpts.pad.l,
    y: dims.headerHeight / 2 + constants.textOffsetY + menuOpts.pad.t
  });
  header.on('click', function () {
    gButton.call(removeAllButtons, String(isActive(gButton, menuOpts) ? -1 : menuOpts._index));
    drawButtons(gd, gHeader, gButton, scrollBox, menuOpts);
  });
  header.on('mouseover', function () {
    header.call(styleOnMouseOver);
  });
  header.on('mouseout', function () {
    header.call(styleOnMouseOut, menuOpts);
  });

  // translate header group
  Drawing.setTranslate(gHeader, dims.lx, dims.ly);
}
function drawButtons(gd, gHeader, gButton, scrollBox, menuOpts) {
  // If this is a set of buttons, set pointer events = all since we play
  // some minor games with which container is which in order to simplify
  // the drawing of *either* buttons or menus
  if (!gButton) {
    gButton = gHeader;
    gButton.attr('pointer-events', 'all');
  }
  var buttonData = !isFolded(gButton) || menuOpts.type === 'buttons' ? menuOpts.buttons : [];
  var klass = menuOpts.type === 'dropdown' ? constants.dropdownButtonClassName : constants.buttonClassName;
  var buttons = gButton.selectAll('g.' + klass).data(Lib.filterVisible(buttonData));
  var enter = buttons.enter().append('g').classed(klass, true);
  var exit = buttons.exit();
  if (menuOpts.type === 'dropdown') {
    enter.attr('opacity', '0').transition().attr('opacity', '1');
    exit.transition().attr('opacity', '0').remove();
  } else {
    exit.remove();
  }
  var x0 = 0;
  var y0 = 0;
  var dims = menuOpts._dims;
  var isVertical = ['up', 'down'].indexOf(menuOpts.direction) !== -1;
  if (menuOpts.type === 'dropdown') {
    if (isVertical) {
      y0 = dims.headerHeight + constants.gapButtonHeader;
    } else {
      x0 = dims.headerWidth + constants.gapButtonHeader;
    }
  }
  if (menuOpts.type === 'dropdown' && menuOpts.direction === 'up') {
    y0 = -constants.gapButtonHeader + constants.gapButton - dims.openHeight;
  }
  if (menuOpts.type === 'dropdown' && menuOpts.direction === 'left') {
    x0 = -constants.gapButtonHeader + constants.gapButton - dims.openWidth;
  }
  var posOpts = {
    x: dims.lx + x0 + menuOpts.pad.l,
    y: dims.ly + y0 + menuOpts.pad.t,
    yPad: constants.gapButton,
    xPad: constants.gapButton,
    index: 0
  };
  var scrollBoxPosition = {
    l: posOpts.x + menuOpts.borderwidth,
    t: posOpts.y + menuOpts.borderwidth
  };
  buttons.each(function (buttonOpts, buttonIndex) {
    var button = d3.select(this);
    button.call(drawItem, menuOpts, buttonOpts, gd).call(setItemPosition, menuOpts, posOpts);
    button.on('click', function () {
      // skip `dragend` events
      if (d3.event.defaultPrevented) return;
      if (buttonOpts.execute) {
        if (buttonOpts.args2 && menuOpts.active === buttonIndex) {
          setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, -1);
          Plots.executeAPICommand(gd, buttonOpts.method, buttonOpts.args2);
        } else {
          setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, buttonIndex);
          Plots.executeAPICommand(gd, buttonOpts.method, buttonOpts.args);
        }
      }
      gd.emit('plotly_buttonclicked', {
        menu: menuOpts,
        button: buttonOpts,
        active: menuOpts.active
      });
    });
    button.on('mouseover', function () {
      button.call(styleOnMouseOver);
    });
    button.on('mouseout', function () {
      button.call(styleOnMouseOut, menuOpts);
      buttons.call(styleButtons, menuOpts);
    });
  });
  buttons.call(styleButtons, menuOpts);
  if (isVertical) {
    scrollBoxPosition.w = Math.max(dims.openWidth, dims.headerWidth);
    scrollBoxPosition.h = posOpts.y - scrollBoxPosition.t;
  } else {
    scrollBoxPosition.w = posOpts.x - scrollBoxPosition.l;
    scrollBoxPosition.h = Math.max(dims.openHeight, dims.headerHeight);
  }
  scrollBoxPosition.direction = menuOpts.direction;
  if (scrollBox) {
    if (buttons.size()) {
      drawScrollBox(gd, gHeader, gButton, scrollBox, menuOpts, scrollBoxPosition);
    } else {
      hideScrollBox(scrollBox);
    }
  }
}
function drawScrollBox(gd, gHeader, gButton, scrollBox, menuOpts, position) {
  // enable the scrollbox
  var direction = menuOpts.direction;
  var isVertical = direction === 'up' || direction === 'down';
  var dims = menuOpts._dims;
  var active = menuOpts.active;
  var translateX, translateY;
  var i;
  if (isVertical) {
    translateY = 0;
    for (i = 0; i < active; i++) {
      translateY += dims.heights[i] + constants.gapButton;
    }
  } else {
    translateX = 0;
    for (i = 0; i < active; i++) {
      translateX += dims.widths[i] + constants.gapButton;
    }
  }
  scrollBox.enable(position, translateX, translateY);
  if (scrollBox.hbar) {
    scrollBox.hbar.attr('opacity', '0').transition().attr('opacity', '1');
  }
  if (scrollBox.vbar) {
    scrollBox.vbar.attr('opacity', '0').transition().attr('opacity', '1');
  }
}
function hideScrollBox(scrollBox) {
  var hasHBar = !!scrollBox.hbar;
  var hasVBar = !!scrollBox.vbar;
  if (hasHBar) {
    scrollBox.hbar.transition().attr('opacity', '0').each('end', function () {
      hasHBar = false;
      if (!hasVBar) scrollBox.disable();
    });
  }
  if (hasVBar) {
    scrollBox.vbar.transition().attr('opacity', '0').each('end', function () {
      hasVBar = false;
      if (!hasHBar) scrollBox.disable();
    });
  }
}
function drawItem(item, menuOpts, itemOpts, gd) {
  item.call(drawItemRect, menuOpts).call(drawItemText, menuOpts, itemOpts, gd);
}
function drawItemRect(item, menuOpts) {
  var rect = Lib.ensureSingle(item, 'rect', constants.itemRectClassName, function (s) {
    s.attr({
      rx: constants.rx,
      ry: constants.ry,
      'shape-rendering': 'crispEdges'
    });
  });
  rect.call(Color.stroke, menuOpts.bordercolor).call(Color.fill, menuOpts.bgcolor).style('stroke-width', menuOpts.borderwidth + 'px');
}
function drawItemText(item, menuOpts, itemOpts, gd) {
  var text = Lib.ensureSingle(item, 'text', constants.itemTextClassName, function (s) {
    s.attr({
      'text-anchor': 'start',
      'data-notex': 1
    });
  });
  var tx = itemOpts.label;
  var _meta = gd._fullLayout._meta;
  if (_meta) tx = Lib.templateString(tx, _meta);
  text.call(Drawing.font, menuOpts.font).text(tx).call(svgTextUtils.convertToTspans, gd);
}
function styleButtons(buttons, menuOpts) {
  var active = menuOpts.active;
  buttons.each(function (buttonOpts, i) {
    var button = d3.select(this);
    if (i === active && menuOpts.showactive) {
      button.select('rect.' + constants.itemRectClassName).call(Color.fill, constants.activeColor);
    }
  });
}
function styleOnMouseOver(item) {
  item.select('rect.' + constants.itemRectClassName).call(Color.fill, constants.hoverColor);
}
function styleOnMouseOut(item, menuOpts) {
  item.select('rect.' + constants.itemRectClassName).call(Color.fill, menuOpts.bgcolor);
}

// find item dimensions (this mutates menuOpts)
function findDimensions(gd, menuOpts) {
  var dims = menuOpts._dims = {
    width1: 0,
    height1: 0,
    heights: [],
    widths: [],
    totalWidth: 0,
    totalHeight: 0,
    openWidth: 0,
    openHeight: 0,
    lx: 0,
    ly: 0
  };
  var fakeButtons = Drawing.tester.selectAll('g.' + constants.dropdownButtonClassName).data(Lib.filterVisible(menuOpts.buttons));
  fakeButtons.enter().append('g').classed(constants.dropdownButtonClassName, true);
  var isVertical = ['up', 'down'].indexOf(menuOpts.direction) !== -1;

  // loop over fake buttons to find width / height
  fakeButtons.each(function (buttonOpts, i) {
    var button = d3.select(this);
    button.call(drawItem, menuOpts, buttonOpts, gd);
    var text = button.select('.' + constants.itemTextClassName);

    // width is given by max width of all buttons
    var tWidth = text.node() && Drawing.bBox(text.node()).width;
    var wEff = Math.max(tWidth + constants.textPadX, constants.minWidth);

    // height is determined by item text
    var tHeight = menuOpts.font.size * LINE_SPACING;
    var tLines = svgTextUtils.lineCount(text);
    var hEff = Math.max(tHeight * tLines, constants.minHeight) + constants.textOffsetY;
    hEff = Math.ceil(hEff);
    wEff = Math.ceil(wEff);

    // Store per-item sizes since a row of horizontal buttons, for example,
    // don't all need to be the same width:
    dims.widths[i] = wEff;
    dims.heights[i] = hEff;

    // Height and width of individual element:
    dims.height1 = Math.max(dims.height1, hEff);
    dims.width1 = Math.max(dims.width1, wEff);
    if (isVertical) {
      dims.totalWidth = Math.max(dims.totalWidth, wEff);
      dims.openWidth = dims.totalWidth;
      dims.totalHeight += hEff + constants.gapButton;
      dims.openHeight += hEff + constants.gapButton;
    } else {
      dims.totalWidth += wEff + constants.gapButton;
      dims.openWidth += wEff + constants.gapButton;
      dims.totalHeight = Math.max(dims.totalHeight, hEff);
      dims.openHeight = dims.totalHeight;
    }
  });
  if (isVertical) {
    dims.totalHeight -= constants.gapButton;
  } else {
    dims.totalWidth -= constants.gapButton;
  }
  dims.headerWidth = dims.width1 + constants.arrowPadX;
  dims.headerHeight = dims.height1;
  if (menuOpts.type === 'dropdown') {
    if (isVertical) {
      dims.width1 += constants.arrowPadX;
      dims.totalHeight = dims.height1;
    } else {
      dims.totalWidth = dims.width1;
    }
    dims.totalWidth += constants.arrowPadX;
  }
  fakeButtons.remove();
  var paddedWidth = dims.totalWidth + menuOpts.pad.l + menuOpts.pad.r;
  var paddedHeight = dims.totalHeight + menuOpts.pad.t + menuOpts.pad.b;
  var graphSize = gd._fullLayout._size;
  dims.lx = graphSize.l + graphSize.w * menuOpts.x;
  dims.ly = graphSize.t + graphSize.h * (1 - menuOpts.y);
  var xanchor = 'left';
  if (Lib.isRightAnchor(menuOpts)) {
    dims.lx -= paddedWidth;
    xanchor = 'right';
  }
  if (Lib.isCenterAnchor(menuOpts)) {
    dims.lx -= paddedWidth / 2;
    xanchor = 'center';
  }
  var yanchor = 'top';
  if (Lib.isBottomAnchor(menuOpts)) {
    dims.ly -= paddedHeight;
    yanchor = 'bottom';
  }
  if (Lib.isMiddleAnchor(menuOpts)) {
    dims.ly -= paddedHeight / 2;
    yanchor = 'middle';
  }
  dims.totalWidth = Math.ceil(dims.totalWidth);
  dims.totalHeight = Math.ceil(dims.totalHeight);
  dims.lx = Math.round(dims.lx);
  dims.ly = Math.round(dims.ly);
  Plots.autoMargin(gd, autoMarginId(menuOpts), {
    x: menuOpts.x,
    y: menuOpts.y,
    l: paddedWidth * ({
      right: 1,
      center: 0.5
    }[xanchor] || 0),
    r: paddedWidth * ({
      left: 1,
      center: 0.5
    }[xanchor] || 0),
    b: paddedHeight * ({
      top: 1,
      middle: 0.5
    }[yanchor] || 0),
    t: paddedHeight * ({
      bottom: 1,
      middle: 0.5
    }[yanchor] || 0)
  });
}
function autoMarginId(menuOpts) {
  return constants.autoMarginIdRoot + menuOpts._index;
}

// set item positions (mutates posOpts)
function setItemPosition(item, menuOpts, posOpts, overrideOpts) {
  overrideOpts = overrideOpts || {};
  var rect = item.select('.' + constants.itemRectClassName);
  var text = item.select('.' + constants.itemTextClassName);
  var borderWidth = menuOpts.borderwidth;
  var index = posOpts.index;
  var dims = menuOpts._dims;
  Drawing.setTranslate(item, borderWidth + posOpts.x, borderWidth + posOpts.y);
  var isVertical = ['up', 'down'].indexOf(menuOpts.direction) !== -1;
  var finalHeight = overrideOpts.height || (isVertical ? dims.heights[index] : dims.height1);
  rect.attr({
    x: 0,
    y: 0,
    width: overrideOpts.width || (isVertical ? dims.width1 : dims.widths[index]),
    height: finalHeight
  });
  var tHeight = menuOpts.font.size * LINE_SPACING;
  var tLines = svgTextUtils.lineCount(text);
  var spanOffset = (tLines - 1) * tHeight / 2;
  svgTextUtils.positionText(text, constants.textOffsetX, finalHeight / 2 - spanOffset + constants.textOffsetY);
  if (isVertical) {
    posOpts.y += dims.heights[index] + posOpts.yPad;
  } else {
    posOpts.x += dims.widths[index] + posOpts.xPad;
  }
  posOpts.index++;
}
function removeAllButtons(gButton, newMenuIndexAttr) {
  gButton.attr(constants.menuIndexAttrName, newMenuIndexAttr || '-1').selectAll('g.' + constants.dropdownButtonClassName).remove();
}

/***/ }),

/***/ 763:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var constants = __webpack_require__(5909);
module.exports = {
  moduleType: 'component',
  name: constants.name,
  layoutAttributes: __webpack_require__(7163),
  supplyLayoutDefaults: __webpack_require__(4897),
  draw: __webpack_require__(3689)
};

/***/ }),

/***/ 5849:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = ScrollBox;
var d3 = __webpack_require__(9898);
var Color = __webpack_require__(7901);
var Drawing = __webpack_require__(1424);
var Lib = __webpack_require__(1828);

/**
 * Helper class to setup a scroll box
 *
 * @class
 * @param           gd          Plotly's graph div
 * @param           container   Container to be scroll-boxed (as a D3 selection)
 * @param {string}  id          Id for the clip path to implement the scroll box
 */
function ScrollBox(gd, container, id) {
  this.gd = gd;
  this.container = container;
  this.id = id;

  // See ScrollBox.prototype.enable for further definition
  this.position = null; // scrollbox position
  this.translateX = null; // scrollbox horizontal translation
  this.translateY = null; // scrollbox vertical translation
  this.hbar = null; // horizontal scrollbar D3 selection
  this.vbar = null; // vertical scrollbar D3 selection

  // <rect> element to capture pointer events
  this.bg = this.container.selectAll('rect.scrollbox-bg').data([0]);
  this.bg.exit().on('.drag', null).on('wheel', null).remove();
  this.bg.enter().append('rect').classed('scrollbox-bg', true).style('pointer-events', 'all').attr({
    opacity: 0,
    x: 0,
    y: 0,
    width: 0,
    height: 0
  });
}

// scroll bar dimensions
ScrollBox.barWidth = 2;
ScrollBox.barLength = 20;
ScrollBox.barRadius = 2;
ScrollBox.barPad = 1;
ScrollBox.barColor = '#808BA4';

/**
 * If needed, setup a clip path and scrollbars
 *
 * @method
 * @param {Object}  position
 * @param {number}  position.l  Left side position (in pixels)
 * @param {number}  position.t  Top side (in pixels)
 * @param {number}  position.w  Width (in pixels)
 * @param {number}  position.h  Height (in pixels)
 * @param {string}  [position.direction='down']
 *                  Either 'down', 'left', 'right' or 'up'
 * @param {number}  [translateX=0]  Horizontal offset (in pixels)
 * @param {number}  [translateY=0]  Vertical offset (in pixels)
 */
ScrollBox.prototype.enable = function enable(position, translateX, translateY) {
  var fullLayout = this.gd._fullLayout;
  var fullWidth = fullLayout.width;
  var fullHeight = fullLayout.height;

  // compute position of scrollbox
  this.position = position;
  var l = this.position.l;
  var w = this.position.w;
  var t = this.position.t;
  var h = this.position.h;
  var direction = this.position.direction;
  var isDown = direction === 'down';
  var isLeft = direction === 'left';
  var isRight = direction === 'right';
  var isUp = direction === 'up';
  var boxW = w;
  var boxH = h;
  var boxL, boxR;
  var boxT, boxB;
  if (!isDown && !isLeft && !isRight && !isUp) {
    this.position.direction = 'down';
    isDown = true;
  }
  var isVertical = isDown || isUp;
  if (isVertical) {
    boxL = l;
    boxR = boxL + boxW;
    if (isDown) {
      // anchor to top side
      boxT = t;
      boxB = Math.min(boxT + boxH, fullHeight);
      boxH = boxB - boxT;
    } else {
      // anchor to bottom side
      boxB = t + boxH;
      boxT = Math.max(boxB - boxH, 0);
      boxH = boxB - boxT;
    }
  } else {
    boxT = t;
    boxB = boxT + boxH;
    if (isLeft) {
      // anchor to right side
      boxR = l + boxW;
      boxL = Math.max(boxR - boxW, 0);
      boxW = boxR - boxL;
    } else {
      // anchor to left side
      boxL = l;
      boxR = Math.min(boxL + boxW, fullWidth);
      boxW = boxR - boxL;
    }
  }
  this._box = {
    l: boxL,
    t: boxT,
    w: boxW,
    h: boxH
  };

  // compute position of horizontal scroll bar
  var needsHorizontalScrollBar = w > boxW;
  var hbarW = ScrollBox.barLength + 2 * ScrollBox.barPad;
  var hbarH = ScrollBox.barWidth + 2 * ScrollBox.barPad;
  // draw horizontal scrollbar on the bottom side
  var hbarL = l;
  var hbarT = t + h;
  if (hbarT + hbarH > fullHeight) hbarT = fullHeight - hbarH;
  var hbar = this.container.selectAll('rect.scrollbar-horizontal').data(needsHorizontalScrollBar ? [0] : []);
  hbar.exit().on('.drag', null).remove();
  hbar.enter().append('rect').classed('scrollbar-horizontal', true).call(Color.fill, ScrollBox.barColor);
  if (needsHorizontalScrollBar) {
    this.hbar = hbar.attr({
      rx: ScrollBox.barRadius,
      ry: ScrollBox.barRadius,
      x: hbarL,
      y: hbarT,
      width: hbarW,
      height: hbarH
    });

    // hbar center moves between hbarXMin and hbarXMin + hbarTranslateMax
    this._hbarXMin = hbarL + hbarW / 2;
    this._hbarTranslateMax = boxW - hbarW;
  } else {
    delete this.hbar;
    delete this._hbarXMin;
    delete this._hbarTranslateMax;
  }

  // compute position of vertical scroll bar
  var needsVerticalScrollBar = h > boxH;
  var vbarW = ScrollBox.barWidth + 2 * ScrollBox.barPad;
  var vbarH = ScrollBox.barLength + 2 * ScrollBox.barPad;
  // draw vertical scrollbar on the right side
  var vbarL = l + w;
  var vbarT = t;
  if (vbarL + vbarW > fullWidth) vbarL = fullWidth - vbarW;
  var vbar = this.container.selectAll('rect.scrollbar-vertical').data(needsVerticalScrollBar ? [0] : []);
  vbar.exit().on('.drag', null).remove();
  vbar.enter().append('rect').classed('scrollbar-vertical', true).call(Color.fill, ScrollBox.barColor);
  if (needsVerticalScrollBar) {
    this.vbar = vbar.attr({
      rx: ScrollBox.barRadius,
      ry: ScrollBox.barRadius,
      x: vbarL,
      y: vbarT,
      width: vbarW,
      height: vbarH
    });

    // vbar center moves between vbarYMin and vbarYMin + vbarTranslateMax
    this._vbarYMin = vbarT + vbarH / 2;
    this._vbarTranslateMax = boxH - vbarH;
  } else {
    delete this.vbar;
    delete this._vbarYMin;
    delete this._vbarTranslateMax;
  }

  // setup a clip path (if scroll bars are needed)
  var clipId = this.id;
  var clipL = boxL - 0.5;
  var clipR = needsVerticalScrollBar ? boxR + vbarW + 0.5 : boxR + 0.5;
  var clipT = boxT - 0.5;
  var clipB = needsHorizontalScrollBar ? boxB + hbarH + 0.5 : boxB + 0.5;
  var clipPath = fullLayout._topdefs.selectAll('#' + clipId).data(needsHorizontalScrollBar || needsVerticalScrollBar ? [0] : []);
  clipPath.exit().remove();
  clipPath.enter().append('clipPath').attr('id', clipId).append('rect');
  if (needsHorizontalScrollBar || needsVerticalScrollBar) {
    this._clipRect = clipPath.select('rect').attr({
      x: Math.floor(clipL),
      y: Math.floor(clipT),
      width: Math.ceil(clipR) - Math.floor(clipL),
      height: Math.ceil(clipB) - Math.floor(clipT)
    });
    this.container.call(Drawing.setClipUrl, clipId, this.gd);
    this.bg.attr({
      x: l,
      y: t,
      width: w,
      height: h
    });
  } else {
    this.bg.attr({
      width: 0,
      height: 0
    });
    this.container.on('wheel', null).on('.drag', null).call(Drawing.setClipUrl, null);
    delete this._clipRect;
  }

  // set up drag listeners (if scroll bars are needed)
  if (needsHorizontalScrollBar || needsVerticalScrollBar) {
    var onBoxDrag = d3.behavior.drag().on('dragstart', function () {
      d3.event.sourceEvent.preventDefault();
    }).on('drag', this._onBoxDrag.bind(this));
    this.container.on('wheel', null).on('wheel', this._onBoxWheel.bind(this)).on('.drag', null).call(onBoxDrag);
    var onBarDrag = d3.behavior.drag().on('dragstart', function () {
      d3.event.sourceEvent.preventDefault();
      d3.event.sourceEvent.stopPropagation();
    }).on('drag', this._onBarDrag.bind(this));
    if (needsHorizontalScrollBar) {
      this.hbar.on('.drag', null).call(onBarDrag);
    }
    if (needsVerticalScrollBar) {
      this.vbar.on('.drag', null).call(onBarDrag);
    }
  }

  // set scrollbox translation
  this.setTranslate(translateX, translateY);
};

/**
 * If present, remove clip-path and scrollbars
 *
 * @method
 */
ScrollBox.prototype.disable = function disable() {
  if (this.hbar || this.vbar) {
    this.bg.attr({
      width: 0,
      height: 0
    });
    this.container.on('wheel', null).on('.drag', null).call(Drawing.setClipUrl, null);
    delete this._clipRect;
  }
  if (this.hbar) {
    this.hbar.on('.drag', null);
    this.hbar.remove();
    delete this.hbar;
    delete this._hbarXMin;
    delete this._hbarTranslateMax;
  }
  if (this.vbar) {
    this.vbar.on('.drag', null);
    this.vbar.remove();
    delete this.vbar;
    delete this._vbarYMin;
    delete this._vbarTranslateMax;
  }
};

/**
 * Handles scroll box drag events
 *
 * @method
 */
ScrollBox.prototype._onBoxDrag = function _onBoxDrag() {
  var translateX = this.translateX;
  var translateY = this.translateY;
  if (this.hbar) {
    translateX -= d3.event.dx;
  }
  if (this.vbar) {
    translateY -= d3.event.dy;
  }
  this.setTranslate(translateX, translateY);
};

/**
 * Handles scroll box wheel events
 *
 * @method
 */
ScrollBox.prototype._onBoxWheel = function _onBoxWheel() {
  var translateX = this.translateX;
  var translateY = this.translateY;
  if (this.hbar) {
    translateX += d3.event.deltaY;
  }
  if (this.vbar) {
    translateY += d3.event.deltaY;
  }
  this.setTranslate(translateX, translateY);
};

/**
 * Handles scroll bar drag events
 *
 * @method
 */
ScrollBox.prototype._onBarDrag = function _onBarDrag() {
  var translateX = this.translateX;
  var translateY = this.translateY;
  if (this.hbar) {
    var xMin = translateX + this._hbarXMin;
    var xMax = xMin + this._hbarTranslateMax;
    var x = Lib.constrain(d3.event.x, xMin, xMax);
    var xf = (x - xMin) / (xMax - xMin);
    var translateXMax = this.position.w - this._box.w;
    translateX = xf * translateXMax;
  }
  if (this.vbar) {
    var yMin = translateY + this._vbarYMin;
    var yMax = yMin + this._vbarTranslateMax;
    var y = Lib.constrain(d3.event.y, yMin, yMax);
    var yf = (y - yMin) / (yMax - yMin);
    var translateYMax = this.position.h - this._box.h;
    translateY = yf * translateYMax;
  }
  this.setTranslate(translateX, translateY);
};

/**
 * Set clip path and scroll bar translate transform
 *
 * @method
 * @param {number}  [translateX=0]  Horizontal offset (in pixels)
 * @param {number}  [translateY=0]  Vertical offset (in pixels)
 */
ScrollBox.prototype.setTranslate = function setTranslate(translateX, translateY) {
  // store translateX and translateY (needed by mouse event handlers)
  var translateXMax = this.position.w - this._box.w;
  var translateYMax = this.position.h - this._box.h;
  translateX = Lib.constrain(translateX || 0, 0, translateXMax);
  translateY = Lib.constrain(translateY || 0, 0, translateYMax);
  this.translateX = translateX;
  this.translateY = translateY;
  this.container.call(Drawing.setTranslate, this._box.l - this.position.l - translateX, this._box.t - this.position.t - translateY);
  if (this._clipRect) {
    this._clipRect.attr({
      x: Math.floor(this.position.l + translateX - 0.5),
      y: Math.floor(this.position.t + translateY - 0.5)
    });
  }
  if (this.hbar) {
    var xf = translateX / translateXMax;
    this.hbar.call(Drawing.setTranslate, translateX + xf * this._hbarTranslateMax, translateY);
  }
  if (this.vbar) {
    var yf = translateY / translateYMax;
    this.vbar.call(Drawing.setTranslate, translateX, translateY + yf * this._vbarTranslateMax);
  }
};

/***/ }),

/***/ 8783:
/***/ (function(module) {

"use strict";


// fraction of some size to get to a named position
module.exports = {
  // from bottom left: this is the origin of our paper-reference
  // positioning system
  FROM_BL: {
    left: 0,
    center: 0.5,
    right: 1,
    bottom: 0,
    middle: 0.5,
    top: 1
  },
  // from top left: this is the screen pixel positioning origin
  FROM_TL: {
    left: 0,
    center: 0.5,
    right: 1,
    bottom: 1,
    middle: 0.5,
    top: 0
  },
  // from bottom right: sometimes you just need the opposite of ^^
  FROM_BR: {
    left: 1,
    center: 0.5,
    right: 0,
    bottom: 0,
    middle: 0.5,
    top: 1
  },
  // multiple of fontSize to get the vertical offset between lines
  LINE_SPACING: 1.3,
  // multiple of fontSize to shift from the baseline
  // to the cap (captical letter) line
  // (to use when we don't calculate this shift from Drawing.bBox)
  // This is an approximation since in reality cap height can differ
  // from font to font. However, according to Wikipedia
  //   an "average" font might have a cap height of 70% of the em
  // https://en.wikipedia.org/wiki/Em_(typography)#History
  CAP_SHIFT: 0.70,
  // half the cap height (distance between baseline and cap line)
  // of an "average" font (for more info see above).
  MID_SHIFT: 0.35,
  OPPOSITE_SIDE: {
    left: 'right',
    right: 'left',
    top: 'bottom',
    bottom: 'top'
  }
};

/***/ }),

/***/ 4695:
/***/ (function(module) {

"use strict";


module.exports = {
  axisRefDescription: function (axisname, lower, upper) {
    return ['If set to a', axisname, 'axis id (e.g. *' + axisname + '* or', '*' + axisname + '2*), the `' + axisname + '` position refers to a', axisname, 'coordinate. If set to *paper*, the `' + axisname + '`', 'position refers to the distance from the', lower, 'of the plotting', 'area in normalized coordinates where *0* (*1*) corresponds to the', lower, '(' + upper + '). If set to a', axisname, 'axis ID followed by', '*domain* (separated by a space), the position behaves like for', '*paper*, but refers to the distance in fractions of the domain', 'length from the', lower, 'of the domain of that axis: e.g.,', '*' + axisname + '2 domain* refers to the domain of the second', axisname, ' axis and a', axisname, 'position of 0.5 refers to the', 'point between the', lower, 'and the', upper, 'of the domain of the', 'second', axisname, 'axis.'].join(' ');
  }
};

/***/ }),

/***/ 1562:
/***/ (function(module) {

"use strict";


module.exports = {
  FORMAT_LINK: 'https://github.com/d3/d3-format/tree/v1.4.5#d3-format',
  DATE_FORMAT_LINK: 'https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format'
};

/***/ }),

/***/ 4808:
/***/ (function(module) {

"use strict";


module.exports = {
  COMPARISON_OPS: ['=', '!=', '<', '>=', '>', '<='],
  COMPARISON_OPS2: ['=', '<', '>=', '>', '<='],
  INTERVAL_OPS: ['[]', '()', '[)', '(]', '][', ')(', '](', ')['],
  SET_OPS: ['{}', '}{'],
  CONSTRAINT_REDUCTION: {
    // for contour constraints, open/closed endpoints are equivalent
    '=': '=',
    '<': '<',
    '<=': '<',
    '>': '>',
    '>=': '>',
    '[]': '[]',
    '()': '[]',
    '[)': '[]',
    '(]': '[]',
    '][': '][',
    ')(': '][',
    '](': '][',
    ')[': ']['
  }
};

/***/ }),

/***/ 9659:
/***/ (function(module) {

"use strict";


module.exports = {
  solid: [[], 0],
  dot: [[0.5, 1], 200],
  dash: [[0.5, 1], 50],
  longdash: [[0.5, 1], 10],
  dashdot: [[0.5, 0.625, 0.875, 1], 50],
  longdashdot: [[0.5, 0.7, 0.8, 1], 10]
};

/***/ }),

/***/ 7381:
/***/ (function(module) {

"use strict";


module.exports = {
  circle: '●',
  'circle-open': '○',
  square: '■',
  'square-open': '□',
  diamond: '◆',
  'diamond-open': '◇',
  cross: '+',
  x: '❌'
};

/***/ }),

/***/ 7822:
/***/ (function(module) {

"use strict";


module.exports = {
  /**
   * Timing information for interactive elements
   */
  SHOW_PLACEHOLDER: 100,
  HIDE_PLACEHOLDER: 1000,
  // opacity dimming fraction for points that are not in selection
  DESELECTDIM: 0.2
};

/***/ }),

/***/ 606:
/***/ (function(module) {

"use strict";


module.exports = {
  /**
   * Standardize all missing data in calcdata to use undefined
   * never null or NaN.
   * That way we can use !==undefined, or !== BADNUM,
   * to test for real data
   */
  BADNUM: undefined,
  /*
   * Limit certain operations to well below floating point max value
   * to avoid glitches: Make sure that even when you multiply it by the
   * number of pixels on a giant screen it still works
   */
  FP_SAFE: Number.MAX_VALUE * 1e-4,
  /*
   * conversion of date units to milliseconds
   * year and month constants are marked "AVG"
   * to remind us that not all years and months
   * have the same length
   */
  ONEMAXYEAR: 31622400000,
  // 366 * ONEDAY
  ONEAVGYEAR: 31557600000,
  // 365.25 days
  ONEMINYEAR: 31536000000,
  // 365 * ONEDAY
  ONEMAXQUARTER: 7948800000,
  // 92 * ONEDAY
  ONEAVGQUARTER: 7889400000,
  // 1/4 of ONEAVGYEAR
  ONEMINQUARTER: 7689600000,
  // 89 * ONEDAY
  ONEMAXMONTH: 2678400000,
  // 31 * ONEDAY
  ONEAVGMONTH: 2629800000,
  // 1/12 of ONEAVGYEAR
  ONEMINMONTH: 2419200000,
  // 28 * ONEDAY
  ONEWEEK: 604800000,
  // 7 * ONEDAY
  ONEDAY: 86400000,
  // 24 * ONEHOUR
  ONEHOUR: 3600000,
  ONEMIN: 60000,
  ONESEC: 1000,
  /*
   * For fast conversion btwn world calendars and epoch ms, the Julian Day Number
   * of the unix epoch. From calendars.instance().newDate(1970, 1, 1).toJD()
   */
  EPOCHJD: 2440587.5,
  /*
   * Are two values nearly equal? Compare to 1PPM
   */
  ALMOST_EQUAL: 1 - 1e-6,
  /*
   * If we're asked to clip a non-positive log value, how far off-screen
   * do we put it?
   */
  LOG_CLIP: 10,
  /*
   * not a number, but for displaying numbers: the "minus sign" symbol is
   * wider than the regular ascii dash "-"
   */
  MINUS_SIGN: '\u2212'
};

/***/ }),

/***/ 7922:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.xmlns = 'http://www.w3.org/2000/xmlns/';
exports.svg = 'http://www.w3.org/2000/svg';
exports.xlink = 'http://www.w3.org/1999/xlink';

// the 'old' d3 quirk got fix in v3.5.7
// https://github.com/mbostock/d3/commit/a6f66e9dd37f764403fc7c1f26be09ab4af24fed
exports.svgAttrs = {
  xmlns: exports.svg,
  'xmlns:xlink': exports.xlink
};

/***/ }),

/***/ 8729:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.version = __webpack_require__(1506).version;

// inject promise polyfill
__webpack_require__(7417);

// inject plot css
__webpack_require__(8847);

// include registry module and expose register method
var Registry = __webpack_require__(3972);
var register = exports.register = Registry.register;

// expose plot api methods
var plotApi = __webpack_require__(641);
var methodNames = Object.keys(plotApi);
for (var i = 0; i < methodNames.length; i++) {
  var name = methodNames[i];
  // _ -> private API methods, but still registered for internal use
  if (name.charAt(0) !== '_') exports[name] = plotApi[name];
  register({
    moduleType: 'apiMethod',
    name: name,
    fn: plotApi[name]
  });
}

// scatter is the only trace included by default
register(__webpack_require__(7368));

// register all registrable components modules
register([__webpack_require__(2745), __webpack_require__(2468), __webpack_require__(7322), __webpack_require__(9853), __webpack_require__(8804), __webpack_require__(763), __webpack_require__(3243), __webpack_require__(3137), __webpack_require__(7218), __webpack_require__(3312), __webpack_require__(7369), __webpack_require__(1081), __webpack_require__(2311), __webpack_require__(2199),
// legend needs to come after shape | legend defaults depends on shapes
__webpack_require__(211),
// fx needs to come after legend | unified hover defaults depends on legends
__webpack_require__(4168)]);

// locales en and en-US are required for default behavior
register([__webpack_require__(2177), __webpack_require__(7815)]);

// locales that are present in the window should be loaded
if (window.PlotlyLocales && Array.isArray(window.PlotlyLocales)) {
  register(window.PlotlyLocales);
  delete window.PlotlyLocales;
}

// plot icons
exports.Icons = __webpack_require__(4255);

// unofficial 'beta' plot methods, use at your own risk
var Fx = __webpack_require__(211);
var Plots = __webpack_require__(4875);
exports.Plots = {
  resize: Plots.resize,
  graphJson: Plots.graphJson,
  sendDataToCloud: Plots.sendDataToCloud
};
exports.Fx = {
  hover: Fx.hover,
  unhover: Fx.unhover,
  loneHover: Fx.loneHover,
  loneUnhover: Fx.loneUnhover
};
exports.Snapshot = __webpack_require__(4511);
exports.PlotSchema = __webpack_require__(6281);

/***/ }),

/***/ 4255:
/***/ (function(module) {

"use strict";


module.exports = {
  undo: {
    width: 857.1,
    height: 1000,
    path: 'm857 350q0-87-34-166t-91-137-137-92-166-34q-96 0-183 41t-147 114q-4 6-4 13t5 11l76 77q6 5 14 5 9-1 13-7 41-53 100-82t126-29q58 0 110 23t92 61 61 91 22 111-22 111-61 91-92 61-110 23q-55 0-105-20t-90-57l77-77q17-16 8-38-10-23-33-23h-250q-15 0-25 11t-11 25v250q0 24 22 33 22 10 39-8l72-72q60 57 137 88t159 31q87 0 166-34t137-92 91-137 34-166z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  home: {
    width: 928.6,
    height: 1000,
    path: 'm786 296v-267q0-15-11-26t-25-10h-214v214h-143v-214h-214q-15 0-25 10t-11 26v267q0 1 0 2t0 2l321 264 321-264q1-1 1-4z m124 39l-34-41q-5-5-12-6h-2q-7 0-12 3l-386 322-386-322q-7-4-13-4-7 2-12 7l-35 41q-4 5-3 13t6 12l401 334q18 15 42 15t43-15l136-114v109q0 8 5 13t13 5h107q8 0 13-5t5-13v-227l122-102q5-5 6-12t-4-13z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  'camera-retro': {
    width: 1000,
    height: 1000,
    path: 'm518 386q0 8-5 13t-13 5q-37 0-63-27t-26-63q0-8 5-13t13-5 12 5 5 13q0 23 16 38t38 16q8 0 13 5t5 13z m125-73q0-59-42-101t-101-42-101 42-42 101 42 101 101 42 101-42 42-101z m-572-320h858v71h-858v-71z m643 320q0 89-62 152t-152 62-151-62-63-152 63-151 151-63 152 63 62 151z m-571 358h214v72h-214v-72z m-72-107h858v143h-462l-36-71h-360v-72z m929 143v-714q0-30-21-51t-50-21h-858q-29 0-50 21t-21 51v714q0 30 21 51t50 21h858q29 0 50-21t21-51z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  zoombox: {
    width: 1000,
    height: 1000,
    path: 'm1000-25l-250 251c40 63 63 138 63 218 0 224-182 406-407 406-224 0-406-182-406-406s183-406 407-406c80 0 155 22 218 62l250-250 125 125z m-812 250l0 438 437 0 0-438-437 0z m62 375l313 0 0-312-313 0 0 312z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  pan: {
    width: 1000,
    height: 1000,
    path: 'm1000 350l-187 188 0-125-250 0 0 250 125 0-188 187-187-187 125 0 0-250-250 0 0 125-188-188 186-187 0 125 252 0 0-250-125 0 187-188 188 188-125 0 0 250 250 0 0-126 187 188z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  zoom_plus: {
    width: 875,
    height: 1000,
    path: 'm1 787l0-875 875 0 0 875-875 0z m687-500l-187 0 0-187-125 0 0 187-188 0 0 125 188 0 0 187 125 0 0-187 187 0 0-125z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  zoom_minus: {
    width: 875,
    height: 1000,
    path: 'm0 788l0-876 875 0 0 876-875 0z m688-500l-500 0 0 125 500 0 0-125z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  autoscale: {
    width: 1000,
    height: 1000,
    path: 'm250 850l-187 0-63 0 0-62 0-188 63 0 0 188 187 0 0 62z m688 0l-188 0 0-62 188 0 0-188 62 0 0 188 0 62-62 0z m-875-938l0 188-63 0 0-188 0-62 63 0 187 0 0 62-187 0z m875 188l0-188-188 0 0-62 188 0 62 0 0 62 0 188-62 0z m-125 188l-1 0-93-94-156 156 156 156 92-93 2 0 0 250-250 0 0-2 93-92-156-156-156 156 94 92 0 2-250 0 0-250 0 0 93 93 157-156-157-156-93 94 0 0 0-250 250 0 0 0-94 93 156 157 156-157-93-93 0 0 250 0 0 250z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  tooltip_basic: {
    width: 1500,
    height: 1000,
    path: 'm375 725l0 0-375-375 375-374 0-1 1125 0 0 750-1125 0z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  tooltip_compare: {
    width: 1125,
    height: 1000,
    path: 'm187 786l0 2-187-188 188-187 0 0 937 0 0 373-938 0z m0-499l0 1-187-188 188-188 0 0 937 0 0 376-938-1z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  plotlylogo: {
    width: 1542,
    height: 1000,
    path: 'm0-10h182v-140h-182v140z m228 146h183v-286h-183v286z m225 714h182v-1000h-182v1000z m225-285h182v-715h-182v715z m225 142h183v-857h-183v857z m231-428h182v-429h-182v429z m225-291h183v-138h-183v138z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  'z-axis': {
    width: 1000,
    height: 1000,
    path: 'm833 5l-17 108v41l-130-65 130-66c0 0 0 38 0 39 0-1 36-14 39-25 4-15-6-22-16-30-15-12-39-16-56-20-90-22-187-23-279-23-261 0-341 34-353 59 3 60 228 110 228 110-140-8-351-35-351-116 0-120 293-142 474-142 155 0 477 22 477 142 0 50-74 79-163 96z m-374 94c-58-5-99-21-99-40 0-24 65-43 144-43 79 0 143 19 143 43 0 19-42 34-98 40v216h87l-132 135-133-135h88v-216z m167 515h-136v1c16 16 31 34 46 52l84 109v54h-230v-71h124v-1c-16-17-28-32-44-51l-89-114v-51h245v72z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  '3d_rotate': {
    width: 1000,
    height: 1000,
    path: 'm922 660c-5 4-9 7-14 11-359 263-580-31-580-31l-102 28 58-400c0 1 1 1 2 2 118 108 351 249 351 249s-62 27-100 42c88 83 222 183 347 122 16-8 30-17 44-27-2 1-4 2-6 4z m36-329c0 0 64 229-88 296-62 27-124 14-175-11 157-78 225-208 249-266 8-19 11-31 11-31 2 5 6 15 11 32-5-13-8-20-8-20z m-775-239c70-31 117-50 198-32-121 80-199 346-199 346l-96-15-58-12c0 0 55-226 155-287z m603 133l-317-139c0 0 4-4 19-14 7-5 24-15 24-15s-177-147-389 4c235-287 536-112 536-112l31-22 100 299-4-1z m-298-153c6-4 14-9 24-15 0 0-17 10-24 15z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  camera: {
    width: 1000,
    height: 1000,
    path: 'm500 450c-83 0-150-67-150-150 0-83 67-150 150-150 83 0 150 67 150 150 0 83-67 150-150 150z m400 150h-120c-16 0-34 13-39 29l-31 93c-6 15-23 28-40 28h-340c-16 0-34-13-39-28l-31-94c-6-15-23-28-40-28h-120c-55 0-100-45-100-100v-450c0-55 45-100 100-100h800c55 0 100 45 100 100v450c0 55-45 100-100 100z m-400-550c-138 0-250 112-250 250 0 138 112 250 250 250 138 0 250-112 250-250 0-138-112-250-250-250z m365 380c-19 0-35 16-35 35 0 19 16 35 35 35 19 0 35-16 35-35 0-19-16-35-35-35z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  movie: {
    width: 1000,
    height: 1000,
    path: 'm938 413l-188-125c0 37-17 71-44 94 64 38 107 107 107 187 0 121-98 219-219 219-121 0-219-98-219-219 0-61 25-117 66-156h-115c30 33 49 76 49 125 0 103-84 187-187 187s-188-84-188-187c0-57 26-107 65-141-38-22-65-62-65-109v-250c0-70 56-126 125-126h500c69 0 125 56 125 126l188-126c34 0 62 28 62 63v375c0 35-28 63-62 63z m-750 0c-69 0-125 56-125 125s56 125 125 125 125-56 125-125-56-125-125-125z m406-1c-87 0-157 70-157 157 0 86 70 156 157 156s156-70 156-156-70-157-156-157z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  question: {
    width: 857.1,
    height: 1000,
    path: 'm500 82v107q0 8-5 13t-13 5h-107q-8 0-13-5t-5-13v-107q0-8 5-13t13-5h107q8 0 13 5t5 13z m143 375q0 49-31 91t-77 65-95 23q-136 0-207-119-9-14 4-24l74-55q4-4 10-4 9 0 14 7 30 38 48 51 19 14 48 14 27 0 48-15t21-33q0-21-11-34t-38-25q-35-16-65-48t-29-70v-20q0-8 5-13t13-5h107q8 0 13 5t5 13q0 10 12 27t30 28q18 10 28 16t25 19 25 27 16 34 7 45z m214-107q0-117-57-215t-156-156-215-58-216 58-155 156-58 215 58 215 155 156 216 58 215-58 156-156 57-215z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  disk: {
    width: 857.1,
    height: 1000,
    path: 'm214-7h429v214h-429v-214z m500 0h72v500q0 8-6 21t-11 20l-157 156q-5 6-19 12t-22 5v-232q0-22-15-38t-38-16h-322q-22 0-37 16t-16 38v232h-72v-714h72v232q0 22 16 38t37 16h465q22 0 38-16t15-38v-232z m-214 518v178q0 8-5 13t-13 5h-107q-7 0-13-5t-5-13v-178q0-8 5-13t13-5h107q7 0 13 5t5 13z m357-18v-518q0-22-15-38t-38-16h-750q-23 0-38 16t-16 38v750q0 22 16 38t38 16h517q23 0 50-12t42-26l156-157q16-15 27-42t11-49z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  drawopenpath: {
    width: 70,
    height: 70,
    path: 'M33.21,85.65a7.31,7.31,0,0,1-2.59-.48c-8.16-3.11-9.27-19.8-9.88-41.3-.1-3.58-.19-6.68-.35-9-.15-2.1-.67-3.48-1.43-3.79-2.13-.88-7.91,2.32-12,5.86L3,32.38c1.87-1.64,11.55-9.66,18.27-6.9,2.13.87,4.75,3.14,5.17,9,.17,2.43.26,5.59.36,9.25a224.17,224.17,0,0,0,1.5,23.4c1.54,10.76,4,12.22,4.48,12.4.84.32,2.79-.46,5.76-3.59L43,80.07C41.53,81.57,37.68,85.64,33.21,85.65ZM74.81,69a11.34,11.34,0,0,0,6.09-6.72L87.26,44.5,74.72,32,56.9,38.35c-2.37.86-5.57,3.42-6.61,6L38.65,72.14l8.42,8.43ZM55,46.27a7.91,7.91,0,0,1,3.64-3.17l14.8-5.3,8,8L76.11,60.6l-.06.19a6.37,6.37,0,0,1-3,3.43L48.25,74.59,44.62,71Zm16.57,7.82A6.9,6.9,0,1,0,64.64,61,6.91,6.91,0,0,0,71.54,54.09Zm-4.05,0a2.85,2.85,0,1,1-2.85-2.85A2.86,2.86,0,0,1,67.49,54.09Zm-4.13,5.22L60.5,56.45,44.26,72.7l2.86,2.86ZM97.83,35.67,84.14,22l-8.57,8.57L89.26,44.24Zm-13.69-8,8,8-2.85,2.85-8-8Z',
    transform: 'matrix(1 0 0 1 -15 -15)'
  },
  drawclosedpath: {
    width: 90,
    height: 90,
    path: 'M88.41,21.12a26.56,26.56,0,0,0-36.18,0l-2.07,2-2.07-2a26.57,26.57,0,0,0-36.18,0,23.74,23.74,0,0,0,0,34.8L48,90.12a3.22,3.22,0,0,0,4.42,0l36-34.21a23.73,23.73,0,0,0,0-34.79ZM84,51.24,50.16,83.35,16.35,51.25a17.28,17.28,0,0,1,0-25.47,20,20,0,0,1,27.3,0l4.29,4.07a3.23,3.23,0,0,0,4.44,0l4.29-4.07a20,20,0,0,1,27.3,0,17.27,17.27,0,0,1,0,25.46ZM66.76,47.68h-33v6.91h33ZM53.35,35H46.44V68h6.91Z',
    transform: 'matrix(1 0 0 1 -5 -5)'
  },
  lasso: {
    width: 1031,
    height: 1000,
    path: 'm1018 538c-36 207-290 336-568 286-277-48-473-256-436-463 10-57 36-108 76-151-13-66 11-137 68-183 34-28 75-41 114-42l-55-70 0 0c-2-1-3-2-4-3-10-14-8-34 5-45 14-11 34-8 45 4 1 1 2 3 2 5l0 0 113 140c16 11 31 24 45 40 4 3 6 7 8 11 48-3 100 0 151 9 278 48 473 255 436 462z m-624-379c-80 14-149 48-197 96 42 42 109 47 156 9 33-26 47-66 41-105z m-187-74c-19 16-33 37-39 60 50-32 109-55 174-68-42-25-95-24-135 8z m360 75c-34-7-69-9-102-8 8 62-16 128-68 170-73 59-175 54-244-5-9 20-16 40-20 61-28 159 121 317 333 354s407-60 434-217c28-159-121-318-333-355z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  selectbox: {
    width: 1000,
    height: 1000,
    path: 'm0 850l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m285 0l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m-857-286l0-143 143 0 0 143-143 0z m857 0l0-143 143 0 0 143-143 0z m-857-285l0-143 143 0 0 143-143 0z m857 0l0-143 143 0 0 143-143 0z m-857-286l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m285 0l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z',
    transform: 'matrix(1 0 0 -1 0 850)'
  },
  drawline: {
    width: 70,
    height: 70,
    path: 'M60.64,62.3a11.29,11.29,0,0,0,6.09-6.72l6.35-17.72L60.54,25.31l-17.82,6.4c-2.36.86-5.57,3.41-6.6,6L24.48,65.5l8.42,8.42ZM40.79,39.63a7.89,7.89,0,0,1,3.65-3.17l14.79-5.31,8,8L61.94,54l-.06.19a6.44,6.44,0,0,1-3,3.43L34.07,68l-3.62-3.63Zm16.57,7.81a6.9,6.9,0,1,0-6.89,6.9A6.9,6.9,0,0,0,57.36,47.44Zm-4,0a2.86,2.86,0,1,1-2.85-2.85A2.86,2.86,0,0,1,53.32,47.44Zm-4.13,5.22L46.33,49.8,30.08,66.05l2.86,2.86ZM83.65,29,70,15.34,61.4,23.9,75.09,37.59ZM70,21.06l8,8-2.84,2.85-8-8ZM87,80.49H10.67V87H87Z',
    transform: 'matrix(1 0 0 1 -15 -15)'
  },
  drawrect: {
    width: 80,
    height: 80,
    path: 'M78,22V79H21V22H78m9-9H12V88H87V13ZM68,46.22H31V54H68ZM53,32H45.22V69H53Z',
    transform: 'matrix(1 0 0 1 -10 -10)'
  },
  drawcircle: {
    width: 80,
    height: 80,
    path: 'M50,84.72C26.84,84.72,8,69.28,8,50.3S26.84,15.87,50,15.87,92,31.31,92,50.3,73.16,84.72,50,84.72Zm0-60.59c-18.6,0-33.74,11.74-33.74,26.17S31.4,76.46,50,76.46,83.74,64.72,83.74,50.3,68.6,24.13,50,24.13Zm17.15,22h-34v7.11h34Zm-13.8-13H46.24v34h7.11Z',
    transform: 'matrix(1 0 0 1 -10 -10)'
  },
  eraseshape: {
    width: 80,
    height: 80,
    path: 'M82.77,78H31.85L6,49.57,31.85,21.14H82.77a8.72,8.72,0,0,1,8.65,8.77V69.24A8.72,8.72,0,0,1,82.77,78ZM35.46,69.84H82.77a.57.57,0,0,0,.49-.6V29.91a.57.57,0,0,0-.49-.61H35.46L17,49.57Zm32.68-34.7-24,24,5,5,24-24Zm-19,.53-5,5,24,24,5-5Z',
    transform: 'matrix(1 0 0 1 -10 -10)'
  },
  spikeline: {
    width: 1000,
    height: 1000,
    path: 'M512 409c0-57-46-104-103-104-57 0-104 47-104 104 0 57 47 103 104 103 57 0 103-46 103-103z m-327-39l92 0 0 92-92 0z m-185 0l92 0 0 92-92 0z m370-186l92 0 0 93-92 0z m0-184l92 0 0 92-92 0z',
    transform: 'matrix(1.5 0 0 -1.5 0 850)'
  },
  pencil: {
    width: 1792,
    height: 1792,
    path: 'M491 1536l91-91-235-235-91 91v107h128v128h107zm523-928q0-22-22-22-10 0-17 7l-542 542q-7 7-7 17 0 22 22 22 10 0 17-7l542-542q7-7 7-17zm-54-192l416 416-832 832h-416v-416zm683 96q0 53-37 90l-166 166-416-416 166-165q36-38 90-38 53 0 91 38l235 234q37 39 37 91z',
    transform: 'matrix(1 0 0 1 0 1)'
  },
  newplotlylogo: {
    name: 'newplotlylogo',
    svg: ['<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 132 132\'>', '<defs>', ' <style>', '  .cls-0{fill:#000;}', '  .cls-1{fill:#FFF;}', '  .cls-2{fill:#F26;}', '  .cls-3{fill:#D69;}', '  .cls-4{fill:#BAC;}', '  .cls-5{fill:#9EF;}', ' </style>', '</defs>', ' <title>plotly-logomark</title>', ' <g id=\'symbol\'>', '  <rect class=\'cls-0\' x=\'0\' y=\'0\' width=\'132\' height=\'132\' rx=\'18\' ry=\'18\'/>', '  <circle class=\'cls-5\' cx=\'102\' cy=\'30\' r=\'6\'/>', '  <circle class=\'cls-4\' cx=\'78\' cy=\'30\' r=\'6\'/>', '  <circle class=\'cls-4\' cx=\'78\' cy=\'54\' r=\'6\'/>', '  <circle class=\'cls-3\' cx=\'54\' cy=\'30\' r=\'6\'/>', '  <circle class=\'cls-2\' cx=\'30\' cy=\'30\' r=\'6\'/>', '  <circle class=\'cls-2\' cx=\'30\' cy=\'54\' r=\'6\'/>', '  <path class=\'cls-1\' d=\'M30,72a6,6,0,0,0-6,6v24a6,6,0,0,0,12,0V78A6,6,0,0,0,30,72Z\'/>', '  <path class=\'cls-1\' d=\'M78,72a6,6,0,0,0-6,6v24a6,6,0,0,0,12,0V78A6,6,0,0,0,78,72Z\'/>', '  <path class=\'cls-1\' d=\'M54,48a6,6,0,0,0-6,6v48a6,6,0,0,0,12,0V54A6,6,0,0,0,54,48Z\'/>', '  <path class=\'cls-1\' d=\'M102,48a6,6,0,0,0-6,6v48a6,6,0,0,0,12,0V54A6,6,0,0,0,102,48Z\'/>', ' </g>', '</svg>'].join('')
  }
};

/***/ }),

/***/ 9863:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


/**
 * Determine the position anchor property of x/y xanchor/yanchor components.
 *
 * - values < 1/3 align the low side at that fraction,
 * - values [1/3, 2/3] align the center at that fraction,
 * - values > 2/3 align the right at that fraction.
 */
exports.isLeftAnchor = function isLeftAnchor(opts) {
  return opts.xanchor === 'left' || opts.xanchor === 'auto' && opts.x <= 1 / 3;
};
exports.isCenterAnchor = function isCenterAnchor(opts) {
  return opts.xanchor === 'center' || opts.xanchor === 'auto' && opts.x > 1 / 3 && opts.x < 2 / 3;
};
exports.isRightAnchor = function isRightAnchor(opts) {
  return opts.xanchor === 'right' || opts.xanchor === 'auto' && opts.x >= 2 / 3;
};
exports.isTopAnchor = function isTopAnchor(opts) {
  return opts.yanchor === 'top' || opts.yanchor === 'auto' && opts.y >= 2 / 3;
};
exports.isMiddleAnchor = function isMiddleAnchor(opts) {
  return opts.yanchor === 'middle' || opts.yanchor === 'auto' && opts.y > 1 / 3 && opts.y < 2 / 3;
};
exports.isBottomAnchor = function isBottomAnchor(opts) {
  return opts.yanchor === 'bottom' || opts.yanchor === 'auto' && opts.y <= 1 / 3;
};

/***/ }),

/***/ 6348:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var modModule = __webpack_require__(4872);
var mod = modModule.mod;
var modHalf = modModule.modHalf;
var PI = Math.PI;
var twoPI = 2 * PI;
function deg2rad(deg) {
  return deg / 180 * PI;
}
function rad2deg(rad) {
  return rad / PI * 180;
}

/**
 * is sector a full circle?
 * ... this comes up a lot in SVG path-drawing routines
 *
 * N.B. we consider all sectors that span more that 2pi 'full' circles
 *
 * @param {2-item array} aBnds : angular bounds in *radians*
 * @return {boolean}
 */
function isFullCircle(aBnds) {
  return Math.abs(aBnds[1] - aBnds[0]) > twoPI - 1e-14;
}

/**
 * angular delta between angle 'a' and 'b'
 * solution taken from: https://stackoverflow.com/a/2007279
 *
 * @param {number} a : first angle in *radians*
 * @param {number} b : second angle in *radians*
 * @return {number} angular delta in *radians*
 */
function angleDelta(a, b) {
  return modHalf(b - a, twoPI);
}

/**
 * angular distance between angle 'a' and 'b'
 *
 * @param {number} a : first angle in *radians*
 * @param {number} b : second angle in *radians*
 * @return {number} angular distance in *radians*
 */
function angleDist(a, b) {
  return Math.abs(angleDelta(a, b));
}

/**
 * is angle inside sector?
 *
 * @param {number} a : angle to test in *radians*
 * @param {2-item array} aBnds : sector's angular bounds in *radians*
 * @param {boolean}
 */
function isAngleInsideSector(a, aBnds) {
  if (isFullCircle(aBnds)) return true;
  var s0, s1;
  if (aBnds[0] < aBnds[1]) {
    s0 = aBnds[0];
    s1 = aBnds[1];
  } else {
    s0 = aBnds[1];
    s1 = aBnds[0];
  }
  s0 = mod(s0, twoPI);
  s1 = mod(s1, twoPI);
  if (s0 > s1) s1 += twoPI;
  var a0 = mod(a, twoPI);
  var a1 = a0 + twoPI;
  return a0 >= s0 && a0 <= s1 || a1 >= s0 && a1 <= s1;
}

/**
 * is pt (r,a) inside sector?
 *
 * @param {number} r : pt's radial coordinate
 * @param {number} a : pt's angular coordinate in *radians*
 * @param {2-item array} rBnds : sector's radial bounds
 * @param {2-item array} aBnds : sector's angular bounds in *radians*
 * @return {boolean}
 */
function isPtInsideSector(r, a, rBnds, aBnds) {
  if (!isAngleInsideSector(a, aBnds)) return false;
  var r0, r1;
  if (rBnds[0] < rBnds[1]) {
    r0 = rBnds[0];
    r1 = rBnds[1];
  } else {
    r0 = rBnds[1];
    r1 = rBnds[0];
  }
  return r >= r0 && r <= r1;
}

// common to pathArc, pathSector and pathAnnulus
function _path(r0, r1, a0, a1, cx, cy, isClosed) {
  cx = cx || 0;
  cy = cy || 0;
  var isCircle = isFullCircle([a0, a1]);
  var aStart, aMid, aEnd;
  var rStart, rEnd;
  if (isCircle) {
    aStart = 0;
    aMid = PI;
    aEnd = twoPI;
  } else {
    if (a0 < a1) {
      aStart = a0;
      aEnd = a1;
    } else {
      aStart = a1;
      aEnd = a0;
    }
  }
  if (r0 < r1) {
    rStart = r0;
    rEnd = r1;
  } else {
    rStart = r1;
    rEnd = r0;
  }

  // N.B. svg coordinates here, where y increases downward
  function pt(r, a) {
    return [r * Math.cos(a) + cx, cy - r * Math.sin(a)];
  }
  var largeArc = Math.abs(aEnd - aStart) <= PI ? 0 : 1;
  function arc(r, a, cw) {
    return 'A' + [r, r] + ' ' + [0, largeArc, cw] + ' ' + pt(r, a);
  }
  var p;
  if (isCircle) {
    if (rStart === null) {
      p = 'M' + pt(rEnd, aStart) + arc(rEnd, aMid, 0) + arc(rEnd, aEnd, 0) + 'Z';
    } else {
      p = 'M' + pt(rStart, aStart) + arc(rStart, aMid, 0) + arc(rStart, aEnd, 0) + 'Z' + 'M' + pt(rEnd, aStart) + arc(rEnd, aMid, 1) + arc(rEnd, aEnd, 1) + 'Z';
    }
  } else {
    if (rStart === null) {
      p = 'M' + pt(rEnd, aStart) + arc(rEnd, aEnd, 0);
      if (isClosed) p += 'L0,0Z';
    } else {
      p = 'M' + pt(rStart, aStart) + 'L' + pt(rEnd, aStart) + arc(rEnd, aEnd, 0) + 'L' + pt(rStart, aEnd) + arc(rStart, aStart, 1) + 'Z';
    }
  }
  return p;
}

/**
 * path an arc
 *
 * @param {number} r : radius
 * @param {number} a0 : first angular coordinate in *radians*
 * @param {number} a1 : second angular coordinate in *radians*
 * @param {number (optional)} cx : x coordinate of center
 * @param {number (optional)} cy : y coordinate of center
 * @return {string} svg path
 */
function pathArc(r, a0, a1, cx, cy) {
  return _path(null, r, a0, a1, cx, cy, 0);
}

/**
 * path a sector
 *
 * @param {number} r : radius
 * @param {number} a0 : first angular coordinate in *radians*
 * @param {number} a1 : second angular coordinate in *radians*
 * @param {number (optional)} cx : x coordinate of center
 * @param {number (optional)} cy : y coordinate of center
 * @return {string} svg path
 */
function pathSector(r, a0, a1, cx, cy) {
  return _path(null, r, a0, a1, cx, cy, 1);
}

/**
 * path an annulus
 *
 * @param {number} r0 : first radial coordinate
 * @param {number} r1 : second radial coordinate
 * @param {number} a0 : first angular coordinate in *radians*
 * @param {number} a1 : second angular coordinate in *radians*
 * @param {number (optional)} cx : x coordinate of center
 * @param {number (optional)} cy : y coordinate of center
 * @return {string} svg path
 */
function pathAnnulus(r0, r1, a0, a1, cx, cy) {
  return _path(r0, r1, a0, a1, cx, cy, 1);
}
module.exports = {
  deg2rad: deg2rad,
  rad2deg: rad2deg,
  angleDelta: angleDelta,
  angleDist: angleDist,
  isFullCircle: isFullCircle,
  isAngleInsideSector: isAngleInsideSector,
  isPtInsideSector: isPtInsideSector,
  pathArc: pathArc,
  pathSector: pathSector,
  pathAnnulus: pathAnnulus
};

/***/ }),

/***/ 3627:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


var isArray = Array.isArray;
var ab = ArrayBuffer;
var dv = DataView;
function isTypedArray(a) {
  return ab.isView(a) && !(a instanceof dv);
}
exports.isTypedArray = isTypedArray;
function isArrayOrTypedArray(a) {
  return isArray(a) || isTypedArray(a);
}
exports.isArrayOrTypedArray = isArrayOrTypedArray;

/*
 * Test whether an input object is 1D.
 *
 * Assumes we already know the object is an array.
 *
 * Looks only at the first element, if the dimensionality is
 * not consistent we won't figure that out here.
 */
function isArray1D(a) {
  return !isArrayOrTypedArray(a[0]);
}
exports.isArray1D = isArray1D;

/*
 * Ensures an array has the right amount of storage space. If it doesn't
 * exist, it creates an array. If it does exist, it returns it if too
 * short or truncates it in-place.
 *
 * The goal is to just reuse memory to avoid a bit of excessive garbage
 * collection.
 */
exports.ensureArray = function (out, n) {
  // TODO: typed array support here? This is only used in
  // traces/carpet/compute_control_points
  if (!isArray(out)) out = [];

  // If too long, truncate. (If too short, it will grow
  // automatically so we don't care about that case)
  out.length = n;
  return out;
};

/*
 * TypedArray-compatible concatenation of n arrays
 * if all arrays are the same type it will preserve that type,
 * otherwise it falls back on Array.
 * Also tries to avoid copying, in case one array has zero length
 * But never mutates an existing array
 */
exports.concat = function () {
  var args = [];
  var allArray = true;
  var totalLen = 0;
  var _constructor, arg0, i, argi, posi, leni, out, j;
  for (i = 0; i < arguments.length; i++) {
    argi = arguments[i];
    leni = argi.length;
    if (leni) {
      if (arg0) args.push(argi);else {
        arg0 = argi;
        posi = leni;
      }
      if (isArray(argi)) {
        _constructor = false;
      } else {
        allArray = false;
        if (!totalLen) {
          _constructor = argi.constructor;
        } else if (_constructor !== argi.constructor) {
          // TODO: in principle we could upgrade here,
          // ie keep typed array but convert all to Float64Array?
          _constructor = false;
        }
      }
      totalLen += leni;
    }
  }
  if (!totalLen) return [];
  if (!args.length) return arg0;
  if (allArray) return arg0.concat.apply(arg0, args);
  if (_constructor) {
    // matching typed arrays
    out = new _constructor(totalLen);
    out.set(arg0);
    for (i = 0; i < args.length; i++) {
      argi = args[i];
      out.set(argi, posi);
      posi += argi.length;
    }
    return out;
  }

  // mismatched types or Array + typed
  out = new Array(totalLen);
  for (j = 0; j < arg0.length; j++) out[j] = arg0[j];
  for (i = 0; i < args.length; i++) {
    argi = args[i];
    for (j = 0; j < argi.length; j++) out[posi + j] = argi[j];
    posi += j;
  }
  return out;
};
exports.maxRowLength = function (z) {
  return _rowLength(z, Math.max, 0);
};
exports.minRowLength = function (z) {
  return _rowLength(z, Math.min, Infinity);
};
function _rowLength(z, fn, len0) {
  if (isArrayOrTypedArray(z)) {
    if (isArrayOrTypedArray(z[0])) {
      var len = len0;
      for (var i = 0; i < z.length; i++) {
        len = fn(len, z[i].length);
      }
      return len;
    } else {
      return z.length;
    }
  }
  return 0;
}

/***/ }),

/***/ 5218:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var BADNUM = (__webpack_require__(606).BADNUM);

// precompile for speed
var JUNK = /^['"%,$#\s']+|[, ]|['"%,$#\s']+$/g;

/**
 * cleanNumber: remove common leading and trailing cruft
 * Always returns either a number or BADNUM.
 */
module.exports = function cleanNumber(v) {
  if (typeof v === 'string') {
    v = v.replace(JUNK, '');
  }
  if (isNumeric(v)) return Number(v);
  return BADNUM;
};

/***/ }),

/***/ 3306:
/***/ (function(module) {

"use strict";


/**
 * Clear gl frame (if any). This is a common pattern as
 * we usually set `preserveDrawingBuffer: true` during
 * gl context creation (e.g. via `reglUtils.prepare`).
 *
 * @param {DOM node or object} gd : graph div object
 */
module.exports = function clearGlCanvases(gd) {
  var fullLayout = gd._fullLayout;
  if (fullLayout._glcanvas && fullLayout._glcanvas.size()) {
    fullLayout._glcanvas.each(function (d) {
      if (d.regl) d.regl.clear({
        color: true,
        depth: true
      });
    });
  }
};

/***/ }),

/***/ 6367:
/***/ (function(module) {

"use strict";


/**
 * Clear responsive handlers (if any).
 *
 * @param {DOM node or object} gd : graph div object
 */
module.exports = function clearResponsive(gd) {
  if (gd._responsiveChartHandler) {
    window.removeEventListener('resize', gd._responsiveChartHandler);
    delete gd._responsiveChartHandler;
  }
};

/***/ }),

/***/ 6554:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var tinycolor = __webpack_require__(4267);
var baseTraceAttrs = __webpack_require__(9012);
var colorscales = __webpack_require__(3282);
var Color = __webpack_require__(7901);
var DESELECTDIM = (__webpack_require__(7822).DESELECTDIM);
var nestedProperty = __webpack_require__(5487);
var counterRegex = (__webpack_require__(587).counter);
var modHalf = (__webpack_require__(4872).modHalf);
var isArrayOrTypedArray = (__webpack_require__(3627).isArrayOrTypedArray);
exports.valObjectMeta = {
  data_array: {
    // You can use *dflt=[] to force said array to exist though.
    coerceFunction: function (v, propOut, dflt) {
      // TODO maybe `v: {type: 'float32', vals: [/* ... */]}` also
      if (isArrayOrTypedArray(v)) propOut.set(v);else if (dflt !== undefined) propOut.set(dflt);
    }
  },
  enumerated: {
    coerceFunction: function (v, propOut, dflt, opts) {
      if (opts.coerceNumber) v = +v;
      if (opts.values.indexOf(v) === -1) propOut.set(dflt);else propOut.set(v);
    },
    validateFunction: function (v, opts) {
      if (opts.coerceNumber) v = +v;
      var values = opts.values;
      for (var i = 0; i < values.length; i++) {
        var k = String(values[i]);
        if (k.charAt(0) === '/' && k.charAt(k.length - 1) === '/') {
          var regex = new RegExp(k.substr(1, k.length - 2));
          if (regex.test(v)) return true;
        } else if (v === values[i]) return true;
      }
      return false;
    }
  },
  boolean: {
    coerceFunction: function (v, propOut, dflt) {
      if (v === true || v === false) propOut.set(v);else propOut.set(dflt);
    }
  },
  number: {
    coerceFunction: function (v, propOut, dflt, opts) {
      if (!isNumeric(v) || opts.min !== undefined && v < opts.min || opts.max !== undefined && v > opts.max) {
        propOut.set(dflt);
      } else propOut.set(+v);
    }
  },
  integer: {
    coerceFunction: function (v, propOut, dflt, opts) {
      if (v % 1 || !isNumeric(v) || opts.min !== undefined && v < opts.min || opts.max !== undefined && v > opts.max) {
        propOut.set(dflt);
      } else propOut.set(+v);
    }
  },
  string: {
    // TODO 'values shouldn't be in there (edge case: 'dash' in Scatter)
    coerceFunction: function (v, propOut, dflt, opts) {
      if (typeof v !== 'string') {
        var okToCoerce = typeof v === 'number';
        if (opts.strict === true || !okToCoerce) propOut.set(dflt);else propOut.set(String(v));
      } else if (opts.noBlank && !v) propOut.set(dflt);else propOut.set(v);
    }
  },
  color: {
    coerceFunction: function (v, propOut, dflt) {
      if (tinycolor(v).isValid()) propOut.set(v);else propOut.set(dflt);
    }
  },
  colorlist: {
    coerceFunction: function (v, propOut, dflt) {
      function isColor(color) {
        return tinycolor(color).isValid();
      }
      if (!Array.isArray(v) || !v.length) propOut.set(dflt);else if (v.every(isColor)) propOut.set(v);else propOut.set(dflt);
    }
  },
  colorscale: {
    coerceFunction: function (v, propOut, dflt) {
      propOut.set(colorscales.get(v, dflt));
    }
  },
  angle: {
    coerceFunction: function (v, propOut, dflt) {
      if (v === 'auto') propOut.set('auto');else if (!isNumeric(v)) propOut.set(dflt);else propOut.set(modHalf(+v, 360));
    }
  },
  subplotid: {
    coerceFunction: function (v, propOut, dflt, opts) {
      var regex = opts.regex || counterRegex(dflt);
      if (typeof v === 'string' && regex.test(v)) {
        propOut.set(v);
        return;
      }
      propOut.set(dflt);
    },
    validateFunction: function (v, opts) {
      var dflt = opts.dflt;
      if (v === dflt) return true;
      if (typeof v !== 'string') return false;
      if (counterRegex(dflt).test(v)) return true;
      return false;
    }
  },
  flaglist: {
    coerceFunction: function (v, propOut, dflt, opts) {
      if ((opts.extras || []).indexOf(v) !== -1) {
        propOut.set(v);
        return;
      }
      if (typeof v !== 'string') {
        propOut.set(dflt);
        return;
      }
      var vParts = v.split('+');
      var i = 0;
      while (i < vParts.length) {
        var vi = vParts[i];
        if (opts.flags.indexOf(vi) === -1 || vParts.indexOf(vi) < i) {
          vParts.splice(i, 1);
        } else i++;
      }
      if (!vParts.length) propOut.set(dflt);else propOut.set(vParts.join('+'));
    }
  },
  any: {
    coerceFunction: function (v, propOut, dflt) {
      if (v === undefined) propOut.set(dflt);else propOut.set(v);
    }
  },
  info_array: {
    // set `dimensions=2` for a 2D array or '1-2' for either
    // `items` may be a single object instead of an array, in which case
    // `freeLength` must be true.
    // if `dimensions='1-2'` and items is a 1D array, then the value can
    // either be a matching 1D array or an array of such matching 1D arrays
    coerceFunction: function (v, propOut, dflt, opts) {
      // simplified coerce function just for array items
      function coercePart(v, opts, dflt) {
        var out;
        var propPart = {
          set: function (v) {
            out = v;
          }
        };
        if (dflt === undefined) dflt = opts.dflt;
        exports.valObjectMeta[opts.valType].coerceFunction(v, propPart, dflt, opts);
        return out;
      }
      var twoD = opts.dimensions === 2 || opts.dimensions === '1-2' && Array.isArray(v) && Array.isArray(v[0]);
      if (!Array.isArray(v)) {
        propOut.set(dflt);
        return;
      }
      var items = opts.items;
      var vOut = [];
      var arrayItems = Array.isArray(items);
      var arrayItems2D = arrayItems && twoD && Array.isArray(items[0]);
      var innerItemsOnly = twoD && arrayItems && !arrayItems2D;
      var len = arrayItems && !innerItemsOnly ? items.length : v.length;
      var i, j, row, item, len2, vNew;
      dflt = Array.isArray(dflt) ? dflt : [];
      if (twoD) {
        for (i = 0; i < len; i++) {
          vOut[i] = [];
          row = Array.isArray(v[i]) ? v[i] : [];
          if (innerItemsOnly) len2 = items.length;else if (arrayItems) len2 = items[i].length;else len2 = row.length;
          for (j = 0; j < len2; j++) {
            if (innerItemsOnly) item = items[j];else if (arrayItems) item = items[i][j];else item = items;
            vNew = coercePart(row[j], item, (dflt[i] || [])[j]);
            if (vNew !== undefined) vOut[i][j] = vNew;
          }
        }
      } else {
        for (i = 0; i < len; i++) {
          vNew = coercePart(v[i], arrayItems ? items[i] : items, dflt[i]);
          if (vNew !== undefined) vOut[i] = vNew;
        }
      }
      propOut.set(vOut);
    },
    validateFunction: function (v, opts) {
      if (!Array.isArray(v)) return false;
      var items = opts.items;
      var arrayItems = Array.isArray(items);
      var twoD = opts.dimensions === 2;

      // when free length is off, input and declared lengths must match
      if (!opts.freeLength && v.length !== items.length) return false;

      // valid when all input items are valid
      for (var i = 0; i < v.length; i++) {
        if (twoD) {
          if (!Array.isArray(v[i]) || !opts.freeLength && v[i].length !== items[i].length) {
            return false;
          }
          for (var j = 0; j < v[i].length; j++) {
            if (!validate(v[i][j], arrayItems ? items[i][j] : items)) {
              return false;
            }
          }
        } else if (!validate(v[i], arrayItems ? items[i] : items)) return false;
      }
      return true;
    }
  }
};

/**
 * Ensures that container[attribute] has a valid value.
 *
 * attributes[attribute] is an object with possible keys:
 * - valType: data_array, enumerated, boolean, ... as in valObjectMeta
 * - values: (enumerated only) array of allowed vals
 * - min, max: (number, integer only) inclusive bounds on allowed vals
 *      either or both may be omitted
 * - dflt: if attribute is invalid or missing, use this default
 *      if dflt is provided as an argument to lib.coerce it takes precedence
 *      as a convenience, returns the value it finally set
 */
exports.coerce = function (containerIn, containerOut, attributes, attribute, dflt) {
  var opts = nestedProperty(attributes, attribute).get();
  var propIn = nestedProperty(containerIn, attribute);
  var propOut = nestedProperty(containerOut, attribute);
  var v = propIn.get();
  var template = containerOut._template;
  if (v === undefined && template) {
    v = nestedProperty(template, attribute).get();
    // already used the template value, so short-circuit the second check
    template = 0;
  }
  if (dflt === undefined) dflt = opts.dflt;

  /**
   * arrayOk: value MAY be an array, then we do no value checking
   * at this point, because it can be more complicated than the
   * individual form (eg. some array vals can be numbers, even if the
   * single values must be color strings)
   */
  if (opts.arrayOk && isArrayOrTypedArray(v)) {
    propOut.set(v);
    return v;
  }
  var coerceFunction = exports.valObjectMeta[opts.valType].coerceFunction;
  coerceFunction(v, propOut, dflt, opts);
  var out = propOut.get();
  // in case v was provided but invalid, try the template again so it still
  // overrides the regular default
  if (template && out === dflt && !validate(v, opts)) {
    v = nestedProperty(template, attribute).get();
    coerceFunction(v, propOut, dflt, opts);
    out = propOut.get();
  }
  return out;
};

/**
 * Variation on coerce
 *
 * Uses coerce to get attribute value if user input is valid,
 * returns attribute default if user input it not valid or
 * returns false if there is no user input.
 */
exports.coerce2 = function (containerIn, containerOut, attributes, attribute, dflt) {
  var propIn = nestedProperty(containerIn, attribute);
  var propOut = exports.coerce(containerIn, containerOut, attributes, attribute, dflt);
  var valIn = propIn.get();
  return valIn !== undefined && valIn !== null ? propOut : false;
};

/*
 * Shortcut to coerce the three font attributes
 *
 * 'coerce' is a lib.coerce wrapper with implied first three arguments
 */
exports.coerceFont = function (coerce, attr, dfltObj) {
  var out = {};
  dfltObj = dfltObj || {};
  out.family = coerce(attr + '.family', dfltObj.family);
  out.size = coerce(attr + '.size', dfltObj.size);
  out.color = coerce(attr + '.color', dfltObj.color);
  return out;
};

/*
 * Shortcut to coerce the pattern attributes
 */
exports.coercePattern = function (coerce, attr, markerColor, hasMarkerColorscale) {
  var shape = coerce(attr + '.shape');
  if (shape) {
    coerce(attr + '.solidity');
    coerce(attr + '.size');
    var fillmode = coerce(attr + '.fillmode');
    var isOverlay = fillmode === 'overlay';
    if (!hasMarkerColorscale) {
      var bgcolor = coerce(attr + '.bgcolor', isOverlay ? markerColor : undefined);
      coerce(attr + '.fgcolor', isOverlay ? Color.contrast(bgcolor) : markerColor);
    }
    coerce(attr + '.fgopacity', isOverlay ? 0.5 : 1);
  }
};

/** Coerce shortcut for 'hoverinfo'
 * handling 1-vs-multi-trace dflt logic
 *
 * @param {object} traceIn : user trace object
 * @param {object} traceOut : full trace object (requires _module ref)
 * @param {object} layoutOut : full layout object (require _dataLength ref)
 * @return {any} : the coerced value
 */
exports.coerceHoverinfo = function (traceIn, traceOut, layoutOut) {
  var moduleAttrs = traceOut._module.attributes;
  var attrs = moduleAttrs.hoverinfo ? moduleAttrs : baseTraceAttrs;
  var valObj = attrs.hoverinfo;
  var dflt;
  if (layoutOut._dataLength === 1) {
    var flags = valObj.dflt === 'all' ? valObj.flags.slice() : valObj.dflt.split('+');
    flags.splice(flags.indexOf('name'), 1);
    dflt = flags.join('+');
  }
  return exports.coerce(traceIn, traceOut, attrs, 'hoverinfo', dflt);
};

/** Coerce shortcut for [un]selected.marker.opacity,
 *  which has special default logic, to ensure that it corresponds to the
 *  default selection behavior while allowing to be overtaken by any other
 *  [un]selected attribute.
 *
 *  N.B. This must be called *after* coercing all the other [un]selected attrs,
 *  to give the intended result.
 *
 * @param {object} traceOut : fullData item
 * @param {function} coerce : lib.coerce wrapper with implied first three arguments
 */
exports.coerceSelectionMarkerOpacity = function (traceOut, coerce) {
  if (!traceOut.marker) return;
  var mo = traceOut.marker.opacity;
  // you can still have a `marker` container with no markers if there's text
  if (mo === undefined) return;
  var smoDflt;
  var usmoDflt;

  // Don't give [un]selected.marker.opacity a default value if
  // marker.opacity is an array: handle this during style step.
  //
  // Only give [un]selected.marker.opacity a default value if you don't
  // set any other [un]selected attributes.
  if (!isArrayOrTypedArray(mo) && !traceOut.selected && !traceOut.unselected) {
    smoDflt = mo;
    usmoDflt = DESELECTDIM * mo;
  }
  coerce('selected.marker.opacity', smoDflt);
  coerce('unselected.marker.opacity', usmoDflt);
};
function validate(value, opts) {
  var valObjectDef = exports.valObjectMeta[opts.valType];
  if (opts.arrayOk && isArrayOrTypedArray(value)) return true;
  if (valObjectDef.validateFunction) {
    return valObjectDef.validateFunction(value, opts);
  }
  var failed = {};
  var out = failed;
  var propMock = {
    set: function (v) {
      out = v;
    }
  };

  // 'failed' just something mutable that won't be === anything else

  valObjectDef.coerceFunction(value, propMock, failed, opts);
  return out !== failed;
}
exports.validate = validate;

/***/ }),

/***/ 1631:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var timeFormat = (__webpack_require__(4096)/* .timeFormat */ .i$);
var isNumeric = __webpack_require__(2770);
var Loggers = __webpack_require__(7769);
var mod = (__webpack_require__(4872).mod);
var constants = __webpack_require__(606);
var BADNUM = constants.BADNUM;
var ONEDAY = constants.ONEDAY;
var ONEHOUR = constants.ONEHOUR;
var ONEMIN = constants.ONEMIN;
var ONESEC = constants.ONESEC;
var EPOCHJD = constants.EPOCHJD;
var Registry = __webpack_require__(3972);
var utcFormat = (__webpack_require__(4096)/* .utcFormat */ .g0);
var DATETIME_REGEXP = /^\s*(-?\d\d\d\d|\d\d)(-(\d?\d)(-(\d?\d)([ Tt]([01]?\d|2[0-3])(:([0-5]\d)(:([0-5]\d(\.\d+)?))?(Z|z|[+\-]\d\d(:?\d\d)?)?)?)?)?)?\s*$/m;
// special regex for chinese calendars to support yyyy-mmi-dd etc for intercalary months
var DATETIME_REGEXP_CN = /^\s*(-?\d\d\d\d|\d\d)(-(\d?\di?)(-(\d?\d)([ Tt]([01]?\d|2[0-3])(:([0-5]\d)(:([0-5]\d(\.\d+)?))?(Z|z|[+\-]\d\d(:?\d\d)?)?)?)?)?)?\s*$/m;

// for 2-digit years, the first year we map them onto
var YFIRST = new Date().getFullYear() - 70;
function isWorldCalendar(calendar) {
  return calendar && Registry.componentsRegistry.calendars && typeof calendar === 'string' && calendar !== 'gregorian';
}

/*
 * dateTick0: get the canonical tick for this calendar
 *
 * integer weekdays : Saturday: 0, Sunday: 1, Monday: 2, etc.
 */
exports.dateTick0 = function (calendar, dayOfWeek) {
  var tick0 = _dateTick0(calendar, !!dayOfWeek);
  if (dayOfWeek < 2) return tick0;
  var v = exports.dateTime2ms(tick0, calendar);
  v += ONEDAY * (dayOfWeek - 1); // shift Sunday to Monday, etc.
  return exports.ms2DateTime(v, 0, calendar);
};

/*
 * _dateTick0: get the canonical tick for this calendar
 *
 * bool sunday is for week ticks, shift it to a Sunday.
 */
function _dateTick0(calendar, sunday) {
  if (isWorldCalendar(calendar)) {
    return sunday ? Registry.getComponentMethod('calendars', 'CANONICAL_SUNDAY')[calendar] : Registry.getComponentMethod('calendars', 'CANONICAL_TICK')[calendar];
  } else {
    return sunday ? '2000-01-02' : '2000-01-01';
  }
}

/*
 * dfltRange: for each calendar, give a valid default range
 */
exports.dfltRange = function (calendar) {
  if (isWorldCalendar(calendar)) {
    return Registry.getComponentMethod('calendars', 'DFLTRANGE')[calendar];
  } else {
    return ['2000-01-01', '2001-01-01'];
  }
};

// is an object a javascript date?
exports.isJSDate = function (v) {
  return typeof v === 'object' && v !== null && typeof v.getTime === 'function';
};

// The absolute limits of our date-time system
// This is a little weird: we use MIN_MS and MAX_MS in dateTime2ms
// but we use dateTime2ms to calculate them (after defining it!)
var MIN_MS, MAX_MS;

/**
 * dateTime2ms - turn a date object or string s into milliseconds
 * (relative to 1970-01-01, per javascript standard)
 * optional calendar (string) to use a non-gregorian calendar
 *
 * Returns BADNUM if it doesn't find a date
 *
 * strings should have the form:
 *
 *    -?YYYY-mm-dd<sep>HH:MM:SS.sss<tzInfo>?
 *
 * <sep>: space (our normal standard) or T or t (ISO-8601)
 * <tzInfo>: Z, z, [+\-]HH:?MM or [+\-]HH and we THROW IT AWAY
 * this format comes from https://tools.ietf.org/html/rfc3339#section-5.6
 * and 4.2.5.1 Difference between local time and UTC of day (ISO-8601)
 * but we allow it even with a space as the separator
 *
 * May truncate after any full field, and sss can be any length
 * even >3 digits, though javascript dates truncate to milliseconds,
 * we keep as much as javascript numeric precision can hold, but we only
 * report back up to 100 microsecond precision, because most dates support
 * this precision (close to 1970 support more, very far away support less)
 *
 * Expanded to support negative years to -9999 but you must always
 * give 4 digits, except for 2-digit positive years which we assume are
 * near the present time.
 * Note that we follow ISO 8601:2004: there *is* a year 0, which
 * is 1BC/BCE, and -1===2BC etc.
 *
 * World calendars: not all of these *have* agreed extensions to this full range,
 * if you have another calendar system but want a date range outside its validity,
 * you can use a gregorian date string prefixed with 'G' or 'g'.
 *
 * Where to cut off 2-digit years between 1900s and 2000s?
 * from https://docs.microsoft.com/en-us/office/troubleshoot/excel/two-digit-year-numbers#the-2029-rule:
 *   1930-2029 (the most retro of all...)
 * but in my mac chrome from eg. d=new Date(Date.parse('8/19/50')):
 *   1950-2049
 * by Java, from http://stackoverflow.com/questions/2024273/:
 *   now-80 - now+19
 * or FileMaker Pro, from
 *      https://fmhelp.filemaker.com/help/18/fmp/en/index.html#page/FMP_Help/dates-with-two-digit-years.html:
 *   now-70 - now+29
 * but python strptime etc, via
 *      http://docs.python.org/py3k/library/time.html:
 *   1969-2068 (super forward-looking, but static, not sliding!)
 *
 * lets go with now-70 to now+29, and if anyone runs into this problem
 * they can learn the hard way not to use 2-digit years, as no choice we
 * make now will cover all possibilities. mostly this will all be taken
 * care of in initial parsing, should only be an issue for hand-entered data
 * currently (2016) this range is:
 *   1946-2045
 */
exports.dateTime2ms = function (s, calendar) {
  // first check if s is a date object
  if (exports.isJSDate(s)) {
    // Convert to the UTC milliseconds that give the same
    // hours as this date has in the local timezone
    var tzOffset = s.getTimezoneOffset() * ONEMIN;
    var offsetTweak = (s.getUTCMinutes() - s.getMinutes()) * ONEMIN + (s.getUTCSeconds() - s.getSeconds()) * ONESEC + (s.getUTCMilliseconds() - s.getMilliseconds());
    if (offsetTweak) {
      var comb = 3 * ONEMIN;
      tzOffset = tzOffset - comb / 2 + mod(offsetTweak - tzOffset + comb / 2, comb);
    }
    s = Number(s) - tzOffset;
    if (s >= MIN_MS && s <= MAX_MS) return s;
    return BADNUM;
  }
  // otherwise only accept strings and numbers
  if (typeof s !== 'string' && typeof s !== 'number') return BADNUM;
  s = String(s);
  var isWorld = isWorldCalendar(calendar);

  // to handle out-of-range dates in international calendars, accept
  // 'G' as a prefix to force the built-in gregorian calendar.
  var s0 = s.charAt(0);
  if (isWorld && (s0 === 'G' || s0 === 'g')) {
    s = s.substr(1);
    calendar = '';
  }
  var isChinese = isWorld && calendar.substr(0, 7) === 'chinese';
  var match = s.match(isChinese ? DATETIME_REGEXP_CN : DATETIME_REGEXP);
  if (!match) return BADNUM;
  var y = match[1];
  var m = match[3] || '1';
  var d = Number(match[5] || 1);
  var H = Number(match[7] || 0);
  var M = Number(match[9] || 0);
  var S = Number(match[11] || 0);
  if (isWorld) {
    // disallow 2-digit years for world calendars
    if (y.length === 2) return BADNUM;
    y = Number(y);
    var cDate;
    try {
      var calInstance = Registry.getComponentMethod('calendars', 'getCal')(calendar);
      if (isChinese) {
        var isIntercalary = m.charAt(m.length - 1) === 'i';
        m = parseInt(m, 10);
        cDate = calInstance.newDate(y, calInstance.toMonthIndex(y, m, isIntercalary), d);
      } else {
        cDate = calInstance.newDate(y, Number(m), d);
      }
    } catch (e) {
      return BADNUM;
    } // Invalid ... date

    if (!cDate) return BADNUM;
    return (cDate.toJD() - EPOCHJD) * ONEDAY + H * ONEHOUR + M * ONEMIN + S * ONESEC;
  }
  if (y.length === 2) {
    y = (Number(y) + 2000 - YFIRST) % 100 + YFIRST;
  } else y = Number(y);

  // new Date uses months from 0; subtract 1 here just so we
  // don't have to do it again during the validity test below
  m -= 1;

  // javascript takes new Date(0..99,m,d) to mean 1900-1999, so
  // to support years 0-99 we need to use setFullYear explicitly
  // Note that 2000 is a leap year.
  var date = new Date(Date.UTC(2000, m, d, H, M));
  date.setUTCFullYear(y);
  if (date.getUTCMonth() !== m) return BADNUM;
  if (date.getUTCDate() !== d) return BADNUM;
  return date.getTime() + S * ONESEC;
};
MIN_MS = exports.MIN_MS = exports.dateTime2ms('-9999');
MAX_MS = exports.MAX_MS = exports.dateTime2ms('9999-12-31 23:59:59.9999');

// is string s a date? (see above)
exports.isDateTime = function (s, calendar) {
  return exports.dateTime2ms(s, calendar) !== BADNUM;
};

// pad a number with zeroes, to given # of digits before the decimal point
function lpad(val, digits) {
  return String(val + Math.pow(10, digits)).substr(1);
}

/**
 * Turn ms into string of the form YYYY-mm-dd HH:MM:SS.ssss
 * Crop any trailing zeros in time, except never stop right after hours
 * (we could choose to crop '-01' from date too but for now we always
 * show the whole date)
 * Optional range r is the data range that applies, also in ms.
 * If rng is big, the later parts of time will be omitted
 */
var NINETYDAYS = 90 * ONEDAY;
var THREEHOURS = 3 * ONEHOUR;
var FIVEMIN = 5 * ONEMIN;
exports.ms2DateTime = function (ms, r, calendar) {
  if (typeof ms !== 'number' || !(ms >= MIN_MS && ms <= MAX_MS)) return BADNUM;
  if (!r) r = 0;
  var msecTenths = Math.floor(mod(ms + 0.05, 1) * 10);
  var msRounded = Math.round(ms - msecTenths / 10);
  var dateStr, h, m, s, msec10, d;
  if (isWorldCalendar(calendar)) {
    var dateJD = Math.floor(msRounded / ONEDAY) + EPOCHJD;
    var timeMs = Math.floor(mod(ms, ONEDAY));
    try {
      dateStr = Registry.getComponentMethod('calendars', 'getCal')(calendar).fromJD(dateJD).formatDate('yyyy-mm-dd');
    } catch (e) {
      // invalid date in this calendar - fall back to Gyyyy-mm-dd
      dateStr = utcFormat('G%Y-%m-%d')(new Date(msRounded));
    }

    // yyyy does NOT guarantee 4-digit years. YYYY mostly does, but does
    // other things for a few calendars, so we can't trust it. Just pad
    // it manually (after the '-' if there is one)
    if (dateStr.charAt(0) === '-') {
      while (dateStr.length < 11) dateStr = '-0' + dateStr.substr(1);
    } else {
      while (dateStr.length < 10) dateStr = '0' + dateStr;
    }

    // TODO: if this is faster, we could use this block for extracting
    // the time components of regular gregorian too
    h = r < NINETYDAYS ? Math.floor(timeMs / ONEHOUR) : 0;
    m = r < NINETYDAYS ? Math.floor(timeMs % ONEHOUR / ONEMIN) : 0;
    s = r < THREEHOURS ? Math.floor(timeMs % ONEMIN / ONESEC) : 0;
    msec10 = r < FIVEMIN ? timeMs % ONESEC * 10 + msecTenths : 0;
  } else {
    d = new Date(msRounded);
    dateStr = utcFormat('%Y-%m-%d')(d);

    // <90 days: add hours and minutes - never *only* add hours
    h = r < NINETYDAYS ? d.getUTCHours() : 0;
    m = r < NINETYDAYS ? d.getUTCMinutes() : 0;
    // <3 hours: add seconds
    s = r < THREEHOURS ? d.getUTCSeconds() : 0;
    // <5 minutes: add ms (plus one extra digit, this is msec*10)
    msec10 = r < FIVEMIN ? d.getUTCMilliseconds() * 10 + msecTenths : 0;
  }
  return includeTime(dateStr, h, m, s, msec10);
};

// For converting old-style milliseconds to date strings,
// we use the local timezone rather than UTC like we use
// everywhere else, both for backward compatibility and
// because that's how people mostly use javasript date objects.
// Clip one extra day off our date range though so we can't get
// thrown beyond the range by the timezone shift.
exports.ms2DateTimeLocal = function (ms) {
  if (!(ms >= MIN_MS + ONEDAY && ms <= MAX_MS - ONEDAY)) return BADNUM;
  var msecTenths = Math.floor(mod(ms + 0.05, 1) * 10);
  var d = new Date(Math.round(ms - msecTenths / 10));
  var dateStr = timeFormat('%Y-%m-%d')(d);
  var h = d.getHours();
  var m = d.getMinutes();
  var s = d.getSeconds();
  var msec10 = d.getUTCMilliseconds() * 10 + msecTenths;
  return includeTime(dateStr, h, m, s, msec10);
};
function includeTime(dateStr, h, m, s, msec10) {
  // include each part that has nonzero data in or after it
  if (h || m || s || msec10) {
    dateStr += ' ' + lpad(h, 2) + ':' + lpad(m, 2);
    if (s || msec10) {
      dateStr += ':' + lpad(s, 2);
      if (msec10) {
        var digits = 4;
        while (msec10 % 10 === 0) {
          digits -= 1;
          msec10 /= 10;
        }
        dateStr += '.' + lpad(msec10, digits);
      }
    }
  }
  return dateStr;
}

// normalize date format to date string, in case it starts as
// a Date object or milliseconds
// optional dflt is the return value if cleaning fails
exports.cleanDate = function (v, dflt, calendar) {
  // let us use cleanDate to provide a missing default without an error
  if (v === BADNUM) return dflt;
  if (exports.isJSDate(v) || typeof v === 'number' && isFinite(v)) {
    // do not allow milliseconds (old) or jsdate objects (inherently
    // described as gregorian dates) with world calendars
    if (isWorldCalendar(calendar)) {
      Loggers.error('JS Dates and milliseconds are incompatible with world calendars', v);
      return dflt;
    }

    // NOTE: if someone puts in a year as a number rather than a string,
    // this will mistakenly convert it thinking it's milliseconds from 1970
    // that is: '2012' -> Jan. 1, 2012, but 2012 -> 2012 epoch milliseconds
    v = exports.ms2DateTimeLocal(+v);
    if (!v && dflt !== undefined) return dflt;
  } else if (!exports.isDateTime(v, calendar)) {
    Loggers.error('unrecognized date', v);
    return dflt;
  }
  return v;
};

/*
 *  Date formatting for ticks and hovertext
 */

/*
 * modDateFormat: Support world calendars, and add two items to
 * d3's vocabulary:
 * %{n}f where n is the max number of digits of fractional seconds
 * %h formats: half of the year as a decimal number [1,2]
 */
var fracMatch = /%\d?f/g;
var halfYearMatch = /%h/g;
var quarterToHalfYear = {
  1: '1',
  2: '1',
  3: '2',
  4: '2'
};
function modDateFormat(fmt, x, formatter, calendar) {
  fmt = fmt.replace(fracMatch, function (match) {
    var digits = Math.min(+match.charAt(1) || 6, 6);
    var fracSecs = (x / 1000 % 1 + 2).toFixed(digits).substr(2).replace(/0+$/, '') || '0';
    return fracSecs;
  });
  var d = new Date(Math.floor(x + 0.05));
  fmt = fmt.replace(halfYearMatch, function () {
    return quarterToHalfYear[formatter('%q')(d)];
  });
  if (isWorldCalendar(calendar)) {
    try {
      fmt = Registry.getComponentMethod('calendars', 'worldCalFmt')(fmt, x, calendar);
    } catch (e) {
      return 'Invalid';
    }
  }
  return formatter(fmt)(d);
}

/*
 * formatTime: create a time string from:
 *   x: milliseconds
 *   tr: tickround ('M', 'S', or # digits)
 * only supports UTC times (where every day is 24 hours and 0 is at midnight)
 */
var MAXSECONDS = [59, 59.9, 59.99, 59.999, 59.9999];
function formatTime(x, tr) {
  var timePart = mod(x + 0.05, ONEDAY);
  var timeStr = lpad(Math.floor(timePart / ONEHOUR), 2) + ':' + lpad(mod(Math.floor(timePart / ONEMIN), 60), 2);
  if (tr !== 'M') {
    if (!isNumeric(tr)) tr = 0; // should only be 'S'

    /*
     * this is a weird one - and shouldn't come up unless people
     * monkey with tick0 in weird ways, but we need to do something!
     * IN PARTICULAR we had better not display garbage (see below)
     * for numbers we always round to the nearest increment of the
     * precision we're showing, and this seems like the right way to
     * handle seconds and milliseconds, as they have a decimal point
     * and people will interpret that to mean rounding like numbers.
     * but for larger increments we floor the value: it's always
     * 2013 until the ball drops on the new year. We could argue about
     * which field it is where we start rounding (should 12:08:59
     * round to 12:09 if we're stopping at minutes?) but for now I'll
     * say we round seconds but floor everything else. BUT that means
     * we need to never round up to 60 seconds, ie 23:59:60
     */
    var sec = Math.min(mod(x / ONESEC, 60), MAXSECONDS[tr]);
    var secStr = (100 + sec).toFixed(tr).substr(1);
    if (tr > 0) {
      secStr = secStr.replace(/0+$/, '').replace(/[\.]$/, '');
    }
    timeStr += ':' + secStr;
  }
  return timeStr;
}

/*
 * formatDate: turn a date into tick or hover label text.
 *
 *   x: milliseconds, the value to convert
 *   fmt: optional, an explicit format string (d3 format, even for world calendars)
 *   tr: tickround ('y', 'm', 'd', 'M', 'S', or # digits)
 *      used if no explicit fmt is provided
 *   formatter: locale-aware d3 date formatter for standard gregorian calendars
 *      should be the result of exports.getD3DateFormat(gd)
 *   calendar: optional string, the world calendar system to use
 *
 * returns the date/time as a string, potentially with the leading portion
 * on a separate line (after '\n')
 * Note that this means if you provide an explicit format which includes '\n'
 * the axis may choose to strip things after it when they don't change from
 * one tick to the next (as it does with automatic formatting)
 */
exports.formatDate = function (x, fmt, tr, formatter, calendar, extraFormat) {
  calendar = isWorldCalendar(calendar) && calendar;
  if (!fmt) {
    if (tr === 'y') fmt = extraFormat.year;else if (tr === 'm') fmt = extraFormat.month;else if (tr === 'd') {
      fmt = extraFormat.dayMonth + '\n' + extraFormat.year;
    } else {
      return formatTime(x, tr) + '\n' + modDateFormat(extraFormat.dayMonthYear, x, formatter, calendar);
    }
  }
  return modDateFormat(fmt, x, formatter, calendar);
};

/*
 * incrementMonth: make a new milliseconds value from the given one,
 * having changed the month
 *
 * special case for world calendars: multiples of 12 are treated as years,
 * even for calendar systems that don't have (always or ever) 12 months/year
 * TODO: perhaps we need a different code for year increments to support this?
 *
 * ms (number): the initial millisecond value
 * dMonth (int): the (signed) number of months to shift
 * calendar (string): the calendar system to use
 *
 * changing month does not (and CANNOT) always preserve day, since
 * months have different lengths. The worst example of this is:
 *   d = new Date(1970,0,31); d.setMonth(1) -> Feb 31 turns into Mar 3
 *
 * But we want to be able to iterate over the last day of each month,
 * regardless of what its number is.
 * So shift 3 days forward, THEN set the new month, then unshift:
 *   1/31 -> 2/28 (or 29) -> 3/31 -> 4/30 -> ...
 *
 * Note that odd behavior still exists if you start from the 26th-28th:
 *   1/28 -> 2/28 -> 3/31
 * but at least you can't shift any dates into the wrong month,
 * and ticks on these days incrementing by month would be very unusual
 */
var THREEDAYS = 3 * ONEDAY;
exports.incrementMonth = function (ms, dMonth, calendar) {
  calendar = isWorldCalendar(calendar) && calendar;

  // pull time out and operate on pure dates, then add time back at the end
  // this gives maximum precision - not that we *normally* care if we're
  // incrementing by month, but better to be safe!
  var timeMs = mod(ms, ONEDAY);
  ms = Math.round(ms - timeMs);
  if (calendar) {
    try {
      var dateJD = Math.round(ms / ONEDAY) + EPOCHJD;
      var calInstance = Registry.getComponentMethod('calendars', 'getCal')(calendar);
      var cDate = calInstance.fromJD(dateJD);
      if (dMonth % 12) calInstance.add(cDate, dMonth, 'm');else calInstance.add(cDate, dMonth / 12, 'y');
      return (cDate.toJD() - EPOCHJD) * ONEDAY + timeMs;
    } catch (e) {
      Loggers.error('invalid ms ' + ms + ' in calendar ' + calendar);
      // then keep going in gregorian even though the result will be 'Invalid'
    }
  }

  var y = new Date(ms + THREEDAYS);
  return y.setUTCMonth(y.getUTCMonth() + dMonth) + timeMs - THREEDAYS;
};

/*
 * findExactDates: what fraction of data is exact days, months, or years?
 *
 * data: array of millisecond values
 * calendar (string) the calendar to test against
 */
exports.findExactDates = function (data, calendar) {
  var exactYears = 0;
  var exactMonths = 0;
  var exactDays = 0;
  var blankCount = 0;
  var d;
  var di;
  var calInstance = isWorldCalendar(calendar) && Registry.getComponentMethod('calendars', 'getCal')(calendar);
  for (var i = 0; i < data.length; i++) {
    di = data[i];

    // not date data at all
    if (!isNumeric(di)) {
      blankCount++;
      continue;
    }

    // not an exact date
    if (di % ONEDAY) continue;
    if (calInstance) {
      try {
        d = calInstance.fromJD(di / ONEDAY + EPOCHJD);
        if (d.day() === 1) {
          if (d.month() === 1) exactYears++;else exactMonths++;
        } else exactDays++;
      } catch (e) {
        // invalid date in this calendar - ignore it here.
      }
    } else {
      d = new Date(di);
      if (d.getUTCDate() === 1) {
        if (d.getUTCMonth() === 0) exactYears++;else exactMonths++;
      } else exactDays++;
    }
  }
  exactMonths += exactYears;
  exactDays += exactMonths;
  var dataCount = data.length - blankCount;
  return {
    exactYears: exactYears / dataCount,
    exactMonths: exactMonths / dataCount,
    exactDays: exactDays / dataCount
  };
};

/***/ }),

/***/ 4401:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var loggers = __webpack_require__(7769);
var matrix = __webpack_require__(5657);
var mat4X4 = __webpack_require__(9576);

/**
 * Allow referencing a graph DOM element either directly
 * or by its id string
 *
 * @param {HTMLDivElement|string} gd: a graph element or its id
 *
 * @returns {HTMLDivElement} the DOM element of the graph
 */
function getGraphDiv(gd) {
  var gdElement;
  if (typeof gd === 'string') {
    gdElement = document.getElementById(gd);
    if (gdElement === null) {
      throw new Error('No DOM element with id \'' + gd + '\' exists on the page.');
    }
    return gdElement;
  } else if (gd === null || gd === undefined) {
    throw new Error('DOM element provided is null or undefined');
  }

  // otherwise assume that gd is a DOM element
  return gd;
}
function isPlotDiv(el) {
  var el3 = d3.select(el);
  return el3.node() instanceof HTMLElement && el3.size() && el3.classed('js-plotly-plot');
}
function removeElement(el) {
  var elParent = el && el.parentNode;
  if (elParent) elParent.removeChild(el);
}

/**
 * for dynamically adding style rules
 * makes one stylesheet that contains all rules added
 * by all calls to this function
 */
function addStyleRule(selector, styleString) {
  addRelatedStyleRule('global', selector, styleString);
}

/**
 * for dynamically adding style rules
 * to a stylesheet uniquely identified by a uid
 */
function addRelatedStyleRule(uid, selector, styleString) {
  var id = 'plotly.js-style-' + uid;
  var style = document.getElementById(id);
  if (!style) {
    style = document.createElement('style');
    style.setAttribute('id', id);
    // WebKit hack :(
    style.appendChild(document.createTextNode(''));
    document.head.appendChild(style);
  }
  var styleSheet = style.sheet;
  if (styleSheet.insertRule) {
    styleSheet.insertRule(selector + '{' + styleString + '}', 0);
  } else if (styleSheet.addRule) {
    styleSheet.addRule(selector, styleString, 0);
  } else loggers.warn('addStyleRule failed');
}

/**
 * to remove from the page a stylesheet identified by a given uid
 */
function deleteRelatedStyleRule(uid) {
  var id = 'plotly.js-style-' + uid;
  var style = document.getElementById(id);
  if (style) removeElement(style);
}
function getFullTransformMatrix(element) {
  var allElements = getElementAndAncestors(element);
  // the identity matrix
  var out = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  allElements.forEach(function (e) {
    var t = getElementTransformMatrix(e);
    if (t) {
      var m = matrix.convertCssMatrix(t);
      out = mat4X4.multiply(out, out, m);
    }
  });
  return out;
}

/**
 * extracts and parses the 2d css style transform matrix from some element
 */
function getElementTransformMatrix(element) {
  var style = window.getComputedStyle(element, null);
  var transform = style.getPropertyValue('-webkit-transform') || style.getPropertyValue('-moz-transform') || style.getPropertyValue('-ms-transform') || style.getPropertyValue('-o-transform') || style.getPropertyValue('transform');
  if (transform === 'none') return null;
  // the transform is a string in the form of matrix(a, b, ...) or matrix3d(...)
  return transform.replace('matrix', '').replace('3d', '').slice(1, -1).split(',').map(function (n) {
    return +n;
  });
}
/**
 * retrieve all DOM elements that are ancestors of the specified one (including itself)
 */
function getElementAndAncestors(element) {
  var allElements = [];
  while (isTransformableElement(element)) {
    allElements.push(element);
    element = element.parentNode;
  }
  return allElements;
}
function isTransformableElement(element) {
  return element && (element instanceof Element || element instanceof HTMLElement);
}
function equalDomRects(a, b) {
  return a && b && a.top === b.top && a.left === b.left && a.right === b.right && a.bottom === b.bottom;
}
module.exports = {
  getGraphDiv: getGraphDiv,
  isPlotDiv: isPlotDiv,
  removeElement: removeElement,
  addStyleRule: addStyleRule,
  addRelatedStyleRule: addRelatedStyleRule,
  deleteRelatedStyleRule: deleteRelatedStyleRule,
  getFullTransformMatrix: getFullTransformMatrix,
  getElementTransformMatrix: getElementTransformMatrix,
  getElementAndAncestors: getElementAndAncestors,
  equalDomRects: equalDomRects
};

/***/ }),

/***/ 1086:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/* global jQuery:false */
var EventEmitter = (__webpack_require__(5398).EventEmitter);
var Events = {
  init: function (plotObj) {
    /*
     * If we have already instantiated an emitter for this plot
     * return early.
     */
    if (plotObj._ev instanceof EventEmitter) return plotObj;
    var ev = new EventEmitter();
    var internalEv = new EventEmitter();

    /*
     * Assign to plot._ev while we still live in a land
     * where plot is a DOM element with stuff attached to it.
     * In the future we can make plot the event emitter itself.
     */
    plotObj._ev = ev;

    /*
     * Create a second event handler that will manage events *internally*.
     * This allows parts of plotly to respond to thing like relayout without
     * having to use the user-facing event handler. They cannot peacefully
     * coexist on the same handler because a user invoking
     * plotObj.removeAllListeners() would detach internal events, breaking
     * plotly.
     */
    plotObj._internalEv = internalEv;

    /*
     * Assign bound methods from the ev to the plot object. These methods
     * will reference the 'this' of plot._ev even though they are methods
     * of plot. This will keep the event machinery away from the plot object
     * which currently is often a DOM element but presents an API that will
     * continue to function when plot becomes an emitter. Not all EventEmitter
     * methods have been bound to `plot` as some do not currently add value to
     * the Plotly event API.
     */
    plotObj.on = ev.on.bind(ev);
    plotObj.once = ev.once.bind(ev);
    plotObj.removeListener = ev.removeListener.bind(ev);
    plotObj.removeAllListeners = ev.removeAllListeners.bind(ev);

    /*
     * Create functions for managing internal events. These are *only* triggered
     * by the mirroring of external events via the emit function.
     */
    plotObj._internalOn = internalEv.on.bind(internalEv);
    plotObj._internalOnce = internalEv.once.bind(internalEv);
    plotObj._removeInternalListener = internalEv.removeListener.bind(internalEv);
    plotObj._removeAllInternalListeners = internalEv.removeAllListeners.bind(internalEv);

    /*
     * We must wrap emit to continue to support JQuery events. The idea
     * is to check to see if the user is using JQuery events, if they are
     * we emit JQuery events to trigger user handlers as well as the EventEmitter
     * events.
     */
    plotObj.emit = function (event, data) {
      if (typeof jQuery !== 'undefined') {
        jQuery(plotObj).trigger(event, data);
      }
      ev.emit(event, data);
      internalEv.emit(event, data);
    };
    return plotObj;
  },
  /*
   * This function behaves like jQuery's triggerHandler. It calls
   * all handlers for a particular event and returns the return value
   * of the LAST handler. This function also triggers jQuery's
   * triggerHandler for backwards compatibility.
   */
  triggerHandler: function (plotObj, event, data) {
    var jQueryHandlerValue;
    var nodeEventHandlerValue;

    /*
     * If jQuery exists run all its handlers for this event and
     * collect the return value of the LAST handler function
     */
    if (typeof jQuery !== 'undefined') {
      jQueryHandlerValue = jQuery(plotObj).triggerHandler(event, data);
    }

    /*
     * Now run all the node style event handlers
     */
    var ev = plotObj._ev;
    if (!ev) return jQueryHandlerValue;
    var handlers = ev._events[event];
    if (!handlers) return jQueryHandlerValue;

    // making sure 'this' is the EventEmitter instance
    function apply(handler) {
      // The 'once' case, we can't just call handler() as we need
      // the return value here. So,
      // - remove handler
      // - call listener and grab return value!
      // - stash 'fired' key to not call handler twice
      if (handler.listener) {
        ev.removeListener(event, handler.listener);
        if (!handler.fired) {
          handler.fired = true;
          return handler.listener.apply(ev, [data]);
        }
      } else {
        return handler.apply(ev, [data]);
      }
    }

    // handlers can be function or an array of functions
    handlers = Array.isArray(handlers) ? handlers : [handlers];
    var i;
    for (i = 0; i < handlers.length - 1; i++) {
      apply(handlers[i]);
    }
    // now call the final handler and collect its value
    nodeEventHandlerValue = apply(handlers[i]);

    /*
     * Return either the jQuery handler value if it exists or the
     * nodeEventHandler value. jQuery event value supersedes nodejs
     * events for backwards compatibility reasons.
     */
    return jQueryHandlerValue !== undefined ? jQueryHandlerValue : nodeEventHandlerValue;
  },
  purge: function (plotObj) {
    delete plotObj._ev;
    delete plotObj.on;
    delete plotObj.once;
    delete plotObj.removeListener;
    delete plotObj.removeAllListeners;
    delete plotObj.emit;
    delete plotObj._ev;
    delete plotObj._internalEv;
    delete plotObj._internalOn;
    delete plotObj._internalOnce;
    delete plotObj._removeInternalListener;
    delete plotObj._removeAllInternalListeners;
    return plotObj;
  }
};
module.exports = Events;

/***/ }),

/***/ 1426:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var isPlainObject = __webpack_require__(1965);
var isArray = Array.isArray;
function primitivesLoopSplice(source, target) {
  var i, value;
  for (i = 0; i < source.length; i++) {
    value = source[i];
    if (value !== null && typeof value === 'object') {
      return false;
    }
    if (value !== void 0) {
      target[i] = value;
    }
  }
  return true;
}
exports.extendFlat = function () {
  return _extend(arguments, false, false, false);
};
exports.extendDeep = function () {
  return _extend(arguments, true, false, false);
};
exports.extendDeepAll = function () {
  return _extend(arguments, true, true, false);
};
exports.extendDeepNoArrays = function () {
  return _extend(arguments, true, false, true);
};

/*
 * Inspired by https://github.com/justmoon/node-extend/blob/master/index.js
 * All credit to the jQuery authors for perfecting this amazing utility.
 *
 * API difference with jQuery version:
 * - No optional boolean (true -> deep extend) first argument,
 *   use `extendFlat` for first-level only extend and
 *   use `extendDeep` for a deep extend.
 *
 * Other differences with jQuery version:
 * - Uses a modern (and faster) isPlainObject routine.
 * - Expected to work with object {} and array [] arguments only.
 * - Does not check for circular structure.
 *   FYI: jQuery only does a check across one level.
 *   Warning: this might result in infinite loops.
 *
 */
function _extend(inputs, isDeep, keepAllKeys, noArrayCopies) {
  var target = inputs[0];
  var length = inputs.length;
  var input, key, src, copy, copyIsArray, clone, allPrimitives;

  // TODO does this do the right thing for typed arrays?

  if (length === 2 && isArray(target) && isArray(inputs[1]) && target.length === 0) {
    allPrimitives = primitivesLoopSplice(inputs[1], target);
    if (allPrimitives) {
      return target;
    } else {
      target.splice(0, target.length); // reset target and continue to next block
    }
  }

  for (var i = 1; i < length; i++) {
    input = inputs[i];
    for (key in input) {
      src = target[key];
      copy = input[key];
      if (noArrayCopies && isArray(copy)) {
        // Stop early and just transfer the array if array copies are disallowed:

        target[key] = copy;
      } else if (isDeep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
        // recurse if we're merging plain objects or arrays

        if (copyIsArray) {
          copyIsArray = false;
          clone = src && isArray(src) ? src : [];
        } else {
          clone = src && isPlainObject(src) ? src : {};
        }

        // never move original objects, clone them
        target[key] = _extend([clone, copy], isDeep, keepAllKeys, noArrayCopies);
      } else if (typeof copy !== 'undefined' || keepAllKeys) {
        // don't bring in undefined values, except for extendDeepAll

        target[key] = copy;
      }
    }
  }
  return target;
}

/***/ }),

/***/ 5744:
/***/ (function(module) {

"use strict";


/**
 * Return news array containing only the unique items
 * found in input array.
 *
 * IMPORTANT: Note that items are considered unique
 * if `String({})` is unique. For example;
 *
 *  Lib.filterUnique([ { a: 1 }, { b: 2 } ])
 *
 *  returns [{ a: 1 }]
 *
 * and
 *
 *  Lib.filterUnique([ '1', 1 ])
 *
 *  returns ['1']
 *
 *
 * @param {array} array base array
 * @return {array} new filtered array
 */
module.exports = function filterUnique(array) {
  var seen = {};
  var out = [];
  var j = 0;
  for (var i = 0; i < array.length; i++) {
    var item = array[i];
    if (seen[item] !== 1) {
      seen[item] = 1;
      out[j++] = item;
    }
  }
  return out;
};

/***/ }),

/***/ 6756:
/***/ (function(module) {

"use strict";


/** Filter out object items with visible !== true
 *  insider array container.
 *
 *  @param {array of objects} container
 *  @return {array of objects} of length <= container
 *
 */
module.exports = function filterVisible(container) {
  var filterFn = isCalcData(container) ? calcDataFilter : baseFilter;
  var out = [];
  for (var i = 0; i < container.length; i++) {
    var item = container[i];
    if (filterFn(item)) out.push(item);
  }
  return out;
};
function baseFilter(item) {
  return item.visible === true;
}
function calcDataFilter(item) {
  var trace = item[0].trace;
  return trace.visible === true && trace._length !== 0;
}
function isCalcData(cont) {
  return Array.isArray(cont) && Array.isArray(cont[0]) && cont[0][0] && cont[0][0].trace;
}

/***/ }),

/***/ 7642:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var mod = (__webpack_require__(4872).mod);

/*
 * look for intersection of two line segments
 *   (1->2 and 3->4) - returns array [x,y] if they do, null if not
 */
exports.segmentsIntersect = segmentsIntersect;
function segmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
  var a = x2 - x1;
  var b = x3 - x1;
  var c = x4 - x3;
  var d = y2 - y1;
  var e = y3 - y1;
  var f = y4 - y3;
  var det = a * f - c * d;
  // parallel lines? intersection is undefined
  // ignore the case where they are colinear
  if (det === 0) return null;
  var t = (b * f - c * e) / det;
  var u = (b * d - a * e) / det;
  // segments do not intersect?
  if (u < 0 || u > 1 || t < 0 || t > 1) return null;
  return {
    x: x1 + a * t,
    y: y1 + d * t
  };
}

/*
 * find the minimum distance between two line segments (1->2 and 3->4)
 */
exports.segmentDistance = function segmentDistance(x1, y1, x2, y2, x3, y3, x4, y4) {
  if (segmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4)) return 0;

  // the two segments and their lengths squared
  var x12 = x2 - x1;
  var y12 = y2 - y1;
  var x34 = x4 - x3;
  var y34 = y4 - y3;
  var ll12 = x12 * x12 + y12 * y12;
  var ll34 = x34 * x34 + y34 * y34;

  // calculate distance squared, then take the sqrt at the very end
  var dist2 = Math.min(perpDistance2(x12, y12, ll12, x3 - x1, y3 - y1), perpDistance2(x12, y12, ll12, x4 - x1, y4 - y1), perpDistance2(x34, y34, ll34, x1 - x3, y1 - y3), perpDistance2(x34, y34, ll34, x2 - x3, y2 - y3));
  return Math.sqrt(dist2);
};

/*
 * distance squared from segment ab to point c
 * [xab, yab] is the vector b-a
 * [xac, yac] is the vector c-a
 * llab is the length squared of (b-a), just to simplify calculation
 */
function perpDistance2(xab, yab, llab, xac, yac) {
  var fcAB = xac * xab + yac * yab;
  if (fcAB < 0) {
    // point c is closer to point a
    return xac * xac + yac * yac;
  } else if (fcAB > llab) {
    // point c is closer to point b
    var xbc = xac - xab;
    var ybc = yac - yab;
    return xbc * xbc + ybc * ybc;
  } else {
    // perpendicular distance is the shortest
    var crossProduct = xac * yab - yac * xab;
    return crossProduct * crossProduct / llab;
  }
}

// a very short-term cache for getTextLocation, just because
// we're often looping over the same locations multiple times
// invalidated as soon as we look at a different path
var locationCache, workingPath, workingTextWidth;

// turn a path and position along it into x, y, and angle for the given text
exports.getTextLocation = function getTextLocation(path, totalPathLen, positionOnPath, textWidth) {
  if (path !== workingPath || textWidth !== workingTextWidth) {
    locationCache = {};
    workingPath = path;
    workingTextWidth = textWidth;
  }
  if (locationCache[positionOnPath]) {
    return locationCache[positionOnPath];
  }

  // for the angle, use points on the path separated by the text width
  // even though due to curvature, the text will cover a bit more than that
  var p0 = path.getPointAtLength(mod(positionOnPath - textWidth / 2, totalPathLen));
  var p1 = path.getPointAtLength(mod(positionOnPath + textWidth / 2, totalPathLen));
  // note: atan handles 1/0 nicely
  var theta = Math.atan((p1.y - p0.y) / (p1.x - p0.x));
  // center the text at 2/3 of the center position plus 1/3 the p0/p1 midpoint
  // that's the average position of this segment, assuming it's roughly quadratic
  var pCenter = path.getPointAtLength(mod(positionOnPath, totalPathLen));
  var x = (pCenter.x * 4 + p0.x + p1.x) / 6;
  var y = (pCenter.y * 4 + p0.y + p1.y) / 6;
  var out = {
    x: x,
    y: y,
    theta: theta
  };
  locationCache[positionOnPath] = out;
  return out;
};
exports.clearLocationCache = function () {
  workingPath = null;
};

/*
 * Find the segment of `path` that's within the visible area
 * given by `bounds` {left, right, top, bottom}, to within a
 * precision of `buffer` px
 *
 * returns: undefined if nothing is visible, else object:
 * {
 *   min: position where the path first enters bounds, or 0 if it
 *        starts within bounds
 *   max: position where the path last exits bounds, or the path length
 *        if it finishes within bounds
 *   len: max - min, ie the length of visible path
 *   total: the total path length - just included so the caller doesn't
 *        need to call path.getTotalLength() again
 *   isClosed: true iff the start and end points of the path are both visible
 *        and are at the same point
 * }
 *
 * Works by starting from either end and repeatedly finding the distance from
 * that point to the plot area, and if it's outside the plot, moving along the
 * path by that distance (because the plot must be at least that far away on
 * the path). Note that if a path enters, exits, and re-enters the plot, we
 * will not capture this behavior.
 */
exports.getVisibleSegment = function getVisibleSegment(path, bounds, buffer) {
  var left = bounds.left;
  var right = bounds.right;
  var top = bounds.top;
  var bottom = bounds.bottom;
  var pMin = 0;
  var pTotal = path.getTotalLength();
  var pMax = pTotal;
  var pt0, ptTotal;
  function getDistToPlot(len) {
    var pt = path.getPointAtLength(len);

    // hold on to the start and end points for `closed`
    if (len === 0) pt0 = pt;else if (len === pTotal) ptTotal = pt;
    var dx = pt.x < left ? left - pt.x : pt.x > right ? pt.x - right : 0;
    var dy = pt.y < top ? top - pt.y : pt.y > bottom ? pt.y - bottom : 0;
    return Math.sqrt(dx * dx + dy * dy);
  }
  var distToPlot = getDistToPlot(pMin);
  while (distToPlot) {
    pMin += distToPlot + buffer;
    if (pMin > pMax) return;
    distToPlot = getDistToPlot(pMin);
  }
  distToPlot = getDistToPlot(pMax);
  while (distToPlot) {
    pMax -= distToPlot + buffer;
    if (pMin > pMax) return;
    distToPlot = getDistToPlot(pMax);
  }
  return {
    min: pMin,
    max: pMax,
    len: pMax - pMin,
    total: pTotal,
    isClosed: pMin === 0 && pMax === pTotal && Math.abs(pt0.x - ptTotal.x) < 0.1 && Math.abs(pt0.y - ptTotal.y) < 0.1
  };
};

/**
 * Find point on SVG path corresponding to a given constraint coordinate
 *
 * @param {SVGPathElement} path
 * @param {Number} val : constraint coordinate value
 * @param {String} coord : 'x' or 'y' the constraint coordinate
 * @param {Object} opts :
 *  - {Number} pathLength : supply total path length before hand
 *  - {Number} tolerance
 *  - {Number} iterationLimit
 * @return {SVGPoint}
 */
exports.findPointOnPath = function findPointOnPath(path, val, coord, opts) {
  opts = opts || {};
  var pathLength = opts.pathLength || path.getTotalLength();
  var tolerance = opts.tolerance || 1e-3;
  var iterationLimit = opts.iterationLimit || 30;

  // if path starts at a val greater than the path tail (like on vertical violins),
  // we must flip the sign of the computed diff.
  var mul = path.getPointAtLength(0)[coord] > path.getPointAtLength(pathLength)[coord] ? -1 : 1;
  var i = 0;
  var b0 = 0;
  var b1 = pathLength;
  var mid;
  var pt;
  var diff;
  while (i < iterationLimit) {
    mid = (b0 + b1) / 2;
    pt = path.getPointAtLength(mid);
    diff = pt[coord] - val;
    if (Math.abs(diff) < tolerance) {
      return pt;
    } else {
      if (mul * diff > 0) {
        b1 = mid;
      } else {
        b0 = mid;
      }
      i++;
    }
  }
  return pt;
};

/***/ }),

/***/ 1697:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var tinycolor = __webpack_require__(4267);
var rgba = __webpack_require__(5075);
var Colorscale = __webpack_require__(1081);
var colorDflt = (__webpack_require__(2399).defaultLine);
var isArrayOrTypedArray = (__webpack_require__(3627).isArrayOrTypedArray);
var colorDfltRgba = rgba(colorDflt);
var opacityDflt = 1;
function calculateColor(colorIn, opacityIn) {
  var colorOut = colorIn;
  colorOut[3] *= opacityIn;
  return colorOut;
}
function validateColor(colorIn) {
  if (isNumeric(colorIn)) return colorDfltRgba;
  var colorOut = rgba(colorIn);
  return colorOut.length ? colorOut : colorDfltRgba;
}
function validateOpacity(opacityIn) {
  return isNumeric(opacityIn) ? opacityIn : opacityDflt;
}
function formatColor(containerIn, opacityIn, len) {
  var colorIn = containerIn.color;
  var isArrayColorIn = isArrayOrTypedArray(colorIn);
  var isArrayOpacityIn = isArrayOrTypedArray(opacityIn);
  var cOpts = Colorscale.extractOpts(containerIn);
  var colorOut = [];
  var sclFunc, getColor, getOpacity, colori, opacityi;
  if (cOpts.colorscale !== undefined) {
    sclFunc = Colorscale.makeColorScaleFuncFromTrace(containerIn);
  } else {
    sclFunc = validateColor;
  }
  if (isArrayColorIn) {
    getColor = function (c, i) {
      // FIXME: there is double work, considering that sclFunc does the opposite
      return c[i] === undefined ? colorDfltRgba : rgba(sclFunc(c[i]));
    };
  } else getColor = validateColor;
  if (isArrayOpacityIn) {
    getOpacity = function (o, i) {
      return o[i] === undefined ? opacityDflt : validateOpacity(o[i]);
    };
  } else getOpacity = validateOpacity;
  if (isArrayColorIn || isArrayOpacityIn) {
    for (var i = 0; i < len; i++) {
      colori = getColor(colorIn, i);
      opacityi = getOpacity(opacityIn, i);
      colorOut[i] = calculateColor(colori, opacityi);
    }
  } else colorOut = calculateColor(rgba(colorIn), opacityIn);
  return colorOut;
}
function parseColorScale(cont) {
  var cOpts = Colorscale.extractOpts(cont);
  var colorscale = cOpts.colorscale;
  if (cOpts.reversescale) colorscale = Colorscale.flipScale(cOpts.colorscale);
  return colorscale.map(function (elem) {
    var index = elem[0];
    var color = tinycolor(elem[1]);
    var rgb = color.toRgb();
    return {
      index: index,
      rgb: [rgb.r, rgb.g, rgb.b, rgb.a]
    };
  });
}
module.exports = {
  formatColor: formatColor,
  parseColorScale: parseColorScale
};

/***/ }),

/***/ 3389:
/***/ (function(module) {

"use strict";


// Simple helper functions
// none of these need any external deps
module.exports = function identity(d) {
  return d;
};

/***/ }),

/***/ 9240:
/***/ (function(module) {

"use strict";


module.exports = function incrementNumeric(x, delta) {
  if (!delta) return x;

  // Note 1:
  // 0.3 != 0.1 + 0.2 == 0.30000000000000004
  // but 0.3 == (10 * 0.1 + 10 * 0.2) / 10
  // Attempt to use integer steps to increment
  var scale = 1 / Math.abs(delta);
  var newX = scale > 1 ? (scale * x + scale * delta) / scale : x + delta;

  // Note 2:
  // now we may also consider rounding to cover few more edge cases
  // e.g. 0.3 * 3 = 0.8999999999999999
  var lenX1 = String(newX).length;
  if (lenX1 > 16) {
    var lenDt = String(delta).length;
    var lenX0 = String(x).length;
    if (lenX1 >= lenX0 + lenDt) {
      // likely a rounding error!
      var s = parseFloat(newX).toPrecision(12);
      if (s.indexOf('e+') === -1) newX = +s;
    }
  }
  return newX;
};

/***/ }),

/***/ 1828:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var utcFormat = (__webpack_require__(4096)/* .utcFormat */ .g0);
var d3Format = (__webpack_require__(721)/* .format */ .WU);
var isNumeric = __webpack_require__(2770);
var numConstants = __webpack_require__(606);
var MAX_SAFE = numConstants.FP_SAFE;
var MIN_SAFE = -MAX_SAFE;
var BADNUM = numConstants.BADNUM;
var lib = module.exports = {};
lib.adjustFormat = function adjustFormat(formatStr) {
  if (!formatStr || /^\d[.]\df/.test(formatStr) || /[.]\d%/.test(formatStr)) return formatStr;
  if (formatStr === '0.f') return '~f';
  if (/^\d%/.test(formatStr)) return '~%';
  if (/^\ds/.test(formatStr)) return '~s';

  // try adding tilde to the start of format in order to trim
  if (!/^[~,.0$]/.test(formatStr) && /[&fps]/.test(formatStr)) return '~' + formatStr;
  return formatStr;
};
var seenBadFormats = {};
lib.warnBadFormat = function (f) {
  var key = String(f);
  if (!seenBadFormats[key]) {
    seenBadFormats[key] = 1;
    lib.warn('encountered bad format: "' + key + '"');
  }
};
lib.noFormat = function (value) {
  return String(value);
};
lib.numberFormat = function (formatStr) {
  var fn;
  try {
    fn = d3Format(lib.adjustFormat(formatStr));
  } catch (e) {
    lib.warnBadFormat(formatStr);
    return lib.noFormat;
  }
  return fn;
};
lib.nestedProperty = __webpack_require__(5487);
lib.keyedContainer = __webpack_require__(6636);
lib.relativeAttr = __webpack_require__(6962);
lib.isPlainObject = __webpack_require__(1965);
lib.toLogRange = __webpack_require__(8163);
lib.relinkPrivateKeys = __webpack_require__(1332);
var arrayModule = __webpack_require__(3627);
lib.isTypedArray = arrayModule.isTypedArray;
lib.isArrayOrTypedArray = arrayModule.isArrayOrTypedArray;
lib.isArray1D = arrayModule.isArray1D;
lib.ensureArray = arrayModule.ensureArray;
lib.concat = arrayModule.concat;
lib.maxRowLength = arrayModule.maxRowLength;
lib.minRowLength = arrayModule.minRowLength;
var modModule = __webpack_require__(4872);
lib.mod = modModule.mod;
lib.modHalf = modModule.modHalf;
var coerceModule = __webpack_require__(6554);
lib.valObjectMeta = coerceModule.valObjectMeta;
lib.coerce = coerceModule.coerce;
lib.coerce2 = coerceModule.coerce2;
lib.coerceFont = coerceModule.coerceFont;
lib.coercePattern = coerceModule.coercePattern;
lib.coerceHoverinfo = coerceModule.coerceHoverinfo;
lib.coerceSelectionMarkerOpacity = coerceModule.coerceSelectionMarkerOpacity;
lib.validate = coerceModule.validate;
var datesModule = __webpack_require__(1631);
lib.dateTime2ms = datesModule.dateTime2ms;
lib.isDateTime = datesModule.isDateTime;
lib.ms2DateTime = datesModule.ms2DateTime;
lib.ms2DateTimeLocal = datesModule.ms2DateTimeLocal;
lib.cleanDate = datesModule.cleanDate;
lib.isJSDate = datesModule.isJSDate;
lib.formatDate = datesModule.formatDate;
lib.incrementMonth = datesModule.incrementMonth;
lib.dateTick0 = datesModule.dateTick0;
lib.dfltRange = datesModule.dfltRange;
lib.findExactDates = datesModule.findExactDates;
lib.MIN_MS = datesModule.MIN_MS;
lib.MAX_MS = datesModule.MAX_MS;
var searchModule = __webpack_require__(5888);
lib.findBin = searchModule.findBin;
lib.sorterAsc = searchModule.sorterAsc;
lib.sorterDes = searchModule.sorterDes;
lib.distinctVals = searchModule.distinctVals;
lib.roundUp = searchModule.roundUp;
lib.sort = searchModule.sort;
lib.findIndexOfMin = searchModule.findIndexOfMin;
lib.sortObjectKeys = __webpack_require__(8607);
var statsModule = __webpack_require__(38);
lib.aggNums = statsModule.aggNums;
lib.len = statsModule.len;
lib.mean = statsModule.mean;
lib.median = statsModule.median;
lib.midRange = statsModule.midRange;
lib.variance = statsModule.variance;
lib.stdev = statsModule.stdev;
lib.interp = statsModule.interp;
var matrixModule = __webpack_require__(5657);
lib.init2dArray = matrixModule.init2dArray;
lib.transposeRagged = matrixModule.transposeRagged;
lib.dot = matrixModule.dot;
lib.translationMatrix = matrixModule.translationMatrix;
lib.rotationMatrix = matrixModule.rotationMatrix;
lib.rotationXYMatrix = matrixModule.rotationXYMatrix;
lib.apply3DTransform = matrixModule.apply3DTransform;
lib.apply2DTransform = matrixModule.apply2DTransform;
lib.apply2DTransform2 = matrixModule.apply2DTransform2;
lib.convertCssMatrix = matrixModule.convertCssMatrix;
lib.inverseTransformMatrix = matrixModule.inverseTransformMatrix;
var anglesModule = __webpack_require__(6348);
lib.deg2rad = anglesModule.deg2rad;
lib.rad2deg = anglesModule.rad2deg;
lib.angleDelta = anglesModule.angleDelta;
lib.angleDist = anglesModule.angleDist;
lib.isFullCircle = anglesModule.isFullCircle;
lib.isAngleInsideSector = anglesModule.isAngleInsideSector;
lib.isPtInsideSector = anglesModule.isPtInsideSector;
lib.pathArc = anglesModule.pathArc;
lib.pathSector = anglesModule.pathSector;
lib.pathAnnulus = anglesModule.pathAnnulus;
var anchorUtils = __webpack_require__(9863);
lib.isLeftAnchor = anchorUtils.isLeftAnchor;
lib.isCenterAnchor = anchorUtils.isCenterAnchor;
lib.isRightAnchor = anchorUtils.isRightAnchor;
lib.isTopAnchor = anchorUtils.isTopAnchor;
lib.isMiddleAnchor = anchorUtils.isMiddleAnchor;
lib.isBottomAnchor = anchorUtils.isBottomAnchor;
var geom2dModule = __webpack_require__(7642);
lib.segmentsIntersect = geom2dModule.segmentsIntersect;
lib.segmentDistance = geom2dModule.segmentDistance;
lib.getTextLocation = geom2dModule.getTextLocation;
lib.clearLocationCache = geom2dModule.clearLocationCache;
lib.getVisibleSegment = geom2dModule.getVisibleSegment;
lib.findPointOnPath = geom2dModule.findPointOnPath;
var extendModule = __webpack_require__(1426);
lib.extendFlat = extendModule.extendFlat;
lib.extendDeep = extendModule.extendDeep;
lib.extendDeepAll = extendModule.extendDeepAll;
lib.extendDeepNoArrays = extendModule.extendDeepNoArrays;
var loggersModule = __webpack_require__(7769);
lib.log = loggersModule.log;
lib.warn = loggersModule.warn;
lib.error = loggersModule.error;
var regexModule = __webpack_require__(587);
lib.counterRegex = regexModule.counter;
var throttleModule = __webpack_require__(9990);
lib.throttle = throttleModule.throttle;
lib.throttleDone = throttleModule.done;
lib.clearThrottle = throttleModule.clear;
var domModule = __webpack_require__(4401);
lib.getGraphDiv = domModule.getGraphDiv;
lib.isPlotDiv = domModule.isPlotDiv;
lib.removeElement = domModule.removeElement;
lib.addStyleRule = domModule.addStyleRule;
lib.addRelatedStyleRule = domModule.addRelatedStyleRule;
lib.deleteRelatedStyleRule = domModule.deleteRelatedStyleRule;
lib.getFullTransformMatrix = domModule.getFullTransformMatrix;
lib.getElementTransformMatrix = domModule.getElementTransformMatrix;
lib.getElementAndAncestors = domModule.getElementAndAncestors;
lib.equalDomRects = domModule.equalDomRects;
lib.clearResponsive = __webpack_require__(6367);
lib.preserveDrawingBuffer = __webpack_require__(5142);
lib.makeTraceGroups = __webpack_require__(7310);
lib._ = __webpack_require__(5867);
lib.notifier = __webpack_require__(5046);
lib.filterUnique = __webpack_require__(5744);
lib.filterVisible = __webpack_require__(6756);
lib.pushUnique = __webpack_require__(5138);
lib.increment = __webpack_require__(9240);
lib.cleanNumber = __webpack_require__(5218);
lib.ensureNumber = function ensureNumber(v) {
  if (!isNumeric(v)) return BADNUM;
  v = Number(v);
  return v > MAX_SAFE || v < MIN_SAFE ? BADNUM : v;
};

/**
 * Is v a valid array index? Accepts numeric strings as well as numbers.
 *
 * @param {any} v: the value to test
 * @param {Optional[integer]} len: the array length we are indexing
 *
 * @return {bool}: v is a valid array index
 */
lib.isIndex = function (v, len) {
  if (len !== undefined && v >= len) return false;
  return isNumeric(v) && v >= 0 && v % 1 === 0;
};
lib.noop = __webpack_require__(4213);
lib.identity = __webpack_require__(3389);

/**
 * create an array of length 'cnt' filled with 'v' at all indices
 *
 * @param {any} v
 * @param {number} cnt
 * @return {array}
 */
lib.repeat = function (v, cnt) {
  var out = new Array(cnt);
  for (var i = 0; i < cnt; i++) {
    out[i] = v;
  }
  return out;
};

/**
 * swap x and y of the same attribute in container cont
 * specify attr with a ? in place of x/y
 * you can also swap other things than x/y by providing part1 and part2
 */
lib.swapAttrs = function (cont, attrList, part1, part2) {
  if (!part1) part1 = 'x';
  if (!part2) part2 = 'y';
  for (var i = 0; i < attrList.length; i++) {
    var attr = attrList[i];
    var xp = lib.nestedProperty(cont, attr.replace('?', part1));
    var yp = lib.nestedProperty(cont, attr.replace('?', part2));
    var temp = xp.get();
    xp.set(yp.get());
    yp.set(temp);
  }
};

/**
 * SVG painter's algo worked around with reinsertion
 */
lib.raiseToTop = function raiseToTop(elem) {
  elem.parentNode.appendChild(elem);
};

/**
 * cancel a possibly pending transition; returned selection may be used by caller
 */
lib.cancelTransition = function (selection) {
  return selection.transition().duration(0);
};

// constrain - restrict a number v to be between v0 and v1
lib.constrain = function (v, v0, v1) {
  if (v0 > v1) return Math.max(v1, Math.min(v0, v));
  return Math.max(v0, Math.min(v1, v));
};

/**
 * do two bounding boxes from getBoundingClientRect,
 * ie {left,right,top,bottom,width,height}, overlap?
 * takes optional padding pixels
 */
lib.bBoxIntersect = function (a, b, pad) {
  pad = pad || 0;
  return a.left <= b.right + pad && b.left <= a.right + pad && a.top <= b.bottom + pad && b.top <= a.bottom + pad;
};

/*
 * simpleMap: alternative to Array.map that only
 * passes on the element and up to 2 extra args you
 * provide (but not the array index or the whole array)
 *
 * array: the array to map it to
 * func: the function to apply
 * x1, x2: optional extra args
 */
lib.simpleMap = function (array, func, x1, x2, opts) {
  var len = array.length;
  var out = new Array(len);
  for (var i = 0; i < len; i++) out[i] = func(array[i], x1, x2, opts);
  return out;
};

/**
 * Random string generator
 *
 * @param {object} existing
 *     pass in strings to avoid as keys with truthy values
 * @param {int} bits
 *     bits of information in the output string, default 24
 * @param {int} base
 *     base of string representation, default 16. Should be a power of 2.
 */
lib.randstr = function randstr(existing, bits, base, _recursion) {
  if (!base) base = 16;
  if (bits === undefined) bits = 24;
  if (bits <= 0) return '0';
  var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
  var res = '';
  var i, b, x;
  for (i = 2; digits === Infinity; i *= 2) {
    digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
  }
  var rem = digits - Math.floor(digits);
  for (i = 0; i < Math.floor(digits); i++) {
    x = Math.floor(Math.random() * base).toString(base);
    res = x + res;
  }
  if (rem) {
    b = Math.pow(base, rem);
    x = Math.floor(Math.random() * b).toString(base);
    res = x + res;
  }
  var parsed = parseInt(res, base);
  if (existing && existing[res] || parsed !== Infinity && parsed >= Math.pow(2, bits)) {
    if (_recursion > 10) {
      lib.warn('randstr failed uniqueness');
      return res;
    }
    return randstr(existing, bits, base, (_recursion || 0) + 1);
  } else return res;
};
lib.OptionControl = function (opt, optname) {
  /*
   * An environment to contain all option setters and
   * getters that collectively modify opts.
   *
   * You can call up opts from any function in new object
   * as this.optname || this.opt
   *
   * See FitOpts for example of usage
   */
  if (!opt) opt = {};
  if (!optname) optname = 'opt';
  var self = {};
  self.optionList = [];
  self._newoption = function (optObj) {
    optObj[optname] = opt;
    self[optObj.name] = optObj;
    self.optionList.push(optObj);
  };
  self['_' + optname] = opt;
  return self;
};

/**
 * lib.smooth: smooth arrayIn by convolving with
 * a hann window with given full width at half max
 * bounce the ends in, so the output has the same length as the input
 */
lib.smooth = function (arrayIn, FWHM) {
  FWHM = Math.round(FWHM) || 0; // only makes sense for integers
  if (FWHM < 2) return arrayIn;
  var alen = arrayIn.length;
  var alen2 = 2 * alen;
  var wlen = 2 * FWHM - 1;
  var w = new Array(wlen);
  var arrayOut = new Array(alen);
  var i;
  var j;
  var k;
  var v;

  // first make the window array
  for (i = 0; i < wlen; i++) {
    w[i] = (1 - Math.cos(Math.PI * (i + 1) / FWHM)) / (2 * FWHM);
  }

  // now do the convolution
  for (i = 0; i < alen; i++) {
    v = 0;
    for (j = 0; j < wlen; j++) {
      k = i + j + 1 - FWHM;

      // multibounce
      if (k < -alen) k -= alen2 * Math.round(k / alen2);else if (k >= alen2) k -= alen2 * Math.floor(k / alen2);

      // single bounce
      if (k < 0) k = -1 - k;else if (k >= alen) k = alen2 - 1 - k;
      v += arrayIn[k] * w[j];
    }
    arrayOut[i] = v;
  }
  return arrayOut;
};

/**
 * syncOrAsync: run a sequence of functions synchronously
 * as long as its returns are not promises (ie have no .then)
 * includes one argument arg to send to all functions...
 * this is mainly just to prevent us having to make wrapper functions
 * when the only purpose of the wrapper is to reference gd
 * and a final step to be executed at the end
 * TODO: if there's an error and everything is sync,
 * this doesn't happen yet because we want to make sure
 * that it gets reported
 */
lib.syncOrAsync = function (sequence, arg, finalStep) {
  var ret, fni;
  function continueAsync() {
    return lib.syncOrAsync(sequence, arg, finalStep);
  }
  while (sequence.length) {
    fni = sequence.splice(0, 1)[0];
    ret = fni(arg);
    if (ret && ret.then) {
      return ret.then(continueAsync);
    }
  }
  return finalStep && finalStep(arg);
};

/**
 * Helper to strip trailing slash, from
 * http://stackoverflow.com/questions/6680825/return-string-without-trailing-slash
 */
lib.stripTrailingSlash = function (str) {
  if (str.substr(-1) === '/') return str.substr(0, str.length - 1);
  return str;
};
lib.noneOrAll = function (containerIn, containerOut, attrList) {
  /**
   * some attributes come together, so if you have one of them
   * in the input, you should copy the default values of the others
   * to the input as well.
   */
  if (!containerIn) return;
  var hasAny = false;
  var hasAll = true;
  var i;
  var val;
  for (i = 0; i < attrList.length; i++) {
    val = containerIn[attrList[i]];
    if (val !== undefined && val !== null) hasAny = true;else hasAll = false;
  }
  if (hasAny && !hasAll) {
    for (i = 0; i < attrList.length; i++) {
      containerIn[attrList[i]] = containerOut[attrList[i]];
    }
  }
};

/** merges calcdata field (given by cdAttr) with traceAttr values
 *
 * N.B. Loop over minimum of cd.length and traceAttr.length
 * i.e. it does not try to fill in beyond traceAttr.length-1
 *
 * @param {array} traceAttr : trace attribute
 * @param {object} cd : calcdata trace
 * @param {string} cdAttr : calcdata key
 */
lib.mergeArray = function (traceAttr, cd, cdAttr, fn) {
  var hasFn = typeof fn === 'function';
  if (lib.isArrayOrTypedArray(traceAttr)) {
    var imax = Math.min(traceAttr.length, cd.length);
    for (var i = 0; i < imax; i++) {
      var v = traceAttr[i];
      cd[i][cdAttr] = hasFn ? fn(v) : v;
    }
  }
};

// cast numbers to positive numbers, returns 0 if not greater than 0
lib.mergeArrayCastPositive = function (traceAttr, cd, cdAttr) {
  return lib.mergeArray(traceAttr, cd, cdAttr, function (v) {
    var w = +v;
    return !isFinite(w) ? 0 : w > 0 ? w : 0;
  });
};

/** fills calcdata field (given by cdAttr) with traceAttr values
 *  or function of traceAttr values (e.g. some fallback)
 *
 * N.B. Loops over all cd items.
 *
 * @param {array} traceAttr : trace attribute
 * @param {object} cd : calcdata trace
 * @param {string} cdAttr : calcdata key
 * @param {function} [fn] : optional function to apply to each array item
 */
lib.fillArray = function (traceAttr, cd, cdAttr, fn) {
  fn = fn || lib.identity;
  if (lib.isArrayOrTypedArray(traceAttr)) {
    for (var i = 0; i < cd.length; i++) {
      cd[i][cdAttr] = fn(traceAttr[i]);
    }
  }
};

/** Handler for trace-wide vs per-point options
 *
 * @param {object} trace : (full) trace object
 * @param {number} ptNumber : index of the point in question
 * @param {string} astr : attribute string
 * @param {function} [fn] : optional function to apply to each array item
 *
 * @return {any}
 */
lib.castOption = function (trace, ptNumber, astr, fn) {
  fn = fn || lib.identity;
  var val = lib.nestedProperty(trace, astr).get();
  if (lib.isArrayOrTypedArray(val)) {
    if (Array.isArray(ptNumber) && lib.isArrayOrTypedArray(val[ptNumber[0]])) {
      return fn(val[ptNumber[0]][ptNumber[1]]);
    } else {
      return fn(val[ptNumber]);
    }
  } else {
    return val;
  }
};

/** Extract option from calcdata item, correctly falling back to
 *  trace value if not found.
 *
 *  @param {object} calcPt : calcdata[i][j] item
 *  @param {object} trace : (full) trace object
 *  @param {string} calcKey : calcdata key
 *  @param {string} traceKey : aka trace attribute string
 *  @return {any}
 */
lib.extractOption = function (calcPt, trace, calcKey, traceKey) {
  if (calcKey in calcPt) return calcPt[calcKey];

  // fallback to trace value,
  //   must check if value isn't itself an array
  //   which means the trace attribute has a corresponding
  //   calcdata key, but its value is falsy
  var traceVal = lib.nestedProperty(trace, traceKey).get();
  if (!Array.isArray(traceVal)) return traceVal;
};
function makePtIndex2PtNumber(indexToPoints) {
  var ptIndex2ptNumber = {};
  for (var k in indexToPoints) {
    var pts = indexToPoints[k];
    for (var j = 0; j < pts.length; j++) {
      ptIndex2ptNumber[pts[j]] = +k;
    }
  }
  return ptIndex2ptNumber;
}

/** Tag selected calcdata items
 *
 * N.B. note that point 'index' corresponds to input data array index
 *  whereas 'number' is its post-transform version.
 *
 * @param {array} calcTrace
 * @param {object} trace
 *  - selectedpoints {array}
 *  - _indexToPoints {object}
 * @param {ptNumber2cdIndex} ptNumber2cdIndex (optional)
 *  optional map object for trace types that do not have 1-to-1 point number to
 *  calcdata item index correspondence (e.g. histogram)
 */
lib.tagSelected = function (calcTrace, trace, ptNumber2cdIndex) {
  var selectedpoints = trace.selectedpoints;
  var indexToPoints = trace._indexToPoints;
  var ptIndex2ptNumber;

  // make pt index-to-number map object, which takes care of transformed traces
  if (indexToPoints) {
    ptIndex2ptNumber = makePtIndex2PtNumber(indexToPoints);
  }
  function isCdIndexValid(v) {
    return v !== undefined && v < calcTrace.length;
  }
  for (var i = 0; i < selectedpoints.length; i++) {
    var ptIndex = selectedpoints[i];
    if (lib.isIndex(ptIndex) || lib.isArrayOrTypedArray(ptIndex) && lib.isIndex(ptIndex[0]) && lib.isIndex(ptIndex[1])) {
      var ptNumber = ptIndex2ptNumber ? ptIndex2ptNumber[ptIndex] : ptIndex;
      var cdIndex = ptNumber2cdIndex ? ptNumber2cdIndex[ptNumber] : ptNumber;
      if (isCdIndexValid(cdIndex)) {
        calcTrace[cdIndex].selected = 1;
      }
    }
  }
};
lib.selIndices2selPoints = function (trace) {
  var selectedpoints = trace.selectedpoints;
  var indexToPoints = trace._indexToPoints;
  if (indexToPoints) {
    var ptIndex2ptNumber = makePtIndex2PtNumber(indexToPoints);
    var out = [];
    for (var i = 0; i < selectedpoints.length; i++) {
      var ptIndex = selectedpoints[i];
      if (lib.isIndex(ptIndex)) {
        var ptNumber = ptIndex2ptNumber[ptIndex];
        if (lib.isIndex(ptNumber)) {
          out.push(ptNumber);
        }
      }
    }
    return out;
  } else {
    return selectedpoints;
  }
};

/** Returns target as set by 'target' transform attribute
 *
 * @param {object} trace : full trace object
 * @param {object} transformOpts : transform option object
 *  - target (string} :
 *      either an attribute string referencing an array in the trace object, or
 *      a set array.
 *
 * @return {array or false} : the target array (NOT a copy!!) or false if invalid
 */
lib.getTargetArray = function (trace, transformOpts) {
  var target = transformOpts.target;
  if (typeof target === 'string' && target) {
    var array = lib.nestedProperty(trace, target).get();
    return Array.isArray(array) ? array : false;
  } else if (Array.isArray(target)) {
    return target;
  }
  return false;
};

/**
 * modified version of jQuery's extend to strip out private objs and functions,
 * and cut arrays down to first <arraylen> or 1 elements
 * because extend-like algorithms are hella slow
 * obj2 is assumed to already be clean of these things (including no arrays)
 */
function minExtend(obj1, obj2, opt) {
  var objOut = {};
  if (typeof obj2 !== 'object') obj2 = {};
  var arrayLen = opt === 'pieLike' ? -1 : 3;
  var keys = Object.keys(obj1);
  var i, k, v;
  for (i = 0; i < keys.length; i++) {
    k = keys[i];
    v = obj1[k];
    if (k.charAt(0) === '_' || typeof v === 'function') continue;else if (k === 'module') objOut[k] = v;else if (Array.isArray(v)) {
      if (k === 'colorscale' || arrayLen === -1) {
        objOut[k] = v.slice();
      } else {
        objOut[k] = v.slice(0, arrayLen);
      }
    } else if (lib.isTypedArray(v)) {
      if (arrayLen === -1) {
        objOut[k] = v.subarray();
      } else {
        objOut[k] = v.subarray(0, arrayLen);
      }
    } else if (v && typeof v === 'object') objOut[k] = minExtend(obj1[k], obj2[k], opt);else objOut[k] = v;
  }
  keys = Object.keys(obj2);
  for (i = 0; i < keys.length; i++) {
    k = keys[i];
    v = obj2[k];
    if (typeof v !== 'object' || !(k in objOut) || typeof objOut[k] !== 'object') {
      objOut[k] = v;
    }
  }
  return objOut;
}
lib.minExtend = minExtend;
lib.titleCase = function (s) {
  return s.charAt(0).toUpperCase() + s.substr(1);
};
lib.containsAny = function (s, fragments) {
  for (var i = 0; i < fragments.length; i++) {
    if (s.indexOf(fragments[i]) !== -1) return true;
  }
  return false;
};
lib.isIE = function () {
  return typeof window.navigator.msSaveBlob !== 'undefined';
};
var IS_SAFARI_REGEX = /Version\/[\d\.]+.*Safari/;
lib.isSafari = function () {
  return IS_SAFARI_REGEX.test(window.navigator.userAgent);
};
var IS_IOS_REGEX = /iPad|iPhone|iPod/;
lib.isIOS = function () {
  return IS_IOS_REGEX.test(window.navigator.userAgent);
};
var FIREFOX_VERSION_REGEX = /Firefox\/(\d+)\.\d+/;
lib.getFirefoxVersion = function () {
  var match = FIREFOX_VERSION_REGEX.exec(window.navigator.userAgent);
  if (match && match.length === 2) {
    var versionInt = parseInt(match[1]);
    if (!isNaN(versionInt)) {
      return versionInt;
    }
  }
  return null;
};
lib.isD3Selection = function (obj) {
  return obj instanceof d3.selection;
};

/**
 * Append element to DOM only if not present.
 *
 * @param {d3 selection} parent : parent selection of the element in question
 * @param {string} nodeType : node type of element to append
 * @param {string} className (optional) : class name of element in question
 * @param {fn} enterFn (optional) : optional fn applied to entering elements only
 * @return {d3 selection} selection of new layer
 *
 * Previously, we were using the following pattern:
 *
 * ```
 * var sel = parent.selectAll('.' + className)
 *     .data([0]);
 *
 * sel.enter().append(nodeType)
 *     .classed(className, true);
 *
 * return sel;
 * ```
 *
 * in numerous places in our codebase to achieve the same behavior.
 *
 * The logic below performs much better, mostly as we are using
 * `.select` instead `.selectAll` that is `querySelector` instead of
 * `querySelectorAll`.
 *
 */
lib.ensureSingle = function (parent, nodeType, className, enterFn) {
  var sel = parent.select(nodeType + (className ? '.' + className : ''));
  if (sel.size()) return sel;
  var layer = parent.append(nodeType);
  if (className) layer.classed(className, true);
  if (enterFn) layer.call(enterFn);
  return layer;
};

/**
 * Same as Lib.ensureSingle, but using id as selector.
 * This version is mostly used for clipPath nodes.
 *
 * @param {d3 selection} parent : parent selection of the element in question
 * @param {string} nodeType : node type of element to append
 * @param {string} id : id of element in question
 * @param {fn} enterFn (optional) : optional fn applied to entering elements only
 * @return {d3 selection} selection of new layer
 */
lib.ensureSingleById = function (parent, nodeType, id, enterFn) {
  var sel = parent.select(nodeType + '#' + id);
  if (sel.size()) return sel;
  var layer = parent.append(nodeType).attr('id', id);
  if (enterFn) layer.call(enterFn);
  return layer;
};

/**
 * Converts a string path to an object.
 *
 * When given a string containing an array element, it will create a `null`
 * filled array of the given size.
 *
 * @example
 * lib.objectFromPath('nested.test[2].path', 'value');
 * // returns { nested: { test: [null, null, { path: 'value' }]}
 *
 * @param   {string}    path to nested value
 * @param   {*}         any value to be set
 *
 * @return {Object} the constructed object with a full nested path
 */
lib.objectFromPath = function (path, value) {
  var keys = path.split('.');
  var tmpObj;
  var obj = tmpObj = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var el = null;
    var parts = keys[i].match(/(.*)\[([0-9]+)\]/);
    if (parts) {
      key = parts[1];
      el = parts[2];
      tmpObj = tmpObj[key] = [];
      if (i === keys.length - 1) {
        tmpObj[el] = value;
      } else {
        tmpObj[el] = {};
      }
      tmpObj = tmpObj[el];
    } else {
      if (i === keys.length - 1) {
        tmpObj[key] = value;
      } else {
        tmpObj[key] = {};
      }
      tmpObj = tmpObj[key];
    }
  }
  return obj;
};

/**
 * Iterate through an object in-place, converting dotted properties to objects.
 *
 * Examples:
 *
 *   lib.expandObjectPaths({'nested.test.path': 'value'});
 *     => { nested: { test: {path: 'value'}}}
 *
 * It also handles array notation, e.g.:
 *
 *   lib.expandObjectPaths({'foo[1].bar': 'value'});
 *     => { foo: [null, {bar: value}] }
 *
 * It handles merges the results when two properties are specified in parallel:
 *
 *   lib.expandObjectPaths({'foo[1].bar': 10, 'foo[0].bar': 20});
 *     => { foo: [{bar: 10}, {bar: 20}] }
 *
 * It does NOT, however, merge multiple multiply-nested arrays::
 *
 *   lib.expandObjectPaths({'marker[1].range[1]': 5, 'marker[1].range[0]': 4})
 *     => { marker: [null, {range: 4}] }
 */

// Store this to avoid recompiling regex on *every* prop since this may happen many
// many times for animations. Could maybe be inside the function. Not sure about
// scoping vs. recompilation tradeoff, but at least it's not just inlining it into
// the inner loop.
var dottedPropertyRegex = /^([^\[\.]+)\.(.+)?/;
var indexedPropertyRegex = /^([^\.]+)\[([0-9]+)\](\.)?(.+)?/;
function notValid(prop) {
  // guard against polluting __proto__ and other internals getters and setters
  return prop.slice(0, 2) === '__';
}
lib.expandObjectPaths = function (data) {
  var match, key, prop, datum, idx, dest, trailingPath;
  if (typeof data === 'object' && !Array.isArray(data)) {
    for (key in data) {
      if (data.hasOwnProperty(key)) {
        if (match = key.match(dottedPropertyRegex)) {
          datum = data[key];
          prop = match[1];
          if (notValid(prop)) continue;
          delete data[key];
          data[prop] = lib.extendDeepNoArrays(data[prop] || {}, lib.objectFromPath(key, lib.expandObjectPaths(datum))[prop]);
        } else if (match = key.match(indexedPropertyRegex)) {
          datum = data[key];
          prop = match[1];
          if (notValid(prop)) continue;
          idx = parseInt(match[2]);
          delete data[key];
          data[prop] = data[prop] || [];
          if (match[3] === '.') {
            // This is the case where theere are subsequent properties into which
            // we must recurse, e.g. transforms[0].value
            trailingPath = match[4];
            dest = data[prop][idx] = data[prop][idx] || {};

            // NB: Extend deep no arrays prevents this from working on multiple
            // nested properties in the same object, e.g.
            //
            // {
            //   foo[0].bar[1].range
            //   foo[0].bar[0].range
            // }
            //
            // In this case, the extendDeepNoArrays will overwrite one array with
            // the other, so that both properties *will not* be present in the
            // result. Fixing this would require a more intelligent tracking
            // of changes and merging than extendDeepNoArrays currently accomplishes.
            lib.extendDeepNoArrays(dest, lib.objectFromPath(trailingPath, lib.expandObjectPaths(datum)));
          } else {
            // This is the case where this property is the end of the line,
            // e.g. xaxis.range[0]

            if (notValid(prop)) continue;
            data[prop][idx] = lib.expandObjectPaths(datum);
          }
        } else {
          if (notValid(key)) continue;
          data[key] = lib.expandObjectPaths(data[key]);
        }
      }
    }
  }
  return data;
};

/**
 * Converts value to string separated by the provided separators.
 *
 * @example
 * lib.numSeparate(2016, '.,');
 * // returns '2016'
 *
 * @example
 * lib.numSeparate(3000, '.,', true);
 * // returns '3,000'
 *
 * @example
 * lib.numSeparate(1234.56, '|,')
 * // returns '1,234|56'
 *
 * @param   {string|number} value       the value to be converted
 * @param   {string}    separators  string of decimal, then thousands separators
 * @param   {boolean}    separatethousands  boolean, 4-digit integers are separated if true
 *
 * @return  {string}    the value that has been separated
 */
lib.numSeparate = function (value, separators, separatethousands) {
  if (!separatethousands) separatethousands = false;
  if (typeof separators !== 'string' || separators.length === 0) {
    throw new Error('Separator string required for formatting!');
  }
  if (typeof value === 'number') {
    value = String(value);
  }
  var thousandsRe = /(\d+)(\d{3})/;
  var decimalSep = separators.charAt(0);
  var thouSep = separators.charAt(1);
  var x = value.split('.');
  var x1 = x[0];
  var x2 = x.length > 1 ? decimalSep + x[1] : '';

  // Years are ignored for thousands separators
  if (thouSep && (x.length > 1 || x1.length > 4 || separatethousands)) {
    while (thousandsRe.test(x1)) {
      x1 = x1.replace(thousandsRe, '$1' + thouSep + '$2');
    }
  }
  return x1 + x2;
};
lib.TEMPLATE_STRING_REGEX = /%{([^\s%{}:]*)([:|\|][^}]*)?}/g;
var SIMPLE_PROPERTY_REGEX = /^\w*$/;

/**
 * Substitute values from an object into a string
 *
 * Examples:
 *  Lib.templateString('name: %{trace}', {trace: 'asdf'}) --> 'name: asdf'
 *  Lib.templateString('name: %{trace[0].name}', {trace: [{name: 'asdf'}]}) --> 'name: asdf'
 *
 * @param {string}  input string containing %{...} template strings
 * @param {obj}     data object containing substitution values
 *
 * @return {string} templated string
 */
lib.templateString = function (string, obj) {
  // Not all that useful, but cache nestedProperty instantiation
  // just in case it speeds things up *slightly*:
  var getterCache = {};
  return string.replace(lib.TEMPLATE_STRING_REGEX, function (dummy, key) {
    var v;
    if (SIMPLE_PROPERTY_REGEX.test(key)) {
      v = obj[key];
    } else {
      getterCache[key] = getterCache[key] || lib.nestedProperty(obj, key).get;
      v = getterCache[key]();
    }
    return lib.isValidTextValue(v) ? v : '';
  });
};
var hovertemplateWarnings = {
  max: 10,
  count: 0,
  name: 'hovertemplate'
};
lib.hovertemplateString = function () {
  return templateFormatString.apply(hovertemplateWarnings, arguments);
};
var texttemplateWarnings = {
  max: 10,
  count: 0,
  name: 'texttemplate'
};
lib.texttemplateString = function () {
  return templateFormatString.apply(texttemplateWarnings, arguments);
};

// Regex for parsing multiplication and division operations applied to a template key
// Used for shape.label.texttemplate
// Matches a key name (non-whitespace characters), followed by a * or / character, followed by a number
// For example, the following strings are matched: `x0*2`, `slope/1.60934`, `y1*2.54`
var MULT_DIV_REGEX = /^(\S+)([\*\/])(-?\d+(\.\d+)?)$/;
function multDivParser(inputStr) {
  var match = inputStr.match(MULT_DIV_REGEX);
  if (match) return {
    key: match[1],
    op: match[2],
    number: Number(match[3])
  };
  return {
    key: inputStr,
    op: null,
    number: null
  };
}
var texttemplateWarningsForShapes = {
  max: 10,
  count: 0,
  name: 'texttemplate',
  parseMultDiv: true
};
lib.texttemplateStringForShapes = function () {
  return templateFormatString.apply(texttemplateWarningsForShapes, arguments);
};
var TEMPLATE_STRING_FORMAT_SEPARATOR = /^[:|\|]/;
/**
 * Substitute values from an object into a string and optionally formats them using d3-format,
 * or fallback to associated labels.
 *
 * Examples:
 *  Lib.hovertemplateString('name: %{trace}', {trace: 'asdf'}) --> 'name: asdf'
 *  Lib.hovertemplateString('name: %{trace[0].name}', {trace: [{name: 'asdf'}]}) --> 'name: asdf'
 *  Lib.hovertemplateString('price: %{y:$.2f}', {y: 1}) --> 'price: $1.00'
 *
 * @param {string}  input string containing %{...:...} template strings
 * @param {obj}     data object containing fallback text when no formatting is specified, ex.: {yLabel: 'formattedYValue'}
 * @param {obj}     d3 locale
 * @param {obj}     data objects containing substitution values
 *
 * @return {string} templated string
 */
function templateFormatString(string, labels, d3locale) {
  var opts = this;
  var args = arguments;
  if (!labels) labels = {};
  // Not all that useful, but cache nestedProperty instantiation
  // just in case it speeds things up *slightly*:
  var getterCache = {};
  return string.replace(lib.TEMPLATE_STRING_REGEX, function (match, rawKey, format) {
    var isOther = rawKey === 'xother' || rawKey === 'yother';
    var isSpaceOther = rawKey === '_xother' || rawKey === '_yother';
    var isSpaceOtherSpace = rawKey === '_xother_' || rawKey === '_yother_';
    var isOtherSpace = rawKey === 'xother_' || rawKey === 'yother_';
    var hasOther = isOther || isSpaceOther || isOtherSpace || isSpaceOtherSpace;
    var key = rawKey;
    if (isSpaceOther || isSpaceOtherSpace) key = key.substring(1);
    if (isOtherSpace || isSpaceOtherSpace) key = key.substring(0, key.length - 1);

    // Shape labels support * and / operators in template string
    // Parse these if the parseMultDiv param is set to true
    var parsedOp = null;
    var parsedNumber = null;
    if (opts.parseMultDiv) {
      var _match = multDivParser(key);
      key = _match.key;
      parsedOp = _match.op;
      parsedNumber = _match.number;
    }
    var value;
    if (hasOther) {
      value = labels[key];
      if (value === undefined) return '';
    } else {
      var obj, i;
      for (i = 3; i < args.length; i++) {
        obj = args[i];
        if (!obj) continue;
        if (obj.hasOwnProperty(key)) {
          value = obj[key];
          break;
        }
        if (!SIMPLE_PROPERTY_REGEX.test(key)) {
          value = lib.nestedProperty(obj, key).get();
          value = getterCache[key] || lib.nestedProperty(obj, key).get();
          if (value) getterCache[key] = value;
        }
        if (value !== undefined) break;
      }
    }

    // Apply mult/div operation (if applicable)
    if (value !== undefined) {
      if (parsedOp === '*') value *= parsedNumber;
      if (parsedOp === '/') value /= parsedNumber;
    }
    if (value === undefined && opts) {
      if (opts.count < opts.max) {
        lib.warn('Variable \'' + key + '\' in ' + opts.name + ' could not be found!');
        value = match;
      }
      if (opts.count === opts.max) {
        lib.warn('Too many ' + opts.name + ' warnings - additional warnings will be suppressed');
      }
      opts.count++;
      return match;
    }
    if (format) {
      var fmt;
      if (format[0] === ':') {
        fmt = d3locale ? d3locale.numberFormat : lib.numberFormat;
        value = fmt(format.replace(TEMPLATE_STRING_FORMAT_SEPARATOR, ''))(value);
      }
      if (format[0] === '|') {
        fmt = d3locale ? d3locale.timeFormat : utcFormat;
        var ms = lib.dateTime2ms(value);
        value = lib.formatDate(ms, format.replace(TEMPLATE_STRING_FORMAT_SEPARATOR, ''), false, fmt);
      }
    } else {
      var keyLabel = key + 'Label';
      if (labels.hasOwnProperty(keyLabel)) value = labels[keyLabel];
    }
    if (hasOther) {
      value = '(' + value + ')';
      if (isSpaceOther || isSpaceOtherSpace) value = ' ' + value;
      if (isOtherSpace || isSpaceOtherSpace) value = value + ' ';
    }
    return value;
  });
}

/*
 * alphanumeric string sort, tailored for subplot IDs like scene2, scene10, x10y13 etc
 */
var char0 = 48;
var char9 = 57;
lib.subplotSort = function (a, b) {
  var l = Math.min(a.length, b.length) + 1;
  var numA = 0;
  var numB = 0;
  for (var i = 0; i < l; i++) {
    var charA = a.charCodeAt(i) || 0;
    var charB = b.charCodeAt(i) || 0;
    var isNumA = charA >= char0 && charA <= char9;
    var isNumB = charB >= char0 && charB <= char9;
    if (isNumA) numA = 10 * numA + charA - char0;
    if (isNumB) numB = 10 * numB + charB - char0;
    if (!isNumA || !isNumB) {
      if (numA !== numB) return numA - numB;
      if (charA !== charB) return charA - charB;
    }
  }
  return numB - numA;
};

// repeatable pseudorandom generator
var randSeed = 2000000000;
lib.seedPseudoRandom = function () {
  randSeed = 2000000000;
};
lib.pseudoRandom = function () {
  var lastVal = randSeed;
  randSeed = (69069 * randSeed + 1) % 4294967296;
  // don't let consecutive vals be too close together
  // gets away from really trying to be random, in favor of better local uniformity
  if (Math.abs(randSeed - lastVal) < 429496729) return lib.pseudoRandom();
  return randSeed / 4294967296;
};

/** Fill hover 'pointData' container with 'correct' hover text value
 *
 * - If trace hoverinfo contains a 'text' flag and hovertext is not set,
 *   the text elements will be seen in the hover labels.
 *
 * - If trace hoverinfo contains a 'text' flag and hovertext is set,
 *   hovertext takes precedence over text
 *   i.e. the hoverinfo elements will be seen in the hover labels
 *
 *  @param {object} calcPt
 *  @param {object} trace
 *  @param {object || array} contOut (mutated here)
 */
lib.fillText = function (calcPt, trace, contOut) {
  var fill = Array.isArray(contOut) ? function (v) {
    contOut.push(v);
  } : function (v) {
    contOut.text = v;
  };
  var htx = lib.extractOption(calcPt, trace, 'htx', 'hovertext');
  if (lib.isValidTextValue(htx)) return fill(htx);
  var tx = lib.extractOption(calcPt, trace, 'tx', 'text');
  if (lib.isValidTextValue(tx)) return fill(tx);
};

// accept all truthy values and 0 (which gets cast to '0' in the hover labels)
lib.isValidTextValue = function (v) {
  return v || v === 0;
};

/**
 * @param {number} ratio
 * @param {number} n (number of decimal places)
 */
lib.formatPercent = function (ratio, n) {
  n = n || 0;
  var str = (Math.round(100 * ratio * Math.pow(10, n)) * Math.pow(0.1, n)).toFixed(n) + '%';
  for (var i = 0; i < n; i++) {
    if (str.indexOf('.') !== -1) {
      str = str.replace('0%', '%');
      str = str.replace('.%', '%');
    }
  }
  return str;
};
lib.isHidden = function (gd) {
  var display = window.getComputedStyle(gd).display;
  return !display || display === 'none';
};
lib.strTranslate = function (x, y) {
  return x || y ? 'translate(' + x + ',' + y + ')' : '';
};
lib.strRotate = function (a) {
  return a ? 'rotate(' + a + ')' : '';
};
lib.strScale = function (s) {
  return s !== 1 ? 'scale(' + s + ')' : '';
};

/** Return transform text for bar bar-like rectangles and pie-like slices
 *  @param {object} transform
 *  - targetX: desired position on the x-axis
 *  - targetY: desired position on the y-axis
 *  - textX: text middle position on the x-axis
 *  - textY: text middle position on the y-axis
 *  - anchorX: (optional) text anchor position on the x-axis (computed from textX), zero for middle anchor
 *  - anchorY: (optional) text anchor position on the y-axis (computed from textY), zero for middle anchor
 *  - scale: (optional) scale applied after translate
 *  - rotate: (optional) rotation applied after scale
 *  - noCenter: when defined no extra arguments needed in rotation
 */
lib.getTextTransform = function (transform) {
  var noCenter = transform.noCenter;
  var textX = transform.textX;
  var textY = transform.textY;
  var targetX = transform.targetX;
  var targetY = transform.targetY;
  var anchorX = transform.anchorX || 0;
  var anchorY = transform.anchorY || 0;
  var rotate = transform.rotate;
  var scale = transform.scale;
  if (!scale) scale = 0;else if (scale > 1) scale = 1;
  return lib.strTranslate(targetX - scale * (textX + anchorX), targetY - scale * (textY + anchorY)) + lib.strScale(scale) + (rotate ? 'rotate(' + rotate + (noCenter ? '' : ' ' + textX + ' ' + textY) + ')' : '');
};
lib.setTransormAndDisplay = function (s, transform) {
  s.attr('transform', lib.getTextTransform(transform));
  s.style('display', transform.scale ? null : 'none');
};
lib.ensureUniformFontSize = function (gd, baseFont) {
  var out = lib.extendFlat({}, baseFont);
  out.size = Math.max(baseFont.size, gd._fullLayout.uniformtext.minsize || 0);
  return out;
};

/**
 * provide a human-readable list e.g. "A, B, C and D" with an ending separator
 *
 * @param {array} arr : the array to join
 * @param {string} mainSeparator : main separator
 * @param {string} lastSeparator : last separator
 *
 * @return {string} : joined list
 */
lib.join2 = function (arr, mainSeparator, lastSeparator) {
  var len = arr.length;
  if (len > 1) {
    return arr.slice(0, -1).join(mainSeparator) + lastSeparator + arr[len - 1];
  }
  return arr.join(mainSeparator);
};
lib.bigFont = function (size) {
  return Math.round(1.2 * size);
};
var firefoxVersion = lib.getFirefoxVersion();
// see https://bugzilla.mozilla.org/show_bug.cgi?id=1684973
var isProblematicFirefox = firefoxVersion !== null && firefoxVersion < 86;

/**
 * Return the mouse position from the last event registered by D3.
 * @returns An array with two numbers, representing the x and y coordinates of the mouse pointer
 *   at the event relative to the targeted node.
 */
lib.getPositionFromD3Event = function () {
  if (isProblematicFirefox) {
    // layerX and layerY are non-standard, so we only fallback to them when we have to:
    return [d3.event.layerX, d3.event.layerY];
  } else {
    return [d3.event.offsetX, d3.event.offsetY];
  }
};

/***/ }),

/***/ 1965:
/***/ (function(module) {

"use strict";


// more info: http://stackoverflow.com/questions/18531624/isplainobject-thing
module.exports = function isPlainObject(obj) {
  // We need to be a little less strict in the `imagetest` container because
  // of how async image requests are handled.
  //
  // N.B. isPlainObject(new Constructor()) will return true in `imagetest`
  if (window && window.process && window.process.versions) {
    return Object.prototype.toString.call(obj) === '[object Object]';
  }
  return Object.prototype.toString.call(obj) === '[object Object]' && Object.getPrototypeOf(obj).hasOwnProperty('hasOwnProperty');
};

/***/ }),

/***/ 6636:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var nestedProperty = __webpack_require__(5487);
var SIMPLE_PROPERTY_REGEX = /^\w*$/;

// bitmask for deciding what's updated. Sometimes the name needs to be updated,
// sometimes the value needs to be updated, and sometimes both do. This is just
// a simple way to track what's updated such that it's a simple OR operation to
// assimilate new updates.
//
// The only exception is the UNSET bit that tracks when we need to explicitly
// unset and remove the property. This concrn arises because of the special
// way in which nestedProperty handles null/undefined. When you specify `null`,
// it prunes any unused items in the tree. I ran into some issues with it getting
// null vs undefined confused, so UNSET is just a bit that forces the property
// update to send `null`, removing the property explicitly rather than setting
// it to undefined.
var NONE = 0;
var NAME = 1;
var VALUE = 2;
var BOTH = 3;
var UNSET = 4;
module.exports = function keyedContainer(baseObj, path, keyName, valueName) {
  keyName = keyName || 'name';
  valueName = valueName || 'value';
  var i, arr, baseProp;
  var changeTypes = {};
  if (path && path.length) {
    baseProp = nestedProperty(baseObj, path);
    arr = baseProp.get();
  } else {
    arr = baseObj;
  }
  path = path || '';

  // Construct an index:
  var indexLookup = {};
  if (arr) {
    for (i = 0; i < arr.length; i++) {
      indexLookup[arr[i][keyName]] = i;
    }
  }
  var isSimpleValueProp = SIMPLE_PROPERTY_REGEX.test(valueName);
  var obj = {
    set: function (name, value) {
      var changeType = value === null ? UNSET : NONE;

      // create the base array if necessary
      if (!arr) {
        if (!baseProp || changeType === UNSET) return;
        arr = [];
        baseProp.set(arr);
      }
      var idx = indexLookup[name];
      if (idx === undefined) {
        if (changeType === UNSET) return;
        changeType = changeType | BOTH;
        idx = arr.length;
        indexLookup[name] = idx;
      } else if (value !== (isSimpleValueProp ? arr[idx][valueName] : nestedProperty(arr[idx], valueName).get())) {
        changeType = changeType | VALUE;
      }
      var newValue = arr[idx] = arr[idx] || {};
      newValue[keyName] = name;
      if (isSimpleValueProp) {
        newValue[valueName] = value;
      } else {
        nestedProperty(newValue, valueName).set(value);
      }

      // If it's not an unset, force that bit to be unset. This is all related to the fact
      // that undefined and null are a bit specially implemented in nestedProperties.
      if (value !== null) {
        changeType = changeType & ~UNSET;
      }
      changeTypes[idx] = changeTypes[idx] | changeType;
      return obj;
    },
    get: function (name) {
      if (!arr) return;
      var idx = indexLookup[name];
      if (idx === undefined) {
        return undefined;
      } else if (isSimpleValueProp) {
        return arr[idx][valueName];
      } else {
        return nestedProperty(arr[idx], valueName).get();
      }
    },
    rename: function (name, newName) {
      var idx = indexLookup[name];
      if (idx === undefined) return obj;
      changeTypes[idx] = changeTypes[idx] | NAME;
      indexLookup[newName] = idx;
      delete indexLookup[name];
      arr[idx][keyName] = newName;
      return obj;
    },
    remove: function (name) {
      var idx = indexLookup[name];
      if (idx === undefined) return obj;
      var object = arr[idx];
      if (Object.keys(object).length > 2) {
        // This object contains more than just the key/value, so unset
        // the value without modifying the entry otherwise:
        changeTypes[idx] = changeTypes[idx] | VALUE;
        return obj.set(name, null);
      }
      if (isSimpleValueProp) {
        for (i = idx; i < arr.length; i++) {
          changeTypes[i] = changeTypes[i] | BOTH;
        }
        for (i = idx; i < arr.length; i++) {
          indexLookup[arr[i][keyName]]--;
        }
        arr.splice(idx, 1);
        delete indexLookup[name];
      } else {
        // Perform this update *strictly* so we can check whether the result's
        // been pruned. If so, it's a removal. If not, it's a value unset only.
        nestedProperty(object, valueName).set(null);

        // Now check if the top level nested property has any keys left. If so,
        // the object still has values so we only want to unset the key. If not,
        // the entire object can be removed since there's no other data.
        // var topLevelKeys = Object.keys(object[valueName.split('.')[0]] || []);

        changeTypes[idx] = changeTypes[idx] | VALUE | UNSET;
      }
      return obj;
    },
    constructUpdate: function () {
      var astr, idx;
      var update = {};
      var changed = Object.keys(changeTypes);
      for (var i = 0; i < changed.length; i++) {
        idx = changed[i];
        astr = path + '[' + idx + ']';
        if (arr[idx]) {
          if (changeTypes[idx] & NAME) {
            update[astr + '.' + keyName] = arr[idx][keyName];
          }
          if (changeTypes[idx] & VALUE) {
            if (isSimpleValueProp) {
              update[astr + '.' + valueName] = changeTypes[idx] & UNSET ? null : arr[idx][valueName];
            } else {
              update[astr + '.' + valueName] = changeTypes[idx] & UNSET ? null : nestedProperty(arr[idx], valueName).get();
            }
          }
        } else {
          update[astr] = null;
        }
      }
      return update;
    }
  };
  return obj;
};

/***/ }),

/***/ 5867:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);

/**
 * localize: translate a string for the current locale
 *
 * @param {object} gd: the graphDiv for context
 *  gd._context.locale determines the language (& optional region/country)
 *  the dictionary for each locale may either be supplied in
 *  gd._context.locales or globally via Plotly.register
 * @param {string} s: the string to translate
 */
module.exports = function localize(gd, s) {
  var locale = gd._context.locale;

  /*
   * Priority of lookup:
   *     contextDicts[locale],
   *     registeredDicts[locale],
   *     contextDicts[baseLocale], (if baseLocale is distinct)
   *     registeredDicts[baseLocale]
   * Return the first translation we find.
   * This way if you have a regionalization you are allowed to specify
   * only what's different from the base locale, everything else will
   * fall back on the base.
   */
  for (var i = 0; i < 2; i++) {
    var locales = gd._context.locales;
    for (var j = 0; j < 2; j++) {
      var dict = (locales[locale] || {}).dictionary;
      if (dict) {
        var out = dict[s];
        if (out) return out;
      }
      locales = Registry.localeRegistry;
    }
    var baseLocale = locale.split('-')[0];
    if (baseLocale === locale) break;
    locale = baseLocale;
  }
  return s;
};

/***/ }),

/***/ 7769:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/* eslint-disable no-console */
var dfltConfig = (__webpack_require__(2075).dfltConfig);
var notifier = __webpack_require__(5046);
var loggers = module.exports = {};

/**
 * ------------------------------------------
 * debugging tools
 * ------------------------------------------
 */

loggers.log = function () {
  var i;
  if (dfltConfig.logging > 1) {
    var messages = ['LOG:'];
    for (i = 0; i < arguments.length; i++) {
      messages.push(arguments[i]);
    }
    console.trace.apply(console, messages);
  }
  if (dfltConfig.notifyOnLogging > 1) {
    var lines = [];
    for (i = 0; i < arguments.length; i++) {
      lines.push(arguments[i]);
    }
    notifier(lines.join('<br>'), 'long');
  }
};
loggers.warn = function () {
  var i;
  if (dfltConfig.logging > 0) {
    var messages = ['WARN:'];
    for (i = 0; i < arguments.length; i++) {
      messages.push(arguments[i]);
    }
    console.trace.apply(console, messages);
  }
  if (dfltConfig.notifyOnLogging > 0) {
    var lines = [];
    for (i = 0; i < arguments.length; i++) {
      lines.push(arguments[i]);
    }
    notifier(lines.join('<br>'), 'stick');
  }
};
loggers.error = function () {
  var i;
  if (dfltConfig.logging > 0) {
    var messages = ['ERROR:'];
    for (i = 0; i < arguments.length; i++) {
      messages.push(arguments[i]);
    }
    console.error.apply(console, messages);
  }
  if (dfltConfig.notifyOnLogging > 0) {
    var lines = [];
    for (i = 0; i < arguments.length; i++) {
      lines.push(arguments[i]);
    }
    notifier(lines.join('<br>'), 'stick');
  }
};

/***/ }),

/***/ 7310:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);

/**
 * General helper to manage trace groups based on calcdata
 *
 * @param {d3.selection} traceLayer: a selection containing a single group
 *     to draw these traces into
 * @param {array} cdModule: array of calcdata items for this
 *     module and subplot combination. Assumes the calcdata item for each
 *     trace is an array with the fullData trace attached to the first item.
 * @param {string} cls: the class attribute to give each trace group
 *     so you can give multiple classes separated by spaces
 */
module.exports = function makeTraceGroups(traceLayer, cdModule, cls) {
  var traces = traceLayer.selectAll('g.' + cls.replace(/\s/g, '.')).data(cdModule, function (cd) {
    return cd[0].trace.uid;
  });
  traces.exit().remove();
  traces.enter().append('g').attr('class', cls);
  traces.order();

  // stash ref node to trace group in calcdata,
  // useful for (fast) styleOnSelect
  var k = traceLayer.classed('rangeplot') ? 'nodeRangePlot3' : 'node3';
  traces.each(function (cd) {
    cd[0][k] = d3.select(this);
  });
  return traces;
};

/***/ }),

/***/ 5657:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var mat4X4 = __webpack_require__(9576);
exports.init2dArray = function (rowLength, colLength) {
  var array = new Array(rowLength);
  for (var i = 0; i < rowLength; i++) array[i] = new Array(colLength);
  return array;
};

/**
 * transpose a (possibly ragged) 2d array z. inspired by
 * http://stackoverflow.com/questions/17428587/
 * transposing-a-2d-array-in-javascript
 */
exports.transposeRagged = function (z) {
  var maxlen = 0;
  var zlen = z.length;
  var i, j;
  // Maximum row length:
  for (i = 0; i < zlen; i++) maxlen = Math.max(maxlen, z[i].length);
  var t = new Array(maxlen);
  for (i = 0; i < maxlen; i++) {
    t[i] = new Array(zlen);
    for (j = 0; j < zlen; j++) t[i][j] = z[j][i];
  }
  return t;
};

// our own dot function so that we don't need to include numeric
exports.dot = function (x, y) {
  if (!(x.length && y.length) || x.length !== y.length) return null;
  var len = x.length;
  var out;
  var i;
  if (x[0].length) {
    // mat-vec or mat-mat
    out = new Array(len);
    for (i = 0; i < len; i++) out[i] = exports.dot(x[i], y);
  } else if (y[0].length) {
    // vec-mat
    var yTranspose = exports.transposeRagged(y);
    out = new Array(yTranspose.length);
    for (i = 0; i < yTranspose.length; i++) out[i] = exports.dot(x, yTranspose[i]);
  } else {
    // vec-vec
    out = 0;
    for (i = 0; i < len; i++) out += x[i] * y[i];
  }
  return out;
};

// translate by (x,y)
exports.translationMatrix = function (x, y) {
  return [[1, 0, x], [0, 1, y], [0, 0, 1]];
};

// rotate by alpha around (0,0)
exports.rotationMatrix = function (alpha) {
  var a = alpha * Math.PI / 180;
  return [[Math.cos(a), -Math.sin(a), 0], [Math.sin(a), Math.cos(a), 0], [0, 0, 1]];
};

// rotate by alpha around (x,y)
exports.rotationXYMatrix = function (a, x, y) {
  return exports.dot(exports.dot(exports.translationMatrix(x, y), exports.rotationMatrix(a)), exports.translationMatrix(-x, -y));
};

// applies a 3D transformation matrix to either x, y and z params
// Note: z is optional
exports.apply3DTransform = function (transform) {
  return function () {
    var args = arguments;
    var xyz = arguments.length === 1 ? args[0] : [args[0], args[1], args[2] || 0];
    return exports.dot(transform, [xyz[0], xyz[1], xyz[2], 1]).slice(0, 3);
  };
};

// applies a 2D transformation matrix to either x and y params or an [x,y] array
exports.apply2DTransform = function (transform) {
  return function () {
    var args = arguments;
    if (args.length === 3) {
      args = args[0];
    } // from map
    var xy = arguments.length === 1 ? args[0] : [args[0], args[1]];
    return exports.dot(transform, [xy[0], xy[1], 1]).slice(0, 2);
  };
};

// applies a 2D transformation matrix to an [x1,y1,x2,y2] array (to transform a segment)
exports.apply2DTransform2 = function (transform) {
  var at = exports.apply2DTransform(transform);
  return function (xys) {
    return at(xys.slice(0, 2)).concat(at(xys.slice(2, 4)));
  };
};
exports.convertCssMatrix = function (m) {
  if (m) {
    var len = m.length;
    if (len === 16) return m;
    if (len === 6) {
      // converts a 2x3 css transform matrix to a 4x4 matrix see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix
      return [m[0], m[1], 0, 0, m[2], m[3], 0, 0, 0, 0, 1, 0, m[4], m[5], 0, 1];
    }
  }
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
};

// find the inverse for a 4x4 affine transform matrix
exports.inverseTransformMatrix = function (m) {
  var out = [];
  mat4X4.invert(out, m);
  return [[out[0], out[1], out[2], out[3]], [out[4], out[5], out[6], out[7]], [out[8], out[9], out[10], out[11]], [out[12], out[13], out[14], out[15]]];
};

/***/ }),

/***/ 4872:
/***/ (function(module) {

"use strict";


/**
 * sanitized modulus function that always returns in the range [0, d)
 * rather than (-d, 0] if v is negative
 */
function mod(v, d) {
  var out = v % d;
  return out < 0 ? out + d : out;
}

/**
 * sanitized modulus function that always returns in the range [-d/2, d/2]
 * rather than (-d, 0] if v is negative
 */
function modHalf(v, d) {
  return Math.abs(v) > d / 2 ? v - Math.round(v / d) * d : v;
}
module.exports = {
  mod: mod,
  modHalf: modHalf
};

/***/ }),

/***/ 5487:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var isArrayOrTypedArray = (__webpack_require__(3627).isArrayOrTypedArray);

/**
 * convert a string s (such as 'xaxis.range[0]')
 * representing a property of nested object into set and get methods
 * also return the string and object so we don't have to keep track of them
 * allows [-1] for an array index, to set a property inside all elements
 * of an array
 * eg if obj = {arr: [{a: 1}, {a: 2}]}
 * you can do p = nestedProperty(obj, 'arr[-1].a')
 * but you cannot set the array itself this way, to do that
 * just set the whole array.
 * eg if obj = {arr: [1, 2, 3]}
 * you can't do nestedProperty(obj, 'arr[-1]').set(5)
 * but you can do nestedProperty(obj, 'arr').set([5, 5, 5])
 */
module.exports = function nestedProperty(container, propStr) {
  if (isNumeric(propStr)) propStr = String(propStr);else if (typeof propStr !== 'string' || propStr.substr(propStr.length - 4) === '[-1]') {
    throw 'bad property string';
  }
  var propParts = propStr.split('.');
  var indexed;
  var indices;
  var i, j;
  for (j = 0; j < propParts.length; j++) {
    // guard against polluting __proto__ and other internals
    if (String(propParts[j]).slice(0, 2) === '__') {
      throw 'bad property string';
    }
  }

  // check for parts of the nesting hierarchy that are numbers (ie array elements)
  j = 0;
  while (j < propParts.length) {
    // look for non-bracket chars, then any number of [##] blocks
    indexed = String(propParts[j]).match(/^([^\[\]]*)((\[\-?[0-9]*\])+)$/);
    if (indexed) {
      if (indexed[1]) propParts[j] = indexed[1];
      // allow propStr to start with bracketed array indices
      else if (j === 0) propParts.splice(0, 1);else throw 'bad property string';
      indices = indexed[2].substr(1, indexed[2].length - 2).split('][');
      for (i = 0; i < indices.length; i++) {
        j++;
        propParts.splice(j, 0, Number(indices[i]));
      }
    }
    j++;
  }
  if (typeof container !== 'object') {
    return badContainer(container, propStr, propParts);
  }
  return {
    set: npSet(container, propParts, propStr),
    get: npGet(container, propParts),
    astr: propStr,
    parts: propParts,
    obj: container
  };
};
function npGet(cont, parts) {
  return function () {
    var curCont = cont;
    var curPart;
    var allSame;
    var out;
    var i;
    var j;
    for (i = 0; i < parts.length - 1; i++) {
      curPart = parts[i];
      if (curPart === -1) {
        allSame = true;
        out = [];
        for (j = 0; j < curCont.length; j++) {
          out[j] = npGet(curCont[j], parts.slice(i + 1))();
          if (out[j] !== out[0]) allSame = false;
        }
        return allSame ? out[0] : out;
      }
      if (typeof curPart === 'number' && !isArrayOrTypedArray(curCont)) {
        return undefined;
      }
      curCont = curCont[curPart];
      if (typeof curCont !== 'object' || curCont === null) {
        return undefined;
      }
    }

    // only hit this if parts.length === 1
    if (typeof curCont !== 'object' || curCont === null) return undefined;
    out = curCont[parts[i]];
    if (out === null) return undefined;
    return out;
  };
}

/*
 * Can this value be deleted? We can delete `undefined`, and `null` except INSIDE an
 * *args* array.
 *
 * Previously we also deleted some `{}` and `[]`, in order to try and make set/unset
 * a net noop; but this causes far more complication than it's worth, and still had
 * lots of exceptions. See https://github.com/plotly/plotly.js/issues/1410
 *
 * *args* arrays get passed directly to API methods and we should respect null if
 * the user put it there, but otherwise null is deleted as we use it as code
 * in restyle/relayout/update for "delete this value" whereas undefined means
 * "ignore this edit"
 */
var ARGS_PATTERN = /(^|\.)args\[/;
function isDeletable(val, propStr) {
  return val === undefined || val === null && !propStr.match(ARGS_PATTERN);
}
function npSet(cont, parts, propStr) {
  return function (val) {
    var curCont = cont;
    var propPart = '';
    var containerLevels = [[cont, propPart]];
    var toDelete = isDeletable(val, propStr);
    var curPart;
    var i;
    for (i = 0; i < parts.length - 1; i++) {
      curPart = parts[i];
      if (typeof curPart === 'number' && !isArrayOrTypedArray(curCont)) {
        throw 'array index but container is not an array';
      }

      // handle special -1 array index
      if (curPart === -1) {
        toDelete = !setArrayAll(curCont, parts.slice(i + 1), val, propStr);
        if (toDelete) break;else return;
      }
      if (!checkNewContainer(curCont, curPart, parts[i + 1], toDelete)) {
        break;
      }
      curCont = curCont[curPart];
      if (typeof curCont !== 'object' || curCont === null) {
        throw 'container is not an object';
      }
      propPart = joinPropStr(propPart, curPart);
      containerLevels.push([curCont, propPart]);
    }
    if (toDelete) {
      if (i === parts.length - 1) {
        delete curCont[parts[i]];

        // The one bit of pruning we still do: drop `undefined` from the end of arrays.
        // In case someone has already unset previous items, continue until we hit a
        // non-undefined value.
        if (Array.isArray(curCont) && +parts[i] === curCont.length - 1) {
          while (curCont.length && curCont[curCont.length - 1] === undefined) {
            curCont.pop();
          }
        }
      }
    } else curCont[parts[i]] = val;
  };
}
function joinPropStr(propStr, newPart) {
  var toAdd = newPart;
  if (isNumeric(newPart)) toAdd = '[' + newPart + ']';else if (propStr) toAdd = '.' + newPart;
  return propStr + toAdd;
}

// handle special -1 array index
function setArrayAll(containerArray, innerParts, val, propStr) {
  var arrayVal = isArrayOrTypedArray(val);
  var allSet = true;
  var thisVal = val;
  var thisPropStr = propStr.replace('-1', 0);
  var deleteThis = arrayVal ? false : isDeletable(val, thisPropStr);
  var firstPart = innerParts[0];
  var i;
  for (i = 0; i < containerArray.length; i++) {
    thisPropStr = propStr.replace('-1', i);
    if (arrayVal) {
      thisVal = val[i % val.length];
      deleteThis = isDeletable(thisVal, thisPropStr);
    }
    if (deleteThis) allSet = false;
    if (!checkNewContainer(containerArray, i, firstPart, deleteThis)) {
      continue;
    }
    npSet(containerArray[i], innerParts, propStr.replace('-1', i))(thisVal);
  }
  return allSet;
}

/**
 * make new sub-container as needed.
 * returns false if there's no container and none is needed
 * because we're only deleting an attribute
 */
function checkNewContainer(container, part, nextPart, toDelete) {
  if (container[part] === undefined) {
    if (toDelete) return false;
    if (typeof nextPart === 'number') container[part] = [];else container[part] = {};
  }
  return true;
}
function badContainer(container, propStr, propParts) {
  return {
    set: function () {
      throw 'bad container';
    },
    get: function () {},
    astr: propStr,
    parts: propParts,
    obj: container
  };
}

/***/ }),

/***/ 4213:
/***/ (function(module) {

"use strict";


// Simple helper functions
// none of these need any external deps
module.exports = function noop() {};

/***/ }),

/***/ 5046:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var isNumeric = __webpack_require__(2770);
var NOTEDATA = [];

/**
 * notifier
 * @param {String} text The person's user name
 * @param {Number} [delay=1000] The delay time in milliseconds
 *          or 'long' which provides 2000 ms delay time.
 * @return {undefined} this function does not return a value
 */
module.exports = function (text, displayLength) {
  if (NOTEDATA.indexOf(text) !== -1) return;
  NOTEDATA.push(text);
  var ts = 1000;
  if (isNumeric(displayLength)) ts = displayLength;else if (displayLength === 'long') ts = 3000;
  var notifierContainer = d3.select('body').selectAll('.plotly-notifier').data([0]);
  notifierContainer.enter().append('div').classed('plotly-notifier', true);
  var notes = notifierContainer.selectAll('.notifier-note').data(NOTEDATA);
  function killNote(transition) {
    transition.duration(700).style('opacity', 0).each('end', function (thisText) {
      var thisIndex = NOTEDATA.indexOf(thisText);
      if (thisIndex !== -1) NOTEDATA.splice(thisIndex, 1);
      d3.select(this).remove();
    });
  }
  notes.enter().append('div').classed('notifier-note', true).style('opacity', 0).each(function (thisText) {
    var note = d3.select(this);
    note.append('button').classed('notifier-close', true).html('&times;').on('click', function () {
      note.transition().call(killNote);
    });
    var p = note.append('p');
    var lines = thisText.split(/<br\s*\/?>/g);
    for (var i = 0; i < lines.length; i++) {
      if (i) p.append('br');
      p.append('span').text(lines[i]);
    }
    if (displayLength === 'stick') {
      note.transition().duration(350).style('opacity', 1);
    } else {
      note.transition().duration(700).style('opacity', 1).transition().delay(ts).call(killNote);
    }
  });
};

/***/ }),

/***/ 9918:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var setCursor = __webpack_require__(6964);
var STASHATTR = 'data-savedcursor';
var NO_CURSOR = '!!';

/*
 * works with our CSS cursor classes (see css/_cursor.scss)
 * to override a previous cursor set on d3 single-element selections,
 * by moving the name of the original cursor to the data-savedcursor attr.
 * omit cursor to revert to the previously set value.
 */
module.exports = function overrideCursor(el3, csr) {
  var savedCursor = el3.attr(STASHATTR);
  if (csr) {
    if (!savedCursor) {
      var classes = (el3.attr('class') || '').split(' ');
      for (var i = 0; i < classes.length; i++) {
        var cls = classes[i];
        if (cls.indexOf('cursor-') === 0) {
          el3.attr(STASHATTR, cls.substr(7)).classed(cls, false);
        }
      }
      if (!el3.attr(STASHATTR)) {
        el3.attr(STASHATTR, NO_CURSOR);
      }
    }
    setCursor(el3, csr);
  } else if (savedCursor) {
    el3.attr(STASHATTR, null);
    if (savedCursor === NO_CURSOR) setCursor(el3);else setCursor(el3, savedCursor);
  }
};

/***/ }),

/***/ 1082:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var dot = (__webpack_require__(5657).dot);
var BADNUM = (__webpack_require__(606).BADNUM);
var polygon = module.exports = {};

/**
 * Turn an array of [x, y] pairs into a polygon object
 * that can test if points are inside it
 *
 * @param ptsIn Array of [x, y] pairs
 *
 * @returns polygon Object {xmin, xmax, ymin, ymax, pts, contains}
 *      (x|y)(min|max) are the bounding rect of the polygon
 *      pts is the original array, with the first pair repeated at the end
 *      contains is a function: (pt, omitFirstEdge)
 *          pt is the [x, y] pair to test
 *          omitFirstEdge truthy means points exactly on the first edge don't
 *              count. This is for use adding one polygon to another so we
 *              don't double-count the edge where they meet.
 *          returns boolean: is pt inside the polygon (including on its edges)
 */
polygon.tester = function tester(ptsIn) {
  var pts = ptsIn.slice();
  var xmin = pts[0][0];
  var xmax = xmin;
  var ymin = pts[0][1];
  var ymax = ymin;
  var i;
  if (pts[pts.length - 1][0] !== pts[0][0] || pts[pts.length - 1][1] !== pts[0][1]) {
    // close the polygon
    pts.push(pts[0]);
  }
  for (i = 1; i < pts.length; i++) {
    xmin = Math.min(xmin, pts[i][0]);
    xmax = Math.max(xmax, pts[i][0]);
    ymin = Math.min(ymin, pts[i][1]);
    ymax = Math.max(ymax, pts[i][1]);
  }

  // do we have a rectangle? Handle this here, so we can use the same
  // tester for the rectangular case without sacrificing speed

  var isRect = false;
  var rectFirstEdgeTest;
  if (pts.length === 5) {
    if (pts[0][0] === pts[1][0]) {
      // vert, horz, vert, horz
      if (pts[2][0] === pts[3][0] && pts[0][1] === pts[3][1] && pts[1][1] === pts[2][1]) {
        isRect = true;
        rectFirstEdgeTest = function (pt) {
          return pt[0] === pts[0][0];
        };
      }
    } else if (pts[0][1] === pts[1][1]) {
      // horz, vert, horz, vert
      if (pts[2][1] === pts[3][1] && pts[0][0] === pts[3][0] && pts[1][0] === pts[2][0]) {
        isRect = true;
        rectFirstEdgeTest = function (pt) {
          return pt[1] === pts[0][1];
        };
      }
    }
  }
  function rectContains(pt, omitFirstEdge) {
    var x = pt[0];
    var y = pt[1];
    if (x === BADNUM || x < xmin || x > xmax || y === BADNUM || y < ymin || y > ymax) {
      // pt is outside the bounding box of polygon
      return false;
    }
    if (omitFirstEdge && rectFirstEdgeTest(pt)) return false;
    return true;
  }
  function contains(pt, omitFirstEdge) {
    var x = pt[0];
    var y = pt[1];
    if (x === BADNUM || x < xmin || x > xmax || y === BADNUM || y < ymin || y > ymax) {
      // pt is outside the bounding box of polygon
      return false;
    }
    var imax = pts.length;
    var x1 = pts[0][0];
    var y1 = pts[0][1];
    var crossings = 0;
    var i;
    var x0;
    var y0;
    var xmini;
    var ycross;
    for (i = 1; i < imax; i++) {
      // find all crossings of a vertical line upward from pt with
      // polygon segments
      // crossings exactly at xmax don't count, unless the point is
      // exactly on the segment, then it counts as inside.
      x0 = x1;
      y0 = y1;
      x1 = pts[i][0];
      y1 = pts[i][1];
      xmini = Math.min(x0, x1);
      if (x < xmini || x > Math.max(x0, x1) || y > Math.max(y0, y1)) {
        // outside the bounding box of this segment, it's only a crossing
        // if it's below the box.

        continue;
      } else if (y < Math.min(y0, y1)) {
        // don't count the left-most point of the segment as a crossing
        // because we don't want to double-count adjacent crossings
        // UNLESS the polygon turns past vertical at exactly this x
        // Note that this is repeated below, but we can't factor it out
        // because
        if (x !== xmini) crossings++;
      } else {
        // inside the bounding box, check the actual line intercept

        // vertical segment - we know already that the point is exactly
        // on the segment, so mark the crossing as exactly at the point.
        if (x1 === x0) ycross = y;
        // any other angle
        else ycross = y0 + (x - x0) * (y1 - y0) / (x1 - x0);

        // exactly on the edge: counts as inside the polygon, unless it's the
        // first edge and we're omitting it.
        if (y === ycross) {
          if (i === 1 && omitFirstEdge) return false;
          return true;
        }
        if (y <= ycross && x !== xmini) crossings++;
      }
    }

    // if we've gotten this far, odd crossings means inside, even is outside
    return crossings % 2 === 1;
  }

  // detect if poly is degenerate
  var degenerate = true;
  var lastPt = pts[0];
  for (i = 1; i < pts.length; i++) {
    if (lastPt[0] !== pts[i][0] || lastPt[1] !== pts[i][1]) {
      degenerate = false;
      break;
    }
  }
  return {
    xmin: xmin,
    xmax: xmax,
    ymin: ymin,
    ymax: ymax,
    pts: pts,
    contains: isRect ? rectContains : contains,
    isRect: isRect,
    degenerate: degenerate
  };
};

/**
 * Test if a segment of a points array is bent or straight
 *
 * @param pts Array of [x, y] pairs
 * @param start the index of the proposed start of the straight section
 * @param end the index of the proposed end point
 * @param tolerance the max distance off the line connecting start and end
 *      before the line counts as bent
 * @returns boolean: true means this segment is bent, false means straight
 */
polygon.isSegmentBent = function isSegmentBent(pts, start, end, tolerance) {
  var startPt = pts[start];
  var segment = [pts[end][0] - startPt[0], pts[end][1] - startPt[1]];
  var segmentSquared = dot(segment, segment);
  var segmentLen = Math.sqrt(segmentSquared);
  var unitPerp = [-segment[1] / segmentLen, segment[0] / segmentLen];
  var i;
  var part;
  var partParallel;
  for (i = start + 1; i < end; i++) {
    part = [pts[i][0] - startPt[0], pts[i][1] - startPt[1]];
    partParallel = dot(part, segment);
    if (partParallel < 0 || partParallel > segmentSquared || Math.abs(dot(part, unitPerp)) > tolerance) return true;
  }
  return false;
};

/**
 * Make a filtering polygon, to minimize the number of segments
 *
 * @param pts Array of [x, y] pairs (must start with at least 1 pair)
 * @param tolerance the maximum deviation from straight allowed for
 *      removing points to simplify the polygon
 *
 * @returns Object {addPt, raw, filtered}
 *      addPt is a function(pt: [x, y] pair) to add a raw point and
 *          continue filtering
 *      raw is all the input points
 *      filtered is the resulting filtered Array of [x, y] pairs
 */
polygon.filter = function filter(pts, tolerance) {
  var ptsFiltered = [pts[0]];
  var doneRawIndex = 0;
  var doneFilteredIndex = 0;
  function addPt(pt) {
    pts.push(pt);
    var prevFilterLen = ptsFiltered.length;
    var iLast = doneRawIndex;
    ptsFiltered.splice(doneFilteredIndex + 1);
    for (var i = iLast + 1; i < pts.length; i++) {
      if (i === pts.length - 1 || polygon.isSegmentBent(pts, iLast, i + 1, tolerance)) {
        ptsFiltered.push(pts[i]);
        if (ptsFiltered.length < prevFilterLen - 2) {
          doneRawIndex = i;
          doneFilteredIndex = ptsFiltered.length - 1;
        }
        iLast = i;
      }
    }
  }
  if (pts.length > 1) {
    var lastPt = pts.pop();
    addPt(lastPt);
  }
  return {
    addPt: addPt,
    raw: pts,
    filtered: ptsFiltered
  };
};

/***/ }),

/***/ 5142:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var isMobileOrTablet = __webpack_require__(5791);
module.exports = function preserveDrawingBuffer(opts) {
  var ua;
  if (opts && opts.hasOwnProperty('userAgent')) {
    ua = opts.userAgent;
  } else {
    ua = getUserAgent();
  }
  if (typeof ua !== 'string') return true;
  var enable = isMobileOrTablet({
    ua: {
      headers: {
        'user-agent': ua
      }
    },
    tablet: true,
    featureDetect: false
  });
  if (!enable) {
    var allParts = ua.split(' ');
    for (var i = 1; i < allParts.length; i++) {
      var part = allParts[i];
      if (part.indexOf('Safari') !== -1) {
        // find Safari version
        for (var k = i - 1; k > -1; k--) {
          var prevPart = allParts[k];
          if (prevPart.substr(0, 8) === 'Version/') {
            var v = prevPart.substr(8).split('.')[0];
            if (isNumeric(v)) v = +v;
            if (v >= 13) return true;
          }
        }
      }
    }
  }
  return enable;
};
function getUserAgent() {
  // similar to https://github.com/juliangruber/is-mobile/blob/91ca39ccdd4cfc5edfb5391e2515b923a730fbea/index.js#L14-L17
  var ua;
  if (typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }
  if (ua && ua.headers && typeof ua.headers['user-agent'] === 'string') {
    ua = ua.headers['user-agent'];
  }
  return ua;
}

/***/ }),

/***/ 5138:
/***/ (function(module) {

"use strict";


/**
 * Push array with unique items
 *
 * Ignores falsy items, except 0 so we can use it to construct arrays of indices.
 *
 * @param {array} array
 *  array to be filled
 * @param {any} item
 *  item to be or not to be inserted
 * @return {array}
 *  ref to array (now possibly containing one more item)
 *
 */
module.exports = function pushUnique(array, item) {
  if (item instanceof RegExp) {
    var itemStr = item.toString();
    for (var i = 0; i < array.length; i++) {
      if (array[i] instanceof RegExp && array[i].toString() === itemStr) {
        return array;
      }
    }
    array.push(item);
  } else if ((item || item === 0) && array.indexOf(item) === -1) array.push(item);
  return array;
};

/***/ }),

/***/ 847:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var dfltConfig = (__webpack_require__(2075).dfltConfig);

/**
 * Copy arg array *without* removing `undefined` values from objects.
 *
 * @param gd
 * @param args
 * @returns {Array}
 */
function copyArgArray(gd, args) {
  var copy = [];
  var arg;
  for (var i = 0; i < args.length; i++) {
    arg = args[i];
    if (arg === gd) copy[i] = arg;else if (typeof arg === 'object') {
      copy[i] = Array.isArray(arg) ? Lib.extendDeep([], arg) : Lib.extendDeepAll({}, arg);
    } else copy[i] = arg;
  }
  return copy;
}

// -----------------------------------------------------
// Undo/Redo queue for plots
// -----------------------------------------------------

var queue = {};

// TODO: disable/enable undo and redo buttons appropriately

/**
 * Add an item to the undoQueue for a graphDiv
 *
 * @param gd
 * @param undoFunc Function undo this operation
 * @param undoArgs Args to supply undoFunc with
 * @param redoFunc Function to redo this operation
 * @param redoArgs Args to supply redoFunc with
 */
queue.add = function (gd, undoFunc, undoArgs, redoFunc, redoArgs) {
  var queueObj, queueIndex;

  // make sure we have the queue and our position in it
  gd.undoQueue = gd.undoQueue || {
    index: 0,
    queue: [],
    sequence: false
  };
  queueIndex = gd.undoQueue.index;

  // if we're already playing an undo or redo, or if this is an auto operation
  // (like pane resize... any others?) then we don't save this to the undo queue
  if (gd.autoplay) {
    if (!gd.undoQueue.inSequence) gd.autoplay = false;
    return;
  }

  // if we're not in a sequence or are just starting, we need a new queue item
  if (!gd.undoQueue.sequence || gd.undoQueue.beginSequence) {
    queueObj = {
      undo: {
        calls: [],
        args: []
      },
      redo: {
        calls: [],
        args: []
      }
    };
    gd.undoQueue.queue.splice(queueIndex, gd.undoQueue.queue.length - queueIndex, queueObj);
    gd.undoQueue.index += 1;
  } else {
    queueObj = gd.undoQueue.queue[queueIndex - 1];
  }
  gd.undoQueue.beginSequence = false;

  // we unshift to handle calls for undo in a forward for loop later
  if (queueObj) {
    queueObj.undo.calls.unshift(undoFunc);
    queueObj.undo.args.unshift(undoArgs);
    queueObj.redo.calls.push(redoFunc);
    queueObj.redo.args.push(redoArgs);
  }
  if (gd.undoQueue.queue.length > dfltConfig.queueLength) {
    gd.undoQueue.queue.shift();
    gd.undoQueue.index--;
  }
};

/**
 * Begin a sequence of undoQueue changes
 *
 * @param gd
 */
queue.startSequence = function (gd) {
  gd.undoQueue = gd.undoQueue || {
    index: 0,
    queue: [],
    sequence: false
  };
  gd.undoQueue.sequence = true;
  gd.undoQueue.beginSequence = true;
};

/**
 * Stop a sequence of undoQueue changes
 *
 * Call this *after* you're sure your undo chain has ended
 *
 * @param gd
 */
queue.stopSequence = function (gd) {
  gd.undoQueue = gd.undoQueue || {
    index: 0,
    queue: [],
    sequence: false
  };
  gd.undoQueue.sequence = false;
  gd.undoQueue.beginSequence = false;
};

/**
 * Move one step back in the undo queue, and undo the object there.
 *
 * @param gd
 */
queue.undo = function undo(gd) {
  var queueObj, i;
  if (gd.undoQueue === undefined || isNaN(gd.undoQueue.index) || gd.undoQueue.index <= 0) {
    return;
  }

  // index is pointing to next *forward* queueObj, point to the one we're undoing
  gd.undoQueue.index--;

  // get the queueObj for instructions on how to undo
  queueObj = gd.undoQueue.queue[gd.undoQueue.index];

  // this sequence keeps things from adding to the queue during undo/redo
  gd.undoQueue.inSequence = true;
  for (i = 0; i < queueObj.undo.calls.length; i++) {
    queue.plotDo(gd, queueObj.undo.calls[i], queueObj.undo.args[i]);
  }
  gd.undoQueue.inSequence = false;
  gd.autoplay = false;
};

/**
 * Redo the current object in the undo, then move forward in the queue.
 *
 * @param gd
 */
queue.redo = function redo(gd) {
  var queueObj, i;
  if (gd.undoQueue === undefined || isNaN(gd.undoQueue.index) || gd.undoQueue.index >= gd.undoQueue.queue.length) {
    return;
  }

  // get the queueObj for instructions on how to undo
  queueObj = gd.undoQueue.queue[gd.undoQueue.index];

  // this sequence keeps things from adding to the queue during undo/redo
  gd.undoQueue.inSequence = true;
  for (i = 0; i < queueObj.redo.calls.length; i++) {
    queue.plotDo(gd, queueObj.redo.calls[i], queueObj.redo.args[i]);
  }
  gd.undoQueue.inSequence = false;
  gd.autoplay = false;

  // index is pointing to the thing we just redid, move it
  gd.undoQueue.index++;
};

/**
 * Called by undo/redo to make the actual changes.
 *
 * Not meant to be called publically, but included for mocking out in tests.
 *
 * @param gd
 * @param func
 * @param args
 */
queue.plotDo = function (gd, func, args) {
  gd.autoplay = true;

  // this *won't* copy gd and it preserves `undefined` properties!
  args = copyArgArray(gd, args);

  // call the supplied function
  func.apply(null, args);
};
module.exports = queue;

/***/ }),

/***/ 587:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


/*
 * make a regex for matching counter ids/names ie xaxis, xaxis2, xaxis10...
 *
 * @param {string} head: the head of the pattern, eg 'x' matches 'x', 'x2', 'x10' etc.
 *      'xy' is a special case for cartesian subplots: it matches 'x2y3' etc
 * @param {Optional(string)} tail: a fixed piece after the id
 *      eg counterRegex('scene', '.annotations') for scene2.annotations etc.
 * @param {boolean} openEnded: if true, the string may continue past the match.
 * @param {boolean} matchBeginning: if false, the string may start before the match.
 */
exports.counter = function (head, tail, openEnded, matchBeginning) {
  var fullTail = (tail || '') + (openEnded ? '' : '$');
  var startWithPrefix = matchBeginning === false ? '' : '^';
  if (head === 'xy') {
    return new RegExp(startWithPrefix + 'x([2-9]|[1-9][0-9]+)?y([2-9]|[1-9][0-9]+)?' + fullTail);
  }
  return new RegExp(startWithPrefix + head + '([2-9]|[1-9][0-9]+)?' + fullTail);
};

/***/ }),

/***/ 6962:
/***/ (function(module) {

"use strict";


// ASCEND: chop off the last nesting level - either [<n>] or .<key> - to ascend
// the attribute tree. the remaining attrString is in match[1]
var ASCEND = /^(.*)(\.[^\.\[\]]+|\[\d\])$/;

// SIMPLEATTR: is this an un-nested attribute? (no dots or brackets)
var SIMPLEATTR = /^[^\.\[\]]+$/;

/*
 * calculate a relative attribute string, similar to a relative path
 *
 * @param {string} baseAttr:
 *   an attribute string, such as 'annotations[3].x'. The "current location"
 *   is the attribute string minus the last component ('annotations[3]')
 * @param {string} relativeAttr:
 *   a route to the desired attribute string, using '^' to ascend
 *
 * @return {string} attrString:
 *   for example:
 *     relativeAttr('annotations[3].x', 'y') = 'annotations[3].y'
 *     relativeAttr('annotations[3].x', '^[2].z') = 'annotations[2].z'
 *     relativeAttr('annotations[3].x', '^^margin') = 'margin'
 *     relativeAttr('annotations[3].x', '^^margin.r') = 'margin.r'
 */
module.exports = function (baseAttr, relativeAttr) {
  while (relativeAttr) {
    var match = baseAttr.match(ASCEND);
    if (match) baseAttr = match[1];else if (baseAttr.match(SIMPLEATTR)) baseAttr = '';else throw new Error('bad relativeAttr call:' + [baseAttr, relativeAttr]);
    if (relativeAttr.charAt(0) === '^') relativeAttr = relativeAttr.slice(1);else break;
  }
  if (baseAttr && relativeAttr.charAt(0) !== '[') {
    return baseAttr + '.' + relativeAttr;
  }
  return baseAttr + relativeAttr;
};

/***/ }),

/***/ 1332:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isArrayOrTypedArray = (__webpack_require__(3627).isArrayOrTypedArray);
var isPlainObject = __webpack_require__(1965);

/**
 * Relink private _keys and keys with a function value from one container
 * to the new container.
 * Relink means copying if object is pass-by-value and adding a reference
 * if object is pass-by-ref.
 * This prevents deepCopying massive structures like a webgl context.
 */
module.exports = function relinkPrivateKeys(toContainer, fromContainer) {
  for (var k in fromContainer) {
    var fromVal = fromContainer[k];
    var toVal = toContainer[k];
    if (toVal === fromVal) continue;
    if (k.charAt(0) === '_' || typeof fromVal === 'function') {
      // if it already exists at this point, it's something
      // that we recreate each time around, so ignore it
      if (k in toContainer) continue;
      toContainer[k] = fromVal;
    } else if (isArrayOrTypedArray(fromVal) && isArrayOrTypedArray(toVal) && isPlainObject(fromVal[0])) {
      // filter out data_array items that can contain user objects
      // most of the time the toVal === fromVal check will catch these early
      // but if the user makes new ones we also don't want to recurse in.
      if (k === 'customdata' || k === 'ids') continue;

      // recurse into arrays containers
      var minLen = Math.min(fromVal.length, toVal.length);
      for (var j = 0; j < minLen; j++) {
        if (toVal[j] !== fromVal[j] && isPlainObject(fromVal[j]) && isPlainObject(toVal[j])) {
          relinkPrivateKeys(toVal[j], fromVal[j]);
        }
      }
    } else if (isPlainObject(fromVal) && isPlainObject(toVal)) {
      // recurse into objects, but only if they still exist
      relinkPrivateKeys(toVal, fromVal);
      if (!Object.keys(toVal).length) delete toContainer[k];
    }
  }
};

/***/ }),

/***/ 5888:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var loggers = __webpack_require__(7769);
var identity = __webpack_require__(3389);
var BADNUM = (__webpack_require__(606).BADNUM);

// don't trust floating point equality - fraction of bin size to call
// "on the line" and ensure that they go the right way specified by
// linelow
var roundingError = 1e-9;

/**
 * findBin - find the bin for val - note that it can return outside the
 * bin range any pos. or neg. integer for linear bins, or -1 or
 * bins.length-1 for explicit.
 * bins is either an object {start,size,end} or an array length #bins+1
 * bins can be either increasing or decreasing but must be monotonic
 * for linear bins, we can just calculate. For listed bins, run a binary
 * search linelow (truthy) says the bin boundary should be attributed to
 * the lower bin rather than the default upper bin
 */
exports.findBin = function (val, bins, linelow) {
  if (isNumeric(bins.start)) {
    return linelow ? Math.ceil((val - bins.start) / bins.size - roundingError) - 1 : Math.floor((val - bins.start) / bins.size + roundingError);
  } else {
    var n1 = 0;
    var n2 = bins.length;
    var c = 0;
    var binSize = n2 > 1 ? (bins[n2 - 1] - bins[0]) / (n2 - 1) : 1;
    var n, test;
    if (binSize >= 0) {
      test = linelow ? lessThan : lessOrEqual;
    } else {
      test = linelow ? greaterOrEqual : greaterThan;
    }
    val += binSize * roundingError * (linelow ? -1 : 1) * (binSize >= 0 ? 1 : -1);
    // c is just to avoid infinite loops if there's an error
    while (n1 < n2 && c++ < 100) {
      n = Math.floor((n1 + n2) / 2);
      if (test(bins[n], val)) n1 = n + 1;else n2 = n;
    }
    if (c > 90) loggers.log('Long binary search...');
    return n1 - 1;
  }
};
function lessThan(a, b) {
  return a < b;
}
function lessOrEqual(a, b) {
  return a <= b;
}
function greaterThan(a, b) {
  return a > b;
}
function greaterOrEqual(a, b) {
  return a >= b;
}
exports.sorterAsc = function (a, b) {
  return a - b;
};
exports.sorterDes = function (a, b) {
  return b - a;
};

/**
 * find distinct values in an array, lumping together ones that appear to
 * just be off by a rounding error
 * return the distinct values and the minimum difference between any two
 */
exports.distinctVals = function (valsIn) {
  var vals = valsIn.slice(); // otherwise we sort the original array...
  vals.sort(exports.sorterAsc); // undefined listed in the end - also works on IE11

  var last;
  for (last = vals.length - 1; last > -1; last--) {
    if (vals[last] !== BADNUM) break;
  }
  var minDiff = vals[last] - vals[0] || 1;
  var errDiff = minDiff / (last || 1) / 10000;
  var newVals = [];
  var preV;
  for (var i = 0; i <= last; i++) {
    var v = vals[i];

    // make sure values aren't just off by a rounding error
    var diff = v - preV;
    if (preV === undefined) {
      newVals.push(v);
      preV = v;
    } else if (diff > errDiff) {
      minDiff = Math.min(minDiff, diff);
      newVals.push(v);
      preV = v;
    }
  }
  return {
    vals: newVals,
    minDiff: minDiff
  };
};

/**
 * return the smallest element from (sorted) array arrayIn that's bigger than val,
 * or (reverse) the largest element smaller than val
 * used to find the best tick given the minimum (non-rounded) tick
 * particularly useful for date/time where things are not powers of 10
 * binary search is probably overkill here...
 */
exports.roundUp = function (val, arrayIn, reverse) {
  var low = 0;
  var high = arrayIn.length - 1;
  var mid;
  var c = 0;
  var dlow = reverse ? 0 : 1;
  var dhigh = reverse ? 1 : 0;
  var rounded = reverse ? Math.ceil : Math.floor;
  // c is just to avoid infinite loops if there's an error
  while (low < high && c++ < 100) {
    mid = rounded((low + high) / 2);
    if (arrayIn[mid] <= val) low = mid + dlow;else high = mid - dhigh;
  }
  return arrayIn[low];
};

/**
 * Tweak to Array.sort(sortFn) that improves performance for pre-sorted arrays
 *
 * Note that newer browsers (such as Chrome v70+) are starting to pick up
 * on pre-sorted arrays which may render the following optimization unnecessary
 * in the future.
 *
 * Motivation: sometimes we need to sort arrays but the input is likely to
 * already be sorted. Browsers don't seem to pick up on pre-sorted arrays,
 * and in fact Chrome is actually *slower* sorting pre-sorted arrays than purely
 * random arrays. FF is at least faster if the array is pre-sorted, but still
 * not as fast as it could be.
 * Here's how this plays out sorting a length-1e6 array:
 *
 * Calls to Sort FN  |  Chrome bare  |  FF bare  |  Chrome tweak  |  FF tweak
 *                   |  v68.0 Mac    |  v61.0 Mac|                |
 * ------------------+---------------+-----------+----------------+------------
 * ordered           |  30.4e6       |  10.1e6   |  1e6           |  1e6
 * reversed          |  29.4e6       |  9.9e6    |  1e6 + reverse |  1e6 + reverse
 * random            |  ~21e6        |  ~18.7e6  |  ~21e6         |  ~18.7e6
 *
 * So this is a substantial win for pre-sorted (ordered or exactly reversed)
 * arrays. Including this wrapper on an unsorted array adds a penalty that will
 * in general be only a few calls to the sort function. The only case this
 * penalty will be significant is if the array is mostly sorted but there are
 * a few unsorted items near the end, but the penalty is still at most N calls
 * out of (for N=1e6) ~20N total calls
 *
 * @param {Array} array: the array, to be sorted in place
 * @param {function} sortFn: As in Array.sort, function(a, b) that puts
 *     item a before item b if the return is negative, a after b if positive,
 *     and no change if zero.
 * @return {Array}: the original array, sorted in place.
 */
exports.sort = function (array, sortFn) {
  var notOrdered = 0;
  var notReversed = 0;
  for (var i = 1; i < array.length; i++) {
    var pairOrder = sortFn(array[i], array[i - 1]);
    if (pairOrder < 0) notOrdered = 1;else if (pairOrder > 0) notReversed = 1;
    if (notOrdered && notReversed) return array.sort(sortFn);
  }
  return notReversed ? array : array.reverse();
};

/**
 * find index in array 'arr' that minimizes 'fn'
 *
 * @param {array} arr : array where to search
 * @param {fn (optional)} fn : function to minimize,
 *   if not given, fn is the identity function
 * @return {integer}
 */
exports.findIndexOfMin = function (arr, fn) {
  fn = fn || identity;
  var min = Infinity;
  var ind;
  for (var i = 0; i < arr.length; i++) {
    var v = fn(arr[i]);
    if (v < min) {
      min = v;
      ind = i;
    }
  }
  return ind;
};

/***/ }),

/***/ 6964:
/***/ (function(module) {

"use strict";


// works with our CSS cursor classes (see css/_cursor.scss)
// to apply cursors to d3 single-element selections.
// omit cursor to revert to the default.
module.exports = function setCursor(el3, csr) {
  (el3.attr('class') || '').split(' ').forEach(function (cls) {
    if (cls.indexOf('cursor-') === 0) el3.classed(cls, false);
  });
  if (csr) el3.classed('cursor-' + csr, true);
};

/***/ }),

/***/ 8617:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Color = __webpack_require__(7901);
var noop = function () {};

/**
 * Prints a no webgl error message into the scene container
 * @param {scene instance} scene
 *
 * Expects 'scene' to have property 'container'
 *
 */
module.exports = function showNoWebGlMsg(scene) {
  for (var prop in scene) {
    if (typeof scene[prop] === 'function') scene[prop] = noop;
  }
  scene.destroy = function () {
    scene.container.parentNode.removeChild(scene.container);
  };
  var div = document.createElement('div');
  div.className = 'no-webgl';
  div.style.cursor = 'pointer';
  div.style.fontSize = '24px';
  div.style.color = Color.defaults[0];
  div.style.position = 'absolute';
  div.style.left = div.style.top = '0px';
  div.style.width = div.style.height = '100%';
  div.style['background-color'] = Color.lightLine;
  div.style['z-index'] = 30;
  var p = document.createElement('p');
  p.textContent = 'WebGL is not supported by your browser - visit https://get.webgl.org for more info';
  p.style.position = 'relative';
  p.style.top = '50%';
  p.style.left = '50%';
  p.style.height = '30%';
  p.style.width = '50%';
  p.style.margin = '-15% 0 0 -25%';
  div.appendChild(p);
  scene.container.appendChild(div);
  scene.container.style.background = '#FFFFFF';
  scene.container.onclick = function () {
    window.open('https://get.webgl.org');
  };

  // return before setting up camera and onrender methods
  return false;
};

/***/ }),

/***/ 8607:
/***/ (function(module) {

"use strict";


module.exports = function sortObjectKeys(obj) {
  return Object.keys(obj).sort();
};

/***/ }),

/***/ 38:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var isArrayOrTypedArray = (__webpack_require__(3627).isArrayOrTypedArray);

/**
 * aggNums() returns the result of an aggregate function applied to an array of
 * values, where non-numerical values have been tossed out.
 *
 * @param {function} f - aggregation function (e.g., Math.min)
 * @param {Number} v - initial value (continuing from previous calls)
 *      if there's no continuing value, use null for selector-type
 *      functions (max,min), or 0 for summations
 * @param {Array} a - array to aggregate (may be nested, we will recurse,
 *                    but all elements must have the same dimension)
 * @param {Number} len - maximum length of a to aggregate
 * @return {Number} - result of f applied to a starting from v
 */
exports.aggNums = function (f, v, a, len) {
  var i, b;
  if (!len || len > a.length) len = a.length;
  if (!isNumeric(v)) v = false;
  if (isArrayOrTypedArray(a[0])) {
    b = new Array(len);
    for (i = 0; i < len; i++) b[i] = exports.aggNums(f, v, a[i]);
    a = b;
  }
  for (i = 0; i < len; i++) {
    if (!isNumeric(v)) v = a[i];else if (isNumeric(a[i])) v = f(+v, +a[i]);
  }
  return v;
};

/**
 * mean & std dev functions using aggNums, so it handles non-numerics nicely
 * even need to use aggNums instead of .length, to toss out non-numerics
 */
exports.len = function (data) {
  return exports.aggNums(function (a) {
    return a + 1;
  }, 0, data);
};
exports.mean = function (data, len) {
  if (!len) len = exports.len(data);
  return exports.aggNums(function (a, b) {
    return a + b;
  }, 0, data) / len;
};
exports.midRange = function (numArr) {
  if (numArr === undefined || numArr.length === 0) return undefined;
  return (exports.aggNums(Math.max, null, numArr) + exports.aggNums(Math.min, null, numArr)) / 2;
};
exports.variance = function (data, len, mean) {
  if (!len) len = exports.len(data);
  if (!isNumeric(mean)) mean = exports.mean(data, len);
  return exports.aggNums(function (a, b) {
    return a + Math.pow(b - mean, 2);
  }, 0, data) / len;
};
exports.stdev = function (data, len, mean) {
  return Math.sqrt(exports.variance(data, len, mean));
};

/**
 * median of a finite set of numbers
 * reference page: https://en.wikipedia.org/wiki/Median#Finite_set_of_numbers
**/
exports.median = function (data) {
  var b = data.slice().sort();
  return exports.interp(b, 0.5);
};

/**
 * interp() computes a percentile (quantile) for a given distribution.
 * We interpolate the distribution (to compute quantiles, we follow method #10 here:
 * http://jse.amstat.org/v14n3/langford.html).
 * Typically the index or rank (n * arr.length) may be non-integer.
 * For reference: ends are clipped to the extreme values in the array;
 * For box plots: index you get is half a point too high (see
 * http://en.wikipedia.org/wiki/Percentile#Nearest_rank) but note that this definition
 * indexes from 1 rather than 0, so we subtract 1/2 (instead of add).
 *
 * @param {Array} arr - This array contains the values that make up the distribution.
 * @param {Number} n - Between 0 and 1, n = p/100 is such that we compute the p^th percentile.
 * For example, the 50th percentile (or median) corresponds to n = 0.5
 * @return {Number} - percentile
 */
exports.interp = function (arr, n) {
  if (!isNumeric(n)) throw 'n should be a finite number';
  n = n * arr.length - 0.5;
  if (n < 0) return arr[0];
  if (n > arr.length - 1) return arr[arr.length - 1];
  var frac = n % 1;
  return frac * arr[Math.ceil(n)] + (1 - frac) * arr[Math.floor(n)];
};

/***/ }),

/***/ 8614:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var rgba = __webpack_require__(5075);
function str2RgbaArray(color) {
  if (!color) return [0, 0, 0, 1];
  return rgba(color);
}
module.exports = str2RgbaArray;

/***/ }),

/***/ 3893:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


/* global MathJax:false */
var d3 = __webpack_require__(9898);
var Lib = __webpack_require__(1828);
var strTranslate = Lib.strTranslate;
var xmlnsNamespaces = __webpack_require__(7922);
var LINE_SPACING = (__webpack_require__(8783).LINE_SPACING);

// text converter

var FIND_TEX = /([^$]*)([$]+[^$]*[$]+)([^$]*)/;
exports.convertToTspans = function (_context, gd, _callback) {
  var str = _context.text();

  // Until we get tex integrated more fully (so it can be used along with non-tex)
  // allow some elements to prohibit it by attaching 'data-notex' to the original
  var tex = !_context.attr('data-notex') && gd && gd._context.typesetMath && typeof MathJax !== 'undefined' && str.match(FIND_TEX);
  var parent = d3.select(_context.node().parentNode);
  if (parent.empty()) return;
  var svgClass = _context.attr('class') ? _context.attr('class').split(' ')[0] : 'text';
  svgClass += '-math';
  parent.selectAll('svg.' + svgClass).remove();
  parent.selectAll('g.' + svgClass + '-group').remove();
  _context.style('display', null).attr({
    // some callers use data-unformatted *from the <text> element* in 'cancel'
    // so we need it here even if we're going to turn it into math
    // these two (plus style and text-anchor attributes) form the key we're
    // going to use for Drawing.bBox
    'data-unformatted': str,
    'data-math': 'N'
  });
  function showText() {
    if (!parent.empty()) {
      svgClass = _context.attr('class') + '-math';
      parent.select('svg.' + svgClass).remove();
    }
    _context.text('').style('white-space', 'pre');
    var hasLink = buildSVGText(_context.node(), str);
    if (hasLink) {
      // at least in Chrome, pointer-events does not seem
      // to be honored in children of <text> elements
      // so if we have an anchor, we have to make the
      // whole element respond
      _context.style('pointer-events', 'all');
    }
    exports.positionText(_context);
    if (_callback) _callback.call(_context);
  }
  if (tex) {
    (gd && gd._promises || []).push(new Promise(function (resolve) {
      _context.style('display', 'none');
      var fontSize = parseInt(_context.node().style.fontSize, 10);
      var config = {
        fontSize: fontSize
      };
      texToSVG(tex[2], config, function (_svgEl, _glyphDefs, _svgBBox) {
        parent.selectAll('svg.' + svgClass).remove();
        parent.selectAll('g.' + svgClass + '-group').remove();
        var newSvg = _svgEl && _svgEl.select('svg');
        if (!newSvg || !newSvg.node()) {
          showText();
          resolve();
          return;
        }
        var mathjaxGroup = parent.append('g').classed(svgClass + '-group', true).attr({
          'pointer-events': 'none',
          'data-unformatted': str,
          'data-math': 'Y'
        });
        mathjaxGroup.node().appendChild(newSvg.node());

        // stitch the glyph defs
        if (_glyphDefs && _glyphDefs.node()) {
          newSvg.node().insertBefore(_glyphDefs.node().cloneNode(true), newSvg.node().firstChild);
        }
        var w0 = _svgBBox.width;
        var h0 = _svgBBox.height;
        newSvg.attr({
          class: svgClass,
          height: h0,
          preserveAspectRatio: 'xMinYMin meet'
        }).style({
          overflow: 'visible',
          'pointer-events': 'none'
        });
        var fill = _context.node().style.fill || 'black';
        var g = newSvg.select('g');
        g.attr({
          fill: fill,
          stroke: fill
        });
        var bb = g.node().getBoundingClientRect();
        var w = bb.width;
        var h = bb.height;
        if (w > w0 || h > h0) {
          // this happen in firefox v82+ | see https://bugzilla.mozilla.org/show_bug.cgi?id=1709251 addressed
          // temporary fix:
          newSvg.style('overflow', 'hidden');
          bb = newSvg.node().getBoundingClientRect();
          w = bb.width;
          h = bb.height;
        }
        var x = +_context.attr('x');
        var y = +_context.attr('y');

        // font baseline is about 1/4 fontSize below centerline
        var textHeight = fontSize || _context.node().getBoundingClientRect().height;
        var dy = -textHeight / 4;
        if (svgClass[0] === 'y') {
          mathjaxGroup.attr({
            transform: 'rotate(' + [-90, x, y] + ')' + strTranslate(-w / 2, dy - h / 2)
          });
        } else if (svgClass[0] === 'l') {
          y = dy - h / 2;
        } else if (svgClass[0] === 'a' && svgClass.indexOf('atitle') !== 0) {
          x = 0;
          y = dy;
        } else {
          var anchor = _context.attr('text-anchor');
          x = x - w * (anchor === 'middle' ? 0.5 : anchor === 'end' ? 1 : 0);
          y = y + dy - h / 2;
        }
        newSvg.attr({
          x: x,
          y: y
        });
        if (_callback) _callback.call(_context, mathjaxGroup);
        resolve(mathjaxGroup);
      });
    }));
  } else showText();
  return _context;
};

// MathJax

var LT_MATCH = /(<|&lt;|&#60;)/g;
var GT_MATCH = /(>|&gt;|&#62;)/g;
function cleanEscapesForTex(s) {
  return s.replace(LT_MATCH, '\\lt ').replace(GT_MATCH, '\\gt ');
}
var inlineMath = [['$', '$'], ['\\(', '\\)']];
function texToSVG(_texString, _config, _callback) {
  var MathJaxVersion = parseInt((MathJax.version || '').split('.')[0]);
  if (MathJaxVersion !== 2 && MathJaxVersion !== 3) {
    Lib.warn('No MathJax version:', MathJax.version);
    return;
  }
  var originalRenderer, originalConfig, originalProcessSectionDelay, tmpDiv;
  var setConfig2 = function () {
    originalConfig = Lib.extendDeepAll({}, MathJax.Hub.config);
    originalProcessSectionDelay = MathJax.Hub.processSectionDelay;
    if (MathJax.Hub.processSectionDelay !== undefined) {
      // MathJax 2.5+ but not 3+
      MathJax.Hub.processSectionDelay = 0;
    }
    return MathJax.Hub.Config({
      messageStyle: 'none',
      tex2jax: {
        inlineMath: inlineMath
      },
      displayAlign: 'left'
    });
  };
  var setConfig3 = function () {
    originalConfig = Lib.extendDeepAll({}, MathJax.config);
    if (!MathJax.config.tex) {
      MathJax.config.tex = {};
    }
    MathJax.config.tex.inlineMath = inlineMath;
  };
  var setRenderer2 = function () {
    originalRenderer = MathJax.Hub.config.menuSettings.renderer;
    if (originalRenderer !== 'SVG') {
      return MathJax.Hub.setRenderer('SVG');
    }
  };
  var setRenderer3 = function () {
    originalRenderer = MathJax.config.startup.output;
    if (originalRenderer !== 'svg') {
      MathJax.config.startup.output = 'svg';
    }
  };
  var initiateMathJax = function () {
    var randomID = 'math-output-' + Lib.randstr({}, 64);
    tmpDiv = d3.select('body').append('div').attr({
      id: randomID
    }).style({
      visibility: 'hidden',
      position: 'absolute',
      'font-size': _config.fontSize + 'px'
    }).text(cleanEscapesForTex(_texString));
    var tmpNode = tmpDiv.node();
    return MathJaxVersion === 2 ? MathJax.Hub.Typeset(tmpNode) : MathJax.typeset([tmpNode]);
  };
  var finalizeMathJax = function () {
    var sel = tmpDiv.select(MathJaxVersion === 2 ? '.MathJax_SVG' : '.MathJax');
    var node = !sel.empty() && tmpDiv.select('svg').node();
    if (!node) {
      Lib.log('There was an error in the tex syntax.', _texString);
      _callback();
    } else {
      var nodeBBox = node.getBoundingClientRect();
      var glyphDefs;
      if (MathJaxVersion === 2) {
        glyphDefs = d3.select('body').select('#MathJax_SVG_glyphs');
      } else {
        glyphDefs = sel.select('defs');
      }
      _callback(sel, glyphDefs, nodeBBox);
    }
    tmpDiv.remove();
  };
  var resetRenderer2 = function () {
    if (originalRenderer !== 'SVG') {
      return MathJax.Hub.setRenderer(originalRenderer);
    }
  };
  var resetRenderer3 = function () {
    if (originalRenderer !== 'svg') {
      MathJax.config.startup.output = originalRenderer;
    }
  };
  var resetConfig2 = function () {
    if (originalProcessSectionDelay !== undefined) {
      MathJax.Hub.processSectionDelay = originalProcessSectionDelay;
    }
    return MathJax.Hub.Config(originalConfig);
  };
  var resetConfig3 = function () {
    MathJax.config = originalConfig;
  };
  if (MathJaxVersion === 2) {
    MathJax.Hub.Queue(setConfig2, setRenderer2, initiateMathJax, finalizeMathJax, resetRenderer2, resetConfig2);
  } else if (MathJaxVersion === 3) {
    setConfig3();
    setRenderer3();
    MathJax.startup.defaultReady();
    MathJax.startup.promise.then(function () {
      initiateMathJax();
      finalizeMathJax();
      resetRenderer3();
      resetConfig3();
    });
  }
}
var TAG_STYLES = {
  // would like to use baseline-shift for sub/sup but FF doesn't support it
  // so we need to use dy along with the uber hacky shift-back-to
  // baseline below
  sup: 'font-size:70%',
  sub: 'font-size:70%',
  b: 'font-weight:bold',
  i: 'font-style:italic',
  a: 'cursor:pointer',
  span: '',
  em: 'font-style:italic;font-weight:bold'
};

// baseline shifts for sub and sup
var SHIFT_DY = {
  sub: '0.3em',
  sup: '-0.6em'
};
// reset baseline by adding a tspan (empty except for a zero-width space)
// with dy of -70% * SHIFT_DY (because font-size=70%)
var RESET_DY = {
  sub: '-0.21em',
  sup: '0.42em'
};
var ZERO_WIDTH_SPACE = '\u200b';

/*
 * Whitelist of protocols in user-supplied urls. Mostly we want to avoid javascript
 * and related attack vectors. The empty items are there for IE, that in various
 * versions treats relative paths as having different flavors of no protocol, while
 * other browsers have these explicitly inherit the protocol of the page they're in.
 */
var PROTOCOLS = ['http:', 'https:', 'mailto:', '', undefined, ':'];
var NEWLINES = exports.NEWLINES = /(\r\n?|\n)/g;
var SPLIT_TAGS = /(<[^<>]*>)/;
var ONE_TAG = /<(\/?)([^ >]*)(\s+(.*))?>/i;
var BR_TAG = /<br(\s+.*)?>/i;
exports.BR_TAG_ALL = /<br(\s+.*)?>/gi;

/*
 * style and href: pull them out of either single or double quotes. Also
 * - target: (_blank|_self|_parent|_top|framename)
 *     note that you can't use target to get a popup but if you use popup,
 *     a `framename` will be passed along as the name of the popup window.
 *     per the spec, cannot contain whitespace.
 *     for backward compatibility we default to '_blank'
 * - popup: a custom one for us to enable popup (new window) links. String
 *     for window.open -> strWindowFeatures, like 'menubar=yes,width=500,height=550'
 *     note that at least in Chrome, you need to give at least one property
 *     in this string or the page will open in a new tab anyway. We follow this
 *     convention and will not make a popup if this string is empty.
 *     per the spec, cannot contain whitespace.
 *
 * Because we hack in other attributes with style (sub & sup), drop any trailing
 * semicolon in user-supplied styles so we can consistently append the tag-dependent style
 *
 * These are for tag attributes; Chrome anyway will convert entities in
 * attribute values, but not in attribute names
 * you can test this by for example:
 * > p = document.createElement('p')
 * > p.innerHTML = '<span styl&#x65;="font-color:r&#x65;d;">Hi</span>'
 * > p.innerHTML
 * <- '<span styl&#x65;="font-color:red;">Hi</span>'
 */
var STYLEMATCH = /(^|[\s"'])style\s*=\s*("([^"]*);?"|'([^']*);?')/i;
var HREFMATCH = /(^|[\s"'])href\s*=\s*("([^"]*)"|'([^']*)')/i;
var TARGETMATCH = /(^|[\s"'])target\s*=\s*("([^"\s]*)"|'([^'\s]*)')/i;
var POPUPMATCH = /(^|[\s"'])popup\s*=\s*("([\w=,]*)"|'([\w=,]*)')/i;

// dedicated matcher for these quoted regexes, that can return their results
// in two different places
function getQuotedMatch(_str, re) {
  if (!_str) return null;
  var match = _str.match(re);
  var result = match && (match[3] || match[4]);
  return result && convertEntities(result);
}
var COLORMATCH = /(^|;)\s*color:/;

/**
 * Strip string of tags
 *
 * @param {string} _str : input string
 * @param {object} opts :
 * - len {number} max length of output string
 * - allowedTags {array} list of pseudo-html tags to NOT strip
 * @return {string}
 */
exports.plainText = function (_str, opts) {
  opts = opts || {};
  var len = opts.len !== undefined && opts.len !== -1 ? opts.len : Infinity;
  var allowedTags = opts.allowedTags !== undefined ? opts.allowedTags : ['br'];
  var ellipsis = '...';
  var eLen = ellipsis.length;
  var oldParts = _str.split(SPLIT_TAGS);
  var newParts = [];
  var prevTag = '';
  var l = 0;
  for (var i = 0; i < oldParts.length; i++) {
    var p = oldParts[i];
    var match = p.match(ONE_TAG);
    var tagType = match && match[2].toLowerCase();
    if (tagType) {
      // N.B. tags do not count towards string length
      if (allowedTags.indexOf(tagType) !== -1) {
        newParts.push(p);
        prevTag = tagType;
      }
    } else {
      var pLen = p.length;
      if (l + pLen < len) {
        newParts.push(p);
        l += pLen;
      } else if (l < len) {
        var pLen2 = len - l;
        if (prevTag && (prevTag !== 'br' || pLen2 <= eLen || pLen <= eLen)) {
          newParts.pop();
        }
        if (len > eLen) {
          newParts.push(p.substr(0, pLen2 - eLen) + ellipsis);
        } else {
          newParts.push(p.substr(0, pLen2));
        }
        break;
      }
      prevTag = '';
    }
  }
  return newParts.join('');
};

/*
 * N.B. HTML entities are listed without the leading '&' and trailing ';'
 * https://www.freeformatter.com/html-entities.html
 *
 * FWIW if we wanted to support the full set, it has 2261 entries:
 * https://www.w3.org/TR/html5/entities.json
 * though I notice that some of these are duplicates and/or are missing ";"
 * eg: "&amp;", "&amp", "&AMP;", and "&AMP" all map to "&"
 * We no longer need to include numeric entities here, these are now handled
 * by String.fromCodePoint/fromCharCode
 *
 * Anyway the only ones that are really important to allow are the HTML special
 * chars <, >, and &, because these ones can trigger special processing if not
 * replaced by the corresponding entity.
 */
var entityToUnicode = {
  mu: 'μ',
  amp: '&',
  lt: '<',
  gt: '>',
  nbsp: ' ',
  times: '×',
  plusmn: '±',
  deg: '°'
};

// NOTE: in general entities can contain uppercase too (so [a-zA-Z]) but all the
// ones we support use only lowercase. If we ever change that, update the regex.
var ENTITY_MATCH = /&(#\d+|#x[\da-fA-F]+|[a-z]+);/g;
function convertEntities(_str) {
  return _str.replace(ENTITY_MATCH, function (fullMatch, innerMatch) {
    var outChar;
    if (innerMatch.charAt(0) === '#') {
      // cannot use String.fromCodePoint in IE
      outChar = fromCodePoint(innerMatch.charAt(1) === 'x' ? parseInt(innerMatch.substr(2), 16) : parseInt(innerMatch.substr(1), 10));
    } else outChar = entityToUnicode[innerMatch];

    // as in regular HTML, if we didn't decode the entity just
    // leave the raw text in place.
    return outChar || fullMatch;
  });
}
exports.convertEntities = convertEntities;
function fromCodePoint(code) {
  // Don't allow overflow. In Chrome this turns into � but I feel like it's
  // more useful to just not convert it at all.
  if (code > 0x10FFFF) return;
  var stringFromCodePoint = String.fromCodePoint;
  if (stringFromCodePoint) return stringFromCodePoint(code);

  // IE doesn't have String.fromCodePoint
  // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint
  var stringFromCharCode = String.fromCharCode;
  if (code <= 0xFFFF) return stringFromCharCode(code);
  return stringFromCharCode((code >> 10) + 0xD7C0, code % 0x400 + 0xDC00);
}

/*
 * buildSVGText: convert our pseudo-html into SVG tspan elements, and attach these
 * to containerNode
 *
 * @param {svg text element} containerNode: the <text> node to insert this text into
 * @param {string} str: the pseudo-html string to convert to svg
 *
 * @returns {bool}: does the result contain any links? We need to handle the text element
 *   somewhat differently if it does, so just keep track of this when it happens.
 */
function buildSVGText(containerNode, str) {
  /*
   * Normalize behavior between IE and others wrt newlines and whitespace:pre
   * this combination makes IE barf https://github.com/plotly/plotly.js/issues/746
   * Chrome and FF display \n, \r, or \r\n as a space in this mode.
   * I feel like at some point we turned these into <br> but currently we don't so
   * I'm just going to cement what we do now in Chrome and FF
   */
  str = str.replace(NEWLINES, ' ');
  var hasLink = false;

  // as we're building the text, keep track of what elements we're nested inside
  // nodeStack will be an array of {node, type, style, href, target, popup}
  // where only type: 'a' gets the last 3 and node is only added when it's created
  var nodeStack = [];
  var currentNode;
  var currentLine = -1;
  function newLine() {
    currentLine++;
    var lineNode = document.createElementNS(xmlnsNamespaces.svg, 'tspan');
    d3.select(lineNode).attr({
      class: 'line',
      dy: currentLine * LINE_SPACING + 'em'
    });
    containerNode.appendChild(lineNode);
    currentNode = lineNode;
    var oldNodeStack = nodeStack;
    nodeStack = [{
      node: lineNode
    }];
    if (oldNodeStack.length > 1) {
      for (var i = 1; i < oldNodeStack.length; i++) {
        enterNode(oldNodeStack[i]);
      }
    }
  }
  function enterNode(nodeSpec) {
    var type = nodeSpec.type;
    var nodeAttrs = {};
    var nodeType;
    if (type === 'a') {
      nodeType = 'a';
      var target = nodeSpec.target;
      var href = nodeSpec.href;
      var popup = nodeSpec.popup;
      if (href) {
        nodeAttrs = {
          'xlink:xlink:show': target === '_blank' || target.charAt(0) !== '_' ? 'new' : 'replace',
          target: target,
          'xlink:xlink:href': href
        };
        if (popup) {
          // security: href and target are not inserted as code but
          // as attributes. popup is, but limited to /[A-Za-z0-9_=,]/
          nodeAttrs.onclick = 'window.open(this.href.baseVal,this.target.baseVal,"' + popup + '");return false;';
        }
      }
    } else nodeType = 'tspan';
    if (nodeSpec.style) nodeAttrs.style = nodeSpec.style;
    var newNode = document.createElementNS(xmlnsNamespaces.svg, nodeType);
    if (type === 'sup' || type === 'sub') {
      addTextNode(currentNode, ZERO_WIDTH_SPACE);
      currentNode.appendChild(newNode);
      var resetter = document.createElementNS(xmlnsNamespaces.svg, 'tspan');
      addTextNode(resetter, ZERO_WIDTH_SPACE);
      d3.select(resetter).attr('dy', RESET_DY[type]);
      nodeAttrs.dy = SHIFT_DY[type];
      currentNode.appendChild(newNode);
      currentNode.appendChild(resetter);
    } else {
      currentNode.appendChild(newNode);
    }
    d3.select(newNode).attr(nodeAttrs);
    currentNode = nodeSpec.node = newNode;
    nodeStack.push(nodeSpec);
  }
  function addTextNode(node, text) {
    node.appendChild(document.createTextNode(text));
  }
  function exitNode(type) {
    // A bare closing tag can't close the root node. If we encounter this it
    // means there's an extra closing tag that can just be ignored:
    if (nodeStack.length === 1) {
      Lib.log('Ignoring unexpected end tag </' + type + '>.', str);
      return;
    }
    var innerNode = nodeStack.pop();
    if (type !== innerNode.type) {
      Lib.log('Start tag <' + innerNode.type + '> doesnt match end tag <' + type + '>. Pretending it did match.', str);
    }
    currentNode = nodeStack[nodeStack.length - 1].node;
  }
  var hasLines = BR_TAG.test(str);
  if (hasLines) newLine();else {
    currentNode = containerNode;
    nodeStack = [{
      node: containerNode
    }];
  }
  var parts = str.split(SPLIT_TAGS);
  for (var i = 0; i < parts.length; i++) {
    var parti = parts[i];
    var match = parti.match(ONE_TAG);
    var tagType = match && match[2].toLowerCase();
    var tagStyle = TAG_STYLES[tagType];
    if (tagType === 'br') {
      newLine();
    } else if (tagStyle === undefined) {
      addTextNode(currentNode, convertEntities(parti));
    } else {
      // tag - open or close
      if (match[1]) {
        exitNode(tagType);
      } else {
        var extra = match[4];
        var nodeSpec = {
          type: tagType
        };

        // now add style, from both the tag name and any extra css
        // Most of the svg css that users will care about is just like html,
        // but font color is different (uses fill). Let our users ignore this.
        var css = getQuotedMatch(extra, STYLEMATCH);
        if (css) {
          css = css.replace(COLORMATCH, '$1 fill:');
          if (tagStyle) css += ';' + tagStyle;
        } else if (tagStyle) css = tagStyle;
        if (css) nodeSpec.style = css;
        if (tagType === 'a') {
          hasLink = true;
          var href = getQuotedMatch(extra, HREFMATCH);
          if (href) {
            var safeHref = sanitizeHref(href);
            if (safeHref) {
              nodeSpec.href = safeHref;
              nodeSpec.target = getQuotedMatch(extra, TARGETMATCH) || '_blank';
              nodeSpec.popup = getQuotedMatch(extra, POPUPMATCH);
            }
          }
        }
        enterNode(nodeSpec);
      }
    }
  }
  return hasLink;
}
function sanitizeHref(href) {
  var decodedHref = encodeURI(decodeURI(href));
  var dummyAnchor1 = document.createElement('a');
  var dummyAnchor2 = document.createElement('a');
  dummyAnchor1.href = href;
  dummyAnchor2.href = decodedHref;
  var p1 = dummyAnchor1.protocol;
  var p2 = dummyAnchor2.protocol;

  // check safe protocols
  if (PROTOCOLS.indexOf(p1) !== -1 && PROTOCOLS.indexOf(p2) !== -1) {
    return decodedHref;
  } else {
    return '';
  }
}

/*
 * sanitizeHTML: port of buildSVGText aimed at providing a clean subset of HTML
 * @param {string} str: the html string to clean
 * @returns {string}: a cleaned and normalized version of the input,
 *     supporting only a small subset of html
 */
exports.sanitizeHTML = function sanitizeHTML(str) {
  str = str.replace(NEWLINES, ' ');
  var rootNode = document.createElement('p');
  var currentNode = rootNode;
  var nodeStack = [];
  var parts = str.split(SPLIT_TAGS);
  for (var i = 0; i < parts.length; i++) {
    var parti = parts[i];
    var match = parti.match(ONE_TAG);
    var tagType = match && match[2].toLowerCase();
    if (tagType in TAG_STYLES) {
      if (match[1]) {
        if (nodeStack.length) {
          currentNode = nodeStack.pop();
        }
      } else {
        var extra = match[4];
        var css = getQuotedMatch(extra, STYLEMATCH);
        var nodeAttrs = css ? {
          style: css
        } : {};
        if (tagType === 'a') {
          var href = getQuotedMatch(extra, HREFMATCH);
          if (href) {
            var safeHref = sanitizeHref(href);
            if (safeHref) {
              nodeAttrs.href = safeHref;
              var target = getQuotedMatch(extra, TARGETMATCH);
              if (target) {
                nodeAttrs.target = target;
              }
            }
          }
        }
        var newNode = document.createElement(tagType);
        currentNode.appendChild(newNode);
        d3.select(newNode).attr(nodeAttrs);
        currentNode = newNode;
        nodeStack.push(newNode);
      }
    } else {
      currentNode.appendChild(document.createTextNode(convertEntities(parti)));
    }
  }
  var key = 'innerHTML'; // i.e. to avoid pass test-syntax
  return rootNode[key];
};
exports.lineCount = function lineCount(s) {
  return s.selectAll('tspan.line').size() || 1;
};
exports.positionText = function positionText(s, x, y) {
  return s.each(function () {
    var text = d3.select(this);
    function setOrGet(attr, val) {
      if (val === undefined) {
        val = text.attr(attr);
        if (val === null) {
          text.attr(attr, 0);
          val = 0;
        }
      } else text.attr(attr, val);
      return val;
    }
    var thisX = setOrGet('x', x);
    var thisY = setOrGet('y', y);
    if (this.nodeName === 'text') {
      text.selectAll('tspan.line').attr({
        x: thisX,
        y: thisY
      });
    }
  });
};
function alignHTMLWith(_base, container, options) {
  var alignH = options.horizontalAlign;
  var alignV = options.verticalAlign || 'top';
  var bRect = _base.node().getBoundingClientRect();
  var cRect = container.node().getBoundingClientRect();
  var thisRect;
  var getTop;
  var getLeft;
  if (alignV === 'bottom') {
    getTop = function () {
      return bRect.bottom - thisRect.height;
    };
  } else if (alignV === 'middle') {
    getTop = function () {
      return bRect.top + (bRect.height - thisRect.height) / 2;
    };
  } else {
    // default: top
    getTop = function () {
      return bRect.top;
    };
  }
  if (alignH === 'right') {
    getLeft = function () {
      return bRect.right - thisRect.width;
    };
  } else if (alignH === 'center') {
    getLeft = function () {
      return bRect.left + (bRect.width - thisRect.width) / 2;
    };
  } else {
    // default: left
    getLeft = function () {
      return bRect.left;
    };
  }
  return function () {
    thisRect = this.node().getBoundingClientRect();
    var x0 = getLeft() - cRect.left;
    var y0 = getTop() - cRect.top;
    var gd = options.gd || {};
    if (options.gd) {
      gd._fullLayout._calcInverseTransform(gd);
      var transformedCoords = Lib.apply3DTransform(gd._fullLayout._invTransform)(x0, y0);
      x0 = transformedCoords[0];
      y0 = transformedCoords[1];
    }
    this.style({
      top: y0 + 'px',
      left: x0 + 'px',
      'z-index': 1000
    });
    return this;
  };
}
var onePx = '1px ';
exports.makeTextShadow = function (color) {
  var x = onePx;
  var y = onePx;
  var b = onePx;
  return x + y + b + color + ', ' + '-' + x + '-' + y + b + color + ', ' + x + '-' + y + b + color + ', ' + '-' + x + y + b + color;
};

/*
 * Editable title
 * @param {d3.selection} context: the element being edited. Normally text,
 *   but if it isn't, you should provide the styling options
 * @param {object} options:
 *   @param {div} options.gd: graphDiv
 *   @param {d3.selection} options.delegate: item to bind events to if not this
 *   @param {boolean} options.immediate: start editing now (true) or on click (false, default)
 *   @param {string} options.fill: font color if not as shown
 *   @param {string} options.background: background color if not as shown
 *   @param {string} options.text: initial text, if not as shown
 *   @param {string} options.horizontalAlign: alignment of the edit box wrt. the bound element
 *   @param {string} options.verticalAlign: alignment of the edit box wrt. the bound element
 */

exports.makeEditable = function (context, options) {
  var gd = options.gd;
  var _delegate = options.delegate;
  var dispatch = d3.dispatch('edit', 'input', 'cancel');
  var handlerElement = _delegate || context;
  context.style({
    'pointer-events': _delegate ? 'none' : 'all'
  });
  if (context.size() !== 1) throw new Error('boo');
  function handleClick() {
    appendEditable();
    context.style({
      opacity: 0
    });
    // also hide any mathjax svg
    var svgClass = handlerElement.attr('class');
    var mathjaxClass;
    if (svgClass) mathjaxClass = '.' + svgClass.split(' ')[0] + '-math-group';else mathjaxClass = '[class*=-math-group]';
    if (mathjaxClass) {
      d3.select(context.node().parentNode).select(mathjaxClass).style({
        opacity: 0
      });
    }
  }
  function selectElementContents(_el) {
    var el = _el.node();
    var range = document.createRange();
    range.selectNodeContents(el);
    var sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
    el.focus();
  }
  function appendEditable() {
    var plotDiv = d3.select(gd);
    var container = plotDiv.select('.svg-container');
    var div = container.append('div');
    var cStyle = context.node().style;
    var fontSize = parseFloat(cStyle.fontSize || 12);
    var initialText = options.text;
    if (initialText === undefined) initialText = context.attr('data-unformatted');
    div.classed('plugin-editable editable', true).style({
      position: 'absolute',
      'font-family': cStyle.fontFamily || 'Arial',
      'font-size': fontSize,
      color: options.fill || cStyle.fill || 'black',
      opacity: 1,
      'background-color': options.background || 'transparent',
      outline: '#ffffff33 1px solid',
      margin: [-fontSize / 8 + 1, 0, 0, -1].join('px ') + 'px',
      padding: '0',
      'box-sizing': 'border-box'
    }).attr({
      contenteditable: true
    }).text(initialText).call(alignHTMLWith(context, container, options)).on('blur', function () {
      gd._editing = false;
      context.text(this.textContent).style({
        opacity: 1
      });
      var svgClass = d3.select(this).attr('class');
      var mathjaxClass;
      if (svgClass) mathjaxClass = '.' + svgClass.split(' ')[0] + '-math-group';else mathjaxClass = '[class*=-math-group]';
      if (mathjaxClass) {
        d3.select(context.node().parentNode).select(mathjaxClass).style({
          opacity: 0
        });
      }
      var text = this.textContent;
      d3.select(this).transition().duration(0).remove();
      d3.select(document).on('mouseup', null);
      dispatch.edit.call(context, text);
    }).on('focus', function () {
      var editDiv = this;
      gd._editing = true;
      d3.select(document).on('mouseup', function () {
        if (d3.event.target === editDiv) return false;
        if (document.activeElement === div.node()) div.node().blur();
      });
    }).on('keyup', function () {
      if (d3.event.which === 27) {
        gd._editing = false;
        context.style({
          opacity: 1
        });
        d3.select(this).style({
          opacity: 0
        }).on('blur', function () {
          return false;
        }).transition().remove();
        dispatch.cancel.call(context, this.textContent);
      } else {
        dispatch.input.call(context, this.textContent);
        d3.select(this).call(alignHTMLWith(context, container, options));
      }
    }).on('keydown', function () {
      if (d3.event.which === 13) this.blur();
    }).call(selectElementContents);
  }
  if (options.immediate) handleClick();else handlerElement.on('click', handleClick);
  return d3.rebind(context, dispatch, 'on');
};

/***/ }),

/***/ 9990:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


var timerCache = {};

/**
 * Throttle a callback. `callback` executes synchronously only if
 * more than `minInterval` milliseconds have already elapsed since the latest
 * call (if any). Otherwise we wait until `minInterval` is over and execute the
 * last callback received while waiting.
 * So the first and last events in a train are always executed (eventually)
 * but some of the events in the middle can be dropped.
 *
 * @param {string} id: an identifier to mark events to throttle together
 * @param {number} minInterval: minimum time, in milliseconds, between
 *   invocations of `callback`
 * @param {function} callback: the function to throttle. `callback` itself
 *   should be a purely synchronous function.
 */
exports.throttle = function throttle(id, minInterval, callback) {
  var cache = timerCache[id];
  var now = Date.now();
  if (!cache) {
    /*
     * Throw out old items before making a new one, to prevent the cache
     * getting overgrown, for example from old plots that have been replaced.
     * 1 minute age is arbitrary.
     */
    for (var idi in timerCache) {
      if (timerCache[idi].ts < now - 60000) {
        delete timerCache[idi];
      }
    }
    cache = timerCache[id] = {
      ts: 0,
      timer: null
    };
  }
  _clearTimeout(cache);
  function exec() {
    callback();
    cache.ts = Date.now();
    if (cache.onDone) {
      cache.onDone();
      cache.onDone = null;
    }
  }
  if (now > cache.ts + minInterval) {
    exec();
    return;
  }
  cache.timer = setTimeout(function () {
    exec();
    cache.timer = null;
  }, minInterval);
};
exports.done = function (id) {
  var cache = timerCache[id];
  if (!cache || !cache.timer) return Promise.resolve();
  return new Promise(function (resolve) {
    var previousOnDone = cache.onDone;
    cache.onDone = function onDone() {
      if (previousOnDone) previousOnDone();
      resolve();
      cache.onDone = null;
    };
  });
};

/**
 * Clear the throttle cache for one or all timers
 * @param {optional string} id:
 *   if provided, clear just this timer
 *   if omitted, clear all timers (mainly useful for testing)
 */
exports.clear = function (id) {
  if (id) {
    _clearTimeout(timerCache[id]);
    delete timerCache[id];
  } else {
    for (var idi in timerCache) exports.clear(idi);
  }
};
function _clearTimeout(cache) {
  if (cache && cache.timer !== null) {
    clearTimeout(cache.timer);
    cache.timer = null;
  }
}

/***/ }),

/***/ 8163:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);

/**
 * convert a linear value into a logged value, folding negative numbers into
 * the given range
 */
module.exports = function toLogRange(val, range) {
  if (val > 0) return Math.log(val) / Math.LN10;

  // move a negative value reference to a log axis - just put the
  // result at the lowest range value on the plot (or if the range also went negative,
  // one millionth of the top of the range)
  var newVal = Math.log(Math.min(range[0], range[1])) / Math.LN10;
  if (!isNumeric(newVal)) newVal = Math.log(Math.max(range[0], range[1])) / Math.LN10 - 6;
  return newVal;
};

/***/ }),

/***/ 7815:
/***/ (function(module) {

"use strict";


module.exports = {
  moduleType: 'locale',
  name: 'en-US',
  dictionary: {
    'Click to enter Colorscale title': 'Click to enter Colorscale title'
  },
  format: {
    date: '%m/%d/%Y'
  }
};

/***/ }),

/***/ 2177:
/***/ (function(module) {

"use strict";


module.exports = {
  moduleType: 'locale',
  name: 'en',
  dictionary: {
    'Click to enter Colorscale title': 'Click to enter Colourscale title'
  },
  format: {
    days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    periods: ['AM', 'PM'],
    dateTime: '%a %b %e %X %Y',
    date: '%d/%m/%Y',
    time: '%H:%M:%S',
    decimal: '.',
    thousands: ',',
    grouping: [3],
    currency: ['$', ''],
    year: '%Y',
    month: '%b %Y',
    dayMonth: '%b %-d',
    dayMonthYear: '%b %-d, %Y'
  }
};

/***/ }),

/***/ 4458:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);

/*
 * containerArrayMatch: does this attribute string point into a
 * layout container array?
 *
 * @param {String} astr: an attribute string, like *annotations[2].text*
 *
 * @returns {Object | false} Returns false if `astr` doesn't match a container
 *  array. If it does, returns:
 *     {array: {String}, index: {Number}, property: {String}}
 *  ie the attribute string for the array, the index within the array (or ''
 *  if the whole array) and the property within that (or '' if the whole array
 *  or the whole object)
 */
module.exports = function containerArrayMatch(astr) {
  var rootContainers = Registry.layoutArrayContainers;
  var regexpContainers = Registry.layoutArrayRegexes;
  var rootPart = astr.split('[')[0];
  var arrayStr;
  var match;

  // look for regexp matches first, because they may be nested inside root matches
  // eg updatemenus[i].buttons is nested inside updatemenus
  for (var i = 0; i < regexpContainers.length; i++) {
    match = astr.match(regexpContainers[i]);
    if (match && match.index === 0) {
      arrayStr = match[0];
      break;
    }
  }

  // now look for root matches
  if (!arrayStr) arrayStr = rootContainers[rootContainers.indexOf(rootPart)];
  if (!arrayStr) return false;
  var tail = astr.substr(arrayStr.length);
  if (!tail) return {
    array: arrayStr,
    index: '',
    property: ''
  };
  match = tail.match(/^\[(0|[1-9][0-9]*)\](\.(.+))?$/);
  if (!match) return false;
  return {
    array: arrayStr,
    index: Number(match[1]),
    property: match[3] || ''
  };
};

/***/ }),

/***/ 962:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var extendFlat = (__webpack_require__(1426).extendFlat);
var isPlainObject = __webpack_require__(1965);
var traceOpts = {
  valType: 'flaglist',
  extras: ['none'],
  flags: ['calc', 'clearAxisTypes', 'plot', 'style', 'markerSize', 'colorbars']
};
var layoutOpts = {
  valType: 'flaglist',
  extras: ['none'],
  flags: ['calc', 'plot', 'legend', 'ticks', 'axrange', 'layoutstyle', 'modebar', 'camera', 'arraydraw', 'colorbars']
};

// flags for inside restyle/relayout include a few extras
// that shouldn't be used in attributes, to deal with certain
// combinations and conditionals efficiently
var traceEditTypeFlags = traceOpts.flags.slice().concat(['fullReplot']);
var layoutEditTypeFlags = layoutOpts.flags.slice().concat('layoutReplot');
module.exports = {
  traces: traceOpts,
  layout: layoutOpts,
  /*
   * default (all false) edit flags for restyle (traces)
   * creates a new object each call, so the caller can mutate freely
   */
  traceFlags: function () {
    return falseObj(traceEditTypeFlags);
  },
  /*
   * default (all false) edit flags for relayout
   * creates a new object each call, so the caller can mutate freely
   */
  layoutFlags: function () {
    return falseObj(layoutEditTypeFlags);
  },
  /*
   * update `flags` with the `editType` values found in `attr`
   */
  update: function (flags, attr) {
    var editType = attr.editType;
    if (editType && editType !== 'none') {
      var editTypeParts = editType.split('+');
      for (var i = 0; i < editTypeParts.length; i++) {
        flags[editTypeParts[i]] = true;
      }
    }
  },
  overrideAll: overrideAll
};
function falseObj(keys) {
  var out = {};
  for (var i = 0; i < keys.length; i++) out[keys[i]] = false;
  return out;
}

/**
 * For attributes that are largely copied from elsewhere into a plot type that doesn't
 * support partial redraws - overrides the editType field of all attributes in the object
 *
 * @param {object} attrs: the attributes to override. Will not be mutated.
 * @param {string} editTypeOverride: the new editType to use
 * @param {'nested'|'from-root'} overrideContainers:
 *   - 'nested' will override editType for nested containers but not the root.
 *   - 'from-root' will also override editType of the root container.
 *   Containers below the absolute top level (trace or layout root) DO need an
 *   editType even if they are not `valObject`s themselves (eg `scatter.marker`)
 *   to handle the case where you edit the whole container.
 *
 * @return {object} a new attributes object with `editType` modified as directed
 */
function overrideAll(attrs, editTypeOverride, overrideContainers) {
  var out = extendFlat({}, attrs);
  for (var key in out) {
    var attr = out[key];
    if (isPlainObject(attr)) {
      out[key] = overrideOne(attr, editTypeOverride, overrideContainers, key);
    }
  }
  if (overrideContainers === 'from-root') out.editType = editTypeOverride;
  return out;
}
function overrideOne(attr, editTypeOverride, overrideContainers, key) {
  if (attr.valType) {
    var out = extendFlat({}, attr);
    out.editType = editTypeOverride;
    if (Array.isArray(attr.items)) {
      out.items = new Array(attr.items.length);
      for (var i = 0; i < attr.items.length; i++) {
        out.items[i] = overrideOne(attr.items[i], editTypeOverride, 'from-root');
      }
    }
    return out;
  } else {
    // don't provide an editType for the _deprecated container
    return overrideAll(attr, editTypeOverride, key.charAt(0) === '_' ? 'nested' : 'from-root');
  }
}

/***/ }),

/***/ 8377:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var m4FromQuat = __webpack_require__(7812);
var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var Plots = __webpack_require__(4875);
var AxisIds = __webpack_require__(1675);
var Color = __webpack_require__(7901);
var cleanId = AxisIds.cleanId;
var getFromTrace = AxisIds.getFromTrace;
var traceIs = Registry.traceIs;

// clear the promise queue if one of them got rejected
exports.clearPromiseQueue = function (gd) {
  if (Array.isArray(gd._promises) && gd._promises.length > 0) {
    Lib.log('Clearing previous rejected promises from queue.');
  }
  gd._promises = [];
};

// make a few changes to the layout right away
// before it gets used for anything
// backward compatibility and cleanup of nonstandard options
exports.cleanLayout = function (layout) {
  var i, j;
  if (!layout) layout = {};

  // cannot have (x|y)axis1, numbering goes axis, axis2, axis3...
  if (layout.xaxis1) {
    if (!layout.xaxis) layout.xaxis = layout.xaxis1;
    delete layout.xaxis1;
  }
  if (layout.yaxis1) {
    if (!layout.yaxis) layout.yaxis = layout.yaxis1;
    delete layout.yaxis1;
  }
  if (layout.scene1) {
    if (!layout.scene) layout.scene = layout.scene1;
    delete layout.scene1;
  }
  var axisAttrRegex = (Plots.subplotsRegistry.cartesian || {}).attrRegex;
  var polarAttrRegex = (Plots.subplotsRegistry.polar || {}).attrRegex;
  var ternaryAttrRegex = (Plots.subplotsRegistry.ternary || {}).attrRegex;
  var sceneAttrRegex = (Plots.subplotsRegistry.gl3d || {}).attrRegex;
  var keys = Object.keys(layout);
  for (i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (axisAttrRegex && axisAttrRegex.test(key)) {
      // modifications to cartesian axes

      var ax = layout[key];
      if (ax.anchor && ax.anchor !== 'free') {
        ax.anchor = cleanId(ax.anchor);
      }
      if (ax.overlaying) ax.overlaying = cleanId(ax.overlaying);

      // old method of axis type - isdate and islog (before category existed)
      if (!ax.type) {
        if (ax.isdate) ax.type = 'date';else if (ax.islog) ax.type = 'log';else if (ax.isdate === false && ax.islog === false) ax.type = 'linear';
      }
      if (ax.autorange === 'withzero' || ax.autorange === 'tozero') {
        ax.autorange = true;
        ax.rangemode = 'tozero';
      }
      if (ax.insiderange) delete ax.range;
      delete ax.islog;
      delete ax.isdate;
      delete ax.categories; // replaced by _categories

      // prune empty domain arrays made before the new nestedProperty
      if (emptyContainer(ax, 'domain')) delete ax.domain;

      // autotick -> tickmode
      if (ax.autotick !== undefined) {
        if (ax.tickmode === undefined) {
          ax.tickmode = ax.autotick ? 'auto' : 'linear';
        }
        delete ax.autotick;
      }
      cleanTitle(ax);
    } else if (polarAttrRegex && polarAttrRegex.test(key)) {
      // modifications for polar

      var polar = layout[key];
      cleanTitle(polar.radialaxis);
    } else if (ternaryAttrRegex && ternaryAttrRegex.test(key)) {
      // modifications for ternary

      var ternary = layout[key];
      cleanTitle(ternary.aaxis);
      cleanTitle(ternary.baxis);
      cleanTitle(ternary.caxis);
    } else if (sceneAttrRegex && sceneAttrRegex.test(key)) {
      // modifications for 3D scenes

      var scene = layout[key];

      // clean old Camera coords
      var cameraposition = scene.cameraposition;
      if (Array.isArray(cameraposition) && cameraposition[0].length === 4) {
        var rotation = cameraposition[0];
        var center = cameraposition[1];
        var radius = cameraposition[2];
        var mat = m4FromQuat([], rotation);
        var eye = [];
        for (j = 0; j < 3; ++j) {
          eye[j] = center[j] + radius * mat[2 + 4 * j];
        }
        scene.camera = {
          eye: {
            x: eye[0],
            y: eye[1],
            z: eye[2]
          },
          center: {
            x: center[0],
            y: center[1],
            z: center[2]
          },
          up: {
            x: 0,
            y: 0,
            z: 1
          } // we just ignore calculating camera z up in this case
        };

        delete scene.cameraposition;
      }

      // clean axis titles
      cleanTitle(scene.xaxis);
      cleanTitle(scene.yaxis);
      cleanTitle(scene.zaxis);
    }
  }
  var annotationsLen = Array.isArray(layout.annotations) ? layout.annotations.length : 0;
  for (i = 0; i < annotationsLen; i++) {
    var ann = layout.annotations[i];
    if (!Lib.isPlainObject(ann)) continue;
    if (ann.ref) {
      if (ann.ref === 'paper') {
        ann.xref = 'paper';
        ann.yref = 'paper';
      } else if (ann.ref === 'data') {
        ann.xref = 'x';
        ann.yref = 'y';
      }
      delete ann.ref;
    }
    cleanAxRef(ann, 'xref');
    cleanAxRef(ann, 'yref');
  }
  var shapesLen = Array.isArray(layout.shapes) ? layout.shapes.length : 0;
  for (i = 0; i < shapesLen; i++) {
    var shape = layout.shapes[i];
    if (!Lib.isPlainObject(shape)) continue;
    cleanAxRef(shape, 'xref');
    cleanAxRef(shape, 'yref');
  }
  var imagesLen = Array.isArray(layout.images) ? layout.images.length : 0;
  for (i = 0; i < imagesLen; i++) {
    var image = layout.images[i];
    if (!Lib.isPlainObject(image)) continue;
    cleanAxRef(image, 'xref');
    cleanAxRef(image, 'yref');
  }
  var legend = layout.legend;
  if (legend) {
    // check for old-style legend positioning (x or y is +/- 100)
    if (legend.x > 3) {
      legend.x = 1.02;
      legend.xanchor = 'left';
    } else if (legend.x < -2) {
      legend.x = -0.02;
      legend.xanchor = 'right';
    }
    if (legend.y > 3) {
      legend.y = 1.02;
      legend.yanchor = 'bottom';
    } else if (legend.y < -2) {
      legend.y = -0.02;
      legend.yanchor = 'top';
    }
  }

  // clean plot title
  cleanTitle(layout);

  /*
   * Moved from rotate -> orbit for dragmode
   */
  if (layout.dragmode === 'rotate') layout.dragmode = 'orbit';

  // sanitize rgb(fractions) and rgba(fractions) that old tinycolor
  // supported, but new tinycolor does not because they're not valid css
  Color.clean(layout);

  // clean the layout container in layout.template
  if (layout.template && layout.template.layout) {
    exports.cleanLayout(layout.template.layout);
  }
  return layout;
};
function cleanAxRef(container, attr) {
  var valIn = container[attr];
  var axLetter = attr.charAt(0);
  if (valIn && valIn !== 'paper') {
    container[attr] = cleanId(valIn, axLetter, true);
  }
}

/**
 * Cleans up old title attribute structure (flat) in favor of the new one (nested).
 *
 * @param {Object} titleContainer - an object potentially including deprecated title attributes
 */
function cleanTitle(titleContainer) {
  if (titleContainer) {
    // title -> title.text
    // (although title used to be a string attribute,
    // numbers are accepted as well)
    if (typeof titleContainer.title === 'string' || typeof titleContainer.title === 'number') {
      titleContainer.title = {
        text: titleContainer.title
      };
    }
    rewireAttr('titlefont', 'font');
    rewireAttr('titleposition', 'position');
    rewireAttr('titleside', 'side');
    rewireAttr('titleoffset', 'offset');
  }
  function rewireAttr(oldAttrName, newAttrName) {
    var oldAttrSet = titleContainer[oldAttrName];
    var newAttrSet = titleContainer.title && titleContainer.title[newAttrName];
    if (oldAttrSet && !newAttrSet) {
      // Ensure title object exists
      if (!titleContainer.title) {
        titleContainer.title = {};
      }
      titleContainer.title[newAttrName] = titleContainer[oldAttrName];
      delete titleContainer[oldAttrName];
    }
  }
}

/*
 * cleanData: Make a few changes to the data for backward compatibility
 * before it gets used for anything. Modifies the data traces users provide.
 *
 * Important: if you're going to add something here that modifies a data array,
 * update it in place so the new array === the old one.
 */
exports.cleanData = function (data) {
  for (var tracei = 0; tracei < data.length; tracei++) {
    var trace = data[tracei];
    var i;

    // use xbins to bin data in x, and ybins to bin data in y
    if (trace.type === 'histogramy' && 'xbins' in trace && !('ybins' in trace)) {
      trace.ybins = trace.xbins;
      delete trace.xbins;
    }

    // error_y.opacity is obsolete - merge into color
    if (trace.error_y && 'opacity' in trace.error_y) {
      var dc = Color.defaults;
      var yeColor = trace.error_y.color || (traceIs(trace, 'bar') ? Color.defaultLine : dc[tracei % dc.length]);
      trace.error_y.color = Color.addOpacity(Color.rgb(yeColor), Color.opacity(yeColor) * trace.error_y.opacity);
      delete trace.error_y.opacity;
    }

    // convert bardir to orientation, and put the data into
    // the axes it's eventually going to be used with
    if ('bardir' in trace) {
      if (trace.bardir === 'h' && (traceIs(trace, 'bar') || trace.type.substr(0, 9) === 'histogram')) {
        trace.orientation = 'h';
        exports.swapXYData(trace);
      }
      delete trace.bardir;
    }

    // now we have only one 1D histogram type, and whether
    // it uses x or y data depends on trace.orientation
    if (trace.type === 'histogramy') exports.swapXYData(trace);
    if (trace.type === 'histogramx' || trace.type === 'histogramy') {
      trace.type = 'histogram';
    }

    // scl->scale, reversescl->reversescale
    if ('scl' in trace && !('colorscale' in trace)) {
      trace.colorscale = trace.scl;
      delete trace.scl;
    }
    if ('reversescl' in trace && !('reversescale' in trace)) {
      trace.reversescale = trace.reversescl;
      delete trace.reversescl;
    }

    // axis ids x1 -> x, y1-> y
    if (trace.xaxis) trace.xaxis = cleanId(trace.xaxis, 'x');
    if (trace.yaxis) trace.yaxis = cleanId(trace.yaxis, 'y');

    // scene ids scene1 -> scene
    if (traceIs(trace, 'gl3d') && trace.scene) {
      trace.scene = Plots.subplotsRegistry.gl3d.cleanId(trace.scene);
    }
    if (!traceIs(trace, 'pie-like') && !traceIs(trace, 'bar-like')) {
      if (Array.isArray(trace.textposition)) {
        for (i = 0; i < trace.textposition.length; i++) {
          trace.textposition[i] = cleanTextPosition(trace.textposition[i]);
        }
      } else if (trace.textposition) {
        trace.textposition = cleanTextPosition(trace.textposition);
      }
    }

    // fix typo in colorscale definition
    var _module = Registry.getModule(trace);
    if (_module && _module.colorbar) {
      var containerName = _module.colorbar.container;
      var container = containerName ? trace[containerName] : trace;
      if (container && container.colorscale) {
        if (container.colorscale === 'YIGnBu') container.colorscale = 'YlGnBu';
        if (container.colorscale === 'YIOrRd') container.colorscale = 'YlOrRd';
      }
    }

    // fix typo in surface 'highlight*' definitions
    if (trace.type === 'surface' && Lib.isPlainObject(trace.contours)) {
      var dims = ['x', 'y', 'z'];
      for (i = 0; i < dims.length; i++) {
        var opts = trace.contours[dims[i]];
        if (!Lib.isPlainObject(opts)) continue;
        if (opts.highlightColor) {
          opts.highlightcolor = opts.highlightColor;
          delete opts.highlightColor;
        }
        if (opts.highlightWidth) {
          opts.highlightwidth = opts.highlightWidth;
          delete opts.highlightWidth;
        }
      }
    }

    // fixes from converting finance from transforms to real trace types
    if (trace.type === 'candlestick' || trace.type === 'ohlc') {
      var increasingShowlegend = (trace.increasing || {}).showlegend !== false;
      var decreasingShowlegend = (trace.decreasing || {}).showlegend !== false;
      var increasingName = cleanFinanceDir(trace.increasing);
      var decreasingName = cleanFinanceDir(trace.decreasing);

      // now figure out something smart to do with the separate direction
      // names we removed
      if (increasingName !== false && decreasingName !== false) {
        // both sub-names existed: base name previously had no effect
        // so ignore it and try to find a shared part of the sub-names

        var newName = commonPrefix(increasingName, decreasingName, increasingShowlegend, decreasingShowlegend);
        // if no common part, leave whatever name was (or wasn't) there
        if (newName) trace.name = newName;
      } else if ((increasingName || decreasingName) && !trace.name) {
        // one sub-name existed but not the base name - just use the sub-name
        trace.name = increasingName || decreasingName;
      }
    }

    // transforms backward compatibility fixes
    if (Array.isArray(trace.transforms)) {
      var transforms = trace.transforms;
      for (i = 0; i < transforms.length; i++) {
        var transform = transforms[i];
        if (!Lib.isPlainObject(transform)) continue;
        switch (transform.type) {
          case 'filter':
            if (transform.filtersrc) {
              transform.target = transform.filtersrc;
              delete transform.filtersrc;
            }
            if (transform.calendar) {
              if (!transform.valuecalendar) {
                transform.valuecalendar = transform.calendar;
              }
              delete transform.calendar;
            }
            break;
          case 'groupby':
            // Name has changed from `style` to `styles`, so use `style` but prefer `styles`:
            transform.styles = transform.styles || transform.style;
            if (transform.styles && !Array.isArray(transform.styles)) {
              var prevStyles = transform.styles;
              var styleKeys = Object.keys(prevStyles);
              transform.styles = [];
              for (var j = 0; j < styleKeys.length; j++) {
                transform.styles.push({
                  target: styleKeys[j],
                  value: prevStyles[styleKeys[j]]
                });
              }
            }
            break;
        }
      }
    }

    // prune empty containers made before the new nestedProperty
    if (emptyContainer(trace, 'line')) delete trace.line;
    if ('marker' in trace) {
      if (emptyContainer(trace.marker, 'line')) delete trace.marker.line;
      if (emptyContainer(trace, 'marker')) delete trace.marker;
    }

    // sanitize rgb(fractions) and rgba(fractions) that old tinycolor
    // supported, but new tinycolor does not because they're not valid css
    Color.clean(trace);

    // remove obsolete autobin(x|y) attributes, but only if true
    // if false, this needs to happen in Histogram.calc because it
    // can be a one-time autobin so we need to know the results before
    // we can push them back into the trace.
    if (trace.autobinx) {
      delete trace.autobinx;
      delete trace.xbins;
    }
    if (trace.autobiny) {
      delete trace.autobiny;
      delete trace.ybins;
    }
    cleanTitle(trace);
    if (trace.colorbar) cleanTitle(trace.colorbar);
    if (trace.marker && trace.marker.colorbar) cleanTitle(trace.marker.colorbar);
    if (trace.line && trace.line.colorbar) cleanTitle(trace.line.colorbar);
    if (trace.aaxis) cleanTitle(trace.aaxis);
    if (trace.baxis) cleanTitle(trace.baxis);
  }
};
function cleanFinanceDir(dirContainer) {
  if (!Lib.isPlainObject(dirContainer)) return false;
  var dirName = dirContainer.name;
  delete dirContainer.name;
  delete dirContainer.showlegend;
  return (typeof dirName === 'string' || typeof dirName === 'number') && String(dirName);
}
function commonPrefix(name1, name2, show1, show2) {
  // if only one is shown in the legend, use that
  if (show1 && !show2) return name1;
  if (show2 && !show1) return name2;

  // if both or neither are in the legend, check if one is blank (or whitespace)
  // and use the other one
  // note that hover labels can still use the name even if the legend doesn't
  if (!name1.trim()) return name2;
  if (!name2.trim()) return name1;
  var minLen = Math.min(name1.length, name2.length);
  var i;
  for (i = 0; i < minLen; i++) {
    if (name1.charAt(i) !== name2.charAt(i)) break;
  }
  var out = name1.substr(0, i);
  return out.trim();
}

// textposition - support partial attributes (ie just 'top')
// and incorrect use of middle / center etc.
function cleanTextPosition(textposition) {
  var posY = 'middle';
  var posX = 'center';
  if (typeof textposition === 'string') {
    if (textposition.indexOf('top') !== -1) posY = 'top';else if (textposition.indexOf('bottom') !== -1) posY = 'bottom';
    if (textposition.indexOf('left') !== -1) posX = 'left';else if (textposition.indexOf('right') !== -1) posX = 'right';
  }
  return posY + ' ' + posX;
}
function emptyContainer(outer, innerStr) {
  return innerStr in outer && typeof outer[innerStr] === 'object' && Object.keys(outer[innerStr]).length === 0;
}

// swap all the data and data attributes associated with x and y
exports.swapXYData = function (trace) {
  var i;
  Lib.swapAttrs(trace, ['?', '?0', 'd?', '?bins', 'nbins?', 'autobin?', '?src', 'error_?']);
  if (Array.isArray(trace.z) && Array.isArray(trace.z[0])) {
    if (trace.transpose) delete trace.transpose;else trace.transpose = true;
  }
  if (trace.error_x && trace.error_y) {
    var errorY = trace.error_y;
    var copyYstyle = 'copy_ystyle' in errorY ? errorY.copy_ystyle : !(errorY.color || errorY.thickness || errorY.width);
    Lib.swapAttrs(trace, ['error_?.copy_ystyle']);
    if (copyYstyle) {
      Lib.swapAttrs(trace, ['error_?.color', 'error_?.thickness', 'error_?.width']);
    }
  }
  if (typeof trace.hoverinfo === 'string') {
    var hoverInfoParts = trace.hoverinfo.split('+');
    for (i = 0; i < hoverInfoParts.length; i++) {
      if (hoverInfoParts[i] === 'x') hoverInfoParts[i] = 'y';else if (hoverInfoParts[i] === 'y') hoverInfoParts[i] = 'x';
    }
    trace.hoverinfo = hoverInfoParts.join('+');
  }
};

// coerce traceIndices input to array of trace indices
exports.coerceTraceIndices = function (gd, traceIndices) {
  if (isNumeric(traceIndices)) {
    return [traceIndices];
  } else if (!Array.isArray(traceIndices) || !traceIndices.length) {
    return gd.data.map(function (_, i) {
      return i;
    });
  } else if (Array.isArray(traceIndices)) {
    var traceIndicesOut = [];
    for (var i = 0; i < traceIndices.length; i++) {
      if (Lib.isIndex(traceIndices[i], gd.data.length)) {
        traceIndicesOut.push(traceIndices[i]);
      } else {
        Lib.warn('trace index (', traceIndices[i], ') is not a number or is out of bounds');
      }
    }
    return traceIndicesOut;
  }
  return traceIndices;
};

/**
 * Manages logic around array container item creation / deletion / update
 * that nested property alone can't handle.
 *
 * @param {Object} np
 *  nested property of update attribute string about trace or layout object
 * @param {*} newVal
 *  update value passed to restyle / relayout / update
 * @param {Object} undoit
 *  undo hash (N.B. undoit may be mutated here).
 *
 */
exports.manageArrayContainers = function (np, newVal, undoit) {
  var obj = np.obj;
  var parts = np.parts;
  var pLength = parts.length;
  var pLast = parts[pLength - 1];
  var pLastIsNumber = isNumeric(pLast);
  if (pLastIsNumber && newVal === null) {
    // delete item

    // Clear item in array container when new value is null
    var contPath = parts.slice(0, pLength - 1).join('.');
    var cont = Lib.nestedProperty(obj, contPath).get();
    cont.splice(pLast, 1);

    // Note that nested property clears null / undefined at end of
    // array container, but not within them.
  } else if (pLastIsNumber && np.get() === undefined) {
    // create item

    // When adding a new item, make sure undo command will remove it
    if (np.get() === undefined) undoit[np.astr] = null;
    np.set(newVal);
  } else {
    // update item

    // If the last part of attribute string isn't a number,
    // np.set is all we need.
    np.set(newVal);
  }
};

/*
 * Match the part to strip off to turn an attribute into its parent
 * really it should be either '.some_characters' or '[number]'
 * but we're a little more permissive here and match either
 * '.not_brackets_or_dot' or '[not_brackets_or_dot]'
 */
var ATTR_TAIL_RE = /(\.[^\[\]\.]+|\[[^\[\]\.]+\])$/;
function getParent(attr) {
  var tail = attr.search(ATTR_TAIL_RE);
  if (tail > 0) return attr.substr(0, tail);
}

/*
 * hasParent: does an attribute object contain a parent of the given attribute?
 * for example, given 'images[2].x' do we also have 'images' or 'images[2]'?
 *
 * @param {Object} aobj
 *  update object, whose keys are attribute strings and values are their new settings
 * @param {string} attr
 *  the attribute string to test against
 * @returns {Boolean}
 *  is a parent of attr present in aobj?
 */
exports.hasParent = function (aobj, attr) {
  var attrParent = getParent(attr);
  while (attrParent) {
    if (attrParent in aobj) return true;
    attrParent = getParent(attrParent);
  }
  return false;
};

/**
 * Empty out types for all axes containing these traces so we auto-set them again
 *
 * @param {object} gd
 * @param {[integer]} traces: trace indices to search for axes to clear the types of
 * @param {object} layoutUpdate: any update being done concurrently to the layout,
 *   which may supercede clearing the axis types
 */
var axLetters = ['x', 'y', 'z'];
exports.clearAxisTypes = function (gd, traces, layoutUpdate) {
  for (var i = 0; i < traces.length; i++) {
    var trace = gd._fullData[i];
    for (var j = 0; j < 3; j++) {
      var ax = getFromTrace(gd, trace, axLetters[j]);

      // do not clear log type - that's never an auto result so must have been intentional
      if (ax && ax.type !== 'log') {
        var axAttr = ax._name;
        var sceneName = ax._id.substr(1);
        if (sceneName.substr(0, 5) === 'scene') {
          if (layoutUpdate[sceneName] !== undefined) continue;
          axAttr = sceneName + '.' + axAttr;
        }
        var typeAttr = axAttr + '.type';
        if (layoutUpdate[axAttr] === undefined && layoutUpdate[typeAttr] === undefined) {
          Lib.nestedProperty(gd.layout, typeAttr).set(null);
        }
      }
    }
  }
};

/***/ }),

/***/ 641:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var main = __webpack_require__(2391);
exports._doPlot = main._doPlot;
exports.newPlot = main.newPlot;
exports.restyle = main.restyle;
exports.relayout = main.relayout;
exports.redraw = main.redraw;
exports.update = main.update;
exports._guiRestyle = main._guiRestyle;
exports._guiRelayout = main._guiRelayout;
exports._guiUpdate = main._guiUpdate;
exports._storeDirectGUIEdit = main._storeDirectGUIEdit;
exports.react = main.react;
exports.extendTraces = main.extendTraces;
exports.prependTraces = main.prependTraces;
exports.addTraces = main.addTraces;
exports.deleteTraces = main.deleteTraces;
exports.moveTraces = main.moveTraces;
exports.purge = main.purge;
exports.addFrames = main.addFrames;
exports.deleteFrames = main.deleteFrames;
exports.animate = main.animate;
exports.setPlotConfig = main.setPlotConfig;
var getGraphDiv = (__webpack_require__(4401).getGraphDiv);
var eraseActiveShape = (__webpack_require__(4031).eraseActiveShape);
exports.deleteActiveShape = function (gd) {
  return eraseActiveShape(getGraphDiv(gd));
};
exports.toImage = __webpack_require__(403);
exports.validate = __webpack_require__(4936);
exports.downloadImage = __webpack_require__(7239);
var templateApi = __webpack_require__(6318);
exports.makeTemplate = templateApi.makeTemplate;
exports.validateTemplate = templateApi.validateTemplate;

/***/ }),

/***/ 6611:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var isPlainObject = __webpack_require__(1965);
var noop = __webpack_require__(4213);
var Loggers = __webpack_require__(7769);
var sorterAsc = (__webpack_require__(5888).sorterAsc);
var Registry = __webpack_require__(3972);
exports.containerArrayMatch = __webpack_require__(4458);
var isAddVal = exports.isAddVal = function isAddVal(val) {
  return val === 'add' || isPlainObject(val);
};
var isRemoveVal = exports.isRemoveVal = function isRemoveVal(val) {
  return val === null || val === 'remove';
};

/*
 * applyContainerArrayChanges: for managing arrays of layout components in relayout
 * handles them all with a consistent interface.
 *
 * Here are the supported actions -> relayout calls -> edits we get here
 * (as prepared in _relayout):
 *
 * add an empty obj -> {'annotations[2]': 'add'} -> {2: {'': 'add'}}
 * add a specific obj -> {'annotations[2]': {attrs}} -> {2: {'': {attrs}}}
 * delete an obj -> {'annotations[2]': 'remove'} -> {2: {'': 'remove'}}
 *               -> {'annotations[2]': null} -> {2: {'': null}}
 * delete the whole array -> {'annotations': 'remove'} -> {'': {'': 'remove'}}
 *                        -> {'annotations': null} -> {'': {'': null}}
 * edit an object -> {'annotations[2].text': 'boo'} -> {2: {'text': 'boo'}}
 *
 * You can combine many edits to different objects. Objects are added and edited
 * in ascending order, then removed in descending order.
 * For example, starting with [a, b, c], if you want to:
 * - replace b with d:
 *   {'annotations[1]': d, 'annotations[2]': null} (b is item 2 after adding d)
 * - add a new item d between a and b, and edit b:
 *    {'annotations[1]': d, 'annotations[2].x': newX} (b is item 2 after adding d)
 * - delete b and edit c:
 *    {'annotations[1]': null, 'annotations[2].x': newX} (c is edited before b is removed)
 *
 * You CANNOT combine adding/deleting an item at index `i` with edits to the same index `i`
 * You CANNOT combine replacing/deleting the whole array with anything else (for the same array).
 *
 * @param {HTMLDivElement} gd
 *  the DOM element of the graph container div
 * @param {Lib.nestedProperty} componentType: the array we are editing
 * @param {Object} edits
 *  the changes to make; keys are indices to edit, values are themselves objects:
 *  {attr: newValue} of changes to make to that index (with add/remove behavior
 *  in special values of the empty attr)
 * @param {Object} flags
 *  the flags for which actions we're going to perform to display these (and
 *  any other) changes. If we're already `recalc`ing, we don't need to redraw
 *  individual items
 * @param {function} _nestedProperty
 *  a (possibly modified for gui edits) nestedProperty constructor
 *  The modified version takes a 3rd argument, for a prefix to the attribute
 *  string necessary for storing GUI edits
 *
 * @returns {bool} `true` if it managed to complete drawing of the changes
 *  `false` would mean the parent should replot.
 */
exports.applyContainerArrayChanges = function applyContainerArrayChanges(gd, np, edits, flags, _nestedProperty) {
  var componentType = np.astr;
  var supplyComponentDefaults = Registry.getComponentMethod(componentType, 'supplyLayoutDefaults');
  var draw = Registry.getComponentMethod(componentType, 'draw');
  var drawOne = Registry.getComponentMethod(componentType, 'drawOne');
  var replotLater = flags.replot || flags.recalc || supplyComponentDefaults === noop || draw === noop;
  var layout = gd.layout;
  var fullLayout = gd._fullLayout;
  if (edits['']) {
    if (Object.keys(edits).length > 1) {
      Loggers.warn('Full array edits are incompatible with other edits', componentType);
    }
    var fullVal = edits[''][''];
    if (isRemoveVal(fullVal)) np.set(null);else if (Array.isArray(fullVal)) np.set(fullVal);else {
      Loggers.warn('Unrecognized full array edit value', componentType, fullVal);
      return true;
    }
    if (replotLater) return false;
    supplyComponentDefaults(layout, fullLayout);
    draw(gd);
    return true;
  }
  var componentNums = Object.keys(edits).map(Number).sort(sorterAsc);
  var componentArrayIn = np.get();
  var componentArray = componentArrayIn || [];
  // componentArrayFull is used just to keep splices in line between
  // full and input arrays, so private keys can be copied over after
  // redoing supplyDefaults
  // TODO: this assumes componentArray is in gd.layout - which will not be
  // true after we extend this to restyle
  var componentArrayFull = _nestedProperty(fullLayout, componentType).get();
  var deletes = [];
  var firstIndexChange = -1;
  var maxIndex = componentArray.length;
  var i;
  var j;
  var componentNum;
  var objEdits;
  var objKeys;
  var objVal;
  var adding, prefix;

  // first make the add and edit changes
  for (i = 0; i < componentNums.length; i++) {
    componentNum = componentNums[i];
    objEdits = edits[componentNum];
    objKeys = Object.keys(objEdits);
    objVal = objEdits[''], adding = isAddVal(objVal);
    if (componentNum < 0 || componentNum > componentArray.length - (adding ? 0 : 1)) {
      Loggers.warn('index out of range', componentType, componentNum);
      continue;
    }
    if (objVal !== undefined) {
      if (objKeys.length > 1) {
        Loggers.warn('Insertion & removal are incompatible with edits to the same index.', componentType, componentNum);
      }
      if (isRemoveVal(objVal)) {
        deletes.push(componentNum);
      } else if (adding) {
        if (objVal === 'add') objVal = {};
        componentArray.splice(componentNum, 0, objVal);
        if (componentArrayFull) componentArrayFull.splice(componentNum, 0, {});
      } else {
        Loggers.warn('Unrecognized full object edit value', componentType, componentNum, objVal);
      }
      if (firstIndexChange === -1) firstIndexChange = componentNum;
    } else {
      for (j = 0; j < objKeys.length; j++) {
        prefix = componentType + '[' + componentNum + '].';
        _nestedProperty(componentArray[componentNum], objKeys[j], prefix).set(objEdits[objKeys[j]]);
      }
    }
  }

  // now do deletes
  for (i = deletes.length - 1; i >= 0; i--) {
    componentArray.splice(deletes[i], 1);
    // TODO: this drops private keys that had been stored in componentArrayFull
    // does this have any ill effects?
    if (componentArrayFull) componentArrayFull.splice(deletes[i], 1);
  }
  if (!componentArray.length) np.set(null);else if (!componentArrayIn) np.set(componentArray);
  if (replotLater) return false;
  supplyComponentDefaults(layout, fullLayout);

  // finally draw all the components we need to
  // if we added or removed any, redraw all after it
  if (drawOne !== noop) {
    var indicesToDraw;
    if (firstIndexChange === -1) {
      // there's no re-indexing to do, so only redraw components that changed
      indicesToDraw = componentNums;
    } else {
      // in case the component array was shortened, we still need do call
      // drawOne on the latter items so they get properly removed
      maxIndex = Math.max(componentArray.length, maxIndex);
      indicesToDraw = [];
      for (i = 0; i < componentNums.length; i++) {
        componentNum = componentNums[i];
        if (componentNum >= firstIndexChange) break;
        indicesToDraw.push(componentNum);
      }
      for (i = firstIndexChange; i < maxIndex; i++) {
        indicesToDraw.push(i);
      }
    }
    for (i = 0; i < indicesToDraw.length; i++) {
      drawOne(gd, indicesToDraw[i]);
    }
  } else draw(gd);
  return true;
};

/***/ }),

/***/ 2391:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var isNumeric = __webpack_require__(2770);
var hasHover = __webpack_require__(7035);
var Lib = __webpack_require__(1828);
var nestedProperty = Lib.nestedProperty;
var Events = __webpack_require__(1086);
var Queue = __webpack_require__(847);
var Registry = __webpack_require__(3972);
var PlotSchema = __webpack_require__(6281);
var Plots = __webpack_require__(4875);
var Axes = __webpack_require__(9298);
var handleRangeDefaults = __webpack_require__(3608);
var cartesianLayoutAttributes = __webpack_require__(3838);
var Drawing = __webpack_require__(1424);
var Color = __webpack_require__(7901);
var initInteractions = (__webpack_require__(4305).initInteractions);
var xmlnsNamespaces = __webpack_require__(7922);
var clearOutline = (__webpack_require__(7322).clearOutline);
var dfltConfig = (__webpack_require__(2075).dfltConfig);
var manageArrays = __webpack_require__(6611);
var helpers = __webpack_require__(8377);
var subroutines = __webpack_require__(1549);
var editTypes = __webpack_require__(962);
var AX_NAME_PATTERN = (__webpack_require__(5555).AX_NAME_PATTERN);
var numericNameWarningCount = 0;
var numericNameWarningCountLimit = 5;

/**
 * Internal plot-creation function
 *
 * @param {string id or DOM element} gd
 *      the id or DOM element of the graph container div
 * @param {array of objects} data
 *      array of traces, containing the data and display information for each trace
 * @param {object} layout
 *      object describing the overall display of the plot,
 *      all the stuff that doesn't pertain to any individual trace
 * @param {object} config
 *      configuration options (see ./plot_config.js for more info)
 *
 * OR
 *
 * @param {string id or DOM element} gd
 *      the id or DOM element of the graph container div
 * @param {object} figure
 *      object containing `data`, `layout`, `config`, and `frames` members
 *
 */
function _doPlot(gd, data, layout, config) {
  var frames;
  gd = Lib.getGraphDiv(gd);

  // Events.init is idempotent and bails early if gd has already been init'd
  Events.init(gd);
  if (Lib.isPlainObject(data)) {
    var obj = data;
    data = obj.data;
    layout = obj.layout;
    config = obj.config;
    frames = obj.frames;
  }
  var okToPlot = Events.triggerHandler(gd, 'plotly_beforeplot', [data, layout, config]);
  if (okToPlot === false) return Promise.reject();

  // if there's no data or layout, and this isn't yet a plotly plot
  // container, log a warning to help plotly.js users debug
  if (!data && !layout && !Lib.isPlotDiv(gd)) {
    Lib.warn('Calling _doPlot as if redrawing ' + 'but this container doesn\'t yet have a plot.', gd);
  }
  function addFrames() {
    if (frames) {
      return exports.addFrames(gd, frames);
    }
  }

  // transfer configuration options to gd until we move over to
  // a more OO like model
  setPlotContext(gd, config);
  if (!layout) layout = {};

  // hook class for plots main container (in case of plotly.js
  // this won't be #embedded-graph or .js-tab-contents)
  d3.select(gd).classed('js-plotly-plot', true);

  // off-screen getBoundingClientRect testing space,
  // in #js-plotly-tester (and stored as Drawing.tester)
  // so we can share cached text across tabs
  Drawing.makeTester();

  // collect promises for any async actions during plotting
  // any part of the plotting code can push to gd._promises, then
  // before we move to the next step, we check that they're all
  // complete, and empty out the promise list again.
  if (!Array.isArray(gd._promises)) gd._promises = [];
  var graphWasEmpty = (gd.data || []).length === 0 && Array.isArray(data);

  // if there is already data on the graph, append the new data
  // if you only want to redraw, pass a non-array for data
  if (Array.isArray(data)) {
    helpers.cleanData(data);
    if (graphWasEmpty) gd.data = data;else gd.data.push.apply(gd.data, data);

    // for routines outside graph_obj that want a clean tab
    // (rather than appending to an existing one) gd.empty
    // is used to determine whether to make a new tab
    gd.empty = false;
  }
  if (!gd.layout || graphWasEmpty) {
    gd.layout = helpers.cleanLayout(layout);
  }
  Plots.supplyDefaults(gd);
  var fullLayout = gd._fullLayout;
  var hasCartesian = fullLayout._has('cartesian');

  // so we don't try to re-call _doPlot from inside
  // legend and colorbar, if margins changed
  fullLayout._replotting = true;

  // make or remake the framework if we need to
  if (graphWasEmpty || fullLayout._shouldCreateBgLayer) {
    makePlotFramework(gd);
    if (fullLayout._shouldCreateBgLayer) {
      delete fullLayout._shouldCreateBgLayer;
    }
  }

  // clear gradient and pattern defs on each .plot call, because we know we'll loop through all traces
  Drawing.initGradients(gd);
  Drawing.initPatterns(gd);

  // save initial show spikes once per graph
  if (graphWasEmpty) Axes.saveShowSpikeInitial(gd);

  // prepare the data and find the autorange

  // generate calcdata, if we need to
  // to force redoing calcdata, just delete it before calling _doPlot
  var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;
  if (recalc) Plots.doCalcdata(gd);

  // in case it has changed, attach fullData traces to calcdata
  for (var i = 0; i < gd.calcdata.length; i++) {
    gd.calcdata[i][0].trace = gd._fullData[i];
  }

  // make the figure responsive
  if (gd._context.responsive) {
    if (!gd._responsiveChartHandler) {
      // Keep a reference to the resize handler to purge it down the road
      gd._responsiveChartHandler = function () {
        if (!Lib.isHidden(gd)) Plots.resize(gd);
      };

      // Listen to window resize
      window.addEventListener('resize', gd._responsiveChartHandler);
    }
  } else {
    Lib.clearResponsive(gd);
  }

  /*
   * start async-friendly code - now we're actually drawing things
   */

  var oldMargins = Lib.extendFlat({}, fullLayout._size);

  // draw framework first so that margin-pushing
  // components can position themselves correctly
  var drawFrameworkCalls = 0;
  function drawFramework() {
    var basePlotModules = fullLayout._basePlotModules;
    for (var i = 0; i < basePlotModules.length; i++) {
      if (basePlotModules[i].drawFramework) {
        basePlotModules[i].drawFramework(gd);
      }
    }
    if (!fullLayout._glcanvas && fullLayout._has('gl')) {
      fullLayout._glcanvas = fullLayout._glcontainer.selectAll('.gl-canvas').data([{
        key: 'contextLayer',
        context: true,
        pick: false
      }, {
        key: 'focusLayer',
        context: false,
        pick: false
      }, {
        key: 'pickLayer',
        context: false,
        pick: true
      }], function (d) {
        return d.key;
      });
      fullLayout._glcanvas.enter().append('canvas').attr('class', function (d) {
        return 'gl-canvas gl-canvas-' + d.key.replace('Layer', '');
      }).style({
        position: 'absolute',
        top: 0,
        left: 0,
        overflow: 'visible',
        'pointer-events': 'none'
      });
    }
    var plotGlPixelRatio = gd._context.plotGlPixelRatio;
    if (fullLayout._glcanvas) {
      fullLayout._glcanvas.attr('width', fullLayout.width * plotGlPixelRatio).attr('height', fullLayout.height * plotGlPixelRatio).style('width', fullLayout.width + 'px').style('height', fullLayout.height + 'px');
      var regl = fullLayout._glcanvas.data()[0].regl;
      if (regl) {
        // Unfortunately, this can happen when relayouting to large
        // width/height on some browsers.
        if (Math.floor(fullLayout.width * plotGlPixelRatio) !== regl._gl.drawingBufferWidth || Math.floor(fullLayout.height * plotGlPixelRatio) !== regl._gl.drawingBufferHeight) {
          var msg = 'WebGL context buffer and canvas dimensions do not match due to browser/WebGL bug.';
          if (drawFrameworkCalls) {
            Lib.error(msg);
          } else {
            Lib.log(msg + ' Clearing graph and plotting again.');
            Plots.cleanPlot([], {}, gd._fullData, fullLayout);
            Plots.supplyDefaults(gd);
            fullLayout = gd._fullLayout;
            Plots.doCalcdata(gd);
            drawFrameworkCalls++;
            return drawFramework();
          }
        }
      }
    }
    if (fullLayout.modebar.orientation === 'h') {
      fullLayout._modebardiv.style('height', null).style('width', '100%');
    } else {
      fullLayout._modebardiv.style('width', null).style('height', fullLayout.height + 'px');
    }
    return Plots.previousPromises(gd);
  }

  // draw anything that can affect margins.
  function marginPushers() {
    // First reset the list of things that are allowed to change the margins
    // So any deleted traces or components will be wiped out of the
    // automargin calculation.
    // This means *every* margin pusher must be listed here, even if it
    // doesn't actually try to push the margins until later.
    Plots.clearAutoMarginIds(gd);
    subroutines.drawMarginPushers(gd);
    Axes.allowAutoMargin(gd);
    if (gd._fullLayout.title.text && gd._fullLayout.title.automargin) Plots.allowAutoMargin(gd, 'title.automargin');

    // TODO can this be moved elsewhere?
    if (fullLayout._has('pie')) {
      var fullData = gd._fullData;
      for (var i = 0; i < fullData.length; i++) {
        var trace = fullData[i];
        if (trace.type === 'pie' && trace.automargin) {
          Plots.allowAutoMargin(gd, 'pie.' + trace.uid + '.automargin');
        }
      }
    }
    Plots.doAutoMargin(gd);
    return Plots.previousPromises(gd);
  }

  // in case the margins changed, draw margin pushers again
  function marginPushersAgain() {
    if (!Plots.didMarginChange(oldMargins, fullLayout._size)) return;
    return Lib.syncOrAsync([marginPushers, subroutines.layoutStyles], gd);
  }
  function positionAndAutorange() {
    if (!recalc) {
      doAutoRangeAndConstraints();
      return;
    }

    // TODO: autosize extra for text markers and images
    // see https://github.com/plotly/plotly.js/issues/1111
    return Lib.syncOrAsync([Registry.getComponentMethod('shapes', 'calcAutorange'), Registry.getComponentMethod('annotations', 'calcAutorange'), doAutoRangeAndConstraints], gd);
  }
  function doAutoRangeAndConstraints() {
    if (gd._transitioning) return;
    subroutines.doAutoRangeAndConstraints(gd);

    // store initial ranges *after* enforcing constraints, otherwise
    // we will never look like we're at the initial ranges
    if (graphWasEmpty) Axes.saveRangeInitial(gd);

    // this one is different from shapes/annotations calcAutorange
    // the others incorporate those components into ax._extremes,
    // this one actually sets the ranges in rangesliders.
    Registry.getComponentMethod('rangeslider', 'calcAutorange')(gd);
  }

  // draw ticks, titles, and calculate axis scaling (._b, ._m)
  function drawAxes() {
    return Axes.draw(gd, graphWasEmpty ? '' : 'redraw');
  }
  var seq = [Plots.previousPromises, addFrames, drawFramework, marginPushers, marginPushersAgain];
  if (hasCartesian) seq.push(positionAndAutorange);
  seq.push(subroutines.layoutStyles);
  if (hasCartesian) {
    seq.push(drawAxes, function insideTickLabelsAutorange(gd) {
      var insideTickLabelsUpdaterange = gd._fullLayout._insideTickLabelsUpdaterange;
      if (insideTickLabelsUpdaterange) {
        gd._fullLayout._insideTickLabelsUpdaterange = undefined;
        return relayout(gd, insideTickLabelsUpdaterange).then(function () {
          Axes.saveRangeInitial(gd, true);
        });
      }
    });
  }
  seq.push(subroutines.drawData, subroutines.finalDraw, initInteractions, Plots.addLinks, Plots.rehover, Plots.redrag, Plots.reselect,
  // TODO: doAutoMargin is only needed here for axis automargin, which
  // happens outside of marginPushers where all the other automargins are
  // calculated. Would be much better to separate margin calculations from
  // component drawing - see https://github.com/plotly/plotly.js/issues/2704
  Plots.doAutoMargin, Plots.previousPromises);

  // even if everything we did was synchronous, return a promise
  // so that the caller doesn't care which route we took
  var plotDone = Lib.syncOrAsync(seq, gd);
  if (!plotDone || !plotDone.then) plotDone = Promise.resolve();
  return plotDone.then(function () {
    emitAfterPlot(gd);
    return gd;
  });
}
function emitAfterPlot(gd) {
  var fullLayout = gd._fullLayout;
  if (fullLayout._redrawFromAutoMarginCount) {
    fullLayout._redrawFromAutoMarginCount--;
  } else {
    gd.emit('plotly_afterplot');
  }
}
function setPlotConfig(obj) {
  return Lib.extendFlat(dfltConfig, obj);
}
function setBackground(gd, bgColor) {
  try {
    gd._fullLayout._paper.style('background', bgColor);
  } catch (e) {
    Lib.error(e);
  }
}
function opaqueSetBackground(gd, bgColor) {
  var blend = Color.combine(bgColor, 'white');
  setBackground(gd, blend);
}
function setPlotContext(gd, config) {
  if (!gd._context) {
    gd._context = Lib.extendDeep({}, dfltConfig);

    // stash <base> href, used to make robust clipPath URLs
    var base = d3.select('base');
    gd._context._baseUrl = base.size() && base.attr('href') ? window.location.href.split('#')[0] : '';
  }
  var context = gd._context;
  var i, keys, key;
  if (config) {
    keys = Object.keys(config);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      if (key === 'editable' || key === 'edits') continue;
      if (key in context) {
        if (key === 'setBackground' && config[key] === 'opaque') {
          context[key] = opaqueSetBackground;
        } else {
          context[key] = config[key];
        }
      }
    }

    // map plot3dPixelRatio to plotGlPixelRatio for backward compatibility
    if (config.plot3dPixelRatio && !context.plotGlPixelRatio) {
      context.plotGlPixelRatio = context.plot3dPixelRatio;
    }

    // now deal with editable and edits - first editable overrides
    // everything, then edits refines
    var editable = config.editable;
    if (editable !== undefined) {
      // we're not going to *use* context.editable, we're only going to
      // use context.edits... but keep it for the record
      context.editable = editable;
      keys = Object.keys(context.edits);
      for (i = 0; i < keys.length; i++) {
        context.edits[keys[i]] = editable;
      }
    }
    if (config.edits) {
      keys = Object.keys(config.edits);
      for (i = 0; i < keys.length; i++) {
        key = keys[i];
        if (key in context.edits) {
          context.edits[key] = config.edits[key];
        }
      }
    }

    // not part of the user-facing config options
    context._exportedPlot = config._exportedPlot;
  }

  // staticPlot forces a bunch of others:
  if (context.staticPlot) {
    context.editable = false;
    context.edits = {};
    context.autosizable = false;
    context.scrollZoom = false;
    context.doubleClick = false;
    context.showTips = false;
    context.showLink = false;
    context.displayModeBar = false;
  }

  // make sure hover-only devices have mode bar visible
  if (context.displayModeBar === 'hover' && !hasHover) {
    context.displayModeBar = true;
  }

  // default and fallback for setBackground
  if (context.setBackground === 'transparent' || typeof context.setBackground !== 'function') {
    context.setBackground = setBackground;
  }

  // Check if gd has a specified widht/height to begin with
  context._hasZeroHeight = context._hasZeroHeight || gd.clientHeight === 0;
  context._hasZeroWidth = context._hasZeroWidth || gd.clientWidth === 0;

  // fill context._scrollZoom helper to help manage scrollZoom flaglist
  var szIn = context.scrollZoom;
  var szOut = context._scrollZoom = {};
  if (szIn === true) {
    szOut.cartesian = 1;
    szOut.gl3d = 1;
    szOut.geo = 1;
    szOut.mapbox = 1;
  } else if (typeof szIn === 'string') {
    var parts = szIn.split('+');
    for (i = 0; i < parts.length; i++) {
      szOut[parts[i]] = 1;
    }
  } else if (szIn !== false) {
    szOut.gl3d = 1;
    szOut.geo = 1;
    szOut.mapbox = 1;
  }
}

// convenience function to force a full redraw, mostly for use by plotly.js
function redraw(gd) {
  gd = Lib.getGraphDiv(gd);
  if (!Lib.isPlotDiv(gd)) {
    throw new Error('This element is not a Plotly plot: ' + gd);
  }
  helpers.cleanData(gd.data);
  helpers.cleanLayout(gd.layout);
  gd.calcdata = undefined;
  return exports._doPlot(gd).then(function () {
    gd.emit('plotly_redraw');
    return gd;
  });
}

/**
 * Convenience function to make idempotent plot option obvious to users.
 *
 * @param gd
 * @param {Object[]} data
 * @param {Object} layout
 * @param {Object} config
 */
function newPlot(gd, data, layout, config) {
  gd = Lib.getGraphDiv(gd);

  // remove gl contexts
  Plots.cleanPlot([], {}, gd._fullData || [], gd._fullLayout || {});
  Plots.purge(gd);
  return exports._doPlot(gd, data, layout, config);
}

/**
 * Wrap negative indicies to their positive counterparts.
 *
 * @param {Number[]} indices An array of indices
 * @param {Number} maxIndex The maximum index allowable (arr.length - 1)
 */
function positivifyIndices(indices, maxIndex) {
  var parentLength = maxIndex + 1;
  var positiveIndices = [];
  var i;
  var index;
  for (i = 0; i < indices.length; i++) {
    index = indices[i];
    if (index < 0) {
      positiveIndices.push(parentLength + index);
    } else {
      positiveIndices.push(index);
    }
  }
  return positiveIndices;
}

/**
 * Ensures that an index array for manipulating gd.data is valid.
 *
 * Intended for use with addTraces, deleteTraces, and moveTraces.
 *
 * @param gd
 * @param indices
 * @param arrayName
 */
function assertIndexArray(gd, indices, arrayName) {
  var i, index;
  for (i = 0; i < indices.length; i++) {
    index = indices[i];

    // validate that indices are indeed integers
    if (index !== parseInt(index, 10)) {
      throw new Error('all values in ' + arrayName + ' must be integers');
    }

    // check that all indices are in bounds for given gd.data array length
    if (index >= gd.data.length || index < -gd.data.length) {
      throw new Error(arrayName + ' must be valid indices for gd.data.');
    }

    // check that indices aren't repeated
    if (indices.indexOf(index, i + 1) > -1 || index >= 0 && indices.indexOf(-gd.data.length + index) > -1 || index < 0 && indices.indexOf(gd.data.length + index) > -1) {
      throw new Error('each index in ' + arrayName + ' must be unique.');
    }
  }
}

/**
 * Private function used by Plotly.moveTraces to check input args
 *
 * @param gd
 * @param currentIndices
 * @param newIndices
 */
function checkMoveTracesArgs(gd, currentIndices, newIndices) {
  // check that gd has attribute 'data' and 'data' is array
  if (!Array.isArray(gd.data)) {
    throw new Error('gd.data must be an array.');
  }

  // validate currentIndices array
  if (typeof currentIndices === 'undefined') {
    throw new Error('currentIndices is a required argument.');
  } else if (!Array.isArray(currentIndices)) {
    currentIndices = [currentIndices];
  }
  assertIndexArray(gd, currentIndices, 'currentIndices');

  // validate newIndices array if it exists
  if (typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {
    newIndices = [newIndices];
  }
  if (typeof newIndices !== 'undefined') {
    assertIndexArray(gd, newIndices, 'newIndices');
  }

  // check currentIndices and newIndices are the same length if newIdices exists
  if (typeof newIndices !== 'undefined' && currentIndices.length !== newIndices.length) {
    throw new Error('current and new indices must be of equal length.');
  }
}
/**
 * A private function to reduce the type checking clutter in addTraces.
 *
 * @param gd
 * @param traces
 * @param newIndices
 */
function checkAddTracesArgs(gd, traces, newIndices) {
  var i, value;

  // check that gd has attribute 'data' and 'data' is array
  if (!Array.isArray(gd.data)) {
    throw new Error('gd.data must be an array.');
  }

  // make sure traces exists
  if (typeof traces === 'undefined') {
    throw new Error('traces must be defined.');
  }

  // make sure traces is an array
  if (!Array.isArray(traces)) {
    traces = [traces];
  }

  // make sure each value in traces is an object
  for (i = 0; i < traces.length; i++) {
    value = traces[i];
    if (typeof value !== 'object' || Array.isArray(value) || value === null) {
      throw new Error('all values in traces array must be non-array objects');
    }
  }

  // make sure we have an index for each trace
  if (typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {
    newIndices = [newIndices];
  }
  if (typeof newIndices !== 'undefined' && newIndices.length !== traces.length) {
    throw new Error('if indices is specified, traces.length must equal indices.length');
  }
}

/**
 * A private function to reduce the type checking clutter in spliceTraces.
 * Get all update Properties from gd.data. Validate inputs and outputs.
 * Used by prependTrace and extendTraces
 *
 * @param gd
 * @param update
 * @param indices
 * @param maxPoints
 */
function assertExtendTracesArgs(gd, update, indices, maxPoints) {
  var maxPointsIsObject = Lib.isPlainObject(maxPoints);
  if (!Array.isArray(gd.data)) {
    throw new Error('gd.data must be an array');
  }
  if (!Lib.isPlainObject(update)) {
    throw new Error('update must be a key:value object');
  }
  if (typeof indices === 'undefined') {
    throw new Error('indices must be an integer or array of integers');
  }
  assertIndexArray(gd, indices, 'indices');
  for (var key in update) {
    /*
     * Verify that the attribute to be updated contains as many trace updates
     * as indices. Failure must result in throw and no-op
     */
    if (!Array.isArray(update[key]) || update[key].length !== indices.length) {
      throw new Error('attribute ' + key + ' must be an array of length equal to indices array length');
    }

    /*
     * if maxPoints is an object it must match keys and array lengths of 'update' 1:1
     */
    if (maxPointsIsObject && (!(key in maxPoints) || !Array.isArray(maxPoints[key]) || maxPoints[key].length !== update[key].length)) {
      throw new Error('when maxPoints is set as a key:value object it must contain a 1:1 ' + 'corrispondence with the keys and number of traces in the update object');
    }
  }
}

/**
 * A private function to reduce the type checking clutter in spliceTraces.
 *
 * @param {Object|HTMLDivElement} gd
 * @param {Object} update
 * @param {Number[]} indices
 * @param {Number||Object} maxPoints
 * @return {Object[]}
 */
function getExtendProperties(gd, update, indices, maxPoints) {
  var maxPointsIsObject = Lib.isPlainObject(maxPoints);
  var updateProps = [];
  var trace, target, prop, insert, maxp;

  // allow scalar index to represent a single trace position
  if (!Array.isArray(indices)) indices = [indices];

  // negative indices are wrapped around to their positive value. Equivalent to python indexing.
  indices = positivifyIndices(indices, gd.data.length - 1);

  // loop through all update keys and traces and harvest validated data.
  for (var key in update) {
    for (var j = 0; j < indices.length; j++) {
      /*
       * Choose the trace indexed by the indices map argument and get the prop setter-getter
       * instance that references the key and value for this particular trace.
       */
      trace = gd.data[indices[j]];
      prop = nestedProperty(trace, key);

      /*
       * Target is the existing gd.data.trace.dataArray value like "x" or "marker.size"
       * Target must exist as an Array to allow the extend operation to be performed.
       */
      target = prop.get();
      insert = update[key][j];
      if (!Lib.isArrayOrTypedArray(insert)) {
        throw new Error('attribute: ' + key + ' index: ' + j + ' must be an array');
      }
      if (!Lib.isArrayOrTypedArray(target)) {
        throw new Error('cannot extend missing or non-array attribute: ' + key);
      }
      if (target.constructor !== insert.constructor) {
        throw new Error('cannot extend array with an array of a different type: ' + key);
      }

      /*
       * maxPoints may be an object map or a scalar. If object select the key:value, else
       * Use the scalar maxPoints for all key and trace combinations.
       */
      maxp = maxPointsIsObject ? maxPoints[key][j] : maxPoints;

      // could have chosen null here, -1 just tells us to not take a window
      if (!isNumeric(maxp)) maxp = -1;

      /*
       * Wrap the nestedProperty in an object containing required data
       * for lengthening and windowing this particular trace - key combination.
       * Flooring maxp mirrors the behaviour of floats in the Array.slice JSnative function.
       */
      updateProps.push({
        prop: prop,
        target: target,
        insert: insert,
        maxp: Math.floor(maxp)
      });
    }
  }

  // all target and insertion data now validated
  return updateProps;
}

/**
 * A private function to key Extend and Prepend traces DRY
 *
 * @param {Object|HTMLDivElement} gd
 * @param {Object} update
 * @param {Number[]} indices
 * @param {Number||Object} maxPoints
 * @param {Function} updateArray
 * @return {Object}
 */
function spliceTraces(gd, update, indices, maxPoints, updateArray) {
  assertExtendTracesArgs(gd, update, indices, maxPoints);
  var updateProps = getExtendProperties(gd, update, indices, maxPoints);
  var undoUpdate = {};
  var undoPoints = {};
  for (var i = 0; i < updateProps.length; i++) {
    var prop = updateProps[i].prop;
    var maxp = updateProps[i].maxp;

    // return new array and remainder
    var out = updateArray(updateProps[i].target, updateProps[i].insert, maxp);
    prop.set(out[0]);

    // build the inverse update object for the undo operation
    if (!Array.isArray(undoUpdate[prop.astr])) undoUpdate[prop.astr] = [];
    undoUpdate[prop.astr].push(out[1]);

    // build the matching maxPoints undo object containing original trace lengths
    if (!Array.isArray(undoPoints[prop.astr])) undoPoints[prop.astr] = [];
    undoPoints[prop.astr].push(updateProps[i].target.length);
  }
  return {
    update: undoUpdate,
    maxPoints: undoPoints
  };
}
function concatTypedArray(arr0, arr1) {
  var arr2 = new arr0.constructor(arr0.length + arr1.length);
  arr2.set(arr0);
  arr2.set(arr1, arr0.length);
  return arr2;
}

/**
 * extend && prepend traces at indices with update arrays, window trace lengths to maxPoints
 *
 * Extend and Prepend have identical APIs. Prepend inserts an array at the head while Extend
 * inserts an array off the tail. Prepend truncates the tail of the array - counting maxPoints
 * from the head, whereas Extend truncates the head of the array, counting backward maxPoints
 * from the tail.
 *
 * If maxPoints is undefined, nonNumeric, negative or greater than extended trace length no
 * truncation / windowing will be performed. If its zero, well the whole trace is truncated.
 *
 * @param {Object|HTMLDivElement} gd The graph div
 * @param {Object} update The key:array map of target attributes to extend
 * @param {Number|Number[]} indices The locations of traces to be extended
 * @param {Number|Object} [maxPoints] Number of points for trace window after lengthening.
 *
 */
function extendTraces(gd, update, indices, maxPoints) {
  gd = Lib.getGraphDiv(gd);
  function updateArray(target, insert, maxp) {
    var newArray, remainder;
    if (Lib.isTypedArray(target)) {
      if (maxp < 0) {
        var none = new target.constructor(0);
        var both = concatTypedArray(target, insert);
        if (maxp < 0) {
          newArray = both;
          remainder = none;
        } else {
          newArray = none;
          remainder = both;
        }
      } else {
        newArray = new target.constructor(maxp);
        remainder = new target.constructor(target.length + insert.length - maxp);
        if (maxp === insert.length) {
          newArray.set(insert);
          remainder.set(target);
        } else if (maxp < insert.length) {
          var numberOfItemsFromInsert = insert.length - maxp;
          newArray.set(insert.subarray(numberOfItemsFromInsert));
          remainder.set(target);
          remainder.set(insert.subarray(0, numberOfItemsFromInsert), target.length);
        } else {
          var numberOfItemsFromTarget = maxp - insert.length;
          var targetBegin = target.length - numberOfItemsFromTarget;
          newArray.set(target.subarray(targetBegin));
          newArray.set(insert, numberOfItemsFromTarget);
          remainder.set(target.subarray(0, targetBegin));
        }
      }
    } else {
      newArray = target.concat(insert);
      remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(0, newArray.length - maxp) : [];
    }
    return [newArray, remainder];
  }
  var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);
  var promise = exports.redraw(gd);
  var undoArgs = [gd, undo.update, indices, undo.maxPoints];
  Queue.add(gd, exports.prependTraces, undoArgs, extendTraces, arguments);
  return promise;
}
function prependTraces(gd, update, indices, maxPoints) {
  gd = Lib.getGraphDiv(gd);
  function updateArray(target, insert, maxp) {
    var newArray, remainder;
    if (Lib.isTypedArray(target)) {
      if (maxp <= 0) {
        var none = new target.constructor(0);
        var both = concatTypedArray(insert, target);
        if (maxp < 0) {
          newArray = both;
          remainder = none;
        } else {
          newArray = none;
          remainder = both;
        }
      } else {
        newArray = new target.constructor(maxp);
        remainder = new target.constructor(target.length + insert.length - maxp);
        if (maxp === insert.length) {
          newArray.set(insert);
          remainder.set(target);
        } else if (maxp < insert.length) {
          var numberOfItemsFromInsert = insert.length - maxp;
          newArray.set(insert.subarray(0, numberOfItemsFromInsert));
          remainder.set(insert.subarray(numberOfItemsFromInsert));
          remainder.set(target, numberOfItemsFromInsert);
        } else {
          var numberOfItemsFromTarget = maxp - insert.length;
          newArray.set(insert);
          newArray.set(target.subarray(0, numberOfItemsFromTarget), insert.length);
          remainder.set(target.subarray(numberOfItemsFromTarget));
        }
      }
    } else {
      newArray = insert.concat(target);
      remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(maxp, newArray.length) : [];
    }
    return [newArray, remainder];
  }
  var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);
  var promise = exports.redraw(gd);
  var undoArgs = [gd, undo.update, indices, undo.maxPoints];
  Queue.add(gd, exports.extendTraces, undoArgs, prependTraces, arguments);
  return promise;
}

/**
 * Add data traces to an existing graph div.
 *
 * @param {Object|HTMLDivElement} gd The graph div
 * @param {Object[]} gd.data The array of traces we're adding to
 * @param {Object[]|Object} traces The object or array of objects to add
 * @param {Number[]|Number} [newIndices=[gd.data.length]] Locations to add traces
 *
 */
function addTraces(gd, traces, newIndices) {
  gd = Lib.getGraphDiv(gd);
  var currentIndices = [];
  var undoFunc = exports.deleteTraces;
  var redoFunc = addTraces;
  var undoArgs = [gd, currentIndices];
  var redoArgs = [gd, traces]; // no newIndices here
  var i;
  var promise;

  // all validation is done elsewhere to remove clutter here
  checkAddTracesArgs(gd, traces, newIndices);

  // make sure traces is an array
  if (!Array.isArray(traces)) {
    traces = [traces];
  }

  // make sure traces do not repeat existing ones
  traces = traces.map(function (trace) {
    return Lib.extendFlat({}, trace);
  });
  helpers.cleanData(traces);

  // add the traces to gd.data (no redrawing yet!)
  for (i = 0; i < traces.length; i++) {
    gd.data.push(traces[i]);
  }

  // to continue, we need to call moveTraces which requires currentIndices
  for (i = 0; i < traces.length; i++) {
    currentIndices.push(-traces.length + i);
  }

  // if the user didn't define newIndices, they just want the traces appended
  // i.e., we can simply redraw and be done
  if (typeof newIndices === 'undefined') {
    promise = exports.redraw(gd);
    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
    return promise;
  }

  // make sure indices is property defined
  if (!Array.isArray(newIndices)) {
    newIndices = [newIndices];
  }
  try {
    // this is redundant, but necessary to not catch later possible errors!
    checkMoveTracesArgs(gd, currentIndices, newIndices);
  } catch (error) {
    // something went wrong, reset gd to be safe and rethrow error
    gd.data.splice(gd.data.length - traces.length, traces.length);
    throw error;
  }

  // if we're here, the user has defined specific places to place the new traces
  // this requires some extra work that moveTraces will do
  Queue.startSequence(gd);
  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
  promise = exports.moveTraces(gd, currentIndices, newIndices);
  Queue.stopSequence(gd);
  return promise;
}

/**
 * Delete traces at `indices` from gd.data array.
 *
 * @param {Object|HTMLDivElement} gd The graph div
 * @param {Object[]} gd.data The array of traces we're removing from
 * @param {Number|Number[]} indices The indices
 */
function deleteTraces(gd, indices) {
  gd = Lib.getGraphDiv(gd);
  var traces = [];
  var undoFunc = exports.addTraces;
  var redoFunc = deleteTraces;
  var undoArgs = [gd, traces, indices];
  var redoArgs = [gd, indices];
  var i;
  var deletedTrace;

  // make sure indices are defined
  if (typeof indices === 'undefined') {
    throw new Error('indices must be an integer or array of integers.');
  } else if (!Array.isArray(indices)) {
    indices = [indices];
  }
  assertIndexArray(gd, indices, 'indices');

  // convert negative indices to positive indices
  indices = positivifyIndices(indices, gd.data.length - 1);

  // we want descending here so that splicing later doesn't affect indexing
  indices.sort(Lib.sorterDes);
  for (i = 0; i < indices.length; i += 1) {
    deletedTrace = gd.data.splice(indices[i], 1)[0];
    traces.push(deletedTrace);
  }
  var promise = exports.redraw(gd);
  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
  return promise;
}

/**
 * Move traces at currentIndices array to locations in newIndices array.
 *
 * If newIndices is omitted, currentIndices will be moved to the end. E.g.,
 * these are equivalent:
 *
 * Plotly.moveTraces(gd, [1, 2, 3], [-3, -2, -1])
 * Plotly.moveTraces(gd, [1, 2, 3])
 *
 * @param {Object|HTMLDivElement} gd The graph div
 * @param {Object[]} gd.data The array of traces we're removing from
 * @param {Number|Number[]} currentIndices The locations of traces to be moved
 * @param {Number|Number[]} [newIndices] The locations to move traces to
 *
 * Example calls:
 *
 *      // move trace i to location x
 *      Plotly.moveTraces(gd, i, x)
 *
 *      // move trace i to end of array
 *      Plotly.moveTraces(gd, i)
 *
 *      // move traces i, j, k to end of array (i != j != k)
 *      Plotly.moveTraces(gd, [i, j, k])
 *
 *      // move traces [i, j, k] to [x, y, z] (i != j != k) (x != y != z)
 *      Plotly.moveTraces(gd, [i, j, k], [x, y, z])
 *
 *      // reorder all traces (assume there are 5--a, b, c, d, e)
 *      Plotly.moveTraces(gd, [b, d, e, a, c])  // same as 'move to end'
 */
function moveTraces(gd, currentIndices, newIndices) {
  gd = Lib.getGraphDiv(gd);
  var newData = [];
  var movingTraceMap = [];
  var undoFunc = moveTraces;
  var redoFunc = moveTraces;
  var undoArgs = [gd, newIndices, currentIndices];
  var redoArgs = [gd, currentIndices, newIndices];
  var i;

  // to reduce complexity here, check args elsewhere
  // this throws errors where appropriate
  checkMoveTracesArgs(gd, currentIndices, newIndices);

  // make sure currentIndices is an array
  currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices];

  // if undefined, define newIndices to point to the end of gd.data array
  if (typeof newIndices === 'undefined') {
    newIndices = [];
    for (i = 0; i < currentIndices.length; i++) {
      newIndices.push(-currentIndices.length + i);
    }
  }

  // make sure newIndices is an array if it's user-defined
  newIndices = Array.isArray(newIndices) ? newIndices : [newIndices];

  // convert negative indices to positive indices (they're the same length)
  currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);
  newIndices = positivifyIndices(newIndices, gd.data.length - 1);

  // at this point, we've coerced the index arrays into predictable forms

  // get the traces that aren't being moved around
  for (i = 0; i < gd.data.length; i++) {
    // if index isn't in currentIndices, include it in ignored!
    if (currentIndices.indexOf(i) === -1) {
      newData.push(gd.data[i]);
    }
  }

  // get a mapping of indices to moving traces
  for (i = 0; i < currentIndices.length; i++) {
    movingTraceMap.push({
      newIndex: newIndices[i],
      trace: gd.data[currentIndices[i]]
    });
  }

  // reorder this mapping by newIndex, ascending
  movingTraceMap.sort(function (a, b) {
    return a.newIndex - b.newIndex;
  });

  // now, add the moving traces back in, in order!
  for (i = 0; i < movingTraceMap.length; i += 1) {
    newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);
  }
  gd.data = newData;
  var promise = exports.redraw(gd);
  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
  return promise;
}

/**
 * restyle: update trace attributes of an existing plot
 *
 * Can be called two ways.
 *
 * Signature 1:
 * @param {String | HTMLDivElement} gd
 *  the id or DOM element of the graph container div
 * @param {String} astr
 *  attribute string (like `'marker.symbol'`) to update
 * @param {*} val
 *  value to give this attribute
 * @param {Number[] | Number} [traces]
 *  integer or array of integers for the traces to alter (all if omitted)
 *
 * Signature 2:
 * @param {String | HTMLDivElement} gd
 *  (as in signature 1)
 * @param {Object} aobj
 *  attribute object `{astr1: val1, astr2: val2 ...}`
 *  allows setting multiple attributes simultaneously
 * @param {Number[] | Number} [traces]
 *  (as in signature 1)
 *
 * `val` (or `val1`, `val2` ... in the object form) can be an array,
 * to apply different values to each trace.
 *
 * If the array is too short, it will wrap around (useful for
 * style files that want to specify cyclical default values).
 */
function restyle(gd, astr, val, _traces) {
  gd = Lib.getGraphDiv(gd);
  helpers.clearPromiseQueue(gd);
  var aobj = {};
  if (typeof astr === 'string') aobj[astr] = val;else if (Lib.isPlainObject(astr)) {
    // the 3-arg form
    aobj = Lib.extendFlat({}, astr);
    if (_traces === undefined) _traces = val;
  } else {
    Lib.warn('Restyle fail.', astr, val, _traces);
    return Promise.reject();
  }
  if (Object.keys(aobj).length) gd.changed = true;
  var traces = helpers.coerceTraceIndices(gd, _traces);
  var specs = _restyle(gd, aobj, traces);
  var flags = specs.flags;

  // clear calcdata and/or axis types if required so they get regenerated
  if (flags.calc) gd.calcdata = undefined;
  if (flags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, {});

  // fill in redraw sequence
  var seq = [];
  if (flags.fullReplot) {
    seq.push(exports._doPlot);
  } else {
    seq.push(Plots.previousPromises);

    // maybe only call Plots.supplyDataDefaults in the splom case,
    // to skip over long and slow axes defaults
    Plots.supplyDefaults(gd);
    if (flags.markerSize) {
      Plots.doCalcdata(gd);
      addAxRangeSequence(seq);

      // TODO
      // if all axes have autorange:false, then
      // proceed to subroutines.doTraceStyle(),
      // otherwise we must go through addAxRangeSequence,
      // which in general must redraws 'all' axes
    }

    if (flags.style) seq.push(subroutines.doTraceStyle);
    if (flags.colorbars) seq.push(subroutines.doColorBars);
    seq.push(emitAfterPlot);
  }
  seq.push(Plots.rehover, Plots.redrag, Plots.reselect);
  Queue.add(gd, restyle, [gd, specs.undoit, specs.traces], restyle, [gd, specs.redoit, specs.traces]);
  var plotDone = Lib.syncOrAsync(seq, gd);
  if (!plotDone || !plotDone.then) plotDone = Promise.resolve();
  return plotDone.then(function () {
    gd.emit('plotly_restyle', specs.eventData);
    return gd;
  });
}

// for undo: undefined initial vals must be turned into nulls
// so that we unset rather than ignore them
function undefinedToNull(val) {
  if (val === undefined) return null;
  return val;
}

/**
 * Factory function to wrap nestedProperty with GUI edits if necessary
 * with GUI edits we add an optional prefix to the nestedProperty constructor
 * to prepend to the attribute string in the preGUI store.
 */
function makeNP(preGUI, guiEditFlag) {
  if (!guiEditFlag) return nestedProperty;
  return function (container, attr, prefix) {
    var np = nestedProperty(container, attr);
    var npSet = np.set;
    np.set = function (val) {
      var fullAttr = (prefix || '') + attr;
      storeCurrent(fullAttr, np.get(), val, preGUI);
      npSet(val);
    };
    return np;
  };
}
function storeCurrent(attr, val, newVal, preGUI) {
  if (Array.isArray(val) || Array.isArray(newVal)) {
    var arrayVal = Array.isArray(val) ? val : [];
    var arrayNew = Array.isArray(newVal) ? newVal : [];
    var maxLen = Math.max(arrayVal.length, arrayNew.length);
    for (var i = 0; i < maxLen; i++) {
      storeCurrent(attr + '[' + i + ']', arrayVal[i], arrayNew[i], preGUI);
    }
  } else if (Lib.isPlainObject(val) || Lib.isPlainObject(newVal)) {
    var objVal = Lib.isPlainObject(val) ? val : {};
    var objNew = Lib.isPlainObject(newVal) ? newVal : {};
    var objBoth = Lib.extendFlat({}, objVal, objNew);
    for (var key in objBoth) {
      storeCurrent(attr + '.' + key, objVal[key], objNew[key], preGUI);
    }
  } else if (preGUI[attr] === undefined) {
    preGUI[attr] = undefinedToNull(val);
  }
}

/**
 * storeDirectGUIEdit: for routines that skip restyle/relayout and mock it
 * by emitting a plotly_restyle or plotly_relayout event, this routine
 * keeps track of the initial state in _preGUI for use by uirevision
 * Does *not* apply these changes to data/layout - that's the responsibility
 * of the calling routine.
 *
 * @param {object} container: the input attributes container (eg `layout` or a `trace`)
 * @param {object} preGUI: where original values should be stored, either
 *     `layout._preGUI` or `layout._tracePreGUI[uid]`
 * @param {object} edits: the {attr: val} object as normally passed to `relayout` etc
 */
function _storeDirectGUIEdit(container, preGUI, edits) {
  for (var attr in edits) {
    var np = nestedProperty(container, attr);
    storeCurrent(attr, np.get(), edits[attr], preGUI);
  }
}
function _restyle(gd, aobj, traces) {
  var fullLayout = gd._fullLayout;
  var fullData = gd._fullData;
  var data = gd.data;
  var guiEditFlag = fullLayout._guiEditing;
  var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);
  var eventData = Lib.extendDeepAll({}, aobj);
  var i;
  cleanDeprecatedAttributeKeys(aobj);

  // initialize flags
  var flags = editTypes.traceFlags();

  // copies of the change (and previous values of anything affected)
  // for the undo / redo queue
  var redoit = {};
  var undoit = {};
  var axlist;

  // make a new empty vals array for undoit
  function a0() {
    return traces.map(function () {
      return undefined;
    });
  }

  // for autoranging multiple axes
  function addToAxlist(axid) {
    var axName = Axes.id2name(axid);
    if (axlist.indexOf(axName) === -1) axlist.push(axName);
  }
  function autorangeAttr(axName) {
    return 'LAYOUT' + axName + '.autorange';
  }
  function rangeAttr(axName) {
    return 'LAYOUT' + axName + '.range';
  }
  function getFullTrace(traceIndex) {
    // usually fullData maps 1:1 onto data, but with groupby transforms
    // the fullData index can be greater. Take the *first* matching trace.
    for (var j = traceIndex; j < fullData.length; j++) {
      if (fullData[j]._input === data[traceIndex]) return fullData[j];
    }
    // should never get here - and if we *do* it should cause an error
    // later on undefined fullTrace is passed to nestedProperty.
  }

  // for attrs that interact (like scales & autoscales), save the
  // old vals before making the change
  // val=undefined will not set a value, just record what the value was.
  // val=null will delete the attribute
  // attr can be an array to set several at once (all to the same val)
  function doextra(attr, val, i) {
    if (Array.isArray(attr)) {
      attr.forEach(function (a) {
        doextra(a, val, i);
      });
      return;
    }
    // quit if explicitly setting this elsewhere
    if (attr in aobj || helpers.hasParent(aobj, attr)) return;
    var extraparam;
    if (attr.substr(0, 6) === 'LAYOUT') {
      extraparam = layoutNP(gd.layout, attr.replace('LAYOUT', ''));
    } else {
      var tracei = traces[i];
      var preGUI = fullLayout._tracePreGUI[getFullTrace(tracei)._fullInput.uid];
      extraparam = makeNP(preGUI, guiEditFlag)(data[tracei], attr);
    }
    if (!(attr in undoit)) {
      undoit[attr] = a0();
    }
    if (undoit[attr][i] === undefined) {
      undoit[attr][i] = undefinedToNull(extraparam.get());
    }
    if (val !== undefined) {
      extraparam.set(val);
    }
  }
  function allBins(binAttr) {
    return function (j) {
      return fullData[j][binAttr];
    };
  }
  function arrayBins(binAttr) {
    return function (vij, j) {
      return vij === false ? fullData[traces[j]][binAttr] : null;
    };
  }

  // now make the changes to gd.data (and occasionally gd.layout)
  // and figure out what kind of graphics update we need to do
  for (var ai in aobj) {
    if (helpers.hasParent(aobj, ai)) {
      throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');
    }
    var vi = aobj[ai];
    var cont;
    var contFull;
    var param;
    var oldVal;
    var newVal;
    var valObject;

    // Backward compatibility shim for turning histogram autobin on,
    // or freezing previous autobinned values.
    // Replace obsolete `autobin(x|y): true` with `(x|y)bins: null`
    // and `autobin(x|y): false` with the `(x|y)bins` in `fullData`
    if (ai === 'autobinx' || ai === 'autobiny') {
      ai = ai.charAt(ai.length - 1) + 'bins';
      if (Array.isArray(vi)) vi = vi.map(arrayBins(ai));else if (vi === false) vi = traces.map(allBins(ai));else vi = null;
    }
    redoit[ai] = vi;
    if (ai.substr(0, 6) === 'LAYOUT') {
      param = layoutNP(gd.layout, ai.replace('LAYOUT', ''));
      undoit[ai] = [undefinedToNull(param.get())];
      // since we're allowing val to be an array, allow it here too,
      // even though that's meaningless
      param.set(Array.isArray(vi) ? vi[0] : vi);
      // ironically, the layout attrs in restyle only require replot,
      // not relayout
      flags.calc = true;
      continue;
    }

    // set attribute in gd.data
    undoit[ai] = a0();
    for (i = 0; i < traces.length; i++) {
      cont = data[traces[i]];
      contFull = getFullTrace(traces[i]);
      var preGUI = fullLayout._tracePreGUI[contFull._fullInput.uid];
      param = makeNP(preGUI, guiEditFlag)(cont, ai);
      oldVal = param.get();
      newVal = Array.isArray(vi) ? vi[i % vi.length] : vi;
      if (newVal === undefined) continue;
      var finalPart = param.parts[param.parts.length - 1];
      var prefix = ai.substr(0, ai.length - finalPart.length - 1);
      var prefixDot = prefix ? prefix + '.' : '';
      var innerContFull = prefix ? nestedProperty(contFull, prefix).get() : contFull;
      valObject = PlotSchema.getTraceValObject(contFull, param.parts);
      if (valObject && valObject.impliedEdits && newVal !== null) {
        for (var impliedKey in valObject.impliedEdits) {
          doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey], i);
        }
      } else if ((finalPart === 'thicknessmode' || finalPart === 'lenmode') && oldVal !== newVal && (newVal === 'fraction' || newVal === 'pixels') && innerContFull) {
        // changing colorbar size modes,
        // make the resulting size not change
        // note that colorbar fractional sizing is based on the
        // original plot size, before anything (like a colorbar)
        // increases the margins

        var gs = fullLayout._size;
        var orient = innerContFull.orient;
        var topOrBottom = orient === 'top' || orient === 'bottom';
        if (finalPart === 'thicknessmode') {
          var thicknorm = topOrBottom ? gs.h : gs.w;
          doextra(prefixDot + 'thickness', innerContFull.thickness * (newVal === 'fraction' ? 1 / thicknorm : thicknorm), i);
        } else {
          var lennorm = topOrBottom ? gs.w : gs.h;
          doextra(prefixDot + 'len', innerContFull.len * (newVal === 'fraction' ? 1 / lennorm : lennorm), i);
        }
      } else if (ai === 'type' && (newVal === 'pie' !== (oldVal === 'pie') || newVal === 'funnelarea' !== (oldVal === 'funnelarea'))) {
        var labelsTo = 'x';
        var valuesTo = 'y';
        if ((newVal === 'bar' || oldVal === 'bar') && cont.orientation === 'h') {
          labelsTo = 'y';
          valuesTo = 'x';
        }
        Lib.swapAttrs(cont, ['?', '?src'], 'labels', labelsTo);
        Lib.swapAttrs(cont, ['d?', '?0'], 'label', labelsTo);
        Lib.swapAttrs(cont, ['?', '?src'], 'values', valuesTo);
        if (oldVal === 'pie' || oldVal === 'funnelarea') {
          nestedProperty(cont, 'marker.color').set(nestedProperty(cont, 'marker.colors').get());

          // super kludgy - but if all pies are gone we won't remove them otherwise
          fullLayout._pielayer.selectAll('g.trace').remove();
        } else if (Registry.traceIs(cont, 'cartesian')) {
          nestedProperty(cont, 'marker.colors').set(nestedProperty(cont, 'marker.color').get());
        }
      }
      undoit[ai][i] = undefinedToNull(oldVal);
      // set the new value - if val is an array, it's one el per trace
      // first check for attributes that get more complex alterations
      var swapAttrs = ['swapxy', 'swapxyaxes', 'orientation', 'orientationaxes'];
      if (swapAttrs.indexOf(ai) !== -1) {
        // setting an orientation: make sure it's changing
        // before we swap everything else
        if (ai === 'orientation') {
          param.set(newVal);
          // obnoxious that we need this level of coupling... but in order to
          // properly handle setting orientation to `null` we need to mimic
          // the logic inside Bars.supplyDefaults for default orientation
          var defaultOrientation = cont.x && !cont.y ? 'h' : 'v';
          if ((param.get() || defaultOrientation) === contFull.orientation) {
            continue;
          }
        } else if (ai === 'orientationaxes') {
          // orientationaxes has no value,
          // it flips everything and the axes

          cont.orientation = {
            v: 'h',
            h: 'v'
          }[contFull.orientation];
        }
        helpers.swapXYData(cont);
        flags.calc = flags.clearAxisTypes = true;
      } else if (Plots.dataArrayContainers.indexOf(param.parts[0]) !== -1) {
        // TODO: use manageArrays.applyContainerArrayChanges here too
        helpers.manageArrayContainers(param, newVal, undoit);
        flags.calc = true;
      } else {
        if (valObject) {
          // must redo calcdata when restyling array values of arrayOk attributes
          // ... but no need to this for regl-based traces
          if (valObject.arrayOk && !Registry.traceIs(contFull, 'regl') && (Lib.isArrayOrTypedArray(newVal) || Lib.isArrayOrTypedArray(oldVal))) {
            flags.calc = true;
          } else editTypes.update(flags, valObject);
        } else {
          /*
           * if we couldn't find valObject,  assume a full recalc.
           * This can happen if you're changing type and making
           * some other edits too, so the modules we're
           * looking at don't have these attributes in them.
           */
          flags.calc = true;
        }

        // all the other ones, just modify that one attribute
        param.set(newVal);
      }
    }

    // swap the data attributes of the relevant x and y axes?
    if (['swapxyaxes', 'orientationaxes'].indexOf(ai) !== -1) {
      Axes.swap(gd, traces);
    }

    // swap hovermode if set to "compare x/y data"
    if (ai === 'orientationaxes') {
      var hovermode = nestedProperty(gd.layout, 'hovermode');
      var h = hovermode.get();
      if (h === 'x') {
        hovermode.set('y');
      } else if (h === 'y') {
        hovermode.set('x');
      } else if (h === 'x unified') {
        hovermode.set('y unified');
      } else if (h === 'y unified') {
        hovermode.set('x unified');
      }
    }

    // Major enough changes deserve autoscale and
    // non-reversed axes so people don't get confused
    //
    // Note: autobin (or its new analog bin clearing) is not included here
    // since we're not pushing bins back to gd.data, so if we have bin
    // info it was explicitly provided by the user.
    if (['orientation', 'type'].indexOf(ai) !== -1) {
      axlist = [];
      for (i = 0; i < traces.length; i++) {
        var trace = data[traces[i]];
        if (Registry.traceIs(trace, 'cartesian')) {
          addToAxlist(trace.xaxis || 'x');
          addToAxlist(trace.yaxis || 'y');
        }
      }
      doextra(axlist.map(autorangeAttr), true, 0);
      doextra(axlist.map(rangeAttr), [0, 1], 0);
    }
  }
  if (flags.calc || flags.plot) {
    flags.fullReplot = true;
  }
  return {
    flags: flags,
    undoit: undoit,
    redoit: redoit,
    traces: traces,
    eventData: Lib.extendDeepNoArrays([], [eventData, traces])
  };
}

/**
 * Converts deprecated attribute keys to
 * the current API to ensure backwards compatibility.
 *
 * This is needed for the update mechanism to determine which
 * subroutines to run based on the actual attribute
 * definitions (that don't include the deprecated ones).
 *
 * E.g. Maps {'xaxis.title': 'A chart'} to {'xaxis.title.text': 'A chart'}
 * and {titlefont: {...}} to {'title.font': {...}}.
 *
 * @param aobj
 */
function cleanDeprecatedAttributeKeys(aobj) {
  var oldAxisTitleRegex = Lib.counterRegex('axis', '\.title', false, false);
  var colorbarRegex = /colorbar\.title$/;
  var keys = Object.keys(aobj);
  var i, key, value;
  for (i = 0; i < keys.length; i++) {
    key = keys[i];
    value = aobj[key];
    if ((key === 'title' || oldAxisTitleRegex.test(key) || colorbarRegex.test(key)) && (typeof value === 'string' || typeof value === 'number')) {
      replace(key, key.replace('title', 'title.text'));
    } else if (key.indexOf('titlefont') > -1 && key.indexOf('grouptitlefont') === -1) {
      replace(key, key.replace('titlefont', 'title.font'));
    } else if (key.indexOf('titleposition') > -1) {
      replace(key, key.replace('titleposition', 'title.position'));
    } else if (key.indexOf('titleside') > -1) {
      replace(key, key.replace('titleside', 'title.side'));
    } else if (key.indexOf('titleoffset') > -1) {
      replace(key, key.replace('titleoffset', 'title.offset'));
    }
  }
  function replace(oldAttrStr, newAttrStr) {
    aobj[newAttrStr] = aobj[oldAttrStr];
    delete aobj[oldAttrStr];
  }
}

/**
 * relayout: update layout attributes of an existing plot
 *
 * Can be called two ways:
 *
 * Signature 1:
 * @param {String | HTMLDivElement} gd
 *  the id or dom element of the graph container div
 * @param {String} astr
 *  attribute string (like `'xaxis.range[0]'`) to update
 * @param {*} val
 *  value to give this attribute
 *
 * Signature 2:
 * @param {String | HTMLDivElement} gd
 *  (as in signature 1)
 * @param {Object} aobj
 *  attribute object `{astr1: val1, astr2: val2 ...}`
 *  allows setting multiple attributes simultaneously
 */
function relayout(gd, astr, val) {
  gd = Lib.getGraphDiv(gd);
  helpers.clearPromiseQueue(gd);
  var aobj = {};
  if (typeof astr === 'string') {
    aobj[astr] = val;
  } else if (Lib.isPlainObject(astr)) {
    aobj = Lib.extendFlat({}, astr);
  } else {
    Lib.warn('Relayout fail.', astr, val);
    return Promise.reject();
  }
  if (Object.keys(aobj).length) gd.changed = true;
  var specs = _relayout(gd, aobj);
  var flags = specs.flags;

  // clear calcdata if required
  if (flags.calc) gd.calcdata = undefined;

  // fill in redraw sequence

  // even if we don't have anything left in aobj,
  // something may have happened within relayout that we
  // need to wait for
  var seq = [Plots.previousPromises];
  if (flags.layoutReplot) {
    seq.push(subroutines.layoutReplot);
  } else if (Object.keys(aobj).length) {
    axRangeSupplyDefaultsByPass(gd, flags, specs) || Plots.supplyDefaults(gd);
    if (flags.legend) seq.push(subroutines.doLegend);
    if (flags.layoutstyle) seq.push(subroutines.layoutStyles);
    if (flags.axrange) addAxRangeSequence(seq, specs.rangesAltered);
    if (flags.ticks) seq.push(subroutines.doTicksRelayout);
    if (flags.modebar) seq.push(subroutines.doModeBar);
    if (flags.camera) seq.push(subroutines.doCamera);
    if (flags.colorbars) seq.push(subroutines.doColorBars);
    seq.push(emitAfterPlot);
  }
  seq.push(Plots.rehover, Plots.redrag, Plots.reselect);
  Queue.add(gd, relayout, [gd, specs.undoit], relayout, [gd, specs.redoit]);
  var plotDone = Lib.syncOrAsync(seq, gd);
  if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);
  return plotDone.then(function () {
    gd.emit('plotly_relayout', specs.eventData);
    return gd;
  });
}

// Optimization mostly for large splom traces where
// Plots.supplyDefaults can take > 100ms
function axRangeSupplyDefaultsByPass(gd, flags, specs) {
  var fullLayout = gd._fullLayout;
  if (!flags.axrange) return false;
  for (var k in flags) {
    if (k !== 'axrange' && flags[k]) return false;
  }
  var axIn, axOut;
  var coerce = function (attr, dflt) {
    return Lib.coerce(axIn, axOut, cartesianLayoutAttributes, attr, dflt);
  };
  var options = {}; // passing empty options for now!

  for (var axId in specs.rangesAltered) {
    var axName = Axes.id2name(axId);
    axIn = gd.layout[axName];
    axOut = fullLayout[axName];
    handleRangeDefaults(axIn, axOut, coerce, options);
    if (axOut._matchGroup) {
      for (var axId2 in axOut._matchGroup) {
        if (axId2 !== axId) {
          var ax2 = fullLayout[Axes.id2name(axId2)];
          ax2.autorange = axOut.autorange;
          ax2.range = axOut.range.slice();
          ax2._input.range = axOut.range.slice();
        }
      }
    }
  }
  return true;
}
function addAxRangeSequence(seq, rangesAltered) {
  // N.B. leave as sequence of subroutines (for now) instead of
  // subroutine of its own so that finalDraw always gets
  // executed after drawData
  var drawAxes = rangesAltered ? function (gd) {
    var axIds = [];
    var skipTitle = true;
    for (var id in rangesAltered) {
      var ax = Axes.getFromId(gd, id);
      axIds.push(id);
      if ((ax.ticklabelposition || '').indexOf('inside') !== -1) {
        if (ax._anchorAxis) {
          axIds.push(ax._anchorAxis._id);
        }
      }
      if (ax._matchGroup) {
        for (var id2 in ax._matchGroup) {
          if (!rangesAltered[id2]) {
            axIds.push(id2);
          }
        }
      }
    }
    return Axes.draw(gd, axIds, {
      skipTitle: skipTitle
    });
  } : function (gd) {
    return Axes.draw(gd, 'redraw');
  };
  seq.push(clearOutline, subroutines.doAutoRangeAndConstraints, drawAxes, subroutines.drawData, subroutines.finalDraw);
}
var AX_RANGE_RE = /^[xyz]axis[0-9]*\.range(\[[0|1]\])?$/;
var AX_AUTORANGE_RE = /^[xyz]axis[0-9]*\.autorange$/;
var AX_DOMAIN_RE = /^[xyz]axis[0-9]*\.domain(\[[0|1]\])?$/;
function _relayout(gd, aobj) {
  var layout = gd.layout;
  var fullLayout = gd._fullLayout;
  var guiEditFlag = fullLayout._guiEditing;
  var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);
  var keys = Object.keys(aobj);
  var axes = Axes.list(gd);
  var eventData = Lib.extendDeepAll({}, aobj);
  var arrayEdits = {};
  var arrayStr, i, j;
  cleanDeprecatedAttributeKeys(aobj);
  keys = Object.keys(aobj);

  // look for 'allaxes', split out into all axes
  // in case of 3D the axis are nested within a scene which is held in _id
  for (i = 0; i < keys.length; i++) {
    if (keys[i].indexOf('allaxes') === 0) {
      for (j = 0; j < axes.length; j++) {
        var scene = axes[j]._id.substr(1);
        var axisAttr = scene.indexOf('scene') !== -1 ? scene + '.' : '';
        var newkey = keys[i].replace('allaxes', axisAttr + axes[j]._name);
        if (!aobj[newkey]) aobj[newkey] = aobj[keys[i]];
      }
      delete aobj[keys[i]];
    }
  }

  // initialize flags
  var flags = editTypes.layoutFlags();

  // copies of the change (and previous values of anything affected)
  // for the undo / redo queue
  var redoit = {};
  var undoit = {};

  // for attrs that interact (like scales & autoscales), save the
  // old vals before making the change
  // val=undefined will not set a value, just record what the value was.
  // attr can be an array to set several at once (all to the same val)
  function doextra(attr, val) {
    if (Array.isArray(attr)) {
      attr.forEach(function (a) {
        doextra(a, val);
      });
      return;
    }

    // if we have another value for this attribute (explicitly or
    // via a parent) do not override with this auto-generated extra
    if (attr in aobj || helpers.hasParent(aobj, attr)) return;
    var p = layoutNP(layout, attr);
    if (!(attr in undoit)) {
      undoit[attr] = undefinedToNull(p.get());
    }
    if (val !== undefined) p.set(val);
  }

  // for constraint enforcement: keep track of all axes (as {id: name})
  // we're editing the (auto)range of, so we can tell the others constrained
  // to scale with them that it's OK for them to shrink
  var rangesAltered = {};
  var ax;
  function recordAlteredAxis(pleafPlus) {
    var axId = Axes.name2id(pleafPlus.split('.')[0]);
    rangesAltered[axId] = 1;
    return axId;
  }

  // alter gd.layout
  for (var ai in aobj) {
    if (helpers.hasParent(aobj, ai)) {
      throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');
    }
    var p = layoutNP(layout, ai);
    var vi = aobj[ai];
    var plen = p.parts.length;
    // p.parts may end with an index integer if the property is an array
    var pend = plen - 1;
    while (pend > 0 && typeof p.parts[pend] !== 'string') pend--;
    // last property in chain (leaf node)
    var pleaf = p.parts[pend];
    // leaf plus immediate parent
    var pleafPlus = p.parts[pend - 1] + '.' + pleaf;
    // trunk nodes (everything except the leaf)
    var ptrunk = p.parts.slice(0, pend).join('.');
    var parentIn = nestedProperty(gd.layout, ptrunk).get();
    var parentFull = nestedProperty(fullLayout, ptrunk).get();
    var vOld = p.get();
    if (vi === undefined) continue;
    redoit[ai] = vi;

    // axis reverse is special - it is its own inverse
    // op and has no flag.
    undoit[ai] = pleaf === 'reverse' ? vi : undefinedToNull(vOld);
    var valObject = PlotSchema.getLayoutValObject(fullLayout, p.parts);
    if (valObject && valObject.impliedEdits && vi !== null) {
      for (var impliedKey in valObject.impliedEdits) {
        doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey]);
      }
    }

    // Setting width or height to null must reset the graph's width / height
    // back to its initial value as computed during the first pass in Plots.plotAutoSize.
    //
    // To do so, we must manually set them back here using the _initialAutoSize cache.
    // can't use impliedEdits for this because behavior depends on vi
    if (['width', 'height'].indexOf(ai) !== -1) {
      if (vi) {
        doextra('autosize', null);
        // currently we don't support autosize one dim only - so
        // explicitly set the other one. Note that doextra will
        // ignore this if the same relayout call also provides oppositeAttr
        var oppositeAttr = ai === 'height' ? 'width' : 'height';
        doextra(oppositeAttr, fullLayout[oppositeAttr]);
      } else {
        fullLayout[ai] = gd._initialAutoSize[ai];
      }
    } else if (ai === 'autosize') {
      // depends on vi here too, so again can't use impliedEdits
      doextra('width', vi ? null : fullLayout.width);
      doextra('height', vi ? null : fullLayout.height);
    } else if (pleafPlus.match(AX_RANGE_RE)) {
      // check autorange vs range

      recordAlteredAxis(pleafPlus);
      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);
    } else if (pleafPlus.match(AX_AUTORANGE_RE)) {
      recordAlteredAxis(pleafPlus);
      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);
      var axFull = nestedProperty(fullLayout, ptrunk).get();
      if (axFull._inputDomain) {
        // if we're autoranging and this axis has a constrained domain,
        // reset it so we don't get locked into a shrunken size
        axFull._input.domain = axFull._inputDomain.slice();
      }
    } else if (pleafPlus.match(AX_DOMAIN_RE)) {
      nestedProperty(fullLayout, ptrunk + '._inputDomain').set(null);
    }

    // toggling axis type between log and linear: we need to convert
    // positions for components that are still using linearized values,
    // not data values like newer components.
    // previously we did this for log <-> not-log, but now only do it
    // for log <-> linear
    if (pleaf === 'type') {
      ax = parentIn;
      var toLog = parentFull.type === 'linear' && vi === 'log';
      var fromLog = parentFull.type === 'log' && vi === 'linear';
      if (toLog || fromLog) {
        if (!ax || !ax.range) {
          // 2D never gets here, but 3D does
          // I don't think this is needed, but left here in case there
          // are edge cases I'm not thinking of.
          doextra(ptrunk + '.autorange', true);
        } else if (!parentFull.autorange) {
          // toggling log without autorange: need to also recalculate ranges
          // because log axes use linearized values for range endpoints
          var r0 = ax.range[0];
          var r1 = ax.range[1];
          if (toLog) {
            // if both limits are negative, autorange
            if (r0 <= 0 && r1 <= 0) {
              doextra(ptrunk + '.autorange', true);
            }
            // if one is negative, set it 6 orders below the other.
            if (r0 <= 0) r0 = r1 / 1e6;else if (r1 <= 0) r1 = r0 / 1e6;
            // now set the range values as appropriate
            doextra(ptrunk + '.range[0]', Math.log(r0) / Math.LN10);
            doextra(ptrunk + '.range[1]', Math.log(r1) / Math.LN10);
          } else {
            doextra(ptrunk + '.range[0]', Math.pow(10, r0));
            doextra(ptrunk + '.range[1]', Math.pow(10, r1));
          }
        } else if (toLog) {
          // just make sure the range is positive and in the right
          // order, it'll get recalculated later
          ax.range = ax.range[1] > ax.range[0] ? [1, 2] : [2, 1];
        }

        // clear polar view initial stash for radial range so that
        // value get recomputed in correct units
        if (Array.isArray(fullLayout._subplots.polar) && fullLayout._subplots.polar.length && fullLayout[p.parts[0]] && p.parts[1] === 'radialaxis') {
          delete fullLayout[p.parts[0]]._subplot.viewInitial['radialaxis.range'];
        }

        // Annotations and images also need to convert to/from linearized coords
        // Shapes do not need this :)
        Registry.getComponentMethod('annotations', 'convertCoords')(gd, parentFull, vi, doextra);
        Registry.getComponentMethod('images', 'convertCoords')(gd, parentFull, vi, doextra);
      } else {
        // any other type changes: the range from the previous type
        // will not make sense, so autorange it.
        doextra(ptrunk + '.autorange', true);
        doextra(ptrunk + '.range', null);
      }
      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);
    } else if (pleaf.match(AX_NAME_PATTERN)) {
      var fullProp = nestedProperty(fullLayout, ai).get();
      var newType = (vi || {}).type;

      // This can potentially cause strange behavior if the autotype is not
      // numeric (linear, because we don't auto-log) but the previous type
      // was log. That's a very strange edge case though
      if (!newType || newType === '-') newType = 'linear';
      Registry.getComponentMethod('annotations', 'convertCoords')(gd, fullProp, newType, doextra);
      Registry.getComponentMethod('images', 'convertCoords')(gd, fullProp, newType, doextra);
    }

    // alter gd.layout

    // collect array component edits for execution all together
    // so we can ensure consistent behavior adding/removing items
    // and order-independence for add/remove/edit all together in
    // one relayout call
    var containerArrayMatch = manageArrays.containerArrayMatch(ai);
    if (containerArrayMatch) {
      arrayStr = containerArrayMatch.array;
      i = containerArrayMatch.index;
      var propStr = containerArrayMatch.property;
      var updateValObject = valObject || {
        editType: 'calc'
      };
      if (i !== '' && propStr === '') {
        // special handling of undoit if we're adding or removing an element
        // ie 'annotations[2]' which can be {...} (add) or null,
        // does not work when replacing the entire array
        if (manageArrays.isAddVal(vi)) {
          undoit[ai] = null;
        } else if (manageArrays.isRemoveVal(vi)) {
          undoit[ai] = (nestedProperty(layout, arrayStr).get() || [])[i];
        } else {
          Lib.warn('unrecognized full object value', aobj);
        }
      }
      editTypes.update(flags, updateValObject);

      // prepare the edits object we'll send to applyContainerArrayChanges
      if (!arrayEdits[arrayStr]) arrayEdits[arrayStr] = {};
      var objEdits = arrayEdits[arrayStr][i];
      if (!objEdits) objEdits = arrayEdits[arrayStr][i] = {};
      objEdits[propStr] = vi;
      delete aobj[ai];
    } else if (pleaf === 'reverse') {
      // handle axis reversal explicitly, as there's no 'reverse' attribute

      if (parentIn.range) parentIn.range.reverse();else {
        doextra(ptrunk + '.autorange', true);
        parentIn.range = [1, 0];
      }
      if (parentFull.autorange) flags.calc = true;else flags.plot = true;
    } else {
      if (ai === 'dragmode' && (vi === false && vOld !== false || vi !== false && vOld === false)) {
        flags.plot = true;
      } else if (fullLayout._has('scatter-like') && fullLayout._has('regl') && ai === 'dragmode' && (vi === 'lasso' || vi === 'select') && !(vOld === 'lasso' || vOld === 'select')) {
        flags.plot = true;
      } else if (fullLayout._has('gl2d')) {
        flags.plot = true;
      } else if (valObject) editTypes.update(flags, valObject);else flags.calc = true;
      p.set(vi);
    }
  }

  // now we've collected component edits - execute them all together
  for (arrayStr in arrayEdits) {
    var finished = manageArrays.applyContainerArrayChanges(gd, layoutNP(layout, arrayStr), arrayEdits[arrayStr], flags, layoutNP);
    if (!finished) flags.plot = true;
  }

  // figure out if we need to recalculate axis constraints
  for (var axId in rangesAltered) {
    ax = Axes.getFromId(gd, axId);
    var group = ax && ax._constraintGroup;
    if (group) {
      // Always recalc if we're changing constrained ranges.
      // Otherwise it's possible to violate the constraints by
      // specifying arbitrary ranges for all axes in the group.
      // this way some ranges may expand beyond what's specified,
      // as they do at first draw, to satisfy the constraints.
      flags.calc = true;
      for (var groupAxId in group) {
        if (!rangesAltered[groupAxId]) {
          Axes.getFromId(gd, groupAxId)._constraintShrinkable = true;
        }
      }
    }
  }

  // If the autosize changed or height or width was explicitly specified,
  // this triggers a redraw
  // TODO: do we really need special aobj.height/width handling here?
  // couldn't editType do this?
  if (updateAutosize(gd) || aobj.height || aobj.width) flags.plot = true;

  // update shape legends
  var shapes = fullLayout.shapes;
  for (i = 0; i < shapes.length; i++) {
    if (shapes[i].showlegend) {
      flags.calc = true;
      break;
    }
  }
  if (flags.plot || flags.calc) {
    flags.layoutReplot = true;
  }

  // now all attribute mods are done, as are
  // redo and undo so we can save them

  return {
    flags: flags,
    rangesAltered: rangesAltered,
    undoit: undoit,
    redoit: redoit,
    eventData: eventData
  };
}

/*
 * updateAutosize: we made a change, does it change the autosize result?
 * puts the new size into fullLayout
 * returns true if either height or width changed
 */
function updateAutosize(gd) {
  var fullLayout = gd._fullLayout;
  var oldWidth = fullLayout.width;
  var oldHeight = fullLayout.height;

  // calculate autosizing
  if (gd.layout.autosize) Plots.plotAutoSize(gd, gd.layout, fullLayout);
  return fullLayout.width !== oldWidth || fullLayout.height !== oldHeight;
}

/**
 * update: update trace and layout attributes of an existing plot
 *
 * @param {String | HTMLDivElement} gd
 *  the id or DOM element of the graph container div
 * @param {Object} traceUpdate
 *  attribute object `{astr1: val1, astr2: val2 ...}`
 *  corresponding to updates in the plot's traces
 * @param {Object} layoutUpdate
 *  attribute object `{astr1: val1, astr2: val2 ...}`
 *  corresponding to updates in the plot's layout
 * @param {Number[] | Number} [traces]
 *  integer or array of integers for the traces to alter (all if omitted)
 *
 */
function update(gd, traceUpdate, layoutUpdate, _traces) {
  gd = Lib.getGraphDiv(gd);
  helpers.clearPromiseQueue(gd);
  if (!Lib.isPlainObject(traceUpdate)) traceUpdate = {};
  if (!Lib.isPlainObject(layoutUpdate)) layoutUpdate = {};
  if (Object.keys(traceUpdate).length) gd.changed = true;
  if (Object.keys(layoutUpdate).length) gd.changed = true;
  var traces = helpers.coerceTraceIndices(gd, _traces);
  var restyleSpecs = _restyle(gd, Lib.extendFlat({}, traceUpdate), traces);
  var restyleFlags = restyleSpecs.flags;
  var relayoutSpecs = _relayout(gd, Lib.extendFlat({}, layoutUpdate));
  var relayoutFlags = relayoutSpecs.flags;

  // clear calcdata and/or axis types if required
  if (restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined;
  if (restyleFlags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, layoutUpdate);

  // fill in redraw sequence
  var seq = [];
  if (relayoutFlags.layoutReplot) {
    // N.B. works fine when both
    // relayoutFlags.layoutReplot and restyleFlags.fullReplot are true
    seq.push(subroutines.layoutReplot);
  } else if (restyleFlags.fullReplot) {
    seq.push(exports._doPlot);
  } else {
    seq.push(Plots.previousPromises);
    axRangeSupplyDefaultsByPass(gd, relayoutFlags, relayoutSpecs) || Plots.supplyDefaults(gd);
    if (restyleFlags.style) seq.push(subroutines.doTraceStyle);
    if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);
    if (relayoutFlags.legend) seq.push(subroutines.doLegend);
    if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);
    if (relayoutFlags.axrange) addAxRangeSequence(seq, relayoutSpecs.rangesAltered);
    if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);
    if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);
    if (relayoutFlags.camera) seq.push(subroutines.doCamera);
    seq.push(emitAfterPlot);
  }
  seq.push(Plots.rehover, Plots.redrag, Plots.reselect);
  Queue.add(gd, update, [gd, restyleSpecs.undoit, relayoutSpecs.undoit, restyleSpecs.traces], update, [gd, restyleSpecs.redoit, relayoutSpecs.redoit, restyleSpecs.traces]);
  var plotDone = Lib.syncOrAsync(seq, gd);
  if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);
  return plotDone.then(function () {
    gd.emit('plotly_update', {
      data: restyleSpecs.eventData,
      layout: relayoutSpecs.eventData
    });
    return gd;
  });
}

/*
 * internal-use-only restyle/relayout/update variants that record the initial
 * values in (fullLayout|fullTrace)._preGUI so changes can be persisted across
 * Plotly.react data updates, dependent on uirevision attributes
 */
function guiEdit(func) {
  return function wrappedEdit(gd) {
    gd._fullLayout._guiEditing = true;
    var p = func.apply(null, arguments);
    gd._fullLayout._guiEditing = false;
    return p;
  };
}

// For connecting edited layout attributes to uirevision attrs
// If no `attr` we use `match[1] + '.uirevision'`
// Ordered by most common edits first, to minimize our search time
var layoutUIControlPatterns = [{
  pattern: /^hiddenlabels/,
  attr: 'legend.uirevision'
}, {
  pattern: /^((x|y)axis\d*)\.((auto)?range|title\.text)/
},
// showspikes and modes include those nested inside scenes
{
  pattern: /axis\d*\.showspikes$/,
  attr: 'modebar.uirevision'
}, {
  pattern: /(hover|drag)mode$/,
  attr: 'modebar.uirevision'
}, {
  pattern: /^(scene\d*)\.camera/
}, {
  pattern: /^(geo\d*)\.(projection|center|fitbounds)/
}, {
  pattern: /^(ternary\d*\.[abc]axis)\.(min|title\.text)$/
}, {
  pattern: /^(polar\d*\.radialaxis)\.((auto)?range|angle|title\.text)/
}, {
  pattern: /^(polar\d*\.angularaxis)\.rotation/
}, {
  pattern: /^(mapbox\d*)\.(center|zoom|bearing|pitch)/
}, {
  pattern: /^legend\.(x|y)$/,
  attr: 'editrevision'
}, {
  pattern: /^(shapes|annotations)/,
  attr: 'editrevision'
}, {
  pattern: /^title\.text$/,
  attr: 'editrevision'
}];

// same for trace attributes: if `attr` is given it's in layout,
// or with no `attr` we use `trace.uirevision`
var traceUIControlPatterns = [{
  pattern: /^selectedpoints$/,
  attr: 'selectionrevision'
},
// "visible" includes trace.transforms[i].styles[j].value.visible
{
  pattern: /(^|value\.)visible$/,
  attr: 'legend.uirevision'
}, {
  pattern: /^dimensions\[\d+\]\.constraintrange/
}, {
  pattern: /^node\.(x|y|groups)/
},
// for Sankey nodes
{
  pattern: /^level$/
},
// for Sunburst, Treemap and Icicle traces

// below this you must be in editable: true mode
// TODO: I still put name and title with `trace.uirevision`
// reasonable or should these be `editrevision`?
// Also applies to axis titles up in the layout section

// "name" also includes transform.styles
{
  pattern: /(^|value\.)name$/
},
// including nested colorbar attributes (ie marker.colorbar)
{
  pattern: /colorbar\.title\.text$/
}, {
  pattern: /colorbar\.(x|y)$/,
  attr: 'editrevision'
}];
function findUIPattern(key, patternSpecs) {
  for (var i = 0; i < patternSpecs.length; i++) {
    var spec = patternSpecs[i];
    var match = key.match(spec.pattern);
    if (match) {
      var head = match[1] || '';
      return {
        head: head,
        tail: key.substr(head.length + 1),
        attr: spec.attr
      };
    }
  }
}

// We're finding the new uirevision before supplyDefaults, so do the
// inheritance manually. Note that only `undefined` inherits - other
// falsy values are returned.
function getNewRev(revAttr, container) {
  var newRev = nestedProperty(container, revAttr).get();
  if (newRev !== undefined) return newRev;
  var parts = revAttr.split('.');
  parts.pop();
  while (parts.length > 1) {
    parts.pop();
    newRev = nestedProperty(container, parts.join('.') + '.uirevision').get();
    if (newRev !== undefined) return newRev;
  }
  return container.uirevision;
}
function getFullTraceIndexFromUid(uid, fullData) {
  for (var i = 0; i < fullData.length; i++) {
    if (fullData[i]._fullInput.uid === uid) return i;
  }
  return -1;
}
function getTraceIndexFromUid(uid, data, tracei) {
  for (var i = 0; i < data.length; i++) {
    if (data[i].uid === uid) return i;
  }
  // fall back on trace order, but only if user didn't provide a uid for that trace
  return !data[tracei] || data[tracei].uid ? -1 : tracei;
}
function valsMatch(v1, v2) {
  var v1IsObj = Lib.isPlainObject(v1);
  var v1IsArray = Array.isArray(v1);
  if (v1IsObj || v1IsArray) {
    return (v1IsObj && Lib.isPlainObject(v2) || v1IsArray && Array.isArray(v2)) && JSON.stringify(v1) === JSON.stringify(v2);
  }
  return v1 === v2;
}
function applyUIRevisions(data, layout, oldFullData, oldFullLayout) {
  var layoutPreGUI = oldFullLayout._preGUI;
  var key, revAttr, oldRev, newRev, match, preGUIVal, newNP, newVal, head, tail;
  var bothInheritAutorange = [];
  var newAutorangeIn = {};
  var newRangeAccepted = {};
  for (key in layoutPreGUI) {
    match = findUIPattern(key, layoutUIControlPatterns);
    if (match) {
      head = match.head;
      tail = match.tail;
      revAttr = match.attr || head + '.uirevision';
      oldRev = nestedProperty(oldFullLayout, revAttr).get();
      newRev = oldRev && getNewRev(revAttr, layout);
      if (newRev && newRev === oldRev) {
        preGUIVal = layoutPreGUI[key];
        if (preGUIVal === null) preGUIVal = undefined;
        newNP = nestedProperty(layout, key);
        newVal = newNP.get();
        if (valsMatch(newVal, preGUIVal)) {
          if (newVal === undefined && tail === 'autorange') {
            bothInheritAutorange.push(head);
          }
          newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));
          continue;
        } else if (tail === 'autorange' || tail.substr(0, 6) === 'range[') {
          // Special case for (auto)range since we push it back into the layout
          // so all null should be treated equivalently to autorange: true with any range
          var pre0 = layoutPreGUI[head + '.range[0]'];
          var pre1 = layoutPreGUI[head + '.range[1]'];
          var preAuto = layoutPreGUI[head + '.autorange'];
          if (preAuto || preAuto === null && pre0 === null && pre1 === null) {
            // Only read the input layout once and stash the result,
            // so we get it before we start modifying it
            if (!(head in newAutorangeIn)) {
              var newContainer = nestedProperty(layout, head).get();
              newAutorangeIn[head] = newContainer && (newContainer.autorange || newContainer.autorange !== false && (!newContainer.range || newContainer.range.length !== 2));
            }
            if (newAutorangeIn[head]) {
              newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));
              continue;
            }
          }
        }
      }
    } else {
      Lib.warn('unrecognized GUI edit: ' + key);
    }
    // if we got this far, the new value was accepted as the new starting
    // point (either because it changed or revision changed)
    // so remove it from _preGUI for next time.
    delete layoutPreGUI[key];
    if (match && match.tail.substr(0, 6) === 'range[') {
      newRangeAccepted[match.head] = 1;
    }
  }

  // More special logic for `autorange`, since it interacts with `range`:
  // If the new figure's matching `range` was kept, and `autorange`
  // wasn't supplied explicitly in either the original or the new figure,
  // we shouldn't alter that - but we may just have done that, so fix it.
  for (var i = 0; i < bothInheritAutorange.length; i++) {
    var axAttr = bothInheritAutorange[i];
    if (newRangeAccepted[axAttr]) {
      var newAx = nestedProperty(layout, axAttr).get();
      if (newAx) delete newAx.autorange;
    }
  }

  // Now traces - try to match them up by uid (in case we added/deleted in
  // the middle), then fall back on index.
  var allTracePreGUI = oldFullLayout._tracePreGUI;
  for (var uid in allTracePreGUI) {
    var tracePreGUI = allTracePreGUI[uid];
    var newTrace = null;
    var fullInput;
    for (key in tracePreGUI) {
      // wait until we know we have preGUI values to look for traces
      // but if we don't find both, stop looking at this uid
      if (!newTrace) {
        var fulli = getFullTraceIndexFromUid(uid, oldFullData);
        if (fulli < 0) {
          // Somehow we didn't even have this trace in oldFullData...
          // I guess this could happen with `deleteTraces` or something
          delete allTracePreGUI[uid];
          break;
        }
        var fullTrace = oldFullData[fulli];
        fullInput = fullTrace._fullInput;
        var newTracei = getTraceIndexFromUid(uid, data, fullInput.index);
        if (newTracei < 0) {
          // No match in new data
          delete allTracePreGUI[uid];
          break;
        }
        newTrace = data[newTracei];
      }
      match = findUIPattern(key, traceUIControlPatterns);
      if (match) {
        if (match.attr) {
          oldRev = nestedProperty(oldFullLayout, match.attr).get();
          newRev = oldRev && getNewRev(match.attr, layout);
        } else {
          oldRev = fullInput.uirevision;
          // inheritance for trace.uirevision is simple, just layout.uirevision
          newRev = newTrace.uirevision;
          if (newRev === undefined) newRev = layout.uirevision;
        }
        if (newRev && newRev === oldRev) {
          preGUIVal = tracePreGUI[key];
          if (preGUIVal === null) preGUIVal = undefined;
          newNP = nestedProperty(newTrace, key);
          newVal = newNP.get();
          if (valsMatch(newVal, preGUIVal)) {
            newNP.set(undefinedToNull(nestedProperty(fullInput, key).get()));
            continue;
          }
        }
      } else {
        Lib.warn('unrecognized GUI edit: ' + key + ' in trace uid ' + uid);
      }
      delete tracePreGUI[key];
    }
  }
}

/**
 * Plotly.react:
 * A plot/update method that takes the full plot state (same API as plot/newPlot)
 * and diffs to determine the minimal update pathway
 *
 * @param {string id or DOM element} gd
 *      the id or DOM element of the graph container div
 * @param {array of objects} data
 *      array of traces, containing the data and display information for each trace
 * @param {object} layout
 *      object describing the overall display of the plot,
 *      all the stuff that doesn't pertain to any individual trace
 * @param {object} config
 *      configuration options (see ./plot_config.js for more info)
 *
 * OR
 *
 * @param {string id or DOM element} gd
 *      the id or DOM element of the graph container div
 * @param {object} figure
 *      object containing `data`, `layout`, `config`, and `frames` members
 *
 */
function react(gd, data, layout, config) {
  var frames, plotDone;
  function addFrames() {
    return exports.addFrames(gd, frames);
  }
  gd = Lib.getGraphDiv(gd);
  helpers.clearPromiseQueue(gd);
  var oldFullData = gd._fullData;
  var oldFullLayout = gd._fullLayout;

  // you can use this as the initial draw as well as to update
  if (!Lib.isPlotDiv(gd) || !oldFullData || !oldFullLayout) {
    plotDone = exports.newPlot(gd, data, layout, config);
  } else {
    if (Lib.isPlainObject(data)) {
      var obj = data;
      data = obj.data;
      layout = obj.layout;
      config = obj.config;
      frames = obj.frames;
    }
    var configChanged = false;
    // assume that if there's a config at all, we're reacting to it too,
    // and completely replace the previous config
    if (config) {
      var oldConfig = Lib.extendDeep({}, gd._context);
      gd._context = undefined;
      setPlotContext(gd, config);
      configChanged = diffConfig(oldConfig, gd._context);
    }
    gd.data = data || [];
    helpers.cleanData(gd.data);
    gd.layout = layout || {};
    helpers.cleanLayout(gd.layout);
    applyUIRevisions(gd.data, gd.layout, oldFullData, oldFullLayout);

    // "true" skips updating calcdata and remapping arrays from calcTransforms,
    // which supplyDefaults usually does at the end, but we may need to NOT do
    // if the diff (which we haven't determined yet) says we'll recalc
    Plots.supplyDefaults(gd, {
      skipUpdateCalc: true
    });
    var newFullData = gd._fullData;
    var newFullLayout = gd._fullLayout;
    var immutable = newFullLayout.datarevision === undefined;
    var transition = newFullLayout.transition;
    var relayoutFlags = diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition);
    var newDataRevision = relayoutFlags.newDataRevision;
    var restyleFlags = diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision);

    // TODO: how to translate this part of relayout to Plotly.react?
    // // Setting width or height to null must reset the graph's width / height
    // // back to its initial value as computed during the first pass in Plots.plotAutoSize.
    // //
    // // To do so, we must manually set them back here using the _initialAutoSize cache.
    // if(['width', 'height'].indexOf(ai) !== -1 && vi === null) {
    //     fullLayout[ai] = gd._initialAutoSize[ai];
    // }

    if (updateAutosize(gd)) relayoutFlags.layoutReplot = true;

    // clear calcdata and empty categories if required
    if (restyleFlags.calc || relayoutFlags.calc) {
      gd.calcdata = undefined;
      var allNames = Object.getOwnPropertyNames(newFullLayout);
      for (var q = 0; q < allNames.length; q++) {
        var name = allNames[q];
        var start = name.substring(0, 5);
        if (start === 'xaxis' || start === 'yaxis') {
          var emptyCategories = newFullLayout[name]._emptyCategories;
          if (emptyCategories) emptyCategories();
        }
      }
      // otherwise do the calcdata updates and calcTransform array remaps that we skipped earlier
    } else {
      Plots.supplyDefaultsUpdateCalc(gd.calcdata, newFullData);
    }

    // Note: what restyle/relayout use impliedEdits and clearAxisTypes for
    // must be handled by the user when using Plotly.react.

    // fill in redraw sequence
    var seq = [];
    if (frames) {
      gd._transitionData = {};
      Plots.createTransitionData(gd);
      seq.push(addFrames);
    }

    // Transition pathway,
    // only used when 'transition' is set by user and
    // when at least one animatable attribute has changed,
    // N.B. config changed aren't animatable
    if (newFullLayout.transition && !configChanged && (restyleFlags.anim || relayoutFlags.anim)) {
      if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);
      Plots.doCalcdata(gd);
      subroutines.doAutoRangeAndConstraints(gd);
      seq.push(function () {
        return Plots.transitionFromReact(gd, restyleFlags, relayoutFlags, oldFullLayout);
      });
    } else if (restyleFlags.fullReplot || relayoutFlags.layoutReplot || configChanged) {
      gd._fullLayout._skipDefaults = true;
      seq.push(exports._doPlot);
    } else {
      for (var componentType in relayoutFlags.arrays) {
        var indices = relayoutFlags.arrays[componentType];
        if (indices.length) {
          var drawOne = Registry.getComponentMethod(componentType, 'drawOne');
          if (drawOne !== Lib.noop) {
            for (var i = 0; i < indices.length; i++) {
              drawOne(gd, indices[i]);
            }
          } else {
            var draw = Registry.getComponentMethod(componentType, 'draw');
            if (draw === Lib.noop) {
              throw new Error('cannot draw components: ' + componentType);
            }
            draw(gd);
          }
        }
      }
      seq.push(Plots.previousPromises);
      if (restyleFlags.style) seq.push(subroutines.doTraceStyle);
      if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);
      if (relayoutFlags.legend) seq.push(subroutines.doLegend);
      if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);
      if (relayoutFlags.axrange) addAxRangeSequence(seq);
      if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);
      if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);
      if (relayoutFlags.camera) seq.push(subroutines.doCamera);
      seq.push(emitAfterPlot);
    }
    seq.push(Plots.rehover, Plots.redrag, Plots.reselect);
    plotDone = Lib.syncOrAsync(seq, gd);
    if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);
  }
  return plotDone.then(function () {
    gd.emit('plotly_react', {
      data: data,
      layout: layout
    });
    return gd;
  });
}
function diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision) {
  var sameTraceLength = oldFullData.length === newFullData.length;
  if (!transition && !sameTraceLength) {
    return {
      fullReplot: true,
      calc: true
    };
  }
  var flags = editTypes.traceFlags();
  flags.arrays = {};
  flags.nChanges = 0;
  flags.nChangesAnim = 0;
  var i, trace;
  function getTraceValObject(parts) {
    var out = PlotSchema.getTraceValObject(trace, parts);
    if (!trace._module.animatable && out.anim) {
      out.anim = false;
    }
    return out;
  }
  var diffOpts = {
    getValObject: getTraceValObject,
    flags: flags,
    immutable: immutable,
    transition: transition,
    newDataRevision: newDataRevision,
    gd: gd
  };
  var seenUIDs = {};
  for (i = 0; i < oldFullData.length; i++) {
    if (newFullData[i]) {
      trace = newFullData[i]._fullInput;
      if (Plots.hasMakesDataTransform(trace)) trace = newFullData[i];
      if (seenUIDs[trace.uid]) continue;
      seenUIDs[trace.uid] = 1;
      getDiffFlags(oldFullData[i]._fullInput, trace, [], diffOpts);
    }
  }
  if (flags.calc || flags.plot) {
    flags.fullReplot = true;
  }
  if (transition && flags.nChanges && flags.nChangesAnim) {
    flags.anim = flags.nChanges === flags.nChangesAnim && sameTraceLength ? 'all' : 'some';
  }
  return flags;
}
function diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition) {
  var flags = editTypes.layoutFlags();
  flags.arrays = {};
  flags.rangesAltered = {};
  flags.nChanges = 0;
  flags.nChangesAnim = 0;
  function getLayoutValObject(parts) {
    return PlotSchema.getLayoutValObject(newFullLayout, parts);
  }
  var diffOpts = {
    getValObject: getLayoutValObject,
    flags: flags,
    immutable: immutable,
    transition: transition,
    gd: gd
  };
  getDiffFlags(oldFullLayout, newFullLayout, [], diffOpts);
  if (flags.plot || flags.calc) {
    flags.layoutReplot = true;
  }
  if (transition && flags.nChanges && flags.nChangesAnim) {
    flags.anim = flags.nChanges === flags.nChangesAnim ? 'all' : 'some';
  }
  return flags;
}
function getDiffFlags(oldContainer, newContainer, outerparts, opts) {
  var valObject, key, astr;
  var getValObject = opts.getValObject;
  var flags = opts.flags;
  var immutable = opts.immutable;
  var inArray = opts.inArray;
  var arrayIndex = opts.arrayIndex;
  function changed() {
    var editType = valObject.editType;
    if (inArray && editType.indexOf('arraydraw') !== -1) {
      Lib.pushUnique(flags.arrays[inArray], arrayIndex);
      return;
    }
    editTypes.update(flags, valObject);
    if (editType !== 'none') {
      flags.nChanges++;
    }

    // track animatable changes
    if (opts.transition && valObject.anim) {
      flags.nChangesAnim++;
    }

    // track cartesian axes with altered ranges
    if (AX_RANGE_RE.test(astr) || AX_AUTORANGE_RE.test(astr)) {
      flags.rangesAltered[outerparts[0]] = 1;
    }

    // clear _inputDomain on cartesian axes with altered domains
    if (AX_DOMAIN_RE.test(astr)) {
      nestedProperty(newContainer, '_inputDomain').set(null);
    }

    // track datarevision changes
    if (key === 'datarevision') {
      flags.newDataRevision = 1;
    }
  }
  function valObjectCanBeDataArray(valObject) {
    return valObject.valType === 'data_array' || valObject.arrayOk;
  }
  for (key in oldContainer) {
    // short-circuit based on previous calls or previous keys that already maximized the pathway
    if (flags.calc && !opts.transition) return;
    var oldVal = oldContainer[key];
    var newVal = newContainer[key];
    var parts = outerparts.concat(key);
    astr = parts.join('.');
    if (key.charAt(0) === '_' || typeof oldVal === 'function' || oldVal === newVal) continue;

    // FIXME: ax.tick0 and dtick get filled in during plotting (except for geo subplots),
    // and unlike other auto values they don't make it back into the input,
    // so newContainer won't have them.
    if ((key === 'tick0' || key === 'dtick') && outerparts[0] !== 'geo') {
      var tickMode = newContainer.tickmode;
      if (tickMode === 'auto' || tickMode === 'array' || !tickMode) continue;
    }
    // FIXME: Similarly for axis ranges for 3D
    // contourcarpet doesn't HAVE zmin/zmax, they're just auto-added. It needs them.
    if (key === 'range' && newContainer.autorange) continue;
    if ((key === 'zmin' || key === 'zmax') && newContainer.type === 'contourcarpet') continue;
    valObject = getValObject(parts);

    // in case type changed, we may not even *have* a valObject.
    if (!valObject) continue;
    if (valObject._compareAsJSON && JSON.stringify(oldVal) === JSON.stringify(newVal)) continue;
    var valType = valObject.valType;
    var i;
    var canBeDataArray = valObjectCanBeDataArray(valObject);
    var wasArray = Array.isArray(oldVal);
    var nowArray = Array.isArray(newVal);

    // hack for traces that modify the data in supplyDefaults, like
    // converting 1D to 2D arrays, which will always create new objects
    if (wasArray && nowArray) {
      var inputKey = '_input_' + key;
      var oldValIn = oldContainer[inputKey];
      var newValIn = newContainer[inputKey];
      if (Array.isArray(oldValIn) && oldValIn === newValIn) continue;
    }
    if (newVal === undefined) {
      if (canBeDataArray && wasArray) flags.calc = true;else changed();
    } else if (valObject._isLinkedToArray) {
      var arrayEditIndices = [];
      var extraIndices = false;
      if (!inArray) flags.arrays[key] = arrayEditIndices;
      var minLen = Math.min(oldVal.length, newVal.length);
      var maxLen = Math.max(oldVal.length, newVal.length);
      if (minLen !== maxLen) {
        if (valObject.editType === 'arraydraw') {
          extraIndices = true;
        } else {
          changed();
          continue;
        }
      }
      for (i = 0; i < minLen; i++) {
        getDiffFlags(oldVal[i], newVal[i], parts.concat(i),
        // add array indices, but not if we're already in an array
        Lib.extendFlat({
          inArray: key,
          arrayIndex: i
        }, opts));
      }

      // put this at the end so that we know our collected array indices are sorted
      // but the check for length changes happens up front so we can short-circuit
      // diffing if appropriate
      if (extraIndices) {
        for (i = minLen; i < maxLen; i++) {
          arrayEditIndices.push(i);
        }
      }
    } else if (!valType && Lib.isPlainObject(oldVal)) {
      getDiffFlags(oldVal, newVal, parts, opts);
    } else if (canBeDataArray) {
      if (wasArray && nowArray) {
        // don't try to diff two data arrays. If immutable we know the data changed,
        // if not, assume it didn't and let `layout.datarevision` tell us if it did
        if (immutable) {
          flags.calc = true;
        }

        // look for animatable attributes when the data changed
        if (immutable || opts.newDataRevision) {
          changed();
        }
      } else if (wasArray !== nowArray) {
        flags.calc = true;
      } else changed();
    } else if (wasArray && nowArray) {
      // info array, colorscale, 'any' - these are short, just stringify.
      // I don't *think* that covers up any real differences post-validation, does it?
      // otherwise we need to dive in 1 (info_array) or 2 (colorscale) levels and compare
      // all elements.
      if (oldVal.length !== newVal.length || String(oldVal) !== String(newVal)) {
        changed();
      }
    } else {
      changed();
    }
  }
  for (key in newContainer) {
    if (!(key in oldContainer || key.charAt(0) === '_' || typeof newContainer[key] === 'function')) {
      valObject = getValObject(outerparts.concat(key));
      if (valObjectCanBeDataArray(valObject) && Array.isArray(newContainer[key])) {
        flags.calc = true;
        return;
      } else changed();
    }
  }
}

/*
 * simple diff for config - for now, just treat all changes as equivalent
 */
function diffConfig(oldConfig, newConfig) {
  var key;
  for (key in oldConfig) {
    if (key.charAt(0) === '_') continue;
    var oldVal = oldConfig[key];
    var newVal = newConfig[key];
    if (oldVal !== newVal) {
      if (Lib.isPlainObject(oldVal) && Lib.isPlainObject(newVal)) {
        if (diffConfig(oldVal, newVal)) {
          return true;
        }
      } else if (Array.isArray(oldVal) && Array.isArray(newVal)) {
        if (oldVal.length !== newVal.length) {
          return true;
        }
        for (var i = 0; i < oldVal.length; i++) {
          if (oldVal[i] !== newVal[i]) {
            if (Lib.isPlainObject(oldVal[i]) && Lib.isPlainObject(newVal[i])) {
              if (diffConfig(oldVal[i], newVal[i])) {
                return true;
              }
            } else {
              return true;
            }
          }
        }
      } else {
        return true;
      }
    }
  }
}

/**
 * Animate to a frame, sequence of frame, frame group, or frame definition
 *
 * @param {string id or DOM element} gd
 *      the id or DOM element of the graph container div
 *
 * @param {string or object or array of strings or array of objects} frameOrGroupNameOrFrameList
 *      a single frame, array of frames, or group to which to animate. The intent is
 *      inferred by the type of the input. Valid inputs are:
 *
 *      - string, e.g. 'groupname': animate all frames of a given `group` in the order
 *            in which they are defined via `Plotly.addFrames`.
 *
 *      - array of strings, e.g. ['frame1', frame2']: a list of frames by name to which
 *            to animate in sequence
 *
 *      - object: {data: ...}: a frame definition to which to animate. The frame is not
 *            and does not need to be added via `Plotly.addFrames`. It may contain any of
 *            the properties of a frame, including `data`, `layout`, and `traces`. The
 *            frame is used as provided and does not use the `baseframe` property.
 *
 *      - array of objects, e.g. [{data: ...}, {data: ...}]: a list of frame objects,
 *            each following the same rules as a single `object`.
 *
 * @param {object} animationOpts
 *      configuration for the animation
 */
function animate(gd, frameOrGroupNameOrFrameList, animationOpts) {
  gd = Lib.getGraphDiv(gd);
  if (!Lib.isPlotDiv(gd)) {
    throw new Error('This element is not a Plotly plot: ' + gd + '. It\'s likely that you\'ve failed ' + 'to create a plot before animating it. For more details, see ' + 'https://plotly.com/javascript/animations/');
  }
  var trans = gd._transitionData;

  // This is the queue of frames that will be animated as soon as possible. They
  // are popped immediately upon the *start* of a transition:
  if (!trans._frameQueue) {
    trans._frameQueue = [];
  }
  animationOpts = Plots.supplyAnimationDefaults(animationOpts);
  var transitionOpts = animationOpts.transition;
  var frameOpts = animationOpts.frame;

  // Since frames are popped immediately, an empty queue only means all frames have
  // *started* to transition, not that the animation is complete. To solve that,
  // track a separate counter that increments at the same time as frames are added
  // to the queue, but decrements only when the transition is complete.
  if (trans._frameWaitingCnt === undefined) {
    trans._frameWaitingCnt = 0;
  }
  function getTransitionOpts(i) {
    if (Array.isArray(transitionOpts)) {
      if (i >= transitionOpts.length) {
        return transitionOpts[0];
      } else {
        return transitionOpts[i];
      }
    } else {
      return transitionOpts;
    }
  }
  function getFrameOpts(i) {
    if (Array.isArray(frameOpts)) {
      if (i >= frameOpts.length) {
        return frameOpts[0];
      } else {
        return frameOpts[i];
      }
    } else {
      return frameOpts;
    }
  }

  // Execute a callback after the wrapper function has been called n times.
  // This is used to defer the resolution until a transition has resolved *and*
  // the frame has completed. If it's not done this way, then we get a race
  // condition in which the animation might resolve before a transition is complete
  // or vice versa.
  function callbackOnNthTime(cb, n) {
    var cnt = 0;
    return function () {
      if (cb && ++cnt === n) {
        return cb();
      }
    };
  }
  return new Promise(function (resolve, reject) {
    function discardExistingFrames() {
      if (trans._frameQueue.length === 0) {
        return;
      }
      while (trans._frameQueue.length) {
        var next = trans._frameQueue.pop();
        if (next.onInterrupt) {
          next.onInterrupt();
        }
      }
      gd.emit('plotly_animationinterrupted', []);
    }
    function queueFrames(frameList) {
      if (frameList.length === 0) return;
      for (var i = 0; i < frameList.length; i++) {
        var computedFrame;
        if (frameList[i].type === 'byname') {
          // If it's a named frame, compute it:
          computedFrame = Plots.computeFrame(gd, frameList[i].name);
        } else {
          // Otherwise we must have been given a simple object, so treat
          // the input itself as the computed frame.
          computedFrame = frameList[i].data;
        }
        var frameOpts = getFrameOpts(i);
        var transitionOpts = getTransitionOpts(i);

        // It doesn't make much sense for the transition duration to be greater than
        // the frame duration, so limit it:
        transitionOpts.duration = Math.min(transitionOpts.duration, frameOpts.duration);
        var nextFrame = {
          frame: computedFrame,
          name: frameList[i].name,
          frameOpts: frameOpts,
          transitionOpts: transitionOpts
        };
        if (i === frameList.length - 1) {
          // The last frame in this .animate call stores the promise resolve
          // and reject callbacks. This is how we ensure that the animation
          // loop (which may exist as a result of a *different* .animate call)
          // still resolves or rejecdts this .animate call's promise. once it's
          // complete.
          nextFrame.onComplete = callbackOnNthTime(resolve, 2);
          nextFrame.onInterrupt = reject;
        }
        trans._frameQueue.push(nextFrame);
      }

      // Set it as never having transitioned to a frame. This will cause the animation
      // loop to immediately transition to the next frame (which, for immediate mode,
      // is the first frame in the list since all others would have been discarded
      // below)
      if (animationOpts.mode === 'immediate') {
        trans._lastFrameAt = -Infinity;
      }

      // Only it's not already running, start a RAF loop. This could be avoided in the
      // case that there's only one frame, but it significantly complicated the logic
      // and only sped things up by about 5% or so for a lorenz attractor simulation.
      // It would be a fine thing to implement, but the benefit of that optimization
      // doesn't seem worth the extra complexity.
      if (!trans._animationRaf) {
        beginAnimationLoop();
      }
    }
    function stopAnimationLoop() {
      gd.emit('plotly_animated');

      // Be sure to unset also since it's how we know whether a loop is already running:
      window.cancelAnimationFrame(trans._animationRaf);
      trans._animationRaf = null;
    }
    function nextFrame() {
      if (trans._currentFrame && trans._currentFrame.onComplete) {
        // Execute the callback and unset it to ensure it doesn't
        // accidentally get called twice
        trans._currentFrame.onComplete();
      }
      var newFrame = trans._currentFrame = trans._frameQueue.shift();
      if (newFrame) {
        // Since it's sometimes necessary to do deep digging into frame data,
        // we'll consider it not 100% impossible for nulls or numbers to sneak through,
        // so check when casting the name, just to be absolutely certain:
        var stringName = newFrame.name ? newFrame.name.toString() : null;
        gd._fullLayout._currentFrame = stringName;
        trans._lastFrameAt = Date.now();
        trans._timeToNext = newFrame.frameOpts.duration;

        // This is simply called and it's left to .transition to decide how to manage
        // interrupting current transitions. That means we don't need to worry about
        // how it resolves or what happens after this:
        Plots.transition(gd, newFrame.frame.data, newFrame.frame.layout, helpers.coerceTraceIndices(gd, newFrame.frame.traces), newFrame.frameOpts, newFrame.transitionOpts).then(function () {
          if (newFrame.onComplete) {
            newFrame.onComplete();
          }
        });
        gd.emit('plotly_animatingframe', {
          name: stringName,
          frame: newFrame.frame,
          animation: {
            frame: newFrame.frameOpts,
            transition: newFrame.transitionOpts
          }
        });
      } else {
        // If there are no more frames, then stop the RAF loop:
        stopAnimationLoop();
      }
    }
    function beginAnimationLoop() {
      gd.emit('plotly_animating');

      // If no timer is running, then set last frame = long ago so that the next
      // frame is immediately transitioned:
      trans._lastFrameAt = -Infinity;
      trans._timeToNext = 0;
      trans._runningTransitions = 0;
      trans._currentFrame = null;
      var doFrame = function () {
        // This *must* be requested before nextFrame since nextFrame may decide
        // to cancel it if there's nothing more to animated:
        trans._animationRaf = window.requestAnimationFrame(doFrame);

        // Check if we're ready for a new frame:
        if (Date.now() - trans._lastFrameAt > trans._timeToNext) {
          nextFrame();
        }
      };
      doFrame();
    }

    // This is an animate-local counter that helps match up option input list
    // items with the particular frame.
    var configCounter = 0;
    function setTransitionConfig(frame) {
      if (Array.isArray(transitionOpts)) {
        if (configCounter >= transitionOpts.length) {
          frame.transitionOpts = transitionOpts[configCounter];
        } else {
          frame.transitionOpts = transitionOpts[0];
        }
      } else {
        frame.transitionOpts = transitionOpts;
      }
      configCounter++;
      return frame;
    }

    // Disambiguate what's sort of frames have been received
    var i, frame;
    var frameList = [];
    var allFrames = frameOrGroupNameOrFrameList === undefined || frameOrGroupNameOrFrameList === null;
    var isFrameArray = Array.isArray(frameOrGroupNameOrFrameList);
    var isSingleFrame = !allFrames && !isFrameArray && Lib.isPlainObject(frameOrGroupNameOrFrameList);
    if (isSingleFrame) {
      // In this case, a simple object has been passed to animate.
      frameList.push({
        type: 'object',
        data: setTransitionConfig(Lib.extendFlat({}, frameOrGroupNameOrFrameList))
      });
    } else if (allFrames || ['string', 'number'].indexOf(typeof frameOrGroupNameOrFrameList) !== -1) {
      // In this case, null or undefined has been passed so that we want to
      // animate *all* currently defined frames
      for (i = 0; i < trans._frames.length; i++) {
        frame = trans._frames[i];
        if (!frame) continue;
        if (allFrames || String(frame.group) === String(frameOrGroupNameOrFrameList)) {
          frameList.push({
            type: 'byname',
            name: String(frame.name),
            data: setTransitionConfig({
              name: frame.name
            })
          });
        }
      }
    } else if (isFrameArray) {
      for (i = 0; i < frameOrGroupNameOrFrameList.length; i++) {
        var frameOrName = frameOrGroupNameOrFrameList[i];
        if (['number', 'string'].indexOf(typeof frameOrName) !== -1) {
          frameOrName = String(frameOrName);
          // In this case, there's an array and this frame is a string name:
          frameList.push({
            type: 'byname',
            name: frameOrName,
            data: setTransitionConfig({
              name: frameOrName
            })
          });
        } else if (Lib.isPlainObject(frameOrName)) {
          frameList.push({
            type: 'object',
            data: setTransitionConfig(Lib.extendFlat({}, frameOrName))
          });
        }
      }
    }

    // Verify that all of these frames actually exist; return and reject if not:
    for (i = 0; i < frameList.length; i++) {
      frame = frameList[i];
      if (frame.type === 'byname' && !trans._frameHash[frame.data.name]) {
        Lib.warn('animate failure: frame not found: "' + frame.data.name + '"');
        reject();
        return;
      }
    }

    // If the mode is either next or immediate, then all currently queued frames must
    // be dumped and the corresponding .animate promises rejected.
    if (['next', 'immediate'].indexOf(animationOpts.mode) !== -1) {
      discardExistingFrames();
    }
    if (animationOpts.direction === 'reverse') {
      frameList.reverse();
    }
    var currentFrame = gd._fullLayout._currentFrame;
    if (currentFrame && animationOpts.fromcurrent) {
      var idx = -1;
      for (i = 0; i < frameList.length; i++) {
        frame = frameList[i];
        if (frame.type === 'byname' && frame.name === currentFrame) {
          idx = i;
          break;
        }
      }
      if (idx > 0 && idx < frameList.length - 1) {
        var filteredFrameList = [];
        for (i = 0; i < frameList.length; i++) {
          frame = frameList[i];
          if (frameList[i].type !== 'byname' || i > idx) {
            filteredFrameList.push(frame);
          }
        }
        frameList = filteredFrameList;
      }
    }
    if (frameList.length > 0) {
      queueFrames(frameList);
    } else {
      // This is the case where there were simply no frames. It's a little strange
      // since there's not much to do:
      gd.emit('plotly_animated');
      resolve();
    }
  });
}

/**
 * Register new frames
 *
 * @param {string id or DOM element} gd
 *      the id or DOM element of the graph container div
 *
 * @param {array of objects} frameList
 *      list of frame definitions, in which each object includes any of:
 *      - name: {string} name of frame to add
 *      - data: {array of objects} trace data
 *      - layout {object} layout definition
 *      - traces {array} trace indices
 *      - baseframe {string} name of frame from which this frame gets defaults
 *
 *  @param {array of integers} indices
 *      an array of integer indices matching the respective frames in `frameList`. If not
 *      provided, an index will be provided in serial order. If already used, the frame
 *      will be overwritten.
 */
function addFrames(gd, frameList, indices) {
  gd = Lib.getGraphDiv(gd);
  if (frameList === null || frameList === undefined) {
    return Promise.resolve();
  }
  if (!Lib.isPlotDiv(gd)) {
    throw new Error('This element is not a Plotly plot: ' + gd + '. It\'s likely that you\'ve failed ' + 'to create a plot before adding frames. For more details, see ' + 'https://plotly.com/javascript/animations/');
  }
  var i, frame, j, idx;
  var _frames = gd._transitionData._frames;
  var _frameHash = gd._transitionData._frameHash;
  if (!Array.isArray(frameList)) {
    throw new Error('addFrames failure: frameList must be an Array of frame definitions' + frameList);
  }

  // Create a sorted list of insertions since we run into lots of problems if these
  // aren't in ascending order of index:
  //
  // Strictly for sorting. Make sure this is guaranteed to never collide with any
  // already-exisisting indices:
  var bigIndex = _frames.length + frameList.length * 2;
  var insertions = [];
  var _frameHashLocal = {};
  for (i = frameList.length - 1; i >= 0; i--) {
    if (!Lib.isPlainObject(frameList[i])) continue;

    // The entire logic for checking for this type of name collision can be removed once we migrate to ES6 and
    // use a Map instead of an Object instance, as Map keys aren't converted to strings.
    var lookupName = frameList[i].name;
    var name = (_frameHash[lookupName] || _frameHashLocal[lookupName] || {}).name;
    var newName = frameList[i].name;
    var collisionPresent = _frameHash[name] || _frameHashLocal[name];
    if (name && newName && typeof newName === 'number' && collisionPresent && numericNameWarningCount < numericNameWarningCountLimit) {
      numericNameWarningCount++;
      Lib.warn('addFrames: overwriting frame "' + (_frameHash[name] || _frameHashLocal[name]).name + '" with a frame whose name of type "number" also equates to "' + name + '". This is valid but may potentially lead to unexpected ' + 'behavior since all plotly.js frame names are stored internally ' + 'as strings.');
      if (numericNameWarningCount === numericNameWarningCountLimit) {
        Lib.warn('addFrames: This API call has yielded too many of these warnings. ' + 'For the rest of this call, further warnings about numeric frame ' + 'names will be suppressed.');
      }
    }
    _frameHashLocal[lookupName] = {
      name: lookupName
    };
    insertions.push({
      frame: Plots.supplyFrameDefaults(frameList[i]),
      index: indices && indices[i] !== undefined && indices[i] !== null ? indices[i] : bigIndex + i
    });
  }

  // Sort this, taking note that undefined insertions end up at the end:
  insertions.sort(function (a, b) {
    if (a.index > b.index) return -1;
    if (a.index < b.index) return 1;
    return 0;
  });
  var ops = [];
  var revops = [];
  var frameCount = _frames.length;
  for (i = insertions.length - 1; i >= 0; i--) {
    frame = insertions[i].frame;
    if (typeof frame.name === 'number') {
      Lib.warn('Warning: addFrames accepts frames with numeric names, but the numbers are' + 'implicitly cast to strings');
    }
    if (!frame.name) {
      // Repeatedly assign a default name, incrementing the counter each time until
      // we get a name that's not in the hashed lookup table:
      while (_frameHash[frame.name = 'frame ' + gd._transitionData._counter++]);
    }
    if (_frameHash[frame.name]) {
      // If frame is present, overwrite its definition:
      for (j = 0; j < _frames.length; j++) {
        if ((_frames[j] || {}).name === frame.name) break;
      }
      ops.push({
        type: 'replace',
        index: j,
        value: frame
      });
      revops.unshift({
        type: 'replace',
        index: j,
        value: _frames[j]
      });
    } else {
      // Otherwise insert it at the end of the list:
      idx = Math.max(0, Math.min(insertions[i].index, frameCount));
      ops.push({
        type: 'insert',
        index: idx,
        value: frame
      });
      revops.unshift({
        type: 'delete',
        index: idx
      });
      frameCount++;
    }
  }
  var undoFunc = Plots.modifyFrames;
  var redoFunc = Plots.modifyFrames;
  var undoArgs = [gd, revops];
  var redoArgs = [gd, ops];
  if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
  return Plots.modifyFrames(gd, ops);
}

/**
 * Delete frame
 *
 * @param {string id or DOM element} gd
 *      the id or DOM element of the graph container div
 *
 * @param {array of integers} frameList
 *      list of integer indices of frames to be deleted
 */
function deleteFrames(gd, frameList) {
  gd = Lib.getGraphDiv(gd);
  if (!Lib.isPlotDiv(gd)) {
    throw new Error('This element is not a Plotly plot: ' + gd);
  }
  var i, idx;
  var _frames = gd._transitionData._frames;
  var ops = [];
  var revops = [];
  if (!frameList) {
    frameList = [];
    for (i = 0; i < _frames.length; i++) {
      frameList.push(i);
    }
  }
  frameList = frameList.slice();
  frameList.sort();
  for (i = frameList.length - 1; i >= 0; i--) {
    idx = frameList[i];
    ops.push({
      type: 'delete',
      index: idx
    });
    revops.unshift({
      type: 'insert',
      index: idx,
      value: _frames[idx]
    });
  }
  var undoFunc = Plots.modifyFrames;
  var redoFunc = Plots.modifyFrames;
  var undoArgs = [gd, revops];
  var redoArgs = [gd, ops];
  if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
  return Plots.modifyFrames(gd, ops);
}

/**
 * Purge a graph container div back to its initial pre-_doPlot state
 *
 * @param {string id or DOM element} gd
 *      the id or DOM element of the graph container div
 */
function purge(gd) {
  gd = Lib.getGraphDiv(gd);
  var fullLayout = gd._fullLayout || {};
  var fullData = gd._fullData || [];

  // remove gl contexts
  Plots.cleanPlot([], {}, fullData, fullLayout);

  // purge properties
  Plots.purge(gd);

  // purge event emitter methods
  Events.purge(gd);

  // remove plot container
  if (fullLayout._container) fullLayout._container.remove();

  // in contrast to _doPlots.purge which does NOT clear _context!
  delete gd._context;
  return gd;
}

// determines if the graph div requires a recalculation of its inverse matrix transforms by comparing old + new bounding boxes.
function calcInverseTransform(gd) {
  var fullLayout = gd._fullLayout;
  var newBBox = gd.getBoundingClientRect();
  if (Lib.equalDomRects(newBBox, fullLayout._lastBBox)) return;
  var m = fullLayout._invTransform = Lib.inverseTransformMatrix(Lib.getFullTransformMatrix(gd));
  fullLayout._invScaleX = Math.sqrt(m[0][0] * m[0][0] + m[0][1] * m[0][1] + m[0][2] * m[0][2]);
  fullLayout._invScaleY = Math.sqrt(m[1][0] * m[1][0] + m[1][1] * m[1][1] + m[1][2] * m[1][2]);
  fullLayout._lastBBox = newBBox;
}

// -------------------------------------------------------
// makePlotFramework: Create the plot container and axes
// -------------------------------------------------------
function makePlotFramework(gd) {
  var gd3 = d3.select(gd);
  var fullLayout = gd._fullLayout;
  fullLayout._calcInverseTransform = calcInverseTransform;
  fullLayout._calcInverseTransform(gd);

  // Plot container
  fullLayout._container = gd3.selectAll('.plot-container').data([0]);
  fullLayout._container.enter().insert('div', ':first-child').classed('plot-container', true).classed('plotly', true);

  // Make the svg container
  fullLayout._paperdiv = fullLayout._container.selectAll('.svg-container').data([0]);
  fullLayout._paperdiv.enter().append('div').classed('user-select-none', true).classed('svg-container', true).style('position', 'relative');

  // Make the graph containers
  // start fresh each time we get here, so we know the order comes out
  // right, rather than enter/exit which can muck up the order
  // TODO: sort out all the ordering so we don't have to
  // explicitly delete anything
  // FIXME: parcoords reuses this object, not the best pattern
  fullLayout._glcontainer = fullLayout._paperdiv.selectAll('.gl-container').data([{}]);
  fullLayout._glcontainer.enter().append('div').classed('gl-container', true);
  fullLayout._paperdiv.selectAll('.main-svg').remove();
  fullLayout._paperdiv.select('.modebar-container').remove();
  fullLayout._paper = fullLayout._paperdiv.insert('svg', ':first-child').classed('main-svg', true);
  fullLayout._toppaper = fullLayout._paperdiv.append('svg').classed('main-svg', true);
  fullLayout._modebardiv = fullLayout._paperdiv.append('div');
  delete fullLayout._modeBar;
  fullLayout._hoverpaper = fullLayout._paperdiv.append('svg').classed('main-svg', true);
  if (!fullLayout._uid) {
    var otherUids = {};
    d3.selectAll('defs').each(function () {
      if (this.id) otherUids[this.id.split('-')[1]] = 1;
    });
    fullLayout._uid = Lib.randstr(otherUids);
  }
  fullLayout._paperdiv.selectAll('.main-svg').attr(xmlnsNamespaces.svgAttrs);
  fullLayout._defs = fullLayout._paper.append('defs').attr('id', 'defs-' + fullLayout._uid);
  fullLayout._clips = fullLayout._defs.append('g').classed('clips', true);
  fullLayout._topdefs = fullLayout._toppaper.append('defs').attr('id', 'topdefs-' + fullLayout._uid);
  fullLayout._topclips = fullLayout._topdefs.append('g').classed('clips', true);
  fullLayout._bgLayer = fullLayout._paper.append('g').classed('bglayer', true);
  fullLayout._draggers = fullLayout._paper.append('g').classed('draglayer', true);

  // lower shape/image layer - note that this is behind
  // all subplots data/grids but above the backgrounds
  // except inset subplots, whose backgrounds are drawn
  // inside their own group so that they appear above
  // the data for the main subplot
  // lower shapes and images which are fully referenced to
  // a subplot still get drawn within the subplot's group
  // so they will work correctly on insets
  var layerBelow = fullLayout._paper.append('g').classed('layer-below', true);
  fullLayout._imageLowerLayer = layerBelow.append('g').classed('imagelayer', true);
  fullLayout._shapeLowerLayer = layerBelow.append('g').classed('shapelayer', true);

  // single cartesian layer for the whole plot
  fullLayout._cartesianlayer = fullLayout._paper.append('g').classed('cartesianlayer', true);

  // single polar layer for the whole plot
  fullLayout._polarlayer = fullLayout._paper.append('g').classed('polarlayer', true);

  // single smith layer for the whole plot
  fullLayout._smithlayer = fullLayout._paper.append('g').classed('smithlayer', true);

  // single ternary layer for the whole plot
  fullLayout._ternarylayer = fullLayout._paper.append('g').classed('ternarylayer', true);

  // single geo layer for the whole plot
  fullLayout._geolayer = fullLayout._paper.append('g').classed('geolayer', true);

  // single funnelarea layer for the whole plot
  fullLayout._funnelarealayer = fullLayout._paper.append('g').classed('funnelarealayer', true);

  // single pie layer for the whole plot
  fullLayout._pielayer = fullLayout._paper.append('g').classed('pielayer', true);

  // single treemap layer for the whole plot
  fullLayout._iciclelayer = fullLayout._paper.append('g').classed('iciclelayer', true);

  // single treemap layer for the whole plot
  fullLayout._treemaplayer = fullLayout._paper.append('g').classed('treemaplayer', true);

  // single sunburst layer for the whole plot
  fullLayout._sunburstlayer = fullLayout._paper.append('g').classed('sunburstlayer', true);

  // single indicator layer for the whole plot
  fullLayout._indicatorlayer = fullLayout._toppaper.append('g').classed('indicatorlayer', true);

  // fill in image server scrape-svg
  fullLayout._glimages = fullLayout._paper.append('g').classed('glimages', true);

  // lastly upper shapes, info (legend, annotations) and hover layers go on top
  // these are in a different svg element normally, but get collapsed into a single
  // svg when exporting (after inserting 3D)
  // upper shapes/images are only those drawn above the whole plot, including subplots
  var layerAbove = fullLayout._toppaper.append('g').classed('layer-above', true);
  fullLayout._imageUpperLayer = layerAbove.append('g').classed('imagelayer', true);
  fullLayout._shapeUpperLayer = layerAbove.append('g').classed('shapelayer', true);
  fullLayout._selectionLayer = fullLayout._toppaper.append('g').classed('selectionlayer', true);
  fullLayout._infolayer = fullLayout._toppaper.append('g').classed('infolayer', true);
  fullLayout._menulayer = fullLayout._toppaper.append('g').classed('menulayer', true);
  fullLayout._zoomlayer = fullLayout._toppaper.append('g').classed('zoomlayer', true);
  fullLayout._hoverlayer = fullLayout._hoverpaper.append('g').classed('hoverlayer', true);

  // Make the modebar container
  fullLayout._modebardiv.classed('modebar-container', true).style('position', 'absolute').style('top', '0px').style('right', '0px');
  gd.emit('plotly_framework');
}
exports.animate = animate;
exports.addFrames = addFrames;
exports.deleteFrames = deleteFrames;
exports.addTraces = addTraces;
exports.deleteTraces = deleteTraces;
exports.extendTraces = extendTraces;
exports.moveTraces = moveTraces;
exports.prependTraces = prependTraces;
exports.newPlot = newPlot;
exports._doPlot = _doPlot;
exports.purge = purge;
exports.react = react;
exports.redraw = redraw;
exports.relayout = relayout;
exports.restyle = restyle;
exports.setPlotConfig = setPlotConfig;
exports.update = update;
exports._guiRelayout = guiEdit(relayout);
exports._guiRestyle = guiEdit(restyle);
exports._guiUpdate = guiEdit(update);
exports._storeDirectGUIEdit = _storeDirectGUIEdit;

/***/ }),

/***/ 2075:
/***/ (function(module) {

"use strict";


/**
 * This will be transferred over to gd and overridden by
 * config args to Plotly.newPlot.
 *
 * The defaults are the appropriate settings for plotly.js,
 * so we get the right experience without any config argument.
 *
 * N.B. the config options are not coerced using Lib.coerce so keys
 * like `valType` and `values` are only set for documentation purposes
 * at the moment.
 */
var configAttributes = {
  staticPlot: {
    valType: 'boolean',
    dflt: false
  },
  typesetMath: {
    valType: 'boolean',
    dflt: true
  },
  plotlyServerURL: {
    valType: 'string',
    dflt: ''
  },
  editable: {
    valType: 'boolean',
    dflt: false
  },
  edits: {
    annotationPosition: {
      valType: 'boolean',
      dflt: false
    },
    annotationTail: {
      valType: 'boolean',
      dflt: false
    },
    annotationText: {
      valType: 'boolean',
      dflt: false
    },
    axisTitleText: {
      valType: 'boolean',
      dflt: false
    },
    colorbarPosition: {
      valType: 'boolean',
      dflt: false
    },
    colorbarTitleText: {
      valType: 'boolean',
      dflt: false
    },
    legendPosition: {
      valType: 'boolean',
      dflt: false
    },
    legendText: {
      valType: 'boolean',
      dflt: false
    },
    shapePosition: {
      valType: 'boolean',
      dflt: false
    },
    titleText: {
      valType: 'boolean',
      dflt: false
    }
  },
  editSelection: {
    valType: 'boolean',
    dflt: true
  },
  autosizable: {
    valType: 'boolean',
    dflt: false
  },
  responsive: {
    valType: 'boolean',
    dflt: false
  },
  fillFrame: {
    valType: 'boolean',
    dflt: false
  },
  frameMargins: {
    valType: 'number',
    dflt: 0,
    min: 0,
    max: 0.5
  },
  scrollZoom: {
    valType: 'flaglist',
    flags: ['cartesian', 'gl3d', 'geo', 'mapbox'],
    extras: [true, false],
    dflt: 'gl3d+geo+mapbox'
  },
  doubleClick: {
    valType: 'enumerated',
    values: [false, 'reset', 'autosize', 'reset+autosize'],
    dflt: 'reset+autosize'
  },
  doubleClickDelay: {
    valType: 'number',
    dflt: 300,
    min: 0
  },
  showAxisDragHandles: {
    valType: 'boolean',
    dflt: true
  },
  showAxisRangeEntryBoxes: {
    valType: 'boolean',
    dflt: true
  },
  showTips: {
    valType: 'boolean',
    dflt: true
  },
  showLink: {
    valType: 'boolean',
    dflt: false
  },
  linkText: {
    valType: 'string',
    dflt: 'Edit chart',
    noBlank: true
  },
  sendData: {
    valType: 'boolean',
    dflt: true
  },
  showSources: {
    valType: 'any',
    dflt: false
  },
  displayModeBar: {
    valType: 'enumerated',
    values: ['hover', true, false],
    dflt: 'hover'
  },
  showSendToCloud: {
    valType: 'boolean',
    dflt: false
  },
  showEditInChartStudio: {
    valType: 'boolean',
    dflt: false
  },
  modeBarButtonsToRemove: {
    valType: 'any',
    dflt: []
  },
  modeBarButtonsToAdd: {
    valType: 'any',
    dflt: []
  },
  modeBarButtons: {
    valType: 'any',
    dflt: false
  },
  toImageButtonOptions: {
    valType: 'any',
    dflt: {}
  },
  displaylogo: {
    valType: 'boolean',
    dflt: true
  },
  watermark: {
    valType: 'boolean',
    dflt: false
  },
  plotGlPixelRatio: {
    valType: 'number',
    dflt: 2,
    min: 1,
    max: 4
  },
  setBackground: {
    valType: 'any',
    dflt: 'transparent'
  },
  topojsonURL: {
    valType: 'string',
    noBlank: true,
    dflt: 'https://cdn.plot.ly/'
  },
  mapboxAccessToken: {
    valType: 'string',
    dflt: null
  },
  logging: {
    valType: 'integer',
    min: 0,
    max: 2,
    dflt: 1
  },
  notifyOnLogging: {
    valType: 'integer',
    min: 0,
    max: 2,
    dflt: 0
  },
  queueLength: {
    valType: 'integer',
    min: 0,
    dflt: 0
  },
  globalTransforms: {
    valType: 'any',
    dflt: []
  },
  locale: {
    valType: 'string',
    dflt: 'en-US'
  },
  locales: {
    valType: 'any',
    dflt: {}
  }
};
var dfltConfig = {};
function crawl(src, target) {
  for (var k in src) {
    var obj = src[k];
    if (obj.valType) {
      target[k] = obj.dflt;
    } else {
      if (!target[k]) {
        target[k] = {};
      }
      crawl(obj, target[k]);
    }
  }
}
crawl(configAttributes, dfltConfig);
module.exports = {
  configAttributes: configAttributes,
  dfltConfig: dfltConfig
};

/***/ }),

/***/ 6281:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var baseAttributes = __webpack_require__(9012);
var baseLayoutAttributes = __webpack_require__(820);
var frameAttributes = __webpack_require__(1391);
var animationAttributes = __webpack_require__(5594);
var configAttributes = (__webpack_require__(2075).configAttributes);
var editTypes = __webpack_require__(962);
var extendDeepAll = Lib.extendDeepAll;
var isPlainObject = Lib.isPlainObject;
var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
var nestedProperty = Lib.nestedProperty;
var valObjectMeta = Lib.valObjectMeta;
var IS_SUBPLOT_OBJ = '_isSubplotObj';
var IS_LINKED_TO_ARRAY = '_isLinkedToArray';
var ARRAY_ATTR_REGEXPS = '_arrayAttrRegexps';
var DEPRECATED = '_deprecated';
var UNDERSCORE_ATTRS = [IS_SUBPLOT_OBJ, IS_LINKED_TO_ARRAY, ARRAY_ATTR_REGEXPS, DEPRECATED];
exports.IS_SUBPLOT_OBJ = IS_SUBPLOT_OBJ;
exports.IS_LINKED_TO_ARRAY = IS_LINKED_TO_ARRAY;
exports.DEPRECATED = DEPRECATED;
exports.UNDERSCORE_ATTRS = UNDERSCORE_ATTRS;

/** Outputs the full plotly.js plot schema
 *
 * @return {object}
 *  - defs
 *  - traces
 *  - layout
 *  - transforms
 *  - frames
 *  - animations
 *  - config
 */
exports.get = function () {
  var traces = {};
  Registry.allTypes.forEach(function (type) {
    traces[type] = getTraceAttributes(type);
  });
  var transforms = {};
  Object.keys(Registry.transformsRegistry).forEach(function (type) {
    transforms[type] = getTransformAttributes(type);
  });
  return {
    defs: {
      valObjects: valObjectMeta,
      metaKeys: UNDERSCORE_ATTRS.concat(['description', 'role', 'editType', 'impliedEdits']),
      editType: {
        traces: editTypes.traces,
        layout: editTypes.layout
      },
      impliedEdits: {}
    },
    traces: traces,
    layout: getLayoutAttributes(),
    transforms: transforms,
    frames: getFramesAttributes(),
    animation: formatAttributes(animationAttributes),
    config: formatAttributes(configAttributes)
  };
};

/**
 * Crawl the attribute tree, recursively calling a callback function
 *
 * @param {object} attrs
 *  The node of the attribute tree (e.g. the root) from which recursion originates
 * @param {Function} callback
 *  A callback function with the signature:
 *          @callback callback
 *          @param {object} attr an attribute
 *          @param {String} attrName name string
 *          @param {object[]} attrs all the attributes
 *          @param {Number} level the recursion level, 0 at the root
 *          @param {String} fullAttrString full attribute name (ie 'marker.line')
 * @param {Number} [specifiedLevel]
 *  The level in the tree, in order to let the callback function detect descend or backtrack,
 *  typically unsupplied (implied 0), just used by the self-recursive call.
 *  The necessity arises because the tree traversal is not controlled by callback return values.
 *  The decision to not use callback return values for controlling tree pruning arose from
 *  the goal of keeping the crawler backwards compatible. Observe that one of the pruning conditions
 *  precedes the callback call.
 * @param {string} [attrString]
 *  the path to the current attribute, as an attribute string (ie 'marker.line')
 *  typically unsupplied, but you may supply it if you want to disambiguate which attrs tree you
 *  are starting from
 *
 * @return {object} transformOut
 *  copy of transformIn that contains attribute defaults
 */
exports.crawl = function (attrs, callback, specifiedLevel, attrString) {
  var level = specifiedLevel || 0;
  attrString = attrString || '';
  Object.keys(attrs).forEach(function (attrName) {
    var attr = attrs[attrName];
    if (UNDERSCORE_ATTRS.indexOf(attrName) !== -1) return;
    var fullAttrString = (attrString ? attrString + '.' : '') + attrName;
    callback(attr, attrName, attrs, level, fullAttrString);
    if (exports.isValObject(attr)) return;
    if (isPlainObject(attr) && attrName !== 'impliedEdits') {
      exports.crawl(attr, callback, level + 1, fullAttrString);
    }
  });
};

/** Is object a value object (or a container object)?
 *
 * @param {object} obj
 * @return {boolean}
 *  returns true for a valid value object and
 *  false for tree nodes in the attribute hierarchy
 */
exports.isValObject = function (obj) {
  return obj && obj.valType !== undefined;
};

/**
 * Find all data array attributes in a given trace object - including
 * `arrayOk` attributes.
 *
 * @param {object} trace
 *  full trace object that contains a reference to `_module.attributes`
 *
 * @return {array} arrayAttributes
 *  list of array attributes for the given trace
 */
exports.findArrayAttributes = function (trace) {
  var arrayAttributes = [];
  var stack = [];
  var isArrayStack = [];
  var baseContainer, baseAttrName;
  function callback(attr, attrName, attrs, level) {
    stack = stack.slice(0, level).concat([attrName]);
    isArrayStack = isArrayStack.slice(0, level).concat([attr && attr._isLinkedToArray]);
    var splittableAttr = attr && (attr.valType === 'data_array' || attr.arrayOk === true) && !(stack[level - 1] === 'colorbar' && (attrName === 'ticktext' || attrName === 'tickvals'));

    // Manually exclude 'colorbar.tickvals' and 'colorbar.ticktext' for now
    // which are declared as `valType: 'data_array'` but scale independently of
    // the coordinate arrays.
    //
    // Down the road, we might want to add a schema field (e.g `uncorrelatedArray: true`)
    // to distinguish attributes of the likes.

    if (!splittableAttr) return;
    crawlIntoTrace(baseContainer, 0, '');
  }
  function crawlIntoTrace(container, i, astrPartial) {
    var item = container[stack[i]];
    var newAstrPartial = astrPartial + stack[i];
    if (i === stack.length - 1) {
      if (isArrayOrTypedArray(item)) {
        arrayAttributes.push(baseAttrName + newAstrPartial);
      }
    } else {
      if (isArrayStack[i]) {
        if (Array.isArray(item)) {
          for (var j = 0; j < item.length; j++) {
            if (isPlainObject(item[j])) {
              crawlIntoTrace(item[j], i + 1, newAstrPartial + '[' + j + '].');
            }
          }
        }
      } else if (isPlainObject(item)) {
        crawlIntoTrace(item, i + 1, newAstrPartial + '.');
      }
    }
  }
  baseContainer = trace;
  baseAttrName = '';
  exports.crawl(baseAttributes, callback);
  if (trace._module && trace._module.attributes) {
    exports.crawl(trace._module.attributes, callback);
  }
  var transforms = trace.transforms;
  if (transforms) {
    for (var i = 0; i < transforms.length; i++) {
      var transform = transforms[i];
      var module = transform._module;
      if (module) {
        baseAttrName = 'transforms[' + i + '].';
        baseContainer = transform;
        exports.crawl(module.attributes, callback);
      }
    }
  }
  return arrayAttributes;
};

/*
 * Find the valObject for one attribute in an existing trace
 *
 * @param {object} trace
 *  full trace object that contains a reference to `_module.attributes`
 * @param {object} parts
 *  an array of parts, like ['transforms', 1, 'value']
 *  typically from nestedProperty(...).parts
 *
 * @return {object|false}
 *  the valObject for this attribute, or the last found parent
 *  in some cases the innermost valObject will not exist, for example
 *  `valType: 'any'` attributes where we might set a part of the attribute.
 *  In that case, stop at the deepest valObject we *do* find.
 */
exports.getTraceValObject = function (trace, parts) {
  var head = parts[0];
  var i = 1; // index to start recursing from
  var moduleAttrs, valObject;
  if (head === 'transforms') {
    if (parts.length === 1) {
      return baseAttributes.transforms;
    }
    var transforms = trace.transforms;
    if (!Array.isArray(transforms) || !transforms.length) return false;
    var tNum = parts[1];
    if (!isIndex(tNum) || tNum >= transforms.length) {
      return false;
    }
    moduleAttrs = (Registry.transformsRegistry[transforms[tNum].type] || {}).attributes;
    valObject = moduleAttrs && moduleAttrs[parts[2]];
    i = 3; // start recursing only inside the transform
  } else {
    // first look in the module for this trace
    // components have already merged their trace attributes in here
    var _module = trace._module;
    if (!_module) _module = (Registry.modules[trace.type || baseAttributes.type.dflt] || {})._module;
    if (!_module) return false;
    moduleAttrs = _module.attributes;
    valObject = moduleAttrs && moduleAttrs[head];

    // then look in the subplot attributes
    if (!valObject) {
      var subplotModule = _module.basePlotModule;
      if (subplotModule && subplotModule.attributes) {
        valObject = subplotModule.attributes[head];
      }
    }

    // finally look in the global attributes
    if (!valObject) valObject = baseAttributes[head];
  }
  return recurseIntoValObject(valObject, parts, i);
};

/*
 * Find the valObject for one layout attribute
 *
 * @param {array} parts
 *  an array of parts, like ['annotations', 1, 'x']
 *  typically from nestedProperty(...).parts
 *
 * @return {object|false}
 *  the valObject for this attribute, or the last found parent
 *  in some cases the innermost valObject will not exist, for example
 *  `valType: 'any'` attributes where we might set a part of the attribute.
 *  In that case, stop at the deepest valObject we *do* find.
 */
exports.getLayoutValObject = function (fullLayout, parts) {
  var valObject = layoutHeadAttr(fullLayout, parts[0]);
  return recurseIntoValObject(valObject, parts, 1);
};
function layoutHeadAttr(fullLayout, head) {
  var i, key, _module, attributes;

  // look for attributes of the subplot types used on the plot
  var basePlotModules = fullLayout._basePlotModules;
  if (basePlotModules) {
    var out;
    for (i = 0; i < basePlotModules.length; i++) {
      _module = basePlotModules[i];
      if (_module.attrRegex && _module.attrRegex.test(head)) {
        // if a module defines overrides, these take precedence
        // initially this is to allow gl2d different editTypes from svg cartesian
        if (_module.layoutAttrOverrides) return _module.layoutAttrOverrides;

        // otherwise take the first attributes we find
        if (!out && _module.layoutAttributes) out = _module.layoutAttributes;
      }

      // a module can also override the behavior of base (and component) module layout attrs
      // again see gl2d for initial use case
      var baseOverrides = _module.baseLayoutAttrOverrides;
      if (baseOverrides && head in baseOverrides) return baseOverrides[head];
    }
    if (out) return out;
  }

  // look for layout attributes contributed by traces on the plot
  var modules = fullLayout._modules;
  if (modules) {
    for (i = 0; i < modules.length; i++) {
      attributes = modules[i].layoutAttributes;
      if (attributes && head in attributes) {
        return attributes[head];
      }
    }
  }

  /*
   * Next look in components.
   * Components that define a schema have already merged this into
   * base and subplot attribute defs, so ignore these.
   * Others (older style) all put all their attributes
   * inside a container matching the module `name`
   * eg `attributes` (array) or `legend` (object)
   */
  for (key in Registry.componentsRegistry) {
    _module = Registry.componentsRegistry[key];
    if (_module.name === 'colorscale' && head.indexOf('coloraxis') === 0) {
      return _module.layoutAttributes[head];
    } else if (!_module.schema && head === _module.name) {
      return _module.layoutAttributes;
    }
  }
  if (head in baseLayoutAttributes) return baseLayoutAttributes[head];
  return false;
}
function recurseIntoValObject(valObject, parts, i) {
  if (!valObject) return false;
  if (valObject._isLinkedToArray) {
    // skip array index, abort if we try to dive into an array without an index
    if (isIndex(parts[i])) i++;else if (i < parts.length) return false;
  }

  // now recurse as far as we can. Occasionally we have an attribute
  // setting an internal part below what's in the schema; just return
  // the innermost schema item we find.
  for (; i < parts.length; i++) {
    var newValObject = valObject[parts[i]];
    if (isPlainObject(newValObject)) valObject = newValObject;else break;
    if (i === parts.length - 1) break;
    if (valObject._isLinkedToArray) {
      i++;
      if (!isIndex(parts[i])) return false;
    } else if (valObject.valType === 'info_array') {
      i++;
      var index = parts[i];
      if (!isIndex(index)) return false;
      var items = valObject.items;
      if (Array.isArray(items)) {
        if (index >= items.length) return false;
        if (valObject.dimensions === 2) {
          i++;
          if (parts.length === i) return valObject;
          var index2 = parts[i];
          if (!isIndex(index2)) return false;
          valObject = items[index][index2];
        } else valObject = items[index];
      } else {
        valObject = items;
      }
    }
  }
  return valObject;
}

// note: this is different from Lib.isIndex, this one doesn't accept numeric
// strings, only actual numbers.
function isIndex(val) {
  return val === Math.round(val) && val >= 0;
}
function getTraceAttributes(type) {
  var _module, basePlotModule;
  _module = Registry.modules[type]._module, basePlotModule = _module.basePlotModule;
  var attributes = {};

  // make 'type' the first attribute in the object
  attributes.type = null;
  var copyBaseAttributes = extendDeepAll({}, baseAttributes);
  var copyModuleAttributes = extendDeepAll({}, _module.attributes);

  // prune global-level trace attributes that are already defined in a trace
  exports.crawl(copyModuleAttributes, function (attr, attrName, attrs, level, fullAttrString) {
    nestedProperty(copyBaseAttributes, fullAttrString).set(undefined);
    // Prune undefined attributes
    if (attr === undefined) nestedProperty(copyModuleAttributes, fullAttrString).set(undefined);
  });

  // base attributes (same for all trace types)
  extendDeepAll(attributes, copyBaseAttributes);

  // prune-out base attributes based on trace module categories
  if (Registry.traceIs(type, 'noOpacity')) {
    delete attributes.opacity;
  }
  if (!Registry.traceIs(type, 'showLegend')) {
    delete attributes.showlegend;
    delete attributes.legendgroup;
  }
  if (Registry.traceIs(type, 'noHover')) {
    delete attributes.hoverinfo;
    delete attributes.hoverlabel;
  }
  if (!_module.selectPoints) {
    delete attributes.selectedpoints;
  }

  // module attributes
  extendDeepAll(attributes, copyModuleAttributes);

  // subplot attributes
  if (basePlotModule.attributes) {
    extendDeepAll(attributes, basePlotModule.attributes);
  }

  // 'type' gets overwritten by baseAttributes; reset it here
  attributes.type = type;
  var out = {
    meta: _module.meta || {},
    categories: _module.categories || {},
    animatable: Boolean(_module.animatable),
    type: type,
    attributes: formatAttributes(attributes)
  };

  // trace-specific layout attributes
  if (_module.layoutAttributes) {
    var layoutAttributes = {};
    extendDeepAll(layoutAttributes, _module.layoutAttributes);
    out.layoutAttributes = formatAttributes(layoutAttributes);
  }

  // drop anim:true in non-animatable modules
  if (!_module.animatable) {
    exports.crawl(out, function (attr) {
      if (exports.isValObject(attr) && 'anim' in attr) {
        delete attr.anim;
      }
    });
  }
  return out;
}
function getLayoutAttributes() {
  var layoutAttributes = {};
  var key, _module;

  // global layout attributes
  extendDeepAll(layoutAttributes, baseLayoutAttributes);

  // add base plot module layout attributes
  for (key in Registry.subplotsRegistry) {
    _module = Registry.subplotsRegistry[key];
    if (!_module.layoutAttributes) continue;
    if (Array.isArray(_module.attr)) {
      for (var i = 0; i < _module.attr.length; i++) {
        handleBasePlotModule(layoutAttributes, _module, _module.attr[i]);
      }
    } else {
      var astr = _module.attr === 'subplot' ? _module.name : _module.attr;
      handleBasePlotModule(layoutAttributes, _module, astr);
    }
  }

  // add registered components layout attributes
  for (key in Registry.componentsRegistry) {
    _module = Registry.componentsRegistry[key];
    var schema = _module.schema;
    if (schema && (schema.subplots || schema.layout)) {
      /*
       * Components with defined schema have already been merged in at register time
       * but a few components define attributes that apply only to xaxis
       * not yaxis (rangeselector, rangeslider) - delete from y schema.
       * Note that the input attributes for xaxis/yaxis are the same object
       * so it's not possible to only add them to xaxis from the start.
       * If we ever have such asymmetry the other way, or anywhere else,
       * we will need to extend both this code and mergeComponentAttrsToSubplot
       * (which will not find yaxis only for example)
       */
      var subplots = schema.subplots;
      if (subplots && subplots.xaxis && !subplots.yaxis) {
        for (var xkey in subplots.xaxis) {
          delete layoutAttributes.yaxis[xkey];
        }
      }

      /*
       * Also some attributes e.g. shift & autoshift only implemented on the yaxis
       * at the moment. Remove them from the xaxis.
      */
      delete layoutAttributes.xaxis.shift;
      delete layoutAttributes.xaxis.autoshift;
    } else if (_module.name === 'colorscale') {
      extendDeepAll(layoutAttributes, _module.layoutAttributes);
    } else if (_module.layoutAttributes) {
      // older style without schema need to be explicitly merged in now
      insertAttrs(layoutAttributes, _module.layoutAttributes, _module.name);
    }
  }
  return {
    layoutAttributes: formatAttributes(layoutAttributes)
  };
}
function getTransformAttributes(type) {
  var _module = Registry.transformsRegistry[type];
  var attributes = extendDeepAll({}, _module.attributes);

  // add registered components transform attributes
  Object.keys(Registry.componentsRegistry).forEach(function (k) {
    var _module = Registry.componentsRegistry[k];
    if (_module.schema && _module.schema.transforms && _module.schema.transforms[type]) {
      Object.keys(_module.schema.transforms[type]).forEach(function (v) {
        insertAttrs(attributes, _module.schema.transforms[type][v], v);
      });
    }
  });
  return {
    attributes: formatAttributes(attributes)
  };
}
function getFramesAttributes() {
  var attrs = {
    frames: extendDeepAll({}, frameAttributes)
  };
  formatAttributes(attrs);
  return attrs.frames;
}
function formatAttributes(attrs) {
  mergeValTypeAndRole(attrs);
  formatArrayContainers(attrs);
  stringify(attrs);
  return attrs;
}
function mergeValTypeAndRole(attrs) {
  function makeSrcAttr(attrName) {
    return {
      valType: 'string',
      editType: 'none'
    };
  }
  function callback(attr, attrName, attrs) {
    if (exports.isValObject(attr)) {
      if (attr.arrayOk === true || attr.valType === 'data_array') {
        // all 'arrayOk' and 'data_array' attrs have a corresponding 'src' attr
        attrs[attrName + 'src'] = makeSrcAttr(attrName);
      }
    } else if (isPlainObject(attr)) {
      // all attrs container objects get role 'object'
      attr.role = 'object';
    }
  }
  exports.crawl(attrs, callback);
}
function formatArrayContainers(attrs) {
  function callback(attr, attrName, attrs) {
    if (!attr) return;
    var itemName = attr[IS_LINKED_TO_ARRAY];
    if (!itemName) return;
    delete attr[IS_LINKED_TO_ARRAY];
    attrs[attrName] = {
      items: {}
    };
    attrs[attrName].items[itemName] = attr;
    attrs[attrName].role = 'object';
  }
  exports.crawl(attrs, callback);
}

// this can take around 10ms and should only be run from PlotSchema.get(),
// to ensure JSON.stringify(PlotSchema.get()) gives the intended result.
function stringify(attrs) {
  function walk(attr) {
    for (var k in attr) {
      if (isPlainObject(attr[k])) {
        walk(attr[k]);
      } else if (Array.isArray(attr[k])) {
        for (var i = 0; i < attr[k].length; i++) {
          walk(attr[k][i]);
        }
      } else {
        // as JSON.stringify(/test/) // => {}
        if (attr[k] instanceof RegExp) {
          attr[k] = attr[k].toString();
        }
      }
    }
  }
  walk(attrs);
}
function handleBasePlotModule(layoutAttributes, _module, astr) {
  var np = nestedProperty(layoutAttributes, astr);
  var attrs = extendDeepAll({}, _module.layoutAttributes);
  attrs[IS_SUBPLOT_OBJ] = true;
  np.set(attrs);
}
function insertAttrs(baseAttrs, newAttrs, astr) {
  var np = nestedProperty(baseAttrs, astr);
  np.set(extendDeepAll(np.get() || {}, newAttrs));
}

/***/ }),

/***/ 4467:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var plotAttributes = __webpack_require__(9012);
var TEMPLATEITEMNAME = 'templateitemname';
var templateAttrs = {
  name: {
    valType: 'string',
    editType: 'none'
  }
};
templateAttrs[TEMPLATEITEMNAME] = {
  valType: 'string',
  editType: 'calc'
};

/**
 * templatedArray: decorate an attributes object with templating (and array)
 * properties.
 *
 * @param {string} name: the singular form of the array name. Sets
 *     `_isLinkedToArray` to this, so the schema knows to treat this as an array.
 * @param {object} attrs: the item attributes. Since all callers are expected
 *     to be constructing this object on the spot, we mutate it here for
 *     performance, rather than extending a new object with it.
 *
 * @returns {object}: the decorated `attrs` object
 */
exports.templatedArray = function (name, attrs) {
  attrs._isLinkedToArray = name;
  attrs.name = templateAttrs.name;
  attrs[TEMPLATEITEMNAME] = templateAttrs[TEMPLATEITEMNAME];
  return attrs;
};

/**
 * traceTemplater: logic for matching traces to trace templates
 *
 * @param {object} dataTemplate: collection of {traceType: [{template}, ...]}
 *     ie each type the template applies to contains a list of template objects,
 *     to be provided cyclically to data traces of that type.
 *
 * @returns {object}: {newTrace}, a function:
 *     newTrace(traceIn): that takes the input traceIn, coerces its type, then
 *         uses that type to find the next template to apply. returns the output
 *         traceOut with template attached, ready to continue supplyDefaults.
 */
exports.traceTemplater = function (dataTemplate) {
  var traceCounts = {};
  var traceType, typeTemplates;
  for (traceType in dataTemplate) {
    typeTemplates = dataTemplate[traceType];
    if (Array.isArray(typeTemplates) && typeTemplates.length) {
      traceCounts[traceType] = 0;
    }
  }
  function newTrace(traceIn) {
    traceType = Lib.coerce(traceIn, {}, plotAttributes, 'type');
    var traceOut = {
      type: traceType,
      _template: null
    };
    if (traceType in traceCounts) {
      typeTemplates = dataTemplate[traceType];
      // cycle through traces in the template set for this type
      var typei = traceCounts[traceType] % typeTemplates.length;
      traceCounts[traceType]++;
      traceOut._template = typeTemplates[typei];
    } else {
      // TODO: anything we should do for types missing from the template?
      // try to apply some other type? Or just bail as we do here?
      // Actually I think yes, we should apply other types; would be nice
      // if all scatter* could inherit from each other, and if histogram
      // could inherit from bar, etc... but how to specify this? And do we
      // compose them, or if a type is present require it to be complete?
      // Actually this could apply to layout too - 3D annotations
      // inheriting from 2D, axes of different types inheriting from each
      // other...
    }
    return traceOut;
  }
  return {
    newTrace: newTrace
    // TODO: function to figure out what's left & what didn't work
  };
};

/**
 * newContainer: Create a new sub-container inside `container` and propagate any
 * applicable template to it. If there's no template, still propagates
 * `undefined` so relinkPrivate will not retain an old template!
 *
 * @param {object} container: the outer container, should already have _template
 *     if there *is* a template for this plot
 * @param {string} name: the key of the new container to make
 * @param {string} baseName: if applicable, a base attribute to take the
 *     template from, ie for xaxis3 the base would be xaxis
 *
 * @returns {object}: an object for inclusion _full*, empty except for the
 *     appropriate template piece
 */
exports.newContainer = function (container, name, baseName) {
  var template = container._template;
  var part = template && (template[name] || baseName && template[baseName]);
  if (!Lib.isPlainObject(part)) part = null;
  var out = container[name] = {
    _template: part
  };
  return out;
};

/**
 * arrayTemplater: special logic for templating both defaults and specific items
 * in a container array (annotations etc)
 *
 * @param {object} container: the outer container, should already have _template
 *     if there *is* a template for this plot
 * @param {string} name: the name of the array to template (ie 'annotations')
 *     will be used to find default ('annotationdefaults' object) and specific
 *     ('annotations' array) template specs.
 * @param {string} inclusionAttr: the attribute determining this item's
 *     inclusion in the output, usually 'visible' or 'enabled'
 *
 * @returns {object}: {newItem, defaultItems}, both functions:
 *     newItem(itemIn): create an output item, bare except for the correct
 *         template and name(s), as the base for supplyDefaults
 *     defaultItems(): to be called after all newItem calls, return any
 *         specific template items that have not already beeen included,
 *         also as bare output items ready for supplyDefaults.
 */
exports.arrayTemplater = function (container, name, inclusionAttr) {
  var template = container._template;
  var defaultsTemplate = template && template[arrayDefaultKey(name)];
  var templateItems = template && template[name];
  if (!Array.isArray(templateItems) || !templateItems.length) {
    templateItems = [];
  }
  var usedNames = {};
  function newItem(itemIn) {
    // include name and templateitemname in the output object for ALL
    // container array items. Note: you could potentially use different
    // name and templateitemname, if you're using one template to make
    // another template. templateitemname would be the name in the original
    // template, and name is the new "subclassed" item name.
    var out = {
      name: itemIn.name,
      _input: itemIn
    };
    var templateItemName = out[TEMPLATEITEMNAME] = itemIn[TEMPLATEITEMNAME];

    // no itemname: use the default template
    if (!validItemName(templateItemName)) {
      out._template = defaultsTemplate;
      return out;
    }

    // look for an item matching this itemname
    // note these do not inherit from the default template, only the item.
    for (var i = 0; i < templateItems.length; i++) {
      var templateItem = templateItems[i];
      if (templateItem.name === templateItemName) {
        // Note: it's OK to use a template item more than once
        // but using it at least once will stop it from generating
        // a default item at the end.
        usedNames[templateItemName] = 1;
        out._template = templateItem;
        return out;
      }
    }

    // Didn't find a matching template item, so since this item is intended
    // to only be modifications it's most likely broken. Hide it unless
    // it's explicitly marked visible - in which case it gets NO template,
    // not even the default.
    out[inclusionAttr] = itemIn[inclusionAttr] || false;
    // special falsy value we can look for in validateTemplate
    out._template = false;
    return out;
  }
  function defaultItems() {
    var out = [];
    for (var i = 0; i < templateItems.length; i++) {
      var templateItem = templateItems[i];
      var name = templateItem.name;
      // only allow named items to be added as defaults,
      // and only allow each name once
      if (validItemName(name) && !usedNames[name]) {
        var outi = {
          _template: templateItem,
          name: name,
          _input: {
            _templateitemname: name
          }
        };
        outi[TEMPLATEITEMNAME] = templateItem[TEMPLATEITEMNAME];
        out.push(outi);
        usedNames[name] = 1;
      }
    }
    return out;
  }
  return {
    newItem: newItem,
    defaultItems: defaultItems
  };
};
function validItemName(name) {
  return name && typeof name === 'string';
}
function arrayDefaultKey(name) {
  var lastChar = name.length - 1;
  if (name.charAt(lastChar) !== 's') {
    Lib.warn('bad argument to arrayDefaultKey: ' + name);
  }
  return name.substr(0, name.length - 1) + 'defaults';
}
exports.arrayDefaultKey = arrayDefaultKey;

/**
 * arrayEditor: helper for editing array items that may have come from
 *     template defaults (in which case they will not exist in the input yet)
 *
 * @param {object} parentIn: the input container (eg gd.layout)
 * @param {string} containerStr: the attribute string for the container inside
 *     `parentIn`.
 * @param {object} itemOut: the _full* item (eg gd._fullLayout.annotations[0])
 *     that we'll be editing. Assumed to have been created by `arrayTemplater`.
 *
 * @returns {object}: {modifyBase, modifyItem, getUpdateObj, applyUpdate}, all functions:
 *     modifyBase(attr, value): Add an update that's *not* related to the item.
 *         `attr` is the full attribute string.
 *     modifyItem(attr, value): Add an update to the item. `attr` is just the
 *         portion of the attribute string inside the item.
 *     getUpdateObj(): Get the final constructed update object, to use in
 *         `restyle` or `relayout`. Also resets the update object in case this
 *         update was canceled.
 *     applyUpdate(attr, value): optionally add an update `attr: value`,
 *         then apply it to `parent` which should be the parent of `containerIn`,
 *         ie the object to which `containerStr` is the attribute string.
 */
exports.arrayEditor = function (parentIn, containerStr, itemOut) {
  var lengthIn = (Lib.nestedProperty(parentIn, containerStr).get() || []).length;
  var index = itemOut._index;
  // Check that we are indeed off the end of this container.
  // Otherwise a devious user could put a key `_templateitemname` in their
  // own input and break lots of things.
  var templateItemName = index >= lengthIn && (itemOut._input || {})._templateitemname;
  if (templateItemName) index = lengthIn;
  var itemStr = containerStr + '[' + index + ']';
  var update;
  function resetUpdate() {
    update = {};
    if (templateItemName) {
      update[itemStr] = {};
      update[itemStr][TEMPLATEITEMNAME] = templateItemName;
    }
  }
  resetUpdate();
  function modifyBase(attr, value) {
    update[attr] = value;
  }
  function modifyItem(attr, value) {
    if (templateItemName) {
      // we're making a new object: edit that object
      Lib.nestedProperty(update[itemStr], attr).set(value);
    } else {
      // we're editing an existing object: include *just* the edit
      update[itemStr + '.' + attr] = value;
    }
  }
  function getUpdateObj() {
    var updateOut = update;
    resetUpdate();
    return updateOut;
  }
  function applyUpdate(attr, value) {
    if (attr) modifyItem(attr, value);
    var updateToApply = getUpdateObj();
    for (var key in updateToApply) {
      Lib.nestedProperty(parentIn, key).set(updateToApply[key]);
    }
  }
  return {
    modifyBase: modifyBase,
    modifyItem: modifyItem,
    getUpdateObj: getUpdateObj,
    applyUpdate: applyUpdate
  };
};

/***/ }),

/***/ 1549:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Registry = __webpack_require__(3972);
var Plots = __webpack_require__(4875);
var Lib = __webpack_require__(1828);
var svgTextUtils = __webpack_require__(3893);
var clearGlCanvases = __webpack_require__(3306);
var Color = __webpack_require__(7901);
var Drawing = __webpack_require__(1424);
var Titles = __webpack_require__(2998);
var ModeBar = __webpack_require__(4168);
var Axes = __webpack_require__(9298);
var alignmentConstants = __webpack_require__(8783);
var axisConstraints = __webpack_require__(9082);
var enforceAxisConstraints = axisConstraints.enforce;
var cleanAxisConstraints = axisConstraints.clean;
var doAutoRange = (__webpack_require__(1739).doAutoRange);
var SVG_TEXT_ANCHOR_START = 'start';
var SVG_TEXT_ANCHOR_MIDDLE = 'middle';
var SVG_TEXT_ANCHOR_END = 'end';
exports.layoutStyles = function (gd) {
  return Lib.syncOrAsync([Plots.doAutoMargin, lsInner], gd);
};
function overlappingDomain(xDomain, yDomain, domains) {
  for (var i = 0; i < domains.length; i++) {
    var existingX = domains[i][0];
    var existingY = domains[i][1];
    if (existingX[0] >= xDomain[1] || existingX[1] <= xDomain[0]) {
      continue;
    }
    if (existingY[0] < yDomain[1] && existingY[1] > yDomain[0]) {
      return true;
    }
  }
  return false;
}
function lsInner(gd) {
  var fullLayout = gd._fullLayout;
  var gs = fullLayout._size;
  var pad = gs.p;
  var axList = Axes.list(gd, '', true);
  var i, subplot, plotinfo, ax, xa, ya;
  fullLayout._paperdiv.style({
    width: gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroWidth && !gd.layout.width ? '100%' : fullLayout.width + 'px',
    height: gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroHeight && !gd.layout.height ? '100%' : fullLayout.height + 'px'
  }).selectAll('.main-svg').call(Drawing.setSize, fullLayout.width, fullLayout.height);
  gd._context.setBackground(gd, fullLayout.paper_bgcolor);
  exports.drawMainTitle(gd);
  ModeBar.manage(gd);

  // _has('cartesian') means SVG specifically, not GL2D - but GL2D
  // can still get here because it makes some of the SVG structure
  // for shared features like selections.
  if (!fullLayout._has('cartesian')) {
    return Plots.previousPromises(gd);
  }
  function getLinePosition(ax, counterAx, side) {
    var lwHalf = ax._lw / 2;
    if (ax._id.charAt(0) === 'x') {
      if (!counterAx) return gs.t + gs.h * (1 - (ax.position || 0)) + lwHalf % 1;else if (side === 'top') return counterAx._offset - pad - lwHalf;
      return counterAx._offset + counterAx._length + pad + lwHalf;
    }
    if (!counterAx) return gs.l + gs.w * (ax.position || 0) + lwHalf % 1;else if (side === 'right') return counterAx._offset + counterAx._length + pad + lwHalf;
    return counterAx._offset - pad - lwHalf;
  }

  // some preparation of axis position info
  for (i = 0; i < axList.length; i++) {
    ax = axList[i];
    var counterAx = ax._anchorAxis;

    // clear axis line positions, to be set in the subplot loop below
    ax._linepositions = {};

    // stash crispRounded linewidth so we don't need to pass gd all over the place
    ax._lw = Drawing.crispRound(gd, ax.linewidth, 1);

    // figure out the main axis line and main mirror line position.
    // it's easier to follow the logic if we handle these separately from
    // ax._linepositions, which are only used by mirror=allticks
    // for non-main-subplot ticks, and mirror=all(ticks)? for zero line
    // hiding logic
    ax._mainLinePosition = getLinePosition(ax, counterAx, ax.side);
    ax._mainMirrorPosition = ax.mirror && counterAx ? getLinePosition(ax, counterAx, alignmentConstants.OPPOSITE_SIDE[ax.side]) : null;
  }

  // figure out which backgrounds we need to draw,
  // and in which layers to put them
  var lowerBackgroundIDs = [];
  var backgroundIds = [];
  var lowerDomains = [];
  // no need to draw background when paper and plot color are the same color,
  // activate mode just for large splom (which benefit the most from this
  // optimization), but this could apply to all cartesian subplots.
  var noNeedForBg = Color.opacity(fullLayout.paper_bgcolor) === 1 && Color.opacity(fullLayout.plot_bgcolor) === 1 && fullLayout.paper_bgcolor === fullLayout.plot_bgcolor;
  for (subplot in fullLayout._plots) {
    plotinfo = fullLayout._plots[subplot];
    if (plotinfo.mainplot) {
      // mainplot is a reference to the main plot this one is overlaid on
      // so if it exists, this is an overlaid plot and we don't need to
      // give it its own background
      if (plotinfo.bg) {
        plotinfo.bg.remove();
      }
      plotinfo.bg = undefined;
    } else {
      var xDomain = plotinfo.xaxis.domain;
      var yDomain = plotinfo.yaxis.domain;
      var plotgroup = plotinfo.plotgroup;
      if (overlappingDomain(xDomain, yDomain, lowerDomains)) {
        var pgNode = plotgroup.node();
        var plotgroupBg = plotinfo.bg = Lib.ensureSingle(plotgroup, 'rect', 'bg');
        pgNode.insertBefore(plotgroupBg.node(), pgNode.childNodes[0]);
        backgroundIds.push(subplot);
      } else {
        plotgroup.select('rect.bg').remove();
        lowerDomains.push([xDomain, yDomain]);
        if (!noNeedForBg) {
          lowerBackgroundIDs.push(subplot);
          backgroundIds.push(subplot);
        }
      }
    }
  }

  // now create all the lower-layer backgrounds at once now that
  // we have the list of subplots that need them
  var lowerBackgrounds = fullLayout._bgLayer.selectAll('.bg').data(lowerBackgroundIDs);
  lowerBackgrounds.enter().append('rect').classed('bg', true);
  lowerBackgrounds.exit().remove();
  lowerBackgrounds.each(function (subplot) {
    fullLayout._plots[subplot].bg = d3.select(this);
  });

  // style all backgrounds
  for (i = 0; i < backgroundIds.length; i++) {
    plotinfo = fullLayout._plots[backgroundIds[i]];
    xa = plotinfo.xaxis;
    ya = plotinfo.yaxis;
    if (plotinfo.bg && xa._offset !== undefined && ya._offset !== undefined) {
      plotinfo.bg.call(Drawing.setRect, xa._offset - pad, ya._offset - pad, xa._length + 2 * pad, ya._length + 2 * pad).call(Color.fill, fullLayout.plot_bgcolor).style('stroke-width', 0);
    }
  }
  if (!fullLayout._hasOnlyLargeSploms) {
    for (subplot in fullLayout._plots) {
      plotinfo = fullLayout._plots[subplot];
      xa = plotinfo.xaxis;
      ya = plotinfo.yaxis;

      // Clip so that data only shows up on the plot area.
      var clipId = plotinfo.clipId = 'clip' + fullLayout._uid + subplot + 'plot';
      var plotClip = Lib.ensureSingleById(fullLayout._clips, 'clipPath', clipId, function (s) {
        s.classed('plotclip', true).append('rect');
      });
      plotinfo.clipRect = plotClip.select('rect').attr({
        width: xa._length,
        height: ya._length
      });
      Drawing.setTranslate(plotinfo.plot, xa._offset, ya._offset);
      var plotClipId;
      var layerClipId;
      if (plotinfo._hasClipOnAxisFalse) {
        plotClipId = null;
        layerClipId = clipId;
      } else {
        plotClipId = clipId;
        layerClipId = null;
      }
      Drawing.setClipUrl(plotinfo.plot, plotClipId, gd);

      // stash layer clipId value (null or same as clipId)
      // to DRY up Drawing.setClipUrl calls on trace-module and trace layers
      // downstream
      plotinfo.layerClipId = layerClipId;
    }
  }
  var xLinesXLeft, xLinesXRight, xLinesYBottom, xLinesYTop, leftYLineWidth, rightYLineWidth;
  var yLinesYBottom, yLinesYTop, yLinesXLeft, yLinesXRight, connectYBottom, connectYTop;
  var extraSubplot;
  function xLinePath(y) {
    return 'M' + xLinesXLeft + ',' + y + 'H' + xLinesXRight;
  }
  function xLinePathFree(y) {
    return 'M' + xa._offset + ',' + y + 'h' + xa._length;
  }
  function yLinePath(x) {
    return 'M' + x + ',' + yLinesYTop + 'V' + yLinesYBottom;
  }
  function yLinePathFree(x) {
    if (ya._shift !== undefined) {
      x += ya._shift;
    }
    return 'M' + x + ',' + ya._offset + 'v' + ya._length;
  }
  function mainPath(ax, pathFn, pathFnFree) {
    if (!ax.showline || subplot !== ax._mainSubplot) return '';
    if (!ax._anchorAxis) return pathFnFree(ax._mainLinePosition);
    var out = pathFn(ax._mainLinePosition);
    if (ax.mirror) out += pathFn(ax._mainMirrorPosition);
    return out;
  }
  for (subplot in fullLayout._plots) {
    plotinfo = fullLayout._plots[subplot];
    xa = plotinfo.xaxis;
    ya = plotinfo.yaxis;

    /*
     * x lines get longer where they meet y lines, to make a crisp corner.
     * The x lines get the padding (margin.pad) plus the y line width to
     * fill up the corner nicely. Free x lines are excluded - they always
     * span exactly the data area of the plot
     *
     *  | XXXXX
     *  | XXXXX
     *  |
     *  +------
     *     x1
     *    -----
     *     x2
     */
    var xPath = 'M0,0';
    if (shouldShowLinesOrTicks(xa, subplot)) {
      leftYLineWidth = findCounterAxisLineWidth(xa, 'left', ya, axList);
      xLinesXLeft = xa._offset - (leftYLineWidth ? pad + leftYLineWidth : 0);
      rightYLineWidth = findCounterAxisLineWidth(xa, 'right', ya, axList);
      xLinesXRight = xa._offset + xa._length + (rightYLineWidth ? pad + rightYLineWidth : 0);
      xLinesYBottom = getLinePosition(xa, ya, 'bottom');
      xLinesYTop = getLinePosition(xa, ya, 'top');

      // save axis line positions for extra ticks to reference
      // each subplot that gets ticks from "allticks" gets an entry:
      //    [left or bottom, right or top]
      extraSubplot = !xa._anchorAxis || subplot !== xa._mainSubplot;
      if (extraSubplot && (xa.mirror === 'allticks' || xa.mirror === 'all')) {
        xa._linepositions[subplot] = [xLinesYBottom, xLinesYTop];
      }
      xPath = mainPath(xa, xLinePath, xLinePathFree);
      if (extraSubplot && xa.showline && (xa.mirror === 'all' || xa.mirror === 'allticks')) {
        xPath += xLinePath(xLinesYBottom) + xLinePath(xLinesYTop);
      }
      plotinfo.xlines.style('stroke-width', xa._lw + 'px').call(Color.stroke, xa.showline ? xa.linecolor : 'rgba(0,0,0,0)');
    }
    plotinfo.xlines.attr('d', xPath);

    /*
     * y lines that meet x axes get longer only by margin.pad, because
     * the x axes fill in the corner space. Free y axes, like free x axes,
     * always span exactly the data area of the plot
     *
     *   |   | XXXX
     * y2| y1| XXXX
     *   |   | XXXX
     *       |
     *       +-----
     */
    var yPath = 'M0,0';
    if (shouldShowLinesOrTicks(ya, subplot)) {
      connectYBottom = findCounterAxisLineWidth(ya, 'bottom', xa, axList);
      yLinesYBottom = ya._offset + ya._length + (connectYBottom ? pad : 0);
      connectYTop = findCounterAxisLineWidth(ya, 'top', xa, axList);
      yLinesYTop = ya._offset - (connectYTop ? pad : 0);
      yLinesXLeft = getLinePosition(ya, xa, 'left');
      yLinesXRight = getLinePosition(ya, xa, 'right');
      extraSubplot = !ya._anchorAxis || subplot !== ya._mainSubplot;
      if (extraSubplot && (ya.mirror === 'allticks' || ya.mirror === 'all')) {
        ya._linepositions[subplot] = [yLinesXLeft, yLinesXRight];
      }
      yPath = mainPath(ya, yLinePath, yLinePathFree);
      if (extraSubplot && ya.showline && (ya.mirror === 'all' || ya.mirror === 'allticks')) {
        yPath += yLinePath(yLinesXLeft) + yLinePath(yLinesXRight);
      }
      plotinfo.ylines.style('stroke-width', ya._lw + 'px').call(Color.stroke, ya.showline ? ya.linecolor : 'rgba(0,0,0,0)');
    }
    plotinfo.ylines.attr('d', yPath);
  }
  Axes.makeClipPaths(gd);
  return Plots.previousPromises(gd);
}
function shouldShowLinesOrTicks(ax, subplot) {
  return (ax.ticks || ax.showline) && (subplot === ax._mainSubplot || ax.mirror === 'all' || ax.mirror === 'allticks');
}

/*
 * should we draw a line on counterAx at this side of ax?
 * It's assumed that counterAx is known to overlay the subplot we're working on
 * but it may not be its main axis.
 */
function shouldShowLineThisSide(ax, side, counterAx) {
  // does counterAx get a line at all?
  if (!counterAx.showline || !counterAx._lw) return false;

  // are we drawing *all* lines for counterAx?
  if (counterAx.mirror === 'all' || counterAx.mirror === 'allticks') return true;
  var anchorAx = counterAx._anchorAxis;

  // is this a free axis? free axes can only have a subplot side-line with all(ticks)? mirroring
  if (!anchorAx) return false;

  // in order to handle cases where the user forgot to anchor this axis correctly
  // (because its default anchor has the same domain on the relevant end)
  // check whether the relevant position is the same.
  var sideIndex = alignmentConstants.FROM_BL[side];
  if (counterAx.side === side) {
    return anchorAx.domain[sideIndex] === ax.domain[sideIndex];
  }
  return counterAx.mirror && anchorAx.domain[1 - sideIndex] === ax.domain[1 - sideIndex];
}

/*
 * Is there another axis intersecting `side` end of `ax`?
 * First look at `counterAx` (the axis for this subplot),
 * then at all other potential counteraxes on or overlaying this subplot.
 * Take the line width from the first one that has a line.
 */
function findCounterAxisLineWidth(ax, side, counterAx, axList) {
  if (shouldShowLineThisSide(ax, side, counterAx)) {
    return counterAx._lw;
  }
  for (var i = 0; i < axList.length; i++) {
    var axi = axList[i];
    if (axi._mainAxis === counterAx._mainAxis && shouldShowLineThisSide(ax, side, axi)) {
      return axi._lw;
    }
  }
  return 0;
}
exports.drawMainTitle = function (gd) {
  var title = gd._fullLayout.title;
  var fullLayout = gd._fullLayout;
  var textAnchor = getMainTitleTextAnchor(fullLayout);
  var dy = getMainTitleDy(fullLayout);
  var y = getMainTitleY(fullLayout, dy);
  var x = getMainTitleX(fullLayout, textAnchor);
  Titles.draw(gd, 'gtitle', {
    propContainer: fullLayout,
    propName: 'title.text',
    placeholder: fullLayout._dfltTitle.plot,
    attributes: {
      x: x,
      y: y,
      'text-anchor': textAnchor,
      dy: dy
    }
  });
  if (title.text && title.automargin) {
    var titleObj = d3.selectAll('.gtitle');
    var titleHeight = Drawing.bBox(titleObj.node()).height;
    var pushMargin = needsMarginPush(gd, title, titleHeight);
    if (pushMargin > 0) {
      applyTitleAutoMargin(gd, y, pushMargin, titleHeight);
      // Re-position the title once we know where it needs to be
      titleObj.attr({
        x: x,
        y: y,
        'text-anchor': textAnchor,
        dy: getMainTitleDyAdj(title.yanchor)
      }).call(svgTextUtils.positionText, x, y);
      var extraLines = (title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;
      if (extraLines) {
        var delta = alignmentConstants.LINE_SPACING * extraLines + alignmentConstants.MID_SHIFT;
        if (title.y === 0) {
          delta = -delta;
        }
        titleObj.selectAll('.line').each(function () {
          var newDy = +this.getAttribute('dy').slice(0, -2) - delta + 'em';
          this.setAttribute('dy', newDy);
        });
      }
    }
  }
};
function isOutsideContainer(gd, title, position, y, titleHeight) {
  var plotHeight = title.yref === 'paper' ? gd._fullLayout._size.h : gd._fullLayout.height;
  var yPosTop = Lib.isTopAnchor(title) ? y : y - titleHeight; // Standardize to the top of the title
  var yPosRel = position === 'b' ? plotHeight - yPosTop : yPosTop; // Position relative to the top or bottom of plot
  if (Lib.isTopAnchor(title) && position === 't' || Lib.isBottomAnchor(title) && position === 'b') {
    return false;
  } else {
    return yPosRel < titleHeight;
  }
}
function containerPushVal(position, titleY, titleYanchor, height, titleDepth) {
  var push = 0;
  if (titleYanchor === 'middle') {
    push += titleDepth / 2;
  }
  if (position === 't') {
    if (titleYanchor === 'top') {
      push += titleDepth;
    }
    push += height - titleY * height;
  } else {
    if (titleYanchor === 'bottom') {
      push += titleDepth;
    }
    push += titleY * height;
  }
  return push;
}
function needsMarginPush(gd, title, titleHeight) {
  var titleY = title.y;
  var titleYanchor = title.yanchor;
  var position = titleY > 0.5 ? 't' : 'b';
  var curMargin = gd._fullLayout.margin[position];
  var pushMargin = 0;
  if (title.yref === 'paper') {
    pushMargin = titleHeight + title.pad.t + title.pad.b;
  } else if (title.yref === 'container') {
    pushMargin = containerPushVal(position, titleY, titleYanchor, gd._fullLayout.height, titleHeight) + title.pad.t + title.pad.b;
  }
  if (pushMargin > curMargin) {
    return pushMargin;
  }
  return 0;
}
function applyTitleAutoMargin(gd, y, pushMargin, titleHeight) {
  var titleID = 'title.automargin';
  var title = gd._fullLayout.title;
  var position = title.y > 0.5 ? 't' : 'b';
  var push = {
    x: title.x,
    y: title.y,
    t: 0,
    b: 0
  };
  var reservedPush = {};
  if (title.yref === 'paper' && isOutsideContainer(gd, title, position, y, titleHeight)) {
    push[position] = pushMargin;
  } else if (title.yref === 'container') {
    reservedPush[position] = pushMargin;
    gd._fullLayout._reservedMargin[titleID] = reservedPush;
  }
  Plots.allowAutoMargin(gd, titleID);
  Plots.autoMargin(gd, titleID, push);
}
function getMainTitleX(fullLayout, textAnchor) {
  var title = fullLayout.title;
  var gs = fullLayout._size;
  var hPadShift = 0;
  if (textAnchor === SVG_TEXT_ANCHOR_START) {
    hPadShift = title.pad.l;
  } else if (textAnchor === SVG_TEXT_ANCHOR_END) {
    hPadShift = -title.pad.r;
  }
  switch (title.xref) {
    case 'paper':
      return gs.l + gs.w * title.x + hPadShift;
    case 'container':
    default:
      return fullLayout.width * title.x + hPadShift;
  }
}
function getMainTitleY(fullLayout, dy) {
  var title = fullLayout.title;
  var gs = fullLayout._size;
  var vPadShift = 0;
  if (dy === '0em' || !dy) {
    vPadShift = -title.pad.b;
  } else if (dy === alignmentConstants.CAP_SHIFT + 'em') {
    vPadShift = title.pad.t;
  }
  if (title.y === 'auto') {
    return gs.t / 2;
  } else {
    switch (title.yref) {
      case 'paper':
        return gs.t + gs.h - gs.h * title.y + vPadShift;
      case 'container':
      default:
        return fullLayout.height - fullLayout.height * title.y + vPadShift;
    }
  }
}
function getMainTitleDyAdj(yanchor) {
  if (yanchor === 'top') {
    return alignmentConstants.CAP_SHIFT + 0.3 + 'em';
  } else if (yanchor === 'bottom') {
    return '-0.3em';
  } else {
    return alignmentConstants.MID_SHIFT + 'em';
  }
}
function getMainTitleTextAnchor(fullLayout) {
  var title = fullLayout.title;
  var textAnchor = SVG_TEXT_ANCHOR_MIDDLE;
  if (Lib.isRightAnchor(title)) {
    textAnchor = SVG_TEXT_ANCHOR_END;
  } else if (Lib.isLeftAnchor(title)) {
    textAnchor = SVG_TEXT_ANCHOR_START;
  }
  return textAnchor;
}
function getMainTitleDy(fullLayout) {
  var title = fullLayout.title;
  var dy = '0em';
  if (Lib.isTopAnchor(title)) {
    dy = alignmentConstants.CAP_SHIFT + 'em';
  } else if (Lib.isMiddleAnchor(title)) {
    dy = alignmentConstants.MID_SHIFT + 'em';
  }
  return dy;
}
exports.doTraceStyle = function (gd) {
  var calcdata = gd.calcdata;
  var editStyleCalls = [];
  var i;
  for (i = 0; i < calcdata.length; i++) {
    var cd = calcdata[i];
    var cd0 = cd[0] || {};
    var trace = cd0.trace || {};
    var _module = trace._module || {};

    // See if we need to do arraysToCalcdata
    // call it regardless of what change we made, in case
    // supplyDefaults brought in an array that was already
    // in gd.data but not in gd._fullData previously
    var arraysToCalcdata = _module.arraysToCalcdata;
    if (arraysToCalcdata) arraysToCalcdata(cd, trace);
    var editStyle = _module.editStyle;
    if (editStyle) editStyleCalls.push({
      fn: editStyle,
      cd0: cd0
    });
  }
  if (editStyleCalls.length) {
    for (i = 0; i < editStyleCalls.length; i++) {
      var edit = editStyleCalls[i];
      edit.fn(gd, edit.cd0);
    }
    clearGlCanvases(gd);
    exports.redrawReglTraces(gd);
  }
  Plots.style(gd);
  Registry.getComponentMethod('legend', 'draw')(gd);
  return Plots.previousPromises(gd);
};
exports.doColorBars = function (gd) {
  Registry.getComponentMethod('colorbar', 'draw')(gd);
  return Plots.previousPromises(gd);
};

// force plot() to redo the layout and replot with the modified layout
exports.layoutReplot = function (gd) {
  var layout = gd.layout;
  gd.layout = undefined;
  return Registry.call('_doPlot', gd, '', layout);
};
exports.doLegend = function (gd) {
  Registry.getComponentMethod('legend', 'draw')(gd);
  return Plots.previousPromises(gd);
};
exports.doTicksRelayout = function (gd) {
  Axes.draw(gd, 'redraw');
  if (gd._fullLayout._hasOnlyLargeSploms) {
    Registry.subplotsRegistry.splom.updateGrid(gd);
    clearGlCanvases(gd);
    exports.redrawReglTraces(gd);
  }
  exports.drawMainTitle(gd);
  return Plots.previousPromises(gd);
};
exports.doModeBar = function (gd) {
  var fullLayout = gd._fullLayout;
  ModeBar.manage(gd);
  for (var i = 0; i < fullLayout._basePlotModules.length; i++) {
    var updateFx = fullLayout._basePlotModules[i].updateFx;
    if (updateFx) updateFx(gd);
  }
  return Plots.previousPromises(gd);
};
exports.doCamera = function (gd) {
  var fullLayout = gd._fullLayout;
  var sceneIds = fullLayout._subplots.gl3d;
  for (var i = 0; i < sceneIds.length; i++) {
    var sceneLayout = fullLayout[sceneIds[i]];
    var scene = sceneLayout._scene;
    scene.setViewport(sceneLayout);
  }
};
exports.drawData = function (gd) {
  var fullLayout = gd._fullLayout;
  clearGlCanvases(gd);

  // loop over the base plot modules present on graph
  var basePlotModules = fullLayout._basePlotModules;
  for (var i = 0; i < basePlotModules.length; i++) {
    basePlotModules[i].plot(gd);
  }
  exports.redrawReglTraces(gd);

  // styling separate from drawing
  Plots.style(gd);

  // draw components that can be drawn on axes,
  // and that do not push the margins
  Registry.getComponentMethod('selections', 'draw')(gd);
  Registry.getComponentMethod('shapes', 'draw')(gd);
  Registry.getComponentMethod('annotations', 'draw')(gd);
  Registry.getComponentMethod('images', 'draw')(gd);

  // Mark the first render as complete
  fullLayout._replotting = false;
  return Plots.previousPromises(gd);
};

// Draw (or redraw) all regl-based traces in one go,
// useful during drag and selection where buffers of targeted traces are updated,
// but all traces need to be redrawn following clearGlCanvases.
//
// Note that _module.plot for regl trace does NOT draw things
// on the canvas, they only update the buffers.
// Drawing is perform here.
//
// TODO try adding per-subplot option using gl.SCISSOR_TEST for
// non-overlaying, disjoint subplots.
//
// TODO try to include parcoords in here.
// https://github.com/plotly/plotly.js/issues/3069
exports.redrawReglTraces = function (gd) {
  var fullLayout = gd._fullLayout;
  if (fullLayout._has('regl')) {
    var fullData = gd._fullData;
    var cartesianIds = [];
    var polarIds = [];
    var i, sp;
    if (fullLayout._hasOnlyLargeSploms) {
      fullLayout._splomGrid.draw();
    }

    // N.B.
    // - Loop over fullData (not _splomScenes) to preserve splom trace-to-trace ordering
    // - Fill list if subplot ids (instead of fullLayout._subplots) to handle cases where all traces
    //   of a given module are `visible !== true`
    for (i = 0; i < fullData.length; i++) {
      var trace = fullData[i];
      if (trace.visible === true && trace._length !== 0) {
        if (trace.type === 'splom') {
          fullLayout._splomScenes[trace.uid].draw();
        } else if (trace.type === 'scattergl') {
          Lib.pushUnique(cartesianIds, trace.xaxis + trace.yaxis);
        } else if (trace.type === 'scatterpolargl') {
          Lib.pushUnique(polarIds, trace.subplot);
        }
      }
    }
    for (i = 0; i < cartesianIds.length; i++) {
      sp = fullLayout._plots[cartesianIds[i]];
      if (sp._scene) sp._scene.draw();
    }
    for (i = 0; i < polarIds.length; i++) {
      sp = fullLayout[polarIds[i]]._subplot;
      if (sp._scene) sp._scene.draw();
    }
  }
};
exports.doAutoRangeAndConstraints = function (gd) {
  var axList = Axes.list(gd, '', true);
  var ax;
  var autoRangeDone = {};
  for (var i = 0; i < axList.length; i++) {
    ax = axList[i];
    if (!autoRangeDone[ax._id]) {
      autoRangeDone[ax._id] = 1;
      cleanAxisConstraints(gd, ax);
      doAutoRange(gd, ax);

      // For matching axes, just propagate this autorange to the group.
      // The extra arg to doAutoRange avoids recalculating the range,
      // since doAutoRange by itself accounts for all matching axes. but
      // there are other side-effects of doAutoRange that we still want.
      var matchGroup = ax._matchGroup;
      if (matchGroup) {
        for (var id2 in matchGroup) {
          var ax2 = Axes.getFromId(gd, id2);
          doAutoRange(gd, ax2, ax.range);
          autoRangeDone[id2] = 1;
        }
      }
    }
  }
  enforceAxisConstraints(gd);
};

// An initial paint must be completed before these components can be
// correctly sized and the whole plot re-margined. fullLayout._replotting must
// be set to false before these will work properly.
exports.finalDraw = function (gd) {
  // TODO: rangesliders really belong in marginPushers but they need to be
  // drawn after data - can we at least get the margin pushing part separated
  // out and done earlier?
  Registry.getComponentMethod('rangeslider', 'draw')(gd);
  // TODO: rangeselector only needs to be here (in addition to drawMarginPushers)
  // because the margins need to be fully determined before we can call
  // autorange and update axis ranges (which rangeselector needs to know which
  // button is active). Can we break out its automargin step from its draw step?
  Registry.getComponentMethod('rangeselector', 'draw')(gd);
};
exports.drawMarginPushers = function (gd) {
  Registry.getComponentMethod('legend', 'draw')(gd);
  Registry.getComponentMethod('rangeselector', 'draw')(gd);
  Registry.getComponentMethod('sliders', 'draw')(gd);
  Registry.getComponentMethod('updatemenus', 'draw')(gd);
  Registry.getComponentMethod('colorbar', 'draw')(gd);
};

/***/ }),

/***/ 6318:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var isPlainObject = Lib.isPlainObject;
var PlotSchema = __webpack_require__(6281);
var Plots = __webpack_require__(4875);
var plotAttributes = __webpack_require__(9012);
var Template = __webpack_require__(4467);
var dfltConfig = (__webpack_require__(2075).dfltConfig);

/**
 * Plotly.makeTemplate: create a template off an existing figure to reuse
 * style attributes on other figures.
 *
 * Note: separated from the rest of templates because otherwise we get circular
 * references due to PlotSchema.
 *
 * @param {object|DOM element|string} figure: The figure to base the template on
 *     should contain a trace array `figure.data`
 *     and a layout object `figure.layout`
 * @returns {object} template: the extracted template - can then be used as
 *     `layout.template` in another figure.
 */
exports.makeTemplate = function (figure) {
  figure = Lib.isPlainObject(figure) ? figure : Lib.getGraphDiv(figure);
  figure = Lib.extendDeep({
    _context: dfltConfig
  }, {
    data: figure.data,
    layout: figure.layout
  });
  Plots.supplyDefaults(figure);
  var data = figure.data || [];
  var layout = figure.layout || {};
  // copy over a few items to help follow the schema
  layout._basePlotModules = figure._fullLayout._basePlotModules;
  layout._modules = figure._fullLayout._modules;
  var template = {
    data: {},
    layout: {}
  };

  /*
   * Note: we do NOT validate template values, we just take what's in the
   * user inputs data and layout, not the validated values in fullData and
   * fullLayout. Even if we were to validate here, there's no guarantee that
   * these values would still be valid when applied to a new figure, which
   * may contain different trace modes, different axes, etc. So it's
   * important that when applying a template we still validate the template
   * values, rather than just using them as defaults.
   */

  data.forEach(function (trace) {
    // TODO: What if no style info is extracted for this trace. We may
    // not want an empty object as the null value.
    // TODO: allow transforms to contribute to templates?
    // as it stands they are ignored, which may be for the best...

    var traceTemplate = {};
    walkStyleKeys(trace, traceTemplate, getTraceInfo.bind(null, trace));
    var traceType = Lib.coerce(trace, {}, plotAttributes, 'type');
    var typeTemplates = template.data[traceType];
    if (!typeTemplates) typeTemplates = template.data[traceType] = [];
    typeTemplates.push(traceTemplate);
  });
  walkStyleKeys(layout, template.layout, getLayoutInfo.bind(null, layout));

  /*
   * Compose the new template with an existing one to the same effect
   *
   * NOTE: there's a possibility of slightly different behavior: if the plot
   * has an invalid value and the old template has a valid value for the same
   * attribute, the plot will use the old template value but this routine
   * will pull the invalid value (resulting in the original default).
   * In the general case it's not possible to solve this with a single value,
   * since valid options can be context-dependent. It could be solved with
   * a *list* of values, but that would be huge complexity for little gain.
   */
  delete template.layout.template;
  var oldTemplate = layout.template;
  if (isPlainObject(oldTemplate)) {
    var oldLayoutTemplate = oldTemplate.layout;
    var i, traceType, oldTypeTemplates, oldTypeLen, typeTemplates, typeLen;
    if (isPlainObject(oldLayoutTemplate)) {
      mergeTemplates(oldLayoutTemplate, template.layout);
    }
    var oldDataTemplate = oldTemplate.data;
    if (isPlainObject(oldDataTemplate)) {
      for (traceType in template.data) {
        oldTypeTemplates = oldDataTemplate[traceType];
        if (Array.isArray(oldTypeTemplates)) {
          typeTemplates = template.data[traceType];
          typeLen = typeTemplates.length;
          oldTypeLen = oldTypeTemplates.length;
          for (i = 0; i < typeLen; i++) {
            mergeTemplates(oldTypeTemplates[i % oldTypeLen], typeTemplates[i]);
          }
          for (i = typeLen; i < oldTypeLen; i++) {
            typeTemplates.push(Lib.extendDeep({}, oldTypeTemplates[i]));
          }
        }
      }
      for (traceType in oldDataTemplate) {
        if (!(traceType in template.data)) {
          template.data[traceType] = Lib.extendDeep([], oldDataTemplate[traceType]);
        }
      }
    }
  }
  return template;
};
function mergeTemplates(oldTemplate, newTemplate) {
  // we don't care about speed here, just make sure we have a totally
  // distinct object from the previous template
  oldTemplate = Lib.extendDeep({}, oldTemplate);

  // sort keys so we always get annotationdefaults before annotations etc
  // so arrayTemplater will work right
  var oldKeys = Object.keys(oldTemplate).sort();
  var i, j;
  function mergeOne(oldVal, newVal, key) {
    if (isPlainObject(newVal) && isPlainObject(oldVal)) {
      mergeTemplates(oldVal, newVal);
    } else if (Array.isArray(newVal) && Array.isArray(oldVal)) {
      // Note: omitted `inclusionAttr` from arrayTemplater here,
      // it's irrelevant as we only want the resulting `_template`.
      var templater = Template.arrayTemplater({
        _template: oldTemplate
      }, key);
      for (j = 0; j < newVal.length; j++) {
        var item = newVal[j];
        var oldItem = templater.newItem(item)._template;
        if (oldItem) mergeTemplates(oldItem, item);
      }
      var defaultItems = templater.defaultItems();
      for (j = 0; j < defaultItems.length; j++) newVal.push(defaultItems[j]._template);

      // templateitemname only applies to receiving plots
      for (j = 0; j < newVal.length; j++) delete newVal[j].templateitemname;
    }
  }
  for (i = 0; i < oldKeys.length; i++) {
    var key = oldKeys[i];
    var oldVal = oldTemplate[key];
    if (key in newTemplate) {
      mergeOne(oldVal, newTemplate[key], key);
    } else newTemplate[key] = oldVal;

    // if this is a base key from the old template (eg xaxis), look for
    // extended keys (eg xaxis2) in the new template to merge into
    if (getBaseKey(key) === key) {
      for (var key2 in newTemplate) {
        var baseKey2 = getBaseKey(key2);
        if (key2 !== baseKey2 && baseKey2 === key && !(key2 in oldTemplate)) {
          mergeOne(oldVal, newTemplate[key2], key);
        }
      }
    }
  }
}
function getBaseKey(key) {
  return key.replace(/[0-9]+$/, '');
}
function walkStyleKeys(parent, templateOut, getAttributeInfo, path, basePath) {
  var pathAttr = basePath && getAttributeInfo(basePath);
  for (var key in parent) {
    var child = parent[key];
    var nextPath = getNextPath(parent, key, path);
    var nextBasePath = getNextPath(parent, key, basePath);
    var attr = getAttributeInfo(nextBasePath);
    if (!attr) {
      var baseKey = getBaseKey(key);
      if (baseKey !== key) {
        nextBasePath = getNextPath(parent, baseKey, basePath);
        attr = getAttributeInfo(nextBasePath);
      }
    }

    // we'll get an attr if path starts with a valid part, then has an
    // invalid ending. Make sure we got all the way to the end.
    if (pathAttr && pathAttr === attr) continue;
    if (!attr || attr._noTemplating || attr.valType === 'data_array' || attr.arrayOk && Array.isArray(child)) {
      continue;
    }
    if (!attr.valType && isPlainObject(child)) {
      walkStyleKeys(child, templateOut, getAttributeInfo, nextPath, nextBasePath);
    } else if (attr._isLinkedToArray && Array.isArray(child)) {
      var dfltDone = false;
      var namedIndex = 0;
      var usedNames = {};
      for (var i = 0; i < child.length; i++) {
        var item = child[i];
        if (isPlainObject(item)) {
          var name = item.name;
          if (name) {
            if (!usedNames[name]) {
              // named array items: allow all attributes except data arrays
              walkStyleKeys(item, templateOut, getAttributeInfo, getNextPath(child, namedIndex, nextPath), getNextPath(child, namedIndex, nextBasePath));
              namedIndex++;
              usedNames[name] = 1;
            }
          } else if (!dfltDone) {
            var dfltKey = Template.arrayDefaultKey(key);
            var dfltPath = getNextPath(parent, dfltKey, path);

            // getAttributeInfo will fail if we try to use dfltKey directly.
            // Instead put this item into the next array element, then
            // pull it out and move it to dfltKey.
            var pathInArray = getNextPath(child, namedIndex, nextPath);
            walkStyleKeys(item, templateOut, getAttributeInfo, pathInArray, getNextPath(child, namedIndex, nextBasePath));
            var itemPropInArray = Lib.nestedProperty(templateOut, pathInArray);
            var dfltProp = Lib.nestedProperty(templateOut, dfltPath);
            dfltProp.set(itemPropInArray.get());
            itemPropInArray.set(null);
            dfltDone = true;
          }
        }
      }
    } else {
      var templateProp = Lib.nestedProperty(templateOut, nextPath);
      templateProp.set(child);
    }
  }
}
function getLayoutInfo(layout, path) {
  return PlotSchema.getLayoutValObject(layout, Lib.nestedProperty({}, path).parts);
}
function getTraceInfo(trace, path) {
  return PlotSchema.getTraceValObject(trace, Lib.nestedProperty({}, path).parts);
}
function getNextPath(parent, key, path) {
  var nextPath;
  if (!path) nextPath = key;else if (Array.isArray(parent)) nextPath = path + '[' + key + ']';else nextPath = path + '.' + key;
  return nextPath;
}

/**
 * validateTemplate: Test for consistency between the given figure and
 * a template, either already included in the figure or given separately.
 * Note that not every issue we identify here is necessarily a problem,
 * it depends on what you're using the template for.
 *
 * @param {object|DOM element} figure: the plot, with {data, layout} members,
 *     to test the template against
 * @param {Optional(object)} template: the template, with its own {data, layout},
 *     to test. If omitted, we will look for a template already attached as the
 *     plot's `layout.template` attribute.
 *
 * @returns {array} array of error objects each containing:
 *  - {string} code
 *      error code ('missing', 'unused', 'reused', 'noLayout', 'noData')
 *  - {string} msg
 *      a full readable description of the issue.
 */
exports.validateTemplate = function (figureIn, template) {
  var figure = Lib.extendDeep({}, {
    _context: dfltConfig,
    data: figureIn.data,
    layout: figureIn.layout
  });
  var layout = figure.layout || {};
  if (!isPlainObject(template)) template = layout.template || {};
  var layoutTemplate = template.layout;
  var dataTemplate = template.data;
  var errorList = [];
  figure.layout = layout;
  figure.layout.template = template;
  Plots.supplyDefaults(figure);
  var fullLayout = figure._fullLayout;
  var fullData = figure._fullData;
  var layoutPaths = {};
  function crawlLayoutForContainers(obj, paths) {
    for (var key in obj) {
      if (key.charAt(0) !== '_' && isPlainObject(obj[key])) {
        var baseKey = getBaseKey(key);
        var nextPaths = [];
        var i;
        for (i = 0; i < paths.length; i++) {
          nextPaths.push(getNextPath(obj, key, paths[i]));
          if (baseKey !== key) nextPaths.push(getNextPath(obj, baseKey, paths[i]));
        }
        for (i = 0; i < nextPaths.length; i++) {
          layoutPaths[nextPaths[i]] = 1;
        }
        crawlLayoutForContainers(obj[key], nextPaths);
      }
    }
  }
  function crawlLayoutTemplateForContainers(obj, path) {
    for (var key in obj) {
      if (key.indexOf('defaults') === -1 && isPlainObject(obj[key])) {
        var nextPath = getNextPath(obj, key, path);
        if (layoutPaths[nextPath]) {
          crawlLayoutTemplateForContainers(obj[key], nextPath);
        } else {
          errorList.push({
            code: 'unused',
            path: nextPath
          });
        }
      }
    }
  }
  if (!isPlainObject(layoutTemplate)) {
    errorList.push({
      code: 'layout'
    });
  } else {
    crawlLayoutForContainers(fullLayout, ['layout']);
    crawlLayoutTemplateForContainers(layoutTemplate, 'layout');
  }
  if (!isPlainObject(dataTemplate)) {
    errorList.push({
      code: 'data'
    });
  } else {
    var typeCount = {};
    var traceType;
    for (var i = 0; i < fullData.length; i++) {
      var fullTrace = fullData[i];
      traceType = fullTrace.type;
      typeCount[traceType] = (typeCount[traceType] || 0) + 1;
      if (!fullTrace._fullInput._template) {
        // this takes care of the case of traceType in the data but not
        // the template
        errorList.push({
          code: 'missing',
          index: fullTrace._fullInput.index,
          traceType: traceType
        });
      }
    }
    for (traceType in dataTemplate) {
      var templateCount = dataTemplate[traceType].length;
      var dataCount = typeCount[traceType] || 0;
      if (templateCount > dataCount) {
        errorList.push({
          code: 'unused',
          traceType: traceType,
          templateCount: templateCount,
          dataCount: dataCount
        });
      } else if (dataCount > templateCount) {
        errorList.push({
          code: 'reused',
          traceType: traceType,
          templateCount: templateCount,
          dataCount: dataCount
        });
      }
    }
  }

  // _template: false is when someone tried to modify an array item
  // but there was no template with matching name
  function crawlForMissingTemplates(obj, path) {
    for (var key in obj) {
      if (key.charAt(0) === '_') continue;
      var val = obj[key];
      var nextPath = getNextPath(obj, key, path);
      if (isPlainObject(val)) {
        if (Array.isArray(obj) && val._template === false && val.templateitemname) {
          errorList.push({
            code: 'missing',
            path: nextPath,
            templateitemname: val.templateitemname
          });
        }
        crawlForMissingTemplates(val, nextPath);
      } else if (Array.isArray(val) && hasPlainObject(val)) {
        crawlForMissingTemplates(val, nextPath);
      }
    }
  }
  crawlForMissingTemplates({
    data: fullData,
    layout: fullLayout
  }, '');
  if (errorList.length) return errorList.map(format);
};
function hasPlainObject(arr) {
  for (var i = 0; i < arr.length; i++) {
    if (isPlainObject(arr[i])) return true;
  }
}
function format(opts) {
  var msg;
  switch (opts.code) {
    case 'data':
      msg = 'The template has no key data.';
      break;
    case 'layout':
      msg = 'The template has no key layout.';
      break;
    case 'missing':
      if (opts.path) {
        msg = 'There are no templates for item ' + opts.path + ' with name ' + opts.templateitemname;
      } else {
        msg = 'There are no templates for trace ' + opts.index + ', of type ' + opts.traceType + '.';
      }
      break;
    case 'unused':
      if (opts.path) {
        msg = 'The template item at ' + opts.path + ' was not used in constructing the plot.';
      } else if (opts.dataCount) {
        msg = 'Some of the templates of type ' + opts.traceType + ' were not used. The template has ' + opts.templateCount + ' traces, the data only has ' + opts.dataCount + ' of this type.';
      } else {
        msg = 'The template has ' + opts.templateCount + ' traces of type ' + opts.traceType + ' but there are none in the data.';
      }
      break;
    case 'reused':
      msg = 'Some of the templates of type ' + opts.traceType + ' were used more than once. The template has ' + opts.templateCount + ' traces, the data has ' + opts.dataCount + ' of this type.';
      break;
  }
  opts.msg = msg;
  return opts;
}

/***/ }),

/***/ 403:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var plotApi = __webpack_require__(2391);
var plots = __webpack_require__(4875);
var Lib = __webpack_require__(1828);
var helpers = __webpack_require__(5095);
var toSVG = __webpack_require__(5900);
var svgToImg = __webpack_require__(942);
var version = (__webpack_require__(1506).version);
var attrs = {
  format: {
    valType: 'enumerated',
    values: ['png', 'jpeg', 'webp', 'svg', 'full-json'],
    dflt: 'png'
  },
  width: {
    valType: 'number',
    min: 1
  },
  height: {
    valType: 'number',
    min: 1
  },
  scale: {
    valType: 'number',
    min: 0,
    dflt: 1
  },
  setBackground: {
    valType: 'any',
    dflt: false
  },
  imageDataOnly: {
    valType: 'boolean',
    dflt: false
  }
};

/** Plotly.toImage
 *
 * @param {object | string | HTML div} gd
 *   can either be a data/layout/config object
 *   or an existing graph <div>
 *   or an id to an existing graph <div>
 * @param {object} opts (see above)
 * @return {promise}
 */
function toImage(gd, opts) {
  opts = opts || {};
  var data;
  var layout;
  var config;
  var fullLayout;
  if (Lib.isPlainObject(gd)) {
    data = gd.data || [];
    layout = gd.layout || {};
    config = gd.config || {};
    fullLayout = {};
  } else {
    gd = Lib.getGraphDiv(gd);
    data = Lib.extendDeep([], gd.data);
    layout = Lib.extendDeep({}, gd.layout);
    config = gd._context;
    fullLayout = gd._fullLayout || {};
  }
  function isImpliedOrValid(attr) {
    return !(attr in opts) || Lib.validate(opts[attr], attrs[attr]);
  }
  if (!isImpliedOrValid('width') && opts.width !== null || !isImpliedOrValid('height') && opts.height !== null) {
    throw new Error('Height and width should be pixel values.');
  }
  if (!isImpliedOrValid('format')) {
    throw new Error('Export format is not ' + Lib.join2(attrs.format.values, ', ', ' or ') + '.');
  }
  var fullOpts = {};
  function coerce(attr, dflt) {
    return Lib.coerce(opts, fullOpts, attrs, attr, dflt);
  }
  var format = coerce('format');
  var width = coerce('width');
  var height = coerce('height');
  var scale = coerce('scale');
  var setBackground = coerce('setBackground');
  var imageDataOnly = coerce('imageDataOnly');

  // put the cloned div somewhere off screen before attaching to DOM
  var clonedGd = document.createElement('div');
  clonedGd.style.position = 'absolute';
  clonedGd.style.left = '-5000px';
  document.body.appendChild(clonedGd);

  // extend layout with image options
  var layoutImage = Lib.extendFlat({}, layout);
  if (width) {
    layoutImage.width = width;
  } else if (opts.width === null && isNumeric(fullLayout.width)) {
    layoutImage.width = fullLayout.width;
  }
  if (height) {
    layoutImage.height = height;
  } else if (opts.height === null && isNumeric(fullLayout.height)) {
    layoutImage.height = fullLayout.height;
  }

  // extend config for static plot
  var configImage = Lib.extendFlat({}, config, {
    _exportedPlot: true,
    staticPlot: true,
    setBackground: setBackground
  });
  var redrawFunc = helpers.getRedrawFunc(clonedGd);
  function wait() {
    return new Promise(function (resolve) {
      setTimeout(resolve, helpers.getDelay(clonedGd._fullLayout));
    });
  }
  function convert() {
    return new Promise(function (resolve, reject) {
      var svg = toSVG(clonedGd, format, scale);
      var width = clonedGd._fullLayout.width;
      var height = clonedGd._fullLayout.height;
      function cleanup() {
        plotApi.purge(clonedGd);
        document.body.removeChild(clonedGd);
      }
      if (format === 'full-json') {
        var json = plots.graphJson(clonedGd, false, 'keepdata', 'object', true, true);
        json.version = version;
        json = JSON.stringify(json);
        cleanup();
        if (imageDataOnly) {
          return resolve(json);
        } else {
          return resolve(helpers.encodeJSON(json));
        }
      }
      cleanup();
      if (format === 'svg') {
        if (imageDataOnly) {
          return resolve(svg);
        } else {
          return resolve(helpers.encodeSVG(svg));
        }
      }
      var canvas = document.createElement('canvas');
      canvas.id = Lib.randstr();
      svgToImg({
        format: format,
        width: width,
        height: height,
        scale: scale,
        canvas: canvas,
        svg: svg,
        // ask svgToImg to return a Promise
        //  rather than EventEmitter
        //  leave EventEmitter for backward
        //  compatibility
        promise: true
      }).then(resolve).catch(reject);
    });
  }
  function urlToImageData(url) {
    if (imageDataOnly) {
      return url.replace(helpers.IMAGE_URL_PREFIX, '');
    } else {
      return url;
    }
  }
  return new Promise(function (resolve, reject) {
    plotApi.newPlot(clonedGd, data, layoutImage, configImage).then(redrawFunc).then(wait).then(convert).then(function (url) {
      resolve(urlToImageData(url));
    }).catch(function (err) {
      reject(err);
    });
  });
}
module.exports = toImage;

/***/ }),

/***/ 4936:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Plots = __webpack_require__(4875);
var PlotSchema = __webpack_require__(6281);
var dfltConfig = (__webpack_require__(2075).dfltConfig);
var isPlainObject = Lib.isPlainObject;
var isArray = Array.isArray;
var isArrayOrTypedArray = Lib.isArrayOrTypedArray;

/**
 * Validate a data array and layout object.
 *
 * @param {array} data
 * @param {object} layout
 *
 * @return {array} array of error objects each containing:
 *  - {string} code
 *      error code ('object', 'array', 'schema', 'unused', 'invisible' or 'value')
 *  - {string} container
 *      container where the error occurs ('data' or 'layout')
 *  - {number} trace
 *      trace index of the 'data' container where the error occurs
 *  - {array} path
 *      nested path to the key that causes the error
 *  - {string} astr
 *      attribute string variant of 'path' compatible with Plotly.restyle and
 *      Plotly.relayout.
 *  - {string} msg
 *      error message (shown in console in logger config argument is enable)
 */
module.exports = function validate(data, layout) {
  if (data === undefined) data = [];
  if (layout === undefined) layout = {};
  var schema = PlotSchema.get();
  var errorList = [];
  var gd = {
    _context: Lib.extendFlat({}, dfltConfig)
  };
  var dataIn, layoutIn;
  if (isArray(data)) {
    gd.data = Lib.extendDeep([], data);
    dataIn = data;
  } else {
    gd.data = [];
    dataIn = [];
    errorList.push(format('array', 'data'));
  }
  if (isPlainObject(layout)) {
    gd.layout = Lib.extendDeep({}, layout);
    layoutIn = layout;
  } else {
    gd.layout = {};
    layoutIn = {};
    if (arguments.length > 1) {
      errorList.push(format('object', 'layout'));
    }
  }

  // N.B. dataIn and layoutIn are in general not the same as
  // gd.data and gd.layout after supplyDefaults as some attributes
  // in gd.data and gd.layout (still) get mutated during this step.

  Plots.supplyDefaults(gd);
  var dataOut = gd._fullData;
  var len = dataIn.length;
  for (var i = 0; i < len; i++) {
    var traceIn = dataIn[i];
    var base = ['data', i];
    if (!isPlainObject(traceIn)) {
      errorList.push(format('object', base));
      continue;
    }
    var traceOut = dataOut[i];
    var traceType = traceOut.type;
    var traceSchema = schema.traces[traceType].attributes;

    // PlotSchema does something fancy with trace 'type', reset it here
    // to make the trace schema compatible with Lib.validate.
    traceSchema.type = {
      valType: 'enumerated',
      values: [traceType]
    };
    if (traceOut.visible === false && traceIn.visible !== false) {
      errorList.push(format('invisible', base));
    }
    crawl(traceIn, traceOut, traceSchema, errorList, base);
    var transformsIn = traceIn.transforms;
    var transformsOut = traceOut.transforms;
    if (transformsIn) {
      if (!isArray(transformsIn)) {
        errorList.push(format('array', base, ['transforms']));
      }
      base.push('transforms');
      for (var j = 0; j < transformsIn.length; j++) {
        var path = ['transforms', j];
        var transformType = transformsIn[j].type;
        if (!isPlainObject(transformsIn[j])) {
          errorList.push(format('object', base, path));
          continue;
        }
        var transformSchema = schema.transforms[transformType] ? schema.transforms[transformType].attributes : {};

        // add 'type' to transform schema to validate the transform type
        transformSchema.type = {
          valType: 'enumerated',
          values: Object.keys(schema.transforms)
        };
        crawl(transformsIn[j], transformsOut[j], transformSchema, errorList, base, path);
      }
    }
  }
  var layoutOut = gd._fullLayout;
  var layoutSchema = fillLayoutSchema(schema, dataOut);
  crawl(layoutIn, layoutOut, layoutSchema, errorList, 'layout');

  // return undefined if no validation errors were found
  return errorList.length === 0 ? void 0 : errorList;
};
function crawl(objIn, objOut, schema, list, base, path) {
  path = path || [];
  var keys = Object.keys(objIn);
  for (var i = 0; i < keys.length; i++) {
    var k = keys[i];

    // transforms are handled separately
    if (k === 'transforms') continue;
    var p = path.slice();
    p.push(k);
    var valIn = objIn[k];
    var valOut = objOut[k];
    var nestedSchema = getNestedSchema(schema, k);
    var nestedValType = (nestedSchema || {}).valType;
    var isInfoArray = nestedValType === 'info_array';
    var isColorscale = nestedValType === 'colorscale';
    var items = (nestedSchema || {}).items;
    if (!isInSchema(schema, k)) {
      list.push(format('schema', base, p));
    } else if (isPlainObject(valIn) && isPlainObject(valOut) && nestedValType !== 'any') {
      crawl(valIn, valOut, nestedSchema, list, base, p);
    } else if (isInfoArray && isArray(valIn)) {
      if (valIn.length > valOut.length) {
        list.push(format('unused', base, p.concat(valOut.length)));
      }
      var len = valOut.length;
      var arrayItems = Array.isArray(items);
      if (arrayItems) len = Math.min(len, items.length);
      var m, n, item, valInPart, valOutPart;
      if (nestedSchema.dimensions === 2) {
        for (n = 0; n < len; n++) {
          if (isArray(valIn[n])) {
            if (valIn[n].length > valOut[n].length) {
              list.push(format('unused', base, p.concat(n, valOut[n].length)));
            }
            var len2 = valOut[n].length;
            for (m = 0; m < (arrayItems ? Math.min(len2, items[n].length) : len2); m++) {
              item = arrayItems ? items[n][m] : items;
              valInPart = valIn[n][m];
              valOutPart = valOut[n][m];
              if (!Lib.validate(valInPart, item)) {
                list.push(format('value', base, p.concat(n, m), valInPart));
              } else if (valOutPart !== valInPart && valOutPart !== +valInPart) {
                list.push(format('dynamic', base, p.concat(n, m), valInPart, valOutPart));
              }
            }
          } else {
            list.push(format('array', base, p.concat(n), valIn[n]));
          }
        }
      } else {
        for (n = 0; n < len; n++) {
          item = arrayItems ? items[n] : items;
          valInPart = valIn[n];
          valOutPart = valOut[n];
          if (!Lib.validate(valInPart, item)) {
            list.push(format('value', base, p.concat(n), valInPart));
          } else if (valOutPart !== valInPart && valOutPart !== +valInPart) {
            list.push(format('dynamic', base, p.concat(n), valInPart, valOutPart));
          }
        }
      }
    } else if (nestedSchema.items && !isInfoArray && isArray(valIn)) {
      var _nestedSchema = items[Object.keys(items)[0]];
      var indexList = [];
      var j, _p;

      // loop over valOut items while keeping track of their
      // corresponding input container index (given by _index)
      for (j = 0; j < valOut.length; j++) {
        var _index = valOut[j]._index || j;
        _p = p.slice();
        _p.push(_index);
        if (isPlainObject(valIn[_index]) && isPlainObject(valOut[j])) {
          indexList.push(_index);
          var valInj = valIn[_index];
          var valOutj = valOut[j];
          if (isPlainObject(valInj) && valInj.visible !== false && valOutj.visible === false) {
            list.push(format('invisible', base, _p));
          } else crawl(valInj, valOutj, _nestedSchema, list, base, _p);
        }
      }

      // loop over valIn to determine where it went wrong for some items
      for (j = 0; j < valIn.length; j++) {
        _p = p.slice();
        _p.push(j);
        if (!isPlainObject(valIn[j])) {
          list.push(format('object', base, _p, valIn[j]));
        } else if (indexList.indexOf(j) === -1) {
          list.push(format('unused', base, _p));
        }
      }
    } else if (!isPlainObject(valIn) && isPlainObject(valOut)) {
      list.push(format('object', base, p, valIn));
    } else if (!isArrayOrTypedArray(valIn) && isArrayOrTypedArray(valOut) && !isInfoArray && !isColorscale) {
      list.push(format('array', base, p, valIn));
    } else if (!(k in objOut)) {
      list.push(format('unused', base, p, valIn));
    } else if (!Lib.validate(valIn, nestedSchema)) {
      list.push(format('value', base, p, valIn));
    } else if (nestedSchema.valType === 'enumerated' && (nestedSchema.coerceNumber && valIn !== +valOut || valIn !== valOut)) {
      list.push(format('dynamic', base, p, valIn, valOut));
    }
  }
  return list;
}

// the 'full' layout schema depends on the traces types presents
function fillLayoutSchema(schema, dataOut) {
  var layoutSchema = schema.layout.layoutAttributes;
  for (var i = 0; i < dataOut.length; i++) {
    var traceOut = dataOut[i];
    var traceSchema = schema.traces[traceOut.type];
    var traceLayoutAttr = traceSchema.layoutAttributes;
    if (traceLayoutAttr) {
      if (traceOut.subplot) {
        Lib.extendFlat(layoutSchema[traceSchema.attributes.subplot.dflt], traceLayoutAttr);
      } else {
        Lib.extendFlat(layoutSchema, traceLayoutAttr);
      }
    }
  }
  return layoutSchema;
}

// validation error codes
var code2msgFunc = {
  object: function (base, astr) {
    var prefix;
    if (base === 'layout' && astr === '') prefix = 'The layout argument';else if (base[0] === 'data' && astr === '') {
      prefix = 'Trace ' + base[1] + ' in the data argument';
    } else prefix = inBase(base) + 'key ' + astr;
    return prefix + ' must be linked to an object container';
  },
  array: function (base, astr) {
    var prefix;
    if (base === 'data') prefix = 'The data argument';else prefix = inBase(base) + 'key ' + astr;
    return prefix + ' must be linked to an array container';
  },
  schema: function (base, astr) {
    return inBase(base) + 'key ' + astr + ' is not part of the schema';
  },
  unused: function (base, astr, valIn) {
    var target = isPlainObject(valIn) ? 'container' : 'key';
    return inBase(base) + target + ' ' + astr + ' did not get coerced';
  },
  dynamic: function (base, astr, valIn, valOut) {
    return [inBase(base) + 'key', astr, '(set to \'' + valIn + '\')', 'got reset to', '\'' + valOut + '\'', 'during defaults.'].join(' ');
  },
  invisible: function (base, astr) {
    return (astr ? inBase(base) + 'item ' + astr : 'Trace ' + base[1]) + ' got defaulted to be not visible';
  },
  value: function (base, astr, valIn) {
    return [inBase(base) + 'key ' + astr, 'is set to an invalid value (' + valIn + ')'].join(' ');
  }
};
function inBase(base) {
  if (isArray(base)) return 'In data trace ' + base[1] + ', ';
  return 'In ' + base + ', ';
}
function format(code, base, path, valIn, valOut) {
  path = path || '';
  var container, trace;

  // container is either 'data' or 'layout
  // trace is the trace index if 'data', null otherwise

  if (isArray(base)) {
    container = base[0];
    trace = base[1];
  } else {
    container = base;
    trace = null;
  }
  var astr = convertPathToAttributeString(path);
  var msg = code2msgFunc[code](base, astr, valIn, valOut);

  // log to console if logger config option is enabled
  Lib.log(msg);
  return {
    code: code,
    container: container,
    trace: trace,
    path: path,
    astr: astr,
    msg: msg
  };
}
function isInSchema(schema, key) {
  var parts = splitKey(key);
  var keyMinusId = parts.keyMinusId;
  var id = parts.id;
  if (keyMinusId in schema && schema[keyMinusId]._isSubplotObj && id) {
    return true;
  }
  return key in schema;
}
function getNestedSchema(schema, key) {
  if (key in schema) return schema[key];
  var parts = splitKey(key);
  return schema[parts.keyMinusId];
}
var idRegex = Lib.counterRegex('([a-z]+)');
function splitKey(key) {
  var idMatch = key.match(idRegex);
  return {
    keyMinusId: idMatch && idMatch[1],
    id: idMatch && idMatch[2]
  };
}
function convertPathToAttributeString(path) {
  if (!isArray(path)) return String(path);
  var astr = '';
  for (var i = 0; i < path.length; i++) {
    var p = path[i];
    if (typeof p === 'number') {
      astr = astr.substr(0, astr.length - 1) + '[' + p + ']';
    } else {
      astr += p;
    }
    if (i < path.length - 1) astr += '.';
  }
  return astr;
}

/***/ }),

/***/ 5594:
/***/ (function(module) {

"use strict";


module.exports = {
  mode: {
    valType: 'enumerated',
    dflt: 'afterall',
    values: ['immediate', 'next', 'afterall']
  },
  direction: {
    valType: 'enumerated',
    values: ['forward', 'reverse'],
    dflt: 'forward'
  },
  fromcurrent: {
    valType: 'boolean',
    dflt: false
  },
  frame: {
    duration: {
      valType: 'number',
      min: 0,
      dflt: 500
    },
    redraw: {
      valType: 'boolean',
      dflt: true
    }
  },
  transition: {
    duration: {
      valType: 'number',
      min: 0,
      dflt: 500,
      editType: 'none'
    },
    easing: {
      valType: 'enumerated',
      dflt: 'cubic-in-out',
      values: ['linear', 'quad', 'cubic', 'sin', 'exp', 'circle', 'elastic', 'back', 'bounce', 'linear-in', 'quad-in', 'cubic-in', 'sin-in', 'exp-in', 'circle-in', 'elastic-in', 'back-in', 'bounce-in', 'linear-out', 'quad-out', 'cubic-out', 'sin-out', 'exp-out', 'circle-out', 'elastic-out', 'back-out', 'bounce-out', 'linear-in-out', 'quad-in-out', 'cubic-in-out', 'sin-in-out', 'exp-in-out', 'circle-in-out', 'elastic-in-out', 'back-in-out', 'bounce-in-out'],
      editType: 'none'
    },
    ordering: {
      valType: 'enumerated',
      values: ['layout first', 'traces first'],
      dflt: 'layout first',
      editType: 'none'
    }
  }
};

/***/ }),

/***/ 5501:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Template = __webpack_require__(4467);

/** Convenience wrapper for making array container logic DRY and consistent
 *
 * @param {object} parentObjIn
 *  user input object where the container in question is linked
 *  (i.e. either a user trace object or the user layout object)
 *
 * @param {object} parentObjOut
 *  full object where the coerced container will be linked
 *  (i.e. either a full trace object or the full layout object)
 *
 * @param {object} opts
 *  options object:
 *   - name {string}
 *      name of the key linking the container in question
 *   - inclusionAttr {string}
 *      name of the item attribute for inclusion/exclusion. Default is 'visible'.
 *      Since inclusion is true, use eg 'enabled' instead of 'disabled'.
 *   - handleItemDefaults {function}
 *      defaults method to be called on each item in the array container in question
 *
 *      Its arguments are:
 *          - itemIn {object} item in user layout
 *          - itemOut {object} item in full layout
 *          - parentObj {object} (as in closure)
 *          - opts {object} (as in closure)
 * N.B.
 *
 *  - opts is passed to handleItemDefaults so it can also store
 *    links to supplementary data (e.g. fullData for layout components)
 *
 */
module.exports = function handleArrayContainerDefaults(parentObjIn, parentObjOut, opts) {
  var name = opts.name;
  var inclusionAttr = opts.inclusionAttr || 'visible';
  var previousContOut = parentObjOut[name];
  var contIn = Lib.isArrayOrTypedArray(parentObjIn[name]) ? parentObjIn[name] : [];
  var contOut = parentObjOut[name] = [];
  var templater = Template.arrayTemplater(parentObjOut, name, inclusionAttr);
  var i, itemOut;
  for (i = 0; i < contIn.length; i++) {
    var itemIn = contIn[i];
    if (!Lib.isPlainObject(itemIn)) {
      itemOut = templater.newItem({});
      itemOut[inclusionAttr] = false;
    } else {
      itemOut = templater.newItem(itemIn);
    }
    itemOut._index = i;
    if (itemOut[inclusionAttr] !== false) {
      opts.handleItemDefaults(itemIn, itemOut, parentObjOut, opts);
    }
    contOut.push(itemOut);
  }
  var defaultItems = templater.defaultItems();
  for (i = 0; i < defaultItems.length; i++) {
    itemOut = defaultItems[i];
    itemOut._index = contOut.length;
    opts.handleItemDefaults({}, itemOut, parentObjOut, opts, {});
    contOut.push(itemOut);
  }

  // in case this array gets its defaults rebuilt independent of the whole layout,
  // relink the private keys just for this array.
  if (Lib.isArrayOrTypedArray(previousContOut)) {
    var len = Math.min(previousContOut.length, contOut.length);
    for (i = 0; i < len; i++) {
      Lib.relinkPrivateKeys(contOut[i], previousContOut[i]);
    }
  }
  return contOut;
};

/***/ }),

/***/ 9012:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var fontAttrs = __webpack_require__(1940);
var fxAttrs = __webpack_require__(7914);
module.exports = {
  type: {
    valType: 'enumerated',
    values: [],
    // listed dynamically
    dflt: 'scatter',
    editType: 'calc+clearAxisTypes',
    _noTemplating: true // we handle this at a higher level
  },

  visible: {
    valType: 'enumerated',
    values: [true, false, 'legendonly'],
    dflt: true,
    editType: 'calc'
  },
  showlegend: {
    valType: 'boolean',
    dflt: true,
    editType: 'style'
  },
  legend: {
    valType: 'subplotid',
    dflt: 'legend',
    editType: 'style'
  },
  legendgroup: {
    valType: 'string',
    dflt: '',
    editType: 'style'
  },
  legendgrouptitle: {
    text: {
      valType: 'string',
      dflt: '',
      editType: 'style'
    },
    font: fontAttrs({
      editType: 'style'
    }),
    editType: 'style'
  },
  legendrank: {
    valType: 'number',
    dflt: 1000,
    editType: 'style'
  },
  legendwidth: {
    valType: 'number',
    min: 0,
    editType: 'style'
  },
  opacity: {
    valType: 'number',
    min: 0,
    max: 1,
    dflt: 1,
    editType: 'style'
  },
  name: {
    valType: 'string',
    editType: 'style'
  },
  uid: {
    valType: 'string',
    editType: 'plot',
    anim: true
  },
  ids: {
    valType: 'data_array',
    editType: 'calc',
    anim: true
  },
  customdata: {
    valType: 'data_array',
    editType: 'calc'
  },
  meta: {
    valType: 'any',
    arrayOk: true,
    editType: 'plot'
  },
  // N.B. these cannot be 'data_array' as they do not have the same length as
  // other data arrays and arrayOk attributes in general
  //
  // Maybe add another valType:
  // https://github.com/plotly/plotly.js/issues/1894
  selectedpoints: {
    valType: 'any',
    editType: 'calc'
  },
  hoverinfo: {
    valType: 'flaglist',
    flags: ['x', 'y', 'z', 'text', 'name'],
    extras: ['all', 'none', 'skip'],
    arrayOk: true,
    dflt: 'all',
    editType: 'none'
  },
  hoverlabel: fxAttrs.hoverlabel,
  stream: {
    token: {
      valType: 'string',
      noBlank: true,
      strict: true,
      editType: 'calc'
    },
    maxpoints: {
      valType: 'number',
      min: 0,
      max: 10000,
      dflt: 500,
      editType: 'calc'
    },
    editType: 'calc'
  },
  transforms: {
    _isLinkedToArray: 'transform',
    editType: 'calc'
  },
  uirevision: {
    valType: 'any',
    editType: 'none'
  }
};

/***/ }),

/***/ 2973:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var Lib = __webpack_require__(1828);
var dateTime2ms = Lib.dateTime2ms;
var incrementMonth = Lib.incrementMonth;
var constants = __webpack_require__(606);
var ONEAVGMONTH = constants.ONEAVGMONTH;
module.exports = function alignPeriod(trace, ax, axLetter, vals) {
  if (ax.type !== 'date') return {
    vals: vals
  };
  var alignment = trace[axLetter + 'periodalignment'];
  if (!alignment) return {
    vals: vals
  };
  var period = trace[axLetter + 'period'];
  var mPeriod;
  if (isNumeric(period)) {
    period = +period;
    if (period <= 0) return {
      vals: vals
    };
  } else if (typeof period === 'string' && period.charAt(0) === 'M') {
    var n = +period.substring(1);
    if (n > 0 && Math.round(n) === n) {
      mPeriod = n;
    } else return {
      vals: vals
    };
  }
  var calendar = ax.calendar;
  var isStart = 'start' === alignment;
  // var isMiddle = 'middle' === alignment;
  var isEnd = 'end' === alignment;
  var period0 = trace[axLetter + 'period0'];
  var base = dateTime2ms(period0, calendar) || 0;
  var newVals = [];
  var starts = [];
  var ends = [];
  var len = vals.length;
  for (var i = 0; i < len; i++) {
    var v = vals[i];
    var nEstimated, startTime, endTime;
    if (mPeriod) {
      // guess at how many periods away from base we are
      nEstimated = Math.round((v - base) / (mPeriod * ONEAVGMONTH));
      endTime = incrementMonth(base, mPeriod * nEstimated, calendar);

      // iterate to get the exact bounds before and after v
      // there may be ways to make this faster, but most of the time
      // we'll only execute each loop zero or one time.
      while (endTime > v) {
        endTime = incrementMonth(endTime, -mPeriod, calendar);
      }
      while (endTime <= v) {
        endTime = incrementMonth(endTime, mPeriod, calendar);
      }

      // now we know endTime is the boundary immediately after v
      // so startTime is obtained by incrementing backward one period.
      startTime = incrementMonth(endTime, -mPeriod, calendar);
    } else {
      // case of ms
      nEstimated = Math.round((v - base) / period);
      endTime = base + nEstimated * period;
      while (endTime > v) {
        endTime -= period;
      }
      while (endTime <= v) {
        endTime += period;
      }
      startTime = endTime - period;
    }
    newVals[i] = isStart ? startTime : isEnd ? endTime : (startTime + endTime) / 2;
    starts[i] = startTime;
    ends[i] = endTime;
  }
  return {
    vals: newVals,
    starts: starts,
    ends: ends
  };
};

/***/ }),

/***/ 9502:
/***/ (function(module) {

"use strict";


module.exports = {
  xaxis: {
    valType: 'subplotid',
    dflt: 'x',
    editType: 'calc+clearAxisTypes'
  },
  yaxis: {
    valType: 'subplotid',
    dflt: 'y',
    editType: 'calc+clearAxisTypes'
  }
};

/***/ }),

/***/ 1739:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var isNumeric = __webpack_require__(2770);
var Lib = __webpack_require__(1828);
var FP_SAFE = (__webpack_require__(606).FP_SAFE);
var Registry = __webpack_require__(3972);
var Drawing = __webpack_require__(1424);
var axIds = __webpack_require__(1675);
var getFromId = axIds.getFromId;
var isLinked = axIds.isLinked;
module.exports = {
  applyAutorangeOptions: applyAutorangeOptions,
  getAutoRange: getAutoRange,
  makePadFn: makePadFn,
  doAutoRange: doAutoRange,
  findExtremes: findExtremes,
  concatExtremes: concatExtremes
};

/**
 * getAutoRange
 *
 * Collects all _extremes values corresponding to a given axis
 * and computes its auto range.
 *
 * Note that getAutoRange uses return values from findExtremes.
 *
 * @param {object} gd:
 *   graph div object with filled-in fullData and fullLayout, in particular
 *   with filled-in '_extremes' containers:
 *   {
 *      val: calcdata value,
 *      pad: extra pixels beyond this value,
 *      extrapad: bool, does this point want 5% extra padding
 *   }
 * @param {object} ax:
 *   full axis object, in particular with filled-in '_traceIndices'
 *   and '_annIndices' / '_shapeIndices' if applicable
 * @return {array}
 *   an array of [min, max]. These are calcdata for log and category axes
 *   and data for linear and date axes.
 *
 * TODO: we want to change log to data as well, but it's hard to do this
 * maintaining backward compatibility. category will always have to use calcdata
 * though, because otherwise values between categories (or outside all categories)
 * would be impossible.
 */
function getAutoRange(gd, ax) {
  var i, j;
  var newRange = [];
  var fullLayout = gd._fullLayout;
  var getPadMin = makePadFn(fullLayout, ax, 0);
  var getPadMax = makePadFn(fullLayout, ax, 1);
  var extremes = concatExtremes(gd, ax);
  var minArray = extremes.min;
  var maxArray = extremes.max;
  if (minArray.length === 0 || maxArray.length === 0) {
    return Lib.simpleMap(ax.range, ax.r2l);
  }
  var minmin = minArray[0].val;
  var maxmax = maxArray[0].val;
  for (i = 1; i < minArray.length; i++) {
    if (minmin !== maxmax) break;
    minmin = Math.min(minmin, minArray[i].val);
  }
  for (i = 1; i < maxArray.length; i++) {
    if (minmin !== maxmax) break;
    maxmax = Math.max(maxmax, maxArray[i].val);
  }
  var autorange = ax.autorange;
  var axReverse = autorange === 'reversed' || autorange === 'min reversed' || autorange === 'max reversed';
  if (!axReverse && ax.range) {
    var rng = Lib.simpleMap(ax.range, ax.r2l);
    axReverse = rng[1] < rng[0];
  }

  // one-time setting to easily reverse the axis
  // when plotting from code
  if (ax.autorange === 'reversed') {
    ax.autorange = true;
  }
  var rangeMode = ax.rangemode;
  var toZero = rangeMode === 'tozero';
  var nonNegative = rangeMode === 'nonnegative';
  var axLen = ax._length;
  // don't allow padding to reduce the data to < 10% of the length
  var minSpan = axLen / 10;
  var mbest = 0;
  var minpt, maxpt, minbest, maxbest, dp, dv;
  for (i = 0; i < minArray.length; i++) {
    minpt = minArray[i];
    for (j = 0; j < maxArray.length; j++) {
      maxpt = maxArray[j];
      dv = maxpt.val - minpt.val - calcBreaksLength(ax, minpt.val, maxpt.val);
      if (dv > 0) {
        dp = axLen - getPadMin(minpt) - getPadMax(maxpt);
        if (dp > minSpan) {
          if (dv / dp > mbest) {
            minbest = minpt;
            maxbest = maxpt;
            mbest = dv / dp;
          }
        } else if (dv / axLen > mbest) {
          // in case of padding longer than the axis
          // at least include the unpadded data values.
          minbest = {
            val: minpt.val,
            nopad: 1
          };
          maxbest = {
            val: maxpt.val,
            nopad: 1
          };
          mbest = dv / axLen;
        }
      }
    }
  }
  function maximumPad(prev, pt) {
    return Math.max(prev, getPadMax(pt));
  }
  if (minmin === maxmax) {
    var lower = minmin - 1;
    var upper = minmin + 1;
    if (toZero) {
      if (minmin === 0) {
        // The only value we have on this axis is 0, and we want to
        // autorange so zero is one end.
        // In principle this could be [0, 1] or [-1, 0] but usually
        // 'tozero' pins 0 to the low end, so follow that.
        newRange = [0, 1];
      } else {
        var maxPad = (minmin > 0 ? maxArray : minArray).reduce(maximumPad, 0);
        // we're pushing a single value away from the edge due to its
        // padding, with the other end clamped at zero
        // 0.5 means don't push it farther than the center.
        var rangeEnd = minmin / (1 - Math.min(0.5, maxPad / axLen));
        newRange = minmin > 0 ? [0, rangeEnd] : [rangeEnd, 0];
      }
    } else if (nonNegative) {
      newRange = [Math.max(0, lower), Math.max(1, upper)];
    } else {
      newRange = [lower, upper];
    }
  } else {
    if (toZero) {
      if (minbest.val >= 0) {
        minbest = {
          val: 0,
          nopad: 1
        };
      }
      if (maxbest.val <= 0) {
        maxbest = {
          val: 0,
          nopad: 1
        };
      }
    } else if (nonNegative) {
      if (minbest.val - mbest * getPadMin(minbest) < 0) {
        minbest = {
          val: 0,
          nopad: 1
        };
      }
      if (maxbest.val <= 0) {
        maxbest = {
          val: 1,
          nopad: 1
        };
      }
    }

    // in case it changed again...
    mbest = (maxbest.val - minbest.val - calcBreaksLength(ax, minpt.val, maxpt.val)) / (axLen - getPadMin(minbest) - getPadMax(maxbest));
    newRange = [minbest.val - mbest * getPadMin(minbest), maxbest.val + mbest * getPadMax(maxbest)];
  }
  newRange = applyAutorangeOptions(newRange, ax);
  if (ax.limitRange) ax.limitRange();

  // maintain reversal
  if (axReverse) newRange.reverse();
  return Lib.simpleMap(newRange, ax.l2r || Number);
}

// find axis rangebreaks in [v0,v1] and compute its length in value space
function calcBreaksLength(ax, v0, v1) {
  var lBreaks = 0;
  if (ax.rangebreaks) {
    var rangebreaksOut = ax.locateBreaks(v0, v1);
    for (var i = 0; i < rangebreaksOut.length; i++) {
      var brk = rangebreaksOut[i];
      lBreaks += brk.max - brk.min;
    }
  }
  return lBreaks;
}

/*
 * calculate the pixel padding for ax._min and ax._max entries with
 * optional extrapad as 5% of the total axis length
 */
function makePadFn(fullLayout, ax, max) {
  // 5% padding for points that specify extrapad: true
  var extrappad = 0.05 * ax._length;
  var anchorAxis = ax._anchorAxis || {};
  if ((ax.ticklabelposition || '').indexOf('inside') !== -1 || (anchorAxis.ticklabelposition || '').indexOf('inside') !== -1) {
    var axReverse = ax.isReversed();
    if (!axReverse) {
      var rng = Lib.simpleMap(ax.range, ax.r2l);
      axReverse = rng[1] < rng[0];
    }
    if (axReverse) max = !max;
  }
  var zero = 0;
  if (!isLinked(fullLayout, ax._id)) {
    zero = padInsideLabelsOnAnchorAxis(fullLayout, ax, max);
  }
  extrappad = Math.max(zero, extrappad);

  // domain-constrained axes: base extrappad on the unconstrained
  // domain so it's consistent as the domain changes
  if (ax.constrain === 'domain' && ax._inputDomain) {
    extrappad *= (ax._inputDomain[1] - ax._inputDomain[0]) / (ax.domain[1] - ax.domain[0]);
  }
  return function getPad(pt) {
    if (pt.nopad) return 0;
    return pt.pad + (pt.extrapad ? extrappad : zero);
  };
}
var TEXTPAD = 3;
function padInsideLabelsOnAnchorAxis(fullLayout, ax, max) {
  var pad = 0;
  var isX = ax._id.charAt(0) === 'x';
  for (var subplot in fullLayout._plots) {
    var plotinfo = fullLayout._plots[subplot];
    if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;
    var anchorAxis = (isX ? plotinfo.yaxis : plotinfo.xaxis) || {};
    if ((anchorAxis.ticklabelposition || '').indexOf('inside') !== -1) {
      // increase padding to make more room for inside tick labels of the counter axis
      if (!max && (anchorAxis.side === 'left' || anchorAxis.side === 'bottom') || max && (anchorAxis.side === 'top' || anchorAxis.side === 'right')) {
        if (anchorAxis._vals) {
          var rad = Lib.deg2rad(anchorAxis._tickAngles[anchorAxis._id + 'tick'] || 0);
          var cosA = Math.abs(Math.cos(rad));
          var sinA = Math.abs(Math.sin(rad));

          // no stashed bounding boxes - stash bounding boxes
          if (!anchorAxis._vals[0].bb) {
            var cls = anchorAxis._id + 'tick';
            var tickLabels = anchorAxis._selections[cls];
            tickLabels.each(function (d) {
              var thisLabel = d3.select(this);
              var mathjaxGroup = thisLabel.select('.text-math-group');
              if (mathjaxGroup.empty()) {
                d.bb = Drawing.bBox(thisLabel.node());
              }
            });
          }

          // use bounding boxes
          for (var i = 0; i < anchorAxis._vals.length; i++) {
            var t = anchorAxis._vals[i];
            var bb = t.bb;
            if (bb) {
              var w = 2 * TEXTPAD + bb.width;
              var h = 2 * TEXTPAD + bb.height;
              pad = Math.max(pad, isX ? Math.max(w * cosA, h * sinA) : Math.max(h * cosA, w * sinA));
            }
          }
        }
        if (anchorAxis.ticks === 'inside' && anchorAxis.ticklabelposition === 'inside') {
          pad += anchorAxis.ticklen || 0;
        }
      }
    }
  }
  return pad;
}
function concatExtremes(gd, ax, noMatch) {
  var axId = ax._id;
  var fullData = gd._fullData;
  var fullLayout = gd._fullLayout;
  var minArray = [];
  var maxArray = [];
  var i, j, d;
  function _concat(cont, indices) {
    for (i = 0; i < indices.length; i++) {
      var item = cont[indices[i]];
      var extremes = (item._extremes || {})[axId];
      if (item.visible === true && extremes) {
        for (j = 0; j < extremes.min.length; j++) {
          d = extremes.min[j];
          collapseMinArray(minArray, d.val, d.pad, {
            extrapad: d.extrapad
          });
        }
        for (j = 0; j < extremes.max.length; j++) {
          d = extremes.max[j];
          collapseMaxArray(maxArray, d.val, d.pad, {
            extrapad: d.extrapad
          });
        }
      }
    }
  }
  _concat(fullData, ax._traceIndices);
  _concat(fullLayout.annotations || [], ax._annIndices || []);
  _concat(fullLayout.shapes || [], ax._shapeIndices || []);

  // Include the extremes from other matched axes with this one
  if (ax._matchGroup && !noMatch) {
    for (var axId2 in ax._matchGroup) {
      if (axId2 !== ax._id) {
        var ax2 = getFromId(gd, axId2);
        var extremes2 = concatExtremes(gd, ax2, true);
        // convert padding on the second axis to the first with lenRatio
        var lenRatio = ax._length / ax2._length;
        for (j = 0; j < extremes2.min.length; j++) {
          d = extremes2.min[j];
          collapseMinArray(minArray, d.val, d.pad * lenRatio, {
            extrapad: d.extrapad
          });
        }
        for (j = 0; j < extremes2.max.length; j++) {
          d = extremes2.max[j];
          collapseMaxArray(maxArray, d.val, d.pad * lenRatio, {
            extrapad: d.extrapad
          });
        }
      }
    }
  }
  return {
    min: minArray,
    max: maxArray
  };
}
function doAutoRange(gd, ax, presetRange) {
  ax.setScale();
  if (ax.autorange) {
    ax.range = presetRange ? presetRange.slice() : getAutoRange(gd, ax);
    ax._r = ax.range.slice();
    ax._rl = Lib.simpleMap(ax._r, ax.r2l);

    // doAutoRange will get called on fullLayout,
    // but we want to report its results back to layout

    var axIn = ax._input;

    // before we edit _input, store preGUI values
    var edits = {};
    edits[ax._attr + '.range'] = ax.range;
    edits[ax._attr + '.autorange'] = ax.autorange;
    Registry.call('_storeDirectGUIEdit', gd.layout, gd._fullLayout._preGUI, edits);
    axIn.range = ax.range.slice();
    axIn.autorange = ax.autorange;
  }
  var anchorAx = ax._anchorAxis;
  if (anchorAx && anchorAx.rangeslider) {
    var axeRangeOpts = anchorAx.rangeslider[ax._name];
    if (axeRangeOpts) {
      if (axeRangeOpts.rangemode === 'auto') {
        axeRangeOpts.range = getAutoRange(gd, ax);
      }
    }
    anchorAx._input.rangeslider[ax._name] = Lib.extendFlat({}, axeRangeOpts);
  }
}

/**
 * findExtremes
 *
 * Find min/max extremes of an array of coordinates on a given axis.
 *
 * Note that findExtremes is called during `calc`, when we don't yet know the axis
 * length; all the inputs should be based solely on the trace data, nothing
 * about the axis layout.
 *
 * Note that `ppad` and `vpad` as well as their asymmetric variants refer to
 * the before and after padding of the passed `data` array, not to the whole axis.
 *
 * @param {object} ax: full axis object
 *   relies on
 *   - ax.type
 *   - ax._m (just its sign)
 *   - ax.d2l
 * @param {array} data:
 *  array of numbers (i.e. already run though ax.d2c)
 * @param {object} opts:
 *  available keys are:
 *      vpad: (number or number array) pad values (data value +-vpad)
 *      ppad: (number or number array) pad pixels (pixel location +-ppad)
 *      ppadplus, ppadminus, vpadplus, vpadminus:
 *          separate padding for each side, overrides symmetric
 *      padded: (boolean) add 5% padding to both ends
 *          (unless one end is overridden by tozero)
 *      tozero: (boolean) make sure to include zero if axis is linear,
 *          and make it a tight bound if possible
 *      vpadLinearized: (boolean) whether or not vpad (or vpadplus/vpadminus)
 *          is linearized (for log scale axes)
 *
 * @return {object}
 *  - min {array of objects}
 *  - max {array of objects}
 *  each object item has fields:
 *    - val {number}
 *    - pad {number}
 *    - extrappad {number}
 *  - opts {object}: a ref to the passed "options" object
 */
function findExtremes(ax, data, opts) {
  if (!opts) opts = {};
  if (!ax._m) ax.setScale();
  var minArray = [];
  var maxArray = [];
  var len = data.length;
  var extrapad = opts.padded || false;
  var tozero = opts.tozero && (ax.type === 'linear' || ax.type === '-');
  var isLog = ax.type === 'log';
  var hasArrayOption = false;
  var vpadLinearized = opts.vpadLinearized || false;
  var i, v, di, dmin, dmax, ppadiplus, ppadiminus, vmin, vmax;
  function makePadAccessor(item) {
    if (Array.isArray(item)) {
      hasArrayOption = true;
      return function (i) {
        return Math.max(Number(item[i] || 0), 0);
      };
    } else {
      var v = Math.max(Number(item || 0), 0);
      return function () {
        return v;
      };
    }
  }
  var ppadplus = makePadAccessor((ax._m > 0 ? opts.ppadplus : opts.ppadminus) || opts.ppad || 0);
  var ppadminus = makePadAccessor((ax._m > 0 ? opts.ppadminus : opts.ppadplus) || opts.ppad || 0);
  var vpadplus = makePadAccessor(opts.vpadplus || opts.vpad);
  var vpadminus = makePadAccessor(opts.vpadminus || opts.vpad);
  if (!hasArrayOption) {
    // with no arrays other than `data` we don't need to consider
    // every point, only the extreme data points
    vmin = Infinity;
    vmax = -Infinity;
    if (isLog) {
      for (i = 0; i < len; i++) {
        v = data[i];
        // data is not linearized yet so we still have to filter out negative logs
        if (v < vmin && v > 0) vmin = v;
        if (v > vmax && v < FP_SAFE) vmax = v;
      }
    } else {
      for (i = 0; i < len; i++) {
        v = data[i];
        if (v < vmin && v > -FP_SAFE) vmin = v;
        if (v > vmax && v < FP_SAFE) vmax = v;
      }
    }
    data = [vmin, vmax];
    len = 2;
  }
  var collapseOpts = {
    tozero: tozero,
    extrapad: extrapad
  };
  function addItem(i) {
    di = data[i];
    if (!isNumeric(di)) return;
    ppadiplus = ppadplus(i);
    ppadiminus = ppadminus(i);
    if (vpadLinearized) {
      dmin = ax.c2l(di) - vpadminus(i);
      dmax = ax.c2l(di) + vpadplus(i);
    } else {
      vmin = di - vpadminus(i);
      vmax = di + vpadplus(i);
      // special case for log axes: if vpad makes this object span
      // more than an order of mag, clip it to one order. This is so
      // we don't have non-positive errors or absurdly large lower
      // range due to rounding errors
      if (isLog && vmin < vmax / 10) vmin = vmax / 10;
      dmin = ax.c2l(vmin);
      dmax = ax.c2l(vmax);
    }
    if (tozero) {
      dmin = Math.min(0, dmin);
      dmax = Math.max(0, dmax);
    }
    if (goodNumber(dmin)) {
      collapseMinArray(minArray, dmin, ppadiminus, collapseOpts);
    }
    if (goodNumber(dmax)) {
      collapseMaxArray(maxArray, dmax, ppadiplus, collapseOpts);
    }
  }

  // For efficiency covering monotonic or near-monotonic data,
  // check a few points at both ends first and then sweep
  // through the middle
  var iMax = Math.min(6, len);
  for (i = 0; i < iMax; i++) addItem(i);
  for (i = len - 1; i >= iMax; i--) addItem(i);
  return {
    min: minArray,
    max: maxArray,
    opts: opts
  };
}
function collapseMinArray(array, newVal, newPad, opts) {
  collapseArray(array, newVal, newPad, opts, lessOrEqual);
}
function collapseMaxArray(array, newVal, newPad, opts) {
  collapseArray(array, newVal, newPad, opts, greaterOrEqual);
}

/**
 * collapseArray
 *
 * Takes items from 'array' and compares them to 'newVal', 'newPad'.
 *
 * @param {array} array:
 *  current set of min or max extremes
 * @param {number} newVal:
 *  new value to compare against
 * @param {number} newPad:
 *  pad value associated with 'newVal'
 * @param {object} opts:
 *  - tozero {boolean}
 *  - extrapad {number}
 * @param {function} atLeastAsExtreme:
 *  comparison function, use
 *  - lessOrEqual for min 'array' and
 *  - greaterOrEqual for max 'array'
 *
 * In practice, 'array' is either
 *  - 'extremes[ax._id].min' or
 *  - 'extremes[ax._id].max
 *  found in traces and layout items that affect autorange.
 *
 * Since we don't yet know the relationship between pixels and values
 * (that's what we're trying to figure out!) AND we don't yet know how
 * many pixels `extrapad` represents (it's going to be 5% of the length,
 * but we don't want to have to redo calc just because length changed)
 * two point must satisfy three criteria simultaneously for one to supersede the other:
 *  - at least as extreme a `val`
 *  - at least as big a `pad`
 *  - an unpadded point cannot supersede a padded point, but any other combination can
 *
 * Then:
 * - If the item supersedes the new point, set includeThis false
 * - If the new pt supersedes the item, delete it from 'array'
 */
function collapseArray(array, newVal, newPad, opts, atLeastAsExtreme) {
  var tozero = opts.tozero;
  var extrapad = opts.extrapad;
  var includeThis = true;
  for (var j = 0; j < array.length && includeThis; j++) {
    var v = array[j];
    if (atLeastAsExtreme(v.val, newVal) && v.pad >= newPad && (v.extrapad || !extrapad)) {
      includeThis = false;
      break;
    } else if (atLeastAsExtreme(newVal, v.val) && v.pad <= newPad && (extrapad || !v.extrapad)) {
      array.splice(j, 1);
      j--;
    }
  }
  if (includeThis) {
    var clipAtZero = tozero && newVal === 0;
    array.push({
      val: newVal,
      pad: clipAtZero ? 0 : newPad,
      extrapad: clipAtZero ? false : extrapad
    });
  }
}

// In order to stop overflow errors, don't consider points
// too close to the limits of js floating point
function goodNumber(v) {
  return isNumeric(v) && Math.abs(v) < FP_SAFE;
}
function lessOrEqual(v0, v1) {
  return v0 <= v1;
}
function greaterOrEqual(v0, v1) {
  return v0 >= v1;
}
function applyAutorangeMinOptions(v, ax) {
  var autorangeoptions = ax.autorangeoptions;
  if (autorangeoptions && autorangeoptions.minallowed !== undefined && hasValidMinAndMax(ax, autorangeoptions.minallowed, autorangeoptions.maxallowed)) {
    return autorangeoptions.minallowed;
  }
  if (autorangeoptions && autorangeoptions.clipmin !== undefined && hasValidMinAndMax(ax, autorangeoptions.clipmin, autorangeoptions.clipmax)) {
    return Math.max(v, ax.d2l(autorangeoptions.clipmin));
  }
  return v;
}
function applyAutorangeMaxOptions(v, ax) {
  var autorangeoptions = ax.autorangeoptions;
  if (autorangeoptions && autorangeoptions.maxallowed !== undefined && hasValidMinAndMax(ax, autorangeoptions.minallowed, autorangeoptions.maxallowed)) {
    return autorangeoptions.maxallowed;
  }
  if (autorangeoptions && autorangeoptions.clipmax !== undefined && hasValidMinAndMax(ax, autorangeoptions.clipmin, autorangeoptions.clipmax)) {
    return Math.min(v, ax.d2l(autorangeoptions.clipmax));
  }
  return v;
}
function hasValidMinAndMax(ax, min, max) {
  // in case both min and max are defined, ensure min < max
  if (min !== undefined && max !== undefined) {
    min = ax.d2l(min);
    max = ax.d2l(max);
    return min < max;
  }
  return true;
}

// this function should be (and is) called before reversing the range
// so range[0] is the minimum and range[1] is the maximum
function applyAutorangeOptions(range, ax) {
  if (!ax || !ax.autorangeoptions) return range;
  var min = range[0];
  var max = range[1];
  var include = ax.autorangeoptions.include;
  if (include !== undefined) {
    var lMin = ax.d2l(min);
    var lMax = ax.d2l(max);
    if (!Lib.isArrayOrTypedArray(include)) include = [include];
    for (var i = 0; i < include.length; i++) {
      var v = ax.d2l(include[i]);
      if (lMin >= v) {
        lMin = v;
        min = v;
      }
      if (lMax <= v) {
        lMax = v;
        max = v;
      }
    }
  }
  min = applyAutorangeMinOptions(min, ax);
  max = applyAutorangeMaxOptions(max, ax);
  return [min, max];
}

/***/ }),

/***/ 3074:
/***/ (function(module) {

"use strict";


module.exports = function handleAutorangeOptionsDefaults(coerce, autorange, range) {
  var minRange, maxRange;
  if (range) {
    var isReversed = autorange === 'reversed' || autorange === 'min reversed' || autorange === 'max reversed';
    minRange = range[isReversed ? 1 : 0];
    maxRange = range[isReversed ? 0 : 1];
  }
  var minallowed = coerce('autorangeoptions.minallowed', maxRange === null ? minRange : undefined);
  var maxallowed = coerce('autorangeoptions.maxallowed', minRange === null ? maxRange : undefined);
  if (minallowed === undefined) coerce('autorangeoptions.clipmin');
  if (maxallowed === undefined) coerce('autorangeoptions.clipmax');
  coerce('autorangeoptions.include');
};

/***/ }),

/***/ 9298:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var isNumeric = __webpack_require__(2770);
var Plots = __webpack_require__(4875);
var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var strTranslate = Lib.strTranslate;
var svgTextUtils = __webpack_require__(3893);
var Titles = __webpack_require__(2998);
var Color = __webpack_require__(7901);
var Drawing = __webpack_require__(1424);
var axAttrs = __webpack_require__(3838);
var cleanTicks = __webpack_require__(6287);
var constants = __webpack_require__(606);
var ONEMAXYEAR = constants.ONEMAXYEAR;
var ONEAVGYEAR = constants.ONEAVGYEAR;
var ONEMINYEAR = constants.ONEMINYEAR;
var ONEMAXQUARTER = constants.ONEMAXQUARTER;
var ONEAVGQUARTER = constants.ONEAVGQUARTER;
var ONEMINQUARTER = constants.ONEMINQUARTER;
var ONEMAXMONTH = constants.ONEMAXMONTH;
var ONEAVGMONTH = constants.ONEAVGMONTH;
var ONEMINMONTH = constants.ONEMINMONTH;
var ONEWEEK = constants.ONEWEEK;
var ONEDAY = constants.ONEDAY;
var HALFDAY = ONEDAY / 2;
var ONEHOUR = constants.ONEHOUR;
var ONEMIN = constants.ONEMIN;
var ONESEC = constants.ONESEC;
var MINUS_SIGN = constants.MINUS_SIGN;
var BADNUM = constants.BADNUM;
var ZERO_PATH = {
  K: 'zeroline'
};
var GRID_PATH = {
  K: 'gridline',
  L: 'path'
};
var MINORGRID_PATH = {
  K: 'minor-gridline',
  L: 'path'
};
var TICK_PATH = {
  K: 'tick',
  L: 'path'
};
var TICK_TEXT = {
  K: 'tick',
  L: 'text'
};
var MARGIN_MAPPING = {
  width: ['x', 'r', 'l', 'xl', 'xr'],
  height: ['y', 't', 'b', 'yt', 'yb'],
  right: ['r', 'xr'],
  left: ['l', 'xl'],
  top: ['t', 'yt'],
  bottom: ['b', 'yb']
};
var alignmentConstants = __webpack_require__(8783);
var MID_SHIFT = alignmentConstants.MID_SHIFT;
var CAP_SHIFT = alignmentConstants.CAP_SHIFT;
var LINE_SPACING = alignmentConstants.LINE_SPACING;
var OPPOSITE_SIDE = alignmentConstants.OPPOSITE_SIDE;
var TEXTPAD = 3;
var axes = module.exports = {};
axes.setConvert = __webpack_require__(1994);
var autoType = __webpack_require__(4322);
var axisIds = __webpack_require__(1675);
var idSort = axisIds.idSort;
var isLinked = axisIds.isLinked;

// tight coupling to chart studio
axes.id2name = axisIds.id2name;
axes.name2id = axisIds.name2id;
axes.cleanId = axisIds.cleanId;
axes.list = axisIds.list;
axes.listIds = axisIds.listIds;
axes.getFromId = axisIds.getFromId;
axes.getFromTrace = axisIds.getFromTrace;
var autorange = __webpack_require__(1739);
axes.getAutoRange = autorange.getAutoRange;
axes.findExtremes = autorange.findExtremes;
var epsilon = 0.0001;
function expandRange(range) {
  var delta = (range[1] - range[0]) * epsilon;
  return [range[0] - delta, range[1] + delta];
}

/*
 * find the list of possible axes to reference with an xref or yref attribute
 * and coerce it to that list
 *
 * attr: the attribute we're generating a reference for. Should end in 'x' or 'y'
 *     but can be prefixed, like 'ax' for annotation's arrow x
 * dflt: the default to coerce to, or blank to use the first axis (falling back on
 *     extraOption if there is no axis)
 * extraOption: aside from existing axes with this letter, what non-axis value is allowed?
 *     Only required if it's different from `dflt`
 */
axes.coerceRef = function (containerIn, containerOut, gd, attr, dflt, extraOption) {
  var axLetter = attr.charAt(attr.length - 1);
  var axlist = gd._fullLayout._subplots[axLetter + 'axis'];
  var refAttr = attr + 'ref';
  var attrDef = {};
  if (!dflt) dflt = axlist[0] || (typeof extraOption === 'string' ? extraOption : extraOption[0]);
  if (!extraOption) extraOption = dflt;
  axlist = axlist.concat(axlist.map(function (x) {
    return x + ' domain';
  }));

  // data-ref annotations are not supported in gl2d yet

  attrDef[refAttr] = {
    valType: 'enumerated',
    values: axlist.concat(extraOption ? typeof extraOption === 'string' ? [extraOption] : extraOption : []),
    dflt: dflt
  };

  // xref, yref
  return Lib.coerce(containerIn, containerOut, attrDef, refAttr);
};

/*
 * Get the type of an axis reference. This can be 'range', 'domain', or 'paper'.
 * This assumes ar is a valid axis reference and returns 'range' if it doesn't
 * match the patterns for 'paper' or 'domain'.
 *
 * ar: the axis reference string
 *
 */
axes.getRefType = function (ar) {
  if (ar === undefined) {
    return ar;
  }
  if (ar === 'paper') {
    return 'paper';
  }
  if (ar === 'pixel') {
    return 'pixel';
  }
  if (/( domain)$/.test(ar)) {
    return 'domain';
  } else {
    return 'range';
  }
};

/*
 * coerce position attributes (range-type) that can be either on axes or absolute
 * (paper or pixel) referenced. The biggest complication here is that we don't know
 * before looking at the axis whether the value must be a number or not (it may be
 * a date string), so we can't use the regular valType='number' machinery
 *
 * axRef (string): the axis this position is referenced to, or:
 *     paper: fraction of the plot area
 *     pixel: pixels relative to some starting position
 * attr (string): the attribute in containerOut we are coercing
 * dflt (number): the default position, as a fraction or pixels. If the attribute
 *     is to be axis-referenced, this will be converted to an axis data value
 *
 * Also cleans the values, since the attribute definition itself has to say
 * valType: 'any' to handle date axes. This allows us to accept:
 * - for category axes: category names, and convert them here into serial numbers.
 *   Note that this will NOT work for axis range endpoints, because we don't know
 *   the category list yet (it's set by ax.makeCalcdata during calc)
 *   but it works for component (note, shape, images) positions.
 * - for date axes: JS Dates or milliseconds, and convert to date strings
 * - for other types: coerce them to numbers
 */
axes.coercePosition = function (containerOut, gd, coerce, axRef, attr, dflt) {
  var cleanPos, pos;
  var axRefType = axes.getRefType(axRef);
  if (axRefType !== 'range') {
    cleanPos = Lib.ensureNumber;
    pos = coerce(attr, dflt);
  } else {
    var ax = axes.getFromId(gd, axRef);
    dflt = ax.fraction2r(dflt);
    pos = coerce(attr, dflt);
    cleanPos = ax.cleanPos;
  }
  containerOut[attr] = cleanPos(pos);
};
axes.cleanPosition = function (pos, gd, axRef) {
  var cleanPos = axRef === 'paper' || axRef === 'pixel' ? Lib.ensureNumber : axes.getFromId(gd, axRef).cleanPos;
  return cleanPos(pos);
};
axes.redrawComponents = function (gd, axIds) {
  axIds = axIds ? axIds : axes.listIds(gd);
  var fullLayout = gd._fullLayout;
  function _redrawOneComp(moduleName, methodName, stashName, shortCircuit) {
    var method = Registry.getComponentMethod(moduleName, methodName);
    var stash = {};
    for (var i = 0; i < axIds.length; i++) {
      var ax = fullLayout[axes.id2name(axIds[i])];
      var indices = ax[stashName];
      for (var j = 0; j < indices.length; j++) {
        var ind = indices[j];
        if (!stash[ind]) {
          method(gd, ind);
          stash[ind] = 1;
          // once is enough for images (which doesn't use the `i` arg anyway)
          if (shortCircuit) return;
        }
      }
    }
  }

  // annotations and shapes 'draw' method is slow,
  // use the finer-grained 'drawOne' method instead
  _redrawOneComp('annotations', 'drawOne', '_annIndices');
  _redrawOneComp('shapes', 'drawOne', '_shapeIndices');
  _redrawOneComp('images', 'draw', '_imgIndices', true);
  _redrawOneComp('selections', 'drawOne', '_selectionIndices');
};
var getDataConversions = axes.getDataConversions = function (gd, trace, target, targetArray) {
  var ax;

  // If target points to an axis, use the type we already have for that
  // axis to find the data type. Otherwise use the values to autotype.
  var d2cTarget = target === 'x' || target === 'y' || target === 'z' ? target : targetArray;

  // In the case of an array target, make a mock data array
  // and call supplyDefaults to the data type and
  // setup the data-to-calc method.
  if (Array.isArray(d2cTarget)) {
    ax = {
      type: autoType(targetArray, undefined, {
        autotypenumbers: gd._fullLayout.autotypenumbers
      }),
      _categories: []
    };
    axes.setConvert(ax);

    // build up ax._categories (usually done during ax.makeCalcdata()
    if (ax.type === 'category') {
      for (var i = 0; i < targetArray.length; i++) {
        ax.d2c(targetArray[i]);
      }
    }
    // TODO what to do for transforms?
  } else {
    ax = axes.getFromTrace(gd, trace, d2cTarget);
  }

  // if 'target' has corresponding axis
  // -> use setConvert method
  if (ax) return {
    d2c: ax.d2c,
    c2d: ax.c2d
  };

  // special case for 'ids'
  // -> cast to String
  if (d2cTarget === 'ids') return {
    d2c: toString,
    c2d: toString
  };

  // otherwise (e.g. numeric-array of 'marker.color' or 'marker.size')
  // -> cast to Number

  return {
    d2c: toNum,
    c2d: toNum
  };
};
function toNum(v) {
  return +v;
}
function toString(v) {
  return String(v);
}
axes.getDataToCoordFunc = function (gd, trace, target, targetArray) {
  return getDataConversions(gd, trace, target, targetArray).d2c;
};

// get counteraxis letter for this axis (name or id)
// this can also be used as the id for default counter axis
axes.counterLetter = function (id) {
  var axLetter = id.charAt(0);
  if (axLetter === 'x') return 'y';
  if (axLetter === 'y') return 'x';
};

// incorporate a new minimum difference and first tick into
// forced
// note that _forceTick0 is linearized, so needs to be turned into
// a range value for setting tick0
axes.minDtick = function (ax, newDiff, newFirst, allow) {
  // doesn't make sense to do forced min dTick on log or category axes,
  // and the plot itself may decide to cancel (ie non-grouped bars)
  if (['log', 'category', 'multicategory'].indexOf(ax.type) !== -1 || !allow) {
    ax._minDtick = 0;
  } else if (ax._minDtick === undefined) {
    // undefined means there's nothing there yet

    ax._minDtick = newDiff;
    ax._forceTick0 = newFirst;
  } else if (ax._minDtick) {
    if ((ax._minDtick / newDiff + 1e-6) % 1 < 2e-6 &&
    // existing minDtick is an integer multiple of newDiff
    // (within rounding err)
    // and forceTick0 can be shifted to newFirst

    ((newFirst - ax._forceTick0) / newDiff % 1 + 1.000001) % 1 < 2e-6) {
      ax._minDtick = newDiff;
      ax._forceTick0 = newFirst;
    } else if ((newDiff / ax._minDtick + 1e-6) % 1 > 2e-6 ||
    // if the converse is true (newDiff is a multiple of minDtick and
    // newFirst can be shifted to forceTick0) then do nothing - same
    // forcing stands. Otherwise, cancel forced minimum

    ((newFirst - ax._forceTick0) / ax._minDtick % 1 + 1.000001) % 1 > 2e-6) {
      ax._minDtick = 0;
    }
  }
};

// save a copy of the initial axis ranges in fullLayout
// use them in mode bar and dblclick events
axes.saveRangeInitial = function (gd, overwrite) {
  var axList = axes.list(gd, '', true);
  var hasOneAxisChanged = false;
  for (var i = 0; i < axList.length; i++) {
    var ax = axList[i];
    var isNew = ax._rangeInitial0 === undefined && ax._rangeInitial1 === undefined;
    var hasChanged = isNew || ax.range[0] !== ax._rangeInitial0 || ax.range[1] !== ax._rangeInitial1;
    var autorange = ax.autorange;
    if (isNew && autorange !== true || overwrite && hasChanged) {
      ax._rangeInitial0 = autorange === 'min' || autorange === 'max reversed' ? undefined : ax.range[0];
      ax._rangeInitial1 = autorange === 'max' || autorange === 'min reversed' ? undefined : ax.range[1];
      ax._autorangeInitial = autorange;
      hasOneAxisChanged = true;
    }
  }
  return hasOneAxisChanged;
};

// save a copy of the initial spike visibility
axes.saveShowSpikeInitial = function (gd, overwrite) {
  var axList = axes.list(gd, '', true);
  var hasOneAxisChanged = false;
  var allSpikesEnabled = 'on';
  for (var i = 0; i < axList.length; i++) {
    var ax = axList[i];
    var isNew = ax._showSpikeInitial === undefined;
    var hasChanged = isNew || !(ax.showspikes === ax._showspikes);
    if (isNew || overwrite && hasChanged) {
      ax._showSpikeInitial = ax.showspikes;
      hasOneAxisChanged = true;
    }
    if (allSpikesEnabled === 'on' && !ax.showspikes) {
      allSpikesEnabled = 'off';
    }
  }
  gd._fullLayout._cartesianSpikesEnabled = allSpikesEnabled;
  return hasOneAxisChanged;
};
axes.autoBin = function (data, ax, nbins, is2d, calendar, size) {
  var dataMin = Lib.aggNums(Math.min, null, data);
  var dataMax = Lib.aggNums(Math.max, null, data);
  if (ax.type === 'category' || ax.type === 'multicategory') {
    return {
      start: dataMin - 0.5,
      end: dataMax + 0.5,
      size: Math.max(1, Math.round(size) || 1),
      _dataSpan: dataMax - dataMin
    };
  }
  if (!calendar) calendar = ax.calendar;

  // piggyback off tick code to make "nice" bin sizes and edges
  var dummyAx;
  if (ax.type === 'log') {
    dummyAx = {
      type: 'linear',
      range: [dataMin, dataMax]
    };
  } else {
    dummyAx = {
      type: ax.type,
      range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),
      calendar: calendar
    };
  }
  axes.setConvert(dummyAx);
  size = size && cleanTicks.dtick(size, dummyAx.type);
  if (size) {
    dummyAx.dtick = size;
    dummyAx.tick0 = cleanTicks.tick0(undefined, dummyAx.type, calendar);
  } else {
    var size0;
    if (nbins) size0 = (dataMax - dataMin) / nbins;else {
      // totally auto: scale off std deviation so the highest bin is
      // somewhat taller than the total number of bins, but don't let
      // the size get smaller than the 'nice' rounded down minimum
      // difference between values
      var distinctData = Lib.distinctVals(data);
      var msexp = Math.pow(10, Math.floor(Math.log(distinctData.minDiff) / Math.LN10));
      var minSize = msexp * Lib.roundUp(distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);
      size0 = Math.max(minSize, 2 * Lib.stdev(data) / Math.pow(data.length, is2d ? 0.25 : 0.4));

      // fallback if ax.d2c output BADNUMs
      // e.g. when user try to plot categorical bins
      // on a layout.xaxis.type: 'linear'
      if (!isNumeric(size0)) size0 = 1;
    }
    axes.autoTicks(dummyAx, size0);
  }
  var finalSize = dummyAx.dtick;
  var binStart = axes.tickIncrement(axes.tickFirst(dummyAx), finalSize, 'reverse', calendar);
  var binEnd, bincount;

  // check for too many data points right at the edges of bins
  // (>50% within 1% of bin edges) or all data points integral
  // and offset the bins accordingly
  if (typeof finalSize === 'number') {
    binStart = autoShiftNumericBins(binStart, data, dummyAx, dataMin, dataMax);
    bincount = 1 + Math.floor((dataMax - binStart) / finalSize);
    binEnd = binStart + bincount * finalSize;
  } else {
    // month ticks - should be the only nonlinear kind we have at this point.
    // dtick (as supplied by axes.autoTick) only has nonlinear values on
    // date and log axes, but even if you display a histogram on a log axis
    // we bin it on a linear axis (which one could argue against, but that's
    // a separate issue)
    if (dummyAx.dtick.charAt(0) === 'M') {
      binStart = autoShiftMonthBins(binStart, data, finalSize, dataMin, calendar);
    }

    // calculate the endpoint for nonlinear ticks - you have to
    // just increment until you're done
    binEnd = binStart;
    bincount = 0;
    while (binEnd <= dataMax) {
      binEnd = axes.tickIncrement(binEnd, finalSize, false, calendar);
      bincount++;
    }
  }
  return {
    start: ax.c2r(binStart, 0, calendar),
    end: ax.c2r(binEnd, 0, calendar),
    size: finalSize,
    _dataSpan: dataMax - dataMin
  };
};
function autoShiftNumericBins(binStart, data, ax, dataMin, dataMax) {
  var edgecount = 0;
  var midcount = 0;
  var intcount = 0;
  var blankCount = 0;
  function nearEdge(v) {
    // is a value within 1% of a bin edge?
    return (1 + (v - binStart) * 100 / ax.dtick) % 100 < 2;
  }
  for (var i = 0; i < data.length; i++) {
    if (data[i] % 1 === 0) intcount++;else if (!isNumeric(data[i])) blankCount++;
    if (nearEdge(data[i])) edgecount++;
    if (nearEdge(data[i] + ax.dtick / 2)) midcount++;
  }
  var dataCount = data.length - blankCount;
  if (intcount === dataCount && ax.type !== 'date') {
    if (ax.dtick < 1) {
      // all integers: if bin size is <1, it's because
      // that was specifically requested (large nbins)
      // so respect that... but center the bins containing
      // integers on those integers

      binStart = dataMin - 0.5 * ax.dtick;
    } else {
      // otherwise start half an integer down regardless of
      // the bin size, just enough to clear up endpoint
      // ambiguity about which integers are in which bins.

      binStart -= 0.5;
      if (binStart + ax.dtick < dataMin) binStart += ax.dtick;
    }
  } else if (midcount < dataCount * 0.1) {
    if (edgecount > dataCount * 0.3 || nearEdge(dataMin) || nearEdge(dataMax)) {
      // lots of points at the edge, not many in the middle
      // shift half a bin
      var binshift = ax.dtick / 2;
      binStart += binStart + binshift < dataMin ? binshift : -binshift;
    }
  }
  return binStart;
}
function autoShiftMonthBins(binStart, data, dtick, dataMin, calendar) {
  var stats = Lib.findExactDates(data, calendar);
  // number of data points that needs to be an exact value
  // to shift that increment to (near) the bin center
  var threshold = 0.8;
  if (stats.exactDays > threshold) {
    var numMonths = Number(dtick.substr(1));
    if (stats.exactYears > threshold && numMonths % 12 === 0) {
      // The exact middle of a non-leap-year is 1.5 days into July
      // so if we start the bins here, all but leap years will
      // get hover-labeled as exact years.
      binStart = axes.tickIncrement(binStart, 'M6', 'reverse') + ONEDAY * 1.5;
    } else if (stats.exactMonths > threshold) {
      // Months are not as clean, but if we shift half the *longest*
      // month (31/2 days) then 31-day months will get labeled exactly
      // and shorter months will get labeled with the correct month
      // but shifted 12-36 hours into it.
      binStart = axes.tickIncrement(binStart, 'M1', 'reverse') + ONEDAY * 15.5;
    } else {
      // Shifting half a day is exact, but since these are month bins it
      // will always give a somewhat odd-looking label, until we do something
      // smarter like showing the bin boundaries (or the bounds of the actual
      // data in each bin)
      binStart -= HALFDAY;
    }
    var nextBinStart = axes.tickIncrement(binStart, dtick);
    if (nextBinStart <= dataMin) return nextBinStart;
  }
  return binStart;
}

// ----------------------------------------------------
// Ticks and grids
// ----------------------------------------------------

// ensure we have minor tick0 and dtick calculated
axes.prepMinorTicks = function (mockAx, ax, opts) {
  if (!ax.minor.dtick) {
    delete mockAx.dtick;
    var hasMajor = ax.dtick && isNumeric(ax._tmin);
    var mockMinorRange;
    if (hasMajor) {
      var tick2 = axes.tickIncrement(ax._tmin, ax.dtick, true);
      // mock range a tiny bit smaller than one major tick interval
      mockMinorRange = [ax._tmin, tick2 * 0.99 + ax._tmin * 0.01];
    } else {
      var rl = Lib.simpleMap(ax.range, ax.r2l);
      // If we don't have a major dtick, the concept of minor ticks is a little
      // ambiguous - just take a stab and say minor.nticks should span 1/5 the axis
      mockMinorRange = [rl[0], 0.8 * rl[0] + 0.2 * rl[1]];
    }
    mockAx.range = Lib.simpleMap(mockMinorRange, ax.l2r);
    mockAx._isMinor = true;
    axes.prepTicks(mockAx, opts);
    if (hasMajor) {
      var numericMajor = isNumeric(ax.dtick);
      var numericMinor = isNumeric(mockAx.dtick);
      var majorNum = numericMajor ? ax.dtick : +ax.dtick.substring(1);
      var minorNum = numericMinor ? mockAx.dtick : +mockAx.dtick.substring(1);
      if (numericMajor && numericMinor) {
        if (!isMultiple(majorNum, minorNum)) {
          // give up on minor ticks - outside the below exceptions,
          // this can only happen if minor.nticks is smaller than two jumps
          // in the auto-tick scale and the first jump is not an even multiple
          // (5 -> 2 or for dates 3 ->2, 15 -> 10 etc)  or if you provided
          // an explicit dtick, in which case it's fine to give up,
          // you can provide an explicit minor.dtick.
          if (majorNum === 2 * ONEWEEK && minorNum === 3 * ONEDAY) {
            mockAx.dtick = ONEWEEK;
          } else if (majorNum === ONEWEEK && !(ax._input.minor || {}).nticks) {
            // minor.nticks defaults to 5, but in this one case we want 7,
            // so the minor ticks show on all days of the week
            mockAx.dtick = ONEDAY;
          } else if (isClose(majorNum / minorNum, 2.5)) {
            // 5*10^n -> 2*10^n and you've set nticks < 5
            // quarters are pretty common, we don't do this by default as it
            // would add an extra digit to display, but minor has no labels
            mockAx.dtick = majorNum / 2;
          } else {
            mockAx.dtick = majorNum;
          }
        } else if (majorNum === 2 * ONEWEEK && minorNum === 2 * ONEDAY) {
          // this is a weird one: we don't want to automatically choose
          // 2-day minor ticks for 2-week major, even though it IS an even multiple,
          // because people would expect to see the weeks clearly
          mockAx.dtick = ONEWEEK;
        }
      } else if (String(ax.dtick).charAt(0) === 'M') {
        if (numericMinor) {
          mockAx.dtick = 'M1';
        } else {
          if (!isMultiple(majorNum, minorNum)) {
            // unless you provided an explicit ax.dtick (in which case
            // it's OK for us to give up, you can provide an explicit
            // minor.dtick too), this can only happen with:
            // minor.nticks < 3 and dtick === M3, or
            // minor.nticks < 5 and dtick === 5 * 10^n years
            // so in all cases we just give up.
            mockAx.dtick = ax.dtick;
          } else if (majorNum >= 12 && minorNum === 2) {
            // another special carve-out: for year major ticks, don't show
            // 2-month minor ticks, bump to quarters
            mockAx.dtick = 'M3';
          }
        }
      } else if (String(mockAx.dtick).charAt(0) === 'L') {
        if (String(ax.dtick).charAt(0) === 'L') {
          if (!isMultiple(majorNum, minorNum)) {
            mockAx.dtick = isClose(majorNum / minorNum, 2.5) ? ax.dtick / 2 : ax.dtick;
          }
        } else {
          mockAx.dtick = 'D1';
        }
      } else if (mockAx.dtick === 'D2' && +ax.dtick > 1) {
        // the D2 log axis tick spacing is confusing for unlabeled minor ticks if
        // the major dtick is more than one order of magnitude.
        mockAx.dtick = 1;
      }
    }
    // put back the original range, to use to find the full set of minor ticks
    mockAx.range = ax.range;
  }
  if (ax.minor._tick0Init === undefined) {
    // ensure identical tick0
    mockAx.tick0 = ax.tick0;
  }
};
function isMultiple(bigger, smaller) {
  return Math.abs((bigger / smaller + 0.5) % 1 - 0.5) < 0.001;
}
function isClose(a, b) {
  return Math.abs(a / b - 1) < 0.001;
}

// ensure we have tick0, dtick, and tick rounding calculated
axes.prepTicks = function (ax, opts) {
  var rng = Lib.simpleMap(ax.range, ax.r2l, undefined, undefined, opts);

  // calculate max number of (auto) ticks to display based on plot size
  if (ax.tickmode === 'auto' || !ax.dtick) {
    var nt = ax.nticks;
    var minPx;
    if (!nt) {
      if (ax.type === 'category' || ax.type === 'multicategory') {
        minPx = ax.tickfont ? Lib.bigFont(ax.tickfont.size || 12) : 15;
        nt = ax._length / minPx;
      } else {
        minPx = ax._id.charAt(0) === 'y' ? 40 : 80;
        nt = Lib.constrain(ax._length / minPx, 4, 9) + 1;
      }

      // radial axes span half their domain,
      // multiply nticks value by two to get correct number of auto ticks.
      if (ax._name === 'radialaxis') nt *= 2;
    }
    if (!(ax.minor && ax.minor.tickmode !== 'array')) {
      // add a couple of extra digits for filling in ticks when we
      // have explicit tickvals without tick text
      if (ax.tickmode === 'array') nt *= 100;
    }
    ax._roughDTick = Math.abs(rng[1] - rng[0]) / nt;
    axes.autoTicks(ax, ax._roughDTick);

    // check for a forced minimum dtick
    if (ax._minDtick > 0 && ax.dtick < ax._minDtick * 2) {
      ax.dtick = ax._minDtick;
      ax.tick0 = ax.l2r(ax._forceTick0);
    }
  }
  if (ax.ticklabelmode === 'period') {
    adjustPeriodDelta(ax);
  }

  // check for missing tick0
  if (!ax.tick0) {
    ax.tick0 = ax.type === 'date' ? '2000-01-01' : 0;
  }

  // ensure we don't try to make ticks below our minimum precision
  // see https://github.com/plotly/plotly.js/issues/2892
  if (ax.type === 'date' && ax.dtick < 0.1) ax.dtick = 0.1;

  // now figure out rounding of tick values
  autoTickRound(ax);
};
function nMonths(dtick) {
  return +dtick.substring(1);
}
function adjustPeriodDelta(ax) {
  // adjusts ax.dtick and sets ax._definedDelta
  var definedDelta;
  function mDate() {
    return !(isNumeric(ax.dtick) || ax.dtick.charAt(0) !== 'M');
  }
  var isMDate = mDate();
  var tickformat = axes.getTickFormat(ax);
  if (tickformat) {
    var noDtick = ax._dtickInit !== ax.dtick;
    if (!/%[fLQsSMX]/.test(tickformat)
    // %f: microseconds as a decimal number [000000, 999999]
    // %L: milliseconds as a decimal number [000, 999]
    // %Q: milliseconds since UNIX epoch
    // %s: seconds since UNIX epoch
    // %S: second as a decimal number [00,61]
    // %M: minute as a decimal number [00,59]
    // %X: the locale’s time, such as %-I:%M:%S %p
    ) {
      if (/%[HI]/.test(tickformat)
      // %H: hour (24-hour clock) as a decimal number [00,23]
      // %I: hour (12-hour clock) as a decimal number [01,12]
      ) {
        definedDelta = ONEHOUR;
        if (noDtick && !isMDate && ax.dtick < ONEHOUR) ax.dtick = ONEHOUR;
      } else if (/%p/.test(tickformat) // %p: either AM or PM
      ) {
        definedDelta = HALFDAY;
        if (noDtick && !isMDate && ax.dtick < HALFDAY) ax.dtick = HALFDAY;
      } else if (/%[Aadejuwx]/.test(tickformat)
      // %A: full weekday name
      // %a: abbreviated weekday name
      // %d: zero-padded day of the month as a decimal number [01,31]
      // %e: space-padded day of the month as a decimal number [ 1,31]
      // %j: day of the year as a decimal number [001,366]
      // %u: Monday-based (ISO 8601) weekday as a decimal number [1,7]
      // %w: Sunday-based weekday as a decimal number [0,6]
      // %x: the locale’s date, such as %-m/%-d/%Y
      ) {
        definedDelta = ONEDAY;
        if (noDtick && !isMDate && ax.dtick < ONEDAY) ax.dtick = ONEDAY;
      } else if (/%[UVW]/.test(tickformat)
      // %U: Sunday-based week of the year as a decimal number [00,53]
      // %V: ISO 8601 week of the year as a decimal number [01, 53]
      // %W: Monday-based week of the year as a decimal number [00,53]
      ) {
        definedDelta = ONEWEEK;
        if (noDtick && !isMDate && ax.dtick < ONEWEEK) ax.dtick = ONEWEEK;
      } else if (/%[Bbm]/.test(tickformat)
      // %B: full month name
      // %b: abbreviated month name
      // %m: month as a decimal number [01,12]
      ) {
        definedDelta = ONEAVGMONTH;
        if (noDtick && (isMDate ? nMonths(ax.dtick) < 1 : ax.dtick < ONEMINMONTH)) ax.dtick = 'M1';
      } else if (/%[q]/.test(tickformat)
      // %q: quarter of the year as a decimal number [1,4]
      ) {
        definedDelta = ONEAVGQUARTER;
        if (noDtick && (isMDate ? nMonths(ax.dtick) < 3 : ax.dtick < ONEMINQUARTER)) ax.dtick = 'M3';
      } else if (/%[Yy]/.test(tickformat)
      // %Y: year with century as a decimal number, such as 1999
      // %y: year without century as a decimal number [00,99]
      ) {
        definedDelta = ONEAVGYEAR;
        if (noDtick && (isMDate ? nMonths(ax.dtick) < 12 : ax.dtick < ONEMINYEAR)) ax.dtick = 'M12';
      }
    }
  }
  isMDate = mDate();
  if (isMDate && ax.tick0 === ax._dowTick0) {
    // discard Sunday/Monday tweaks
    ax.tick0 = ax._rawTick0;
  }
  ax._definedDelta = definedDelta;
}
function positionPeriodTicks(tickVals, ax, definedDelta) {
  for (var i = 0; i < tickVals.length; i++) {
    var v = tickVals[i].value;
    var a = i;
    var b = i + 1;
    if (i < tickVals.length - 1) {
      a = i;
      b = i + 1;
    } else if (i > 0) {
      a = i - 1;
      b = i;
    } else {
      a = i;
      b = i;
    }
    var A = tickVals[a].value;
    var B = tickVals[b].value;
    var actualDelta = Math.abs(B - A);
    var delta = definedDelta || actualDelta;
    var periodLength = 0;
    if (delta >= ONEMINYEAR) {
      if (actualDelta >= ONEMINYEAR && actualDelta <= ONEMAXYEAR) {
        periodLength = actualDelta;
      } else {
        periodLength = ONEAVGYEAR;
      }
    } else if (definedDelta === ONEAVGQUARTER && delta >= ONEMINQUARTER) {
      if (actualDelta >= ONEMINQUARTER && actualDelta <= ONEMAXQUARTER) {
        periodLength = actualDelta;
      } else {
        periodLength = ONEAVGQUARTER;
      }
    } else if (delta >= ONEMINMONTH) {
      if (actualDelta >= ONEMINMONTH && actualDelta <= ONEMAXMONTH) {
        periodLength = actualDelta;
      } else {
        periodLength = ONEAVGMONTH;
      }
    } else if (definedDelta === ONEWEEK && delta >= ONEWEEK) {
      periodLength = ONEWEEK;
    } else if (delta >= ONEDAY) {
      periodLength = ONEDAY;
    } else if (definedDelta === HALFDAY && delta >= HALFDAY) {
      periodLength = HALFDAY;
    } else if (definedDelta === ONEHOUR && delta >= ONEHOUR) {
      periodLength = ONEHOUR;
    }
    var inBetween;
    if (periodLength >= actualDelta) {
      // ensure new label positions remain between ticks
      periodLength = actualDelta;
      inBetween = true;
    }
    var endPeriod = v + periodLength;
    if (ax.rangebreaks && periodLength > 0) {
      var nAll = 84; // highly divisible 7 * 12
      var n = 0;
      for (var c = 0; c < nAll; c++) {
        var r = (c + 0.5) / nAll;
        if (ax.maskBreaks(v * (1 - r) + r * endPeriod) !== BADNUM) n++;
      }
      periodLength *= n / nAll;
      if (!periodLength) {
        tickVals[i].drop = true;
      }
      if (inBetween && actualDelta > ONEWEEK) periodLength = actualDelta; // center monthly & longer periods
    }

    if (periodLength > 0 ||
    // not instant
    i === 0 // taking care first tick added
    ) {
      tickVals[i].periodX = v + periodLength / 2;
    }
  }
}

// calculate the ticks: text, values, positioning
// if ticks are set to automatic, determine the right values (tick0,dtick)
// in any case, set tickround to # of digits to round tick labels to,
// or codes to this effect for log and date scales
axes.calcTicks = function calcTicks(ax, opts) {
  var type = ax.type;
  var calendar = ax.calendar;
  var ticklabelstep = ax.ticklabelstep;
  var isPeriod = ax.ticklabelmode === 'period';
  var rng = Lib.simpleMap(ax.range, ax.r2l, undefined, undefined, opts);
  var axrev = rng[1] < rng[0];
  var minRange = Math.min(rng[0], rng[1]);
  var maxRange = Math.max(rng[0], rng[1]);
  var maxTicks = Math.max(1000, ax._length || 0);
  var ticksOut = [];
  var minorTicks = [];
  var tickVals = [];
  var minorTickVals = [];
  var hasMinor = ax.minor && (ax.minor.ticks || ax.minor.showgrid);

  // calc major first
  for (var major = 1; major >= (hasMinor ? 0 : 1); major--) {
    var isMinor = !major;
    if (major) {
      ax._dtickInit = ax.dtick;
      ax._tick0Init = ax.tick0;
    } else {
      ax.minor._dtickInit = ax.minor.dtick;
      ax.minor._tick0Init = ax.minor.tick0;
    }
    var mockAx = major ? ax : Lib.extendFlat({}, ax, ax.minor);
    if (isMinor) {
      axes.prepMinorTicks(mockAx, ax, opts);
    } else {
      axes.prepTicks(mockAx, opts);
    }

    // now that we've figured out the auto values for formatting
    // in case we're missing some ticktext, we can break out for array ticks
    if (mockAx.tickmode === 'array') {
      if (major) {
        tickVals = [];
        ticksOut = arrayTicks(ax);
      } else {
        minorTickVals = [];
        minorTicks = arrayTicks(ax);
      }
      continue;
    }

    // fill tickVals based on overlaying axis
    if (mockAx.tickmode === 'sync') {
      tickVals = [];
      ticksOut = syncTicks(ax);
      continue;
    }

    // add a tiny bit so we get ticks which may have rounded out
    var exRng = expandRange(rng);
    var startTick = exRng[0];
    var endTick = exRng[1];
    var numDtick = isNumeric(mockAx.dtick);
    var isDLog = type === 'log' && !(numDtick || mockAx.dtick.charAt(0) === 'L');

    // find the first tick
    var x0 = axes.tickFirst(mockAx, opts);
    if (major) {
      ax._tmin = x0;

      // No visible ticks? Quit.
      // I've only seen this on category axes with all categories off the edge.
      if (x0 < startTick !== axrev) break;

      // return the full set of tick vals
      if (type === 'category' || type === 'multicategory') {
        endTick = axrev ? Math.max(-0.5, endTick) : Math.min(ax._categories.length - 0.5, endTick);
      }
    }
    var prevX = null;
    var x = x0;
    var majorId;
    if (major) {
      // ids for ticklabelstep
      var _dTick;
      if (numDtick) {
        _dTick = ax.dtick;
      } else {
        if (type === 'date') {
          if (typeof ax.dtick === 'string' && ax.dtick.charAt(0) === 'M') {
            _dTick = ONEAVGMONTH * ax.dtick.substring(1);
          }
        } else {
          _dTick = ax._roughDTick;
        }
      }
      majorId = Math.round((ax.r2l(x) - ax.r2l(ax.tick0)) / _dTick) - 1;
    }
    var dtick = mockAx.dtick;
    if (mockAx.rangebreaks && mockAx._tick0Init !== mockAx.tick0) {
      // adjust tick0
      x = moveOutsideBreak(x, ax);
      if (!axrev) {
        x = axes.tickIncrement(x, dtick, !axrev, calendar);
      }
    }
    if (major && isPeriod) {
      // add one item to label period before tick0
      x = axes.tickIncrement(x, dtick, !axrev, calendar);
      majorId--;
    }
    for (; axrev ? x >= endTick : x <= endTick; x = axes.tickIncrement(x, dtick, axrev, calendar)) {
      if (major) majorId++;
      if (mockAx.rangebreaks) {
        if (!axrev) {
          if (x < startTick) continue;
          if (mockAx.maskBreaks(x) === BADNUM && moveOutsideBreak(x, mockAx) >= maxRange) break;
        }
      }

      // prevent infinite loops - no more than one tick per pixel,
      // and make sure each value is different from the previous
      if (tickVals.length > maxTicks || x === prevX) break;
      prevX = x;
      var obj = {
        value: x
      };
      if (major) {
        if (isDLog && x !== (x | 0)) {
          obj.simpleLabel = true;
        }
        if (ticklabelstep > 1 && majorId % ticklabelstep) {
          obj.skipLabel = true;
        }
        tickVals.push(obj);
      } else {
        obj.minor = true;
        minorTickVals.push(obj);
      }
    }
  }
  if (hasMinor) {
    var canOverlap = ax.minor.ticks === 'inside' && ax.ticks === 'outside' || ax.minor.ticks === 'outside' && ax.ticks === 'inside';
    if (!canOverlap) {
      // remove duplicate minors

      var majorValues = tickVals.map(function (d) {
        return d.value;
      });
      var list = [];
      for (var k = 0; k < minorTickVals.length; k++) {
        var T = minorTickVals[k];
        var v = T.value;
        if (majorValues.indexOf(v) !== -1) {
          continue;
        }
        var found = false;
        for (var q = 0; !found && q < tickVals.length; q++) {
          if (
          // add 10e6 to eliminate problematic digits
          10e6 + tickVals[q].value === 10e6 + v) {
            found = true;
          }
        }
        if (!found) list.push(T);
      }
      minorTickVals = list;
    }
  }
  if (isPeriod) positionPeriodTicks(tickVals, ax, ax._definedDelta);
  var i;
  if (ax.rangebreaks) {
    var flip = ax._id.charAt(0) === 'y';
    var fontSize = 1; // one pixel minimum
    if (ax.tickmode === 'auto') {
      fontSize = ax.tickfont ? ax.tickfont.size : 12;
    }
    var prevL = NaN;
    for (i = tickVals.length - 1; i > -1; i--) {
      if (tickVals[i].drop) {
        tickVals.splice(i, 1);
        continue;
      }
      tickVals[i].value = moveOutsideBreak(tickVals[i].value, ax);

      // avoid overlaps
      var l = ax.c2p(tickVals[i].value);
      if (flip ? prevL > l - fontSize : prevL < l + fontSize) {
        // ensure one pixel minimum
        tickVals.splice(axrev ? i + 1 : i, 1);
      } else {
        prevL = l;
      }
    }
  }

  // If same angle over a full circle, the last tick vals is a duplicate.
  // TODO must do something similar for angular date axes.
  if (isAngular(ax) && Math.abs(rng[1] - rng[0]) === 360) {
    tickVals.pop();
  }

  // save the last tick as well as first, so we can
  // show the exponent only on the last one
  ax._tmax = (tickVals[tickVals.length - 1] || {}).value;

  // for showing the rest of a date when the main tick label is only the
  // latter part: ax._prevDateHead holds what we showed most recently.
  // Start with it cleared and mark that we're in calcTicks (ie calculating a
  // whole string of these so we should care what the previous date head was!)
  ax._prevDateHead = '';
  ax._inCalcTicks = true;
  var lastVisibleHead;
  var hideLabel = function (tick) {
    tick.text = '';
    ax._prevDateHead = lastVisibleHead;
  };
  tickVals = tickVals.concat(minorTickVals);
  var t, p;
  for (i = 0; i < tickVals.length; i++) {
    var _minor = tickVals[i].minor;
    var _value = tickVals[i].value;
    if (_minor) {
      minorTicks.push({
        x: _value,
        minor: true
      });
    } else {
      lastVisibleHead = ax._prevDateHead;
      t = axes.tickText(ax, _value, false,
      // hover
      tickVals[i].simpleLabel // noSuffixPrefix
      );

      p = tickVals[i].periodX;
      if (p !== undefined) {
        t.periodX = p;
        if (p > maxRange || p < minRange) {
          // hide label if outside the range
          if (p > maxRange) t.periodX = maxRange;
          if (p < minRange) t.periodX = minRange;
          hideLabel(t);
        }
      }
      if (tickVals[i].skipLabel) {
        hideLabel(t);
      }
      ticksOut.push(t);
    }
  }
  ticksOut = ticksOut.concat(minorTicks);
  ax._inCalcTicks = false;
  if (isPeriod && ticksOut.length) {
    // drop very first tick that we added to handle period
    ticksOut[0].noTick = true;
  }
  return ticksOut;
};
function filterRangeBreaks(ax, ticksOut) {
  if (ax.rangebreaks) {
    // remove ticks falling inside rangebreaks
    ticksOut = ticksOut.filter(function (d) {
      return ax.maskBreaks(d.x) !== BADNUM;
    });
  }
  return ticksOut;
}
function syncTicks(ax) {
  // get the overlaying axis
  var baseAxis = ax._mainAxis;
  var ticksOut = [];
  if (baseAxis._vals) {
    for (var i = 0; i < baseAxis._vals.length; i++) {
      // filter vals with noTick flag
      if (baseAxis._vals[i].noTick) {
        continue;
      }

      // get the position of the every tick
      var pos = baseAxis.l2p(baseAxis._vals[i].x);

      // get the tick for the current axis based on position
      var vali = ax.p2l(pos);
      var obj = axes.tickText(ax, vali);

      // assign minor ticks
      if (baseAxis._vals[i].minor) {
        obj.minor = true;
        obj.text = '';
      }
      ticksOut.push(obj);
    }
  }
  ticksOut = filterRangeBreaks(ax, ticksOut);
  return ticksOut;
}
function arrayTicks(ax) {
  var rng = Lib.simpleMap(ax.range, ax.r2l);
  var exRng = expandRange(rng);
  var tickMin = Math.min(exRng[0], exRng[1]);
  var tickMax = Math.max(exRng[0], exRng[1]);

  // make sure showing ticks doesn't accidentally add new categories
  // TODO multicategory, if we allow ticktext / tickvals
  var tickVal2l = ax.type === 'category' ? ax.d2l_noadd : ax.d2l;

  // array ticks on log axes always show the full number
  // (if no explicit ticktext overrides it)
  if (ax.type === 'log' && String(ax.dtick).charAt(0) !== 'L') {
    ax.dtick = 'L' + Math.pow(10, Math.floor(Math.min(ax.range[0], ax.range[1])) - 1);
  }
  var ticksOut = [];
  for (var isMinor = 0; isMinor <= 1; isMinor++) {
    if (isMinor && !ax.minor) continue;
    var vals = !isMinor ? ax.tickvals : ax.minor.tickvals;
    var text = !isMinor ? ax.ticktext : [];
    if (!vals) continue;

    // without a text array, just format the given values as any other ticks
    // except with more precision to the numbers
    if (!Array.isArray(text)) text = [];
    for (var i = 0; i < vals.length; i++) {
      var vali = tickVal2l(vals[i]);
      if (vali > tickMin && vali < tickMax) {
        var obj = text[i] === undefined ? axes.tickText(ax, vali) : tickTextObj(ax, vali, String(text[i]));
        if (isMinor) {
          obj.minor = true;
          obj.text = '';
        }
        ticksOut.push(obj);
      }
    }
  }
  ticksOut = filterRangeBreaks(ax, ticksOut);
  return ticksOut;
}
var roundBase10 = [2, 5, 10];
var roundBase24 = [1, 2, 3, 6, 12];
var roundBase60 = [1, 2, 5, 10, 15, 30];
// 2&3 day ticks are weird, but need something btwn 1&7
var roundDays = [1, 2, 3, 7, 14];
// approx. tick positions for log axes, showing all (1) and just 1, 2, 5 (2)
// these don't have to be exact, just close enough to round to the right value
var roundLog1 = [-0.046, 0, 0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1];
var roundLog2 = [-0.301, 0, 0.301, 0.699, 1];
// N.B. `thetaunit; 'radians' angular axes must be converted to degrees
var roundAngles = [15, 30, 45, 90, 180];
function roundDTick(roughDTick, base, roundingSet) {
  return base * Lib.roundUp(roughDTick / base, roundingSet);
}

// autoTicks: calculate best guess at pleasant ticks for this axis
// inputs:
//      ax - an axis object
//      roughDTick - rough tick spacing (to be turned into a nice round number)
// outputs (into ax):
//   tick0: starting point for ticks (not necessarily on the graph)
//      usually 0 for numeric (=10^0=1 for log) or jan 1, 2000 for dates
//   dtick: the actual, nice round tick spacing, usually a little larger than roughDTick
//      if the ticks are spaced linearly (linear scale, categories,
//          log with only full powers, date ticks < month),
//          this will just be a number
//      months: M#
//      years: M# where # is 12*number of years
//      log with linear ticks: L# where # is the linear tick spacing
//      log showing powers plus some intermediates:
//          D1 shows all digits, D2 shows 2 and 5
axes.autoTicks = function (ax, roughDTick, isMinor) {
  var base;
  function getBase(v) {
    return Math.pow(v, Math.floor(Math.log(roughDTick) / Math.LN10));
  }
  if (ax.type === 'date') {
    ax.tick0 = Lib.dateTick0(ax.calendar, 0);

    // the criteria below are all based on the rough spacing we calculate
    // being > half of the final unit - so precalculate twice the rough val
    var roughX2 = 2 * roughDTick;
    if (roughX2 > ONEAVGYEAR) {
      roughDTick /= ONEAVGYEAR;
      base = getBase(10);
      ax.dtick = 'M' + 12 * roundDTick(roughDTick, base, roundBase10);
    } else if (roughX2 > ONEAVGMONTH) {
      roughDTick /= ONEAVGMONTH;
      ax.dtick = 'M' + roundDTick(roughDTick, 1, roundBase24);
    } else if (roughX2 > ONEDAY) {
      ax.dtick = roundDTick(roughDTick, ONEDAY, ax._hasDayOfWeekBreaks ? [1, 2, 7, 14] : roundDays);
      if (!isMinor) {
        // get week ticks on sunday
        // this will also move the base tick off 2000-01-01 if dtick is
        // 2 or 3 days... but that's a weird enough case that we'll ignore it.
        var tickformat = axes.getTickFormat(ax);
        var isPeriod = ax.ticklabelmode === 'period';
        if (isPeriod) ax._rawTick0 = ax.tick0;
        if (/%[uVW]/.test(tickformat)) {
          ax.tick0 = Lib.dateTick0(ax.calendar, 2); // Monday
        } else {
          ax.tick0 = Lib.dateTick0(ax.calendar, 1); // Sunday
        }

        if (isPeriod) ax._dowTick0 = ax.tick0;
      }
    } else if (roughX2 > ONEHOUR) {
      ax.dtick = roundDTick(roughDTick, ONEHOUR, roundBase24);
    } else if (roughX2 > ONEMIN) {
      ax.dtick = roundDTick(roughDTick, ONEMIN, roundBase60);
    } else if (roughX2 > ONESEC) {
      ax.dtick = roundDTick(roughDTick, ONESEC, roundBase60);
    } else {
      // milliseconds
      base = getBase(10);
      ax.dtick = roundDTick(roughDTick, base, roundBase10);
    }
  } else if (ax.type === 'log') {
    ax.tick0 = 0;
    var rng = Lib.simpleMap(ax.range, ax.r2l);
    if (ax._isMinor) {
      // Log axes by default get MORE than nTicks based on the metrics below
      // But for minor ticks we don't want this increase, we already have
      // the major ticks.
      roughDTick *= 1.5;
    }
    if (roughDTick > 0.7) {
      // only show powers of 10
      ax.dtick = Math.ceil(roughDTick);
    } else if (Math.abs(rng[1] - rng[0]) < 1) {
      // span is less than one power of 10
      var nt = 1.5 * Math.abs((rng[1] - rng[0]) / roughDTick);

      // ticks on a linear scale, labeled fully
      roughDTick = Math.abs(Math.pow(10, rng[1]) - Math.pow(10, rng[0])) / nt;
      base = getBase(10);
      ax.dtick = 'L' + roundDTick(roughDTick, base, roundBase10);
    } else {
      // include intermediates between powers of 10,
      // labeled with small digits
      // ax.dtick = "D2" (show 2 and 5) or "D1" (show all digits)
      ax.dtick = roughDTick > 0.3 ? 'D2' : 'D1';
    }
  } else if (ax.type === 'category' || ax.type === 'multicategory') {
    ax.tick0 = 0;
    ax.dtick = Math.ceil(Math.max(roughDTick, 1));
  } else if (isAngular(ax)) {
    ax.tick0 = 0;
    base = 1;
    ax.dtick = roundDTick(roughDTick, base, roundAngles);
  } else {
    // auto ticks always start at 0
    ax.tick0 = 0;
    base = getBase(10);
    ax.dtick = roundDTick(roughDTick, base, roundBase10);
  }

  // prevent infinite loops
  if (ax.dtick === 0) ax.dtick = 1;

  // TODO: this is from log axis histograms with autorange off
  if (!isNumeric(ax.dtick) && typeof ax.dtick !== 'string') {
    var olddtick = ax.dtick;
    ax.dtick = 1;
    throw 'ax.dtick error: ' + String(olddtick);
  }
};

// after dtick is already known, find tickround = precision
// to display in tick labels
//   for numeric ticks, integer # digits after . to round to
//   for date ticks, the last date part to show (y,m,d,H,M,S)
//      or an integer # digits past seconds
function autoTickRound(ax) {
  var dtick = ax.dtick;
  ax._tickexponent = 0;
  if (!isNumeric(dtick) && typeof dtick !== 'string') {
    dtick = 1;
  }
  if (ax.type === 'category' || ax.type === 'multicategory') {
    ax._tickround = null;
  }
  if (ax.type === 'date') {
    // If tick0 is unusual, give tickround a bit more information
    // not necessarily *all* the information in tick0 though, if it's really odd
    // minimal string length for tick0: 'd' is 10, 'M' is 16, 'S' is 19
    // take off a leading minus (year < 0) and i (intercalary month) so length is consistent
    var tick0ms = ax.r2l(ax.tick0);
    var tick0str = ax.l2r(tick0ms).replace(/(^-|i)/g, '');
    var tick0len = tick0str.length;
    if (String(dtick).charAt(0) === 'M') {
      // any tick0 more specific than a year: alway show the full date
      if (tick0len > 10 || tick0str.substr(5) !== '01-01') ax._tickround = 'd';
      // show the month unless ticks are full multiples of a year
      else ax._tickround = +dtick.substr(1) % 12 === 0 ? 'y' : 'm';
    } else if (dtick >= ONEDAY && tick0len <= 10 || dtick >= ONEDAY * 15) ax._tickround = 'd';else if (dtick >= ONEMIN && tick0len <= 16 || dtick >= ONEHOUR) ax._tickround = 'M';else if (dtick >= ONESEC && tick0len <= 19 || dtick >= ONEMIN) ax._tickround = 'S';else {
      // tickround is a number of digits of fractional seconds
      // of any two adjacent ticks, at least one will have the maximum fractional digits
      // of all possible ticks - so take the max. length of tick0 and the next one
      var tick1len = ax.l2r(tick0ms + dtick).replace(/^-/, '').length;
      ax._tickround = Math.max(tick0len, tick1len) - 20;

      // We shouldn't get here... but in case there's a situation I'm
      // not thinking of where tick0str and tick1str are identical or
      // something, fall back on maximum precision
      if (ax._tickround < 0) ax._tickround = 4;
    }
  } else if (isNumeric(dtick) || dtick.charAt(0) === 'L') {
    // linear or log (except D1, D2)
    var rng = ax.range.map(ax.r2d || Number);
    if (!isNumeric(dtick)) dtick = Number(dtick.substr(1));
    // 2 digits past largest digit of dtick
    ax._tickround = 2 - Math.floor(Math.log(dtick) / Math.LN10 + 0.01);
    var maxend = Math.max(Math.abs(rng[0]), Math.abs(rng[1]));
    var rangeexp = Math.floor(Math.log(maxend) / Math.LN10 + 0.01);
    var minexponent = ax.minexponent === undefined ? 3 : ax.minexponent;
    if (Math.abs(rangeexp) > minexponent) {
      if (isSIFormat(ax.exponentformat) && !beyondSI(rangeexp)) {
        ax._tickexponent = 3 * Math.round((rangeexp - 1) / 3);
      } else ax._tickexponent = rangeexp;
    }
  } else {
    // D1 or D2 (log)
    ax._tickround = null;
  }
}

// months and years don't have constant millisecond values
// (but a year is always 12 months so we only need months)
// log-scale ticks are also not consistently spaced, except
// for pure powers of 10
// numeric ticks always have constant differences, other datetime ticks
// can all be calculated as constant number of milliseconds
axes.tickIncrement = function (x, dtick, axrev, calendar) {
  var axSign = axrev ? -1 : 1;

  // includes linear, all dates smaller than month, and pure 10^n in log
  if (isNumeric(dtick)) return Lib.increment(x, axSign * dtick);

  // everything else is a string, one character plus a number
  var tType = dtick.charAt(0);
  var dtSigned = axSign * Number(dtick.substr(1));

  // Dates: months (or years - see Lib.incrementMonth)
  if (tType === 'M') return Lib.incrementMonth(x, dtSigned, calendar);

  // Log scales: Linear, Digits
  if (tType === 'L') return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10;

  // log10 of 2,5,10, or all digits (logs just have to be
  // close enough to round)
  if (tType === 'D') {
    var tickset = dtick === 'D2' ? roundLog2 : roundLog1;
    var x2 = x + axSign * 0.01;
    var frac = Lib.roundUp(Lib.mod(x2, 1), tickset, axrev);
    return Math.floor(x2) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;
  }
  throw 'unrecognized dtick ' + String(dtick);
};

// calculate the first tick on an axis
axes.tickFirst = function (ax, opts) {
  var r2l = ax.r2l || Number;
  var rng = Lib.simpleMap(ax.range, r2l, undefined, undefined, opts);
  var axrev = rng[1] < rng[0];
  var sRound = axrev ? Math.floor : Math.ceil;
  // add a tiny extra bit to make sure we get ticks
  // that may have been rounded out
  var r0 = expandRange(rng)[0];
  var dtick = ax.dtick;
  var tick0 = r2l(ax.tick0);
  if (isNumeric(dtick)) {
    var tmin = sRound((r0 - tick0) / dtick) * dtick + tick0;

    // make sure no ticks outside the category list
    if (ax.type === 'category' || ax.type === 'multicategory') {
      tmin = Lib.constrain(tmin, 0, ax._categories.length - 1);
    }
    return tmin;
  }
  var tType = dtick.charAt(0);
  var dtNum = Number(dtick.substr(1));

  // Dates: months (or years)
  if (tType === 'M') {
    var cnt = 0;
    var t0 = tick0;
    var t1, mult, newDTick;

    // This algorithm should work for *any* nonlinear (but close to linear!)
    // tick spacing. Limit to 10 iterations, for gregorian months it's normally <=3.
    while (cnt < 10) {
      t1 = axes.tickIncrement(t0, dtick, axrev, ax.calendar);
      if ((t1 - r0) * (t0 - r0) <= 0) {
        // t1 and t0 are on opposite sides of r0! we've succeeded!
        if (axrev) return Math.min(t0, t1);
        return Math.max(t0, t1);
      }
      mult = (r0 - (t0 + t1) / 2) / (t1 - t0);
      newDTick = tType + (Math.abs(Math.round(mult)) || 1) * dtNum;
      t0 = axes.tickIncrement(t0, newDTick, mult < 0 ? !axrev : axrev, ax.calendar);
      cnt++;
    }
    Lib.error('tickFirst did not converge', ax);
    return t0;
  } else if (tType === 'L') {
    // Log scales: Linear, Digits

    return Math.log(sRound((Math.pow(10, r0) - tick0) / dtNum) * dtNum + tick0) / Math.LN10;
  } else if (tType === 'D') {
    var tickset = dtick === 'D2' ? roundLog2 : roundLog1;
    var frac = Lib.roundUp(Lib.mod(r0, 1), tickset, axrev);
    return Math.floor(r0) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;
  } else throw 'unrecognized dtick ' + String(dtick);
};

// draw the text for one tick.
// px,py are the location on gd.paper
// prefix is there so the x axis ticks can be dropped a line
// ax is the axis layout, x is the tick value
// hover is a (truthy) flag for whether to show numbers with a bit
// more precision for hovertext
axes.tickText = function (ax, x, hover, noSuffixPrefix) {
  var out = tickTextObj(ax, x);
  var arrayMode = ax.tickmode === 'array';
  var extraPrecision = hover || arrayMode;
  var axType = ax.type;
  // TODO multicategory, if we allow ticktext / tickvals
  var tickVal2l = axType === 'category' ? ax.d2l_noadd : ax.d2l;
  var i;
  if (arrayMode && Array.isArray(ax.ticktext)) {
    var rng = Lib.simpleMap(ax.range, ax.r2l);
    var minDiff = (Math.abs(rng[1] - rng[0]) - (ax._lBreaks || 0)) / 10000;
    for (i = 0; i < ax.ticktext.length; i++) {
      if (Math.abs(x - tickVal2l(ax.tickvals[i])) < minDiff) break;
    }
    if (i < ax.ticktext.length) {
      out.text = String(ax.ticktext[i]);
      return out;
    }
  }
  function isHidden(showAttr) {
    if (showAttr === undefined) return true;
    if (hover) return showAttr === 'none';
    var firstOrLast = {
      first: ax._tmin,
      last: ax._tmax
    }[showAttr];
    return showAttr !== 'all' && x !== firstOrLast;
  }
  var hideexp = hover ? 'never' : ax.exponentformat !== 'none' && isHidden(ax.showexponent) ? 'hide' : '';
  if (axType === 'date') formatDate(ax, out, hover, extraPrecision);else if (axType === 'log') formatLog(ax, out, hover, extraPrecision, hideexp);else if (axType === 'category') formatCategory(ax, out);else if (axType === 'multicategory') formatMultiCategory(ax, out, hover);else if (isAngular(ax)) formatAngle(ax, out, hover, extraPrecision, hideexp);else formatLinear(ax, out, hover, extraPrecision, hideexp);

  // add prefix and suffix
  if (!noSuffixPrefix) {
    if (ax.tickprefix && !isHidden(ax.showtickprefix)) out.text = ax.tickprefix + out.text;
    if (ax.ticksuffix && !isHidden(ax.showticksuffix)) out.text += ax.ticksuffix;
  }
  if (ax.labelalias && ax.labelalias.hasOwnProperty(out.text)) {
    var t = ax.labelalias[out.text];
    if (typeof t === 'string') out.text = t;
  }

  // Setup ticks and grid lines boundaries
  // at 1/2 a 'category' to the left/bottom
  if (ax.tickson === 'boundaries' || ax.showdividers) {
    var inbounds = function (v) {
      var p = ax.l2p(v);
      return p >= 0 && p <= ax._length ? v : null;
    };
    out.xbnd = [inbounds(out.x - 0.5), inbounds(out.x + ax.dtick - 0.5)];
  }
  return out;
};

/**
 * create text for a hover label on this axis, with special handling of
 * log axes (where negative values can't be displayed but can appear in hover text)
 *
 * @param {object} ax: the axis to format text for
 * @param {number or array of numbers} values: calcdata value(s) to format
 * @param {Optional(string)} hoverformat: trace (x|y)hoverformat to override axis.hoverformat
 *
 * @returns {string} `val` formatted as a string appropriate to this axis, or
 *     first value and second value as a range (ie '<val1> - <val2>') if the second value is provided and
 *     it's different from the first value.
 */
axes.hoverLabelText = function (ax, values, hoverformat) {
  if (hoverformat) ax = Lib.extendFlat({}, ax, {
    hoverformat: hoverformat
  });
  var val = Array.isArray(values) ? values[0] : values;
  var val2 = Array.isArray(values) ? values[1] : undefined;
  if (val2 !== undefined && val2 !== val) {
    return axes.hoverLabelText(ax, val, hoverformat) + ' - ' + axes.hoverLabelText(ax, val2, hoverformat);
  }
  var logOffScale = ax.type === 'log' && val <= 0;
  var tx = axes.tickText(ax, ax.c2l(logOffScale ? -val : val), 'hover').text;
  if (logOffScale) {
    return val === 0 ? '0' : MINUS_SIGN + tx;
  }

  // TODO: should we do something special if the axis calendar and
  // the data calendar are different? Somehow display both dates with
  // their system names? Right now it will just display in the axis calendar
  // but users could add the other one as text.
  return tx;
};
function tickTextObj(ax, x, text) {
  var tf = ax.tickfont || {};
  return {
    x: x,
    dx: 0,
    dy: 0,
    text: text || '',
    fontSize: tf.size,
    font: tf.family,
    fontColor: tf.color
  };
}
function formatDate(ax, out, hover, extraPrecision) {
  var tr = ax._tickround;
  var fmt = hover && ax.hoverformat || axes.getTickFormat(ax);

  // Only apply extra precision if no explicit format was provided.
  extraPrecision = !fmt && extraPrecision;
  if (extraPrecision) {
    // second or sub-second precision: extra always shows max digits.
    // for other fields, extra precision just adds one field.
    if (isNumeric(tr)) tr = 4;else tr = {
      y: 'm',
      m: 'd',
      d: 'M',
      M: 'S',
      S: 4
    }[tr];
  }
  var dateStr = Lib.formatDate(out.x, fmt, tr, ax._dateFormat, ax.calendar, ax._extraFormat);
  var headStr;
  var splitIndex = dateStr.indexOf('\n');
  if (splitIndex !== -1) {
    headStr = dateStr.substr(splitIndex + 1);
    dateStr = dateStr.substr(0, splitIndex);
  }
  if (extraPrecision) {
    // if extraPrecision led to trailing zeros, strip them off
    // actually, this can lead to removing even more zeros than
    // in the original rounding, but that's fine because in these
    // contexts uniformity is not so important (if there's even
    // anything to be uniform with!)

    // can we remove the whole time part?
    if (headStr !== undefined && (dateStr === '00:00:00' || dateStr === '00:00')) {
      dateStr = headStr;
      headStr = '';
    } else if (dateStr.length === 8) {
      // strip off seconds if they're zero (zero fractional seconds
      // are already omitted)
      // but we never remove minutes and leave just hours
      dateStr = dateStr.replace(/:00$/, '');
    }
  }
  if (headStr) {
    if (hover) {
      // hover puts it all on one line, so headPart works best up front
      // except for year headPart: turn this into "Jan 1, 2000" etc.
      if (tr === 'd') dateStr += ', ' + headStr;else dateStr = headStr + (dateStr ? ', ' + dateStr : '');
    } else {
      if (!ax._inCalcTicks || ax._prevDateHead !== headStr) {
        ax._prevDateHead = headStr;
        dateStr += '<br>' + headStr;
      } else {
        var isInside = insideTicklabelposition(ax);
        var side = ax._trueSide || ax.side; // polar mocks the side of the radial axis
        if (!isInside && side === 'top' || isInside && side === 'bottom') {
          dateStr += '<br> ';
        }
      }
    }
  }
  out.text = dateStr;
}
function formatLog(ax, out, hover, extraPrecision, hideexp) {
  var dtick = ax.dtick;
  var x = out.x;
  var tickformat = ax.tickformat;
  var dtChar0 = typeof dtick === 'string' && dtick.charAt(0);
  if (hideexp === 'never') {
    // If this is a hover label, then we must *never* hide the exponent
    // for the sake of display, which could give the wrong value by
    // potentially many orders of magnitude. If hideexp was 'never', then
    // it's now succeeded by preventing the other condition from automating
    // this choice. Thus we can unset it so that the axis formatting takes
    // precedence.
    hideexp = '';
  }
  if (extraPrecision && dtChar0 !== 'L') {
    dtick = 'L3';
    dtChar0 = 'L';
  }
  if (tickformat || dtChar0 === 'L') {
    out.text = numFormat(Math.pow(10, x), ax, hideexp, extraPrecision);
  } else if (isNumeric(dtick) || dtChar0 === 'D' && Lib.mod(x + 0.01, 1) < 0.1) {
    var p = Math.round(x);
    var absP = Math.abs(p);
    var exponentFormat = ax.exponentformat;
    if (exponentFormat === 'power' || isSIFormat(exponentFormat) && beyondSI(p)) {
      if (p === 0) out.text = 1;else if (p === 1) out.text = '10';else out.text = '10<sup>' + (p > 1 ? '' : MINUS_SIGN) + absP + '</sup>';
      out.fontSize *= 1.25;
    } else if ((exponentFormat === 'e' || exponentFormat === 'E') && absP > 2) {
      out.text = '1' + exponentFormat + (p > 0 ? '+' : MINUS_SIGN) + absP;
    } else {
      out.text = numFormat(Math.pow(10, x), ax, '', 'fakehover');
      if (dtick === 'D1' && ax._id.charAt(0) === 'y') {
        out.dy -= out.fontSize / 6;
      }
    }
  } else if (dtChar0 === 'D') {
    out.text = String(Math.round(Math.pow(10, Lib.mod(x, 1))));
    out.fontSize *= 0.75;
  } else throw 'unrecognized dtick ' + String(dtick);

  // if 9's are printed on log scale, move the 10's away a bit
  if (ax.dtick === 'D1') {
    var firstChar = String(out.text).charAt(0);
    if (firstChar === '0' || firstChar === '1') {
      if (ax._id.charAt(0) === 'y') {
        out.dx -= out.fontSize / 4;
      } else {
        out.dy += out.fontSize / 2;
        out.dx += (ax.range[1] > ax.range[0] ? 1 : -1) * out.fontSize * (x < 0 ? 0.5 : 0.25);
      }
    }
  }
}
function formatCategory(ax, out) {
  var tt = ax._categories[Math.round(out.x)];
  if (tt === undefined) tt = '';
  out.text = String(tt);
}
function formatMultiCategory(ax, out, hover) {
  var v = Math.round(out.x);
  var cats = ax._categories[v] || [];
  var tt = cats[1] === undefined ? '' : String(cats[1]);
  var tt2 = cats[0] === undefined ? '' : String(cats[0]);
  if (hover) {
    // TODO is this what we want?
    out.text = tt2 + ' - ' + tt;
  } else {
    // setup for secondary labels
    out.text = tt;
    out.text2 = tt2;
  }
}
function formatLinear(ax, out, hover, extraPrecision, hideexp) {
  if (hideexp === 'never') {
    // If this is a hover label, then we must *never* hide the exponent
    // for the sake of display, which could give the wrong value by
    // potentially many orders of magnitude. If hideexp was 'never', then
    // it's now succeeded by preventing the other condition from automating
    // this choice. Thus we can unset it so that the axis formatting takes
    // precedence.
    hideexp = '';
  } else if (ax.showexponent === 'all' && Math.abs(out.x / ax.dtick) < 1e-6) {
    // don't add an exponent to zero if we're showing all exponents
    // so the only reason you'd show an exponent on zero is if it's the
    // ONLY tick to get an exponent (first or last)
    hideexp = 'hide';
  }
  out.text = numFormat(out.x, ax, hideexp, extraPrecision);
}
function formatAngle(ax, out, hover, extraPrecision, hideexp) {
  if (ax.thetaunit === 'radians' && !hover) {
    var num = out.x / 180;
    if (num === 0) {
      out.text = '0';
    } else {
      var frac = num2frac(num);
      if (frac[1] >= 100) {
        out.text = numFormat(Lib.deg2rad(out.x), ax, hideexp, extraPrecision);
      } else {
        var isNeg = out.x < 0;
        if (frac[1] === 1) {
          if (frac[0] === 1) out.text = 'π';else out.text = frac[0] + 'π';
        } else {
          out.text = ['<sup>', frac[0], '</sup>', '⁄', '<sub>', frac[1], '</sub>', 'π'].join('');
        }
        if (isNeg) out.text = MINUS_SIGN + out.text;
      }
    }
  } else {
    out.text = numFormat(out.x, ax, hideexp, extraPrecision);
  }
}

// inspired by
// https://github.com/yisibl/num2fraction/blob/master/index.js
function num2frac(num) {
  function almostEq(a, b) {
    return Math.abs(a - b) <= 1e-6;
  }
  function findGCD(a, b) {
    return almostEq(b, 0) ? a : findGCD(b, a % b);
  }
  function findPrecision(n) {
    var e = 1;
    while (!almostEq(Math.round(n * e) / e, n)) {
      e *= 10;
    }
    return e;
  }
  var precision = findPrecision(num);
  var number = num * precision;
  var gcd = Math.abs(findGCD(number, precision));
  return [
  // numerator
  Math.round(number / gcd),
  // denominator
  Math.round(precision / gcd)];
}

// format a number (tick value) according to the axis settings
// new, more reliable procedure than d3.round or similar:
// add half the rounding increment, then stringify and truncate
// also automatically switch to sci. notation
var SIPREFIXES = ['f', 'p', 'n', 'μ', 'm', '', 'k', 'M', 'G', 'T'];
function isSIFormat(exponentFormat) {
  return exponentFormat === 'SI' || exponentFormat === 'B';
}

// are we beyond the range of common SI prefixes?
// 10^-16 -> 1x10^-16
// 10^-15 -> 1f
// ...
// 10^14 -> 100T
// 10^15 -> 1x10^15
// 10^16 -> 1x10^16
function beyondSI(exponent) {
  return exponent > 14 || exponent < -15;
}
function numFormat(v, ax, fmtoverride, hover) {
  var isNeg = v < 0;
  // max number of digits past decimal point to show
  var tickRound = ax._tickround;
  var exponentFormat = fmtoverride || ax.exponentformat || 'B';
  var exponent = ax._tickexponent;
  var tickformat = axes.getTickFormat(ax);
  var separatethousands = ax.separatethousands;

  // special case for hover: set exponent just for this value, and
  // add a couple more digits of precision over tick labels
  if (hover) {
    // make a dummy axis obj to get the auto rounding and exponent
    var ah = {
      exponentformat: exponentFormat,
      minexponent: ax.minexponent,
      dtick: ax.showexponent === 'none' ? ax.dtick : isNumeric(v) ? Math.abs(v) || 1 : 1,
      // if not showing any exponents, don't change the exponent
      // from what we calculate
      range: ax.showexponent === 'none' ? ax.range.map(ax.r2d) : [0, v || 1]
    };
    autoTickRound(ah);
    tickRound = (Number(ah._tickround) || 0) + 4;
    exponent = ah._tickexponent;
    if (ax.hoverformat) tickformat = ax.hoverformat;
  }
  if (tickformat) return ax._numFormat(tickformat)(v).replace(/-/g, MINUS_SIGN);

  // 'epsilon' - rounding increment
  var e = Math.pow(10, -tickRound) / 2;

  // exponentFormat codes:
  // 'e' (1.2e+6, default)
  // 'E' (1.2E+6)
  // 'SI' (1.2M)
  // 'B' (same as SI except 10^9=B not G)
  // 'none' (1200000)
  // 'power' (1.2x10^6)
  // 'hide' (1.2, use 3rd argument=='hide' to eg
  //      only show exponent on last tick)
  if (exponentFormat === 'none') exponent = 0;

  // take the sign out, put it back manually at the end
  // - makes cases easier
  v = Math.abs(v);
  if (v < e) {
    // 0 is just 0, but may get exponent if it's the last tick
    v = '0';
    isNeg = false;
  } else {
    v += e;
    // take out a common exponent, if any
    if (exponent) {
      v *= Math.pow(10, -exponent);
      tickRound += exponent;
    }
    // round the mantissa
    if (tickRound === 0) v = String(Math.floor(v));else if (tickRound < 0) {
      v = String(Math.round(v));
      v = v.substr(0, v.length + tickRound);
      for (var i = tickRound; i < 0; i++) v += '0';
    } else {
      v = String(v);
      var dp = v.indexOf('.') + 1;
      if (dp) v = v.substr(0, dp + tickRound).replace(/\.?0+$/, '');
    }
    // insert appropriate decimal point and thousands separator
    v = Lib.numSeparate(v, ax._separators, separatethousands);
  }

  // add exponent
  if (exponent && exponentFormat !== 'hide') {
    if (isSIFormat(exponentFormat) && beyondSI(exponent)) exponentFormat = 'power';
    var signedExponent;
    if (exponent < 0) signedExponent = MINUS_SIGN + -exponent;else if (exponentFormat !== 'power') signedExponent = '+' + exponent;else signedExponent = String(exponent);
    if (exponentFormat === 'e' || exponentFormat === 'E') {
      v += exponentFormat + signedExponent;
    } else if (exponentFormat === 'power') {
      v += '×10<sup>' + signedExponent + '</sup>';
    } else if (exponentFormat === 'B' && exponent === 9) {
      v += 'B';
    } else if (isSIFormat(exponentFormat)) {
      v += SIPREFIXES[exponent / 3 + 5];
    }
  }

  // put sign back in and return
  // replace standard minus character (which is technically a hyphen)
  // with a true minus sign
  if (isNeg) return MINUS_SIGN + v;
  return v;
}
axes.getTickFormat = function (ax) {
  var i;
  function convertToMs(dtick) {
    return typeof dtick !== 'string' ? dtick : Number(dtick.replace('M', '')) * ONEAVGMONTH;
  }
  function compareLogTicks(left, right) {
    var priority = ['L', 'D'];
    if (typeof left === typeof right) {
      if (typeof left === 'number') {
        return left - right;
      } else {
        var leftPriority = priority.indexOf(left.charAt(0));
        var rightPriority = priority.indexOf(right.charAt(0));
        if (leftPriority === rightPriority) {
          return Number(left.replace(/(L|D)/g, '')) - Number(right.replace(/(L|D)/g, ''));
        } else {
          return leftPriority - rightPriority;
        }
      }
    } else {
      return typeof left === 'number' ? 1 : -1;
    }
  }
  function isProperStop(dtick, range, convert) {
    var convertFn = convert || function (x) {
      return x;
    };
    var leftDtick = range[0];
    var rightDtick = range[1];
    return (!leftDtick && typeof leftDtick !== 'number' || convertFn(leftDtick) <= convertFn(dtick)) && (!rightDtick && typeof rightDtick !== 'number' || convertFn(rightDtick) >= convertFn(dtick));
  }
  function isProperLogStop(dtick, range) {
    var isLeftDtickNull = range[0] === null;
    var isRightDtickNull = range[1] === null;
    var isDtickInRangeLeft = compareLogTicks(dtick, range[0]) >= 0;
    var isDtickInRangeRight = compareLogTicks(dtick, range[1]) <= 0;
    return (isLeftDtickNull || isDtickInRangeLeft) && (isRightDtickNull || isDtickInRangeRight);
  }
  var tickstop, stopi;
  if (ax.tickformatstops && ax.tickformatstops.length > 0) {
    switch (ax.type) {
      case 'date':
      case 'linear':
        {
          for (i = 0; i < ax.tickformatstops.length; i++) {
            stopi = ax.tickformatstops[i];
            if (stopi.enabled && isProperStop(ax.dtick, stopi.dtickrange, convertToMs)) {
              tickstop = stopi;
              break;
            }
          }
          break;
        }
      case 'log':
        {
          for (i = 0; i < ax.tickformatstops.length; i++) {
            stopi = ax.tickformatstops[i];
            if (stopi.enabled && isProperLogStop(ax.dtick, stopi.dtickrange)) {
              tickstop = stopi;
              break;
            }
          }
          break;
        }
      default:
    }
  }
  return tickstop ? tickstop.value : ax.tickformat;
};

// getSubplots - extract all subplot IDs we need
// as an array of items like 'xy', 'x2y', 'x2y2'...
// sorted by x (x,x2,x3...) then y
// optionally restrict to only subplots containing axis object ax
//
// NOTE: this is currently only used OUTSIDE plotly.js (toolpanel, webapp)
// ideally we get rid of it there (or just copy this there) and remove it here
axes.getSubplots = function (gd, ax) {
  var subplotObj = gd._fullLayout._subplots;
  var allSubplots = subplotObj.cartesian.concat(subplotObj.gl2d || []);
  var out = ax ? axes.findSubplotsWithAxis(allSubplots, ax) : allSubplots;
  out.sort(function (a, b) {
    var aParts = a.substr(1).split('y');
    var bParts = b.substr(1).split('y');
    if (aParts[0] === bParts[0]) return +aParts[1] - +bParts[1];
    return +aParts[0] - +bParts[0];
  });
  return out;
};

// find all subplots with axis 'ax'
// NOTE: this is only used in axes.getSubplots (only used outside plotly.js) and
// gl2d/convert (where it restricts axis subplots to only those with gl2d)
axes.findSubplotsWithAxis = function (subplots, ax) {
  var axMatch = new RegExp(ax._id.charAt(0) === 'x' ? '^' + ax._id + 'y' : ax._id + '$');
  var subplotsWithAx = [];
  for (var i = 0; i < subplots.length; i++) {
    var sp = subplots[i];
    if (axMatch.test(sp)) subplotsWithAx.push(sp);
  }
  return subplotsWithAx;
};

// makeClipPaths: prepare clipPaths for all single axes and all possible xy pairings
axes.makeClipPaths = function (gd) {
  var fullLayout = gd._fullLayout;

  // for more info: https://github.com/plotly/plotly.js/issues/2595
  if (fullLayout._hasOnlyLargeSploms) return;
  var fullWidth = {
    _offset: 0,
    _length: fullLayout.width,
    _id: ''
  };
  var fullHeight = {
    _offset: 0,
    _length: fullLayout.height,
    _id: ''
  };
  var xaList = axes.list(gd, 'x', true);
  var yaList = axes.list(gd, 'y', true);
  var clipList = [];
  var i, j;
  for (i = 0; i < xaList.length; i++) {
    clipList.push({
      x: xaList[i],
      y: fullHeight
    });
    for (j = 0; j < yaList.length; j++) {
      if (i === 0) clipList.push({
        x: fullWidth,
        y: yaList[j]
      });
      clipList.push({
        x: xaList[i],
        y: yaList[j]
      });
    }
  }

  // selectors don't work right with camelCase tags,
  // have to use class instead
  // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I
  var axClips = fullLayout._clips.selectAll('.axesclip').data(clipList, function (d) {
    return d.x._id + d.y._id;
  });
  axClips.enter().append('clipPath').classed('axesclip', true).attr('id', function (d) {
    return 'clip' + fullLayout._uid + d.x._id + d.y._id;
  }).append('rect');
  axClips.exit().remove();
  axClips.each(function (d) {
    d3.select(this).select('rect').attr({
      x: d.x._offset || 0,
      y: d.y._offset || 0,
      width: d.x._length || 1,
      height: d.y._length || 1
    });
  });
};

/**
 * Main multi-axis drawing routine!
 *
 * @param {DOM element} gd : graph div
 * @param {string or array of strings} arg : polymorphic argument
 * @param {object} opts:
 * - @param {boolean} skipTitle : optional flag to skip axis title draw/update
 *
 * Signature 1: Axes.draw(gd, 'redraw')
 *   use this to clear and redraw all axes on graph
 *
 * Signature 2: Axes.draw(gd, '')
 *   use this to draw all axes on graph w/o the selectAll().remove()
 *   of the 'redraw' signature
 *
 * Signature 3: Axes.draw(gd, [axId, axId2, ...])
 *   where the items are axis id string,
 *   use this to update multiple axes in one call
 *
 * N.B draw updates:
 * - ax._r (stored range for use by zoom/pan)
 * - ax._rl (stored linearized range for use by zoom/pan)
 */
axes.draw = function (gd, arg, opts) {
  var fullLayout = gd._fullLayout;
  if (arg === 'redraw') {
    fullLayout._paper.selectAll('g.subplot').each(function (d) {
      var id = d[0];
      var plotinfo = fullLayout._plots[id];
      if (plotinfo) {
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick').remove();
        plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick').remove();
        plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick2').remove();
        plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick2').remove();
        plotinfo.xaxislayer.selectAll('.' + xa._id + 'divider').remove();
        plotinfo.yaxislayer.selectAll('.' + ya._id + 'divider').remove();
        if (plotinfo.minorGridlayer) plotinfo.minorGridlayer.selectAll('path').remove();
        if (plotinfo.gridlayer) plotinfo.gridlayer.selectAll('path').remove();
        if (plotinfo.zerolinelayer) plotinfo.zerolinelayer.selectAll('path').remove();
        fullLayout._infolayer.select('.g-' + xa._id + 'title').remove();
        fullLayout._infolayer.select('.g-' + ya._id + 'title').remove();
      }
    });
  }
  var axList = !arg || arg === 'redraw' ? axes.listIds(gd) : arg;
  var fullAxList = axes.list(gd);
  // Get the list of the overlaying axis for all 'shift' axes
  var overlayingShiftedAx = fullAxList.filter(function (ax) {
    return ax.autoshift;
  }).map(function (ax) {
    return ax.overlaying;
  });

  // order axes that have dependency to other axes
  axList.map(function (axId) {
    var ax = axes.getFromId(gd, axId);
    if (ax.tickmode === 'sync' && ax.overlaying) {
      var overlayingIndex = axList.findIndex(function (axis) {
        return axis === ax.overlaying;
      });
      if (overlayingIndex >= 0) {
        axList.unshift(axList.splice(overlayingIndex, 1).shift());
      }
    }
  });
  var axShifts = {
    false: {
      left: 0,
      right: 0
    }
  };
  return Lib.syncOrAsync(axList.map(function (axId) {
    return function () {
      if (!axId) return;
      var ax = axes.getFromId(gd, axId);
      if (!opts) opts = {};
      opts.axShifts = axShifts;
      opts.overlayingShiftedAx = overlayingShiftedAx;
      var axDone = axes.drawOne(gd, ax, opts);
      if (ax._shiftPusher) {
        incrementShift(ax, ax._fullDepth || 0, axShifts, true);
      }
      ax._r = ax.range.slice();
      ax._rl = Lib.simpleMap(ax._r, ax.r2l);
      return axDone;
    };
  }));
};

/**
 * Draw one cartesian axis
 *
 * @param {DOM element} gd
 * @param {object} ax (full) axis object
 * @param {object} opts
 * - @param {boolean} skipTitle (set to true to skip axis title draw call)
 *
 * Depends on:
 * - ax._mainSubplot (from linkSubplots)
 * - ax._mainAxis
 * - ax._anchorAxis
 * - ax._subplotsWith
 * - ax._counterDomainMin, ax._counterDomainMax (optionally, from linkSubplots)
 * - ax._tickAngles (on redraw only, old value relinked during supplyDefaults)
 * - ax._mainLinePosition (from lsInner)
 * - ax._mainMirrorPosition
 * - ax._linepositions
 *
 * Fills in:
 * - ax._vals:
 * - ax._gridVals:
 * - ax._selections:
 * - ax._tickAngles:
 * - ax._depth (when required only):
 * - and calls ax.setScale
 */
axes.drawOne = function (gd, ax, opts) {
  opts = opts || {};
  var axShifts = opts.axShifts || {};
  var overlayingShiftedAx = opts.overlayingShiftedAx || [];
  var i, sp, plotinfo;
  ax.setScale();
  var fullLayout = gd._fullLayout;
  var axId = ax._id;
  var axLetter = axId.charAt(0);
  var counterLetter = axes.counterLetter(axId);
  var mainPlotinfo = fullLayout._plots[ax._mainSubplot];

  // this happens when updating matched group with 'missing' axes
  if (!mainPlotinfo) return;
  ax._shiftPusher = ax.autoshift || overlayingShiftedAx.indexOf(ax._id) !== -1 || overlayingShiftedAx.indexOf(ax.overlaying) !== -1;
  // An axis is also shifted by 1/2 of its own linewidth and inside tick length if applicable
  // as well as its manually specified `shift` val if we're in the context of `autoshift`
  if (ax._shiftPusher & ax.anchor === 'free') {
    var selfPush = ax.linewidth / 2 || 0;
    if (ax.ticks === 'inside') {
      selfPush += ax.ticklen;
    }
    incrementShift(ax, selfPush, axShifts, true);
    incrementShift(ax, ax.shift || 0, axShifts, false);
  }

  // Somewhat inelegant way of making sure that the shift value is only updated when the
  // Axes.DrawOne() function is called from the right context. An issue when redrawing the
  // axis as result of using the dragbox, for example.
  if (opts.skipTitle !== true || ax._shift === undefined) ax._shift = setShiftVal(ax, axShifts);
  var mainAxLayer = mainPlotinfo[axLetter + 'axislayer'];
  var mainLinePosition = ax._mainLinePosition;
  var mainLinePositionShift = mainLinePosition += ax._shift;
  var mainMirrorPosition = ax._mainMirrorPosition;
  var vals = ax._vals = axes.calcTicks(ax);

  // Add a couple of axis properties that should cause us to recreate
  // elements. Used in d3 data function.
  var axInfo = [ax.mirror, mainLinePositionShift, mainMirrorPosition].join('_');
  for (i = 0; i < vals.length; i++) {
    vals[i].axInfo = axInfo;
  }

  // stash selections to avoid DOM queries e.g.
  // - stash tickLabels selection, so that drawTitle can use it to scoot title
  ax._selections = {};
  // stash tick angle (including the computed 'auto' values) per tick-label class
  // linkup 'previous' tick angles on redraws
  if (ax._tickAngles) ax._prevTickAngles = ax._tickAngles;
  ax._tickAngles = {};
  // measure [in px] between axis position and outward-most part of bounding box
  // (touching either the tick label or ticks)
  // depth can be expansive to compute, so we only do so when required
  ax._depth = null;

  // calcLabelLevelBbox can be expensive,
  // so make sure to not call it twice during the same Axes.drawOne call
  // by stashing label-level bounding boxes per tick-label class
  var llbboxes = {};
  function getLabelLevelBbox(suffix) {
    var cls = axId + (suffix || 'tick');
    if (!llbboxes[cls]) llbboxes[cls] = calcLabelLevelBbox(ax, cls);
    return llbboxes[cls];
  }
  if (!ax.visible) return;
  var transTickFn = axes.makeTransTickFn(ax);
  var transTickLabelFn = axes.makeTransTickLabelFn(ax);
  var tickVals;
  // We remove zero lines, grid lines, and inside ticks if they're within 1px of the end
  // The key case here is removing zero lines when the axis bound is zero
  var valsClipped;
  var insideTicks = ax.ticks === 'inside';
  var outsideTicks = ax.ticks === 'outside';
  if (ax.tickson === 'boundaries') {
    var boundaryVals = getBoundaryVals(ax, vals);
    valsClipped = axes.clipEnds(ax, boundaryVals);
    tickVals = insideTicks ? valsClipped : boundaryVals;
  } else {
    valsClipped = axes.clipEnds(ax, vals);
    tickVals = insideTicks && ax.ticklabelmode !== 'period' ? valsClipped : vals;
  }
  var gridVals = ax._gridVals = valsClipped;
  var dividerVals = getDividerVals(ax, vals);
  if (!fullLayout._hasOnlyLargeSploms) {
    var subplotsWithAx = ax._subplotsWith;

    // keep track of which subplots (by main counter axis) we've already
    // drawn grids for, so we don't overdraw overlaying subplots
    var finishedGrids = {};
    for (i = 0; i < subplotsWithAx.length; i++) {
      sp = subplotsWithAx[i];
      plotinfo = fullLayout._plots[sp];
      var counterAxis = plotinfo[counterLetter + 'axis'];
      var mainCounterID = counterAxis._mainAxis._id;
      if (finishedGrids[mainCounterID]) continue;
      finishedGrids[mainCounterID] = 1;
      var gridPath = axLetter === 'x' ? 'M0,' + counterAxis._offset + 'v' + counterAxis._length : 'M' + counterAxis._offset + ',0h' + counterAxis._length;
      axes.drawGrid(gd, ax, {
        vals: gridVals,
        counterAxis: counterAxis,
        layer: plotinfo.gridlayer.select('.' + axId),
        minorLayer: plotinfo.minorGridlayer.select('.' + axId),
        path: gridPath,
        transFn: transTickFn
      });
      axes.drawZeroLine(gd, ax, {
        counterAxis: counterAxis,
        layer: plotinfo.zerolinelayer,
        path: gridPath,
        transFn: transTickFn
      });
    }
  }
  var tickPath;
  var majorTickSigns = axes.getTickSigns(ax);
  var minorTickSigns = axes.getTickSigns(ax, 'minor');
  if (ax.ticks || ax.minor && ax.minor.ticks) {
    var majorTickPath = axes.makeTickPath(ax, mainLinePositionShift, majorTickSigns[2]);
    var minorTickPath = axes.makeTickPath(ax, mainLinePositionShift, minorTickSigns[2], {
      minor: true
    });
    var mirrorMajorTickPath;
    var mirrorMinorTickPath;
    var fullMajorTickPath;
    var fullMinorTickPath;
    if (ax._anchorAxis && ax.mirror && ax.mirror !== true) {
      mirrorMajorTickPath = axes.makeTickPath(ax, mainMirrorPosition, majorTickSigns[3]);
      mirrorMinorTickPath = axes.makeTickPath(ax, mainMirrorPosition, minorTickSigns[3], {
        minor: true
      });
      fullMajorTickPath = majorTickPath + mirrorMajorTickPath;
      fullMinorTickPath = minorTickPath + mirrorMinorTickPath;
    } else {
      mirrorMajorTickPath = '';
      mirrorMinorTickPath = '';
      fullMajorTickPath = majorTickPath;
      fullMinorTickPath = minorTickPath;
    }
    if (ax.showdividers && outsideTicks && ax.tickson === 'boundaries') {
      var dividerLookup = {};
      for (i = 0; i < dividerVals.length; i++) {
        dividerLookup[dividerVals[i].x] = 1;
      }
      tickPath = function (d) {
        return dividerLookup[d.x] ? mirrorMajorTickPath : fullMajorTickPath;
      };
    } else {
      tickPath = function (d) {
        return d.minor ? fullMinorTickPath : fullMajorTickPath;
      };
    }
  }
  axes.drawTicks(gd, ax, {
    vals: tickVals,
    layer: mainAxLayer,
    path: tickPath,
    transFn: transTickFn
  });
  if (ax.mirror === 'allticks') {
    var tickSubplots = Object.keys(ax._linepositions || {});
    for (i = 0; i < tickSubplots.length; i++) {
      sp = tickSubplots[i];
      plotinfo = fullLayout._plots[sp];
      // [bottom or left, top or right], free and main are handled above
      var linepositions = ax._linepositions[sp] || [];
      var p0 = linepositions[0];
      var p1 = linepositions[1];
      var isMinor = linepositions[2];
      var spTickPath = axes.makeTickPath(ax, p0, isMinor ? majorTickSigns[0] : minorTickSigns[0], {
        minor: isMinor
      }) + axes.makeTickPath(ax, p1, isMinor ? majorTickSigns[1] : minorTickSigns[1], {
        minor: isMinor
      });
      axes.drawTicks(gd, ax, {
        vals: tickVals,
        layer: plotinfo[axLetter + 'axislayer'],
        path: spTickPath,
        transFn: transTickFn
      });
    }
  }
  var seq = [];

  // tick labels - for now just the main labels.
  // TODO: mirror labels, esp for subplots

  seq.push(function () {
    return axes.drawLabels(gd, ax, {
      vals: vals,
      layer: mainAxLayer,
      plotinfo: plotinfo,
      transFn: transTickLabelFn,
      labelFns: axes.makeLabelFns(ax, mainLinePositionShift)
    });
  });
  if (ax.type === 'multicategory') {
    var pad = {
      x: 2,
      y: 10
    }[axLetter];
    seq.push(function () {
      var bboxKey = {
        x: 'height',
        y: 'width'
      }[axLetter];
      var standoff = getLabelLevelBbox()[bboxKey] + pad + (ax._tickAngles[axId + 'tick'] ? ax.tickfont.size * LINE_SPACING : 0);
      return axes.drawLabels(gd, ax, {
        vals: getSecondaryLabelVals(ax, vals),
        layer: mainAxLayer,
        cls: axId + 'tick2',
        repositionOnUpdate: true,
        secondary: true,
        transFn: transTickFn,
        labelFns: axes.makeLabelFns(ax, mainLinePositionShift + standoff * majorTickSigns[4])
      });
    });
    seq.push(function () {
      ax._depth = majorTickSigns[4] * (getLabelLevelBbox('tick2')[ax.side] - mainLinePositionShift);
      return drawDividers(gd, ax, {
        vals: dividerVals,
        layer: mainAxLayer,
        path: axes.makeTickPath(ax, mainLinePositionShift, majorTickSigns[4], {
          len: ax._depth
        }),
        transFn: transTickFn
      });
    });
  } else if (ax.title.hasOwnProperty('standoff')) {
    seq.push(function () {
      ax._depth = majorTickSigns[4] * (getLabelLevelBbox()[ax.side] - mainLinePositionShift);
    });
  }
  var hasRangeSlider = Registry.getComponentMethod('rangeslider', 'isVisible')(ax);
  if (!opts.skipTitle && !(hasRangeSlider && ax.side === 'bottom')) {
    seq.push(function () {
      return drawTitle(gd, ax);
    });
  }
  seq.push(function () {
    var s = ax.side.charAt(0);
    var sMirror = OPPOSITE_SIDE[ax.side].charAt(0);
    var pos = axes.getPxPosition(gd, ax);
    var outsideTickLen = outsideTicks ? ax.ticklen : 0;
    var llbbox;
    var push;
    var mirrorPush;
    var rangeSliderPush;
    if (ax.automargin || hasRangeSlider || ax._shiftPusher) {
      if (ax.type === 'multicategory') {
        llbbox = getLabelLevelBbox('tick2');
      } else {
        llbbox = getLabelLevelBbox();
        if (axLetter === 'x' && s === 'b') {
          ax._depth = Math.max(llbbox.width > 0 ? llbbox.bottom - pos : 0, outsideTickLen);
        }
      }
    }
    var axDepth = 0;
    var titleDepth = 0;
    if (ax._shiftPusher) {
      axDepth = Math.max(outsideTickLen, llbbox.height > 0 ? s === 'l' ? pos - llbbox.left : llbbox.right - pos : 0);
      if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {
        titleDepth = (ax._titleStandoff || 0) + (ax._titleScoot || 0);
        if (s === 'l') {
          titleDepth += approxTitleDepth(ax);
        }
      }
      ax._fullDepth = Math.max(axDepth, titleDepth);
    }
    if (ax.automargin) {
      push = {
        x: 0,
        y: 0,
        r: 0,
        l: 0,
        t: 0,
        b: 0
      };
      var domainIndices = [0, 1];
      var shift = typeof ax._shift === 'number' ? ax._shift : 0;
      if (axLetter === 'x') {
        if (s === 'b') {
          push[s] = ax._depth;
        } else {
          push[s] = ax._depth = Math.max(llbbox.width > 0 ? pos - llbbox.top : 0, outsideTickLen);
          domainIndices.reverse();
        }
        if (llbbox.width > 0) {
          var rExtra = llbbox.right - (ax._offset + ax._length);
          if (rExtra > 0) {
            push.xr = 1;
            push.r = rExtra;
          }
          var lExtra = ax._offset - llbbox.left;
          if (lExtra > 0) {
            push.xl = 0;
            push.l = lExtra;
          }
        }
      } else {
        if (s === 'l') {
          ax._depth = Math.max(llbbox.height > 0 ? pos - llbbox.left : 0, outsideTickLen);
          push[s] = ax._depth - shift;
        } else {
          ax._depth = Math.max(llbbox.height > 0 ? llbbox.right - pos : 0, outsideTickLen);
          push[s] = ax._depth + shift;
          domainIndices.reverse();
        }
        if (llbbox.height > 0) {
          var bExtra = llbbox.bottom - (ax._offset + ax._length);
          if (bExtra > 0) {
            push.yb = 0;
            push.b = bExtra;
          }
          var tExtra = ax._offset - llbbox.top;
          if (tExtra > 0) {
            push.yt = 1;
            push.t = tExtra;
          }
        }
      }
      push[counterLetter] = ax.anchor === 'free' ? ax.position : ax._anchorAxis.domain[domainIndices[0]];
      if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {
        push[s] += approxTitleDepth(ax) + (ax.title.standoff || 0);
      }
      if (ax.mirror && ax.anchor !== 'free') {
        mirrorPush = {
          x: 0,
          y: 0,
          r: 0,
          l: 0,
          t: 0,
          b: 0
        };
        mirrorPush[sMirror] = ax.linewidth;
        if (ax.mirror && ax.mirror !== true) mirrorPush[sMirror] += outsideTickLen;
        if (ax.mirror === true || ax.mirror === 'ticks') {
          mirrorPush[counterLetter] = ax._anchorAxis.domain[domainIndices[1]];
        } else if (ax.mirror === 'all' || ax.mirror === 'allticks') {
          mirrorPush[counterLetter] = [ax._counterDomainMin, ax._counterDomainMax][domainIndices[1]];
        }
      }
    }
    if (hasRangeSlider) {
      rangeSliderPush = Registry.getComponentMethod('rangeslider', 'autoMarginOpts')(gd, ax);
    }
    if (typeof ax.automargin === 'string') {
      filterPush(push, ax.automargin);
      filterPush(mirrorPush, ax.automargin);
    }
    Plots.autoMargin(gd, axAutoMarginID(ax), push);
    Plots.autoMargin(gd, axMirrorAutoMarginID(ax), mirrorPush);
    Plots.autoMargin(gd, rangeSliderAutoMarginID(ax), rangeSliderPush);
  });
  return Lib.syncOrAsync(seq);
};
function filterPush(push, automargin) {
  if (!push) return;
  var keepMargin = Object.keys(MARGIN_MAPPING).reduce(function (data, nextKey) {
    if (automargin.indexOf(nextKey) !== -1) {
      MARGIN_MAPPING[nextKey].forEach(function (key) {
        data[key] = 1;
      });
    }
    return data;
  }, {});
  Object.keys(push).forEach(function (key) {
    if (!keepMargin[key]) {
      if (key.length === 1) push[key] = 0;else delete push[key];
    }
  });
}
function getBoundaryVals(ax, vals) {
  var out = [];
  var i;

  // boundaryVals are never used for labels;
  // no need to worry about the other tickTextObj keys
  var _push = function (d, bndIndex) {
    var xb = d.xbnd[bndIndex];
    if (xb !== null) {
      out.push(Lib.extendFlat({}, d, {
        x: xb
      }));
    }
  };
  if (vals.length) {
    for (i = 0; i < vals.length; i++) {
      _push(vals[i], 0);
    }
    _push(vals[i - 1], 1);
  }
  return out;
}
function getSecondaryLabelVals(ax, vals) {
  var out = [];
  var lookup = {};
  for (var i = 0; i < vals.length; i++) {
    var d = vals[i];
    if (lookup[d.text2]) {
      lookup[d.text2].push(d.x);
    } else {
      lookup[d.text2] = [d.x];
    }
  }
  for (var k in lookup) {
    out.push(tickTextObj(ax, Lib.interp(lookup[k], 0.5), k));
  }
  return out;
}
function getDividerVals(ax, vals) {
  var out = [];
  var i, current;
  var reversed = vals.length && vals[vals.length - 1].x < vals[0].x;

  // never used for labels;
  // no need to worry about the other tickTextObj keys
  var _push = function (d, bndIndex) {
    var xb = d.xbnd[bndIndex];
    if (xb !== null) {
      out.push(Lib.extendFlat({}, d, {
        x: xb
      }));
    }
  };
  if (ax.showdividers && vals.length) {
    for (i = 0; i < vals.length; i++) {
      var d = vals[i];
      if (d.text2 !== current) {
        _push(d, reversed ? 1 : 0);
      }
      current = d.text2;
    }
    _push(vals[i - 1], reversed ? 0 : 1);
  }
  return out;
}
function calcLabelLevelBbox(ax, cls) {
  var top, bottom;
  var left, right;
  if (ax._selections[cls].size()) {
    top = Infinity;
    bottom = -Infinity;
    left = Infinity;
    right = -Infinity;
    ax._selections[cls].each(function () {
      var thisLabel = selectTickLabel(this);
      // Use parent node <g.(x|y)tick>, to make Drawing.bBox
      // retrieve a bbox computed with transform info
      //
      // To improve perf, it would be nice to use `thisLabel.node()`
      // (like in fixLabelOverlaps) instead and use Axes.getPxPosition
      // together with the makeLabelFns outputs and `tickangle`
      // to compute one bbox per (tick value x tick style)
      var bb = Drawing.bBox(thisLabel.node().parentNode);
      top = Math.min(top, bb.top);
      bottom = Math.max(bottom, bb.bottom);
      left = Math.min(left, bb.left);
      right = Math.max(right, bb.right);
    });
  } else {
    top = 0;
    bottom = 0;
    left = 0;
    right = 0;
  }
  return {
    top: top,
    bottom: bottom,
    left: left,
    right: right,
    height: bottom - top,
    width: right - left
  };
}

/**
 * Which direction do the 'ax.side' values, and free ticks go?
 *
 * @param {object} ax (full) axis object
 *  - {string} _id (starting with 'x' or 'y')
 *  - {string} side
 *  - {string} ticks
 * @return {array} all entries are either -1 or 1
 *  - [0]: sign for top/right ticks (i.e. negative SVG direction)
 *  - [1]: sign for bottom/left ticks (i.e. positive SVG direction)
 *  - [2]: sign for ticks corresponding to 'ax.side'
 *  - [3]: sign for ticks mirroring 'ax.side'
 *  - [4]: sign of arrow starting at axis pointing towards margin
 */
axes.getTickSigns = function (ax, minor) {
  var axLetter = ax._id.charAt(0);
  var sideOpposite = {
    x: 'top',
    y: 'right'
  }[axLetter];
  var main = ax.side === sideOpposite ? 1 : -1;
  var out = [-1, 1, main, -main];
  // then we flip if outside XOR y axis

  var ticks = minor ? (ax.minor || {}).ticks : ax.ticks;
  if (ticks !== 'inside' === (axLetter === 'x')) {
    out = out.map(function (v) {
      return -v;
    });
  }
  // independent of `ticks`; do not flip this one
  if (ax.side) {
    out.push({
      l: -1,
      t: -1,
      r: 1,
      b: 1
    }[ax.side.charAt(0)]);
  }
  return out;
};

/**
 * Make axis translate transform function
 *
 * @param {object} ax (full) axis object
 *  - {string} _id
 *  - {number} _offset
 *  - {fn} l2p
 * @return {fn} function of calcTicks items
 */
axes.makeTransTickFn = function (ax) {
  return ax._id.charAt(0) === 'x' ? function (d) {
    return strTranslate(ax._offset + ax.l2p(d.x), 0);
  } : function (d) {
    return strTranslate(0, ax._offset + ax.l2p(d.x));
  };
};
axes.makeTransTickLabelFn = function (ax) {
  var uv = getTickLabelUV(ax);
  var u = uv[0];
  var v = uv[1];
  return ax._id.charAt(0) === 'x' ? function (d) {
    return strTranslate(u + ax._offset + ax.l2p(getPosX(d)), v);
  } : function (d) {
    return strTranslate(v, u + ax._offset + ax.l2p(getPosX(d)));
  };
};
function getPosX(d) {
  return d.periodX !== undefined ? d.periodX : d.x;
}

// u is a shift along the axis,
// v is a shift perpendicular to the axis
function getTickLabelUV(ax) {
  var ticklabelposition = ax.ticklabelposition || '';
  var has = function (str) {
    return ticklabelposition.indexOf(str) !== -1;
  };
  var isTop = has('top');
  var isLeft = has('left');
  var isRight = has('right');
  var isBottom = has('bottom');
  var isInside = has('inside');
  var isAligned = isBottom || isLeft || isTop || isRight;

  // early return
  if (!isAligned && !isInside) return [0, 0];
  var side = ax.side;
  var u = isAligned ? (ax.tickwidth || 0) / 2 : 0;
  var v = TEXTPAD;
  var fontSize = ax.tickfont ? ax.tickfont.size : 12;
  if (isBottom || isTop) {
    u += fontSize * CAP_SHIFT;
    v += (ax.linewidth || 0) / 2;
  }
  if (isLeft || isRight) {
    u += (ax.linewidth || 0) / 2;
    v += TEXTPAD;
  }
  if (isInside && side === 'top') {
    v -= fontSize * (1 - CAP_SHIFT);
  }
  if (isLeft || isTop) u = -u;
  if (side === 'bottom' || side === 'right') v = -v;
  return [isAligned ? u : 0, isInside ? v : 0];
}

/**
 * Make axis tick path string
 *
 * @param {object} ax (full) axis object
 *  - {string} _id
 *  - {number} ticklen
 *  - {number} linewidth
 * @param {number} shift along direction of ticklen
 * @param {1 or -1} sgn tick sign
 * @param {object} opts
 * - {number (optional)} len tick length
 * @return {string}
 */
axes.makeTickPath = function (ax, shift, sgn, opts) {
  if (!opts) opts = {};
  var minor = opts.minor;
  if (minor && !ax.minor) return '';
  var len = opts.len !== undefined ? opts.len : minor ? ax.minor.ticklen : ax.ticklen;
  var axLetter = ax._id.charAt(0);
  var pad = (ax.linewidth || 1) / 2;
  return axLetter === 'x' ? 'M0,' + (shift + pad * sgn) + 'v' + len * sgn : 'M' + (shift + pad * sgn) + ',0h' + len * sgn;
};

/**
 * Make axis tick label x, y and anchor functions
 *
 * @param {object} ax (full) axis object
 *  - {string} _id
 *  - {string} ticks
 *  - {number} ticklen
 *  - {string} side
 *  - {number} linewidth
 *  - {number} tickfont.size
 *  - {boolean} showline
 * @param {number} shift
 * @param {number} angle [in degrees] ...
 * @return {object}
 *  - {fn} xFn
 *  - {fn} yFn
 *  - {fn} anchorFn
 *  - {fn} heightFn
 *  - {number} labelStandoff (gap parallel to ticks)
 *  - {number} labelShift (gap perpendicular to ticks)
 */
axes.makeLabelFns = function (ax, shift, angle) {
  var ticklabelposition = ax.ticklabelposition || '';
  var has = function (str) {
    return ticklabelposition.indexOf(str) !== -1;
  };
  var isTop = has('top');
  var isLeft = has('left');
  var isRight = has('right');
  var isBottom = has('bottom');
  var isAligned = isBottom || isLeft || isTop || isRight;
  var insideTickLabels = has('inside');
  var labelsOverTicks = ticklabelposition === 'inside' && ax.ticks === 'inside' || !insideTickLabels && ax.ticks === 'outside' && ax.tickson !== 'boundaries';
  var labelStandoff = 0;
  var labelShift = 0;
  var tickLen = labelsOverTicks ? ax.ticklen : 0;
  if (insideTickLabels) {
    tickLen *= -1;
  } else if (isAligned) {
    tickLen = 0;
  }
  if (labelsOverTicks) {
    labelStandoff += tickLen;
    if (angle) {
      var rad = Lib.deg2rad(angle);
      labelStandoff = tickLen * Math.cos(rad) + 1;
      labelShift = tickLen * Math.sin(rad);
    }
  }
  if (ax.showticklabels && (labelsOverTicks || ax.showline)) {
    labelStandoff += 0.2 * ax.tickfont.size;
  }
  labelStandoff += (ax.linewidth || 1) / 2 * (insideTickLabels ? -1 : 1);
  var out = {
    labelStandoff: labelStandoff,
    labelShift: labelShift
  };
  var x0, y0, ff, flipIt;
  var xQ = 0;
  var side = ax.side;
  var axLetter = ax._id.charAt(0);
  var tickangle = ax.tickangle;
  var endSide;
  if (axLetter === 'x') {
    endSide = !insideTickLabels && side === 'bottom' || insideTickLabels && side === 'top';
    flipIt = endSide ? 1 : -1;
    if (insideTickLabels) flipIt *= -1;
    x0 = labelShift * flipIt;
    y0 = shift + labelStandoff * flipIt;
    ff = endSide ? 1 : -0.2;
    if (Math.abs(tickangle) === 90) {
      if (insideTickLabels) {
        ff += MID_SHIFT;
      } else {
        if (tickangle === -90 && side === 'bottom') {
          ff = CAP_SHIFT;
        } else if (tickangle === 90 && side === 'top') {
          ff = MID_SHIFT;
        } else {
          ff = 0.5;
        }
      }
      xQ = MID_SHIFT / 2 * (tickangle / 90);
    }
    out.xFn = function (d) {
      return d.dx + x0 + xQ * d.fontSize;
    };
    out.yFn = function (d) {
      return d.dy + y0 + d.fontSize * ff;
    };
    out.anchorFn = function (d, a) {
      if (isAligned) {
        if (isLeft) return 'end';
        if (isRight) return 'start';
      }
      if (!isNumeric(a) || a === 0 || a === 180) {
        return 'middle';
      }
      return a * flipIt < 0 !== insideTickLabels ? 'end' : 'start';
    };
    out.heightFn = function (d, a, h) {
      return a < -60 || a > 60 ? -0.5 * h : ax.side === 'top' !== insideTickLabels ? -h : 0;
    };
  } else if (axLetter === 'y') {
    endSide = !insideTickLabels && side === 'left' || insideTickLabels && side === 'right';
    flipIt = endSide ? 1 : -1;
    if (insideTickLabels) flipIt *= -1;
    x0 = labelStandoff;
    y0 = labelShift * flipIt;
    ff = 0;
    if (!insideTickLabels && Math.abs(tickangle) === 90) {
      if (tickangle === -90 && side === 'left' || tickangle === 90 && side === 'right') {
        ff = CAP_SHIFT;
      } else {
        ff = 0.5;
      }
    }
    if (insideTickLabels) {
      var ang = isNumeric(tickangle) ? +tickangle : 0;
      if (ang !== 0) {
        var rA = Lib.deg2rad(ang);
        xQ = Math.abs(Math.sin(rA)) * CAP_SHIFT * flipIt;
        ff = 0;
      }
    }
    out.xFn = function (d) {
      return d.dx + shift - (x0 + d.fontSize * ff) * flipIt + xQ * d.fontSize;
    };
    out.yFn = function (d) {
      return d.dy + y0 + d.fontSize * MID_SHIFT;
    };
    out.anchorFn = function (d, a) {
      if (isNumeric(a) && Math.abs(a) === 90) {
        return 'middle';
      }
      return endSide ? 'end' : 'start';
    };
    out.heightFn = function (d, a, h) {
      if (ax.side === 'right') a *= -1;
      return a < -30 ? -h : a < 30 ? -0.5 * h : 0;
    };
  }
  return out;
};
function tickDataFn(d) {
  return [d.text, d.x, d.axInfo, d.font, d.fontSize, d.fontColor].join('_');
}

/**
 * Draw axis ticks
 *
 * @param {DOM element} gd
 * @param {object} ax (full) axis object
 *  - {string} _id
 *  - {string} ticks
 *  - {number} linewidth
 *  - {string} tickcolor
 * @param {object} opts
 * - {array of object} vals (calcTicks output-like)
 * - {d3 selection} layer
 * - {string or fn} path
 * - {fn} transFn
 * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)
 */
axes.drawTicks = function (gd, ax, opts) {
  opts = opts || {};
  var cls = ax._id + 'tick';
  var vals = [].concat(ax.minor && ax.minor.ticks ?
  // minor vals
  opts.vals.filter(function (d) {
    return d.minor && !d.noTick;
  }) : []).concat(ax.ticks ?
  // major vals
  opts.vals.filter(function (d) {
    return !d.minor && !d.noTick;
  }) : []);
  var ticks = opts.layer.selectAll('path.' + cls).data(vals, tickDataFn);
  ticks.exit().remove();
  ticks.enter().append('path').classed(cls, 1).classed('ticks', 1).classed('crisp', opts.crisp !== false).each(function (d) {
    return Color.stroke(d3.select(this), d.minor ? ax.minor.tickcolor : ax.tickcolor);
  }).style('stroke-width', function (d) {
    return Drawing.crispRound(gd, d.minor ? ax.minor.tickwidth : ax.tickwidth, 1) + 'px';
  }).attr('d', opts.path).style('display', null); // visible

  hideCounterAxisInsideTickLabels(ax, [TICK_PATH]);
  ticks.attr('transform', opts.transFn);
};

/**
 * Draw axis grid
 *
 * @param {DOM element} gd
 * @param {object} ax (full) axis object
 *  - {string} _id
 *  - {boolean} showgrid
 *  - {string} gridcolor
 *  - {string} gridwidth
 *  - {string} griddash
 *  - {boolean} zeroline
 *  - {string} type
 *  - {string} dtick
 * @param {object} opts
 * - {array of object} vals (calcTicks output-like)
 * - {d3 selection} layer
 * - {object} counterAxis (full axis object corresponding to counter axis)
 *     optional - only required if this axis supports zero lines
 * - {string or fn} path
 * - {fn} transFn
 * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)
 */
axes.drawGrid = function (gd, ax, opts) {
  opts = opts || {};
  if (ax.tickmode === 'sync') {
    // for tickmode sync we use the overlaying axis grid
    return;
  }
  var cls = ax._id + 'grid';
  var hasMinor = ax.minor && ax.minor.showgrid;
  var minorVals = hasMinor ? opts.vals.filter(function (d) {
    return d.minor;
  }) : [];
  var majorVals = ax.showgrid ? opts.vals.filter(function (d) {
    return !d.minor;
  }) : [];
  var counterAx = opts.counterAxis;
  if (counterAx && axes.shouldShowZeroLine(gd, ax, counterAx)) {
    var isArrayMode = ax.tickmode === 'array';
    for (var i = 0; i < majorVals.length; i++) {
      var xi = majorVals[i].x;
      if (isArrayMode ? !xi : Math.abs(xi) < ax.dtick / 100) {
        majorVals = majorVals.slice(0, i).concat(majorVals.slice(i + 1));
        // In array mode you can in principle have multiple
        // ticks at 0, so test them all. Otherwise once we found
        // one we can stop.
        if (isArrayMode) i--;else break;
      }
    }
  }
  ax._gw = Drawing.crispRound(gd, ax.gridwidth, 1);
  var wMinor = !hasMinor ? 0 : Drawing.crispRound(gd, ax.minor.gridwidth, 1);
  var majorLayer = opts.layer;
  var minorLayer = opts.minorLayer;
  for (var major = 1; major >= 0; major--) {
    var layer = major ? majorLayer : minorLayer;
    if (!layer) continue;
    var grid = layer.selectAll('path.' + cls).data(major ? majorVals : minorVals, tickDataFn);
    grid.exit().remove();
    grid.enter().append('path').classed(cls, 1).classed('crisp', opts.crisp !== false);
    grid.attr('transform', opts.transFn).attr('d', opts.path).each(function (d) {
      return Color.stroke(d3.select(this), d.minor ? ax.minor.gridcolor : ax.gridcolor || '#ddd');
    }).style('stroke-dasharray', function (d) {
      return Drawing.dashStyle(d.minor ? ax.minor.griddash : ax.griddash, d.minor ? ax.minor.gridwidth : ax.gridwidth);
    }).style('stroke-width', function (d) {
      return (d.minor ? wMinor : ax._gw) + 'px';
    }).style('display', null); // visible

    if (typeof opts.path === 'function') grid.attr('d', opts.path);
  }
  hideCounterAxisInsideTickLabels(ax, [GRID_PATH, MINORGRID_PATH]);
};

/**
 * Draw axis zero-line
 *
 * @param {DOM element} gd
 * @param {object} ax (full) axis object
 *  - {string} _id
 *  - {boolean} zeroline
 *  - {number} zerolinewidth
 *  - {string} zerolinecolor
 *  - {number (optional)} _gridWidthCrispRound
 * @param {object} opts
 * - {d3 selection} layer
 * - {object} counterAxis (full axis object corresponding to counter axis)
 * - {string or fn} path
 * - {fn} transFn
 * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)
 */
axes.drawZeroLine = function (gd, ax, opts) {
  opts = opts || opts;
  var cls = ax._id + 'zl';
  var show = axes.shouldShowZeroLine(gd, ax, opts.counterAxis);
  var zl = opts.layer.selectAll('path.' + cls).data(show ? [{
    x: 0,
    id: ax._id
  }] : []);
  zl.exit().remove();
  zl.enter().append('path').classed(cls, 1).classed('zl', 1).classed('crisp', opts.crisp !== false).each(function () {
    // use the fact that only one element can enter to trigger a sort.
    // If several zerolines enter at the same time we will sort once per,
    // but generally this should be a minimal overhead.
    opts.layer.selectAll('path').sort(function (da, db) {
      return idSort(da.id, db.id);
    });
  });
  zl.attr('transform', opts.transFn).attr('d', opts.path).call(Color.stroke, ax.zerolinecolor || Color.defaultLine).style('stroke-width', Drawing.crispRound(gd, ax.zerolinewidth, ax._gw || 1) + 'px').style('display', null); // visible

  hideCounterAxisInsideTickLabels(ax, [ZERO_PATH]);
};

/**
 * Draw axis tick labels
 *
 * @param {DOM element} gd
 * @param {object} ax (full) axis object
 *  - {string} _id
 *  - {boolean} showticklabels
 *  - {number} tickangle
 *  - {object (optional)} _selections
 *  - {object} (optional)} _tickAngles
 *  - {object} (optional)} _prevTickAngles
 * @param {object} opts
 * - {array of object} vals (calcTicks output-like)
 * - {d3 selection} layer
 * - {string (optional)} cls (node className)
 * - {boolean} repositionOnUpdate (set to true to reposition update selection)
 * - {boolean} secondary
 * - {fn} transFn
 * - {object} labelFns
 *  + {fn} xFn
 *  + {fn} yFn
 *  + {fn} anchorFn
 *  + {fn} heightFn
 */
axes.drawLabels = function (gd, ax, opts) {
  opts = opts || {};
  var fullLayout = gd._fullLayout;
  var axId = ax._id;
  var axLetter = axId.charAt(0);
  var cls = opts.cls || axId + 'tick';
  var vals = opts.vals.filter(function (d) {
    return d.text;
  });
  var labelFns = opts.labelFns;
  var tickAngle = opts.secondary ? 0 : ax.tickangle;
  var prevAngle = (ax._prevTickAngles || {})[cls];
  var tickLabels = opts.layer.selectAll('g.' + cls).data(ax.showticklabels ? vals : [], tickDataFn);
  var labelsReady = [];
  tickLabels.enter().append('g').classed(cls, 1).append('text')
  // only so tex has predictable alignment that we can
  // alter later
  .attr('text-anchor', 'middle').each(function (d) {
    var thisLabel = d3.select(this);
    var newPromise = gd._promises.length;
    thisLabel.call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d)).call(Drawing.font, d.font, d.fontSize, d.fontColor).text(d.text).call(svgTextUtils.convertToTspans, gd);
    if (gd._promises[newPromise]) {
      // if we have an async label, we'll deal with that
      // all here so take it out of gd._promises and
      // instead position the label and promise this in
      // labelsReady
      labelsReady.push(gd._promises.pop().then(function () {
        positionLabels(thisLabel, tickAngle);
      }));
    } else {
      // sync label: just position it now.
      positionLabels(thisLabel, tickAngle);
    }
  });
  hideCounterAxisInsideTickLabels(ax, [TICK_TEXT]);
  tickLabels.exit().remove();
  if (opts.repositionOnUpdate) {
    tickLabels.each(function (d) {
      d3.select(this).select('text').call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d));
    });
  }
  function positionLabels(s, angle) {
    s.each(function (d) {
      var thisLabel = d3.select(this);
      var mathjaxGroup = thisLabel.select('.text-math-group');
      var anchor = labelFns.anchorFn(d, angle);
      var transform = opts.transFn.call(thisLabel.node(), d) + (isNumeric(angle) && +angle !== 0 ? ' rotate(' + angle + ',' + labelFns.xFn(d) + ',' + (labelFns.yFn(d) - d.fontSize / 2) + ')' : '');

      // how much to shift a multi-line label to center it vertically.
      var nLines = svgTextUtils.lineCount(thisLabel);
      var lineHeight = LINE_SPACING * d.fontSize;
      var anchorHeight = labelFns.heightFn(d, isNumeric(angle) ? +angle : 0, (nLines - 1) * lineHeight);
      if (anchorHeight) {
        transform += strTranslate(0, anchorHeight);
      }
      if (mathjaxGroup.empty()) {
        var thisText = thisLabel.select('text');
        thisText.attr({
          transform: transform,
          'text-anchor': anchor
        });
        thisText.style('opacity', 1); // visible

        if (ax._adjustTickLabelsOverflow) {
          ax._adjustTickLabelsOverflow();
        }
      } else {
        var mjWidth = Drawing.bBox(mathjaxGroup.node()).width;
        var mjShift = mjWidth * {
          end: -0.5,
          start: 0.5
        }[anchor];
        mathjaxGroup.attr('transform', transform + strTranslate(mjShift, 0));
      }
    });
  }
  ax._adjustTickLabelsOverflow = function () {
    var ticklabeloverflow = ax.ticklabeloverflow;
    if (!ticklabeloverflow || ticklabeloverflow === 'allow') return;
    var hideOverflow = ticklabeloverflow.indexOf('hide') !== -1;
    var isX = ax._id.charAt(0) === 'x';
    // div positions
    var p0 = 0;
    var p1 = isX ? gd._fullLayout.width : gd._fullLayout.height;
    if (ticklabeloverflow.indexOf('domain') !== -1) {
      // domain positions
      var rl = Lib.simpleMap(ax.range, ax.r2l);
      p0 = ax.l2p(rl[0]) + ax._offset;
      p1 = ax.l2p(rl[1]) + ax._offset;
    }
    var min = Math.min(p0, p1);
    var max = Math.max(p0, p1);
    var side = ax.side;
    var visibleLabelMin = Infinity;
    var visibleLabelMax = -Infinity;
    tickLabels.each(function (d) {
      var thisLabel = d3.select(this);
      var mathjaxGroup = thisLabel.select('.text-math-group');
      if (mathjaxGroup.empty()) {
        var bb = Drawing.bBox(thisLabel.node());
        var adjust = 0;
        if (isX) {
          if (bb.right > max) adjust = 1;else if (bb.left < min) adjust = 1;
        } else {
          if (bb.bottom > max) adjust = 1;else if (bb.top + (ax.tickangle ? 0 : d.fontSize / 4) < min) adjust = 1;
        }
        var t = thisLabel.select('text');
        if (adjust) {
          if (hideOverflow) t.style('opacity', 0); // hidden
        } else {
          t.style('opacity', 1); // visible

          if (side === 'bottom' || side === 'right') {
            visibleLabelMin = Math.min(visibleLabelMin, isX ? bb.top : bb.left);
          } else {
            visibleLabelMin = -Infinity;
          }
          if (side === 'top' || side === 'left') {
            visibleLabelMax = Math.max(visibleLabelMax, isX ? bb.bottom : bb.right);
          } else {
            visibleLabelMax = Infinity;
          }
        }
      } // TODO: hide mathjax?
    });

    for (var subplot in fullLayout._plots) {
      var plotinfo = fullLayout._plots[subplot];
      if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;
      var anchorAx = isX ? plotinfo.yaxis : plotinfo.xaxis;
      if (anchorAx) {
        anchorAx['_visibleLabelMin_' + ax._id] = visibleLabelMin;
        anchorAx['_visibleLabelMax_' + ax._id] = visibleLabelMax;
      }
    }
  };
  ax._hideCounterAxisInsideTickLabels = function (partialOpts) {
    var isX = ax._id.charAt(0) === 'x';
    var anchoredAxes = [];
    for (var subplot in fullLayout._plots) {
      var plotinfo = fullLayout._plots[subplot];
      if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;
      anchoredAxes.push(isX ? plotinfo.yaxis : plotinfo.xaxis);
    }
    anchoredAxes.forEach(function (anchorAx, idx) {
      if (anchorAx && insideTicklabelposition(anchorAx)) {
        (partialOpts || [ZERO_PATH, MINORGRID_PATH, GRID_PATH, TICK_PATH, TICK_TEXT]).forEach(function (e) {
          var isPeriodLabel = e.K === 'tick' && e.L === 'text' && ax.ticklabelmode === 'period';
          var mainPlotinfo = fullLayout._plots[ax._mainSubplot];
          var sel;
          if (e.K === ZERO_PATH.K) sel = mainPlotinfo.zerolinelayer.selectAll('.' + ax._id + 'zl');else if (e.K === MINORGRID_PATH.K) sel = mainPlotinfo.minorGridlayer.selectAll('.' + ax._id);else if (e.K === GRID_PATH.K) sel = mainPlotinfo.gridlayer.selectAll('.' + ax._id);else sel = mainPlotinfo[ax._id.charAt(0) + 'axislayer'];
          sel.each(function () {
            var w = d3.select(this);
            if (e.L) w = w.selectAll(e.L);
            w.each(function (d) {
              var q = ax.l2p(isPeriodLabel ? getPosX(d) : d.x) + ax._offset;
              var t = d3.select(this);
              if (q < ax['_visibleLabelMax_' + anchorAx._id] && q > ax['_visibleLabelMin_' + anchorAx._id]) {
                t.style('display', 'none'); // hidden
              } else if (e.K === 'tick' && !idx) {
                t.style('display', null); // visible
              }
            });
          });
        });
      }
    });
  };

  // make sure all labels are correctly positioned at their base angle
  // the positionLabels call above is only for newly drawn labels.
  // do this without waiting, using the last calculated angle to
  // minimize flicker, then do it again when we know all labels are
  // there, putting back the prescribed angle to check for overlaps.
  positionLabels(tickLabels, prevAngle + 1 ? prevAngle : tickAngle);
  function allLabelsReady() {
    return labelsReady.length && Promise.all(labelsReady);
  }
  var autoangle = null;
  function fixLabelOverlaps() {
    positionLabels(tickLabels, tickAngle);

    // check for auto-angling if x labels overlap
    // don't auto-angle at all for log axes with
    // base and digit format
    if (vals.length && axLetter === 'x' && !isNumeric(tickAngle) && (ax.type !== 'log' || String(ax.dtick).charAt(0) !== 'D')) {
      autoangle = 0;
      var maxFontSize = 0;
      var lbbArray = [];
      var i;
      tickLabels.each(function (d) {
        maxFontSize = Math.max(maxFontSize, d.fontSize);
        var x = ax.l2p(d.x);
        var thisLabel = selectTickLabel(this);
        var bb = Drawing.bBox(thisLabel.node());
        lbbArray.push({
          // ignore about y, just deal with x overlaps
          top: 0,
          bottom: 10,
          height: 10,
          left: x - bb.width / 2,
          // impose a 2px gap
          right: x + bb.width / 2 + 2,
          width: bb.width + 2
        });
      });
      if ((ax.tickson === 'boundaries' || ax.showdividers) && !opts.secondary) {
        var gap = 2;
        if (ax.ticks) gap += ax.tickwidth / 2;

        // TODO should secondary labels also fall into this fix-overlap regime?

        for (i = 0; i < lbbArray.length; i++) {
          var xbnd = vals[i].xbnd;
          var lbb = lbbArray[i];
          if (xbnd[0] !== null && lbb.left - ax.l2p(xbnd[0]) < gap || xbnd[1] !== null && ax.l2p(xbnd[1]) - lbb.right < gap) {
            autoangle = 90;
            break;
          }
        }
      } else {
        var vLen = vals.length;
        var tickSpacing = Math.abs((vals[vLen - 1].x - vals[0].x) * ax._m) / (vLen - 1);
        var ticklabelposition = ax.ticklabelposition || '';
        var has = function (str) {
          return ticklabelposition.indexOf(str) !== -1;
        };
        var isTop = has('top');
        var isLeft = has('left');
        var isRight = has('right');
        var isBottom = has('bottom');
        var isAligned = isBottom || isLeft || isTop || isRight;
        var pad = !isAligned ? 0 : (ax.tickwidth || 0) + 2 * TEXTPAD;
        var rotate90 = tickSpacing < maxFontSize * 2.5 || ax.type === 'multicategory' || ax._name === 'realaxis';

        // any overlap at all - set 30 degrees or 90 degrees
        for (i = 0; i < lbbArray.length - 1; i++) {
          if (Lib.bBoxIntersect(lbbArray[i], lbbArray[i + 1], pad)) {
            autoangle = rotate90 ? 90 : 30;
            break;
          }
        }
      }
      if (autoangle) {
        positionLabels(tickLabels, autoangle);
      }
    }
  }
  if (ax._selections) {
    ax._selections[cls] = tickLabels;
  }
  var seq = [allLabelsReady];

  // N.B. during auto-margin redraws, if the axis fixed its label overlaps
  // by rotating 90 degrees, do not attempt to re-fix its label overlaps
  // as this can lead to infinite redraw loops!
  if (ax.automargin && fullLayout._redrawFromAutoMarginCount && prevAngle === 90) {
    autoangle = 90;
    seq.push(function () {
      positionLabels(tickLabels, prevAngle);
    });
  } else {
    seq.push(fixLabelOverlaps);
  }

  // save current tick angle for future redraws
  if (ax._tickAngles) {
    seq.push(function () {
      ax._tickAngles[cls] = autoangle === null ? isNumeric(tickAngle) ? tickAngle : 0 : autoangle;
    });
  }
  var computeTickLabelBoundingBoxes = function () {
    var labelsMaxW = 0;
    var labelsMaxH = 0;
    tickLabels.each(function (d, i) {
      var thisLabel = selectTickLabel(this);
      var mathjaxGroup = thisLabel.select('.text-math-group');
      if (mathjaxGroup.empty()) {
        var bb;
        if (ax._vals[i]) {
          bb = ax._vals[i].bb || Drawing.bBox(thisLabel.node());
          ax._vals[i].bb = bb;
        }
        labelsMaxW = Math.max(labelsMaxW, bb.width);
        labelsMaxH = Math.max(labelsMaxH, bb.height);
      }
    });
    return {
      labelsMaxW: labelsMaxW,
      labelsMaxH: labelsMaxH
    };
  };
  var anchorAx = ax._anchorAxis;
  if (anchorAx && (anchorAx.autorange || anchorAx.insiderange) && insideTicklabelposition(ax) && !isLinked(fullLayout, ax._id)) {
    if (!fullLayout._insideTickLabelsUpdaterange) {
      fullLayout._insideTickLabelsUpdaterange = {};
    }
    if (anchorAx.autorange) {
      fullLayout._insideTickLabelsUpdaterange[anchorAx._name + '.autorange'] = anchorAx.autorange;
      seq.push(computeTickLabelBoundingBoxes);
    }
    if (anchorAx.insiderange) {
      var BBs = computeTickLabelBoundingBoxes();
      var move = ax._id.charAt(0) === 'y' ? BBs.labelsMaxW : BBs.labelsMaxH;
      move += 2 * TEXTPAD;
      if (ax.ticklabelposition === 'inside') {
        move += ax.ticklen || 0;
      }
      var sgn = ax.side === 'right' || ax.side === 'top' ? 1 : -1;
      var index = sgn === 1 ? 1 : 0;
      var otherIndex = sgn === 1 ? 0 : 1;
      var newRange = [];
      newRange[otherIndex] = anchorAx.range[otherIndex];
      var p0 = anchorAx.d2p(anchorAx.range[index]);
      var p1 = anchorAx.d2p(anchorAx.range[otherIndex]);
      var dist = Math.abs(p1 - p0);
      if (dist - move > 0) {
        dist -= move;
        move *= 1 + move / dist;
      } else {
        move = 0;
      }
      if (ax._id.charAt(0) !== 'y') move = -move;
      newRange[index] = anchorAx.p2d(anchorAx.d2p(anchorAx.range[index]) + sgn * move);

      // handle partial ranges in insiderange
      if (anchorAx.autorange === 'min' || anchorAx.autorange === 'max reversed') {
        newRange[0] = null;
        anchorAx._rangeInitial0 = undefined;
        anchorAx._rangeInitial1 = undefined;
      } else if (anchorAx.autorange === 'max' || anchorAx.autorange === 'min reversed') {
        newRange[1] = null;
        anchorAx._rangeInitial0 = undefined;
        anchorAx._rangeInitial1 = undefined;
      }
      fullLayout._insideTickLabelsUpdaterange[anchorAx._name + '.range'] = newRange;
    }
  }
  var done = Lib.syncOrAsync(seq);
  if (done && done.then) gd._promises.push(done);
  return done;
};

/**
 * Draw axis dividers
 *
 * @param {DOM element} gd
 * @param {object} ax (full) axis object
 *  - {string} _id
 *  - {string} showdividers
 *  - {number} dividerwidth
 *  - {string} dividercolor
 * @param {object} opts
 * - {array of object} vals (calcTicks output-like)
 * - {d3 selection} layer
 * - {fn} path
 * - {fn} transFn
 */
function drawDividers(gd, ax, opts) {
  var cls = ax._id + 'divider';
  var vals = opts.vals;
  var dividers = opts.layer.selectAll('path.' + cls).data(vals, tickDataFn);
  dividers.exit().remove();
  dividers.enter().insert('path', ':first-child').classed(cls, 1).classed('crisp', 1).call(Color.stroke, ax.dividercolor).style('stroke-width', Drawing.crispRound(gd, ax.dividerwidth, 1) + 'px');
  dividers.attr('transform', opts.transFn).attr('d', opts.path);
}

/**
 * Get axis position in px, that is the distance for the graph's
 * top (left) edge for x (y) axes.
 *
 * @param {DOM element} gd
 * @param {object} ax (full) axis object
 *  - {string} _id
 *  - {string} side
 *  if anchored:
 *  - {object} _anchorAxis
 *  Otherwise:
 *  - {number} position
 * @return {number}
 */
axes.getPxPosition = function (gd, ax) {
  var gs = gd._fullLayout._size;
  var axLetter = ax._id.charAt(0);
  var side = ax.side;
  var anchorAxis;
  if (ax.anchor !== 'free') {
    anchorAxis = ax._anchorAxis;
  } else if (axLetter === 'x') {
    anchorAxis = {
      _offset: gs.t + (1 - (ax.position || 0)) * gs.h,
      _length: 0
    };
  } else if (axLetter === 'y') {
    anchorAxis = {
      _offset: gs.l + (ax.position || 0) * gs.w + ax._shift,
      _length: 0
    };
  }
  if (side === 'top' || side === 'left') {
    return anchorAxis._offset;
  } else if (side === 'bottom' || side === 'right') {
    return anchorAxis._offset + anchorAxis._length;
  }
};

/**
 * Approximate axis title depth (w/o computing its bounding box)
 *
 * @param {object} ax (full) axis object
 *  - {string} title.text
 *  - {number} title.font.size
 *  - {number} title.standoff
 * @return {number} (in px)
 */
function approxTitleDepth(ax) {
  var fontSize = ax.title.font.size;
  var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;
  if (ax.title.hasOwnProperty('standoff')) {
    return extraLines ? fontSize * (CAP_SHIFT + extraLines * LINE_SPACING) : fontSize * CAP_SHIFT;
  } else {
    return extraLines ? fontSize * (extraLines + 1) * LINE_SPACING : fontSize;
  }
}

/**
 * Draw axis title, compute default standoff if necessary
 *
 * @param {DOM element} gd
 * @param {object} ax (full) axis object
 *  - {string} _id
 *  - {string} _name
 *  - {string} side
 *  - {number} title.font.size
 *  - {object} _selections
 *
 *  - {number} _depth
 *  - {number} title.standoff
 *  OR
 *  - {number} linewidth
 *  - {boolean} showticklabels
 */
function drawTitle(gd, ax) {
  var fullLayout = gd._fullLayout;
  var axId = ax._id;
  var axLetter = axId.charAt(0);
  var fontSize = ax.title.font.size;
  var titleStandoff;
  if (ax.title.hasOwnProperty('standoff')) {
    titleStandoff = ax._depth + ax.title.standoff + approxTitleDepth(ax);
  } else {
    var isInside = insideTicklabelposition(ax);
    if (ax.type === 'multicategory') {
      titleStandoff = ax._depth;
    } else {
      var offsetBase = 1.5 * fontSize;
      if (isInside) {
        offsetBase = 0.5 * fontSize;
        if (ax.ticks === 'outside') {
          offsetBase += ax.ticklen;
        }
      }
      titleStandoff = 10 + offsetBase + (ax.linewidth ? ax.linewidth - 1 : 0);
    }
    if (!isInside) {
      if (axLetter === 'x') {
        titleStandoff += ax.side === 'top' ? fontSize * (ax.showticklabels ? 1 : 0) : fontSize * (ax.showticklabels ? 1.5 : 0.5);
      } else {
        titleStandoff += ax.side === 'right' ? fontSize * (ax.showticklabels ? 1 : 0.5) : fontSize * (ax.showticklabels ? 0.5 : 0);
      }
    }
  }
  var pos = axes.getPxPosition(gd, ax);
  var transform, x, y;
  if (axLetter === 'x') {
    x = ax._offset + ax._length / 2;
    y = ax.side === 'top' ? pos - titleStandoff : pos + titleStandoff;
  } else {
    y = ax._offset + ax._length / 2;
    x = ax.side === 'right' ? pos + titleStandoff : pos - titleStandoff;
    transform = {
      rotate: '-90',
      offset: 0
    };
  }
  var avoid;
  if (ax.type !== 'multicategory') {
    var tickLabels = ax._selections[ax._id + 'tick'];
    avoid = {
      selection: tickLabels,
      side: ax.side
    };
    if (tickLabels && tickLabels.node() && tickLabels.node().parentNode) {
      var translation = Drawing.getTranslate(tickLabels.node().parentNode);
      avoid.offsetLeft = translation.x;
      avoid.offsetTop = translation.y;
    }
    if (ax.title.hasOwnProperty('standoff')) {
      avoid.pad = 0;
    }
  }
  ax._titleStandoff = titleStandoff;
  return Titles.draw(gd, axId + 'title', {
    propContainer: ax,
    propName: ax._name + '.title.text',
    placeholder: fullLayout._dfltTitle[axLetter],
    avoid: avoid,
    transform: transform,
    attributes: {
      x: x,
      y: y,
      'text-anchor': 'middle'
    }
  });
}
axes.shouldShowZeroLine = function (gd, ax, counterAxis) {
  var rng = Lib.simpleMap(ax.range, ax.r2l);
  return rng[0] * rng[1] <= 0 && ax.zeroline && (ax.type === 'linear' || ax.type === '-') && !(ax.rangebreaks && ax.maskBreaks(0) === BADNUM) && (clipEnds(ax, 0) || !anyCounterAxLineAtZero(gd, ax, counterAxis, rng) || hasBarsOrFill(gd, ax));
};
axes.clipEnds = function (ax, vals) {
  return vals.filter(function (d) {
    return clipEnds(ax, d.x);
  });
};
function clipEnds(ax, l) {
  var p = ax.l2p(l);
  return p > 1 && p < ax._length - 1;
}
function anyCounterAxLineAtZero(gd, ax, counterAxis, rng) {
  var mainCounterAxis = counterAxis._mainAxis;
  if (!mainCounterAxis) return;
  var fullLayout = gd._fullLayout;
  var axLetter = ax._id.charAt(0);
  var counterLetter = axes.counterLetter(ax._id);
  var zeroPosition = ax._offset + (Math.abs(rng[0]) < Math.abs(rng[1]) === (axLetter === 'x') ? 0 : ax._length);
  function lineNearZero(ax2) {
    if (!ax2.showline || !ax2.linewidth) return false;
    var tolerance = Math.max((ax2.linewidth + ax.zerolinewidth) / 2, 1);
    function closeEnough(pos2) {
      return typeof pos2 === 'number' && Math.abs(pos2 - zeroPosition) < tolerance;
    }
    if (closeEnough(ax2._mainLinePosition) || closeEnough(ax2._mainMirrorPosition)) {
      return true;
    }
    var linePositions = ax2._linepositions || {};
    for (var k in linePositions) {
      if (closeEnough(linePositions[k][0]) || closeEnough(linePositions[k][1])) {
        return true;
      }
    }
  }
  var plotinfo = fullLayout._plots[counterAxis._mainSubplot];
  if (!(plotinfo.mainplotinfo || plotinfo).overlays.length) {
    return lineNearZero(counterAxis, zeroPosition);
  }
  var counterLetterAxes = axes.list(gd, counterLetter);
  for (var i = 0; i < counterLetterAxes.length; i++) {
    var counterAxis2 = counterLetterAxes[i];
    if (counterAxis2._mainAxis === mainCounterAxis && lineNearZero(counterAxis2, zeroPosition)) {
      return true;
    }
  }
}
function hasBarsOrFill(gd, ax) {
  var fullData = gd._fullData;
  var subplot = ax._mainSubplot;
  var axLetter = ax._id.charAt(0);
  for (var i = 0; i < fullData.length; i++) {
    var trace = fullData[i];
    if (trace.visible === true && trace.xaxis + trace.yaxis === subplot) {
      if (Registry.traceIs(trace, 'bar-like') && trace.orientation === {
        x: 'h',
        y: 'v'
      }[axLetter]) return true;
      if (trace.fill && trace.fill.charAt(trace.fill.length - 1) === axLetter) return true;
    }
  }
  return false;
}
function selectTickLabel(gTick) {
  var s = d3.select(gTick);
  var mj = s.select('.text-math-group');
  return mj.empty() ? s.select('text') : mj;
}

/**
 * Find all margin pushers for 2D axes and reserve them for later use
 * Both label and rangeslider automargin calculations happen later so
 * we need to explicitly allow their ids in order to not delete them.
 *
 * TODO: can we pull the actual automargin calls forward to avoid this hack?
 * We're probably also doing multiple redraws in this case, would be faster
 * if we can just do the whole calculation ahead of time and draw once.
 */
axes.allowAutoMargin = function (gd) {
  var axList = axes.list(gd, '', true);
  for (var i = 0; i < axList.length; i++) {
    var ax = axList[i];
    if (ax.automargin) {
      Plots.allowAutoMargin(gd, axAutoMarginID(ax));
      if (ax.mirror) {
        Plots.allowAutoMargin(gd, axMirrorAutoMarginID(ax));
      }
    }
    if (Registry.getComponentMethod('rangeslider', 'isVisible')(ax)) {
      Plots.allowAutoMargin(gd, rangeSliderAutoMarginID(ax));
    }
  }
};
function axAutoMarginID(ax) {
  return ax._id + '.automargin';
}
function axMirrorAutoMarginID(ax) {
  return axAutoMarginID(ax) + '.mirror';
}
function rangeSliderAutoMarginID(ax) {
  return ax._id + '.rangeslider';
}

// swap all the presentation attributes of the axes showing these traces
axes.swap = function (gd, traces) {
  var axGroups = makeAxisGroups(gd, traces);
  for (var i = 0; i < axGroups.length; i++) {
    swapAxisGroup(gd, axGroups[i].x, axGroups[i].y);
  }
};
function makeAxisGroups(gd, traces) {
  var groups = [];
  var i, j;
  for (i = 0; i < traces.length; i++) {
    var groupsi = [];
    var xi = gd._fullData[traces[i]].xaxis;
    var yi = gd._fullData[traces[i]].yaxis;
    if (!xi || !yi) continue; // not a 2D cartesian trace?

    for (j = 0; j < groups.length; j++) {
      if (groups[j].x.indexOf(xi) !== -1 || groups[j].y.indexOf(yi) !== -1) {
        groupsi.push(j);
      }
    }
    if (!groupsi.length) {
      groups.push({
        x: [xi],
        y: [yi]
      });
      continue;
    }
    var group0 = groups[groupsi[0]];
    var groupj;
    if (groupsi.length > 1) {
      for (j = 1; j < groupsi.length; j++) {
        groupj = groups[groupsi[j]];
        mergeAxisGroups(group0.x, groupj.x);
        mergeAxisGroups(group0.y, groupj.y);
      }
    }
    mergeAxisGroups(group0.x, [xi]);
    mergeAxisGroups(group0.y, [yi]);
  }
  return groups;
}
function mergeAxisGroups(intoSet, fromSet) {
  for (var i = 0; i < fromSet.length; i++) {
    if (intoSet.indexOf(fromSet[i]) === -1) intoSet.push(fromSet[i]);
  }
}
function swapAxisGroup(gd, xIds, yIds) {
  var xFullAxes = [];
  var yFullAxes = [];
  var layout = gd.layout;
  var i, j;
  for (i = 0; i < xIds.length; i++) xFullAxes.push(axes.getFromId(gd, xIds[i]));
  for (i = 0; i < yIds.length; i++) yFullAxes.push(axes.getFromId(gd, yIds[i]));
  var allAxKeys = Object.keys(axAttrs);
  var noSwapAttrs = ['anchor', 'domain', 'overlaying', 'position', 'side', 'tickangle', 'editType'];
  var numericTypes = ['linear', 'log'];
  for (i = 0; i < allAxKeys.length; i++) {
    var keyi = allAxKeys[i];
    var xVal = xFullAxes[0][keyi];
    var yVal = yFullAxes[0][keyi];
    var allEqual = true;
    var coerceLinearX = false;
    var coerceLinearY = false;
    if (keyi.charAt(0) === '_' || typeof xVal === 'function' || noSwapAttrs.indexOf(keyi) !== -1) {
      continue;
    }
    for (j = 1; j < xFullAxes.length && allEqual; j++) {
      var xVali = xFullAxes[j][keyi];
      if (keyi === 'type' && numericTypes.indexOf(xVal) !== -1 && numericTypes.indexOf(xVali) !== -1 && xVal !== xVali) {
        // type is special - if we find a mixture of linear and log,
        // coerce them all to linear on flipping
        coerceLinearX = true;
      } else if (xVali !== xVal) allEqual = false;
    }
    for (j = 1; j < yFullAxes.length && allEqual; j++) {
      var yVali = yFullAxes[j][keyi];
      if (keyi === 'type' && numericTypes.indexOf(yVal) !== -1 && numericTypes.indexOf(yVali) !== -1 && yVal !== yVali) {
        // type is special - if we find a mixture of linear and log,
        // coerce them all to linear on flipping
        coerceLinearY = true;
      } else if (yFullAxes[j][keyi] !== yVal) allEqual = false;
    }
    if (allEqual) {
      if (coerceLinearX) layout[xFullAxes[0]._name].type = 'linear';
      if (coerceLinearY) layout[yFullAxes[0]._name].type = 'linear';
      swapAxisAttrs(layout, keyi, xFullAxes, yFullAxes, gd._fullLayout._dfltTitle);
    }
  }

  // now swap x&y for any annotations anchored to these x & y
  for (i = 0; i < gd._fullLayout.annotations.length; i++) {
    var ann = gd._fullLayout.annotations[i];
    if (xIds.indexOf(ann.xref) !== -1 && yIds.indexOf(ann.yref) !== -1) {
      Lib.swapAttrs(layout.annotations[i], ['?']);
    }
  }
}
function swapAxisAttrs(layout, key, xFullAxes, yFullAxes, dfltTitle) {
  // in case the value is the default for either axis,
  // look at the first axis in each list and see if
  // this key's value is undefined
  var np = Lib.nestedProperty;
  var xVal = np(layout[xFullAxes[0]._name], key).get();
  var yVal = np(layout[yFullAxes[0]._name], key).get();
  var i;
  if (key === 'title') {
    // special handling of placeholder titles
    if (xVal && xVal.text === dfltTitle.x) {
      xVal.text = dfltTitle.y;
    }
    if (yVal && yVal.text === dfltTitle.y) {
      yVal.text = dfltTitle.x;
    }
  }
  for (i = 0; i < xFullAxes.length; i++) {
    np(layout, xFullAxes[i]._name + '.' + key).set(yVal);
  }
  for (i = 0; i < yFullAxes.length; i++) {
    np(layout, yFullAxes[i]._name + '.' + key).set(xVal);
  }
}
function isAngular(ax) {
  return ax._id === 'angularaxis';
}
function moveOutsideBreak(v, ax) {
  var len = ax._rangebreaks.length;
  for (var k = 0; k < len; k++) {
    var brk = ax._rangebreaks[k];
    if (v >= brk.min && v < brk.max) {
      return brk.max;
    }
  }
  return v;
}
function insideTicklabelposition(ax) {
  return (ax.ticklabelposition || '').indexOf('inside') !== -1;
}
function hideCounterAxisInsideTickLabels(ax, opts) {
  if (insideTicklabelposition(ax._anchorAxis || {})) {
    if (ax._hideCounterAxisInsideTickLabels) {
      ax._hideCounterAxisInsideTickLabels(opts);
    }
  }
}
function incrementShift(ax, shiftVal, axShifts, normalize) {
  // Need to set 'overlay' for anchored axis
  var overlay = ax.anchor !== 'free' && (ax.overlaying === undefined || ax.overlaying === false) ? ax._id : ax.overlaying;
  var shiftValAdj;
  if (normalize) {
    shiftValAdj = ax.side === 'right' ? shiftVal : -shiftVal;
  } else {
    shiftValAdj = shiftVal;
  }
  if (!(overlay in axShifts)) {
    axShifts[overlay] = {};
  }
  if (!(ax.side in axShifts[overlay])) {
    axShifts[overlay][ax.side] = 0;
  }
  axShifts[overlay][ax.side] += shiftValAdj;
}
function setShiftVal(ax, axShifts) {
  return ax.autoshift ? axShifts[ax.overlaying][ax.side] : ax.shift || 0;
}

/***/ }),

/***/ 4322:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var Lib = __webpack_require__(1828);
var BADNUM = (__webpack_require__(606).BADNUM);
var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
var isDateTime = Lib.isDateTime;
var cleanNumber = Lib.cleanNumber;
var round = Math.round;
module.exports = function autoType(array, calendar, opts) {
  var a = array;
  var noMultiCategory = opts.noMultiCategory;
  if (isArrayOrTypedArray(a) && !a.length) return '-';
  if (!noMultiCategory && multiCategory(a)) return 'multicategory';
  if (noMultiCategory && Array.isArray(a[0])) {
    // no need to flat typed arrays here
    var b = [];
    for (var i = 0; i < a.length; i++) {
      if (isArrayOrTypedArray(a[i])) {
        for (var j = 0; j < a[i].length; j++) {
          b.push(a[i][j]);
        }
      }
    }
    a = b;
  }
  if (moreDates(a, calendar)) return 'date';
  var convertNumeric = opts.autotypenumbers !== 'strict'; // compare against strict, just in case autotypenumbers was not provided in opts
  if (category(a, convertNumeric)) return 'category';
  if (linearOK(a, convertNumeric)) return 'linear';
  return '-';
};
function hasTypeNumber(v, convertNumeric) {
  return convertNumeric ? isNumeric(v) : typeof v === 'number';
}

// is there at least one number in array? If not, we should leave
// ax.type empty so it can be autoset later
function linearOK(a, convertNumeric) {
  var len = a.length;
  for (var i = 0; i < len; i++) {
    if (hasTypeNumber(a[i], convertNumeric)) return true;
  }
  return false;
}

// does the array a have mostly dates rather than numbers?
// note: some values can be neither (such as blanks, text)
// 2- or 4-digit integers can be both, so require twice as many
// dates as non-dates, to exclude cases with mostly 2 & 4 digit
// numbers and a few dates
// as with categories, consider DISTINCT values only.
function moreDates(a, calendar) {
  var len = a.length;
  var inc = getIncrement(len);
  var dats = 0;
  var nums = 0;
  var seen = {};
  for (var f = 0; f < len; f += inc) {
    var i = round(f);
    var ai = a[i];
    var stri = String(ai);
    if (seen[stri]) continue;
    seen[stri] = 1;
    if (isDateTime(ai, calendar)) dats++;
    if (isNumeric(ai)) nums++;
  }
  return dats > nums * 2;
}

// return increment to test at most 1000 points, evenly spaced
function getIncrement(len) {
  return Math.max(1, (len - 1) / 1000);
}

// are the (x,y)-values in gd.data mostly text?
// require twice as many DISTINCT categories as distinct numbers
function category(a, convertNumeric) {
  var len = a.length;
  var inc = getIncrement(len);
  var nums = 0;
  var cats = 0;
  var seen = {};
  for (var f = 0; f < len; f += inc) {
    var i = round(f);
    var ai = a[i];
    var stri = String(ai);
    if (seen[stri]) continue;
    seen[stri] = 1;
    var t = typeof ai;
    if (t === 'boolean') cats++;else if (convertNumeric ? cleanNumber(ai) !== BADNUM : t === 'number') nums++;else if (t === 'string') cats++;
  }
  return cats > nums * 2;
}

// very-loose requirements for multicategory,
// trace modules that should never auto-type to multicategory
// should be declared with 'noMultiCategory'
function multiCategory(a) {
  return isArrayOrTypedArray(a[0]) && isArrayOrTypedArray(a[1]);
}

/***/ }),

/***/ 1453:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var Template = __webpack_require__(4467);
var handleArrayContainerDefaults = __webpack_require__(5501);
var layoutAttributes = __webpack_require__(3838);
var handleTickValueDefaults = __webpack_require__(6218);
var handleTickMarkDefaults = __webpack_require__(8701);
var handleTickLabelDefaults = __webpack_require__(6115);
var handlePrefixSuffixDefaults = __webpack_require__(9426);
var handleCategoryOrderDefaults = __webpack_require__(5258);
var handleLineGridDefaults = __webpack_require__(2128);
var handleRangeDefaults = __webpack_require__(3608);
var setConvert = __webpack_require__(1994);
var DAY_OF_WEEK = (__webpack_require__(5555).WEEKDAY_PATTERN);
var HOUR = (__webpack_require__(5555).HOUR_PATTERN);

/**
 * options: object containing:
 *
 *  letter: 'x' or 'y'
 *  title: name of the axis (ie 'Colorbar') to go in default title
 *  font: the default font to inherit
 *  outerTicks: boolean, should ticks default to outside?
 *  showGrid: boolean, should gridlines be shown by default?
 *  noHover: boolean, this axis doesn't support hover effects?
 *  noTickson: boolean, this axis doesn't support 'tickson'
 *  data: the plot data, used to manage categories
 *  bgColor: the plot background color, to calculate default gridline colors
 *  calendar:
 *  splomStash:
 *  visibleDflt: boolean
 *  reverseDflt: boolean
 *  automargin: boolean
 */
module.exports = function handleAxisDefaults(containerIn, containerOut, coerce, options, layoutOut) {
  var letter = options.letter;
  var font = options.font || {};
  var splomStash = options.splomStash || {};
  var visible = coerce('visible', !options.visibleDflt);
  var axTemplate = containerOut._template || {};
  var axType = containerOut.type || axTemplate.type || '-';
  var ticklabelmode;
  if (axType === 'date') {
    var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleDefaults');
    handleCalendarDefaults(containerIn, containerOut, 'calendar', options.calendar);
    if (!options.noTicklabelmode) {
      ticklabelmode = coerce('ticklabelmode');
    }
  }
  var ticklabelposition = '';
  if (!options.noTicklabelposition || axType === 'multicategory') {
    ticklabelposition = Lib.coerce(containerIn, containerOut, {
      ticklabelposition: {
        valType: 'enumerated',
        dflt: 'outside',
        values: ticklabelmode === 'period' ? ['outside', 'inside'] : letter === 'x' ? ['outside', 'inside', 'outside left', 'inside left', 'outside right', 'inside right'] : ['outside', 'inside', 'outside top', 'inside top', 'outside bottom', 'inside bottom']
      }
    }, 'ticklabelposition');
  }
  if (!options.noTicklabeloverflow) {
    coerce('ticklabeloverflow', ticklabelposition.indexOf('inside') !== -1 ? 'hide past domain' : axType === 'category' || axType === 'multicategory' ? 'allow' : 'hide past div');
  }
  setConvert(containerOut, layoutOut);
  handleRangeDefaults(containerIn, containerOut, coerce, options);
  handleCategoryOrderDefaults(containerIn, containerOut, coerce, options);
  if (axType !== 'category' && !options.noHover) coerce('hoverformat');
  var dfltColor = coerce('color');
  // if axis.color was provided, use it for fonts too; otherwise,
  // inherit from global font color in case that was provided.
  // Compare to dflt rather than to containerIn, so we can provide color via
  // template too.
  var dfltFontColor = dfltColor !== layoutAttributes.color.dflt ? dfltColor : font.color;
  // try to get default title from splom trace, fallback to graph-wide value
  var dfltTitle = splomStash.label || layoutOut._dfltTitle[letter];
  handlePrefixSuffixDefaults(containerIn, containerOut, coerce, axType, options);
  if (!visible) return containerOut;
  coerce('title.text', dfltTitle);
  Lib.coerceFont(coerce, 'title.font', {
    family: font.family,
    size: Lib.bigFont(font.size),
    color: dfltFontColor
  });

  // major ticks
  handleTickValueDefaults(containerIn, containerOut, coerce, axType);
  var hasMinor = options.hasMinor;
  if (hasMinor) {
    // minor ticks
    Template.newContainer(containerOut, 'minor');
    handleTickValueDefaults(containerIn, containerOut, coerce, axType, {
      isMinor: true
    });
  }
  handleTickLabelDefaults(containerIn, containerOut, coerce, axType, options);

  // major and minor ticks
  handleTickMarkDefaults(containerIn, containerOut, coerce, options);
  if (hasMinor) {
    var keepIsMinor = options.isMinor;
    options.isMinor = true;
    handleTickMarkDefaults(containerIn, containerOut, coerce, options);
    options.isMinor = keepIsMinor;
  }
  handleLineGridDefaults(containerIn, containerOut, coerce, {
    dfltColor: dfltColor,
    bgColor: options.bgColor,
    showGrid: options.showGrid,
    hasMinor: hasMinor,
    attributes: layoutAttributes
  });

  // delete minor when no minor ticks or gridlines
  if (hasMinor && !containerOut.minor.ticks && !containerOut.minor.showgrid) {
    delete containerOut.minor;
  }

  // mirror
  if (containerOut.showline || containerOut.ticks) coerce('mirror');
  var isMultiCategory = axType === 'multicategory';
  if (!options.noTickson && (axType === 'category' || isMultiCategory) && (containerOut.ticks || containerOut.showgrid)) {
    var ticksonDflt;
    if (isMultiCategory) ticksonDflt = 'boundaries';
    var tickson = coerce('tickson', ticksonDflt);
    if (tickson === 'boundaries') {
      delete containerOut.ticklabelposition;
    }
  }
  if (isMultiCategory) {
    var showDividers = coerce('showdividers');
    if (showDividers) {
      coerce('dividercolor');
      coerce('dividerwidth');
    }
  }
  if (axType === 'date') {
    handleArrayContainerDefaults(containerIn, containerOut, {
      name: 'rangebreaks',
      inclusionAttr: 'enabled',
      handleItemDefaults: rangebreaksDefaults
    });
    if (!containerOut.rangebreaks.length) {
      delete containerOut.rangebreaks;
    } else {
      for (var k = 0; k < containerOut.rangebreaks.length; k++) {
        if (containerOut.rangebreaks[k].pattern === DAY_OF_WEEK) {
          containerOut._hasDayOfWeekBreaks = true;
          break;
        }
      }
      setConvert(containerOut, layoutOut);
      if (layoutOut._has('scattergl') || layoutOut._has('splom')) {
        for (var i = 0; i < options.data.length; i++) {
          var trace = options.data[i];
          if (trace.type === 'scattergl' || trace.type === 'splom') {
            trace.visible = false;
            Lib.warn(trace.type + ' traces do not work on axes with rangebreaks.' + ' Setting trace ' + trace.index + ' to `visible: false`.');
          }
        }
      }
    }
  }
  return containerOut;
};
function rangebreaksDefaults(itemIn, itemOut, containerOut) {
  function coerce(attr, dflt) {
    return Lib.coerce(itemIn, itemOut, layoutAttributes.rangebreaks, attr, dflt);
  }
  var enabled = coerce('enabled');
  if (enabled) {
    var bnds = coerce('bounds');
    if (bnds && bnds.length >= 2) {
      var dfltPattern = '';
      var i, q;
      if (bnds.length === 2) {
        for (i = 0; i < 2; i++) {
          q = indexOfDay(bnds[i]);
          if (q) {
            dfltPattern = DAY_OF_WEEK;
            break;
          }
        }
      }
      var pattern = coerce('pattern', dfltPattern);
      if (pattern === DAY_OF_WEEK) {
        for (i = 0; i < 2; i++) {
          q = indexOfDay(bnds[i]);
          if (q) {
            // convert to integers i.e 'Sunday' --> 0
            itemOut.bounds[i] = bnds[i] = q - 1;
          }
        }
      }
      if (pattern) {
        // ensure types and ranges
        for (i = 0; i < 2; i++) {
          q = bnds[i];
          switch (pattern) {
            case DAY_OF_WEEK:
              if (!isNumeric(q)) {
                itemOut.enabled = false;
                return;
              }
              q = +q;
              if (q !== Math.floor(q) ||
              // don't accept fractional days for mow
              q < 0 || q >= 7) {
                itemOut.enabled = false;
                return;
              }
              // use number
              itemOut.bounds[i] = bnds[i] = q;
              break;
            case HOUR:
              if (!isNumeric(q)) {
                itemOut.enabled = false;
                return;
              }
              q = +q;
              if (q < 0 || q > 24) {
                // accept 24
                itemOut.enabled = false;
                return;
              }
              // use number
              itemOut.bounds[i] = bnds[i] = q;
              break;
          }
        }
      }
      if (containerOut.autorange === false) {
        var rng = containerOut.range;

        // if bounds are bigger than the (set) range, disable break
        if (rng[0] < rng[1]) {
          if (bnds[0] < rng[0] && bnds[1] > rng[1]) {
            itemOut.enabled = false;
            return;
          }
        } else if (bnds[0] > rng[0] && bnds[1] < rng[1]) {
          itemOut.enabled = false;
          return;
        }
      }
    } else {
      var values = coerce('values');
      if (values && values.length) {
        coerce('dvalue');
      } else {
        itemOut.enabled = false;
        return;
      }
    }
  }
}

// these numbers are one more than what bounds would be mapped to
var dayStrToNum = {
  sun: 1,
  mon: 2,
  tue: 3,
  wed: 4,
  thu: 5,
  fri: 6,
  sat: 7
};
function indexOfDay(v) {
  if (typeof v !== 'string') return;
  return dayStrToNum[v.substr(0, 3).toLowerCase()];
}

/***/ }),

/***/ 2663:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var docs = __webpack_require__(1562);
var FORMAT_LINK = docs.FORMAT_LINK;
var DATE_FORMAT_LINK = docs.DATE_FORMAT_LINK;
function axisHoverFormat(x, noDates) {
  return {
    valType: 'string',
    dflt: '',
    editType: 'none',
    description: (noDates ? descriptionOnlyNumbers : descriptionWithDates)('hover text', x) + ['By default the values are formatted using ' + (noDates ? 'generic number format' : '`' + x + 'axis.hoverformat`') + '.'].join(' ')
  };
}
function descriptionOnlyNumbers(label, x) {
  return ['Sets the ' + label + ' formatting rule' + (x ? 'for `' + x + '` ' : ''), 'using d3 formatting mini-languages', 'which are very similar to those in Python. For numbers, see: ' + FORMAT_LINK + '.'].join(' ');
}
function descriptionWithDates(label, x) {
  return descriptionOnlyNumbers(label, x) + [' And for dates see: ' + DATE_FORMAT_LINK + '.', 'We add two items to d3\'s date formatter:', '*%h* for half of the year as a decimal number as well as', '*%{n}f* for fractional seconds', 'with n digits. For example, *2016-10-13 09:15:23.456* with tickformat', '*%H~%M~%S.%2f* would display *09~15~23.46*'].join(' ');
}
module.exports = {
  axisHoverFormat: axisHoverFormat,
  descriptionOnlyNumbers: descriptionOnlyNumbers,
  descriptionWithDates: descriptionWithDates
};

/***/ }),

/***/ 1675:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);
var constants = __webpack_require__(5555);

// convert between axis names (xaxis, xaxis2, etc, elements of gd.layout)
// and axis id's (x, x2, etc). Would probably have ditched 'xaxis'
// completely in favor of just 'x' if it weren't ingrained in the API etc.
exports.id2name = function id2name(id) {
  if (typeof id !== 'string' || !id.match(constants.AX_ID_PATTERN)) return;
  var axNum = id.split(' ')[0].substr(1);
  if (axNum === '1') axNum = '';
  return id.charAt(0) + 'axis' + axNum;
};
exports.name2id = function name2id(name) {
  if (!name.match(constants.AX_NAME_PATTERN)) return;
  var axNum = name.substr(5);
  if (axNum === '1') axNum = '';
  return name.charAt(0) + axNum;
};

/*
 * Cleans up the number of an axis, e.g., 'x002'->'x2', 'x0'->'x', 'x1' -> 'x',
 * etc.
 * If domainId is true, then id could be a domain reference and if it is, the
 * ' domain' part is kept at the end of the axis ID string.
 */
exports.cleanId = function cleanId(id, axLetter, domainId) {
  var domainTest = /( domain)$/.test(id);
  if (typeof id !== 'string' || !id.match(constants.AX_ID_PATTERN)) return;
  if (axLetter && id.charAt(0) !== axLetter) return;
  if (domainTest && !domainId) return;
  var axNum = id.split(' ')[0].substr(1).replace(/^0+/, '');
  if (axNum === '1') axNum = '';
  return id.charAt(0) + axNum + (domainTest && domainId ? ' domain' : '');
};

// get all axis objects, as restricted in listNames
exports.list = function (gd, axLetter, only2d) {
  var fullLayout = gd._fullLayout;
  if (!fullLayout) return [];
  var idList = exports.listIds(gd, axLetter);
  var out = new Array(idList.length);
  var i;
  for (i = 0; i < idList.length; i++) {
    var idi = idList[i];
    out[i] = fullLayout[idi.charAt(0) + 'axis' + idi.substr(1)];
  }
  if (!only2d) {
    var sceneIds3D = fullLayout._subplots.gl3d || [];
    for (i = 0; i < sceneIds3D.length; i++) {
      var scene = fullLayout[sceneIds3D[i]];
      if (axLetter) out.push(scene[axLetter + 'axis']);else out.push(scene.xaxis, scene.yaxis, scene.zaxis);
    }
  }
  return out;
};

// get all axis ids, optionally restricted by letter
// this only makes sense for 2d axes
exports.listIds = function (gd, axLetter) {
  var fullLayout = gd._fullLayout;
  if (!fullLayout) return [];
  var subplotLists = fullLayout._subplots;
  if (axLetter) return subplotLists[axLetter + 'axis'];
  return subplotLists.xaxis.concat(subplotLists.yaxis);
};

// get an axis object from its id 'x','x2' etc
// optionally, id can be a subplot (ie 'x2y3') and type gets x or y from it
exports.getFromId = function (gd, id, type) {
  var fullLayout = gd._fullLayout;
  // remove "domain" suffix
  id = id === undefined || typeof id !== 'string' ? id : id.replace(' domain', '');
  if (type === 'x') id = id.replace(/y[0-9]*/, '');else if (type === 'y') id = id.replace(/x[0-9]*/, '');
  return fullLayout[exports.id2name(id)];
};

// get an axis object of specified type from the containing trace
exports.getFromTrace = function (gd, fullTrace, type) {
  var fullLayout = gd._fullLayout;
  var ax = null;
  if (Registry.traceIs(fullTrace, 'gl3d')) {
    var scene = fullTrace.scene;
    if (scene.substr(0, 5) === 'scene') {
      ax = fullLayout[scene][type + 'axis'];
    }
  } else {
    ax = exports.getFromId(gd, fullTrace[type + 'axis'] || type);
  }
  return ax;
};

// sort x, x2, x10, y, y2, y10...
exports.idSort = function (id1, id2) {
  var letter1 = id1.charAt(0);
  var letter2 = id2.charAt(0);
  if (letter1 !== letter2) return letter1 > letter2 ? 1 : -1;
  return +(id1.substr(1) || 1) - +(id2.substr(1) || 1);
};

/*
 * An axis reference (e.g., the contents at the 'xref' key of an object) might
 * have extra information appended. Extract the axis ID only.
 *
 * ar: the axis reference string
 *
 */
exports.ref2id = function (ar) {
  // This assumes ar has been coerced via coerceRef, and uses the shortcut of
  // checking if the first letter matches [xyz] to determine if it should
  // return the axis ID. Otherwise it returns false.
  return /^[xyz]/.test(ar) ? ar.split(' ')[0] : false;
};
function isFound(axId, list) {
  if (list && list.length) {
    for (var i = 0; i < list.length; i++) {
      if (list[i][axId]) return true;
    }
  }
  return false;
}
exports.isLinked = function (fullLayout, axId) {
  return isFound(axId, fullLayout._axisMatchGroups) || isFound(axId, fullLayout._axisConstraintGroups);
};

/***/ }),

/***/ 5258:
/***/ (function(module) {

"use strict";


function findCategories(ax, opts) {
  var dataAttr = opts.dataAttr || ax._id.charAt(0);
  var lookup = {};
  var axData;
  var i, j;
  if (opts.axData) {
    // non-x/y case
    axData = opts.axData;
  } else {
    // x/y case
    axData = [];
    for (i = 0; i < opts.data.length; i++) {
      var trace = opts.data[i];
      if (trace[dataAttr + 'axis'] === ax._id) {
        axData.push(trace);
      }
    }
  }
  for (i = 0; i < axData.length; i++) {
    var vals = axData[i][dataAttr];
    for (j = 0; j < vals.length; j++) {
      var v = vals[j];
      if (v !== null && v !== undefined) {
        lookup[v] = 1;
      }
    }
  }
  return Object.keys(lookup);
}

/**
 * Fills in category* default and initial categories.
 *
 * @param {object} containerIn : input axis object
 * @param {object} containerOut : full axis object
 * @param {function} coerce : Lib.coerce fn wrapper
 * @param {object} opts :
 *   - data {array} : (full) data trace
 * OR
 *   - axData {array} : (full) data associated with axis being coerced here
 *   - dataAttr {string} : attribute name corresponding to coordinate array
 */
module.exports = function handleCategoryOrderDefaults(containerIn, containerOut, coerce, opts) {
  if (containerOut.type !== 'category') return;
  var arrayIn = containerIn.categoryarray;
  var isValidArray = Array.isArray(arrayIn) && arrayIn.length > 0;

  // override default 'categoryorder' value when non-empty array is supplied
  var orderDefault;
  if (isValidArray) orderDefault = 'array';
  var order = coerce('categoryorder', orderDefault);
  var array;

  // coerce 'categoryarray' only in array order case
  if (order === 'array') {
    array = coerce('categoryarray');
  }

  // cannot set 'categoryorder' to 'array' with an invalid 'categoryarray'
  if (!isValidArray && order === 'array') {
    order = containerOut.categoryorder = 'trace';
  }

  // set up things for makeCalcdata
  if (order === 'trace') {
    containerOut._initialCategories = [];
  } else if (order === 'array') {
    containerOut._initialCategories = array.slice();
  } else {
    array = findCategories(containerOut, opts).sort();
    if (order === 'category ascending') {
      containerOut._initialCategories = array;
    } else if (order === 'category descending') {
      containerOut._initialCategories = array.reverse();
    }
  }
};

/***/ }),

/***/ 6287:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var Lib = __webpack_require__(1828);
var constants = __webpack_require__(606);
var ONEDAY = constants.ONEDAY;
var ONEWEEK = constants.ONEWEEK;

/**
 * Return a validated dtick value for this axis
 *
 * @param {any} dtick: the candidate dtick. valid values are numbers and strings,
 *     and further constrained depending on the axis type.
 * @param {string} axType: the axis type
 */
exports.dtick = function (dtick, axType) {
  var isLog = axType === 'log';
  var isDate = axType === 'date';
  var isCat = axType === 'category';
  var dtickDflt = isDate ? ONEDAY : 1;
  if (!dtick) return dtickDflt;
  if (isNumeric(dtick)) {
    dtick = Number(dtick);
    if (dtick <= 0) return dtickDflt;
    if (isCat) {
      // category dtick must be positive integers
      return Math.max(1, Math.round(dtick));
    }
    if (isDate) {
      // date dtick must be at least 0.1ms (our current precision)
      return Math.max(0.1, dtick);
    }
    return dtick;
  }
  if (typeof dtick !== 'string' || !(isDate || isLog)) {
    return dtickDflt;
  }
  var prefix = dtick.charAt(0);
  var dtickNum = dtick.substr(1);
  dtickNum = isNumeric(dtickNum) ? Number(dtickNum) : 0;
  if (dtickNum <= 0 || !(
  // "M<n>" gives ticks every (integer) n months
  isDate && prefix === 'M' && dtickNum === Math.round(dtickNum) ||
  // "L<f>" gives ticks linearly spaced in data (not in position) every (float) f
  isLog && prefix === 'L' ||
  // "D1" gives powers of 10 with all small digits between, "D2" gives only 2 and 5
  isLog && prefix === 'D' && (dtickNum === 1 || dtickNum === 2))) {
    return dtickDflt;
  }
  return dtick;
};

/**
 * Return a validated tick0 for this axis
 *
 * @param {any} tick0: the candidate tick0. Valid values are numbers and strings,
 *     further constrained depending on the axis type
 * @param {string} axType: the axis type
 * @param {string} calendar: for date axes, the calendar to validate/convert with
 * @param {any} dtick: an already valid dtick. Only used for D1 and D2 log dticks,
 *     which do not support tick0 at all.
 */
exports.tick0 = function (tick0, axType, calendar, dtick) {
  if (axType === 'date') {
    return Lib.cleanDate(tick0, Lib.dateTick0(calendar, dtick % ONEWEEK === 0 ? 1 : 0));
  }
  if (dtick === 'D1' || dtick === 'D2') {
    // D1 and D2 modes ignore tick0 entirely
    return undefined;
  }
  // Aside from date axes, tick0 must be numeric
  return isNumeric(tick0) ? Number(tick0) : 0;
};

/***/ }),

/***/ 5555:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var counterRegex = (__webpack_require__(587).counter);
module.exports = {
  idRegex: {
    x: counterRegex('x', '( domain)?'),
    y: counterRegex('y', '( domain)?')
  },
  attrRegex: counterRegex('[xy]axis'),
  // axis match regular expression
  xAxisMatch: counterRegex('xaxis'),
  yAxisMatch: counterRegex('yaxis'),
  // pattern matching axis ids and names
  // note that this is more permissive than counterRegex, as
  // id2name, name2id, and cleanId accept "x1" etc
  AX_ID_PATTERN: /^[xyz][0-9]*( domain)?$/,
  AX_NAME_PATTERN: /^[xyz]axis[0-9]*$/,
  // and for 2D subplots
  SUBPLOT_PATTERN: /^x([0-9]*)y([0-9]*)$/,
  HOUR_PATTERN: 'hour',
  WEEKDAY_PATTERN: 'day of week',
  // pixels to move mouse before you stop clamping to starting point
  MINDRAG: 8,
  // smallest dimension allowed for a zoombox
  MINZOOM: 20,
  // width of axis drag regions
  DRAGGERSIZE: 20,
  // delay before a redraw (relayout) after smooth panning and zooming
  REDRAWDELAY: 50,
  // last resort axis ranges for x and y axes if we have no data
  DFLTRANGEX: [-1, 6],
  DFLTRANGEY: [-1, 4],
  // Layers to keep trace types in the right order
  // N.B. each  'unique' plot method must have its own layer
  traceLayerClasses: ['imagelayer', 'heatmaplayer', 'contourcarpetlayer', 'contourlayer', 'funnellayer', 'waterfalllayer', 'barlayer', 'carpetlayer', 'violinlayer', 'boxlayer', 'ohlclayer', 'scattercarpetlayer', 'scatterlayer'],
  clipOnAxisFalseQuery: ['.scatterlayer', '.barlayer', '.funnellayer', '.waterfalllayer'],
  layerValue2layerClass: {
    'above traces': 'above',
    'below traces': 'below'
  }
};

/***/ }),

/***/ 9082:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var autorange = __webpack_require__(1739);
var id2name = (__webpack_require__(1675).id2name);
var layoutAttributes = __webpack_require__(3838);
var scaleZoom = __webpack_require__(2449);
var setConvert = __webpack_require__(1994);
var ALMOST_EQUAL = (__webpack_require__(606).ALMOST_EQUAL);
var FROM_BL = (__webpack_require__(8783).FROM_BL);
exports.handleDefaults = function (layoutIn, layoutOut, opts) {
  var axIds = opts.axIds;
  var axHasImage = opts.axHasImage;

  // sets of axes linked by `scaleanchor` OR `matches` along with the
  // scaleratios compounded together, populated in handleConstraintDefaults
  var constraintGroups = layoutOut._axisConstraintGroups = [];
  // similar to _axisConstraintGroups, but only matching axes
  var matchGroups = layoutOut._axisMatchGroups = [];
  var i, group, axId, axName, axIn, axOut, attr, val;
  for (i = 0; i < axIds.length; i++) {
    axName = id2name(axIds[i]);
    axIn = layoutIn[axName];
    axOut = layoutOut[axName];
    handleOneAxDefaults(axIn, axOut, {
      axIds: axIds,
      layoutOut: layoutOut,
      hasImage: axHasImage[axName]
    });
  }

  // save matchGroup on each matching axis
  function stash(groups, stashAttr) {
    for (i = 0; i < groups.length; i++) {
      group = groups[i];
      for (axId in group) {
        layoutOut[id2name(axId)][stashAttr] = group;
      }
    }
  }
  stash(matchGroups, '_matchGroup');

  // If any axis in a constraint group is fixedrange, they all get fixed
  // This covers matches axes, as they're now in the constraintgroup too
  // and have not yet been removed (if the group is *only* matching)
  for (i = 0; i < constraintGroups.length; i++) {
    group = constraintGroups[i];
    for (axId in group) {
      axOut = layoutOut[id2name(axId)];
      if (axOut.fixedrange) {
        for (var axId2 in group) {
          var axName2 = id2name(axId2);
          if ((layoutIn[axName2] || {}).fixedrange === false) {
            Lib.warn('fixedrange was specified as false for axis ' + axName2 + ' but was overridden because another ' + 'axis in its constraint group has fixedrange true');
          }
          layoutOut[axName2].fixedrange = true;
        }
        break;
      }
    }
  }

  // remove constraint groups that simply duplicate match groups
  i = 0;
  while (i < constraintGroups.length) {
    group = constraintGroups[i];
    for (axId in group) {
      axOut = layoutOut[id2name(axId)];
      if (axOut._matchGroup && Object.keys(axOut._matchGroup).length === Object.keys(group).length) {
        constraintGroups.splice(i, 1);
        i--;
      }
      break;
    }
    i++;
  }

  // save constraintGroup on each constrained axis
  stash(constraintGroups, '_constraintGroup');

  // make sure `matching` axes share values of necessary attributes
  // Precedence (base axis is the one that doesn't list a `matches`, ie others
  // all point to it):
  // (1) explicitly defined value in the base axis
  // (2) explicitly defined in another axis (arbitrary order)
  // (3) default in the base axis
  var matchAttrs = ['constrain', 'range', 'autorange', 'rangemode', 'rangebreaks', 'categoryorder', 'categoryarray'];
  var hasRange = false;
  var hasDayOfWeekBreaks = false;
  function setAttrVal() {
    val = axOut[attr];
    if (attr === 'rangebreaks') {
      hasDayOfWeekBreaks = axOut._hasDayOfWeekBreaks;
    }
  }
  for (i = 0; i < matchGroups.length; i++) {
    group = matchGroups[i];

    // find 'matching' range attrs
    for (var j = 0; j < matchAttrs.length; j++) {
      attr = matchAttrs[j];
      val = null;
      var baseAx;
      for (axId in group) {
        axName = id2name(axId);
        axIn = layoutIn[axName];
        axOut = layoutOut[axName];
        if (!(attr in axOut)) {
          continue;
        }
        if (!axOut.matches) {
          baseAx = axOut;
          // top priority: explicit value in base axis
          if (attr in axIn) {
            setAttrVal();
            break;
          }
        }
        if (val === null && attr in axIn) {
          // second priority: first explicit value in another axis
          setAttrVal();
        }
      }

      // special logic for coupling of range and autorange
      // if nobody explicitly specifies autorange, but someone does
      // explicitly specify range, autorange must be disabled.
      if (attr === 'range' && val && axIn.range && axIn.range.length === 2 && axIn.range[0] !== null && axIn.range[1] !== null) {
        hasRange = true;
      }
      if (attr === 'autorange' && val === null && hasRange) {
        val = false;
      }
      if (val === null && attr in baseAx) {
        // fallback: default value in base axis
        val = baseAx[attr];
      }
      // but we still might not have a value, which is fine.
      if (val !== null) {
        for (axId in group) {
          axOut = layoutOut[id2name(axId)];
          axOut[attr] = attr === 'range' ? val.slice() : val;
          if (attr === 'rangebreaks') {
            axOut._hasDayOfWeekBreaks = hasDayOfWeekBreaks;
            setConvert(axOut, layoutOut);
          }
        }
      }
    }
  }
};
function handleOneAxDefaults(axIn, axOut, opts) {
  var axIds = opts.axIds;
  var layoutOut = opts.layoutOut;
  var hasImage = opts.hasImage;
  var constraintGroups = layoutOut._axisConstraintGroups;
  var matchGroups = layoutOut._axisMatchGroups;
  var axId = axOut._id;
  var axLetter = axId.charAt(0);
  var splomStash = ((layoutOut._splomAxes || {})[axLetter] || {})[axId] || {};
  var thisID = axOut._id;
  var isX = thisID.charAt(0) === 'x';

  // Clear _matchGroup & _constraintGroup so relinkPrivateKeys doesn't keep
  // an old one around. If this axis is in a group we'll set this again later
  axOut._matchGroup = null;
  axOut._constraintGroup = null;
  function coerce(attr, dflt) {
    return Lib.coerce(axIn, axOut, layoutAttributes, attr, dflt);
  }

  // coerce the constraint mechanics even if this axis has no scaleanchor
  // because it may be the anchor of another axis.
  coerce('constrain', hasImage ? 'domain' : 'range');
  Lib.coerce(axIn, axOut, {
    constraintoward: {
      valType: 'enumerated',
      values: isX ? ['left', 'center', 'right'] : ['bottom', 'middle', 'top'],
      dflt: isX ? 'center' : 'middle'
    }
  }, 'constraintoward');

  // If this axis is already part of a constraint group, we can't
  // scaleanchor any other axis in that group, or we'd make a loop.
  // Filter axIds to enforce this, also matching axis types.
  var thisType = axOut.type;
  var i, idi;
  var linkableAxes = [];
  for (i = 0; i < axIds.length; i++) {
    idi = axIds[i];
    if (idi === thisID) continue;
    var axi = layoutOut[id2name(idi)];
    if (axi.type === thisType) {
      linkableAxes.push(idi);
    }
  }
  var thisGroup = getConstraintGroup(constraintGroups, thisID);
  if (thisGroup) {
    var linkableAxesNoLoops = [];
    for (i = 0; i < linkableAxes.length; i++) {
      idi = linkableAxes[i];
      if (!thisGroup[idi]) linkableAxesNoLoops.push(idi);
    }
    linkableAxes = linkableAxesNoLoops;
  }
  var canLink = linkableAxes.length;
  var matches, scaleanchor;
  if (canLink && (axIn.matches || splomStash.matches)) {
    matches = Lib.coerce(axIn, axOut, {
      matches: {
        valType: 'enumerated',
        values: linkableAxes,
        dflt: linkableAxes.indexOf(splomStash.matches) !== -1 ? splomStash.matches : undefined
      }
    }, 'matches');
  }

  // 'matches' wins over 'scaleanchor' - each axis can only specify one
  // constraint, but you can chain matches and scaleanchor constraints by
  // specifying them in separate axes.
  var scaleanchorDflt = hasImage && !isX ? axOut.anchor : undefined;
  if (canLink && !matches && (axIn.scaleanchor || scaleanchorDflt)) {
    scaleanchor = Lib.coerce(axIn, axOut, {
      scaleanchor: {
        valType: 'enumerated',
        values: linkableAxes.concat([false])
      }
    }, 'scaleanchor', scaleanchorDflt);
  }
  if (matches) {
    axOut._matchGroup = updateConstraintGroups(matchGroups, thisID, matches, 1);

    // Also include match constraints in the scale groups
    var matchedAx = layoutOut[id2name(matches)];
    var matchRatio = extent(layoutOut, axOut) / extent(layoutOut, matchedAx);
    if (isX !== (matches.charAt(0) === 'x')) {
      // We don't yet know the actual scale ratio of x/y matches constraints,
      // due to possible automargins, so just leave a placeholder for this:
      // 'x' means "x size over y size", 'y' means the inverse.
      // in principle in the constraint group you could get multiple of these.
      matchRatio = (isX ? 'x' : 'y') + matchRatio;
    }
    updateConstraintGroups(constraintGroups, thisID, matches, matchRatio);
  } else if (axIn.matches && axIds.indexOf(axIn.matches) !== -1) {
    Lib.warn('ignored ' + axOut._name + '.matches: "' + axIn.matches + '" to avoid an infinite loop');
  }
  if (scaleanchor) {
    var scaleratio = coerce('scaleratio');

    // TODO: I suppose I could do attribute.min: Number.MIN_VALUE to avoid zero,
    // but that seems hacky. Better way to say "must be a positive number"?
    // Of course if you use several super-tiny values you could eventually
    // force a product of these to zero and all hell would break loose...
    // Likewise with super-huge values.
    if (!scaleratio) scaleratio = axOut.scaleratio = 1;
    updateConstraintGroups(constraintGroups, thisID, scaleanchor, scaleratio);
  } else if (axIn.scaleanchor && axIds.indexOf(axIn.scaleanchor) !== -1) {
    Lib.warn('ignored ' + axOut._name + '.scaleanchor: "' + axIn.scaleanchor + '" to avoid either an infinite loop ' + 'and possibly inconsistent scaleratios, or because this axis ' + 'declares a *matches* constraint.');
  }
}
function extent(layoutOut, ax) {
  var domain = ax.domain;
  if (!domain) {
    // at this point overlaying axes haven't yet inherited their main domains
    // TODO: constrain: domain with overlaying axes is likely a bug.
    domain = layoutOut[id2name(ax.overlaying)].domain;
  }
  return domain[1] - domain[0];
}
function getConstraintGroup(groups, thisID) {
  for (var i = 0; i < groups.length; i++) {
    if (groups[i][thisID]) {
      return groups[i];
    }
  }
  return null;
}

/*
 * Add this axis to the axis constraint groups, which is the collection
 * of axes that are all constrained together on scale (or matching).
 *
 * constraintGroups: a list of objects. each object is
 * {axis_id: scale_within_group}, where scale_within_group is
 * only important relative to the rest of the group, and defines
 * the relative scales between all axes in the group
 *
 * thisGroup: the group the current axis is already in
 * thisID: the id if the current axis
 * thatID: the id of the axis to scale it with
 * scaleratio: the ratio of this axis to the thatID axis
 */
function updateConstraintGroups(constraintGroups, thisID, thatID, scaleratio) {
  var i, j, groupi, keyj, thisGroupIndex;
  var thisGroup = getConstraintGroup(constraintGroups, thisID);
  if (thisGroup === null) {
    thisGroup = {};
    thisGroup[thisID] = 1;
    thisGroupIndex = constraintGroups.length;
    constraintGroups.push(thisGroup);
  } else {
    thisGroupIndex = constraintGroups.indexOf(thisGroup);
  }
  var thisGroupKeys = Object.keys(thisGroup);

  // we know that this axis isn't in any other groups, but we don't know
  // about the thatID axis. If it is, we need to merge the groups.
  for (i = 0; i < constraintGroups.length; i++) {
    groupi = constraintGroups[i];
    if (i !== thisGroupIndex && groupi[thatID]) {
      var baseScale = groupi[thatID];
      for (j = 0; j < thisGroupKeys.length; j++) {
        keyj = thisGroupKeys[j];
        groupi[keyj] = multiplyScales(baseScale, multiplyScales(scaleratio, thisGroup[keyj]));
      }
      constraintGroups.splice(thisGroupIndex, 1);
      return;
    }
  }

  // otherwise, we insert the new thatID axis as the base scale (1)
  // in its group, and scale the rest of the group to it
  if (scaleratio !== 1) {
    for (j = 0; j < thisGroupKeys.length; j++) {
      var key = thisGroupKeys[j];
      thisGroup[key] = multiplyScales(scaleratio, thisGroup[key]);
    }
  }
  thisGroup[thatID] = 1;
}

// scales may be numbers or 'x1.3', 'yy4.5' etc to multiply by as-yet-unknown
// ratios between x and y plot sizes n times
function multiplyScales(a, b) {
  var aPrefix = '';
  var bPrefix = '';
  var aLen, bLen;
  if (typeof a === 'string') {
    aPrefix = a.match(/^[xy]*/)[0];
    aLen = aPrefix.length;
    a = +a.substr(aLen);
  }
  if (typeof b === 'string') {
    bPrefix = b.match(/^[xy]*/)[0];
    bLen = bPrefix.length;
    b = +b.substr(bLen);
  }
  var c = a * b;

  // just two numbers
  if (!aLen && !bLen) {
    return c;
  }

  // one or more prefixes of the same type
  if (!aLen || !bLen || aPrefix.charAt(0) === bPrefix.charAt(0)) {
    return aPrefix + bPrefix + a * b;
  }

  // x and y cancel each other out exactly - back to a number
  if (aLen === bLen) {
    return c;
  }

  // partial cancelation of prefixes
  return (aLen > bLen ? aPrefix.substr(bLen) : bPrefix.substr(aLen)) + c;
}
function finalRatios(group, fullLayout) {
  var size = fullLayout._size;
  var yRatio = size.h / size.w;
  var out = {};
  var keys = Object.keys(group);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var val = group[key];
    if (typeof val === 'string') {
      var prefix = val.match(/^[xy]*/)[0];
      var pLen = prefix.length;
      val = +val.substr(pLen);
      var mult = prefix.charAt(0) === 'y' ? yRatio : 1 / yRatio;
      for (var j = 0; j < pLen; j++) {
        val *= mult;
      }
    }
    out[key] = val;
  }
  return out;
}
exports.enforce = function enforce(gd) {
  var fullLayout = gd._fullLayout;
  var constraintGroups = fullLayout._axisConstraintGroups || [];
  var i, j, group, axisID, ax, normScale, mode, factor;

  // matching constraints are handled in the autorange code when autoranged,
  // or in the supplyDefaults code when explicitly ranged.
  // now we just need to handle scaleanchor constraints
  // matches constraints that chain with scaleanchor constraints are included
  // here too, but because matches has already been satisfied,
  // any changes here should preserve that.
  for (i = 0; i < constraintGroups.length; i++) {
    group = finalRatios(constraintGroups[i], fullLayout);
    var axisIDs = Object.keys(group);
    var minScale = Infinity;
    var maxScale = 0;
    // mostly matchScale will be the same as minScale
    // ie we expand axis ranges to encompass *everything*
    // that's currently in any of their ranges, but during
    // autorange of a subset of axes we will ignore other
    // axes for this purpose.
    var matchScale = Infinity;
    var normScales = {};
    var axes = {};
    var hasAnyDomainConstraint = false;

    // find the (normalized) scale of each axis in the group
    for (j = 0; j < axisIDs.length; j++) {
      axisID = axisIDs[j];
      axes[axisID] = ax = fullLayout[id2name(axisID)];
      if (ax._inputDomain) ax.domain = ax._inputDomain.slice();else ax._inputDomain = ax.domain.slice();
      if (!ax._inputRange) ax._inputRange = ax.range.slice();

      // set axis scale here so we can use _m rather than
      // having to calculate it from length and range
      ax.setScale();

      // abs: inverted scales still satisfy the constraint
      normScales[axisID] = normScale = Math.abs(ax._m) / group[axisID];
      minScale = Math.min(minScale, normScale);
      if (ax.constrain === 'domain' || !ax._constraintShrinkable) {
        matchScale = Math.min(matchScale, normScale);
      }

      // this has served its purpose, so remove it
      delete ax._constraintShrinkable;
      maxScale = Math.max(maxScale, normScale);
      if (ax.constrain === 'domain') hasAnyDomainConstraint = true;
    }

    // Do we have a constraint mismatch? Give a small buffer for rounding errors
    if (minScale > ALMOST_EQUAL * maxScale && !hasAnyDomainConstraint) continue;

    // now increase any ranges we need to until all normalized scales are equal
    for (j = 0; j < axisIDs.length; j++) {
      axisID = axisIDs[j];
      normScale = normScales[axisID];
      ax = axes[axisID];
      mode = ax.constrain;

      // even if the scale didn't change, if we're shrinking domain
      // we need to recalculate in case `constraintoward` changed
      if (normScale !== matchScale || mode === 'domain') {
        factor = normScale / matchScale;
        if (mode === 'range') {
          scaleZoom(ax, factor);
        } else {
          // mode === 'domain'

          var inputDomain = ax._inputDomain;
          var domainShrunk = (ax.domain[1] - ax.domain[0]) / (inputDomain[1] - inputDomain[0]);
          var rangeShrunk = (ax.r2l(ax.range[1]) - ax.r2l(ax.range[0])) / (ax.r2l(ax._inputRange[1]) - ax.r2l(ax._inputRange[0]));
          factor /= domainShrunk;
          if (factor * rangeShrunk < 1) {
            // we've asked to magnify the axis more than we can just by
            // enlarging the domain - so we need to constrict range
            ax.domain = ax._input.domain = inputDomain.slice();
            scaleZoom(ax, factor);
            continue;
          }
          if (rangeShrunk < 1) {
            // the range has previously been constricted by ^^, but we've
            // switched to the domain-constricted regime, so reset range
            ax.range = ax._input.range = ax._inputRange.slice();
            factor *= rangeShrunk;
          }
          if (ax.autorange) {
            /*
             * range & factor may need to change because range was
             * calculated for the larger scaling, so some pixel
             * paddings may get cut off when we reduce the domain.
             *
             * This is easier than the regular autorange calculation
             * because we already know the scaling `m`, but we still
             * need to cut out impossible constraints (like
             * annotations with super-long arrows). That's what
             * outerMin/Max are for - if the expansion was going to
             * go beyond the original domain, it must be impossible
             */
            var rl0 = ax.r2l(ax.range[0]);
            var rl1 = ax.r2l(ax.range[1]);
            var rangeCenter = (rl0 + rl1) / 2;
            var rangeMin = rangeCenter;
            var rangeMax = rangeCenter;
            var halfRange = Math.abs(rl1 - rangeCenter);
            // extra tiny bit for rounding errors, in case we actually
            // *are* expanding to the full domain
            var outerMin = rangeCenter - halfRange * factor * 1.0001;
            var outerMax = rangeCenter + halfRange * factor * 1.0001;
            var getPadMin = autorange.makePadFn(fullLayout, ax, 0);
            var getPadMax = autorange.makePadFn(fullLayout, ax, 1);
            updateDomain(ax, factor);
            var m = Math.abs(ax._m);
            var extremes = autorange.concatExtremes(gd, ax);
            var minArray = extremes.min;
            var maxArray = extremes.max;
            var newVal;
            var k;
            for (k = 0; k < minArray.length; k++) {
              newVal = minArray[k].val - getPadMin(minArray[k]) / m;
              if (newVal > outerMin && newVal < rangeMin) {
                rangeMin = newVal;
              }
            }
            for (k = 0; k < maxArray.length; k++) {
              newVal = maxArray[k].val + getPadMax(maxArray[k]) / m;
              if (newVal < outerMax && newVal > rangeMax) {
                rangeMax = newVal;
              }
            }
            var domainExpand = (rangeMax - rangeMin) / (2 * halfRange);
            factor /= domainExpand;
            rangeMin = ax.l2r(rangeMin);
            rangeMax = ax.l2r(rangeMax);
            ax.range = ax._input.range = rl0 < rl1 ? [rangeMin, rangeMax] : [rangeMax, rangeMin];
          }
          updateDomain(ax, factor);
        }
      }
    }
  }
};
exports.getAxisGroup = function getAxisGroup(fullLayout, axId) {
  var matchGroups = fullLayout._axisMatchGroups;
  for (var i = 0; i < matchGroups.length; i++) {
    var group = matchGroups[i];
    if (group[axId]) return 'g' + i;
  }
  return axId;
};

// For use before autoranging, check if this axis was previously constrained
// by domain but no longer is
exports.clean = function clean(gd, ax) {
  if (ax._inputDomain) {
    var isConstrained = false;
    var axId = ax._id;
    var constraintGroups = gd._fullLayout._axisConstraintGroups;
    for (var j = 0; j < constraintGroups.length; j++) {
      if (constraintGroups[j][axId]) {
        isConstrained = true;
        break;
      }
    }
    if (!isConstrained || ax.constrain !== 'domain') {
      ax._input.domain = ax.domain = ax._inputDomain;
      delete ax._inputDomain;
    }
  }
};
function updateDomain(ax, factor) {
  var inputDomain = ax._inputDomain;
  var centerFraction = FROM_BL[ax.constraintoward];
  var center = inputDomain[0] + (inputDomain[1] - inputDomain[0]) * centerFraction;
  ax.domain = ax._input.domain = [center + (inputDomain[0] - center) / factor, center + (inputDomain[1] - center) / factor];
  ax.setScale();
}

/***/ }),

/***/ 9323:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Lib = __webpack_require__(1828);
var numberFormat = Lib.numberFormat;
var tinycolor = __webpack_require__(4267);
var supportsPassive = __webpack_require__(8520);
var Registry = __webpack_require__(3972);
var strTranslate = Lib.strTranslate;
var svgTextUtils = __webpack_require__(3893);
var Color = __webpack_require__(7901);
var Drawing = __webpack_require__(1424);
var Fx = __webpack_require__(211);
var Axes = __webpack_require__(9298);
var setCursor = __webpack_require__(6964);
var dragElement = __webpack_require__(8569);
var helpers = __webpack_require__(4505);
var selectingOrDrawing = helpers.selectingOrDrawing;
var freeMode = helpers.freeMode;
var FROM_TL = (__webpack_require__(8783).FROM_TL);
var clearGlCanvases = __webpack_require__(3306);
var redrawReglTraces = (__webpack_require__(1549).redrawReglTraces);
var Plots = __webpack_require__(4875);
var getFromId = (__webpack_require__(1675).getFromId);
var prepSelect = (__webpack_require__(7322).prepSelect);
var clearOutline = (__webpack_require__(7322).clearOutline);
var selectOnClick = (__webpack_require__(7322).selectOnClick);
var scaleZoom = __webpack_require__(2449);
var constants = __webpack_require__(5555);
var MINDRAG = constants.MINDRAG;
var MINZOOM = constants.MINZOOM;

// flag for showing "doubleclick to zoom out" only at the beginning
var SHOWZOOMOUTTIP = true;

// dragBox: create an element to drag one or more axis ends
// inputs:
//      plotinfo - which subplot are we making dragboxes on?
//      x,y,w,h - left, top, width, height of the box
//      ns - how does this drag the vertical axis?
//          'n' - top only
//          's' - bottom only
//          'ns' - top and bottom together, difference unchanged
//      ew - same for horizontal axis
function makeDragBox(gd, plotinfo, x, y, w, h, ns, ew) {
  // mouseDown stores ms of first mousedown event in the last
  // `gd._context.doubleClickDelay` ms on the drag bars
  // numClicks stores how many mousedowns have been seen
  // within `gd._context.doubleClickDelay` so we can check for click or doubleclick events
  // dragged stores whether a drag has occurred, so we don't have to
  // redraw unnecessarily, ie if no move bigger than MINDRAG or MINZOOM px
  var zoomlayer = gd._fullLayout._zoomlayer;
  var isMainDrag = ns + ew === 'nsew';
  var singleEnd = (ns + ew).length === 1;

  // main subplot x and y (i.e. found in plotinfo - the main ones)
  var xa0, ya0;
  // {ax._id: ax} hash objects
  var xaHash, yaHash;
  // xaHash/yaHash values (arrays)
  var xaxes, yaxes;
  // main axis offsets
  var xs, ys;
  // main axis lengths
  var pw, ph;
  // contains keys 'xaHash', 'yaHash', 'xaxes', and 'yaxes'
  // which are the x/y {ax._id: ax} hash objects and their values
  // for linked axis relative to this subplot
  var links;
  // similar to `links` but for matching axes
  var matches;
  // set to ew/ns val when active, set to '' when inactive
  var xActive, yActive;
  // are all axes in this subplot are fixed?
  var allFixedRanges;
  // do we need to edit x/y ranges?
  var editX, editY;
  // graph-wide optimization flags
  var hasScatterGl, hasSplom, hasSVG;
  // collected changes to be made to the plot by relayout at the end
  var updates;
  // scaling factors from css transform
  var scaleX;
  var scaleY;

  // offset the x location of the box if needed
  x += plotinfo.yaxis._shift;
  function recomputeAxisLists() {
    xa0 = plotinfo.xaxis;
    ya0 = plotinfo.yaxis;
    pw = xa0._length;
    ph = ya0._length;
    xs = xa0._offset;
    ys = ya0._offset;
    xaHash = {};
    xaHash[xa0._id] = xa0;
    yaHash = {};
    yaHash[ya0._id] = ya0;

    // if we're dragging two axes at once, also drag overlays
    if (ns && ew) {
      var overlays = plotinfo.overlays;
      for (var i = 0; i < overlays.length; i++) {
        var xa = overlays[i].xaxis;
        xaHash[xa._id] = xa;
        var ya = overlays[i].yaxis;
        yaHash[ya._id] = ya;
      }
    }
    xaxes = hashValues(xaHash);
    yaxes = hashValues(yaHash);
    xActive = isDirectionActive(xaxes, ew);
    yActive = isDirectionActive(yaxes, ns);
    allFixedRanges = !yActive && !xActive;
    matches = calcLinks(gd, gd._fullLayout._axisMatchGroups, xaHash, yaHash);
    links = calcLinks(gd, gd._fullLayout._axisConstraintGroups, xaHash, yaHash, matches);
    var spConstrained = links.isSubplotConstrained || matches.isSubplotConstrained;
    editX = ew || spConstrained;
    editY = ns || spConstrained;
    var fullLayout = gd._fullLayout;
    hasScatterGl = fullLayout._has('scattergl');
    hasSplom = fullLayout._has('splom');
    hasSVG = fullLayout._has('svg');
  }
  recomputeAxisLists();
  var cursor = getDragCursor(yActive + xActive, gd._fullLayout.dragmode, isMainDrag);
  var dragger = makeRectDragger(plotinfo, ns + ew + 'drag', cursor, x, y, w, h);

  // still need to make the element if the axes are disabled
  // but nuke its events (except for maindrag which needs them for hover)
  // and stop there
  if (allFixedRanges && !isMainDrag) {
    dragger.onmousedown = null;
    dragger.style.pointerEvents = 'none';
    return dragger;
  }
  var dragOptions = {
    element: dragger,
    gd: gd,
    plotinfo: plotinfo
  };
  dragOptions.prepFn = function (e, startX, startY) {
    var dragModePrev = dragOptions.dragmode;
    var dragModeNow = gd._fullLayout.dragmode;
    if (dragModeNow !== dragModePrev) {
      dragOptions.dragmode = dragModeNow;
    }
    recomputeAxisLists();
    scaleX = gd._fullLayout._invScaleX;
    scaleY = gd._fullLayout._invScaleY;
    if (!allFixedRanges) {
      if (isMainDrag) {
        // main dragger handles all drag modes, and changes
        // to pan (or to zoom if it already is pan) on shift
        if (e.shiftKey) {
          if (dragModeNow === 'pan') dragModeNow = 'zoom';else if (!selectingOrDrawing(dragModeNow)) dragModeNow = 'pan';
        } else if (e.ctrlKey) {
          dragModeNow = 'pan';
        }
      } else {
        // all other draggers just pan
        dragModeNow = 'pan';
      }
    }
    if (freeMode(dragModeNow)) dragOptions.minDrag = 1;else dragOptions.minDrag = undefined;
    if (selectingOrDrawing(dragModeNow)) {
      dragOptions.xaxes = xaxes;
      dragOptions.yaxes = yaxes;
      // this attaches moveFn, clickFn, doneFn on dragOptions
      prepSelect(e, startX, startY, dragOptions, dragModeNow);
    } else {
      dragOptions.clickFn = clickFn;
      if (selectingOrDrawing(dragModePrev)) {
        // TODO Fix potential bug
        // Note: clearing / resetting selection state only happens, when user
        // triggers at least one interaction in pan/zoom mode. Otherwise, the
        // select/lasso outlines are deleted (in plots.js.cleanPlot) but the selection
        // cache isn't cleared. So when the user switches back to select/lasso and
        // 'adds to a selection' with Shift, the "old", seemingly removed outlines
        // are redrawn again because the selection cache still holds their coordinates.
        // However, this isn't easily solved, since plots.js would need
        // to have a reference to the dragOptions object (which holds the
        // selection cache).
        clearAndResetSelect();
      }
      if (!allFixedRanges) {
        if (dragModeNow === 'zoom') {
          dragOptions.moveFn = zoomMove;
          dragOptions.doneFn = zoomDone;

          // zoomMove takes care of the threshold, but we need to
          // minimize this so that constrained zoom boxes will flip
          // orientation at the right place
          dragOptions.minDrag = 1;
          zoomPrep(e, startX, startY);
        } else if (dragModeNow === 'pan') {
          dragOptions.moveFn = plotDrag;
          dragOptions.doneFn = dragTail;
        }
      }
    }
    gd._fullLayout._redrag = function () {
      var dragDataNow = gd._dragdata;
      if (dragDataNow && dragDataNow.element === dragger) {
        var dragModeNow = gd._fullLayout.dragmode;
        if (!selectingOrDrawing(dragModeNow)) {
          recomputeAxisLists();
          updateSubplots([0, 0, pw, ph]);
          dragOptions.moveFn(dragDataNow.dx, dragDataNow.dy);
        }
      }
    };
  };
  function clearAndResetSelect() {
    // clear selection polygon cache (if any)
    dragOptions.plotinfo.selection = false;
    // clear selection outlines
    clearOutline(gd);
  }
  function clickFn(numClicks, evt) {
    var gd = dragOptions.gd;
    if (gd._fullLayout._activeShapeIndex >= 0) {
      gd._fullLayout._deactivateShape(gd);
      return;
    }
    var clickmode = gd._fullLayout.clickmode;
    removeZoombox(gd);
    if (numClicks === 2 && !singleEnd) doubleClick();
    if (isMainDrag) {
      if (clickmode.indexOf('select') > -1) {
        selectOnClick(evt, gd, xaxes, yaxes, plotinfo.id, dragOptions);
      }
      if (clickmode.indexOf('event') > -1) {
        Fx.click(gd, evt, plotinfo.id);
      }
    } else if (numClicks === 1 && singleEnd) {
      var ax = ns ? ya0 : xa0;
      var end = ns === 's' || ew === 'w' ? 0 : 1;
      var attrStr = ax._name + '.range[' + end + ']';
      var initialText = getEndText(ax, end);
      var hAlign = 'left';
      var vAlign = 'middle';
      if (ax.fixedrange) return;
      if (ns) {
        vAlign = ns === 'n' ? 'top' : 'bottom';
        if (ax.side === 'right') hAlign = 'right';
      } else if (ew === 'e') hAlign = 'right';
      if (gd._context.showAxisRangeEntryBoxes) {
        d3.select(dragger).call(svgTextUtils.makeEditable, {
          gd: gd,
          immediate: true,
          background: gd._fullLayout.paper_bgcolor,
          text: String(initialText),
          fill: ax.tickfont ? ax.tickfont.color : '#444',
          horizontalAlign: hAlign,
          verticalAlign: vAlign
        }).on('edit', function (text) {
          var v = ax.d2r(text);
          if (v !== undefined) {
            Registry.call('_guiRelayout', gd, attrStr, v);
          }
        });
      }
    }
  }
  dragElement.init(dragOptions);

  // x/y px position at start of drag
  var x0, y0;
  // bbox object of the zoombox
  var box;
  // luminance of bg behind zoombox
  var lum;
  // zoombox path outline
  var path0;
  // is zoombox dimmed (during drag)
  var dimmed;
  // 'x'-only, 'y' or 'xy' zooming
  var zoomMode;
  // zoombox d3 selection
  var zb;
  // zoombox corner d3 selection
  var corners;
  // zoom takes over minDrag, so it also has to take over gd._dragged
  var zoomDragged;
  function zoomPrep(e, startX, startY) {
    var dragBBox = dragger.getBoundingClientRect();
    x0 = startX - dragBBox.left;
    y0 = startY - dragBBox.top;
    gd._fullLayout._calcInverseTransform(gd);
    var transformedCoords = Lib.apply3DTransform(gd._fullLayout._invTransform)(x0, y0);
    x0 = transformedCoords[0];
    y0 = transformedCoords[1];
    box = {
      l: x0,
      r: x0,
      w: 0,
      t: y0,
      b: y0,
      h: 0
    };
    lum = gd._hmpixcount ? gd._hmlumcount / gd._hmpixcount : tinycolor(gd._fullLayout.plot_bgcolor).getLuminance();
    path0 = 'M0,0H' + pw + 'V' + ph + 'H0V0';
    dimmed = false;
    zoomMode = 'xy';
    zoomDragged = false;
    zb = makeZoombox(zoomlayer, lum, xs, ys, path0);
    corners = makeCorners(zoomlayer, xs, ys);
  }
  function zoomMove(dx0, dy0) {
    if (gd._transitioningWithDuration) {
      return false;
    }
    var x1 = Math.max(0, Math.min(pw, scaleX * dx0 + x0));
    var y1 = Math.max(0, Math.min(ph, scaleY * dy0 + y0));
    var dx = Math.abs(x1 - x0);
    var dy = Math.abs(y1 - y0);
    box.l = Math.min(x0, x1);
    box.r = Math.max(x0, x1);
    box.t = Math.min(y0, y1);
    box.b = Math.max(y0, y1);
    function noZoom() {
      zoomMode = '';
      box.r = box.l;
      box.t = box.b;
      corners.attr('d', 'M0,0Z');
    }
    if (links.isSubplotConstrained) {
      if (dx > MINZOOM || dy > MINZOOM) {
        zoomMode = 'xy';
        if (dx / pw > dy / ph) {
          dy = dx * ph / pw;
          if (y0 > y1) box.t = y0 - dy;else box.b = y0 + dy;
        } else {
          dx = dy * pw / ph;
          if (x0 > x1) box.l = x0 - dx;else box.r = x0 + dx;
        }
        corners.attr('d', xyCorners(box));
      } else {
        noZoom();
      }
    } else if (matches.isSubplotConstrained) {
      if (dx > MINZOOM || dy > MINZOOM) {
        zoomMode = 'xy';
        var r0 = Math.min(box.l / pw, (ph - box.b) / ph);
        var r1 = Math.max(box.r / pw, (ph - box.t) / ph);
        box.l = r0 * pw;
        box.r = r1 * pw;
        box.b = (1 - r0) * ph;
        box.t = (1 - r1) * ph;
        corners.attr('d', xyCorners(box));
      } else {
        noZoom();
      }
    } else if (!yActive || dy < Math.min(Math.max(dx * 0.6, MINDRAG), MINZOOM)) {
      // look for small drags in one direction or the other,
      // and only drag the other axis

      if (dx < MINDRAG || !xActive) {
        noZoom();
      } else {
        box.t = 0;
        box.b = ph;
        zoomMode = 'x';
        corners.attr('d', xCorners(box, y0));
      }
    } else if (!xActive || dx < Math.min(dy * 0.6, MINZOOM)) {
      box.l = 0;
      box.r = pw;
      zoomMode = 'y';
      corners.attr('d', yCorners(box, x0));
    } else {
      zoomMode = 'xy';
      corners.attr('d', xyCorners(box));
    }
    box.w = box.r - box.l;
    box.h = box.b - box.t;
    if (zoomMode) zoomDragged = true;
    gd._dragged = zoomDragged;
    updateZoombox(zb, corners, box, path0, dimmed, lum);
    computeZoomUpdates();
    gd.emit('plotly_relayouting', updates);
    dimmed = true;
  }
  function computeZoomUpdates() {
    updates = {};

    // TODO: edit linked axes in zoomAxRanges and in dragTail
    if (zoomMode === 'xy' || zoomMode === 'x') {
      zoomAxRanges(xaxes, box.l / pw, box.r / pw, updates, links.xaxes);
      updateMatchedAxRange('x', updates);
    }
    if (zoomMode === 'xy' || zoomMode === 'y') {
      zoomAxRanges(yaxes, (ph - box.b) / ph, (ph - box.t) / ph, updates, links.yaxes);
      updateMatchedAxRange('y', updates);
    }
  }
  function zoomDone() {
    computeZoomUpdates();
    removeZoombox(gd);
    dragTail();
    showDoubleClickNotifier(gd);
  }

  // scroll zoom, on all draggers except corners
  var scrollViewBox = [0, 0, pw, ph];
  // wait a little after scrolling before redrawing
  var redrawTimer = null;
  var REDRAWDELAY = constants.REDRAWDELAY;
  var mainplot = plotinfo.mainplot ? gd._fullLayout._plots[plotinfo.mainplot] : plotinfo;
  function zoomWheel(e) {
    // deactivate mousewheel scrolling on embedded graphs
    // devs can override this with layout._enablescrollzoom,
    // but _ ensures this setting won't leave their page
    if (!gd._context._scrollZoom.cartesian && !gd._fullLayout._enablescrollzoom) {
      return;
    }
    clearAndResetSelect();

    // If a transition is in progress, then disable any behavior:
    if (gd._transitioningWithDuration) {
      e.preventDefault();
      e.stopPropagation();
      return;
    }
    recomputeAxisLists();
    clearTimeout(redrawTimer);
    var wheelDelta = -e.deltaY;
    if (!isFinite(wheelDelta)) wheelDelta = e.wheelDelta / 10;
    if (!isFinite(wheelDelta)) {
      Lib.log('Did not find wheel motion attributes: ', e);
      return;
    }
    var zoom = Math.exp(-Math.min(Math.max(wheelDelta, -20), 20) / 200);
    var gbb = mainplot.draglayer.select('.nsewdrag').node().getBoundingClientRect();
    var xfrac = (e.clientX - gbb.left) / gbb.width;
    var yfrac = (gbb.bottom - e.clientY) / gbb.height;
    var i;
    function zoomWheelOneAxis(ax, centerFraction, zoom) {
      if (ax.fixedrange) return;
      var axRange = Lib.simpleMap(ax.range, ax.r2l);
      var v0 = axRange[0] + (axRange[1] - axRange[0]) * centerFraction;
      function doZoom(v) {
        return ax.l2r(v0 + (v - v0) * zoom);
      }
      ax.range = axRange.map(doZoom);
    }
    if (editX) {
      // if we're only zooming this axis because of constraints,
      // zoom it about the center
      if (!ew) xfrac = 0.5;
      for (i = 0; i < xaxes.length; i++) {
        zoomWheelOneAxis(xaxes[i], xfrac, zoom);
      }
      updateMatchedAxRange('x');
      scrollViewBox[2] *= zoom;
      scrollViewBox[0] += scrollViewBox[2] * xfrac * (1 / zoom - 1);
    }
    if (editY) {
      if (!ns) yfrac = 0.5;
      for (i = 0; i < yaxes.length; i++) {
        zoomWheelOneAxis(yaxes[i], yfrac, zoom);
      }
      updateMatchedAxRange('y');
      scrollViewBox[3] *= zoom;
      scrollViewBox[1] += scrollViewBox[3] * (1 - yfrac) * (1 / zoom - 1);
    }

    // viewbox redraw at first
    updateSubplots(scrollViewBox);
    ticksAndAnnotations();
    gd.emit('plotly_relayouting', updates);

    // then replot after a delay to make sure
    // no more scrolling is coming
    redrawTimer = setTimeout(function () {
      if (!gd._fullLayout) return;
      scrollViewBox = [0, 0, pw, ph];
      dragTail();
    }, REDRAWDELAY);
    e.preventDefault();
    return;
  }

  // everything but the corners gets wheel zoom
  if (ns.length * ew.length !== 1) {
    attachWheelEventHandler(dragger, zoomWheel);
  }

  // plotDrag: move the plot in response to a drag
  function plotDrag(dx, dy) {
    dx = dx * scaleX;
    dy = dy * scaleY;
    // If a transition is in progress, then disable any behavior:
    if (gd._transitioningWithDuration) {
      return;
    }

    // prevent axis drawing from monkeying with margins until we're done
    gd._fullLayout._replotting = true;
    if (xActive === 'ew' || yActive === 'ns') {
      var spDx = xActive ? -dx : 0;
      var spDy = yActive ? -dy : 0;
      if (matches.isSubplotConstrained) {
        if (xActive && yActive) {
          var frac = (dx / pw - dy / ph) / 2;
          dx = frac * pw;
          dy = -frac * ph;
          spDx = -dx;
          spDy = -dy;
        }
        if (yActive) {
          spDx = -spDy * pw / ph;
        } else {
          spDy = -spDx * ph / pw;
        }
      }
      if (xActive) {
        dragAxList(xaxes, dx);
        updateMatchedAxRange('x');
      }
      if (yActive) {
        dragAxList(yaxes, dy);
        updateMatchedAxRange('y');
      }
      updateSubplots([spDx, spDy, pw, ph]);
      ticksAndAnnotations();
      gd.emit('plotly_relayouting', updates);
      return;
    }

    // dz: set a new value for one end (0 or 1) of an axis array axArray,
    // and return a pixel shift for that end for the viewbox
    // based on pixel drag distance d
    // TODO: this makes (generally non-fatal) errors when you get
    // near floating point limits
    function dz(axArray, end, d) {
      var otherEnd = 1 - end;
      var movedAx;
      var newLinearizedEnd;
      for (var i = 0; i < axArray.length; i++) {
        var axi = axArray[i];
        if (axi.fixedrange) continue;
        movedAx = axi;
        newLinearizedEnd = axi._rl[otherEnd] + (axi._rl[end] - axi._rl[otherEnd]) / dZoom(d / axi._length);
        var newEnd = axi.l2r(newLinearizedEnd);

        // if l2r comes back false or undefined, it means we've dragged off
        // the end of valid ranges - so stop.
        if (newEnd !== false && newEnd !== undefined) axi.range[end] = newEnd;
      }
      return movedAx._length * (movedAx._rl[end] - newLinearizedEnd) / (movedAx._rl[end] - movedAx._rl[otherEnd]);
    }
    var dxySign = xActive === 'w' === (yActive === 'n') ? 1 : -1;
    if (xActive && yActive && (links.isSubplotConstrained || matches.isSubplotConstrained)) {
      // dragging a corner of a constrained subplot:
      // respect the fixed corner, but harmonize dx and dy
      var dxyFraction = (dx / pw + dxySign * dy / ph) / 2;
      dx = dxyFraction * pw;
      dy = dxySign * dxyFraction * ph;
    }
    var xStart, yStart;
    if (xActive === 'w') dx = dz(xaxes, 0, dx);else if (xActive === 'e') dx = dz(xaxes, 1, -dx);else if (!xActive) dx = 0;
    if (yActive === 'n') dy = dz(yaxes, 1, dy);else if (yActive === 's') dy = dz(yaxes, 0, -dy);else if (!yActive) dy = 0;
    xStart = xActive === 'w' ? dx : 0;
    yStart = yActive === 'n' ? dy : 0;
    if (links.isSubplotConstrained && !matches.isSubplotConstrained ||
    // NW or SE on matching axes - create a symmetric zoom
    matches.isSubplotConstrained && xActive && yActive && dxySign > 0) {
      var i;
      if (matches.isSubplotConstrained || !xActive && yActive.length === 1) {
        // dragging one end of the y axis of a constrained subplot
        // scale the other axis the same about its middle
        for (i = 0; i < xaxes.length; i++) {
          xaxes[i].range = xaxes[i]._r.slice();
          scaleZoom(xaxes[i], 1 - dy / ph);
        }
        dx = dy * pw / ph;
        xStart = dx / 2;
      }
      if (matches.isSubplotConstrained || !yActive && xActive.length === 1) {
        for (i = 0; i < yaxes.length; i++) {
          yaxes[i].range = yaxes[i]._r.slice();
          scaleZoom(yaxes[i], 1 - dx / pw);
        }
        dy = dx * ph / pw;
        yStart = dy / 2;
      }
    }
    if (!matches.isSubplotConstrained || !yActive) {
      updateMatchedAxRange('x');
    }
    if (!matches.isSubplotConstrained || !xActive) {
      updateMatchedAxRange('y');
    }
    var xSize = pw - dx;
    var ySize = ph - dy;
    if (matches.isSubplotConstrained && !(xActive && yActive)) {
      if (xActive) {
        yStart = xStart ? 0 : dx * ph / pw;
        ySize = xSize * ph / pw;
      } else {
        xStart = yStart ? 0 : dy * pw / ph;
        xSize = ySize * pw / ph;
      }
    }
    updateSubplots([xStart, yStart, xSize, ySize]);
    ticksAndAnnotations();
    gd.emit('plotly_relayouting', updates);
  }
  function updateMatchedAxRange(axLetter, out) {
    var matchedAxes = matches.isSubplotConstrained ? {
      x: yaxes,
      y: xaxes
    }[axLetter] : matches[axLetter + 'axes'];
    var constrainedAxes = matches.isSubplotConstrained ? {
      x: xaxes,
      y: yaxes
    }[axLetter] : [];
    for (var i = 0; i < matchedAxes.length; i++) {
      var ax = matchedAxes[i];
      var axId = ax._id;
      var axId2 = matches.xLinks[axId] || matches.yLinks[axId];
      var ax2 = constrainedAxes[0] || xaHash[axId2] || yaHash[axId2];
      if (ax2) {
        if (out) {
          // zoombox case - don't mutate 'range', just add keys in 'updates'
          out[ax._name + '.range[0]'] = out[ax2._name + '.range[0]'];
          out[ax._name + '.range[1]'] = out[ax2._name + '.range[1]'];
        } else {
          ax.range = ax2.range.slice();
        }
      }
    }
  }

  // Draw ticks and annotations (and other components) when ranges change.
  // Also records the ranges that have changed for use by update at the end.
  function ticksAndAnnotations() {
    var activeAxIds = [];
    var i;
    function pushActiveAxIds(axList) {
      for (i = 0; i < axList.length; i++) {
        if (!axList[i].fixedrange) activeAxIds.push(axList[i]._id);
      }
    }
    function pushActiveAxIdsSynced(axList, axisType) {
      for (i = 0; i < axList.length; i++) {
        var axListI = axList[i];
        var axListIType = axListI[axisType];
        if (!axListI.fixedrange && axListIType.tickmode === 'sync') activeAxIds.push(axListIType._id);
      }
    }
    if (editX) {
      pushActiveAxIds(xaxes);
      pushActiveAxIds(links.xaxes);
      pushActiveAxIds(matches.xaxes);
      pushActiveAxIdsSynced(plotinfo.overlays, 'xaxis');
    }
    if (editY) {
      pushActiveAxIds(yaxes);
      pushActiveAxIds(links.yaxes);
      pushActiveAxIds(matches.yaxes);
      pushActiveAxIdsSynced(plotinfo.overlays, 'yaxis');
    }
    updates = {};
    for (i = 0; i < activeAxIds.length; i++) {
      var axId = activeAxIds[i];
      var ax = getFromId(gd, axId);
      Axes.drawOne(gd, ax, {
        skipTitle: true
      });
      updates[ax._name + '.range[0]'] = ax.range[0];
      updates[ax._name + '.range[1]'] = ax.range[1];
    }
    Axes.redrawComponents(gd, activeAxIds);
  }
  function doubleClick() {
    if (gd._transitioningWithDuration) return;
    var doubleClickConfig = gd._context.doubleClick;
    var axList = [];
    if (xActive) axList = axList.concat(xaxes);
    if (yActive) axList = axList.concat(yaxes);
    if (matches.xaxes) axList = axList.concat(matches.xaxes);
    if (matches.yaxes) axList = axList.concat(matches.yaxes);
    var attrs = {};
    var ax, i;

    // For reset+autosize mode:
    // If *any* of the main axes is not at its initial range
    // (or autoranged, if we have no initial range, to match the logic in
    // doubleClickConfig === 'reset' below), we reset.
    // If they are *all* at their initial ranges, then we autosize.
    if (doubleClickConfig === 'reset+autosize') {
      doubleClickConfig = 'autosize';
      for (i = 0; i < axList.length; i++) {
        ax = axList[i];
        var r0 = ax._rangeInitial0;
        var r1 = ax._rangeInitial1;
        var hasRangeInitial = r0 !== undefined || r1 !== undefined;
        if (hasRangeInitial && (r0 !== undefined && r0 !== ax.range[0] || r1 !== undefined && r1 !== ax.range[1]) || !hasRangeInitial && ax.autorange !== true) {
          doubleClickConfig = 'reset';
          break;
        }
      }
    }
    if (doubleClickConfig === 'autosize') {
      // don't set the linked axes here, so relayout marks them as shrinkable
      // and we autosize just to the requested axis/axes
      for (i = 0; i < axList.length; i++) {
        ax = axList[i];
        if (!ax.fixedrange) attrs[ax._name + '.autorange'] = true;
      }
    } else if (doubleClickConfig === 'reset') {
      // when we're resetting, reset all linked axes too, so we get back
      // to the fully-auto-with-constraints situation
      if (xActive || links.isSubplotConstrained) axList = axList.concat(links.xaxes);
      if (yActive && !links.isSubplotConstrained) axList = axList.concat(links.yaxes);
      if (links.isSubplotConstrained) {
        if (!xActive) axList = axList.concat(xaxes);else if (!yActive) axList = axList.concat(yaxes);
      }
      for (i = 0; i < axList.length; i++) {
        ax = axList[i];
        if (!ax.fixedrange) {
          var axName = ax._name;
          var autorangeInitial = ax._autorangeInitial;
          if (ax._rangeInitial0 === undefined && ax._rangeInitial1 === undefined) {
            attrs[axName + '.autorange'] = true;
          } else if (ax._rangeInitial0 === undefined) {
            attrs[axName + '.autorange'] = autorangeInitial;
            attrs[axName + '.range'] = [null, ax._rangeInitial1];
          } else if (ax._rangeInitial1 === undefined) {
            attrs[axName + '.range'] = [ax._rangeInitial0, null];
            attrs[axName + '.autorange'] = autorangeInitial;
          } else {
            attrs[axName + '.range'] = [ax._rangeInitial0, ax._rangeInitial1];
          }
        }
      }
    }
    gd.emit('plotly_doubleclick', null);
    Registry.call('_guiRelayout', gd, attrs);
  }

  // dragTail - finish a drag event with a redraw
  function dragTail() {
    // put the subplot viewboxes back to default (Because we're going to)
    // be repositioning the data in the relayout. But DON'T call
    // ticksAndAnnotations again - it's unnecessary and would overwrite `updates`
    updateSubplots([0, 0, pw, ph]);

    // since we may have been redrawing some things during the drag, we may have
    // accumulated MathJax promises - wait for them before we relayout.
    Lib.syncOrAsync([Plots.previousPromises, function () {
      gd._fullLayout._replotting = false;
      Registry.call('_guiRelayout', gd, updates);
    }], gd);
  }

  // updateSubplots - find all plot viewboxes that should be
  // affected by this drag, and update them. look for all plots
  // sharing an affected axis (including the one being dragged),
  // includes also scattergl and splom logic.
  function updateSubplots(viewBox) {
    var fullLayout = gd._fullLayout;
    var plotinfos = fullLayout._plots;
    var subplots = fullLayout._subplots.cartesian;
    var i, sp, xa, ya;
    if (hasSplom) {
      Registry.subplotsRegistry.splom.drag(gd);
    }
    if (hasScatterGl) {
      for (i = 0; i < subplots.length; i++) {
        sp = plotinfos[subplots[i]];
        xa = sp.xaxis;
        ya = sp.yaxis;
        if (sp._scene) {
          var xrng = Lib.simpleMap(xa.range, xa.r2l);
          var yrng = Lib.simpleMap(ya.range, ya.r2l);
          if (xa.limitRange) xa.limitRange();
          if (ya.limitRange) ya.limitRange();
          xrng = xa.range;
          yrng = ya.range;
          sp._scene.update({
            range: [xrng[0], yrng[0], xrng[1], yrng[1]]
          });
        }
      }
    }
    if (hasSplom || hasScatterGl) {
      clearGlCanvases(gd);
      redrawReglTraces(gd);
    }
    if (hasSVG) {
      var xScaleFactor = viewBox[2] / xa0._length;
      var yScaleFactor = viewBox[3] / ya0._length;
      for (i = 0; i < subplots.length; i++) {
        sp = plotinfos[subplots[i]];
        xa = sp.xaxis;
        ya = sp.yaxis;
        var editX2 = (editX || matches.isSubplotConstrained) && !xa.fixedrange && xaHash[xa._id];
        var editY2 = (editY || matches.isSubplotConstrained) && !ya.fixedrange && yaHash[ya._id];
        var xScaleFactor2, yScaleFactor2;
        var clipDx, clipDy;
        if (editX2) {
          xScaleFactor2 = xScaleFactor;
          clipDx = ew || matches.isSubplotConstrained ? viewBox[0] : getShift(xa, xScaleFactor2);
        } else if (matches.xaHash[xa._id]) {
          xScaleFactor2 = xScaleFactor;
          clipDx = viewBox[0] * xa._length / xa0._length;
        } else if (matches.yaHash[xa._id]) {
          xScaleFactor2 = yScaleFactor;
          clipDx = yActive === 'ns' ? -viewBox[1] * xa._length / ya0._length : getShift(xa, xScaleFactor2, {
            n: 'top',
            s: 'bottom'
          }[yActive]);
        } else {
          xScaleFactor2 = getLinkedScaleFactor(xa, xScaleFactor, yScaleFactor);
          clipDx = scaleAndGetShift(xa, xScaleFactor2);
        }
        if (xScaleFactor2 > 1 && (xa.maxallowed !== undefined && editX === (xa.range[0] < xa.range[1] ? 'e' : 'w') || xa.minallowed !== undefined && editX === (xa.range[0] < xa.range[1] ? 'w' : 'e'))) {
          xScaleFactor2 = 1;
          clipDx = 0;
        }
        if (editY2) {
          yScaleFactor2 = yScaleFactor;
          clipDy = ns || matches.isSubplotConstrained ? viewBox[1] : getShift(ya, yScaleFactor2);
        } else if (matches.yaHash[ya._id]) {
          yScaleFactor2 = yScaleFactor;
          clipDy = viewBox[1] * ya._length / ya0._length;
        } else if (matches.xaHash[ya._id]) {
          yScaleFactor2 = xScaleFactor;
          clipDy = xActive === 'ew' ? -viewBox[0] * ya._length / xa0._length : getShift(ya, yScaleFactor2, {
            e: 'right',
            w: 'left'
          }[xActive]);
        } else {
          yScaleFactor2 = getLinkedScaleFactor(ya, xScaleFactor, yScaleFactor);
          clipDy = scaleAndGetShift(ya, yScaleFactor2);
        }
        if (yScaleFactor2 > 1 && (ya.maxallowed !== undefined && editY === (ya.range[0] < ya.range[1] ? 'n' : 's') || ya.minallowed !== undefined && editY === (ya.range[0] < ya.range[1] ? 's' : 'n'))) {
          yScaleFactor2 = 1;
          clipDy = 0;
        }

        // don't scale at all if neither axis is scalable here
        if (!xScaleFactor2 && !yScaleFactor2) {
          continue;
        }

        // but if only one is, reset the other axis scaling
        if (!xScaleFactor2) xScaleFactor2 = 1;
        if (!yScaleFactor2) yScaleFactor2 = 1;
        var plotDx = xa._offset - clipDx / xScaleFactor2;
        var plotDy = ya._offset - clipDy / yScaleFactor2;

        // TODO could be more efficient here:
        // setTranslate and setScale do a lot of extra work
        // when working independently, should perhaps combine
        // them into a single routine.
        sp.clipRect.call(Drawing.setTranslate, clipDx, clipDy).call(Drawing.setScale, xScaleFactor2, yScaleFactor2);
        sp.plot.call(Drawing.setTranslate, plotDx, plotDy).call(Drawing.setScale, 1 / xScaleFactor2, 1 / yScaleFactor2);

        // apply an inverse scale to individual points to counteract
        // the scale of the trace group.
        // apply only when scale changes, as adjusting the scale of
        // all the points can be expansive.
        if (xScaleFactor2 !== sp.xScaleFactor || yScaleFactor2 !== sp.yScaleFactor) {
          Drawing.setPointGroupScale(sp.zoomScalePts, xScaleFactor2, yScaleFactor2);
          Drawing.setTextPointsScale(sp.zoomScaleTxt, xScaleFactor2, yScaleFactor2);
        }
        Drawing.hideOutsideRangePoints(sp.clipOnAxisFalseTraces, sp);

        // update x/y scaleFactor stash
        sp.xScaleFactor = xScaleFactor2;
        sp.yScaleFactor = yScaleFactor2;
      }
    }
  }

  // Find the appropriate scaling for this axis, if it's linked to the
  // dragged axes by constraints. 0 is special, it means this axis shouldn't
  // ever be scaled (will be converted to 1 if the other axis is scaled)
  function getLinkedScaleFactor(ax, xScaleFactor, yScaleFactor) {
    if (ax.fixedrange) return 0;
    if (editX && links.xaHash[ax._id]) {
      return xScaleFactor;
    }
    if (editY && (links.isSubplotConstrained ? links.xaHash : links.yaHash)[ax._id]) {
      return yScaleFactor;
    }
    return 0;
  }
  function scaleAndGetShift(ax, scaleFactor) {
    if (scaleFactor) {
      ax.range = ax._r.slice();
      scaleZoom(ax, scaleFactor);
      return getShift(ax, scaleFactor);
    }
    return 0;
  }
  function getShift(ax, scaleFactor, from) {
    return ax._length * (1 - scaleFactor) * FROM_TL[from || ax.constraintoward || 'middle'];
  }
  return dragger;
}
function makeDragger(plotinfo, nodeName, dragClass, cursor) {
  var dragger3 = Lib.ensureSingle(plotinfo.draglayer, nodeName, dragClass, function (s) {
    s.classed('drag', true).style({
      fill: 'transparent',
      'stroke-width': 0
    }).attr('data-subplot', plotinfo.id);
  });
  dragger3.call(setCursor, cursor);
  return dragger3.node();
}
function makeRectDragger(plotinfo, dragClass, cursor, x, y, w, h) {
  var dragger = makeDragger(plotinfo, 'rect', dragClass, cursor);
  d3.select(dragger).call(Drawing.setRect, x, y, w, h);
  return dragger;
}
function isDirectionActive(axList, activeVal) {
  for (var i = 0; i < axList.length; i++) {
    if (!axList[i].fixedrange) return activeVal;
  }
  return '';
}
function getEndText(ax, end) {
  var initialVal = ax.range[end];
  var diff = Math.abs(initialVal - ax.range[1 - end]);
  var dig;

  // TODO: this should basically be ax.r2d but we're doing extra
  // rounding here... can we clean up at all?
  if (ax.type === 'date') {
    return initialVal;
  } else if (ax.type === 'log') {
    dig = Math.ceil(Math.max(0, -Math.log(diff) / Math.LN10)) + 3;
    return numberFormat('.' + dig + 'g')(Math.pow(10, initialVal));
  } else {
    // linear numeric (or category... but just show numbers here)
    dig = Math.floor(Math.log(Math.abs(initialVal)) / Math.LN10) - Math.floor(Math.log(diff) / Math.LN10) + 4;
    return numberFormat('.' + String(dig) + 'g')(initialVal);
  }
}
function zoomAxRanges(axList, r0Fraction, r1Fraction, updates, linkedAxes) {
  for (var i = 0; i < axList.length; i++) {
    var axi = axList[i];
    if (axi.fixedrange) continue;
    if (axi.rangebreaks) {
      var isY = axi._id.charAt(0) === 'y';
      var r0F = isY ? 1 - r0Fraction : r0Fraction;
      var r1F = isY ? 1 - r1Fraction : r1Fraction;
      updates[axi._name + '.range[0]'] = axi.l2r(axi.p2l(r0F * axi._length));
      updates[axi._name + '.range[1]'] = axi.l2r(axi.p2l(r1F * axi._length));
    } else {
      var axRangeLinear0 = axi._rl[0];
      var axRangeLinearSpan = axi._rl[1] - axRangeLinear0;
      updates[axi._name + '.range[0]'] = axi.l2r(axRangeLinear0 + axRangeLinearSpan * r0Fraction);
      updates[axi._name + '.range[1]'] = axi.l2r(axRangeLinear0 + axRangeLinearSpan * r1Fraction);
    }
  }

  // zoom linked axes about their centers
  if (linkedAxes && linkedAxes.length) {
    var linkedR0Fraction = (r0Fraction + (1 - r1Fraction)) / 2;
    zoomAxRanges(linkedAxes, linkedR0Fraction, 1 - linkedR0Fraction, updates, []);
  }
}
function dragAxList(axList, pix) {
  for (var i = 0; i < axList.length; i++) {
    var axi = axList[i];
    if (!axi.fixedrange) {
      if (axi.rangebreaks) {
        var p0 = 0;
        var p1 = axi._length;
        var d0 = axi.p2l(p0 + pix) - axi.p2l(p0);
        var d1 = axi.p2l(p1 + pix) - axi.p2l(p1);
        var delta = (d0 + d1) / 2;
        axi.range = [axi.l2r(axi._rl[0] - delta), axi.l2r(axi._rl[1] - delta)];
      } else {
        axi.range = [axi.l2r(axi._rl[0] - pix / axi._m), axi.l2r(axi._rl[1] - pix / axi._m)];
      }
      if (axi.limitRange) axi.limitRange();
    }
  }
}

// common transform for dragging one end of an axis
// d>0 is compressing scale (cursor is over the plot,
//  the axis end should move with the cursor)
// d<0 is expanding (cursor is off the plot, axis end moves
//  nonlinearly so you can expand far)
function dZoom(d) {
  return 1 - (d >= 0 ? Math.min(d, 0.9) : 1 / (1 / Math.max(d, -0.3) + 3.222));
}
function getDragCursor(nsew, dragmode, isMainDrag) {
  if (!nsew) return 'pointer';
  if (nsew === 'nsew') {
    // in this case here, clear cursor and
    // use the cursor style set on <g .draglayer>
    if (isMainDrag) return '';
    if (dragmode === 'pan') return 'move';
    return 'crosshair';
  }
  return nsew.toLowerCase() + '-resize';
}
function makeZoombox(zoomlayer, lum, xs, ys, path0) {
  return zoomlayer.append('path').attr('class', 'zoombox').style({
    fill: lum > 0.2 ? 'rgba(0,0,0,0)' : 'rgba(255,255,255,0)',
    'stroke-width': 0
  }).attr('transform', strTranslate(xs, ys)).attr('d', path0 + 'Z');
}
function makeCorners(zoomlayer, xs, ys) {
  return zoomlayer.append('path').attr('class', 'zoombox-corners').style({
    fill: Color.background,
    stroke: Color.defaultLine,
    'stroke-width': 1,
    opacity: 0
  }).attr('transform', strTranslate(xs, ys)).attr('d', 'M0,0Z');
}
function updateZoombox(zb, corners, box, path0, dimmed, lum) {
  zb.attr('d', path0 + 'M' + box.l + ',' + box.t + 'v' + box.h + 'h' + box.w + 'v-' + box.h + 'h-' + box.w + 'Z');
  transitionZoombox(zb, corners, dimmed, lum);
}
function transitionZoombox(zb, corners, dimmed, lum) {
  if (!dimmed) {
    zb.transition().style('fill', lum > 0.2 ? 'rgba(0,0,0,0.4)' : 'rgba(255,255,255,0.3)').duration(200);
    corners.transition().style('opacity', 1).duration(200);
  }
}
function removeZoombox(gd) {
  d3.select(gd).selectAll('.zoombox,.js-zoombox-backdrop,.js-zoombox-menu,.zoombox-corners').remove();
}
function showDoubleClickNotifier(gd) {
  if (SHOWZOOMOUTTIP && gd.data && gd._context.showTips) {
    Lib.notifier(Lib._(gd, 'Double-click to zoom back out'), 'long');
    SHOWZOOMOUTTIP = false;
  }
}
function xCorners(box, y0) {
  return 'M' + (box.l - 0.5) + ',' + (y0 - MINZOOM - 0.5) + 'h-3v' + (2 * MINZOOM + 1) + 'h3ZM' + (box.r + 0.5) + ',' + (y0 - MINZOOM - 0.5) + 'h3v' + (2 * MINZOOM + 1) + 'h-3Z';
}
function yCorners(box, x0) {
  return 'M' + (x0 - MINZOOM - 0.5) + ',' + (box.t - 0.5) + 'v-3h' + (2 * MINZOOM + 1) + 'v3ZM' + (x0 - MINZOOM - 0.5) + ',' + (box.b + 0.5) + 'v3h' + (2 * MINZOOM + 1) + 'v-3Z';
}
function xyCorners(box) {
  var clen = Math.floor(Math.min(box.b - box.t, box.r - box.l, MINZOOM) / 2);
  return 'M' + (box.l - 3.5) + ',' + (box.t - 0.5 + clen) + 'h3v' + -clen + 'h' + clen + 'v-3h-' + (clen + 3) + 'ZM' + (box.r + 3.5) + ',' + (box.t - 0.5 + clen) + 'h-3v' + -clen + 'h' + -clen + 'v-3h' + (clen + 3) + 'ZM' + (box.r + 3.5) + ',' + (box.b + 0.5 - clen) + 'h-3v' + clen + 'h' + -clen + 'v3h' + (clen + 3) + 'ZM' + (box.l - 3.5) + ',' + (box.b + 0.5 - clen) + 'h3v' + clen + 'h' + clen + 'v3h-' + (clen + 3) + 'Z';
}
function calcLinks(gd, groups, xaHash, yaHash, exclude) {
  var isSubplotConstrained = false;
  var xLinks = {};
  var yLinks = {};
  var xID, yID, xLinkID, yLinkID;
  var xExclude = (exclude || {}).xaHash;
  var yExclude = (exclude || {}).yaHash;
  for (var i = 0; i < groups.length; i++) {
    var group = groups[i];
    // check if any of the x axes we're dragging is in this constraint group
    for (xID in xaHash) {
      if (group[xID]) {
        // put the rest of these axes into xLinks, if we're not already
        // dragging them, so we know to scale these axes automatically too
        // to match the changes in the dragged x axes
        for (xLinkID in group) {
          if (!(exclude && (xExclude[xLinkID] || yExclude[xLinkID])) && !(xLinkID.charAt(0) === 'x' ? xaHash : yaHash)[xLinkID]) {
            xLinks[xLinkID] = xID;
          }
        }

        // check if the x and y axes of THIS drag are linked
        for (yID in yaHash) {
          if (!(exclude && (xExclude[yID] || yExclude[yID])) && group[yID]) {
            isSubplotConstrained = true;
          }
        }
      }
    }

    // now check if any of the y axes we're dragging is in this constraint group
    // only look for outside links, as we've already checked for links within the dragger
    for (yID in yaHash) {
      if (group[yID]) {
        for (yLinkID in group) {
          if (!(exclude && (xExclude[yLinkID] || yExclude[yLinkID])) && !(yLinkID.charAt(0) === 'x' ? xaHash : yaHash)[yLinkID]) {
            yLinks[yLinkID] = yID;
          }
        }
      }
    }
  }
  if (isSubplotConstrained) {
    // merge xLinks and yLinks if the subplot is constrained,
    // since we'll always apply both anyway and the two will contain
    // duplicates
    Lib.extendFlat(xLinks, yLinks);
    yLinks = {};
  }
  var xaHashLinked = {};
  var xaxesLinked = [];
  for (xLinkID in xLinks) {
    var xa = getFromId(gd, xLinkID);
    xaxesLinked.push(xa);
    xaHashLinked[xa._id] = xa;
  }
  var yaHashLinked = {};
  var yaxesLinked = [];
  for (yLinkID in yLinks) {
    var ya = getFromId(gd, yLinkID);
    yaxesLinked.push(ya);
    yaHashLinked[ya._id] = ya;
  }
  return {
    xaHash: xaHashLinked,
    yaHash: yaHashLinked,
    xaxes: xaxesLinked,
    yaxes: yaxesLinked,
    xLinks: xLinks,
    yLinks: yLinks,
    isSubplotConstrained: isSubplotConstrained
  };
}

// still seems to be some confusion about onwheel vs onmousewheel...
function attachWheelEventHandler(element, handler) {
  if (!supportsPassive) {
    if (element.onwheel !== undefined) element.onwheel = handler;else if (element.onmousewheel !== undefined) element.onmousewheel = handler;else if (!element.isAddedWheelEvent) {
      element.isAddedWheelEvent = true;
      element.addEventListener('wheel', handler, {
        passive: false
      });
    }
  } else {
    var wheelEventName = element.onwheel !== undefined ? 'wheel' : 'mousewheel';
    if (element._onwheel) {
      element.removeEventListener(wheelEventName, element._onwheel);
    }
    element._onwheel = handler;
    element.addEventListener(wheelEventName, handler, {
      passive: false
    });
  }
}
function hashValues(hash) {
  var out = [];
  for (var k in hash) out.push(hash[k]);
  return out;
}
module.exports = {
  makeDragBox: makeDragBox,
  makeDragger: makeDragger,
  makeRectDragger: makeRectDragger,
  makeZoombox: makeZoombox,
  makeCorners: makeCorners,
  updateZoombox: updateZoombox,
  xyCorners: xyCorners,
  transitionZoombox: transitionZoombox,
  removeZoombox: removeZoombox,
  showDoubleClickNotifier: showDoubleClickNotifier,
  attachWheelEventHandler: attachWheelEventHandler
};

/***/ }),

/***/ 4305:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Fx = __webpack_require__(211);
var dragElement = __webpack_require__(8569);
var setCursor = __webpack_require__(6964);
var makeDragBox = (__webpack_require__(9323).makeDragBox);
var DRAGGERSIZE = (__webpack_require__(5555).DRAGGERSIZE);
exports.initInteractions = function initInteractions(gd) {
  var fullLayout = gd._fullLayout;
  if (gd._context.staticPlot) {
    // this sweeps up more than just cartesian drag elements...
    d3.select(gd).selectAll('.drag').remove();
    return;
  }
  if (!fullLayout._has('cartesian') && !fullLayout._has('splom')) return;
  var subplots = Object.keys(fullLayout._plots || {}).sort(function (a, b) {
    // sort overlays last, then by x axis number, then y axis number
    if ((fullLayout._plots[a].mainplot && true) === (fullLayout._plots[b].mainplot && true)) {
      var aParts = a.split('y');
      var bParts = b.split('y');
      return aParts[0] === bParts[0] ? Number(aParts[1] || 1) - Number(bParts[1] || 1) : Number(aParts[0] || 1) - Number(bParts[0] || 1);
    }
    return fullLayout._plots[a].mainplot ? 1 : -1;
  });
  subplots.forEach(function (subplot) {
    var plotinfo = fullLayout._plots[subplot];
    var xa = plotinfo.xaxis;
    var ya = plotinfo.yaxis;

    // main and corner draggers need not be repeated for
    // overlaid subplots - these draggers drag them all
    if (!plotinfo.mainplot) {
      // main dragger goes over the grids and data, so we use its
      // mousemove events for all data hover effects
      var maindrag = makeDragBox(gd, plotinfo, xa._offset, ya._offset, xa._length, ya._length, 'ns', 'ew');
      maindrag.onmousemove = function (evt) {
        // This is on `gd._fullLayout`, *not* fullLayout because the reference
        // changes by the time this is called again.
        gd._fullLayout._rehover = function () {
          if (gd._fullLayout._hoversubplot === subplot && gd._fullLayout._plots[subplot]) {
            Fx.hover(gd, evt, subplot);
          }
        };
        Fx.hover(gd, evt, subplot);

        // Note that we have *not* used the cached fullLayout variable here
        // since that may be outdated when this is called as a callback later on
        gd._fullLayout._lasthover = maindrag;
        gd._fullLayout._hoversubplot = subplot;
      };

      /*
       * IMPORTANT:
       * We must check for the presence of the drag cover here.
       * If we don't, a 'mouseout' event is triggered on the
       * maindrag before each 'click' event, which has the effect
       * of clearing the hoverdata; thus, cancelling the click event.
       */
      maindrag.onmouseout = function (evt) {
        if (gd._dragging) return;

        // When the mouse leaves this maindrag, unset the hovered subplot.
        // This may cause problems if it leaves the subplot directly *onto*
        // another subplot, but that's a tiny corner case at the moment.
        gd._fullLayout._hoversubplot = null;
        dragElement.unhover(gd, evt);
      };

      // corner draggers
      if (gd._context.showAxisDragHandles) {
        makeDragBox(gd, plotinfo, xa._offset - DRAGGERSIZE, ya._offset - DRAGGERSIZE, DRAGGERSIZE, DRAGGERSIZE, 'n', 'w');
        makeDragBox(gd, plotinfo, xa._offset + xa._length, ya._offset - DRAGGERSIZE, DRAGGERSIZE, DRAGGERSIZE, 'n', 'e');
        makeDragBox(gd, plotinfo, xa._offset - DRAGGERSIZE, ya._offset + ya._length, DRAGGERSIZE, DRAGGERSIZE, 's', 'w');
        makeDragBox(gd, plotinfo, xa._offset + xa._length, ya._offset + ya._length, DRAGGERSIZE, DRAGGERSIZE, 's', 'e');
      }
    }
    if (gd._context.showAxisDragHandles) {
      // x axis draggers - if you have overlaid plots,
      // these drag each axis separately
      if (subplot === xa._mainSubplot) {
        // the y position of the main x axis line
        var y0 = xa._mainLinePosition;
        if (xa.side === 'top') y0 -= DRAGGERSIZE;
        makeDragBox(gd, plotinfo, xa._offset + xa._length * 0.1, y0, xa._length * 0.8, DRAGGERSIZE, '', 'ew');
        makeDragBox(gd, plotinfo, xa._offset, y0, xa._length * 0.1, DRAGGERSIZE, '', 'w');
        makeDragBox(gd, plotinfo, xa._offset + xa._length * 0.9, y0, xa._length * 0.1, DRAGGERSIZE, '', 'e');
      }
      // y axis draggers
      if (subplot === ya._mainSubplot) {
        // the x position of the main y axis line
        var x0 = ya._mainLinePosition;
        if (ya.side !== 'right') x0 -= DRAGGERSIZE;
        makeDragBox(gd, plotinfo, x0, ya._offset + ya._length * 0.1, DRAGGERSIZE, ya._length * 0.8, 'ns', '');
        makeDragBox(gd, plotinfo, x0, ya._offset + ya._length * 0.9, DRAGGERSIZE, ya._length * 0.1, 's', '');
        makeDragBox(gd, plotinfo, x0, ya._offset, DRAGGERSIZE, ya._length * 0.1, 'n', '');
      }
    }
  });

  // In case you mousemove over some hovertext, send it to Fx.hover too
  // we do this so that we can put the hover text in front of everything,
  // but still be able to interact with everything as if it isn't there
  var hoverLayer = fullLayout._hoverlayer.node();
  hoverLayer.onmousemove = function (evt) {
    evt.target = gd._fullLayout._lasthover;
    Fx.hover(gd, evt, fullLayout._hoversubplot);
  };
  hoverLayer.onclick = function (evt) {
    evt.target = gd._fullLayout._lasthover;
    Fx.click(gd, evt);
  };

  // also delegate mousedowns... TODO: does this actually work?
  hoverLayer.onmousedown = function (evt) {
    gd._fullLayout._lasthover.onmousedown(evt);
  };
  exports.updateFx(gd);
};

// Minimal set of update needed on 'modebar' edits.
// We only need to update the <g .draglayer> cursor style.
//
// Note that changing the axis configuration and/or the fixedrange attribute
// should trigger a full initInteractions.
exports.updateFx = function (gd) {
  var fullLayout = gd._fullLayout;
  var cursor = fullLayout.dragmode === 'pan' ? 'move' : 'crosshair';
  setCursor(fullLayout._draggers, cursor);
};

/***/ }),

/***/ 6325:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var axisIds = __webpack_require__(1675);

/**
 * Factory function for checking component arrays for subplot references.
 *
 * @param {string} containerArrayName: the top-level array in gd.layout to check
 *   If an item in this container is found that references a cartesian x and/or y axis,
 *   ensure cartesian is marked as a base plot module and record the axes (and subplot
 *   if both refs are axes) in gd._fullLayout
 *
 * @return {function}: with args layoutIn (gd.layout) and layoutOut (gd._fullLayout)
 * as expected of a component includeBasePlot method
 */
module.exports = function makeIncludeComponents(containerArrayName) {
  return function includeComponents(layoutIn, layoutOut) {
    var array = layoutIn[containerArrayName];
    if (!Array.isArray(array)) return;
    var Cartesian = Registry.subplotsRegistry.cartesian;
    var idRegex = Cartesian.idRegex;
    var subplots = layoutOut._subplots;
    var xaList = subplots.xaxis;
    var yaList = subplots.yaxis;
    var cartesianList = subplots.cartesian;
    var hasCartesianOrGL2D = layoutOut._has('cartesian') || layoutOut._has('gl2d');
    for (var i = 0; i < array.length; i++) {
      var itemi = array[i];
      if (!Lib.isPlainObject(itemi)) continue;

      // call cleanId because if xref, or yref has something appended
      // (e.g., ' domain') this will get removed.
      var xref = axisIds.cleanId(itemi.xref, 'x', false);
      var yref = axisIds.cleanId(itemi.yref, 'y', false);
      var hasXref = idRegex.x.test(xref);
      var hasYref = idRegex.y.test(yref);
      if (hasXref || hasYref) {
        if (!hasCartesianOrGL2D) Lib.pushUnique(layoutOut._basePlotModules, Cartesian);
        var newAxis = false;
        if (hasXref && xaList.indexOf(xref) === -1) {
          xaList.push(xref);
          newAxis = true;
        }
        if (hasYref && yaList.indexOf(yref) === -1) {
          yaList.push(yref);
          newAxis = true;
        }

        /*
         * Notice the logic here: only add a subplot for a component if
         * it's referencing both x and y axes AND it's creating a new axis
         * so for example if your plot already has xy and x2y2, an annotation
         * on x2y or xy2 will not create a new subplot.
         */
        if (newAxis && hasXref && hasYref) {
          cartesianList.push(xref + yref);
        }
      }
    }
  };
};

/***/ }),

/***/ 3612:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var Plots = __webpack_require__(4875);
var Drawing = __webpack_require__(1424);
var getModuleCalcData = (__webpack_require__(7659)/* .getModuleCalcData */ .a0);
var axisIds = __webpack_require__(1675);
var constants = __webpack_require__(5555);
var xmlnsNamespaces = __webpack_require__(7922);
var ensureSingle = Lib.ensureSingle;
function ensureSingleAndAddDatum(parent, nodeType, className) {
  return Lib.ensureSingle(parent, nodeType, className, function (s) {
    s.datum(className);
  });
}
exports.name = 'cartesian';
exports.attr = ['xaxis', 'yaxis'];
exports.idRoot = ['x', 'y'];
exports.idRegex = constants.idRegex;
exports.attrRegex = constants.attrRegex;
exports.attributes = __webpack_require__(9502);
exports.layoutAttributes = __webpack_require__(3838);
exports.supplyLayoutDefaults = __webpack_require__(6763);
exports.transitionAxes = __webpack_require__(6847);
exports.finalizeSubplots = function (layoutIn, layoutOut) {
  var subplots = layoutOut._subplots;
  var xList = subplots.xaxis;
  var yList = subplots.yaxis;
  var spSVG = subplots.cartesian;
  var spAll = spSVG.concat(subplots.gl2d || []);
  var allX = {};
  var allY = {};
  var i, xi, yi;
  for (i = 0; i < spAll.length; i++) {
    var parts = spAll[i].split('y');
    allX[parts[0]] = 1;
    allY['y' + parts[1]] = 1;
  }

  // check for x axes with no subplot, and make one from the anchor of that x axis
  for (i = 0; i < xList.length; i++) {
    xi = xList[i];
    if (!allX[xi]) {
      yi = (layoutIn[axisIds.id2name(xi)] || {}).anchor;
      if (!constants.idRegex.y.test(yi)) yi = 'y';
      spSVG.push(xi + yi);
      spAll.push(xi + yi);
      if (!allY[yi]) {
        allY[yi] = 1;
        Lib.pushUnique(yList, yi);
      }
    }
  }

  // same for y axes with no subplot
  for (i = 0; i < yList.length; i++) {
    yi = yList[i];
    if (!allY[yi]) {
      xi = (layoutIn[axisIds.id2name(yi)] || {}).anchor;
      if (!constants.idRegex.x.test(xi)) xi = 'x';
      spSVG.push(xi + yi);
      spAll.push(xi + yi);
      if (!allX[xi]) {
        allX[xi] = 1;
        Lib.pushUnique(xList, xi);
      }
    }
  }

  // finally, if we've gotten here we're supposed to show cartesian...
  // so if there are NO subplots at all, make one from the first
  // x & y axes in the input layout
  if (!spAll.length) {
    xi = '';
    yi = '';
    for (var ki in layoutIn) {
      if (constants.attrRegex.test(ki)) {
        var axLetter = ki.charAt(0);
        if (axLetter === 'x') {
          if (!xi || +ki.substr(5) < +xi.substr(5)) {
            xi = ki;
          }
        } else if (!yi || +ki.substr(5) < +yi.substr(5)) {
          yi = ki;
        }
      }
    }
    xi = xi ? axisIds.name2id(xi) : 'x';
    yi = yi ? axisIds.name2id(yi) : 'y';
    xList.push(xi);
    yList.push(yi);
    spSVG.push(xi + yi);
  }
};

/**
 * Cartesian.plot
 *
 * @param {DOM div | object} gd
 * @param {array (optional)} traces
 *  array of traces indices to plot
 *  if undefined, plots all cartesian traces,
 * @param {object} (optional) transitionOpts
 *  transition option object
 * @param {function} (optional) makeOnCompleteCallback
 *  transition make callback function from Plots.transition
 */
exports.plot = function (gd, traces, transitionOpts, makeOnCompleteCallback) {
  var fullLayout = gd._fullLayout;
  var subplots = fullLayout._subplots.cartesian;
  var calcdata = gd.calcdata;
  var i;
  if (!Array.isArray(traces)) {
    // If traces is not provided, then it's a complete replot and missing
    // traces are removed
    traces = [];
    for (i = 0; i < calcdata.length; i++) traces.push(i);
  }
  for (i = 0; i < subplots.length; i++) {
    var subplot = subplots[i];
    var subplotInfo = fullLayout._plots[subplot];

    // Get all calcdata for this subplot:
    var cdSubplot = [];
    var pcd;
    for (var j = 0; j < calcdata.length; j++) {
      var cd = calcdata[j];
      var trace = cd[0].trace;

      // Skip trace if whitelist provided and it's not whitelisted:
      // if (Array.isArray(traces) && traces.indexOf(i) === -1) continue;
      if (trace.xaxis + trace.yaxis === subplot) {
        // XXX: Should trace carpet dependencies. Only replot all carpet plots if the carpet
        // axis has actually changed:
        //
        // If this trace is specifically requested, add it to the list:
        if (traces.indexOf(trace.index) !== -1 || trace.carpet) {
          // Okay, so example: traces 0, 1, and 2 have fill = tonext. You animate
          // traces 0 and 2. Trace 1 also needs to be updated, otherwise its fill
          // is outdated. So this retroactively adds the previous trace if the
          // traces are interdependent.
          if (pcd && pcd[0].trace.xaxis + pcd[0].trace.yaxis === subplot && ['tonextx', 'tonexty', 'tonext'].indexOf(trace.fill) !== -1 && cdSubplot.indexOf(pcd) === -1) {
            cdSubplot.push(pcd);
          }
          cdSubplot.push(cd);
        }

        // Track the previous trace on this subplot for the retroactive-add step
        // above:
        pcd = cd;
      }
    }
    plotOne(gd, subplotInfo, cdSubplot, transitionOpts, makeOnCompleteCallback);
  }
};
function plotOne(gd, plotinfo, cdSubplot, transitionOpts, makeOnCompleteCallback) {
  var traceLayerClasses = constants.traceLayerClasses;
  var fullLayout = gd._fullLayout;
  var modules = fullLayout._modules;
  var _module, cdModuleAndOthers, cdModule;
  var layerData = [];
  var zoomScaleQueryParts = [];
  for (var i = 0; i < modules.length; i++) {
    _module = modules[i];
    var name = _module.name;
    var categories = Registry.modules[name].categories;
    if (categories.svg) {
      var className = _module.layerName || name + 'layer';
      var plotMethod = _module.plot;

      // plot all visible traces of this type on this subplot at once
      cdModuleAndOthers = getModuleCalcData(cdSubplot, plotMethod);
      cdModule = cdModuleAndOthers[0];
      // don't need to search the found traces again - in fact we need to NOT
      // so that if two modules share the same plotter we don't double-plot
      cdSubplot = cdModuleAndOthers[1];
      if (cdModule.length) {
        layerData.push({
          i: traceLayerClasses.indexOf(className),
          className: className,
          plotMethod: plotMethod,
          cdModule: cdModule
        });
      }
      if (categories.zoomScale) {
        zoomScaleQueryParts.push('.' + className);
      }
    }
  }
  layerData.sort(function (a, b) {
    return a.i - b.i;
  });
  var layers = plotinfo.plot.selectAll('g.mlayer').data(layerData, function (d) {
    return d.className;
  });
  layers.enter().append('g').attr('class', function (d) {
    return d.className;
  }).classed('mlayer', true).classed('rangeplot', plotinfo.isRangePlot);
  layers.exit().remove();
  layers.order();
  layers.each(function (d) {
    var sel = d3.select(this);
    var className = d.className;
    d.plotMethod(gd, plotinfo, d.cdModule, sel, transitionOpts, makeOnCompleteCallback);

    // layers that allow `cliponaxis: false`
    if (constants.clipOnAxisFalseQuery.indexOf('.' + className) === -1) {
      Drawing.setClipUrl(sel, plotinfo.layerClipId, gd);
    }
  });

  // call Scattergl.plot separately
  if (fullLayout._has('scattergl')) {
    _module = Registry.getModule('scattergl');
    cdModule = getModuleCalcData(cdSubplot, _module)[0];
    _module.plot(gd, plotinfo, cdModule);
  }

  // stash "hot" selections for faster interaction on drag and scroll
  if (!gd._context.staticPlot) {
    if (plotinfo._hasClipOnAxisFalse) {
      plotinfo.clipOnAxisFalseTraces = plotinfo.plot.selectAll(constants.clipOnAxisFalseQuery.join(',')).selectAll('.trace');
    }
    if (zoomScaleQueryParts.length) {
      var traces = plotinfo.plot.selectAll(zoomScaleQueryParts.join(',')).selectAll('.trace');
      plotinfo.zoomScalePts = traces.selectAll('path.point');
      plotinfo.zoomScaleTxt = traces.selectAll('.textpoint');
    }
  }
}
exports.clean = function (newFullData, newFullLayout, oldFullData, oldFullLayout) {
  var oldPlots = oldFullLayout._plots || {};
  var newPlots = newFullLayout._plots || {};
  var oldSubplotList = oldFullLayout._subplots || {};
  var plotinfo;
  var i, k;

  // when going from a large splom graph to something else,
  // we need to clear <g subplot> so that the new cartesian subplot
  // can have the correct layer ordering
  if (oldFullLayout._hasOnlyLargeSploms && !newFullLayout._hasOnlyLargeSploms) {
    for (k in oldPlots) {
      plotinfo = oldPlots[k];
      if (plotinfo.plotgroup) plotinfo.plotgroup.remove();
    }
  }
  var hadGl = oldFullLayout._has && oldFullLayout._has('gl');
  var hasGl = newFullLayout._has && newFullLayout._has('gl');
  if (hadGl && !hasGl) {
    for (k in oldPlots) {
      plotinfo = oldPlots[k];
      if (plotinfo._scene) plotinfo._scene.destroy();
    }
  }

  // delete any titles we don't need anymore
  // check if axis list has changed, and if so clear old titles
  if (oldSubplotList.xaxis && oldSubplotList.yaxis) {
    var oldAxIDs = axisIds.listIds({
      _fullLayout: oldFullLayout
    });
    for (i = 0; i < oldAxIDs.length; i++) {
      var oldAxId = oldAxIDs[i];
      if (!newFullLayout[axisIds.id2name(oldAxId)]) {
        oldFullLayout._infolayer.selectAll('.g-' + oldAxId + 'title').remove();
      }
    }
  }
  var hadCartesian = oldFullLayout._has && oldFullLayout._has('cartesian');
  var hasCartesian = newFullLayout._has && newFullLayout._has('cartesian');
  if (hadCartesian && !hasCartesian) {
    // if we've gotten rid of all cartesian traces, remove all the subplot svg items

    purgeSubplotLayers(oldFullLayout._cartesianlayer.selectAll('.subplot'), oldFullLayout);
    oldFullLayout._defs.selectAll('.axesclip').remove();
    delete oldFullLayout._axisConstraintGroups;
    delete oldFullLayout._axisMatchGroups;
  } else if (oldSubplotList.cartesian) {
    // otherwise look for subplots we need to remove

    for (i = 0; i < oldSubplotList.cartesian.length; i++) {
      var oldSubplotId = oldSubplotList.cartesian[i];
      if (!newPlots[oldSubplotId]) {
        var selector = '.' + oldSubplotId + ',.' + oldSubplotId + '-x,.' + oldSubplotId + '-y';
        oldFullLayout._cartesianlayer.selectAll(selector).remove();
        removeSubplotExtras(oldSubplotId, oldFullLayout);
      }
    }
  }
};
exports.drawFramework = function (gd) {
  var fullLayout = gd._fullLayout;
  var subplotData = makeSubplotData(gd);
  var subplotLayers = fullLayout._cartesianlayer.selectAll('.subplot').data(subplotData, String);
  subplotLayers.enter().append('g').attr('class', function (d) {
    return 'subplot ' + d[0];
  });
  subplotLayers.order();
  subplotLayers.exit().call(purgeSubplotLayers, fullLayout);
  subplotLayers.each(function (d) {
    var id = d[0];
    var plotinfo = fullLayout._plots[id];
    plotinfo.plotgroup = d3.select(this);
    makeSubplotLayer(gd, plotinfo);

    // make separate drag layers for each subplot,
    // but append them to paper rather than the plot groups,
    // so they end up on top of the rest
    plotinfo.draglayer = ensureSingle(fullLayout._draggers, 'g', id);
  });
};
exports.rangePlot = function (gd, plotinfo, cdSubplot) {
  makeSubplotLayer(gd, plotinfo);
  plotOne(gd, plotinfo, cdSubplot);
  Plots.style(gd);
};
function makeSubplotData(gd) {
  var fullLayout = gd._fullLayout;
  var ids = fullLayout._subplots.cartesian;
  var len = ids.length;
  var i, j, id, plotinfo, xa, ya;

  // split 'regular' and 'overlaying' subplots
  var regulars = [];
  var overlays = [];
  for (i = 0; i < len; i++) {
    id = ids[i];
    plotinfo = fullLayout._plots[id];
    xa = plotinfo.xaxis;
    ya = plotinfo.yaxis;
    var xa2 = xa._mainAxis;
    var ya2 = ya._mainAxis;
    var mainplot = xa2._id + ya2._id;
    var mainplotinfo = fullLayout._plots[mainplot];
    plotinfo.overlays = [];
    if (mainplot !== id && mainplotinfo) {
      plotinfo.mainplot = mainplot;
      plotinfo.mainplotinfo = mainplotinfo;
      overlays.push(id);
    } else {
      plotinfo.mainplot = undefined;
      plotinfo.mainplotinfo = undefined;
      regulars.push(id);
    }
  }

  // fill in list of overlaying subplots in 'main plot'
  for (i = 0; i < overlays.length; i++) {
    id = overlays[i];
    plotinfo = fullLayout._plots[id];
    plotinfo.mainplotinfo.overlays.push(plotinfo);
  }

  // put 'regular' subplot data before 'overlaying'
  var subplotIds = regulars.concat(overlays);
  var subplotData = new Array(len);
  for (i = 0; i < len; i++) {
    id = subplotIds[i];
    plotinfo = fullLayout._plots[id];
    xa = plotinfo.xaxis;
    ya = plotinfo.yaxis;

    // use info about axis layer and overlaying pattern
    // to clean what need to be cleaned up in exit selection
    var d = [id, xa.layer, ya.layer, xa.overlaying || '', ya.overlaying || ''];
    for (j = 0; j < plotinfo.overlays.length; j++) {
      d.push(plotinfo.overlays[j].id);
    }
    subplotData[i] = d;
  }
  return subplotData;
}
function makeSubplotLayer(gd, plotinfo) {
  var plotgroup = plotinfo.plotgroup;
  var id = plotinfo.id;
  var xLayer = constants.layerValue2layerClass[plotinfo.xaxis.layer];
  var yLayer = constants.layerValue2layerClass[plotinfo.yaxis.layer];
  var hasOnlyLargeSploms = gd._fullLayout._hasOnlyLargeSploms;
  if (!plotinfo.mainplot) {
    if (hasOnlyLargeSploms) {
      // TODO could do even better
      // - we don't need plot (but we would have to mock it in lsInner
      //   and other places
      // - we don't (x|y)lines and (x|y)axislayer for most subplots
      //   usually just the bottom x and left y axes.
      plotinfo.xlines = ensureSingle(plotgroup, 'path', 'xlines-above');
      plotinfo.ylines = ensureSingle(plotgroup, 'path', 'ylines-above');
      plotinfo.xaxislayer = ensureSingle(plotgroup, 'g', 'xaxislayer-above');
      plotinfo.yaxislayer = ensureSingle(plotgroup, 'g', 'yaxislayer-above');
    } else {
      var backLayer = ensureSingle(plotgroup, 'g', 'layer-subplot');
      plotinfo.shapelayer = ensureSingle(backLayer, 'g', 'shapelayer');
      plotinfo.imagelayer = ensureSingle(backLayer, 'g', 'imagelayer');
      plotinfo.minorGridlayer = ensureSingle(plotgroup, 'g', 'minor-gridlayer');
      plotinfo.gridlayer = ensureSingle(plotgroup, 'g', 'gridlayer');
      plotinfo.zerolinelayer = ensureSingle(plotgroup, 'g', 'zerolinelayer');
      ensureSingle(plotgroup, 'path', 'xlines-below');
      ensureSingle(plotgroup, 'path', 'ylines-below');
      plotinfo.overlinesBelow = ensureSingle(plotgroup, 'g', 'overlines-below');
      ensureSingle(plotgroup, 'g', 'xaxislayer-below');
      ensureSingle(plotgroup, 'g', 'yaxislayer-below');
      plotinfo.overaxesBelow = ensureSingle(plotgroup, 'g', 'overaxes-below');
      plotinfo.plot = ensureSingle(plotgroup, 'g', 'plot');
      plotinfo.overplot = ensureSingle(plotgroup, 'g', 'overplot');
      plotinfo.xlines = ensureSingle(plotgroup, 'path', 'xlines-above');
      plotinfo.ylines = ensureSingle(plotgroup, 'path', 'ylines-above');
      plotinfo.overlinesAbove = ensureSingle(plotgroup, 'g', 'overlines-above');
      ensureSingle(plotgroup, 'g', 'xaxislayer-above');
      ensureSingle(plotgroup, 'g', 'yaxislayer-above');
      plotinfo.overaxesAbove = ensureSingle(plotgroup, 'g', 'overaxes-above');

      // set refs to correct layers as determined by 'axis.layer'
      plotinfo.xlines = plotgroup.select('.xlines-' + xLayer);
      plotinfo.ylines = plotgroup.select('.ylines-' + yLayer);
      plotinfo.xaxislayer = plotgroup.select('.xaxislayer-' + xLayer);
      plotinfo.yaxislayer = plotgroup.select('.yaxislayer-' + yLayer);
    }
  } else {
    var mainplotinfo = plotinfo.mainplotinfo;
    var mainplotgroup = mainplotinfo.plotgroup;
    var xId = id + '-x';
    var yId = id + '-y';

    // now make the components of overlaid subplots
    // overlays don't have backgrounds, and append all
    // their other components to the corresponding
    // extra groups of their main plots.

    plotinfo.minorGridlayer = mainplotinfo.minorGridlayer;
    plotinfo.gridlayer = mainplotinfo.gridlayer;
    plotinfo.zerolinelayer = mainplotinfo.zerolinelayer;
    ensureSingle(mainplotinfo.overlinesBelow, 'path', xId);
    ensureSingle(mainplotinfo.overlinesBelow, 'path', yId);
    ensureSingle(mainplotinfo.overaxesBelow, 'g', xId);
    ensureSingle(mainplotinfo.overaxesBelow, 'g', yId);
    plotinfo.plot = ensureSingle(mainplotinfo.overplot, 'g', id);
    ensureSingle(mainplotinfo.overlinesAbove, 'path', xId);
    ensureSingle(mainplotinfo.overlinesAbove, 'path', yId);
    ensureSingle(mainplotinfo.overaxesAbove, 'g', xId);
    ensureSingle(mainplotinfo.overaxesAbove, 'g', yId);

    // set refs to correct layers as determined by 'abovetraces'
    plotinfo.xlines = mainplotgroup.select('.overlines-' + xLayer).select('.' + xId);
    plotinfo.ylines = mainplotgroup.select('.overlines-' + yLayer).select('.' + yId);
    plotinfo.xaxislayer = mainplotgroup.select('.overaxes-' + xLayer).select('.' + xId);
    plotinfo.yaxislayer = mainplotgroup.select('.overaxes-' + yLayer).select('.' + yId);
  }

  // common attributes for all subplots, overlays or not

  if (!hasOnlyLargeSploms) {
    ensureSingleAndAddDatum(plotinfo.minorGridlayer, 'g', plotinfo.xaxis._id);
    ensureSingleAndAddDatum(plotinfo.minorGridlayer, 'g', plotinfo.yaxis._id);
    plotinfo.minorGridlayer.selectAll('g').map(function (d) {
      return d[0];
    }).sort(axisIds.idSort);
    ensureSingleAndAddDatum(plotinfo.gridlayer, 'g', plotinfo.xaxis._id);
    ensureSingleAndAddDatum(plotinfo.gridlayer, 'g', plotinfo.yaxis._id);
    plotinfo.gridlayer.selectAll('g').map(function (d) {
      return d[0];
    }).sort(axisIds.idSort);
  }
  plotinfo.xlines.style('fill', 'none').classed('crisp', true);
  plotinfo.ylines.style('fill', 'none').classed('crisp', true);
}
function purgeSubplotLayers(layers, fullLayout) {
  if (!layers) return;
  var overlayIdsToRemove = {};
  layers.each(function (d) {
    var id = d[0];
    var plotgroup = d3.select(this);
    plotgroup.remove();
    removeSubplotExtras(id, fullLayout);
    overlayIdsToRemove[id] = true;

    // do not remove individual axis <clipPath>s here
    // as other subplots may need them
  });

  // must remove overlaid subplot trace layers 'manually'

  for (var k in fullLayout._plots) {
    var subplotInfo = fullLayout._plots[k];
    var overlays = subplotInfo.overlays || [];
    for (var j = 0; j < overlays.length; j++) {
      var overlayInfo = overlays[j];
      if (overlayIdsToRemove[overlayInfo.id]) {
        overlayInfo.plot.selectAll('.trace').remove();
      }
    }
  }
}
function removeSubplotExtras(subplotId, fullLayout) {
  fullLayout._draggers.selectAll('g.' + subplotId).remove();
  fullLayout._defs.select('#clip' + fullLayout._uid + subplotId + 'plot').remove();
}
exports.toSVG = function (gd) {
  var imageRoot = gd._fullLayout._glimages;
  var root = d3.select(gd).selectAll('.svg-container');
  var canvases = root.filter(function (d, i) {
    return i === root.size() - 1;
  }).selectAll('.gl-canvas-context, .gl-canvas-focus');
  function canvasToImage() {
    var canvas = this;
    var imageData = canvas.toDataURL('image/png');
    var image = imageRoot.append('svg:image');
    image.attr({
      xmlns: xmlnsNamespaces.svg,
      'xlink:href': imageData,
      preserveAspectRatio: 'none',
      x: 0,
      y: 0,
      width: canvas.style.width,
      height: canvas.style.height
    });
  }
  canvases.each(canvasToImage);
};
exports.updateFx = __webpack_require__(4305).updateFx;

/***/ }),

/***/ 3838:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var fontAttrs = __webpack_require__(1940);
var colorAttrs = __webpack_require__(2399);
var dash = (__webpack_require__(9952)/* .dash */ .P);
var extendFlat = (__webpack_require__(1426).extendFlat);
var templatedArray = (__webpack_require__(4467).templatedArray);
var descriptionWithDates = (__webpack_require__(2663).descriptionWithDates);
var ONEDAY = (__webpack_require__(606).ONEDAY);
var constants = __webpack_require__(5555);
var HOUR = constants.HOUR_PATTERN;
var DAY_OF_WEEK = constants.WEEKDAY_PATTERN;
var minorTickmode = {
  valType: 'enumerated',
  values: ['auto', 'linear', 'array'],
  editType: 'ticks',
  impliedEdits: {
    tick0: undefined,
    dtick: undefined
  }
};
var tickmode = extendFlat({}, minorTickmode, {
  values: minorTickmode.values.slice().concat(['sync'])
});
function makeNticks(minor) {
  return {
    valType: 'integer',
    min: 0,
    dflt: minor ? 5 : 0,
    editType: 'ticks'
  };
}
var tick0 = {
  valType: 'any',
  editType: 'ticks',
  impliedEdits: {
    tickmode: 'linear'
  }
};
var dtick = {
  valType: 'any',
  editType: 'ticks',
  impliedEdits: {
    tickmode: 'linear'
  }
};
var tickvals = {
  valType: 'data_array',
  editType: 'ticks'
};
var ticks = {
  valType: 'enumerated',
  values: ['outside', 'inside', ''],
  editType: 'ticks'
};
function makeTicklen(minor) {
  var obj = {
    valType: 'number',
    min: 0,
    editType: 'ticks'
  };
  if (!minor) obj.dflt = 5;
  return obj;
}
function makeTickwidth(minor) {
  var obj = {
    valType: 'number',
    min: 0,
    editType: 'ticks'
  };
  if (!minor) obj.dflt = 1;
  return obj;
}
var tickcolor = {
  valType: 'color',
  dflt: colorAttrs.defaultLine,
  editType: 'ticks'
};
var gridcolor = {
  valType: 'color',
  dflt: colorAttrs.lightLine,
  editType: 'ticks'
};
function makeGridwidth(minor) {
  var obj = {
    valType: 'number',
    min: 0,
    editType: 'ticks'
  };
  if (!minor) obj.dflt = 1;
  return obj;
}
var griddash = extendFlat({}, dash, {
  editType: 'ticks'
});
var showgrid = {
  valType: 'boolean',
  editType: 'ticks'
};
module.exports = {
  visible: {
    valType: 'boolean',
    editType: 'plot'
  },
  color: {
    valType: 'color',
    dflt: colorAttrs.defaultLine,
    editType: 'ticks'
  },
  title: {
    text: {
      valType: 'string',
      editType: 'ticks'
    },
    font: fontAttrs({
      editType: 'ticks'
    }),
    standoff: {
      valType: 'number',
      min: 0,
      editType: 'ticks'
    },
    editType: 'ticks'
  },
  type: {
    valType: 'enumerated',
    // '-' means we haven't yet run autotype or couldn't find any data
    // it gets turned into linear in gd._fullLayout but not copied back
    // to gd.data like the others are.
    values: ['-', 'linear', 'log', 'date', 'category', 'multicategory'],
    dflt: '-',
    editType: 'calc',
    // we forget when an axis has been autotyped, just writing the auto
    // value back to the input - so it doesn't make sense to template this.
    // Note: we do NOT prohibit this in `coerce`, so if someone enters a
    // type in the template explicitly it will be honored as the default.
    _noTemplating: true
  },
  autotypenumbers: {
    valType: 'enumerated',
    values: ['convert types', 'strict'],
    dflt: 'convert types',
    editType: 'calc'
  },
  autorange: {
    valType: 'enumerated',
    values: [true, false, 'reversed', 'min reversed', 'max reversed', 'min', 'max'],
    dflt: true,
    editType: 'axrange',
    impliedEdits: {
      'range[0]': undefined,
      'range[1]': undefined
    }
  },
  autorangeoptions: {
    minallowed: {
      valType: 'any',
      editType: 'plot',
      impliedEdits: {
        'range[0]': undefined,
        'range[1]': undefined
      }
    },
    maxallowed: {
      valType: 'any',
      editType: 'plot',
      impliedEdits: {
        'range[0]': undefined,
        'range[1]': undefined
      }
    },
    clipmin: {
      valType: 'any',
      editType: 'plot',
      impliedEdits: {
        'range[0]': undefined,
        'range[1]': undefined
      }
    },
    clipmax: {
      valType: 'any',
      editType: 'plot',
      impliedEdits: {
        'range[0]': undefined,
        'range[1]': undefined
      }
    },
    include: {
      valType: 'any',
      arrayOk: true,
      editType: 'plot',
      impliedEdits: {
        'range[0]': undefined,
        'range[1]': undefined
      }
    },
    editType: 'plot'
  },
  rangemode: {
    valType: 'enumerated',
    values: ['normal', 'tozero', 'nonnegative'],
    dflt: 'normal',
    editType: 'plot'
  },
  range: {
    valType: 'info_array',
    items: [{
      valType: 'any',
      editType: 'axrange',
      impliedEdits: {
        '^autorange': false
      },
      anim: true
    }, {
      valType: 'any',
      editType: 'axrange',
      impliedEdits: {
        '^autorange': false
      },
      anim: true
    }],
    editType: 'axrange',
    impliedEdits: {
      autorange: false
    },
    anim: true
  },
  minallowed: {
    valType: 'any',
    editType: 'plot',
    impliedEdits: {
      '^autorange': false
    }
  },
  maxallowed: {
    valType: 'any',
    editType: 'plot',
    impliedEdits: {
      '^autorange': false
    }
  },
  fixedrange: {
    valType: 'boolean',
    dflt: false,
    editType: 'calc'
  },
  insiderange: {
    valType: 'info_array',
    items: [{
      valType: 'any',
      editType: 'plot'
    }, {
      valType: 'any',
      editType: 'plot'
    }],
    editType: 'plot'
  },
  // scaleanchor: not used directly, just put here for reference
  // values are any opposite-letter axis id, or `false`.
  scaleanchor: {
    valType: 'enumerated',
    values: [constants.idRegex.x.toString(), constants.idRegex.y.toString(), false],
    editType: 'plot'
  },
  scaleratio: {
    valType: 'number',
    min: 0,
    dflt: 1,
    editType: 'plot'
  },
  constrain: {
    valType: 'enumerated',
    values: ['range', 'domain'],
    editType: 'plot'
  },
  // constraintoward: not used directly, just put here for reference
  constraintoward: {
    valType: 'enumerated',
    values: ['left', 'center', 'right', 'top', 'middle', 'bottom'],
    editType: 'plot'
  },
  matches: {
    valType: 'enumerated',
    values: [constants.idRegex.x.toString(), constants.idRegex.y.toString()],
    editType: 'calc'
  },
  rangebreaks: templatedArray('rangebreak', {
    enabled: {
      valType: 'boolean',
      dflt: true,
      editType: 'calc'
    },
    bounds: {
      valType: 'info_array',
      items: [{
        valType: 'any',
        editType: 'calc'
      }, {
        valType: 'any',
        editType: 'calc'
      }],
      editType: 'calc'
    },
    pattern: {
      valType: 'enumerated',
      values: [DAY_OF_WEEK, HOUR, ''],
      editType: 'calc'
    },
    values: {
      valType: 'info_array',
      freeLength: true,
      editType: 'calc',
      items: {
        valType: 'any',
        editType: 'calc'
      }
    },
    dvalue: {
      // TODO could become 'any' to add support for 'months', 'years'
      valType: 'number',
      editType: 'calc',
      min: 0,
      dflt: ONEDAY
    },
    /*
    gap: {
        valType: 'number',
        min: 0,
        dflt: 0, // for *date* axes, maybe something else for *linear*
        editType: 'calc',
    },
    gapmode: {
        valType: 'enumerated',
        values: ['pixels', 'fraction'],
        dflt: 'pixels',
        editType: 'calc',
    },
    */

    // To complete https://github.com/plotly/plotly.js/issues/4210
    // we additionally need `gap` and make this work on *linear*, and
    // possibly all other cartesian axis types. We possibly would also need
    // some style attributes controlling the zig-zag on the corresponding
    // axis.

    editType: 'calc'
  }),
  // ticks
  tickmode: tickmode,
  nticks: makeNticks(),
  tick0: tick0,
  dtick: dtick,
  ticklabelstep: {
    valType: 'integer',
    min: 1,
    dflt: 1,
    editType: 'ticks'
  },
  tickvals: tickvals,
  ticktext: {
    valType: 'data_array',
    editType: 'ticks'
  },
  ticks: ticks,
  tickson: {
    valType: 'enumerated',
    values: ['labels', 'boundaries'],
    dflt: 'labels',
    editType: 'ticks'
  },
  ticklabelmode: {
    valType: 'enumerated',
    values: ['instant', 'period'],
    dflt: 'instant',
    editType: 'ticks'
  },
  // ticklabelposition: not used directly, as values depend on direction (similar to side)
  // left/right options are for x axes, and top/bottom options are for y axes
  ticklabelposition: {
    valType: 'enumerated',
    values: ['outside', 'inside', 'outside top', 'inside top', 'outside left', 'inside left', 'outside right', 'inside right', 'outside bottom', 'inside bottom'],
    dflt: 'outside',
    editType: 'calc'
  },
  ticklabeloverflow: {
    valType: 'enumerated',
    values: ['allow', 'hide past div', 'hide past domain'],
    editType: 'calc'
  },
  mirror: {
    valType: 'enumerated',
    values: [true, 'ticks', false, 'all', 'allticks'],
    dflt: false,
    editType: 'ticks+layoutstyle'
  },
  ticklen: makeTicklen(),
  tickwidth: makeTickwidth(),
  tickcolor: tickcolor,
  showticklabels: {
    valType: 'boolean',
    dflt: true,
    editType: 'ticks'
  },
  labelalias: {
    valType: 'any',
    dflt: false,
    editType: 'ticks'
  },
  automargin: {
    valType: 'flaglist',
    flags: ['height', 'width', 'left', 'right', 'top', 'bottom'],
    extras: [true, false],
    dflt: false,
    editType: 'ticks'
  },
  showspikes: {
    valType: 'boolean',
    dflt: false,
    editType: 'modebar'
  },
  spikecolor: {
    valType: 'color',
    dflt: null,
    editType: 'none'
  },
  spikethickness: {
    valType: 'number',
    dflt: 3,
    editType: 'none'
  },
  spikedash: extendFlat({}, dash, {
    dflt: 'dash',
    editType: 'none'
  }),
  spikemode: {
    valType: 'flaglist',
    flags: ['toaxis', 'across', 'marker'],
    dflt: 'toaxis',
    editType: 'none'
  },
  spikesnap: {
    valType: 'enumerated',
    values: ['data', 'cursor', 'hovered data'],
    dflt: 'hovered data',
    editType: 'none'
  },
  tickfont: fontAttrs({
    editType: 'ticks'
  }),
  tickangle: {
    valType: 'angle',
    dflt: 'auto',
    editType: 'ticks'
  },
  tickprefix: {
    valType: 'string',
    dflt: '',
    editType: 'ticks'
  },
  showtickprefix: {
    valType: 'enumerated',
    values: ['all', 'first', 'last', 'none'],
    dflt: 'all',
    editType: 'ticks'
  },
  ticksuffix: {
    valType: 'string',
    dflt: '',
    editType: 'ticks'
  },
  showticksuffix: {
    valType: 'enumerated',
    values: ['all', 'first', 'last', 'none'],
    dflt: 'all',
    editType: 'ticks'
  },
  showexponent: {
    valType: 'enumerated',
    values: ['all', 'first', 'last', 'none'],
    dflt: 'all',
    editType: 'ticks'
  },
  exponentformat: {
    valType: 'enumerated',
    values: ['none', 'e', 'E', 'power', 'SI', 'B'],
    dflt: 'B',
    editType: 'ticks'
  },
  minexponent: {
    valType: 'number',
    dflt: 3,
    min: 0,
    editType: 'ticks'
  },
  separatethousands: {
    valType: 'boolean',
    dflt: false,
    editType: 'ticks'
  },
  tickformat: {
    valType: 'string',
    dflt: '',
    editType: 'ticks',
    description: descriptionWithDates('tick label')
  },
  tickformatstops: templatedArray('tickformatstop', {
    enabled: {
      valType: 'boolean',
      dflt: true,
      editType: 'ticks'
    },
    dtickrange: {
      valType: 'info_array',
      items: [{
        valType: 'any',
        editType: 'ticks'
      }, {
        valType: 'any',
        editType: 'ticks'
      }],
      editType: 'ticks'
    },
    value: {
      valType: 'string',
      dflt: '',
      editType: 'ticks'
    },
    editType: 'ticks'
  }),
  hoverformat: {
    valType: 'string',
    dflt: '',
    editType: 'none',
    description: descriptionWithDates('hover text')
  },
  // lines and grids
  showline: {
    valType: 'boolean',
    dflt: false,
    editType: 'ticks+layoutstyle'
  },
  linecolor: {
    valType: 'color',
    dflt: colorAttrs.defaultLine,
    editType: 'layoutstyle'
  },
  linewidth: {
    valType: 'number',
    min: 0,
    dflt: 1,
    editType: 'ticks+layoutstyle'
  },
  showgrid: showgrid,
  gridcolor: gridcolor,
  gridwidth: makeGridwidth(),
  griddash: griddash,
  zeroline: {
    valType: 'boolean',
    editType: 'ticks'
  },
  zerolinecolor: {
    valType: 'color',
    dflt: colorAttrs.defaultLine,
    editType: 'ticks'
  },
  zerolinewidth: {
    valType: 'number',
    dflt: 1,
    editType: 'ticks'
  },
  showdividers: {
    valType: 'boolean',
    dflt: true,
    editType: 'ticks'
  },
  dividercolor: {
    valType: 'color',
    dflt: colorAttrs.defaultLine,
    editType: 'ticks'
  },
  dividerwidth: {
    valType: 'number',
    dflt: 1,
    editType: 'ticks'
  },
  // TODO dividerlen: that would override "to label base" length?

  // positioning attributes
  // anchor: not used directly, just put here for reference
  // values are any opposite-letter axis id
  anchor: {
    valType: 'enumerated',
    values: ['free', constants.idRegex.x.toString(), constants.idRegex.y.toString()],
    editType: 'plot'
  },
  // side: not used directly, as values depend on direction
  // values are top, bottom for x axes, and left, right for y
  side: {
    valType: 'enumerated',
    values: ['top', 'bottom', 'left', 'right'],
    editType: 'plot'
  },
  // overlaying: not used directly, just put here for reference
  // values are false and any other same-letter axis id that's not
  // itself overlaying anything
  overlaying: {
    valType: 'enumerated',
    values: ['free', constants.idRegex.x.toString(), constants.idRegex.y.toString()],
    editType: 'plot'
  },
  minor: {
    tickmode: minorTickmode,
    nticks: makeNticks('minor'),
    tick0: tick0,
    dtick: dtick,
    tickvals: tickvals,
    ticks: ticks,
    ticklen: makeTicklen('minor'),
    tickwidth: makeTickwidth('minor'),
    tickcolor: tickcolor,
    gridcolor: gridcolor,
    gridwidth: makeGridwidth('minor'),
    griddash: griddash,
    showgrid: showgrid,
    editType: 'ticks'
  },
  layer: {
    valType: 'enumerated',
    values: ['above traces', 'below traces'],
    dflt: 'above traces',
    editType: 'plot'
  },
  domain: {
    valType: 'info_array',
    items: [{
      valType: 'number',
      min: 0,
      max: 1,
      editType: 'plot'
    }, {
      valType: 'number',
      min: 0,
      max: 1,
      editType: 'plot'
    }],
    dflt: [0, 1],
    editType: 'plot'
  },
  position: {
    valType: 'number',
    min: 0,
    max: 1,
    dflt: 0,
    editType: 'plot'
  },
  autoshift: {
    valType: 'boolean',
    dflt: false,
    editType: 'plot'
  },
  shift: {
    valType: 'number',
    editType: 'plot'
  },
  categoryorder: {
    valType: 'enumerated',
    values: ['trace', 'category ascending', 'category descending', 'array', 'total ascending', 'total descending', 'min ascending', 'min descending', 'max ascending', 'max descending', 'sum ascending', 'sum descending', 'mean ascending', 'mean descending', 'median ascending', 'median descending'],
    dflt: 'trace',
    editType: 'calc'
  },
  categoryarray: {
    valType: 'data_array',
    editType: 'calc'
  },
  uirevision: {
    valType: 'any',
    editType: 'none'
  },
  editType: 'calc',
  _deprecated: {
    autotick: {
      valType: 'boolean',
      editType: 'ticks'
    },
    title: {
      valType: 'string',
      editType: 'ticks'
    },
    titlefont: fontAttrs({
      editType: 'ticks'
    })
  }
};

/***/ }),

/***/ 6763:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Color = __webpack_require__(7901);
var isUnifiedHover = (__webpack_require__(3469).isUnifiedHover);
var handleHoverModeDefaults = __webpack_require__(8212);
var Template = __webpack_require__(4467);
var basePlotLayoutAttributes = __webpack_require__(820);
var layoutAttributes = __webpack_require__(3838);
var handleTypeDefaults = __webpack_require__(951);
var handleAxisDefaults = __webpack_require__(1453);
var constraints = __webpack_require__(9082);
var handlePositionDefaults = __webpack_require__(2830);
var axisIds = __webpack_require__(1675);
var id2name = axisIds.id2name;
var name2id = axisIds.name2id;
var AX_ID_PATTERN = (__webpack_require__(5555).AX_ID_PATTERN);
var Registry = __webpack_require__(3972);
var traceIs = Registry.traceIs;
var getComponentMethod = Registry.getComponentMethod;
function appendList(cont, k, item) {
  if (Array.isArray(cont[k])) cont[k].push(item);else cont[k] = [item];
}
module.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {
  var autotypenumbersDflt = layoutOut.autotypenumbers;
  var ax2traces = {};
  var xaMayHide = {};
  var yaMayHide = {};
  var xaMustDisplay = {};
  var yaMustDisplay = {};
  var yaMustNotReverse = {};
  var yaMayReverse = {};
  var axHasImage = {};
  var outerTicks = {};
  var noGrids = {};
  var i, j;

  // look for axes in the data
  for (i = 0; i < fullData.length; i++) {
    var trace = fullData[i];
    if (!traceIs(trace, 'cartesian') && !traceIs(trace, 'gl2d')) continue;
    var xaName;
    if (trace.xaxis) {
      xaName = id2name(trace.xaxis);
      appendList(ax2traces, xaName, trace);
    } else if (trace.xaxes) {
      for (j = 0; j < trace.xaxes.length; j++) {
        appendList(ax2traces, id2name(trace.xaxes[j]), trace);
      }
    }
    var yaName;
    if (trace.yaxis) {
      yaName = id2name(trace.yaxis);
      appendList(ax2traces, yaName, trace);
    } else if (trace.yaxes) {
      for (j = 0; j < trace.yaxes.length; j++) {
        appendList(ax2traces, id2name(trace.yaxes[j]), trace);
      }
    }

    // logic for funnels
    if (trace.type === 'funnel') {
      if (trace.orientation === 'h') {
        if (xaName) xaMayHide[xaName] = true;
        if (yaName) yaMayReverse[yaName] = true;
      } else {
        if (yaName) yaMayHide[yaName] = true;
      }
    } else if (trace.type === 'image') {
      if (yaName) axHasImage[yaName] = true;
      if (xaName) axHasImage[xaName] = true;
    } else {
      if (yaName) {
        yaMustDisplay[yaName] = true;
        yaMustNotReverse[yaName] = true;
      }
      if (!traceIs(trace, 'carpet') || trace.type === 'carpet' && !trace._cheater) {
        if (xaName) xaMustDisplay[xaName] = true;
      }
    }

    // Two things trigger axis visibility:
    // 1. is not carpet
    // 2. carpet that's not cheater

    // The above check for definitely-not-cheater is not adequate. This
    // second list tracks which axes *could* be a cheater so that the
    // full condition triggering hiding is:
    //   *could* be a cheater and *is not definitely visible*
    if (trace.type === 'carpet' && trace._cheater) {
      if (xaName) xaMayHide[xaName] = true;
    }

    // check for default formatting tweaks
    if (traceIs(trace, '2dMap')) {
      outerTicks[xaName] = true;
      outerTicks[yaName] = true;
    }
    if (traceIs(trace, 'oriented')) {
      var positionAxis = trace.orientation === 'h' ? yaName : xaName;
      noGrids[positionAxis] = true;
    }
  }
  var subplots = layoutOut._subplots;
  var xIds = subplots.xaxis;
  var yIds = subplots.yaxis;
  var xNames = Lib.simpleMap(xIds, id2name);
  var yNames = Lib.simpleMap(yIds, id2name);
  var axNames = xNames.concat(yNames);

  // plot_bgcolor only makes sense if there's a (2D) plot!
  // TODO: bgcolor for each subplot, to inherit from the main one
  var plotBgColor = Color.background;
  if (xIds.length && yIds.length) {
    plotBgColor = Lib.coerce(layoutIn, layoutOut, basePlotLayoutAttributes, 'plot_bgcolor');
  }
  var bgColor = Color.combine(plotBgColor, layoutOut.paper_bgcolor);

  // name of single axis (e.g. 'xaxis', 'yaxis2')
  var axName;
  // id of single axis (e.g. 'y', 'x5')
  var axId;
  // 'x' or 'y'
  var axLetter;
  // input layout axis container
  var axLayoutIn;
  // full layout axis container
  var axLayoutOut;
  function newAxLayoutOut() {
    var traces = ax2traces[axName] || [];
    axLayoutOut._traceIndices = traces.map(function (t) {
      return t._expandedIndex;
    });
    axLayoutOut._annIndices = [];
    axLayoutOut._shapeIndices = [];
    axLayoutOut._selectionIndices = [];
    axLayoutOut._imgIndices = [];
    axLayoutOut._subplotsWith = [];
    axLayoutOut._counterAxes = [];
    axLayoutOut._name = axLayoutOut._attr = axName;
    axLayoutOut._id = axId;
  }
  function coerce(attr, dflt) {
    return Lib.coerce(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);
  }
  function coerce2(attr, dflt) {
    return Lib.coerce2(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);
  }
  function getCounterAxes(axLetter) {
    return axLetter === 'x' ? yIds : xIds;
  }
  function getOverlayableAxes(axLetter, axName) {
    var list = axLetter === 'x' ? xNames : yNames;
    var out = [];
    for (var j = 0; j < list.length; j++) {
      var axName2 = list[j];
      if (axName2 !== axName && !(layoutIn[axName2] || {}).overlaying) {
        out.push(name2id(axName2));
      }
    }
    return out;
  }

  // list of available counter axis names
  var counterAxes = {
    x: getCounterAxes('x'),
    y: getCounterAxes('y')
  };
  // list of all x AND y axis ids
  var allAxisIds = counterAxes.x.concat(counterAxes.y);
  // lookup and list of axis ids that axes in axNames have a reference to,
  // even though they are missing from allAxisIds
  var missingMatchedAxisIdsLookup = {};
  var missingMatchedAxisIds = [];

  // fill in 'missing' axis lookup when an axis is set to match an axis
  // not part of the allAxisIds list, save axis type so that we can propagate
  // it to the missing axes
  function addMissingMatchedAxis() {
    var matchesIn = axLayoutIn.matches;
    if (AX_ID_PATTERN.test(matchesIn) && allAxisIds.indexOf(matchesIn) === -1) {
      missingMatchedAxisIdsLookup[matchesIn] = axLayoutIn.type;
      missingMatchedAxisIds = Object.keys(missingMatchedAxisIdsLookup);
    }
  }
  var hovermode = handleHoverModeDefaults(layoutIn, layoutOut);
  var unifiedHover = isUnifiedHover(hovermode);

  // first pass creates the containers, determines types, and handles most of the settings
  for (i = 0; i < axNames.length; i++) {
    axName = axNames[i];
    axId = name2id(axName);
    axLetter = axName.charAt(0);
    if (!Lib.isPlainObject(layoutIn[axName])) {
      layoutIn[axName] = {};
    }
    axLayoutIn = layoutIn[axName];
    axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');
    newAxLayoutOut();
    var visibleDflt = axLetter === 'x' && !xaMustDisplay[axName] && xaMayHide[axName] || axLetter === 'y' && !yaMustDisplay[axName] && yaMayHide[axName];
    var reverseDflt = axLetter === 'y' && (!yaMustNotReverse[axName] && yaMayReverse[axName] || axHasImage[axName]);
    var defaultOptions = {
      hasMinor: true,
      letter: axLetter,
      font: layoutOut.font,
      outerTicks: outerTicks[axName],
      showGrid: !noGrids[axName],
      data: ax2traces[axName] || [],
      bgColor: bgColor,
      calendar: layoutOut.calendar,
      automargin: true,
      visibleDflt: visibleDflt,
      reverseDflt: reverseDflt,
      autotypenumbersDflt: autotypenumbersDflt,
      splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId]
    };
    coerce('uirevision', layoutOut.uirevision);
    handleTypeDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions);
    handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions, layoutOut);
    var unifiedSpike = unifiedHover && axLetter === hovermode.charAt(0);
    var spikecolor = coerce2('spikecolor', unifiedHover ? axLayoutOut.color : undefined);
    var spikethickness = coerce2('spikethickness', unifiedHover ? 1.5 : undefined);
    var spikedash = coerce2('spikedash', unifiedHover ? 'dot' : undefined);
    var spikemode = coerce2('spikemode', unifiedHover ? 'across' : undefined);
    var spikesnap = coerce2('spikesnap');
    var showSpikes = coerce('showspikes', !!unifiedSpike || !!spikecolor || !!spikethickness || !!spikedash || !!spikemode || !!spikesnap);
    if (!showSpikes) {
      delete axLayoutOut.spikecolor;
      delete axLayoutOut.spikethickness;
      delete axLayoutOut.spikedash;
      delete axLayoutOut.spikemode;
      delete axLayoutOut.spikesnap;
    }

    // If it exists, the the domain of the axis for the anchor of the overlaying axis
    var overlayingAxis = id2name(axLayoutIn.overlaying);
    var overlayingAnchorDomain = [0, 1];
    if (layoutOut[overlayingAxis] !== undefined) {
      var overlayingAnchor = id2name(layoutOut[overlayingAxis].anchor);
      if (layoutOut[overlayingAnchor] !== undefined) {
        overlayingAnchorDomain = layoutOut[overlayingAnchor].domain;
      }
    }
    handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {
      letter: axLetter,
      counterAxes: counterAxes[axLetter],
      overlayableAxes: getOverlayableAxes(axLetter, axName),
      grid: layoutOut.grid,
      overlayingDomain: overlayingAnchorDomain
    });
    coerce('title.standoff');
    addMissingMatchedAxis();
    axLayoutOut._input = axLayoutIn;
  }

  // coerce the 'missing' axes
  i = 0;
  while (i < missingMatchedAxisIds.length) {
    axId = missingMatchedAxisIds[i++];
    axName = id2name(axId);
    axLetter = axName.charAt(0);
    if (!Lib.isPlainObject(layoutIn[axName])) {
      layoutIn[axName] = {};
    }
    axLayoutIn = layoutIn[axName];
    axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');
    newAxLayoutOut();
    var defaultOptions2 = {
      letter: axLetter,
      font: layoutOut.font,
      outerTicks: outerTicks[axName],
      showGrid: !noGrids[axName],
      data: [],
      bgColor: bgColor,
      calendar: layoutOut.calendar,
      automargin: true,
      visibleDflt: false,
      reverseDflt: false,
      autotypenumbersDflt: autotypenumbersDflt,
      splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId]
    };
    coerce('uirevision', layoutOut.uirevision);
    axLayoutOut.type = missingMatchedAxisIdsLookup[axId] || 'linear';
    handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions2, layoutOut);
    handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {
      letter: axLetter,
      counterAxes: counterAxes[axLetter],
      overlayableAxes: getOverlayableAxes(axLetter, axName),
      grid: layoutOut.grid
    });
    coerce('fixedrange');
    addMissingMatchedAxis();
    axLayoutOut._input = axLayoutIn;
  }

  // quick second pass for range slider and selector defaults
  var rangeSliderDefaults = getComponentMethod('rangeslider', 'handleDefaults');
  var rangeSelectorDefaults = getComponentMethod('rangeselector', 'handleDefaults');
  for (i = 0; i < xNames.length; i++) {
    axName = xNames[i];
    axLayoutIn = layoutIn[axName];
    axLayoutOut = layoutOut[axName];
    rangeSliderDefaults(layoutIn, layoutOut, axName);
    if (axLayoutOut.type === 'date') {
      rangeSelectorDefaults(axLayoutIn, axLayoutOut, layoutOut, yNames, axLayoutOut.calendar);
    }
    coerce('fixedrange');
  }
  for (i = 0; i < yNames.length; i++) {
    axName = yNames[i];
    axLayoutIn = layoutIn[axName];
    axLayoutOut = layoutOut[axName];
    var anchoredAxis = layoutOut[id2name(axLayoutOut.anchor)];
    var fixedRangeDflt = getComponentMethod('rangeslider', 'isVisible')(anchoredAxis);
    coerce('fixedrange', fixedRangeDflt);
  }

  // Finally, handle scale constraints and matching axes.
  //
  // We need to do this after all axes have coerced both `type`
  // (so we link only axes of the same type) and
  // `fixedrange` (so we can avoid linking from OR TO a fixed axis).
  constraints.handleDefaults(layoutIn, layoutOut, {
    axIds: allAxisIds.concat(missingMatchedAxisIds).sort(axisIds.idSort),
    axHasImage: axHasImage
  });
};

/***/ }),

/***/ 2128:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var colorMix = (__webpack_require__(4267).mix);
var colorAttrs = __webpack_require__(2399);
var Lib = __webpack_require__(1828);

/**
 * @param {object} opts :
 *   - dfltColor {string} : default axis color
 *   - bgColor {string} : combined subplot bg color
 *   - blend {number, optional} : blend percentage (to compute dflt grid color)
 *   - showLine {boolean} : show line by default
 *   - showGrid {boolean} : show grid by default
 *   - noZeroLine {boolean} : don't coerce zeroline* attributes
 *   - attributes {object} : attribute object associated with input containers
 */
module.exports = function handleLineGridDefaults(containerIn, containerOut, coerce, opts) {
  opts = opts || {};
  var dfltColor = opts.dfltColor;
  function coerce2(attr, dflt) {
    return Lib.coerce2(containerIn, containerOut, opts.attributes, attr, dflt);
  }
  var lineColor = coerce2('linecolor', dfltColor);
  var lineWidth = coerce2('linewidth');
  var showLine = coerce('showline', opts.showLine || !!lineColor || !!lineWidth);
  if (!showLine) {
    delete containerOut.linecolor;
    delete containerOut.linewidth;
  }
  var gridColorDflt = colorMix(dfltColor, opts.bgColor, opts.blend || colorAttrs.lightFraction).toRgbString();
  var gridColor = coerce2('gridcolor', gridColorDflt);
  var gridWidth = coerce2('gridwidth');
  var gridDash = coerce2('griddash');
  var showGridLines = coerce('showgrid', opts.showGrid || !!gridColor || !!gridWidth || !!gridDash);
  if (!showGridLines) {
    delete containerOut.gridcolor;
    delete containerOut.gridwidth;
    delete containerOut.griddash;
  }
  if (opts.hasMinor) {
    var minorGridColorDflt = colorMix(containerOut.gridcolor, opts.bgColor, 67).toRgbString();
    var minorGridColor = coerce2('minor.gridcolor', minorGridColorDflt);
    var minorGridWidth = coerce2('minor.gridwidth', containerOut.gridwidth || 1);
    var minorGridDash = coerce2('minor.griddash', containerOut.griddash || 'solid');
    var minorShowGridLines = coerce('minor.showgrid', !!minorGridColor || !!minorGridWidth || !!minorGridDash);
    if (!minorShowGridLines) {
      delete containerOut.minor.gridcolor;
      delete containerOut.minor.gridwidth;
      delete containerOut.minor.griddash;
    }
  }
  if (!opts.noZeroLine) {
    var zeroLineColor = coerce2('zerolinecolor', dfltColor);
    var zeroLineWidth = coerce2('zerolinewidth');
    var showZeroLine = coerce('zeroline', opts.showGrid || !!zeroLineColor || !!zeroLineWidth);
    if (!showZeroLine) {
      delete containerOut.zerolinecolor;
      delete containerOut.zerolinewidth;
    }
  }
};

/***/ }),

/***/ 2830:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var Lib = __webpack_require__(1828);
module.exports = function handlePositionDefaults(containerIn, containerOut, coerce, options) {
  var counterAxes = options.counterAxes || [];
  var overlayableAxes = options.overlayableAxes || [];
  var letter = options.letter;
  var grid = options.grid;
  var overlayingDomain = options.overlayingDomain;
  var dfltAnchor, dfltDomain, dfltSide, dfltPosition, dfltShift, dfltAutomargin;
  if (grid) {
    dfltDomain = grid._domains[letter][grid._axisMap[containerOut._id]];
    dfltAnchor = grid._anchors[containerOut._id];
    if (dfltDomain) {
      dfltSide = grid[letter + 'side'].split(' ')[0];
      dfltPosition = grid.domain[letter][dfltSide === 'right' || dfltSide === 'top' ? 1 : 0];
    }
  }

  // Even if there's a grid, this axis may not be in it - fall back on non-grid defaults
  dfltDomain = dfltDomain || [0, 1];
  dfltAnchor = dfltAnchor || (isNumeric(containerIn.position) ? 'free' : counterAxes[0] || 'free');
  dfltSide = dfltSide || (letter === 'x' ? 'bottom' : 'left');
  dfltPosition = dfltPosition || 0;
  dfltShift = 0;
  dfltAutomargin = false;
  var anchor = Lib.coerce(containerIn, containerOut, {
    anchor: {
      valType: 'enumerated',
      values: ['free'].concat(counterAxes),
      dflt: dfltAnchor
    }
  }, 'anchor');
  var side = Lib.coerce(containerIn, containerOut, {
    side: {
      valType: 'enumerated',
      values: letter === 'x' ? ['bottom', 'top'] : ['left', 'right'],
      dflt: dfltSide
    }
  }, 'side');
  if (anchor === 'free') {
    if (letter === 'y') {
      var autoshift = coerce('autoshift');
      if (autoshift) {
        dfltPosition = side === 'left' ? overlayingDomain[0] : overlayingDomain[1];
        dfltAutomargin = containerOut.automargin ? containerOut.automargin : true;
        dfltShift = side === 'left' ? -3 : 3;
      }
      coerce('shift', dfltShift);
    }
    coerce('position', dfltPosition);
  }
  coerce('automargin', dfltAutomargin);
  var overlaying = false;
  if (overlayableAxes.length) {
    overlaying = Lib.coerce(containerIn, containerOut, {
      overlaying: {
        valType: 'enumerated',
        values: [false].concat(overlayableAxes),
        dflt: false
      }
    }, 'overlaying');
  }
  if (!overlaying) {
    // TODO: right now I'm copying this domain over to overlaying axes
    // in ax.setscale()... but this means we still need (imperfect) logic
    // in the axes popover to hide domain for the overlaying axis.
    // perhaps I should make a private version _domain that all axes get???
    var domain = coerce('domain', dfltDomain);

    // according to https://www.npmjs.com/package/canvas-size
    // the minimum value of max canvas width across browsers and devices is 4096
    // which applied in the calculation below:
    if (domain[0] > domain[1] - 1 / 4096) containerOut.domain = dfltDomain;
    Lib.noneOrAll(containerIn.domain, containerOut.domain, dfltDomain);

    // tickmode sync needs an overlaying axis, otherwise
    // we should default it to 'auto'
    if (containerOut.tickmode === 'sync') {
      containerOut.tickmode = 'auto';
    }
  }
  coerce('layer');
  return containerOut;
};

/***/ }),

/***/ 9426:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var getShowAttrDflt = __webpack_require__(9652);
module.exports = function handlePrefixSuffixDefaults(containerIn, containerOut, coerce, axType, options) {
  if (!options) options = {};
  var tickSuffixDflt = options.tickSuffixDflt;
  var showAttrDflt = getShowAttrDflt(containerIn);
  var tickPrefix = coerce('tickprefix');
  if (tickPrefix) coerce('showtickprefix', showAttrDflt);
  var tickSuffix = coerce('ticksuffix', tickSuffixDflt);
  if (tickSuffix) coerce('showticksuffix', showAttrDflt);
};

/***/ }),

/***/ 3608:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var handleAutorangeOptionsDefaults = __webpack_require__(3074);
module.exports = function handleRangeDefaults(containerIn, containerOut, coerce, options) {
  var axTemplate = containerOut._template || {};
  var axType = containerOut.type || axTemplate.type || '-';
  coerce('minallowed');
  coerce('maxallowed');
  var range = coerce('range');
  if (!range) {
    var insiderange;
    if (!options.noInsiderange && axType !== 'log') {
      insiderange = coerce('insiderange');

      // We may support partial insideranges in future
      // For now it is out of scope
      if (insiderange && (insiderange[0] === null || insiderange[1] === null)) {
        containerOut.insiderange = false;
        insiderange = undefined;
      }
      if (insiderange) range = coerce('range', insiderange);
    }
  }
  var autorangeDflt = containerOut.getAutorangeDflt(range, options);
  var autorange = coerce('autorange', autorangeDflt);
  var shouldAutorange;

  // validate range and set autorange true for invalid partial ranges
  if (range && (range[0] === null && range[1] === null || (range[0] === null || range[1] === null) && (autorange === 'reversed' || autorange === true) || range[0] !== null && (autorange === 'min' || autorange === 'max reversed') || range[1] !== null && (autorange === 'max' || autorange === 'min reversed'))) {
    range = undefined;
    delete containerOut.range;
    containerOut.autorange = true;
    shouldAutorange = true;
  }
  if (!shouldAutorange) {
    autorangeDflt = containerOut.getAutorangeDflt(range, options);
    autorange = coerce('autorange', autorangeDflt);
  }
  if (autorange) {
    handleAutorangeOptionsDefaults(coerce, autorange, range);
    if (axType === 'linear' || axType === '-') coerce('rangemode');
  }
  containerOut.cleanRange();
};

/***/ }),

/***/ 2449:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var FROM_BL = (__webpack_require__(8783).FROM_BL);
module.exports = function scaleZoom(ax, factor, centerFraction) {
  if (centerFraction === undefined) {
    centerFraction = FROM_BL[ax.constraintoward || 'center'];
  }
  var rangeLinear = [ax.r2l(ax.range[0]), ax.r2l(ax.range[1])];
  var center = rangeLinear[0] + (rangeLinear[1] - rangeLinear[0]) * centerFraction;
  ax.range = ax._input.range = [ax.l2r(center + (rangeLinear[0] - center) * factor), ax.l2r(center + (rangeLinear[1] - center) * factor)];
  ax.setScale();
};

/***/ }),

/***/ 1994:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var utcFormat = (__webpack_require__(4096)/* .utcFormat */ .g0);
var Lib = __webpack_require__(1828);
var numberFormat = Lib.numberFormat;
var isNumeric = __webpack_require__(2770);
var cleanNumber = Lib.cleanNumber;
var ms2DateTime = Lib.ms2DateTime;
var dateTime2ms = Lib.dateTime2ms;
var ensureNumber = Lib.ensureNumber;
var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
var numConstants = __webpack_require__(606);
var FP_SAFE = numConstants.FP_SAFE;
var BADNUM = numConstants.BADNUM;
var LOG_CLIP = numConstants.LOG_CLIP;
var ONEWEEK = numConstants.ONEWEEK;
var ONEDAY = numConstants.ONEDAY;
var ONEHOUR = numConstants.ONEHOUR;
var ONEMIN = numConstants.ONEMIN;
var ONESEC = numConstants.ONESEC;
var axisIds = __webpack_require__(1675);
var constants = __webpack_require__(5555);
var HOUR_PATTERN = constants.HOUR_PATTERN;
var WEEKDAY_PATTERN = constants.WEEKDAY_PATTERN;
function fromLog(v) {
  return Math.pow(10, v);
}
function isValidCategory(v) {
  return v !== null && v !== undefined;
}

/**
 * Define the conversion functions for an axis data is used in 5 ways:
 *
 *  d: data, in whatever form it's provided
 *  c: calcdata: turned into numbers, but not linearized
 *  l: linearized - same as c except for log axes (and other nonlinear
 *      mappings later?) this is used when we need to know if it's
 *      *possible* to show some data on this axis, without caring about
 *      the current range
 *  p: pixel value - mapped to the screen with current size and zoom
 *  r: ranges, tick0, and annotation positions match one of the above
 *     but are handled differently for different types:
 *     - linear and date: data format (d)
 *     - category: calcdata format (c), and will stay that way because
 *       the data format has no continuous mapping
 *     - log: linearized (l) format
 *       TODO: in v3.0 we plan to change it to data format. At that point
 *       shapes will work the same way as ranges, tick0, and annotations
 *       so they can use this conversion too.
 *
 * Creates/updates these conversion functions, and a few more utilities
 * like cleanRange, and makeCalcdata
 *
 * also clears the autotick constraints ._minDtick, ._forceTick0
 */
module.exports = function setConvert(ax, fullLayout) {
  fullLayout = fullLayout || {};
  var axId = ax._id || 'x';
  var axLetter = axId.charAt(0);
  function toLog(v, clip) {
    if (v > 0) return Math.log(v) / Math.LN10;else if (v <= 0 && clip && ax.range && ax.range.length === 2) {
      // clip NaN (ie past negative infinity) to LOG_CLIP axis
      // length past the negative edge
      var r0 = ax.range[0];
      var r1 = ax.range[1];
      return 0.5 * (r0 + r1 - 2 * LOG_CLIP * Math.abs(r0 - r1));
    } else return BADNUM;
  }

  /*
   * wrapped dateTime2ms that:
   * - accepts ms numbers for backward compatibility
   * - inserts a dummy arg so calendar is the 3rd arg (see notes below).
   * - defaults to ax.calendar
   */
  function dt2ms(v, _, calendar, opts) {
    if ((opts || {}).msUTC && isNumeric(v)) {
      // For now it is only used
      // to fix bar length in milliseconds & gl3d ticks
      // It could be applied in other places in v3
      return +v;
    }

    // NOTE: Changed this behavior: previously we took any numeric value
    // to be a ms, even if it was a string that could be a bare year.
    // Now we convert it as a date if at all possible, and only try
    // as (local) ms if that fails.
    var ms = dateTime2ms(v, calendar || ax.calendar);
    if (ms === BADNUM) {
      if (isNumeric(v)) {
        v = +v;
        // keep track of tenths of ms, that `new Date` will drop
        // same logic as in Lib.ms2DateTime
        var msecTenths = Math.floor(Lib.mod(v + 0.05, 1) * 10);
        var msRounded = Math.round(v - msecTenths / 10);
        ms = dateTime2ms(new Date(msRounded)) + msecTenths / 10;
      } else return BADNUM;
    }
    return ms;
  }

  // wrapped ms2DateTime to insert default ax.calendar
  function ms2dt(v, r, calendar) {
    return ms2DateTime(v, r, calendar || ax.calendar);
  }
  function getCategoryName(v) {
    return ax._categories[Math.round(v)];
  }

  /*
   * setCategoryIndex: return the index of category v,
   * inserting it in the list if it's not already there
   *
   * this will enter the categories in the order it
   * encounters them, ie all the categories from the
   * first data set, then all the ones from the second
   * that aren't in the first etc.
   *
   * it is assumed that this function is being invoked in the
   * already sorted category order; otherwise there would be
   * a disconnect between the array and the index returned
   */
  function setCategoryIndex(v) {
    if (isValidCategory(v)) {
      if (ax._categoriesMap === undefined) {
        ax._categoriesMap = {};
      }
      if (ax._categoriesMap[v] !== undefined) {
        return ax._categoriesMap[v];
      } else {
        ax._categories.push(typeof v === 'number' ? String(v) : v);
        var curLength = ax._categories.length - 1;
        ax._categoriesMap[v] = curLength;
        return curLength;
      }
    }
    return BADNUM;
  }
  function setMultiCategoryIndex(arrayIn, len) {
    var arrayOut = new Array(len);
    for (var i = 0; i < len; i++) {
      var v0 = (arrayIn[0] || [])[i];
      var v1 = (arrayIn[1] || [])[i];
      arrayOut[i] = getCategoryIndex([v0, v1]);
    }
    return arrayOut;
  }
  function getCategoryIndex(v) {
    if (ax._categoriesMap) {
      return ax._categoriesMap[v];
    }
  }
  function getCategoryPosition(v) {
    // d2l/d2c variant that that won't add categories but will also
    // allow numbers to be mapped to the linearized axis positions
    var index = getCategoryIndex(v);
    if (index !== undefined) return index;
    if (isNumeric(v)) return +v;
  }
  function getRangePosition(v) {
    return isNumeric(v) ? +v : getCategoryIndex(v);
  }

  // include 2 fractional digits on pixel, for PDF zooming etc
  function _l2p(v, m, b) {
    return d3.round(b + m * v, 2);
  }
  function _p2l(px, m, b) {
    return (px - b) / m;
  }
  var l2p = function l2p(v) {
    if (!isNumeric(v)) return BADNUM;
    return _l2p(v, ax._m, ax._b);
  };
  var p2l = function (px) {
    return _p2l(px, ax._m, ax._b);
  };
  if (ax.rangebreaks) {
    var isY = axLetter === 'y';
    l2p = function (v) {
      if (!isNumeric(v)) return BADNUM;
      var len = ax._rangebreaks.length;
      if (!len) return _l2p(v, ax._m, ax._b);
      var flip = isY;
      if (ax.range[0] > ax.range[1]) flip = !flip;
      var signAx = flip ? -1 : 1;
      var pos = signAx * v;
      var q = 0;
      for (var i = 0; i < len; i++) {
        var min = signAx * ax._rangebreaks[i].min;
        var max = signAx * ax._rangebreaks[i].max;
        if (pos < min) break;
        if (pos > max) q = i + 1;else {
          // when falls into break, pick 'closest' offset
          q = pos < (min + max) / 2 ? i : i + 1;
          break;
        }
      }
      var b2 = ax._B[q] || 0;
      if (!isFinite(b2)) return 0; // avoid NaN translate e.g. in positionLabels if one keep zooming exactly into a break
      return _l2p(v, ax._m2, b2);
    };
    p2l = function (px) {
      var len = ax._rangebreaks.length;
      if (!len) return _p2l(px, ax._m, ax._b);
      var q = 0;
      for (var i = 0; i < len; i++) {
        if (px < ax._rangebreaks[i].pmin) break;
        if (px > ax._rangebreaks[i].pmax) q = i + 1;
      }
      return _p2l(px, ax._m2, ax._B[q]);
    };
  }

  // conversions among c/l/p are fairly simple - do them together for all axis types
  ax.c2l = ax.type === 'log' ? toLog : ensureNumber;
  ax.l2c = ax.type === 'log' ? fromLog : ensureNumber;
  ax.l2p = l2p;
  ax.p2l = p2l;
  ax.c2p = ax.type === 'log' ? function (v, clip) {
    return l2p(toLog(v, clip));
  } : l2p;
  ax.p2c = ax.type === 'log' ? function (px) {
    return fromLog(p2l(px));
  } : p2l;

  /*
   * now type-specific conversions for **ALL** other combinations
   * they're all written out, instead of being combinations of each other, for
   * both clarity and speed.
   */
  if (['linear', '-'].indexOf(ax.type) !== -1) {
    // all are data vals, but d and r need cleaning
    ax.d2r = ax.r2d = ax.d2c = ax.r2c = ax.d2l = ax.r2l = cleanNumber;
    ax.c2d = ax.c2r = ax.l2d = ax.l2r = ensureNumber;
    ax.d2p = ax.r2p = function (v) {
      return ax.l2p(cleanNumber(v));
    };
    ax.p2d = ax.p2r = p2l;
    ax.cleanPos = ensureNumber;
  } else if (ax.type === 'log') {
    // d and c are data vals, r and l are logged (but d and r need cleaning)
    ax.d2r = ax.d2l = function (v, clip) {
      return toLog(cleanNumber(v), clip);
    };
    ax.r2d = ax.r2c = function (v) {
      return fromLog(cleanNumber(v));
    };
    ax.d2c = ax.r2l = cleanNumber;
    ax.c2d = ax.l2r = ensureNumber;
    ax.c2r = toLog;
    ax.l2d = fromLog;
    ax.d2p = function (v, clip) {
      return ax.l2p(ax.d2r(v, clip));
    };
    ax.p2d = function (px) {
      return fromLog(p2l(px));
    };
    ax.r2p = function (v) {
      return ax.l2p(cleanNumber(v));
    };
    ax.p2r = p2l;
    ax.cleanPos = ensureNumber;
  } else if (ax.type === 'date') {
    // r and d are date strings, l and c are ms

    /*
     * Any of these functions with r and d on either side, calendar is the
     * **3rd** argument. log has reserved the second argument.
     *
     * Unless you need the special behavior of the second arg (ms2DateTime
     * uses this to limit precision, toLog uses true to clip negatives
     * to offscreen low rather than undefined), it's safe to pass 0.
     */
    ax.d2r = ax.r2d = Lib.identity;
    ax.d2c = ax.r2c = ax.d2l = ax.r2l = dt2ms;
    ax.c2d = ax.c2r = ax.l2d = ax.l2r = ms2dt;
    ax.d2p = ax.r2p = function (v, _, calendar) {
      return ax.l2p(dt2ms(v, 0, calendar));
    };
    ax.p2d = ax.p2r = function (px, r, calendar) {
      return ms2dt(p2l(px), r, calendar);
    };
    ax.cleanPos = function (v) {
      return Lib.cleanDate(v, BADNUM, ax.calendar);
    };
  } else if (ax.type === 'category') {
    // d is categories (string)
    // c and l are indices (numbers)
    // r is categories or numbers

    ax.d2c = ax.d2l = setCategoryIndex;
    ax.r2d = ax.c2d = ax.l2d = getCategoryName;
    ax.d2r = ax.d2l_noadd = getCategoryPosition;
    ax.r2c = function (v) {
      var index = getRangePosition(v);
      return index !== undefined ? index : ax.fraction2r(0.5);
    };
    ax.l2r = ax.c2r = ensureNumber;
    ax.r2l = getRangePosition;
    ax.d2p = function (v) {
      return ax.l2p(ax.r2c(v));
    };
    ax.p2d = function (px) {
      return getCategoryName(p2l(px));
    };
    ax.r2p = ax.d2p;
    ax.p2r = p2l;
    ax.cleanPos = function (v) {
      if (typeof v === 'string' && v !== '') return v;
      return ensureNumber(v);
    };
  } else if (ax.type === 'multicategory') {
    // N.B. multicategory axes don't define d2c and d2l,
    // as 'data-to-calcdata' conversion needs to take into
    // account all data array items as in ax.makeCalcdata.

    ax.r2d = ax.c2d = ax.l2d = getCategoryName;
    ax.d2r = ax.d2l_noadd = getCategoryPosition;
    ax.r2c = function (v) {
      var index = getCategoryPosition(v);
      return index !== undefined ? index : ax.fraction2r(0.5);
    };
    ax.r2c_just_indices = getCategoryIndex;
    ax.l2r = ax.c2r = ensureNumber;
    ax.r2l = getCategoryPosition;
    ax.d2p = function (v) {
      return ax.l2p(ax.r2c(v));
    };
    ax.p2d = function (px) {
      return getCategoryName(p2l(px));
    };
    ax.r2p = ax.d2p;
    ax.p2r = p2l;
    ax.cleanPos = function (v) {
      if (Array.isArray(v) || typeof v === 'string' && v !== '') return v;
      return ensureNumber(v);
    };
    ax.setupMultiCategory = function (fullData) {
      var traceIndices = ax._traceIndices;
      var i, j;
      var group = ax._matchGroup;
      if (group && ax._categories.length === 0) {
        for (var axId2 in group) {
          if (axId2 !== axId) {
            var ax2 = fullLayout[axisIds.id2name(axId2)];
            traceIndices = traceIndices.concat(ax2._traceIndices);
          }
        }
      }

      // [ [cnt, {$cat: index}], for 1,2 ]
      var seen = [[0, {}], [0, {}]];
      // [ [arrayIn[0][i], arrayIn[1][i]], for i .. N ]
      var list = [];
      for (i = 0; i < traceIndices.length; i++) {
        var trace = fullData[traceIndices[i]];
        if (axLetter in trace) {
          var arrayIn = trace[axLetter];
          var len = trace._length || Lib.minRowLength(arrayIn);
          if (isArrayOrTypedArray(arrayIn[0]) && isArrayOrTypedArray(arrayIn[1])) {
            for (j = 0; j < len; j++) {
              var v0 = arrayIn[0][j];
              var v1 = arrayIn[1][j];
              if (isValidCategory(v0) && isValidCategory(v1)) {
                list.push([v0, v1]);
                if (!(v0 in seen[0][1])) {
                  seen[0][1][v0] = seen[0][0]++;
                }
                if (!(v1 in seen[1][1])) {
                  seen[1][1][v1] = seen[1][0]++;
                }
              }
            }
          }
        }
      }
      list.sort(function (a, b) {
        var ind0 = seen[0][1];
        var d = ind0[a[0]] - ind0[b[0]];
        if (d) return d;
        var ind1 = seen[1][1];
        return ind1[a[1]] - ind1[b[1]];
      });
      for (i = 0; i < list.length; i++) {
        setCategoryIndex(list[i]);
      }
    };
  }

  // find the range value at the specified (linear) fraction of the axis
  ax.fraction2r = function (v) {
    var rl0 = ax.r2l(ax.range[0]);
    var rl1 = ax.r2l(ax.range[1]);
    return ax.l2r(rl0 + v * (rl1 - rl0));
  };

  // find the fraction of the range at the specified range value
  ax.r2fraction = function (v) {
    var rl0 = ax.r2l(ax.range[0]);
    var rl1 = ax.r2l(ax.range[1]);
    return (ax.r2l(v) - rl0) / (rl1 - rl0);
  };
  ax.limitRange = function (rangeAttr) {
    var minallowed = ax.minallowed;
    var maxallowed = ax.maxallowed;
    if (minallowed === undefined && maxallowed === undefined) return;
    if (!rangeAttr) rangeAttr = 'range';
    var range = Lib.nestedProperty(ax, rangeAttr).get();
    var rng = Lib.simpleMap(range, ax.r2l);
    var axrev = rng[1] < rng[0];
    if (axrev) rng.reverse();
    var bounds = Lib.simpleMap([minallowed, maxallowed], ax.r2l);
    if (minallowed !== undefined && rng[0] < bounds[0]) range[axrev ? 1 : 0] = minallowed;
    if (maxallowed !== undefined && rng[1] > bounds[1]) range[axrev ? 0 : 1] = maxallowed;
  };

  /*
   * cleanRange: make sure range is a couplet of valid & distinct values
   * keep numbers away from the limits of floating point numbers,
   * and dates away from the ends of our date system (+/- 9999 years)
   *
   * optional param rangeAttr: operate on a different attribute, like
   * ax._r, rather than ax.range
   */
  ax.cleanRange = function (rangeAttr, opts) {
    ax._cleanRange(rangeAttr, opts);
    ax.limitRange(rangeAttr);
  };
  ax._cleanRange = function (rangeAttr, opts) {
    if (!opts) opts = {};
    if (!rangeAttr) rangeAttr = 'range';
    var range = Lib.nestedProperty(ax, rangeAttr).get();
    var i, dflt;
    if (ax.type === 'date') dflt = Lib.dfltRange(ax.calendar);else if (axLetter === 'y') dflt = constants.DFLTRANGEY;else if (ax._name === 'realaxis') dflt = [0, 1];else dflt = opts.dfltRange || constants.DFLTRANGEX;

    // make sure we don't later mutate the defaults
    dflt = dflt.slice();
    if (ax.rangemode === 'tozero' || ax.rangemode === 'nonnegative') {
      dflt[0] = 0;
    }
    if (!range || range.length !== 2) {
      Lib.nestedProperty(ax, rangeAttr).set(dflt);
      return;
    }
    var nullRange0 = range[0] === null;
    var nullRange1 = range[1] === null;
    if (ax.type === 'date' && !ax.autorange) {
      // check if milliseconds or js date objects are provided for range
      // and convert to date strings
      range[0] = Lib.cleanDate(range[0], BADNUM, ax.calendar);
      range[1] = Lib.cleanDate(range[1], BADNUM, ax.calendar);
    }
    for (i = 0; i < 2; i++) {
      if (ax.type === 'date') {
        if (!Lib.isDateTime(range[i], ax.calendar)) {
          ax[rangeAttr] = dflt;
          break;
        }
        if (ax.r2l(range[0]) === ax.r2l(range[1])) {
          // split by +/- 1 second
          var linCenter = Lib.constrain(ax.r2l(range[0]), Lib.MIN_MS + 1000, Lib.MAX_MS - 1000);
          range[0] = ax.l2r(linCenter - 1000);
          range[1] = ax.l2r(linCenter + 1000);
          break;
        }
      } else {
        if (!isNumeric(range[i])) {
          if (!(nullRange0 || nullRange1) && isNumeric(range[1 - i])) {
            range[i] = range[1 - i] * (i ? 10 : 0.1);
          } else {
            ax[rangeAttr] = dflt;
            break;
          }
        }
        if (range[i] < -FP_SAFE) range[i] = -FP_SAFE;else if (range[i] > FP_SAFE) range[i] = FP_SAFE;
        if (range[0] === range[1]) {
          // somewhat arbitrary: split by 1 or 1ppm, whichever is bigger
          var inc = Math.max(1, Math.abs(range[0] * 1e-6));
          range[0] -= inc;
          range[1] += inc;
        }
      }
    }
  };

  // set scaling to pixels
  ax.setScale = function (usePrivateRange) {
    var gs = fullLayout._size;

    // make sure we have a domain (pull it in from the axis
    // this one is overlaying if necessary)
    if (ax.overlaying) {
      var ax2 = axisIds.getFromId({
        _fullLayout: fullLayout
      }, ax.overlaying);
      ax.domain = ax2.domain;
    }

    // While transitions are occurring, we get a double-transform
    // issue if we transform the drawn layer *and* use the new axis range to
    // draw the data. This allows us to construct setConvert using the pre-
    // interaction values of the range:
    var rangeAttr = usePrivateRange && ax._r ? '_r' : 'range';
    var calendar = ax.calendar;
    ax.cleanRange(rangeAttr);
    var rl0 = ax.r2l(ax[rangeAttr][0], calendar);
    var rl1 = ax.r2l(ax[rangeAttr][1], calendar);
    var isY = axLetter === 'y';
    if (isY) {
      ax._offset = gs.t + (1 - ax.domain[1]) * gs.h;
      ax._length = gs.h * (ax.domain[1] - ax.domain[0]);
      ax._m = ax._length / (rl0 - rl1);
      ax._b = -ax._m * rl1;
    } else {
      ax._offset = gs.l + ax.domain[0] * gs.w;
      ax._length = gs.w * (ax.domain[1] - ax.domain[0]);
      ax._m = ax._length / (rl1 - rl0);
      ax._b = -ax._m * rl0;
    }

    // set of "N" disjoint rangebreaks inside the range
    ax._rangebreaks = [];
    // length of these rangebreaks in value space - negative on reversed axes
    ax._lBreaks = 0;
    // l2p slope (same for all intervals)
    ax._m2 = 0;
    // set of l2p offsets (one for each of the (N+1) piecewise intervals)
    ax._B = [];
    if (ax.rangebreaks) {
      var i, brk;
      ax._rangebreaks = ax.locateBreaks(Math.min(rl0, rl1), Math.max(rl0, rl1));
      if (ax._rangebreaks.length) {
        for (i = 0; i < ax._rangebreaks.length; i++) {
          brk = ax._rangebreaks[i];
          ax._lBreaks += Math.abs(brk.max - brk.min);
        }
        var flip = isY;
        if (rl0 > rl1) flip = !flip;
        if (flip) ax._rangebreaks.reverse();
        var sign = flip ? -1 : 1;
        ax._m2 = sign * ax._length / (Math.abs(rl1 - rl0) - ax._lBreaks);
        ax._B.push(-ax._m2 * (isY ? rl1 : rl0));
        for (i = 0; i < ax._rangebreaks.length; i++) {
          brk = ax._rangebreaks[i];
          ax._B.push(ax._B[ax._B.length - 1] - sign * ax._m2 * (brk.max - brk.min));
        }

        // fill pixel (i.e. 'p') min/max here,
        // to not have to loop through the _rangebreaks twice during `p2l`
        for (i = 0; i < ax._rangebreaks.length; i++) {
          brk = ax._rangebreaks[i];
          brk.pmin = l2p(brk.min);
          brk.pmax = l2p(brk.max);
        }
      }
    }
    if (!isFinite(ax._m) || !isFinite(ax._b) || ax._length < 0) {
      fullLayout._replotting = false;
      throw new Error('Something went wrong with axis scaling');
    }
  };
  ax.maskBreaks = function (v) {
    var rangebreaksIn = ax.rangebreaks || [];
    var bnds, b0, b1, vb, vDate;
    if (!rangebreaksIn._cachedPatterns) {
      rangebreaksIn._cachedPatterns = rangebreaksIn.map(function (brk) {
        return brk.enabled && brk.bounds ? Lib.simpleMap(brk.bounds, brk.pattern ? cleanNumber : ax.d2c // case of pattern: ''
        ) : null;
      });
    }
    if (!rangebreaksIn._cachedValues) {
      rangebreaksIn._cachedValues = rangebreaksIn.map(function (brk) {
        return brk.enabled && brk.values ? Lib.simpleMap(brk.values, ax.d2c).sort(Lib.sorterAsc) : null;
      });
    }
    for (var i = 0; i < rangebreaksIn.length; i++) {
      var brk = rangebreaksIn[i];
      if (brk.enabled) {
        if (brk.bounds) {
          var pattern = brk.pattern;
          bnds = rangebreaksIn._cachedPatterns[i];
          b0 = bnds[0];
          b1 = bnds[1];
          switch (pattern) {
            case WEEKDAY_PATTERN:
              vDate = new Date(v);
              vb = vDate.getUTCDay();
              if (b0 > b1) {
                b1 += 7;
                if (vb < b0) vb += 7;
              }
              break;
            case HOUR_PATTERN:
              vDate = new Date(v);
              var hours = vDate.getUTCHours();
              var minutes = vDate.getUTCMinutes();
              var seconds = vDate.getUTCSeconds();
              var milliseconds = vDate.getUTCMilliseconds();
              vb = hours + (minutes / 60 + seconds / 3600 + milliseconds / 3600000);
              if (b0 > b1) {
                b1 += 24;
                if (vb < b0) vb += 24;
              }
              break;
            case '':
              // N.B. should work on date axes as well!
              // e.g. { bounds: ['2020-01-04', '2020-01-05 23:59'] }
              // TODO should work with reversed-range axes
              vb = v;
              break;
          }
          if (vb >= b0 && vb < b1) return BADNUM;
        } else {
          var vals = rangebreaksIn._cachedValues[i];
          for (var j = 0; j < vals.length; j++) {
            b0 = vals[j];
            b1 = b0 + brk.dvalue;
            if (v >= b0 && v < b1) return BADNUM;
          }
        }
      }
    }
    return v;
  };
  ax.locateBreaks = function (r0, r1) {
    var i, bnds, b0, b1;
    var rangebreaksOut = [];
    if (!ax.rangebreaks) return rangebreaksOut;
    var rangebreaksIn = ax.rangebreaks.slice().sort(function (a, b) {
      if (a.pattern === WEEKDAY_PATTERN && b.pattern === HOUR_PATTERN) return -1;
      if (b.pattern === WEEKDAY_PATTERN && a.pattern === HOUR_PATTERN) return 1;
      return 0;
    });
    var addBreak = function (min, max) {
      min = Lib.constrain(min, r0, r1);
      max = Lib.constrain(max, r0, r1);
      if (min === max) return;
      var isNewBreak = true;
      for (var j = 0; j < rangebreaksOut.length; j++) {
        var brkj = rangebreaksOut[j];
        if (min < brkj.max && max >= brkj.min) {
          if (min < brkj.min) {
            brkj.min = min;
          }
          if (max > brkj.max) {
            brkj.max = max;
          }
          isNewBreak = false;
        }
      }
      if (isNewBreak) {
        rangebreaksOut.push({
          min: min,
          max: max
        });
      }
    };
    for (i = 0; i < rangebreaksIn.length; i++) {
      var brk = rangebreaksIn[i];
      if (brk.enabled) {
        if (brk.bounds) {
          var t0 = r0;
          var t1 = r1;
          if (brk.pattern) {
            // to remove decimal (most often found in auto ranges)
            t0 = Math.floor(t0);
          }
          bnds = Lib.simpleMap(brk.bounds, brk.pattern ? cleanNumber : ax.r2l);
          b0 = bnds[0];
          b1 = bnds[1];

          // r0 value as date
          var t0Date = new Date(t0);
          // r0 value for break pattern
          var bndDelta;
          // step in ms between rangebreaks
          var step;
          switch (brk.pattern) {
            case WEEKDAY_PATTERN:
              step = ONEWEEK;
              bndDelta = ((b1 < b0 ? 7 : 0) + (b1 - b0)) * ONEDAY;
              t0 += b0 * ONEDAY - (t0Date.getUTCDay() * ONEDAY + t0Date.getUTCHours() * ONEHOUR + t0Date.getUTCMinutes() * ONEMIN + t0Date.getUTCSeconds() * ONESEC + t0Date.getUTCMilliseconds());
              break;
            case HOUR_PATTERN:
              step = ONEDAY;
              bndDelta = ((b1 < b0 ? 24 : 0) + (b1 - b0)) * ONEHOUR;
              t0 += b0 * ONEHOUR - (t0Date.getUTCHours() * ONEHOUR + t0Date.getUTCMinutes() * ONEMIN + t0Date.getUTCSeconds() * ONESEC + t0Date.getUTCMilliseconds());
              break;
            default:
              t0 = Math.min(bnds[0], bnds[1]);
              t1 = Math.max(bnds[0], bnds[1]);
              step = t1 - t0;
              bndDelta = step;
          }
          for (var t = t0; t < t1; t += step) {
            addBreak(t, t + bndDelta);
          }
        } else {
          var vals = Lib.simpleMap(brk.values, ax.d2c);
          for (var j = 0; j < vals.length; j++) {
            b0 = vals[j];
            b1 = b0 + brk.dvalue;
            addBreak(b0, b1);
          }
        }
      }
    }
    rangebreaksOut.sort(function (a, b) {
      return a.min - b.min;
    });
    return rangebreaksOut;
  };

  // makeCalcdata: takes an x or y array and converts it
  // to a position on the axis object "ax"
  // inputs:
  //      trace - a data object from gd.data
  //      axLetter - a string, either 'x' or 'y', for which item
  //          to convert (TODO: is this now always the same as
  //          the first letter of ax._id?)
  // in case the expected data isn't there, make a list of
  // integers based on the opposite data
  ax.makeCalcdata = function (trace, axLetter, opts) {
    var arrayIn, arrayOut, i, len;
    var axType = ax.type;
    var cal = axType === 'date' && trace[axLetter + 'calendar'];
    if (axLetter in trace) {
      arrayIn = trace[axLetter];
      len = trace._length || Lib.minRowLength(arrayIn);
      if (Lib.isTypedArray(arrayIn) && (axType === 'linear' || axType === 'log')) {
        if (len === arrayIn.length) {
          return arrayIn;
        } else if (arrayIn.subarray) {
          return arrayIn.subarray(0, len);
        }
      }
      if (axType === 'multicategory') {
        return setMultiCategoryIndex(arrayIn, len);
      }
      arrayOut = new Array(len);
      for (i = 0; i < len; i++) {
        arrayOut[i] = ax.d2c(arrayIn[i], 0, cal, opts);
      }
    } else {
      var v0 = axLetter + '0' in trace ? ax.d2c(trace[axLetter + '0'], 0, cal) : 0;
      var dv = trace['d' + axLetter] ? Number(trace['d' + axLetter]) : 1;

      // the opposing data, for size if we have x and dx etc
      arrayIn = trace[{
        x: 'y',
        y: 'x'
      }[axLetter]];
      len = trace._length || arrayIn.length;
      arrayOut = new Array(len);
      for (i = 0; i < len; i++) {
        arrayOut[i] = v0 + i * dv;
      }
    }

    // mask (i.e. set to BADNUM) coords that fall inside rangebreaks
    if (ax.rangebreaks) {
      for (i = 0; i < len; i++) {
        arrayOut[i] = ax.maskBreaks(arrayOut[i]);
      }
    }
    return arrayOut;
  };
  ax.isValidRange = function (range, nullOk) {
    return Array.isArray(range) && range.length === 2 && (nullOk && range[0] === null || isNumeric(ax.r2l(range[0]))) && (nullOk && range[1] === null || isNumeric(ax.r2l(range[1])));
  };
  ax.getAutorangeDflt = function (range, options) {
    var autorangeDflt = !ax.isValidRange(range, 'nullOk');
    if (autorangeDflt && options && options.reverseDflt) autorangeDflt = 'reversed';else if (range) {
      if (range[0] === null && range[1] === null) {
        autorangeDflt = true;
      } else if (range[0] === null && range[1] !== null) {
        autorangeDflt = 'min';
      } else if (range[0] !== null && range[1] === null) {
        autorangeDflt = 'max';
      }
    }
    return autorangeDflt;
  };
  ax.isReversed = function () {
    var autorange = ax.autorange;
    return autorange === 'reversed' || autorange === 'min reversed' || autorange === 'max reversed';
  };
  ax.isPtWithinRange = function (d, calendar) {
    var coord = ax.c2l(d[axLetter], null, calendar);
    var r0 = ax.r2l(ax.range[0]);
    var r1 = ax.r2l(ax.range[1]);
    if (r0 < r1) {
      return r0 <= coord && coord <= r1;
    } else {
      // Reversed axis case.
      return r1 <= coord && coord <= r0;
    }
  };
  ax._emptyCategories = function () {
    ax._categories = [];
    ax._categoriesMap = {};
  };

  // should skip if not category nor multicategory
  ax.clearCalc = function () {
    var group = ax._matchGroup;
    if (group) {
      var categories = null;
      var categoriesMap = null;
      for (var axId2 in group) {
        var ax2 = fullLayout[axisIds.id2name(axId2)];
        if (ax2._categories) {
          categories = ax2._categories;
          categoriesMap = ax2._categoriesMap;
          break;
        }
      }
      if (categories && categoriesMap) {
        ax._categories = categories;
        ax._categoriesMap = categoriesMap;
      } else {
        ax._emptyCategories();
      }
    } else {
      ax._emptyCategories();
    }
    if (ax._initialCategories) {
      for (var j = 0; j < ax._initialCategories.length; j++) {
        setCategoryIndex(ax._initialCategories[j]);
      }
    }
  };

  // sort the axis (and all the matching ones) by _initialCategories
  // returns the indices of the traces affected by the reordering
  ax.sortByInitialCategories = function () {
    var affectedTraces = [];
    ax._emptyCategories();
    if (ax._initialCategories) {
      for (var j = 0; j < ax._initialCategories.length; j++) {
        setCategoryIndex(ax._initialCategories[j]);
      }
    }
    affectedTraces = affectedTraces.concat(ax._traceIndices);

    // Propagate to matching axes
    var group = ax._matchGroup;
    for (var axId2 in group) {
      if (axId === axId2) continue;
      var ax2 = fullLayout[axisIds.id2name(axId2)];
      ax2._categories = ax._categories;
      ax2._categoriesMap = ax._categoriesMap;
      affectedTraces = affectedTraces.concat(ax2._traceIndices);
    }
    return affectedTraces;
  };

  // Propagate localization into the axis so that
  // methods in Axes can use it w/o having to pass fullLayout
  // Default (non-d3) number formatting uses separators directly
  // dates and d3-formatted numbers use the d3 locale
  // Fall back on default format for dummy axes that don't care about formatting
  var locale = fullLayout._d3locale;
  if (ax.type === 'date') {
    ax._dateFormat = locale ? locale.timeFormat : utcFormat;
    ax._extraFormat = fullLayout._extraFormat;
  }
  // occasionally we need _numFormat to pass through
  // even though it won't be needed by this axis
  ax._separators = fullLayout.separators;
  ax._numFormat = locale ? locale.numberFormat : numberFormat;

  // and for bar charts and box plots: reset forced minimum tick spacing
  delete ax._minDtick;
  delete ax._forceTick0;
};

/***/ }),

/***/ 9652:
/***/ (function(module) {

"use strict";


/*
 * Attributes 'showexponent', 'showtickprefix' and 'showticksuffix'
 * share values.
 *
 * If only 1 attribute is set,
 * the remaining attributes inherit that value.
 *
 * If 2 attributes are set to the same value,
 * the remaining attribute inherits that value.
 *
 * If 2 attributes are set to different values,
 * the remaining is set to its dflt value.
 *
 */
module.exports = function getShowAttrDflt(containerIn) {
  var showAttrsAll = ['showexponent', 'showtickprefix', 'showticksuffix'];
  var showAttrs = showAttrsAll.filter(function (a) {
    return containerIn[a] !== undefined;
  });
  var sameVal = function (a) {
    return containerIn[a] === containerIn[showAttrs[0]];
  };
  if (showAttrs.every(sameVal) || showAttrs.length === 1) {
    return containerIn[showAttrs[0]];
  }
};

/***/ }),

/***/ 6115:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var contrast = (__webpack_require__(7901).contrast);
var layoutAttributes = __webpack_require__(3838);
var getShowAttrDflt = __webpack_require__(9652);
var handleArrayContainerDefaults = __webpack_require__(5501);
module.exports = function handleTickLabelDefaults(containerIn, containerOut, coerce, axType, options) {
  if (!options) options = {};
  var labelalias = coerce('labelalias');
  if (!Lib.isPlainObject(labelalias)) delete containerOut.labelalias;
  var showAttrDflt = getShowAttrDflt(containerIn);
  var showTickLabels = coerce('showticklabels');
  if (showTickLabels) {
    var font = options.font || {};
    var contColor = containerOut.color;
    var position = containerOut.ticklabelposition || '';
    var dfltFontColor = position.indexOf('inside') !== -1 ? contrast(options.bgColor) :
    // as with titlefont.color, inherit axis.color only if one was
    // explicitly provided
    contColor && contColor !== layoutAttributes.color.dflt ? contColor : font.color;
    Lib.coerceFont(coerce, 'tickfont', {
      family: font.family,
      size: font.size,
      color: dfltFontColor
    });
    if (!options.noTicklabelstep && axType !== 'multicategory' && axType !== 'log') {
      coerce('ticklabelstep');
    }
    if (!options.noAng) coerce('tickangle');
    if (axType !== 'category') {
      var tickFormat = coerce('tickformat');
      handleArrayContainerDefaults(containerIn, containerOut, {
        name: 'tickformatstops',
        inclusionAttr: 'enabled',
        handleItemDefaults: tickformatstopDefaults
      });
      if (!containerOut.tickformatstops.length) {
        delete containerOut.tickformatstops;
      }
      if (!options.noExp && !tickFormat && axType !== 'date') {
        coerce('showexponent', showAttrDflt);
        coerce('exponentformat');
        coerce('minexponent');
        coerce('separatethousands');
      }
    }
  }
};
function tickformatstopDefaults(valueIn, valueOut) {
  function coerce(attr, dflt) {
    return Lib.coerce(valueIn, valueOut, layoutAttributes.tickformatstops, attr, dflt);
  }
  var enabled = coerce('enabled');
  if (enabled) {
    coerce('dtickrange');
    coerce('value');
  }
}

/***/ }),

/***/ 8701:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var layoutAttributes = __webpack_require__(3838);

/**
 * options: inherits outerTicks from axes.handleAxisDefaults
 */
module.exports = function handleTickMarkDefaults(containerIn, containerOut, coerce, options) {
  var isMinor = options.isMinor;
  var cIn = isMinor ? containerIn.minor || {} : containerIn;
  var cOut = isMinor ? containerOut.minor : containerOut;
  var lAttr = isMinor ? layoutAttributes.minor : layoutAttributes;
  var prefix = isMinor ? 'minor.' : '';
  var tickLen = Lib.coerce2(cIn, cOut, lAttr, 'ticklen', isMinor ? (containerOut.ticklen || 5) * 0.6 : undefined);
  var tickWidth = Lib.coerce2(cIn, cOut, lAttr, 'tickwidth', isMinor ? containerOut.tickwidth || 1 : undefined);
  var tickColor = Lib.coerce2(cIn, cOut, lAttr, 'tickcolor', (isMinor ? containerOut.tickcolor : undefined) || cOut.color);
  var showTicks = coerce(prefix + 'ticks', !isMinor && options.outerTicks || tickLen || tickWidth || tickColor ? 'outside' : '');
  if (!showTicks) {
    delete cOut.ticklen;
    delete cOut.tickwidth;
    delete cOut.tickcolor;
  }
};

/***/ }),

/***/ 6218:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var cleanTicks = __webpack_require__(6287);
var isArrayOrTypedArray = (__webpack_require__(1828).isArrayOrTypedArray);
module.exports = function handleTickValueDefaults(containerIn, containerOut, coerce, axType, opts) {
  if (!opts) opts = {};
  var isMinor = opts.isMinor;
  var cIn = isMinor ? containerIn.minor || {} : containerIn;
  var cOut = isMinor ? containerOut.minor : containerOut;
  var prefix = isMinor ? 'minor.' : '';
  function readInput(attr) {
    var v = cIn[attr];
    return v !== undefined ? v : (cOut._template || {})[attr];
  }
  var _tick0 = readInput('tick0');
  var _dtick = readInput('dtick');
  var _tickvals = readInput('tickvals');
  var tickmodeDefault = isArrayOrTypedArray(_tickvals) ? 'array' : _dtick ? 'linear' : 'auto';
  var tickmode = coerce(prefix + 'tickmode', tickmodeDefault);
  if (tickmode === 'auto' || tickmode === 'sync') {
    coerce(prefix + 'nticks');
  } else if (tickmode === 'linear') {
    // dtick is usually a positive number, but there are some
    // special strings available for log or date axes
    // tick0 also has special logic
    var dtick = cOut.dtick = cleanTicks.dtick(_dtick, axType);
    cOut.tick0 = cleanTicks.tick0(_tick0, axType, containerOut.calendar, dtick);
  } else if (axType !== 'multicategory') {
    var tickvals = coerce(prefix + 'tickvals');
    if (tickvals === undefined) cOut.tickmode = 'auto';else if (!isMinor) coerce('ticktext');
  }
};

/***/ }),

/***/ 6847:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var Drawing = __webpack_require__(1424);
var Axes = __webpack_require__(9298);

/**
 * transitionAxes
 *
 * transition axes from one set of ranges to another, using a svg
 * transformations, similar to during panning.
 *
 * @param {DOM element | object} gd
 * @param {array} edits : array of 'edits', each item with
 * - plotinfo {object} subplot object
 * - xr0 {array} initial x-range
 * - xr1 {array} end x-range
 * - yr0 {array} initial y-range
 * - yr1 {array} end y-range
 * @param {object} transitionOpts
 * @param {function} makeOnCompleteCallback
 */
module.exports = function transitionAxes(gd, edits, transitionOpts, makeOnCompleteCallback) {
  var fullLayout = gd._fullLayout;

  // special case for redraw:false Plotly.animate that relies on this
  // to update axis-referenced layout components
  if (edits.length === 0) {
    Axes.redrawComponents(gd);
    return;
  }
  function unsetSubplotTransform(subplot) {
    var xa = subplot.xaxis;
    var ya = subplot.yaxis;
    fullLayout._defs.select('#' + subplot.clipId + '> rect').call(Drawing.setTranslate, 0, 0).call(Drawing.setScale, 1, 1);
    subplot.plot.call(Drawing.setTranslate, xa._offset, ya._offset).call(Drawing.setScale, 1, 1);
    var traceGroups = subplot.plot.selectAll('.scatterlayer .trace');

    // This is specifically directed at scatter traces, applying an inverse
    // scale to individual points to counteract the scale of the trace
    // as a whole:
    traceGroups.selectAll('.point').call(Drawing.setPointGroupScale, 1, 1);
    traceGroups.selectAll('.textpoint').call(Drawing.setTextPointsScale, 1, 1);
    traceGroups.call(Drawing.hideOutsideRangePoints, subplot);
  }
  function updateSubplot(edit, progress) {
    var plotinfo = edit.plotinfo;
    var xa = plotinfo.xaxis;
    var ya = plotinfo.yaxis;
    var xlen = xa._length;
    var ylen = ya._length;
    var editX = !!edit.xr1;
    var editY = !!edit.yr1;
    var viewBox = [];
    if (editX) {
      var xr0 = Lib.simpleMap(edit.xr0, xa.r2l);
      var xr1 = Lib.simpleMap(edit.xr1, xa.r2l);
      var dx0 = xr0[1] - xr0[0];
      var dx1 = xr1[1] - xr1[0];
      viewBox[0] = (xr0[0] * (1 - progress) + progress * xr1[0] - xr0[0]) / (xr0[1] - xr0[0]) * xlen;
      viewBox[2] = xlen * (1 - progress + progress * dx1 / dx0);
      xa.range[0] = xa.l2r(xr0[0] * (1 - progress) + progress * xr1[0]);
      xa.range[1] = xa.l2r(xr0[1] * (1 - progress) + progress * xr1[1]);
    } else {
      viewBox[0] = 0;
      viewBox[2] = xlen;
    }
    if (editY) {
      var yr0 = Lib.simpleMap(edit.yr0, ya.r2l);
      var yr1 = Lib.simpleMap(edit.yr1, ya.r2l);
      var dy0 = yr0[1] - yr0[0];
      var dy1 = yr1[1] - yr1[0];
      viewBox[1] = (yr0[1] * (1 - progress) + progress * yr1[1] - yr0[1]) / (yr0[0] - yr0[1]) * ylen;
      viewBox[3] = ylen * (1 - progress + progress * dy1 / dy0);
      ya.range[0] = xa.l2r(yr0[0] * (1 - progress) + progress * yr1[0]);
      ya.range[1] = ya.l2r(yr0[1] * (1 - progress) + progress * yr1[1]);
    } else {
      viewBox[1] = 0;
      viewBox[3] = ylen;
    }
    Axes.drawOne(gd, xa, {
      skipTitle: true
    });
    Axes.drawOne(gd, ya, {
      skipTitle: true
    });
    Axes.redrawComponents(gd, [xa._id, ya._id]);
    var xScaleFactor = editX ? xlen / viewBox[2] : 1;
    var yScaleFactor = editY ? ylen / viewBox[3] : 1;
    var clipDx = editX ? viewBox[0] : 0;
    var clipDy = editY ? viewBox[1] : 0;
    var fracDx = editX ? viewBox[0] / viewBox[2] * xlen : 0;
    var fracDy = editY ? viewBox[1] / viewBox[3] * ylen : 0;
    var plotDx = xa._offset - fracDx;
    var plotDy = ya._offset - fracDy;
    plotinfo.clipRect.call(Drawing.setTranslate, clipDx, clipDy).call(Drawing.setScale, 1 / xScaleFactor, 1 / yScaleFactor);
    plotinfo.plot.call(Drawing.setTranslate, plotDx, plotDy).call(Drawing.setScale, xScaleFactor, yScaleFactor);

    // apply an inverse scale to individual points to counteract
    // the scale of the trace group.
    Drawing.setPointGroupScale(plotinfo.zoomScalePts, 1 / xScaleFactor, 1 / yScaleFactor);
    Drawing.setTextPointsScale(plotinfo.zoomScaleTxt, 1 / xScaleFactor, 1 / yScaleFactor);
  }
  var onComplete;
  if (makeOnCompleteCallback) {
    // This module makes the choice whether or not it notifies Plotly.transition
    // about completion:
    onComplete = makeOnCompleteCallback();
  }
  function transitionComplete() {
    var aobj = {};
    for (var i = 0; i < edits.length; i++) {
      var edit = edits[i];
      var xa = edit.plotinfo.xaxis;
      var ya = edit.plotinfo.yaxis;
      if (edit.xr1) aobj[xa._name + '.range'] = edit.xr1.slice();
      if (edit.yr1) aobj[ya._name + '.range'] = edit.yr1.slice();
    }

    // Signal that this transition has completed:
    onComplete && onComplete();
    return Registry.call('relayout', gd, aobj).then(function () {
      for (var i = 0; i < edits.length; i++) {
        unsetSubplotTransform(edits[i].plotinfo);
      }
    });
  }
  function transitionInterrupt() {
    var aobj = {};
    for (var i = 0; i < edits.length; i++) {
      var edit = edits[i];
      var xa = edit.plotinfo.xaxis;
      var ya = edit.plotinfo.yaxis;
      if (edit.xr0) aobj[xa._name + '.range'] = edit.xr0.slice();
      if (edit.yr0) aobj[ya._name + '.range'] = edit.yr0.slice();
    }
    return Registry.call('relayout', gd, aobj).then(function () {
      for (var i = 0; i < edits.length; i++) {
        unsetSubplotTransform(edits[i].plotinfo);
      }
    });
  }
  var t1, t2, raf;
  var easeFn = d3.ease(transitionOpts.easing);
  gd._transitionData._interruptCallbacks.push(function () {
    window.cancelAnimationFrame(raf);
    raf = null;
    return transitionInterrupt();
  });
  function doFrame() {
    t2 = Date.now();
    var tInterp = Math.min(1, (t2 - t1) / transitionOpts.duration);
    var progress = easeFn(tInterp);
    for (var i = 0; i < edits.length; i++) {
      updateSubplot(edits[i], progress);
    }
    if (t2 - t1 > transitionOpts.duration) {
      transitionComplete();
      raf = window.cancelAnimationFrame(doFrame);
    } else {
      raf = window.requestAnimationFrame(doFrame);
    }
  }
  t1 = Date.now();
  raf = window.requestAnimationFrame(doFrame);
  return Promise.resolve();
};

/***/ }),

/***/ 951:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var traceIs = (__webpack_require__(3972).traceIs);
var autoType = __webpack_require__(4322);

/*
 *  data: the plot data to use in choosing auto type
 *  name: axis object name (ie 'xaxis') if one should be stored
 */
module.exports = function handleTypeDefaults(containerIn, containerOut, coerce, options) {
  coerce('autotypenumbers', options.autotypenumbersDflt);
  var axType = coerce('type', (options.splomStash || {}).type);
  if (axType === '-') {
    setAutoType(containerOut, options.data);
    if (containerOut.type === '-') {
      containerOut.type = 'linear';
    } else {
      // copy autoType back to input axis
      // note that if this object didn't exist
      // in the input layout, we have to put it in
      // this happens in the main supplyDefaults function
      containerIn.type = containerOut.type;
    }
  }
};
function setAutoType(ax, data) {
  // new logic: let people specify any type they want,
  // only autotype if type is '-'
  if (ax.type !== '-') return;
  var id = ax._id;
  var axLetter = id.charAt(0);
  var i;

  // support 3d
  if (id.indexOf('scene') !== -1) id = axLetter;
  var d0 = getFirstNonEmptyTrace(data, id, axLetter);
  if (!d0) return;

  // first check for histograms, as the count direction
  // should always default to a linear axis
  if (d0.type === 'histogram' && axLetter === {
    v: 'y',
    h: 'x'
  }[d0.orientation || 'v']) {
    ax.type = 'linear';
    return;
  }
  var calAttr = axLetter + 'calendar';
  var calendar = d0[calAttr];
  var opts = {
    noMultiCategory: !traceIs(d0, 'cartesian') || traceIs(d0, 'noMultiCategory')
  };

  // To not confuse 2D x/y used for per-box sample points for multicategory coordinates
  if (d0.type === 'box' && d0._hasPreCompStats && axLetter === {
    h: 'x',
    v: 'y'
  }[d0.orientation || 'v']) {
    opts.noMultiCategory = true;
  }
  opts.autotypenumbers = ax.autotypenumbers;

  // check all boxes on this x axis to see
  // if they're dates, numbers, or categories
  if (isBoxWithoutPositionCoords(d0, axLetter)) {
    var posLetter = getBoxPosLetter(d0);
    var boxPositions = [];
    for (i = 0; i < data.length; i++) {
      var trace = data[i];
      if (!traceIs(trace, 'box-violin') || (trace[axLetter + 'axis'] || axLetter) !== id) continue;
      if (trace[posLetter] !== undefined) boxPositions.push(trace[posLetter][0]);else if (trace.name !== undefined) boxPositions.push(trace.name);else boxPositions.push('text');
      if (trace[calAttr] !== calendar) calendar = undefined;
    }
    ax.type = autoType(boxPositions, calendar, opts);
  } else if (d0.type === 'splom') {
    var dimensions = d0.dimensions;
    var dim = dimensions[d0._axesDim[id]];
    if (dim.visible) ax.type = autoType(dim.values, calendar, opts);
  } else {
    ax.type = autoType(d0[axLetter] || [d0[axLetter + '0']], calendar, opts);
  }
}
function getFirstNonEmptyTrace(data, id, axLetter) {
  for (var i = 0; i < data.length; i++) {
    var trace = data[i];
    if (trace.type === 'splom' && trace._length > 0 && (trace['_' + axLetter + 'axes'] || {})[id]) {
      return trace;
    }
    if ((trace[axLetter + 'axis'] || axLetter) === id) {
      if (isBoxWithoutPositionCoords(trace, axLetter)) {
        return trace;
      } else if ((trace[axLetter] || []).length || trace[axLetter + '0']) {
        return trace;
      }
    }
  }
}
function getBoxPosLetter(trace) {
  return {
    v: 'x',
    h: 'y'
  }[trace.orientation || 'v'];
}
function isBoxWithoutPositionCoords(trace, axLetter) {
  var posLetter = getBoxPosLetter(trace);
  var isBox = traceIs(trace, 'box-violin');
  var isCandlestick = traceIs(trace._fullInput || {}, 'candlestick');
  return isBox && !isCandlestick && axLetter === posLetter && trace[posLetter] === undefined && trace[posLetter + '0'] === undefined;
}

/***/ }),

/***/ 1137:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);

/*
 * Create or update an observer. This function is designed to be
 * idempotent so that it can be called over and over as the component
 * updates, and will attach and detach listeners as needed.
 *
 * @param {optional object} container
 *      An object on which the observer is stored. This is the mechanism
 *      by which it is idempotent. If it already exists, another won't be
 *      added. Each time it's called, the value lookup table is updated.
 * @param {array} commandList
 *      An array of commands, following either `buttons` of `updatemenus`
 *      or `steps` of `sliders`.
 * @param {function} onchange
 *      A listener called when the value is changed. Receives data object
 *      with information about the new state.
 */
exports.manageCommandObserver = function (gd, container, commandList, onchange) {
  var ret = {};
  var enabled = true;
  if (container && container._commandObserver) {
    ret = container._commandObserver;
  }
  if (!ret.cache) {
    ret.cache = {};
  }

  // Either create or just recompute this:
  ret.lookupTable = {};
  var binding = exports.hasSimpleAPICommandBindings(gd, commandList, ret.lookupTable);
  if (container && container._commandObserver) {
    if (!binding) {
      // If container exists and there are no longer any bindings,
      // remove existing:
      if (container._commandObserver.remove) {
        container._commandObserver.remove();
        container._commandObserver = null;
        return ret;
      }
    } else {
      // If container exists and there *are* bindings, then the lookup
      // table should have been updated and check is already attached,
      // so there's nothing to be done:
      return ret;
    }
  }

  // Determine whether there's anything to do for this binding:

  if (binding) {
    // Build the cache:
    bindingValueHasChanged(gd, binding, ret.cache);
    ret.check = function check() {
      if (!enabled) return;
      var update = bindingValueHasChanged(gd, binding, ret.cache);
      if (update.changed && onchange) {
        // Disable checks for the duration of this command in order to avoid
        // infinite loops:
        if (ret.lookupTable[update.value] !== undefined) {
          ret.disable();
          Promise.resolve(onchange({
            value: update.value,
            type: binding.type,
            prop: binding.prop,
            traces: binding.traces,
            index: ret.lookupTable[update.value]
          })).then(ret.enable, ret.enable);
        }
      }
      return update.changed;
    };
    var checkEvents = ['plotly_relayout', 'plotly_redraw', 'plotly_restyle', 'plotly_update', 'plotly_animatingframe', 'plotly_afterplot'];
    for (var i = 0; i < checkEvents.length; i++) {
      gd._internalOn(checkEvents[i], ret.check);
    }
    ret.remove = function () {
      for (var i = 0; i < checkEvents.length; i++) {
        gd._removeInternalListener(checkEvents[i], ret.check);
      }
    };
  } else {
    // TODO: It'd be really neat to actually give a *reason* for this, but at least a warning
    // is a start
    Lib.log('Unable to automatically bind plot updates to API command');
    ret.lookupTable = {};
    ret.remove = function () {};
  }
  ret.disable = function disable() {
    enabled = false;
  };
  ret.enable = function enable() {
    enabled = true;
  };
  if (container) {
    container._commandObserver = ret;
  }
  return ret;
};

/*
 * This function checks to see if an array of objects containing
 * method and args properties is compatible with automatic two-way
 * binding. The criteria right now are that
 *
 *   1. multiple traces may be affected
 *   2. only one property may be affected
 *   3. the same property must be affected by all commands
 */
exports.hasSimpleAPICommandBindings = function (gd, commandList, bindingsByValue) {
  var i;
  var n = commandList.length;
  var refBinding;
  for (i = 0; i < n; i++) {
    var binding;
    var command = commandList[i];
    var method = command.method;
    var args = command.args;
    if (!Array.isArray(args)) args = [];

    // If any command has no method, refuse to bind:
    if (!method) {
      return false;
    }
    var bindings = exports.computeAPICommandBindings(gd, method, args);

    // Right now, handle one and *only* one property being set:
    if (bindings.length !== 1) {
      return false;
    }
    if (!refBinding) {
      refBinding = bindings[0];
      if (Array.isArray(refBinding.traces)) {
        refBinding.traces.sort();
      }
    } else {
      binding = bindings[0];
      if (binding.type !== refBinding.type) {
        return false;
      }
      if (binding.prop !== refBinding.prop) {
        return false;
      }
      if (Array.isArray(refBinding.traces)) {
        if (Array.isArray(binding.traces)) {
          binding.traces.sort();
          for (var j = 0; j < refBinding.traces.length; j++) {
            if (refBinding.traces[j] !== binding.traces[j]) {
              return false;
            }
          }
        } else {
          return false;
        }
      } else {
        if (binding.prop !== refBinding.prop) {
          return false;
        }
      }
    }
    binding = bindings[0];
    var value = binding.value;
    if (Array.isArray(value)) {
      if (value.length === 1) {
        value = value[0];
      } else {
        return false;
      }
    }
    if (bindingsByValue) {
      bindingsByValue[value] = i;
    }
  }
  return refBinding;
};
function bindingValueHasChanged(gd, binding, cache) {
  var container, value, obj;
  var changed = false;
  if (binding.type === 'data') {
    // If it's data, we need to get a trace. Based on the limited scope
    // of what we cover, we can just take the first trace from the list,
    // or otherwise just the first trace:
    container = gd._fullData[binding.traces !== null ? binding.traces[0] : 0];
  } else if (binding.type === 'layout') {
    container = gd._fullLayout;
  } else {
    return false;
  }
  value = Lib.nestedProperty(container, binding.prop).get();
  obj = cache[binding.type] = cache[binding.type] || {};
  if (obj.hasOwnProperty(binding.prop)) {
    if (obj[binding.prop] !== value) {
      changed = true;
    }
  }
  obj[binding.prop] = value;
  return {
    changed: changed,
    value: value
  };
}

/*
 * Execute an API command. There's really not much to this; it just provides
 * a common hook so that implementations don't need to be synchronized across
 * multiple components with the ability to invoke API commands.
 *
 * @param {string} method
 *      The name of the plotly command to execute. Must be one of 'animate',
 *      'restyle', 'relayout', 'update'.
 * @param {array} args
 *      A list of arguments passed to the API command
 */
exports.executeAPICommand = function (gd, method, args) {
  if (method === 'skip') return Promise.resolve();
  var _method = Registry.apiMethodRegistry[method];
  var allArgs = [gd];
  if (!Array.isArray(args)) args = [];
  for (var i = 0; i < args.length; i++) {
    allArgs.push(args[i]);
  }
  return _method.apply(null, allArgs).catch(function (err) {
    Lib.warn('API call to Plotly.' + method + ' rejected.', err);
    return Promise.reject(err);
  });
};
exports.computeAPICommandBindings = function (gd, method, args) {
  var bindings;
  if (!Array.isArray(args)) args = [];
  switch (method) {
    case 'restyle':
      bindings = computeDataBindings(gd, args);
      break;
    case 'relayout':
      bindings = computeLayoutBindings(gd, args);
      break;
    case 'update':
      bindings = computeDataBindings(gd, [args[0], args[2]]).concat(computeLayoutBindings(gd, [args[1]]));
      break;
    case 'animate':
      bindings = computeAnimateBindings(gd, args);
      break;
    default:
      // This is the case where intelligent logic about what affects
      // this command is not implemented. It causes no ill effects.
      // For example, addFrames simply won't bind to a control component.
      bindings = [];
  }
  return bindings;
};
function computeAnimateBindings(gd, args) {
  // We'll assume that the only relevant modification an animation
  // makes that's meaningfully tracked is the frame:
  if (Array.isArray(args[0]) && args[0].length === 1 && ['string', 'number'].indexOf(typeof args[0][0]) !== -1) {
    return [{
      type: 'layout',
      prop: '_currentFrame',
      value: args[0][0].toString()
    }];
  } else {
    return [];
  }
}
function computeLayoutBindings(gd, args) {
  var bindings = [];
  var astr = args[0];
  var aobj = {};
  if (typeof astr === 'string') {
    aobj[astr] = args[1];
  } else if (Lib.isPlainObject(astr)) {
    aobj = astr;
  } else {
    return bindings;
  }
  crawl(aobj, function (path, attrName, attr) {
    bindings.push({
      type: 'layout',
      prop: path,
      value: attr
    });
  }, '', 0);
  return bindings;
}
function computeDataBindings(gd, args) {
  var traces, astr, val, aobj;
  var bindings = [];

  // Logic copied from Plotly.restyle:
  astr = args[0];
  val = args[1];
  traces = args[2];
  aobj = {};
  if (typeof astr === 'string') {
    aobj[astr] = val;
  } else if (Lib.isPlainObject(astr)) {
    // the 3-arg form
    aobj = astr;
    if (traces === undefined) {
      traces = val;
    }
  } else {
    return bindings;
  }
  if (traces === undefined) {
    // Explicitly assign this to null instead of undefined:
    traces = null;
  }
  crawl(aobj, function (path, attrName, _attr) {
    var thisTraces;
    var attr;
    if (Array.isArray(_attr)) {
      attr = _attr.slice();
      var nAttr = Math.min(attr.length, gd.data.length);
      if (traces) {
        nAttr = Math.min(nAttr, traces.length);
      }
      thisTraces = [];
      for (var j = 0; j < nAttr; j++) {
        thisTraces[j] = traces ? traces[j] : j;
      }
    } else {
      attr = _attr;
      thisTraces = traces ? traces.slice() : null;
    }

    // Convert [7] to just 7 when traces is null:
    if (thisTraces === null) {
      if (Array.isArray(attr)) {
        attr = attr[0];
      }
    } else if (Array.isArray(thisTraces)) {
      if (!Array.isArray(attr)) {
        var tmp = attr;
        attr = [];
        for (var i = 0; i < thisTraces.length; i++) {
          attr[i] = tmp;
        }
      }
      attr.length = Math.min(thisTraces.length, attr.length);
    }
    bindings.push({
      type: 'data',
      prop: path,
      traces: thisTraces,
      value: attr
    });
  }, '', 0);
  return bindings;
}
function crawl(attrs, callback, path, depth) {
  Object.keys(attrs).forEach(function (attrName) {
    var attr = attrs[attrName];
    if (attrName[0] === '_') return;
    var thisPath = path + (depth > 0 ? '.' : '') + attrName;
    if (Lib.isPlainObject(attr)) {
      crawl(attr, callback, thisPath, depth + 1);
    } else {
      // Only execute the callback on leaf nodes:
      callback(thisPath, attrName, attr);
    }
  });
}

/***/ }),

/***/ 7670:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var extendFlat = (__webpack_require__(1426).extendFlat);

/**
 * Make a xy domain attribute group
 *
 * @param {object} opts
 *   @param {string}
 *     opts.name: name to be inserted in the default description
 *   @param {boolean}
 *     opts.trace: set to true for trace containers
 *   @param {string}
 *     opts.editType: editType for all pieces
 *   @param {boolean}
 *     opts.noGridCell: set to true to omit `row` and `column`
 *
 * @param {object} extra
 *   @param {string}
 *     extra.description: extra description. N.B we use
 *     a separate extra container to make it compatible with
 *     the compress_attributes transform.
 *
 * @return {object} attributes object containing {x,y} as specified
 */
exports.Y = function (opts, extra) {
  opts = opts || {};
  extra = extra || {};
  var base = {
    valType: 'info_array',
    editType: opts.editType,
    items: [{
      valType: 'number',
      min: 0,
      max: 1,
      editType: opts.editType
    }, {
      valType: 'number',
      min: 0,
      max: 1,
      editType: opts.editType
    }],
    dflt: [0, 1]
  };
  var namePart = opts.name ? opts.name + ' ' : '';
  var contPart = opts.trace ? 'trace ' : 'subplot ';
  var descPart = extra.description ? ' ' + extra.description : '';
  var out = {
    x: extendFlat({}, base, {}),
    y: extendFlat({}, base, {}),
    editType: opts.editType
  };
  if (!opts.noGridCell) {
    out.row = {
      valType: 'integer',
      min: 0,
      dflt: 0,
      editType: opts.editType
    };
    out.column = {
      valType: 'integer',
      min: 0,
      dflt: 0,
      editType: opts.editType
    };
  }
  return out;
};
exports.c = function (containerOut, layout, coerce, dfltDomains) {
  var dfltX = dfltDomains && dfltDomains.x || [0, 1];
  var dfltY = dfltDomains && dfltDomains.y || [0, 1];
  var grid = layout.grid;
  if (grid) {
    var column = coerce('domain.column');
    if (column !== undefined) {
      if (column < grid.columns) dfltX = grid._domains.x[column];else delete containerOut.domain.column;
    }
    var row = coerce('domain.row');
    if (row !== undefined) {
      if (row < grid.rows) dfltY = grid._domains.y[row];else delete containerOut.domain.row;
    }
  }
  var x = coerce('domain.x', dfltX);
  var y = coerce('domain.y', dfltY);

  // don't accept bad input data
  if (!(x[0] < x[1])) containerOut.domain.x = dfltX.slice();
  if (!(y[0] < y[1])) containerOut.domain.y = dfltY.slice();
};

/***/ }),

/***/ 1940:
/***/ (function(module) {

"use strict";


/*
 * make a font attribute group
 *
 * @param {object} opts
 *   @param {string}
 *     opts.description: where & how this font is used
 *   @param {optional bool} arrayOk:
 *     should each part (family, size, color) be arrayOk? default false.
 *   @param {string} editType:
 *     the editType for all pieces of this font
 *   @param {optional string} colorEditType:
 *     a separate editType just for color
 *
 * @return {object} attributes object containing {family, size, color} as specified
 */
module.exports = function (opts) {
  var editType = opts.editType;
  var colorEditType = opts.colorEditType;
  if (colorEditType === undefined) colorEditType = editType;
  var attrs = {
    family: {
      valType: 'string',
      noBlank: true,
      strict: true,
      editType: editType
    },
    size: {
      valType: 'number',
      min: 1,
      editType: editType
    },
    color: {
      valType: 'color',
      editType: colorEditType
    },
    editType: editType
    // blank strings so compress_attributes can remove
    // TODO - that's uber hacky... better solution?
  };

  if (opts.autoSize) attrs.size.dflt = 'auto';
  if (opts.autoColor) attrs.color.dflt = 'auto';
  if (opts.arrayOk) {
    attrs.family.arrayOk = true;
    attrs.size.arrayOk = true;
    attrs.color.arrayOk = true;
  }
  return attrs;
};

/***/ }),

/***/ 1391:
/***/ (function(module) {

"use strict";


module.exports = {
  _isLinkedToArray: 'frames_entry',
  group: {
    valType: 'string'
  },
  name: {
    valType: 'string'
  },
  traces: {
    valType: 'any'
  },
  baseframe: {
    valType: 'string'
  },
  data: {
    valType: 'any'
  },
  layout: {
    valType: 'any'
  }
};

/***/ }),

/***/ 7659:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
var __webpack_unused_export__;


var Registry = __webpack_require__(3972);
var SUBPLOT_PATTERN = (__webpack_require__(5555).SUBPLOT_PATTERN);

/**
 * Get calcdata trace(s) associated with a given subplot
 *
 * @param {array} calcData: as in gd.calcdata
 * @param {string} type: subplot type
 * @param {string} subplotId: subplot id to look for
 *
 * @return {array} array of calcdata traces
 */
__webpack_unused_export__ = function (calcData, type, subplotId) {
  var basePlotModule = Registry.subplotsRegistry[type];
  if (!basePlotModule) return [];
  var attr = basePlotModule.attr;
  var subplotCalcData = [];
  for (var i = 0; i < calcData.length; i++) {
    var calcTrace = calcData[i];
    var trace = calcTrace[0].trace;
    if (trace[attr] === subplotId) subplotCalcData.push(calcTrace);
  }
  return subplotCalcData;
};
/**
 * Get calcdata trace(s) that can be plotted with a given module
 * NOTE: this isn't necessarily just exactly matching trace type,
 * if multiple trace types use the same plotting routine, they will be
 * collected here.
 * In order to not plot the same thing multiple times, we return two arrays,
 * the calcdata we *will* plot with this module, and the ones we *won't*
 *
 * @param {array} calcdata: as in gd.calcdata
 * @param {object|string|fn} arg1:
 *  the plotting module, or its name, or its plot method
 *
 * @return {array[array]} [foundCalcdata, remainingCalcdata]
 */
exports.a0 = function (calcdata, arg1) {
  var moduleCalcData = [];
  var remainingCalcData = [];
  var plotMethod;
  if (typeof arg1 === 'string') {
    plotMethod = Registry.getModule(arg1).plot;
  } else if (typeof arg1 === 'function') {
    plotMethod = arg1;
  } else {
    plotMethod = arg1.plot;
  }
  if (!plotMethod) {
    return [moduleCalcData, calcdata];
  }
  for (var i = 0; i < calcdata.length; i++) {
    var cd = calcdata[i];
    var trace = cd[0].trace;
    // N.B.
    // - 'legendonly' traces do not make it past here
    // - skip over 'visible' traces that got trimmed completely during calc transforms
    if (trace.visible !== true || trace._length === 0) continue;

    // group calcdata trace not by 'module' (as the name of this function
    // would suggest), but by 'module plot method' so that if some traces
    // share the same module plot method (e.g. bar and histogram), we
    // only call it one!
    if (trace._module && trace._module.plot === plotMethod) {
      moduleCalcData.push(cd);
    } else {
      remainingCalcData.push(cd);
    }
  }
  return [moduleCalcData, remainingCalcData];
};

/**
 * Get the data trace(s) associated with a given subplot.
 *
 * @param {array} data  plotly full data array.
 * @param {string} type subplot type to look for.
 * @param {string} subplotId subplot id to look for.
 *
 * @return {array} list of trace objects.
 *
 */
exports.NG = function getSubplotData(data, type, subplotId) {
  if (!Registry.subplotsRegistry[type]) return [];
  var attr = Registry.subplotsRegistry[type].attr;
  var subplotData = [];
  var trace, subplotX, subplotY;
  if (type === 'gl2d') {
    var spmatch = subplotId.match(SUBPLOT_PATTERN);
    subplotX = 'x' + spmatch[1];
    subplotY = 'y' + spmatch[2];
  }
  for (var i = 0; i < data.length; i++) {
    trace = data[i];
    if (type === 'gl2d' && Registry.traceIs(trace, 'gl2d')) {
      if (trace[attr[0]] === subplotX && trace[attr[1]] === subplotY) {
        subplotData.push(trace);
      }
    } else {
      if (trace[attr] === subplotId) subplotData.push(trace);
    }
  }
  return subplotData;
};

/***/ }),

/***/ 8547:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var overrideAll = (__webpack_require__(962).overrideAll);
var fxAttrs = __webpack_require__(528);
var Scene = __webpack_require__(3539);
var getSubplotData = (__webpack_require__(7659)/* .getSubplotData */ .NG);
var Lib = __webpack_require__(1828);
var xmlnsNamespaces = __webpack_require__(7922);
var GL3D = 'gl3d';
var SCENE = 'scene';
exports.name = GL3D;
exports.attr = SCENE;
exports.idRoot = SCENE;
exports.idRegex = exports.attrRegex = Lib.counterRegex('scene');
exports.attributes = __webpack_require__(9084);
exports.layoutAttributes = __webpack_require__(5500);
exports.baseLayoutAttrOverrides = overrideAll({
  hoverlabel: fxAttrs.hoverlabel
}, 'plot', 'nested');
exports.supplyLayoutDefaults = __webpack_require__(4682);
exports.plot = function plot(gd) {
  var fullLayout = gd._fullLayout;
  var fullData = gd._fullData;
  var sceneIds = fullLayout._subplots[GL3D];
  for (var i = 0; i < sceneIds.length; i++) {
    var sceneId = sceneIds[i];
    var fullSceneData = getSubplotData(fullData, GL3D, sceneId);
    var sceneLayout = fullLayout[sceneId];
    var camera = sceneLayout.camera;
    var scene = sceneLayout._scene;
    if (!scene) {
      scene = new Scene({
        id: sceneId,
        graphDiv: gd,
        container: gd.querySelector('.gl-container'),
        staticPlot: gd._context.staticPlot,
        plotGlPixelRatio: gd._context.plotGlPixelRatio,
        camera: camera
      }, fullLayout);

      // set ref to Scene instance
      sceneLayout._scene = scene;
    }

    // save 'initial' camera view settings for modebar button
    if (!scene.viewInitial) {
      scene.viewInitial = {
        up: {
          x: camera.up.x,
          y: camera.up.y,
          z: camera.up.z
        },
        eye: {
          x: camera.eye.x,
          y: camera.eye.y,
          z: camera.eye.z
        },
        center: {
          x: camera.center.x,
          y: camera.center.y,
          z: camera.center.z
        }
      };
    }
    scene.plot(fullSceneData, fullLayout, gd.layout);
  }
};
exports.clean = function (newFullData, newFullLayout, oldFullData, oldFullLayout) {
  var oldSceneKeys = oldFullLayout._subplots[GL3D] || [];
  for (var i = 0; i < oldSceneKeys.length; i++) {
    var oldSceneKey = oldSceneKeys[i];
    if (!newFullLayout[oldSceneKey] && !!oldFullLayout[oldSceneKey]._scene) {
      oldFullLayout[oldSceneKey]._scene.destroy();
      if (oldFullLayout._infolayer) {
        oldFullLayout._infolayer.selectAll('.annotation-' + oldSceneKey).remove();
      }
    }
  }
};
exports.toSVG = function (gd) {
  var fullLayout = gd._fullLayout;
  var sceneIds = fullLayout._subplots[GL3D];
  var size = fullLayout._size;
  for (var i = 0; i < sceneIds.length; i++) {
    var sceneLayout = fullLayout[sceneIds[i]];
    var domain = sceneLayout.domain;
    var scene = sceneLayout._scene;
    var imageData = scene.toImage('png');
    var image = fullLayout._glimages.append('svg:image');
    image.attr({
      xmlns: xmlnsNamespaces.svg,
      'xlink:href': imageData,
      x: size.l + size.w * domain.x[0],
      y: size.t + size.h * (1 - domain.y[1]),
      width: size.w * (domain.x[1] - domain.x[0]),
      height: size.h * (domain.y[1] - domain.y[0]),
      preserveAspectRatio: 'none'
    });
    scene.destroy();
  }
};

// clean scene ids, 'scene1' -> 'scene'
exports.cleanId = function cleanId(id) {
  if (!id.match(/^scene[0-9]*$/)) return;
  var sceneNum = id.substr(5);
  if (sceneNum === '1') sceneNum = '';
  return SCENE + sceneNum;
};
exports.updateFx = function (gd) {
  var fullLayout = gd._fullLayout;
  var subplotIds = fullLayout._subplots[GL3D];
  for (var i = 0; i < subplotIds.length; i++) {
    var subplotObj = fullLayout[subplotIds[i]]._scene;
    subplotObj.updateFx(fullLayout.dragmode, fullLayout.hovermode);
  }
};

/***/ }),

/***/ 9084:
/***/ (function(module) {

"use strict";


module.exports = {
  scene: {
    valType: 'subplotid',
    dflt: 'scene',
    editType: 'calc+clearAxisTypes'
  }
};

/***/ }),

/***/ 7894:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Color = __webpack_require__(7901);
var axesAttrs = __webpack_require__(3838);
var extendFlat = (__webpack_require__(1426).extendFlat);
var overrideAll = (__webpack_require__(962).overrideAll);
module.exports = overrideAll({
  visible: axesAttrs.visible,
  showspikes: {
    valType: 'boolean',
    dflt: true
  },
  spikesides: {
    valType: 'boolean',
    dflt: true
  },
  spikethickness: {
    valType: 'number',
    min: 0,
    dflt: 2
  },
  spikecolor: {
    valType: 'color',
    dflt: Color.defaultLine
  },
  showbackground: {
    valType: 'boolean',
    dflt: false
  },
  backgroundcolor: {
    valType: 'color',
    dflt: 'rgba(204, 204, 204, 0.5)'
  },
  showaxeslabels: {
    valType: 'boolean',
    dflt: true
  },
  color: axesAttrs.color,
  categoryorder: axesAttrs.categoryorder,
  categoryarray: axesAttrs.categoryarray,
  title: {
    text: axesAttrs.title.text,
    font: axesAttrs.title.font
  },
  type: extendFlat({}, axesAttrs.type, {
    values: ['-', 'linear', 'log', 'date', 'category']
  }),
  autotypenumbers: axesAttrs.autotypenumbers,
  autorange: axesAttrs.autorange,
  autorangeoptions: {
    minallowed: axesAttrs.autorangeoptions.minallowed,
    maxallowed: axesAttrs.autorangeoptions.maxallowed,
    clipmin: axesAttrs.autorangeoptions.clipmin,
    clipmax: axesAttrs.autorangeoptions.clipmax,
    include: axesAttrs.autorangeoptions.include,
    editType: 'plot'
  },
  rangemode: axesAttrs.rangemode,
  minallowed: axesAttrs.minallowed,
  maxallowed: axesAttrs.maxallowed,
  range: extendFlat({}, axesAttrs.range, {
    items: [{
      valType: 'any',
      editType: 'plot',
      impliedEdits: {
        '^autorange': false
      }
    }, {
      valType: 'any',
      editType: 'plot',
      impliedEdits: {
        '^autorange': false
      }
    }],
    anim: false
  }),
  // ticks
  tickmode: axesAttrs.minor.tickmode,
  nticks: axesAttrs.nticks,
  tick0: axesAttrs.tick0,
  dtick: axesAttrs.dtick,
  tickvals: axesAttrs.tickvals,
  ticktext: axesAttrs.ticktext,
  ticks: axesAttrs.ticks,
  mirror: axesAttrs.mirror,
  ticklen: axesAttrs.ticklen,
  tickwidth: axesAttrs.tickwidth,
  tickcolor: axesAttrs.tickcolor,
  showticklabels: axesAttrs.showticklabels,
  labelalias: axesAttrs.labelalias,
  tickfont: axesAttrs.tickfont,
  tickangle: axesAttrs.tickangle,
  tickprefix: axesAttrs.tickprefix,
  showtickprefix: axesAttrs.showtickprefix,
  ticksuffix: axesAttrs.ticksuffix,
  showticksuffix: axesAttrs.showticksuffix,
  showexponent: axesAttrs.showexponent,
  exponentformat: axesAttrs.exponentformat,
  minexponent: axesAttrs.minexponent,
  separatethousands: axesAttrs.separatethousands,
  tickformat: axesAttrs.tickformat,
  tickformatstops: axesAttrs.tickformatstops,
  hoverformat: axesAttrs.hoverformat,
  // lines and grids
  showline: axesAttrs.showline,
  linecolor: axesAttrs.linecolor,
  linewidth: axesAttrs.linewidth,
  showgrid: axesAttrs.showgrid,
  gridcolor: extendFlat({}, axesAttrs.gridcolor,
  // shouldn't this be on-par with 2D?
  {
    dflt: 'rgb(204, 204, 204)'
  }),
  gridwidth: axesAttrs.gridwidth,
  zeroline: axesAttrs.zeroline,
  zerolinecolor: axesAttrs.zerolinecolor,
  zerolinewidth: axesAttrs.zerolinewidth,
  _deprecated: {
    title: axesAttrs._deprecated.title,
    titlefont: axesAttrs._deprecated.titlefont
  }
}, 'plot', 'from-root');

/***/ }),

/***/ 3277:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var colorMix = (__webpack_require__(4267).mix);
var Lib = __webpack_require__(1828);
var Template = __webpack_require__(4467);
var layoutAttributes = __webpack_require__(7894);
var handleTypeDefaults = __webpack_require__(951);
var handleAxisDefaults = __webpack_require__(1453);
var axesNames = ['xaxis', 'yaxis', 'zaxis'];

// TODO: hard-coded lightness fraction based on gridline default colors
// that differ from other subplot types.
var gridLightness = 100 * (204 - 0x44) / (255 - 0x44);
module.exports = function supplyLayoutDefaults(layoutIn, layoutOut, options) {
  var containerIn, containerOut;
  function coerce(attr, dflt) {
    return Lib.coerce(containerIn, containerOut, layoutAttributes, attr, dflt);
  }
  for (var j = 0; j < axesNames.length; j++) {
    var axName = axesNames[j];
    containerIn = layoutIn[axName] || {};
    containerOut = Template.newContainer(layoutOut, axName);
    containerOut._id = axName[0] + options.scene;
    containerOut._name = axName;
    handleTypeDefaults(containerIn, containerOut, coerce, options);
    handleAxisDefaults(containerIn, containerOut, coerce, {
      font: options.font,
      letter: axName[0],
      data: options.data,
      showGrid: true,
      noTickson: true,
      noTicklabelmode: true,
      noTicklabelstep: true,
      noTicklabelposition: true,
      noTicklabeloverflow: true,
      noInsiderange: true,
      bgColor: options.bgColor,
      calendar: options.calendar
    }, options.fullLayout);
    coerce('gridcolor', colorMix(containerOut.color, options.bgColor, gridLightness).toRgbString());
    coerce('title.text', axName[0]); // shouldn't this be on-par with 2D?

    containerOut.setScale = Lib.noop;
    if (coerce('showspikes')) {
      coerce('spikesides');
      coerce('spikethickness');
      coerce('spikecolor', containerOut.color);
    }
    coerce('showaxeslabels');
    if (coerce('showbackground')) coerce('backgroundcolor');
  }
};

/***/ }),

/***/ 422:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var str2RgbaArray = __webpack_require__(8614);
var Lib = __webpack_require__(1828);
var AXES_NAMES = ['xaxis', 'yaxis', 'zaxis'];
function AxesOptions() {
  this.bounds = [[-10, -10, -10], [10, 10, 10]];
  this.ticks = [[], [], []];
  this.tickEnable = [true, true, true];
  this.tickFont = ['sans-serif', 'sans-serif', 'sans-serif'];
  this.tickSize = [12, 12, 12];
  this.tickAngle = [0, 0, 0];
  this.tickColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];
  this.tickPad = [18, 18, 18];
  this.labels = ['x', 'y', 'z'];
  this.labelEnable = [true, true, true];
  this.labelFont = ['Open Sans', 'Open Sans', 'Open Sans'];
  this.labelSize = [20, 20, 20];
  this.labelColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];
  this.labelPad = [30, 30, 30];
  this.lineEnable = [true, true, true];
  this.lineMirror = [false, false, false];
  this.lineWidth = [1, 1, 1];
  this.lineColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];
  this.lineTickEnable = [true, true, true];
  this.lineTickMirror = [false, false, false];
  this.lineTickLength = [10, 10, 10];
  this.lineTickWidth = [1, 1, 1];
  this.lineTickColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];
  this.gridEnable = [true, true, true];
  this.gridWidth = [1, 1, 1];
  this.gridColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];
  this.zeroEnable = [true, true, true];
  this.zeroLineColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];
  this.zeroLineWidth = [2, 2, 2];
  this.backgroundEnable = [true, true, true];
  this.backgroundColor = [[0.8, 0.8, 0.8, 0.5], [0.8, 0.8, 0.8, 0.5], [0.8, 0.8, 0.8, 0.5]];

  // some default values are stored for applying model transforms
  this._defaultTickPad = this.tickPad.slice();
  this._defaultLabelPad = this.labelPad.slice();
  this._defaultLineTickLength = this.lineTickLength.slice();
}
var proto = AxesOptions.prototype;
proto.merge = function (fullLayout, sceneLayout) {
  var opts = this;
  for (var i = 0; i < 3; ++i) {
    var axes = sceneLayout[AXES_NAMES[i]];
    if (!axes.visible) {
      opts.tickEnable[i] = false;
      opts.labelEnable[i] = false;
      opts.lineEnable[i] = false;
      opts.lineTickEnable[i] = false;
      opts.gridEnable[i] = false;
      opts.zeroEnable[i] = false;
      opts.backgroundEnable[i] = false;
      continue;
    }

    // Axes labels
    opts.labels[i] = fullLayout._meta ? Lib.templateString(axes.title.text, fullLayout._meta) : axes.title.text;
    if ('font' in axes.title) {
      if (axes.title.font.color) opts.labelColor[i] = str2RgbaArray(axes.title.font.color);
      if (axes.title.font.family) opts.labelFont[i] = axes.title.font.family;
      if (axes.title.font.size) opts.labelSize[i] = axes.title.font.size;
    }

    // Lines
    if ('showline' in axes) opts.lineEnable[i] = axes.showline;
    if ('linecolor' in axes) opts.lineColor[i] = str2RgbaArray(axes.linecolor);
    if ('linewidth' in axes) opts.lineWidth[i] = axes.linewidth;
    if ('showgrid' in axes) opts.gridEnable[i] = axes.showgrid;
    if ('gridcolor' in axes) opts.gridColor[i] = str2RgbaArray(axes.gridcolor);
    if ('gridwidth' in axes) opts.gridWidth[i] = axes.gridwidth;

    // Remove zeroline if axis type is log
    // otherwise the zeroline is incorrectly drawn at 1 on log axes
    if (axes.type === 'log') opts.zeroEnable[i] = false;else if ('zeroline' in axes) opts.zeroEnable[i] = axes.zeroline;
    if ('zerolinecolor' in axes) opts.zeroLineColor[i] = str2RgbaArray(axes.zerolinecolor);
    if ('zerolinewidth' in axes) opts.zeroLineWidth[i] = axes.zerolinewidth;

    // tick lines
    if ('ticks' in axes && !!axes.ticks) opts.lineTickEnable[i] = true;else opts.lineTickEnable[i] = false;
    if ('ticklen' in axes) {
      opts.lineTickLength[i] = opts._defaultLineTickLength[i] = axes.ticklen;
    }
    if ('tickcolor' in axes) opts.lineTickColor[i] = str2RgbaArray(axes.tickcolor);
    if ('tickwidth' in axes) opts.lineTickWidth[i] = axes.tickwidth;
    if ('tickangle' in axes) {
      opts.tickAngle[i] = axes.tickangle === 'auto' ? -3600 :
      // i.e. special number to set auto option
      Math.PI * -axes.tickangle / 180;
    }

    // tick labels
    if ('showticklabels' in axes) opts.tickEnable[i] = axes.showticklabels;
    if ('tickfont' in axes) {
      if (axes.tickfont.color) opts.tickColor[i] = str2RgbaArray(axes.tickfont.color);
      if (axes.tickfont.family) opts.tickFont[i] = axes.tickfont.family;
      if (axes.tickfont.size) opts.tickSize[i] = axes.tickfont.size;
    }
    if ('mirror' in axes) {
      if (['ticks', 'all', 'allticks'].indexOf(axes.mirror) !== -1) {
        opts.lineTickMirror[i] = true;
        opts.lineMirror[i] = true;
      } else if (axes.mirror === true) {
        opts.lineTickMirror[i] = false;
        opts.lineMirror[i] = true;
      } else {
        opts.lineTickMirror[i] = false;
        opts.lineMirror[i] = false;
      }
    } else opts.lineMirror[i] = false;

    // grid background
    if ('showbackground' in axes && axes.showbackground !== false) {
      opts.backgroundEnable[i] = true;
      opts.backgroundColor[i] = str2RgbaArray(axes.backgroundcolor);
    } else opts.backgroundEnable[i] = false;
  }
};
function createAxesOptions(fullLayout, sceneLayout) {
  var result = new AxesOptions();
  result.merge(fullLayout, sceneLayout);
  return result;
}
module.exports = createAxesOptions;

/***/ }),

/***/ 4682:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Color = __webpack_require__(7901);
var Registry = __webpack_require__(3972);
var handleSubplotDefaults = __webpack_require__(9119);
var supplyGl3dAxisLayoutDefaults = __webpack_require__(3277);
var layoutAttributes = __webpack_require__(5500);
var getSubplotData = (__webpack_require__(7659)/* .getSubplotData */ .NG);
var GL3D = 'gl3d';
module.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {
  var hasNon3D = layoutOut._basePlotModules.length > 1;

  // some layout-wide attribute are used in all scenes
  // if 3D is the only visible plot type
  function getDfltFromLayout(attr) {
    if (hasNon3D) return;
    var isValid = Lib.validate(layoutIn[attr], layoutAttributes[attr]);
    if (isValid) return layoutIn[attr];
  }
  handleSubplotDefaults(layoutIn, layoutOut, fullData, {
    type: GL3D,
    attributes: layoutAttributes,
    handleDefaults: handleGl3dDefaults,
    fullLayout: layoutOut,
    font: layoutOut.font,
    fullData: fullData,
    getDfltFromLayout: getDfltFromLayout,
    autotypenumbersDflt: layoutOut.autotypenumbers,
    paper_bgcolor: layoutOut.paper_bgcolor,
    calendar: layoutOut.calendar
  });
};
function handleGl3dDefaults(sceneLayoutIn, sceneLayoutOut, coerce, opts) {
  /*
   * Scene numbering proceeds as follows
   * scene
   * scene2
   * scene3
   *
   * and d.scene will be undefined or some number or number string
   *
   * Also write back a blank scene object to user layout so that some
   * attributes like aspectratio can be written back dynamically.
   */

  var bgcolor = coerce('bgcolor');
  var bgColorCombined = Color.combine(bgcolor, opts.paper_bgcolor);
  var cameraKeys = ['up', 'center', 'eye'];
  for (var j = 0; j < cameraKeys.length; j++) {
    coerce('camera.' + cameraKeys[j] + '.x');
    coerce('camera.' + cameraKeys[j] + '.y');
    coerce('camera.' + cameraKeys[j] + '.z');
  }
  coerce('camera.projection.type');

  /*
   * coerce to positive number (min 0) but also do not accept 0 (>0 not >=0)
   * note that 0's go false with the !! call
   */
  var hasAspect = !!coerce('aspectratio.x') && !!coerce('aspectratio.y') && !!coerce('aspectratio.z');
  var defaultAspectMode = hasAspect ? 'manual' : 'auto';
  var aspectMode = coerce('aspectmode', defaultAspectMode);

  /*
   * We need aspectratio object in all the Layouts as it is dynamically set
   * in the calculation steps, ie, we cant set the correct data now, it happens later.
   * We must also account for the case the user sends bad ratio data with 'manual' set
   * for the mode. In this case we must force change it here as the default coerce
   * misses it above.
   */
  if (!hasAspect) {
    sceneLayoutIn.aspectratio = sceneLayoutOut.aspectratio = {
      x: 1,
      y: 1,
      z: 1
    };
    if (aspectMode === 'manual') sceneLayoutOut.aspectmode = 'auto';

    /*
     * kind of like autorange - we need the calculated aspectmode back in
     * the input layout or relayout can cause problems later
     */
    sceneLayoutIn.aspectmode = sceneLayoutOut.aspectmode;
  }
  var fullGl3dData = getSubplotData(opts.fullData, GL3D, opts.id);
  supplyGl3dAxisLayoutDefaults(sceneLayoutIn, sceneLayoutOut, {
    font: opts.font,
    scene: opts.id,
    data: fullGl3dData,
    bgColor: bgColorCombined,
    calendar: opts.calendar,
    autotypenumbersDflt: opts.autotypenumbersDflt,
    fullLayout: opts.fullLayout
  });
  Registry.getComponentMethod('annotations3d', 'handleDefaults')(sceneLayoutIn, sceneLayoutOut, opts);
  var dragmode = opts.getDfltFromLayout('dragmode');
  if (dragmode !== false) {
    if (!dragmode) {
      dragmode = 'orbit';
      if (sceneLayoutIn.camera && sceneLayoutIn.camera.up) {
        var x = sceneLayoutIn.camera.up.x;
        var y = sceneLayoutIn.camera.up.y;
        var z = sceneLayoutIn.camera.up.z;
        if (z !== 0) {
          if (!x || !y || !z) {
            dragmode = 'turntable';
          } else if (z / Math.sqrt(x * x + y * y + z * z) > 0.999) {
            dragmode = 'turntable';
          }
        }
      } else {
        dragmode = 'turntable';
      }
    }
  }
  coerce('dragmode', dragmode);
  coerce('hovermode', opts.getDfltFromLayout('hovermode'));
}

/***/ }),

/***/ 5500:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var gl3dAxisAttrs = __webpack_require__(7894);
var domainAttrs = (__webpack_require__(7670)/* .attributes */ .Y);
var extendFlat = (__webpack_require__(1426).extendFlat);
var counterRegex = (__webpack_require__(1828).counterRegex);
function makeCameraVector(x, y, z) {
  return {
    x: {
      valType: 'number',
      dflt: x,
      editType: 'camera'
    },
    y: {
      valType: 'number',
      dflt: y,
      editType: 'camera'
    },
    z: {
      valType: 'number',
      dflt: z,
      editType: 'camera'
    },
    editType: 'camera'
  };
}
module.exports = {
  _arrayAttrRegexps: [counterRegex('scene', '.annotations', true)],
  bgcolor: {
    valType: 'color',
    dflt: 'rgba(0,0,0,0)',
    editType: 'plot'
  },
  camera: {
    up: extendFlat(makeCameraVector(0, 0, 1), {}),
    center: extendFlat(makeCameraVector(0, 0, 0), {}),
    eye: extendFlat(makeCameraVector(1.25, 1.25, 1.25), {}),
    projection: {
      type: {
        valType: 'enumerated',
        values: ['perspective', 'orthographic'],
        dflt: 'perspective',
        editType: 'calc'
      },
      editType: 'calc'
    },
    editType: 'camera'
  },
  domain: domainAttrs({
    name: 'scene',
    editType: 'plot'
  }),
  aspectmode: {
    valType: 'enumerated',
    values: ['auto', 'cube', 'data', 'manual'],
    dflt: 'auto',
    editType: 'plot',
    impliedEdits: {
      'aspectratio.x': undefined,
      'aspectratio.y': undefined,
      'aspectratio.z': undefined
    }
  },
  aspectratio: {
    // must be positive (0's are coerced to 1)
    x: {
      valType: 'number',
      min: 0,
      editType: 'plot',
      impliedEdits: {
        '^aspectmode': 'manual'
      }
    },
    y: {
      valType: 'number',
      min: 0,
      editType: 'plot',
      impliedEdits: {
        '^aspectmode': 'manual'
      }
    },
    z: {
      valType: 'number',
      min: 0,
      editType: 'plot',
      impliedEdits: {
        '^aspectmode': 'manual'
      }
    },
    editType: 'plot',
    impliedEdits: {
      aspectmode: 'manual'
    }
  },
  xaxis: gl3dAxisAttrs,
  yaxis: gl3dAxisAttrs,
  zaxis: gl3dAxisAttrs,
  dragmode: {
    valType: 'enumerated',
    values: ['orbit', 'turntable', 'zoom', 'pan', false],
    editType: 'plot'
  },
  hovermode: {
    valType: 'enumerated',
    values: ['closest', false],
    dflt: 'closest',
    editType: 'modebar'
  },
  uirevision: {
    valType: 'any',
    editType: 'none'
  },
  editType: 'plot',
  _deprecated: {
    cameraposition: {
      valType: 'info_array',
      editType: 'camera'
    }
  }
};

/***/ }),

/***/ 3133:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var str2RGBArray = __webpack_require__(8614);
var AXES_NAMES = ['xaxis', 'yaxis', 'zaxis'];
function SpikeOptions() {
  this.enabled = [true, true, true];
  this.colors = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];
  this.drawSides = [true, true, true];
  this.lineWidth = [1, 1, 1];
}
var proto = SpikeOptions.prototype;
proto.merge = function (sceneLayout) {
  for (var i = 0; i < 3; ++i) {
    var axes = sceneLayout[AXES_NAMES[i]];
    if (!axes.visible) {
      this.enabled[i] = false;
      this.drawSides[i] = false;
      continue;
    }
    this.enabled[i] = axes.showspikes;
    this.colors[i] = str2RGBArray(axes.spikecolor);
    this.drawSides[i] = axes.spikesides;
    this.lineWidth[i] = axes.spikethickness;
  }
};
function createSpikeOptions(layout) {
  var result = new SpikeOptions();
  result.merge(layout);
  return result;
}
module.exports = createSpikeOptions;

/***/ }),

/***/ 6085:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* eslint block-scoped-var: 0*/
/* eslint no-redeclare: 0*/



module.exports = computeTickMarks;
var Axes = __webpack_require__(9298);
var Lib = __webpack_require__(1828);
var AXES_NAMES = ['xaxis', 'yaxis', 'zaxis'];
var centerPoint = [0, 0, 0];
function contourLevelsFromTicks(ticks) {
  var result = new Array(3);
  for (var i = 0; i < 3; ++i) {
    var tlevel = ticks[i];
    var clevel = new Array(tlevel.length);
    for (var j = 0; j < tlevel.length; ++j) {
      clevel[j] = tlevel[j].x;
    }
    result[i] = clevel;
  }
  return result;
}
function computeTickMarks(scene) {
  var axesOptions = scene.axesOptions;
  var glRange = scene.glplot.axesPixels;
  var sceneLayout = scene.fullSceneLayout;
  var ticks = [[], [], []];
  for (var i = 0; i < 3; ++i) {
    var axes = sceneLayout[AXES_NAMES[i]];
    axes._length = (glRange[i].hi - glRange[i].lo) * glRange[i].pixelsPerDataUnit / scene.dataScale[i];
    if (Math.abs(axes._length) === Infinity || isNaN(axes._length)) {
      ticks[i] = [];
    } else {
      axes._input_range = axes.range.slice();
      axes.range[0] = glRange[i].lo / scene.dataScale[i];
      axes.range[1] = glRange[i].hi / scene.dataScale[i];
      axes._m = 1.0 / (scene.dataScale[i] * glRange[i].pixelsPerDataUnit);
      if (axes.range[0] === axes.range[1]) {
        axes.range[0] -= 1;
        axes.range[1] += 1;
      }
      // this is necessary to short-circuit the 'y' handling
      // in autotick part of calcTicks... Treating all axes as 'y' in this case
      // running the autoticks here, then setting
      // autoticks to false to get around the 2D handling in calcTicks.
      var tickModeCached = axes.tickmode;
      if (axes.tickmode === 'auto') {
        axes.tickmode = 'linear';
        var nticks = axes.nticks || Lib.constrain(axes._length / 40, 4, 9);
        Axes.autoTicks(axes, Math.abs(axes.range[1] - axes.range[0]) / nticks);
      }
      var dataTicks = Axes.calcTicks(axes, {
        msUTC: true
      });
      for (var j = 0; j < dataTicks.length; ++j) {
        dataTicks[j].x = dataTicks[j].x * scene.dataScale[i];
        if (axes.type === 'date') {
          dataTicks[j].text = dataTicks[j].text.replace(/\<br\>/g, ' ');
        }
      }
      ticks[i] = dataTicks;
      axes.tickmode = tickModeCached;
    }
  }
  axesOptions.ticks = ticks;

  // Calculate tick lengths dynamically
  for (var i = 0; i < 3; ++i) {
    centerPoint[i] = 0.5 * (scene.glplot.bounds[0][i] + scene.glplot.bounds[1][i]);
    for (var j = 0; j < 2; ++j) {
      axesOptions.bounds[j][i] = scene.glplot.bounds[j][i];
    }
  }
  scene.contourLevels = contourLevelsFromTicks(ticks);
}

/***/ }),

/***/ 3538:
/***/ (function(module) {

"use strict";


function xformMatrix(m, v) {
  var out = [0, 0, 0, 0];
  var i, j;
  for (i = 0; i < 4; ++i) {
    for (j = 0; j < 4; ++j) {
      out[j] += m[4 * i + j] * v[i];
    }
  }
  return out;
}
function project(camera, v) {
  var p = xformMatrix(camera.projection, xformMatrix(camera.view, xformMatrix(camera.model, [v[0], v[1], v[2], 1])));
  return p;
}
module.exports = project;

/***/ }),

/***/ 3539:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var glPlot3d = (__webpack_require__(9330).gl_plot3d);
var createCamera = glPlot3d.createCamera;
var createPlot = glPlot3d.createScene;
var getContext = __webpack_require__(372);
var passiveSupported = __webpack_require__(8520);
var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var preserveDrawingBuffer = Lib.preserveDrawingBuffer();
var Axes = __webpack_require__(9298);
var Fx = __webpack_require__(211);
var str2RGBAarray = __webpack_require__(8614);
var showNoWebGlMsg = __webpack_require__(8617);
var project = __webpack_require__(3538);
var createAxesOptions = __webpack_require__(422);
var createSpikeOptions = __webpack_require__(3133);
var computeTickMarks = __webpack_require__(6085);
var applyAutorangeOptions = (__webpack_require__(1739).applyAutorangeOptions);
var STATIC_CANVAS, STATIC_CONTEXT;
var tabletmode = false;
function Scene(options, fullLayout) {
  // create sub container for plot
  var sceneContainer = document.createElement('div');
  var plotContainer = options.container;

  // keep a ref to the graph div to fire hover+click events
  this.graphDiv = options.graphDiv;

  // create SVG container for hover text
  var svgContainer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svgContainer.style.position = 'absolute';
  svgContainer.style.top = svgContainer.style.left = '0px';
  svgContainer.style.width = svgContainer.style.height = '100%';
  svgContainer.style['z-index'] = 20;
  svgContainer.style['pointer-events'] = 'none';
  sceneContainer.appendChild(svgContainer);
  this.svgContainer = svgContainer;

  // Tag the container with the sceneID
  sceneContainer.id = options.id;
  sceneContainer.style.position = 'absolute';
  sceneContainer.style.top = sceneContainer.style.left = '0px';
  sceneContainer.style.width = sceneContainer.style.height = '100%';
  plotContainer.appendChild(sceneContainer);
  this.fullLayout = fullLayout;
  this.id = options.id || 'scene';
  this.fullSceneLayout = fullLayout[this.id];

  // Saved from last call to plot()
  this.plotArgs = [[], {}, {}];

  /*
   * Move this to calc step? Why does it work here?
   */
  this.axesOptions = createAxesOptions(fullLayout, fullLayout[this.id]);
  this.spikeOptions = createSpikeOptions(fullLayout[this.id]);
  this.container = sceneContainer;
  this.staticMode = !!options.staticPlot;
  this.pixelRatio = this.pixelRatio || options.plotGlPixelRatio || 2;

  // Coordinate rescaling
  this.dataScale = [1, 1, 1];
  this.contourLevels = [[], [], []];
  this.convertAnnotations = Registry.getComponentMethod('annotations3d', 'convert');
  this.drawAnnotations = Registry.getComponentMethod('annotations3d', 'draw');
  this.initializeGLPlot();
}
var proto = Scene.prototype;
proto.prepareOptions = function () {
  var scene = this;
  var opts = {
    canvas: scene.canvas,
    gl: scene.gl,
    glOptions: {
      preserveDrawingBuffer: preserveDrawingBuffer,
      premultipliedAlpha: true,
      antialias: true
    },
    container: scene.container,
    axes: scene.axesOptions,
    spikes: scene.spikeOptions,
    pickRadius: 10,
    snapToData: true,
    autoScale: true,
    autoBounds: false,
    cameraObject: scene.camera,
    pixelRatio: scene.pixelRatio
  };

  // for static plots, we reuse the WebGL context
  //  as WebKit doesn't collect them reliably
  if (scene.staticMode) {
    if (!STATIC_CONTEXT) {
      STATIC_CANVAS = document.createElement('canvas');
      STATIC_CONTEXT = getContext({
        canvas: STATIC_CANVAS,
        preserveDrawingBuffer: true,
        premultipliedAlpha: true,
        antialias: true
      });
      if (!STATIC_CONTEXT) {
        throw new Error('error creating static canvas/context for image server');
      }
    }
    opts.gl = STATIC_CONTEXT;
    opts.canvas = STATIC_CANVAS;
  }
  return opts;
};
var firstInit = true;
proto.tryCreatePlot = function () {
  var scene = this;
  var opts = scene.prepareOptions();
  var success = true;
  try {
    scene.glplot = createPlot(opts);
  } catch (e) {
    if (scene.staticMode || !firstInit || preserveDrawingBuffer) {
      success = false;
    } else {
      // try second time
      // enable preserveDrawingBuffer setup
      // in case is-mobile not detecting the right device
      Lib.warn(['webgl setup failed possibly due to', 'false preserveDrawingBuffer config.', 'The mobile/tablet device may not be detected by is-mobile module.', 'Enabling preserveDrawingBuffer in second attempt to create webgl scene...'].join(' '));
      try {
        // invert preserveDrawingBuffer
        preserveDrawingBuffer = opts.glOptions.preserveDrawingBuffer = true;
        scene.glplot = createPlot(opts);
      } catch (e) {
        // revert changes to preserveDrawingBuffer
        preserveDrawingBuffer = opts.glOptions.preserveDrawingBuffer = false;
        success = false;
      }
    }
  }
  firstInit = false;
  return success;
};
proto.initializeGLCamera = function () {
  var scene = this;
  var cameraData = scene.fullSceneLayout.camera;
  var isOrtho = cameraData.projection.type === 'orthographic';
  scene.camera = createCamera(scene.container, {
    center: [cameraData.center.x, cameraData.center.y, cameraData.center.z],
    eye: [cameraData.eye.x, cameraData.eye.y, cameraData.eye.z],
    up: [cameraData.up.x, cameraData.up.y, cameraData.up.z],
    _ortho: isOrtho,
    zoomMin: 0.01,
    zoomMax: 100,
    mode: 'orbit'
  });
};
proto.initializeGLPlot = function () {
  var scene = this;
  scene.initializeGLCamera();
  var success = scene.tryCreatePlot();
  /*
  * createPlot will throw when webgl is not enabled in the client.
  * Lets return an instance of the module with all functions noop'd.
  * The destroy method - which will remove the container from the DOM
  * is overridden with a function that removes the container only.
  */
  if (!success) return showNoWebGlMsg(scene);

  // List of scene objects
  scene.traces = {};
  scene.make4thDimension();
  var gd = scene.graphDiv;
  var layout = gd.layout;
  var makeUpdate = function () {
    var update = {};
    if (scene.isCameraChanged(layout)) {
      // camera updates
      update[scene.id + '.camera'] = scene.getCamera();
    }
    if (scene.isAspectChanged(layout)) {
      // scene updates
      update[scene.id + '.aspectratio'] = scene.glplot.getAspectratio();
      if (layout[scene.id].aspectmode !== 'manual') {
        scene.fullSceneLayout.aspectmode = layout[scene.id].aspectmode = update[scene.id + '.aspectmode'] = 'manual';
      }
    }
    return update;
  };
  var relayoutCallback = function (scene) {
    if (scene.fullSceneLayout.dragmode === false) return;
    var update = makeUpdate();
    scene.saveLayout(layout);
    scene.graphDiv.emit('plotly_relayout', update);
  };
  if (scene.glplot.canvas) {
    scene.glplot.canvas.addEventListener('mouseup', function () {
      relayoutCallback(scene);
    });
    scene.glplot.canvas.addEventListener('touchstart', function () {
      tabletmode = true;
    });
    scene.glplot.canvas.addEventListener('wheel', function (e) {
      if (gd._context._scrollZoom.gl3d) {
        if (scene.camera._ortho) {
          var s = e.deltaX > e.deltaY ? 1.1 : 1.0 / 1.1;
          var o = scene.glplot.getAspectratio();
          scene.glplot.setAspectratio({
            x: s * o.x,
            y: s * o.y,
            z: s * o.z
          });
        }
        relayoutCallback(scene);
      }
    }, passiveSupported ? {
      passive: false
    } : false);
    scene.glplot.canvas.addEventListener('mousemove', function () {
      if (scene.fullSceneLayout.dragmode === false) return;
      if (scene.camera.mouseListener.buttons === 0) return;
      var update = makeUpdate();
      scene.graphDiv.emit('plotly_relayouting', update);
    });
    if (!scene.staticMode) {
      scene.glplot.canvas.addEventListener('webglcontextlost', function (event) {
        if (gd && gd.emit) {
          gd.emit('plotly_webglcontextlost', {
            event: event,
            layer: scene.id
          });
        }
      }, false);
    }
  }
  scene.glplot.oncontextloss = function () {
    scene.recoverContext();
  };
  scene.glplot.onrender = function () {
    scene.render();
  };
  return true;
};
proto.render = function () {
  var scene = this;
  var gd = scene.graphDiv;
  var trace;

  // update size of svg container
  var svgContainer = scene.svgContainer;
  var clientRect = scene.container.getBoundingClientRect();
  gd._fullLayout._calcInverseTransform(gd);
  var scaleX = gd._fullLayout._invScaleX;
  var scaleY = gd._fullLayout._invScaleY;
  var width = clientRect.width * scaleX;
  var height = clientRect.height * scaleY;
  svgContainer.setAttributeNS(null, 'viewBox', '0 0 ' + width + ' ' + height);
  svgContainer.setAttributeNS(null, 'width', width);
  svgContainer.setAttributeNS(null, 'height', height);
  computeTickMarks(scene);
  scene.glplot.axes.update(scene.axesOptions);

  // check if pick has changed
  var keys = Object.keys(scene.traces);
  var lastPicked = null;
  var selection = scene.glplot.selection;
  for (var i = 0; i < keys.length; ++i) {
    trace = scene.traces[keys[i]];
    if (trace.data.hoverinfo !== 'skip' && trace.handlePick(selection)) {
      lastPicked = trace;
    }
    if (trace.setContourLevels) trace.setContourLevels();
  }
  function formatter(axLetter, val, hoverformat) {
    var ax = scene.fullSceneLayout[axLetter + 'axis'];
    if (ax.type !== 'log') {
      val = ax.d2l(val);
    }
    return Axes.hoverLabelText(ax, val, hoverformat);
  }
  if (lastPicked !== null) {
    var pdata = project(scene.glplot.cameraParams, selection.dataCoordinate);
    trace = lastPicked.data;
    var traceNow = gd._fullData[trace.index];
    var ptNumber = selection.index;
    var labels = {
      xLabel: formatter('x', selection.traceCoordinate[0], trace.xhoverformat),
      yLabel: formatter('y', selection.traceCoordinate[1], trace.yhoverformat),
      zLabel: formatter('z', selection.traceCoordinate[2], trace.zhoverformat)
    };
    var hoverinfo = Fx.castHoverinfo(traceNow, scene.fullLayout, ptNumber);
    var hoverinfoParts = (hoverinfo || '').split('+');
    var isHoverinfoAll = hoverinfo && hoverinfo === 'all';
    if (!traceNow.hovertemplate && !isHoverinfoAll) {
      if (hoverinfoParts.indexOf('x') === -1) labels.xLabel = undefined;
      if (hoverinfoParts.indexOf('y') === -1) labels.yLabel = undefined;
      if (hoverinfoParts.indexOf('z') === -1) labels.zLabel = undefined;
      if (hoverinfoParts.indexOf('text') === -1) selection.textLabel = undefined;
      if (hoverinfoParts.indexOf('name') === -1) lastPicked.name = undefined;
    }
    var tx;
    var vectorTx = [];
    if (trace.type === 'cone' || trace.type === 'streamtube') {
      labels.uLabel = formatter('x', selection.traceCoordinate[3], trace.uhoverformat);
      if (isHoverinfoAll || hoverinfoParts.indexOf('u') !== -1) {
        vectorTx.push('u: ' + labels.uLabel);
      }
      labels.vLabel = formatter('y', selection.traceCoordinate[4], trace.vhoverformat);
      if (isHoverinfoAll || hoverinfoParts.indexOf('v') !== -1) {
        vectorTx.push('v: ' + labels.vLabel);
      }
      labels.wLabel = formatter('z', selection.traceCoordinate[5], trace.whoverformat);
      if (isHoverinfoAll || hoverinfoParts.indexOf('w') !== -1) {
        vectorTx.push('w: ' + labels.wLabel);
      }
      labels.normLabel = selection.traceCoordinate[6].toPrecision(3);
      if (isHoverinfoAll || hoverinfoParts.indexOf('norm') !== -1) {
        vectorTx.push('norm: ' + labels.normLabel);
      }
      if (trace.type === 'streamtube') {
        labels.divergenceLabel = selection.traceCoordinate[7].toPrecision(3);
        if (isHoverinfoAll || hoverinfoParts.indexOf('divergence') !== -1) {
          vectorTx.push('divergence: ' + labels.divergenceLabel);
        }
      }
      if (selection.textLabel) {
        vectorTx.push(selection.textLabel);
      }
      tx = vectorTx.join('<br>');
    } else if (trace.type === 'isosurface' || trace.type === 'volume') {
      labels.valueLabel = Axes.hoverLabelText(scene._mockAxis, scene._mockAxis.d2l(selection.traceCoordinate[3]), trace.valuehoverformat);
      vectorTx.push('value: ' + labels.valueLabel);
      if (selection.textLabel) {
        vectorTx.push(selection.textLabel);
      }
      tx = vectorTx.join('<br>');
    } else {
      tx = selection.textLabel;
    }
    var pointData = {
      x: selection.traceCoordinate[0],
      y: selection.traceCoordinate[1],
      z: selection.traceCoordinate[2],
      data: traceNow._input,
      fullData: traceNow,
      curveNumber: traceNow.index,
      pointNumber: ptNumber
    };
    Fx.appendArrayPointValue(pointData, traceNow, ptNumber);
    if (trace._module.eventData) {
      pointData = traceNow._module.eventData(pointData, selection, traceNow, {}, ptNumber);
    }
    var eventData = {
      points: [pointData]
    };
    if (scene.fullSceneLayout.hovermode) {
      var bbox = [];
      Fx.loneHover({
        trace: traceNow,
        x: (0.5 + 0.5 * pdata[0] / pdata[3]) * width,
        y: (0.5 - 0.5 * pdata[1] / pdata[3]) * height,
        xLabel: labels.xLabel,
        yLabel: labels.yLabel,
        zLabel: labels.zLabel,
        text: tx,
        name: lastPicked.name,
        color: Fx.castHoverOption(traceNow, ptNumber, 'bgcolor') || lastPicked.color,
        borderColor: Fx.castHoverOption(traceNow, ptNumber, 'bordercolor'),
        fontFamily: Fx.castHoverOption(traceNow, ptNumber, 'font.family'),
        fontSize: Fx.castHoverOption(traceNow, ptNumber, 'font.size'),
        fontColor: Fx.castHoverOption(traceNow, ptNumber, 'font.color'),
        nameLength: Fx.castHoverOption(traceNow, ptNumber, 'namelength'),
        textAlign: Fx.castHoverOption(traceNow, ptNumber, 'align'),
        hovertemplate: Lib.castOption(traceNow, ptNumber, 'hovertemplate'),
        hovertemplateLabels: Lib.extendFlat({}, pointData, labels),
        eventData: [pointData]
      }, {
        container: svgContainer,
        gd: gd,
        inOut_bbox: bbox
      });
      pointData.bbox = bbox[0];
    }
    if (selection.distance < 5 && (selection.buttons || tabletmode)) {
      gd.emit('plotly_click', eventData);
    } else {
      gd.emit('plotly_hover', eventData);
    }
    this.oldEventData = eventData;
  } else {
    Fx.loneUnhover(svgContainer);
    if (this.oldEventData) gd.emit('plotly_unhover', this.oldEventData);
    this.oldEventData = undefined;
  }
  scene.drawAnnotations(scene);
};
proto.recoverContext = function () {
  var scene = this;
  scene.glplot.dispose();
  var tryRecover = function () {
    if (scene.glplot.gl.isContextLost()) {
      requestAnimationFrame(tryRecover);
      return;
    }
    if (!scene.initializeGLPlot()) {
      Lib.error('Catastrophic and unrecoverable WebGL error. Context lost.');
      return;
    }
    scene.plot.apply(scene, scene.plotArgs);
  };
  requestAnimationFrame(tryRecover);
};
var axisProperties = ['xaxis', 'yaxis', 'zaxis'];
function computeTraceBounds(scene, trace, bounds) {
  var fullSceneLayout = scene.fullSceneLayout;
  for (var d = 0; d < 3; d++) {
    var axisName = axisProperties[d];
    var axLetter = axisName.charAt(0);
    var ax = fullSceneLayout[axisName];
    var coords = trace[axLetter];
    var calendar = trace[axLetter + 'calendar'];
    var len = trace['_' + axLetter + 'length'];
    if (!Lib.isArrayOrTypedArray(coords)) {
      bounds[0][d] = Math.min(bounds[0][d], 0);
      bounds[1][d] = Math.max(bounds[1][d], len - 1);
    } else {
      var v;
      for (var i = 0; i < (len || coords.length); i++) {
        if (Lib.isArrayOrTypedArray(coords[i])) {
          for (var j = 0; j < coords[i].length; ++j) {
            v = ax.d2l(coords[i][j], 0, calendar);
            if (!isNaN(v) && isFinite(v)) {
              bounds[0][d] = Math.min(bounds[0][d], v);
              bounds[1][d] = Math.max(bounds[1][d], v);
            }
          }
        } else {
          v = ax.d2l(coords[i], 0, calendar);
          if (!isNaN(v) && isFinite(v)) {
            bounds[0][d] = Math.min(bounds[0][d], v);
            bounds[1][d] = Math.max(bounds[1][d], v);
          }
        }
      }
    }
  }
}
function computeAnnotationBounds(scene, bounds) {
  var fullSceneLayout = scene.fullSceneLayout;
  var annotations = fullSceneLayout.annotations || [];
  for (var d = 0; d < 3; d++) {
    var axisName = axisProperties[d];
    var axLetter = axisName.charAt(0);
    var ax = fullSceneLayout[axisName];
    for (var j = 0; j < annotations.length; j++) {
      var ann = annotations[j];
      if (ann.visible) {
        var pos = ax.r2l(ann[axLetter]);
        if (!isNaN(pos) && isFinite(pos)) {
          bounds[0][d] = Math.min(bounds[0][d], pos);
          bounds[1][d] = Math.max(bounds[1][d], pos);
        }
      }
    }
  }
}
proto.plot = function (sceneData, fullLayout, layout) {
  var scene = this;

  // Save parameters
  scene.plotArgs = [sceneData, fullLayout, layout];
  if (scene.glplot.contextLost) return;
  var data, trace;
  var i, j, axis, axisType;
  var fullSceneLayout = fullLayout[scene.id];
  var sceneLayout = layout[scene.id];

  // Update layout
  scene.fullLayout = fullLayout;
  scene.fullSceneLayout = fullSceneLayout;
  scene.axesOptions.merge(fullLayout, fullSceneLayout);
  scene.spikeOptions.merge(fullSceneLayout);

  // Update camera and camera mode
  scene.setViewport(fullSceneLayout);
  scene.updateFx(fullSceneLayout.dragmode, fullSceneLayout.hovermode);
  scene.camera.enableWheel = scene.graphDiv._context._scrollZoom.gl3d;

  // Update scene background
  scene.glplot.setClearColor(str2RGBAarray(fullSceneLayout.bgcolor));

  // Update axes functions BEFORE updating traces
  scene.setConvert(axis);

  // Convert scene data
  if (!sceneData) sceneData = [];else if (!Array.isArray(sceneData)) sceneData = [sceneData];

  // Compute trace bounding box
  var dataBounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];
  for (i = 0; i < sceneData.length; ++i) {
    data = sceneData[i];
    if (data.visible !== true || data._length === 0) continue;
    computeTraceBounds(this, data, dataBounds);
  }
  computeAnnotationBounds(this, dataBounds);
  var dataScale = [1, 1, 1];
  for (j = 0; j < 3; ++j) {
    if (dataBounds[1][j] === dataBounds[0][j]) {
      dataScale[j] = 1.0;
    } else {
      dataScale[j] = 1.0 / (dataBounds[1][j] - dataBounds[0][j]);
    }
  }

  // Save scale
  scene.dataScale = dataScale;

  // after computeTraceBounds where ax._categories are filled in
  scene.convertAnnotations(this);

  // Update traces
  for (i = 0; i < sceneData.length; ++i) {
    data = sceneData[i];
    if (data.visible !== true || data._length === 0) {
      continue;
    }
    trace = scene.traces[data.uid];
    if (trace) {
      if (trace.data.type === data.type) {
        trace.update(data);
      } else {
        trace.dispose();
        trace = data._module.plot(this, data);
        scene.traces[data.uid] = trace;
      }
    } else {
      trace = data._module.plot(this, data);
      scene.traces[data.uid] = trace;
    }
    trace.name = data.name;
  }

  // Remove empty traces
  var traceIds = Object.keys(scene.traces);
  traceIdLoop: for (i = 0; i < traceIds.length; ++i) {
    for (j = 0; j < sceneData.length; ++j) {
      if (sceneData[j].uid === traceIds[i] && sceneData[j].visible === true && sceneData[j]._length !== 0) {
        continue traceIdLoop;
      }
    }
    trace = scene.traces[traceIds[i]];
    trace.dispose();
    delete scene.traces[traceIds[i]];
  }

  // order object per trace index
  scene.glplot.objects.sort(function (a, b) {
    return a._trace.data.index - b._trace.data.index;
  });

  // Update ranges (needs to be called *after* objects are added due to updates)
  var sceneBounds = [[0, 0, 0], [0, 0, 0]];
  var axisDataRange = [];
  var axisTypeRatios = {};
  for (i = 0; i < 3; ++i) {
    axis = fullSceneLayout[axisProperties[i]];
    axisType = axis.type;
    if (axisType in axisTypeRatios) {
      axisTypeRatios[axisType].acc *= dataScale[i];
      axisTypeRatios[axisType].count += 1;
    } else {
      axisTypeRatios[axisType] = {
        acc: dataScale[i],
        count: 1
      };
    }
    var range;
    if (axis.autorange) {
      sceneBounds[0][i] = Infinity;
      sceneBounds[1][i] = -Infinity;
      var objects = scene.glplot.objects;
      var annotations = scene.fullSceneLayout.annotations || [];
      var axLetter = axis._name.charAt(0);
      for (j = 0; j < objects.length; j++) {
        var obj = objects[j];
        var objBounds = obj.bounds;
        var pad = obj._trace.data._pad || 0;
        if (obj.constructor.name === 'ErrorBars' && axis._lowerLogErrorBound) {
          sceneBounds[0][i] = Math.min(sceneBounds[0][i], axis._lowerLogErrorBound);
        } else {
          sceneBounds[0][i] = Math.min(sceneBounds[0][i], objBounds[0][i] / dataScale[i] - pad);
        }
        sceneBounds[1][i] = Math.max(sceneBounds[1][i], objBounds[1][i] / dataScale[i] + pad);
      }
      for (j = 0; j < annotations.length; j++) {
        var ann = annotations[j];

        // N.B. not taking into consideration the arrowhead
        if (ann.visible) {
          var pos = axis.r2l(ann[axLetter]);
          sceneBounds[0][i] = Math.min(sceneBounds[0][i], pos);
          sceneBounds[1][i] = Math.max(sceneBounds[1][i], pos);
        }
      }
      if ('rangemode' in axis && axis.rangemode === 'tozero') {
        sceneBounds[0][i] = Math.min(sceneBounds[0][i], 0);
        sceneBounds[1][i] = Math.max(sceneBounds[1][i], 0);
      }
      if (sceneBounds[0][i] > sceneBounds[1][i]) {
        sceneBounds[0][i] = -1;
        sceneBounds[1][i] = 1;
      } else {
        var d = sceneBounds[1][i] - sceneBounds[0][i];
        sceneBounds[0][i] -= d / 32.0;
        sceneBounds[1][i] += d / 32.0;
      }
      range = [sceneBounds[0][i], sceneBounds[1][i]];
      range = applyAutorangeOptions(range, axis);
      sceneBounds[0][i] = range[0];
      sceneBounds[1][i] = range[1];
      if (axis.isReversed()) {
        // swap bounds:
        var tmp = sceneBounds[0][i];
        sceneBounds[0][i] = sceneBounds[1][i];
        sceneBounds[1][i] = tmp;
      }
    } else {
      range = axis.range;
      sceneBounds[0][i] = axis.r2l(range[0]);
      sceneBounds[1][i] = axis.r2l(range[1]);
    }
    if (sceneBounds[0][i] === sceneBounds[1][i]) {
      sceneBounds[0][i] -= 1;
      sceneBounds[1][i] += 1;
    }
    axisDataRange[i] = sceneBounds[1][i] - sceneBounds[0][i];
    axis.range = [sceneBounds[0][i], sceneBounds[1][i]];
    axis.limitRange();

    // Update plot bounds
    scene.glplot.setBounds(i, {
      min: axis.range[0] * dataScale[i],
      max: axis.range[1] * dataScale[i]
    });
  }

  /*
   * Dynamically set the aspect ratio depending on the users aspect settings
   */
  var aspectRatio;
  var aspectmode = fullSceneLayout.aspectmode;
  if (aspectmode === 'cube') {
    aspectRatio = [1, 1, 1];
  } else if (aspectmode === 'manual') {
    var userRatio = fullSceneLayout.aspectratio;
    aspectRatio = [userRatio.x, userRatio.y, userRatio.z];
  } else if (aspectmode === 'auto' || aspectmode === 'data') {
    var axesScaleRatio = [1, 1, 1];
    // Compute axis scale per category
    for (i = 0; i < 3; ++i) {
      axis = fullSceneLayout[axisProperties[i]];
      axisType = axis.type;
      var axisRatio = axisTypeRatios[axisType];
      axesScaleRatio[i] = Math.pow(axisRatio.acc, 1.0 / axisRatio.count) / dataScale[i];
    }
    if (aspectmode === 'data') {
      aspectRatio = axesScaleRatio;
    } else {
      // i.e. 'auto' option
      if (Math.max.apply(null, axesScaleRatio) / Math.min.apply(null, axesScaleRatio) <= 4) {
        // USE DATA MODE WHEN AXIS RANGE DIMENSIONS ARE RELATIVELY EQUAL
        aspectRatio = axesScaleRatio;
      } else {
        // USE EQUAL MODE WHEN AXIS RANGE DIMENSIONS ARE HIGHLY UNEQUAL
        aspectRatio = [1, 1, 1];
      }
    }
  } else {
    throw new Error('scene.js aspectRatio was not one of the enumerated types');
  }

  /*
   * Write aspect Ratio back to user data and fullLayout so that it is modifies as user
   * manipulates the aspectmode settings and the fullLayout is up-to-date.
   */
  fullSceneLayout.aspectratio.x = sceneLayout.aspectratio.x = aspectRatio[0];
  fullSceneLayout.aspectratio.y = sceneLayout.aspectratio.y = aspectRatio[1];
  fullSceneLayout.aspectratio.z = sceneLayout.aspectratio.z = aspectRatio[2];

  /*
   * Finally assign the computed aspecratio to the glplot module. This will have an effect
   * on the next render cycle.
   */
  scene.glplot.setAspectratio(fullSceneLayout.aspectratio);

  // save 'initial' aspectratio & aspectmode view settings for modebar buttons
  if (!scene.viewInitial.aspectratio) {
    scene.viewInitial.aspectratio = {
      x: fullSceneLayout.aspectratio.x,
      y: fullSceneLayout.aspectratio.y,
      z: fullSceneLayout.aspectratio.z
    };
  }
  if (!scene.viewInitial.aspectmode) {
    scene.viewInitial.aspectmode = fullSceneLayout.aspectmode;
  }

  // Update frame position for multi plots
  var domain = fullSceneLayout.domain || null;
  var size = fullLayout._size || null;
  if (domain && size) {
    var containerStyle = scene.container.style;
    containerStyle.position = 'absolute';
    containerStyle.left = size.l + domain.x[0] * size.w + 'px';
    containerStyle.top = size.t + (1 - domain.y[1]) * size.h + 'px';
    containerStyle.width = size.w * (domain.x[1] - domain.x[0]) + 'px';
    containerStyle.height = size.h * (domain.y[1] - domain.y[0]) + 'px';
  }

  // force redraw so that promise is returned when rendering is completed
  scene.glplot.redraw();
};
proto.destroy = function () {
  var scene = this;
  if (!scene.glplot) return;
  scene.camera.mouseListener.enabled = false;
  scene.container.removeEventListener('wheel', scene.camera.wheelListener);
  scene.camera = null;
  scene.glplot.dispose();
  scene.container.parentNode.removeChild(scene.container);
  scene.glplot = null;
};

// getCameraArrays :: plotly_coords -> gl-plot3d_coords
// inverse of getLayoutCamera
function getCameraArrays(camera) {
  return [[camera.eye.x, camera.eye.y, camera.eye.z], [camera.center.x, camera.center.y, camera.center.z], [camera.up.x, camera.up.y, camera.up.z]];
}

// getLayoutCamera :: gl-plot3d_coords -> plotly_coords
// inverse of getCameraArrays
function getLayoutCamera(camera) {
  return {
    up: {
      x: camera.up[0],
      y: camera.up[1],
      z: camera.up[2]
    },
    center: {
      x: camera.center[0],
      y: camera.center[1],
      z: camera.center[2]
    },
    eye: {
      x: camera.eye[0],
      y: camera.eye[1],
      z: camera.eye[2]
    },
    projection: {
      type: camera._ortho === true ? 'orthographic' : 'perspective'
    }
  };
}

// get camera position in plotly coords from 'gl-plot3d' coords
proto.getCamera = function () {
  var scene = this;
  scene.camera.view.recalcMatrix(scene.camera.view.lastT());
  return getLayoutCamera(scene.camera);
};

// set gl-plot3d camera position and scene aspects with a set of plotly coords
proto.setViewport = function (sceneLayout) {
  var scene = this;
  var cameraData = sceneLayout.camera;
  scene.camera.lookAt.apply(this, getCameraArrays(cameraData));
  scene.glplot.setAspectratio(sceneLayout.aspectratio);
  var newOrtho = cameraData.projection.type === 'orthographic';
  var oldOrtho = scene.camera._ortho;
  if (newOrtho !== oldOrtho) {
    scene.glplot.redraw(); // TODO: figure out why we need to redraw here?
    scene.glplot.clearRGBA();
    scene.glplot.dispose();
    scene.initializeGLPlot();
  }
};
proto.isCameraChanged = function (layout) {
  var scene = this;
  var cameraData = scene.getCamera();
  var cameraNestedProp = Lib.nestedProperty(layout, scene.id + '.camera');
  var cameraDataLastSave = cameraNestedProp.get();
  function same(x, y, i, j) {
    var vectors = ['up', 'center', 'eye'];
    var components = ['x', 'y', 'z'];
    return y[vectors[i]] && x[vectors[i]][components[j]] === y[vectors[i]][components[j]];
  }
  var changed = false;
  if (cameraDataLastSave === undefined) {
    changed = true;
  } else {
    for (var i = 0; i < 3; i++) {
      for (var j = 0; j < 3; j++) {
        if (!same(cameraData, cameraDataLastSave, i, j)) {
          changed = true;
          break;
        }
      }
    }
    if (!cameraDataLastSave.projection || cameraData.projection && cameraData.projection.type !== cameraDataLastSave.projection.type) {
      changed = true;
    }
  }
  return changed;
};
proto.isAspectChanged = function (layout) {
  var scene = this;
  var aspectData = scene.glplot.getAspectratio();
  var aspectNestedProp = Lib.nestedProperty(layout, scene.id + '.aspectratio');
  var aspectDataLastSave = aspectNestedProp.get();
  return aspectDataLastSave === undefined || aspectDataLastSave.x !== aspectData.x || aspectDataLastSave.y !== aspectData.y || aspectDataLastSave.z !== aspectData.z;
};

// save camera to user layout (i.e. gd.layout)
proto.saveLayout = function (layout) {
  var scene = this;
  var fullLayout = scene.fullLayout;
  var cameraData;
  var cameraNestedProp;
  var cameraDataLastSave;
  var aspectData;
  var aspectNestedProp;
  var aspectDataLastSave;
  var cameraChanged = scene.isCameraChanged(layout);
  var aspectChanged = scene.isAspectChanged(layout);
  var hasChanged = cameraChanged || aspectChanged;
  if (hasChanged) {
    var preGUI = {};
    if (cameraChanged) {
      cameraData = scene.getCamera();
      cameraNestedProp = Lib.nestedProperty(layout, scene.id + '.camera');
      cameraDataLastSave = cameraNestedProp.get();
      preGUI[scene.id + '.camera'] = cameraDataLastSave;
    }
    if (aspectChanged) {
      aspectData = scene.glplot.getAspectratio();
      aspectNestedProp = Lib.nestedProperty(layout, scene.id + '.aspectratio');
      aspectDataLastSave = aspectNestedProp.get();
      preGUI[scene.id + '.aspectratio'] = aspectDataLastSave;
    }
    Registry.call('_storeDirectGUIEdit', layout, fullLayout._preGUI, preGUI);
    if (cameraChanged) {
      cameraNestedProp.set(cameraData);
      var cameraFullNP = Lib.nestedProperty(fullLayout, scene.id + '.camera');
      cameraFullNP.set(cameraData);
    }
    if (aspectChanged) {
      aspectNestedProp.set(aspectData);
      var aspectFullNP = Lib.nestedProperty(fullLayout, scene.id + '.aspectratio');
      aspectFullNP.set(aspectData);
      scene.glplot.redraw();
    }
  }
  return hasChanged;
};
proto.updateFx = function (dragmode, hovermode) {
  var scene = this;
  var camera = scene.camera;
  if (camera) {
    // rotate and orbital are synonymous
    if (dragmode === 'orbit') {
      camera.mode = 'orbit';
      camera.keyBindingMode = 'rotate';
    } else if (dragmode === 'turntable') {
      camera.up = [0, 0, 1];
      camera.mode = 'turntable';
      camera.keyBindingMode = 'rotate';

      // The setter for camera.mode animates the transition to z-up,
      // but only if we *don't* explicitly set z-up earlier via the
      // relayout. So push `up` back to layout & fullLayout manually now.
      var gd = scene.graphDiv;
      var fullLayout = gd._fullLayout;
      var fullCamera = scene.fullSceneLayout.camera;
      var x = fullCamera.up.x;
      var y = fullCamera.up.y;
      var z = fullCamera.up.z;
      // only push `up` back to (full)layout if it's going to change
      if (z / Math.sqrt(x * x + y * y + z * z) < 0.999) {
        var attr = scene.id + '.camera.up';
        var zUp = {
          x: 0,
          y: 0,
          z: 1
        };
        var edits = {};
        edits[attr] = zUp;
        var layout = gd.layout;
        Registry.call('_storeDirectGUIEdit', layout, fullLayout._preGUI, edits);
        fullCamera.up = zUp;
        Lib.nestedProperty(layout, attr).set(zUp);
      }
    } else {
      // none rotation modes [pan or zoom]
      camera.keyBindingMode = dragmode;
    }
  }

  // to put dragmode and hovermode on the same grounds from relayout
  scene.fullSceneLayout.hovermode = hovermode;
};
function flipPixels(pixels, w, h) {
  for (var i = 0, q = h - 1; i < q; ++i, --q) {
    for (var j = 0; j < w; ++j) {
      for (var k = 0; k < 4; ++k) {
        var a = 4 * (w * i + j) + k;
        var b = 4 * (w * q + j) + k;
        var tmp = pixels[a];
        pixels[a] = pixels[b];
        pixels[b] = tmp;
      }
    }
  }
}
function correctRGB(pixels, w, h) {
  for (var i = 0; i < h; ++i) {
    for (var j = 0; j < w; ++j) {
      var k = 4 * (w * i + j);
      var a = pixels[k + 3]; // alpha
      if (a > 0) {
        var q = 255 / a;
        for (var l = 0; l < 3; ++l) {
          // RGB
          pixels[k + l] = Math.min(q * pixels[k + l], 255);
        }
      }
    }
  }
}
proto.toImage = function (format) {
  var scene = this;
  if (!format) format = 'png';
  if (scene.staticMode) scene.container.appendChild(STATIC_CANVAS);

  // Force redraw
  scene.glplot.redraw();

  // Grab context and yank out pixels
  var gl = scene.glplot.gl;
  var w = gl.drawingBufferWidth;
  var h = gl.drawingBufferHeight;
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  var pixels = new Uint8Array(w * h * 4);
  gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  flipPixels(pixels, w, h);
  correctRGB(pixels, w, h);
  var canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  var context = canvas.getContext('2d', {
    willReadFrequently: true
  });
  var imageData = context.createImageData(w, h);
  imageData.data.set(pixels);
  context.putImageData(imageData, 0, 0);
  var dataURL;
  switch (format) {
    case 'jpeg':
      dataURL = canvas.toDataURL('image/jpeg');
      break;
    case 'webp':
      dataURL = canvas.toDataURL('image/webp');
      break;
    default:
      dataURL = canvas.toDataURL('image/png');
  }
  if (scene.staticMode) scene.container.removeChild(STATIC_CANVAS);
  return dataURL;
};
proto.setConvert = function () {
  var scene = this;
  for (var i = 0; i < 3; i++) {
    var ax = scene.fullSceneLayout[axisProperties[i]];
    Axes.setConvert(ax, scene.fullLayout);
    ax.setScale = Lib.noop;
  }
};
proto.make4thDimension = function () {
  var scene = this;
  var gd = scene.graphDiv;
  var fullLayout = gd._fullLayout;

  // mock axis for hover formatting
  scene._mockAxis = {
    type: 'linear',
    showexponent: 'all',
    exponentformat: 'B'
  };
  Axes.setConvert(scene._mockAxis, fullLayout);
};
module.exports = Scene;

/***/ }),

/***/ 60:
/***/ (function(module) {

"use strict";


module.exports = function zip3(x, y, z, len) {
  len = len || x.length;
  var result = new Array(len);
  for (var i = 0; i < len; i++) {
    result[i] = [x[i], y[i], z[i]];
  }
  return result;
};

/***/ }),

/***/ 820:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var fontAttrs = __webpack_require__(1940);
var animationAttrs = __webpack_require__(5594);
var colorAttrs = __webpack_require__(2399);
var drawNewShapeAttrs = __webpack_require__(9241);
var drawNewSelectionAttrs = __webpack_require__(3777);
var padAttrs = __webpack_require__(5025);
var extendFlat = (__webpack_require__(1426).extendFlat);
var globalFont = fontAttrs({
  editType: 'calc'
});
globalFont.family.dflt = '"Open Sans", verdana, arial, sans-serif';
globalFont.size.dflt = 12;
globalFont.color.dflt = colorAttrs.defaultLine;
module.exports = {
  font: globalFont,
  title: {
    text: {
      valType: 'string',
      editType: 'layoutstyle'
    },
    font: fontAttrs({
      editType: 'layoutstyle'
    }),
    xref: {
      valType: 'enumerated',
      dflt: 'container',
      values: ['container', 'paper'],
      editType: 'layoutstyle'
    },
    yref: {
      valType: 'enumerated',
      dflt: 'container',
      values: ['container', 'paper'],
      editType: 'layoutstyle'
    },
    x: {
      valType: 'number',
      min: 0,
      max: 1,
      dflt: 0.5,
      editType: 'layoutstyle'
    },
    y: {
      valType: 'number',
      min: 0,
      max: 1,
      dflt: 'auto',
      editType: 'layoutstyle'
    },
    xanchor: {
      valType: 'enumerated',
      dflt: 'auto',
      values: ['auto', 'left', 'center', 'right'],
      editType: 'layoutstyle'
    },
    yanchor: {
      valType: 'enumerated',
      dflt: 'auto',
      values: ['auto', 'top', 'middle', 'bottom'],
      editType: 'layoutstyle'
    },
    pad: extendFlat(padAttrs({
      editType: 'layoutstyle'
    }), {}),
    automargin: {
      valType: 'boolean',
      dflt: false,
      editType: 'plot'
    },
    editType: 'layoutstyle'
  },
  uniformtext: {
    mode: {
      valType: 'enumerated',
      values: [false, 'hide', 'show'],
      dflt: false,
      editType: 'plot'
    },
    minsize: {
      valType: 'number',
      min: 0,
      dflt: 0,
      editType: 'plot'
    },
    editType: 'plot'
  },
  autosize: {
    valType: 'boolean',
    dflt: false,
    // autosize, width, and height get special editType treatment in _relayout
    // so we can handle noop resizes more efficiently
    editType: 'none'
  },
  width: {
    valType: 'number',
    min: 10,
    dflt: 700,
    editType: 'plot'
  },
  height: {
    valType: 'number',
    min: 10,
    dflt: 450,
    editType: 'plot'
  },
  minreducedwidth: {
    valType: 'number',
    min: 2,
    dflt: 64,
    editType: 'plot'
  },
  minreducedheight: {
    valType: 'number',
    min: 2,
    dflt: 64,
    editType: 'plot'
  },
  margin: {
    l: {
      valType: 'number',
      min: 0,
      dflt: 80,
      editType: 'plot'
    },
    r: {
      valType: 'number',
      min: 0,
      dflt: 80,
      editType: 'plot'
    },
    t: {
      valType: 'number',
      min: 0,
      dflt: 100,
      editType: 'plot'
    },
    b: {
      valType: 'number',
      min: 0,
      dflt: 80,
      editType: 'plot'
    },
    pad: {
      valType: 'number',
      min: 0,
      dflt: 0,
      editType: 'plot'
    },
    autoexpand: {
      valType: 'boolean',
      dflt: true,
      editType: 'plot'
    },
    editType: 'plot'
  },
  computed: {
    valType: 'any',
    editType: 'none'
  },
  paper_bgcolor: {
    valType: 'color',
    dflt: colorAttrs.background,
    editType: 'plot'
  },
  plot_bgcolor: {
    // defined here, but set in cartesian.supplyLayoutDefaults
    // because it needs to know if there are (2D) axes or not
    valType: 'color',
    dflt: colorAttrs.background,
    editType: 'layoutstyle'
  },
  autotypenumbers: {
    valType: 'enumerated',
    values: ['convert types', 'strict'],
    dflt: 'convert types',
    editType: 'calc'
  },
  separators: {
    valType: 'string',
    editType: 'plot'
  },
  hidesources: {
    valType: 'boolean',
    dflt: false,
    editType: 'plot'
  },
  showlegend: {
    // handled in legend.supplyLayoutDefaults
    // but included here because it's not in the legend object
    valType: 'boolean',
    editType: 'legend'
  },
  colorway: {
    valType: 'colorlist',
    dflt: colorAttrs.defaults,
    editType: 'calc'
  },
  datarevision: {
    valType: 'any',
    editType: 'calc'
  },
  uirevision: {
    valType: 'any',
    editType: 'none'
  },
  editrevision: {
    valType: 'any',
    editType: 'none'
  },
  selectionrevision: {
    valType: 'any',
    editType: 'none'
  },
  template: {
    valType: 'any',
    editType: 'calc'
  },
  newshape: drawNewShapeAttrs.newshape,
  activeshape: drawNewShapeAttrs.activeshape,
  newselection: drawNewSelectionAttrs.newselection,
  activeselection: drawNewSelectionAttrs.activeselection,
  meta: {
    valType: 'any',
    arrayOk: true,
    editType: 'plot'
  },
  transition: extendFlat({}, animationAttrs.transition, {
    editType: 'none'
  }),
  _deprecated: {
    title: {
      valType: 'string',
      editType: 'layoutstyle'
    },
    titlefont: fontAttrs({
      editType: 'layoutstyle'
    })
  }
};

/***/ }),

/***/ 5025:
/***/ (function(module) {

"use strict";


/**
 * Creates a set of padding attributes.
 *
 * @param {object} opts
 *   @param {string} editType:
 *     the editType for all pieces of this padding definition
 *
 * @return {object} attributes object containing {t, r, b, l} as specified
 */
module.exports = function (opts) {
  var editType = opts.editType;
  return {
    t: {
      valType: 'number',
      dflt: 0,
      editType: editType
    },
    r: {
      valType: 'number',
      dflt: 0,
      editType: editType
    },
    b: {
      valType: 'number',
      dflt: 0,
      editType: editType
    },
    l: {
      valType: 'number',
      dflt: 0,
      editType: editType
    },
    editType: editType
  };
};

/***/ }),

/***/ 4875:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var timeFormatLocale = (__webpack_require__(4096)/* .timeFormatLocale */ .Dq);
var formatLocale = (__webpack_require__(721)/* .formatLocale */ .FF);
var isNumeric = __webpack_require__(2770);
var Registry = __webpack_require__(3972);
var PlotSchema = __webpack_require__(6281);
var Template = __webpack_require__(4467);
var Lib = __webpack_require__(1828);
var Color = __webpack_require__(7901);
var BADNUM = (__webpack_require__(606).BADNUM);
var axisIDs = __webpack_require__(1675);
var clearOutline = (__webpack_require__(1873).clearOutline);
var scatterAttrs = __webpack_require__(1479);
var animationAttrs = __webpack_require__(5594);
var frameAttrs = __webpack_require__(1391);
var getModuleCalcData = (__webpack_require__(7659)/* .getModuleCalcData */ .a0);
var relinkPrivateKeys = Lib.relinkPrivateKeys;
var _ = Lib._;
var plots = module.exports = {};

// Expose registry methods on Plots for backward-compatibility
Lib.extendFlat(plots, Registry);
plots.attributes = __webpack_require__(9012);
plots.attributes.type.values = plots.allTypes;
plots.fontAttrs = __webpack_require__(1940);
plots.layoutAttributes = __webpack_require__(820);

// TODO make this a plot attribute?
plots.fontWeight = 'normal';
var transformsRegistry = plots.transformsRegistry;
var commandModule = __webpack_require__(1137);
plots.executeAPICommand = commandModule.executeAPICommand;
plots.computeAPICommandBindings = commandModule.computeAPICommandBindings;
plots.manageCommandObserver = commandModule.manageCommandObserver;
plots.hasSimpleAPICommandBindings = commandModule.hasSimpleAPICommandBindings;

// in some cases the browser doesn't seem to know how big
// the text is at first, so it needs to draw it,
// then wait a little, then draw it again
plots.redrawText = function (gd) {
  gd = Lib.getGraphDiv(gd);
  return new Promise(function (resolve) {
    setTimeout(function () {
      if (!gd._fullLayout) return;
      Registry.getComponentMethod('annotations', 'draw')(gd);
      Registry.getComponentMethod('legend', 'draw')(gd);
      Registry.getComponentMethod('colorbar', 'draw')(gd);
      resolve(plots.previousPromises(gd));
    }, 300);
  });
};

// resize plot about the container size
plots.resize = function (gd) {
  gd = Lib.getGraphDiv(gd);
  var resolveLastResize;
  var p = new Promise(function (resolve, reject) {
    if (!gd || Lib.isHidden(gd)) {
      reject(new Error('Resize must be passed a displayed plot div element.'));
    }
    if (gd._redrawTimer) clearTimeout(gd._redrawTimer);
    if (gd._resolveResize) resolveLastResize = gd._resolveResize;
    gd._resolveResize = resolve;
    gd._redrawTimer = setTimeout(function () {
      // return if there is nothing to resize or is hidden
      if (!gd.layout || gd.layout.width && gd.layout.height || Lib.isHidden(gd)) {
        resolve(gd);
        return;
      }
      delete gd.layout.width;
      delete gd.layout.height;

      // autosizing doesn't count as a change that needs saving
      var oldchanged = gd.changed;

      // nor should it be included in the undo queue
      gd.autoplay = true;
      Registry.call('relayout', gd, {
        autosize: true
      }).then(function () {
        gd.changed = oldchanged;
        // Only resolve if a new call hasn't been made!
        if (gd._resolveResize === resolve) {
          delete gd._resolveResize;
          resolve(gd);
        }
      });
    }, 100);
  });
  if (resolveLastResize) resolveLastResize(p);
  return p;
};

// for use in Lib.syncOrAsync, check if there are any
// pending promises in this plot and wait for them
plots.previousPromises = function (gd) {
  if ((gd._promises || []).length) {
    return Promise.all(gd._promises).then(function () {
      gd._promises = [];
    });
  }
};

/**
 * Adds the 'Edit chart' link.
 * Note that now _doPlot calls this so it can regenerate whenever it replots
 *
 * Add source links to your graph inside the 'showSources' config argument.
 */
plots.addLinks = function (gd) {
  // Do not do anything if showLink and showSources are not set to true in config
  if (!gd._context.showLink && !gd._context.showSources) return;
  var fullLayout = gd._fullLayout;
  var linkContainer = Lib.ensureSingle(fullLayout._paper, 'text', 'js-plot-link-container', function (s) {
    s.style({
      'font-family': '"Open Sans", Arial, sans-serif',
      'font-size': '12px',
      fill: Color.defaultLine,
      'pointer-events': 'all'
    }).each(function () {
      var links = d3.select(this);
      links.append('tspan').classed('js-link-to-tool', true);
      links.append('tspan').classed('js-link-spacer', true);
      links.append('tspan').classed('js-sourcelinks', true);
    });
  });

  // The text node inside svg
  var text = linkContainer.node();
  var attrs = {
    y: fullLayout._paper.attr('height') - 9
  };

  // If text's width is bigger than the layout
  // Check that text is a child node or document.body
  // because otherwise IE/Edge might throw an exception
  // when calling getComputedTextLength().
  // Apparently offsetParent is null for invisibles.
  if (document.body.contains(text) && text.getComputedTextLength() >= fullLayout.width - 20) {
    // Align the text at the left
    attrs['text-anchor'] = 'start';
    attrs.x = 5;
  } else {
    // Align the text at the right
    attrs['text-anchor'] = 'end';
    attrs.x = fullLayout._paper.attr('width') - 7;
  }
  linkContainer.attr(attrs);
  var toolspan = linkContainer.select('.js-link-to-tool');
  var spacespan = linkContainer.select('.js-link-spacer');
  var sourcespan = linkContainer.select('.js-sourcelinks');
  if (gd._context.showSources) gd._context.showSources(gd);

  // 'view in plotly' link for embedded plots
  if (gd._context.showLink) positionPlayWithData(gd, toolspan);

  // separator if we have both sources and tool link
  spacespan.text(toolspan.text() && sourcespan.text() ? ' - ' : '');
};

// note that now this function is only adding the brand in
// iframes and 3rd-party apps
function positionPlayWithData(gd, container) {
  container.text('');
  var link = container.append('a').attr({
    'xlink:xlink:href': '#',
    class: 'link--impt link--embedview',
    'font-weight': 'bold'
  }).text(gd._context.linkText + ' ' + String.fromCharCode(187));
  if (gd._context.sendData) {
    link.on('click', function () {
      plots.sendDataToCloud(gd);
    });
  } else {
    var path = window.location.pathname.split('/');
    var query = window.location.search;
    link.attr({
      'xlink:xlink:show': 'new',
      'xlink:xlink:href': '/' + path[2].split('.')[0] + '/' + path[1] + query
    });
  }
}
plots.sendDataToCloud = function (gd) {
  var baseUrl = (window.PLOTLYENV || {}).BASE_URL || gd._context.plotlyServerURL;
  if (!baseUrl) return;
  gd.emit('plotly_beforeexport');
  var hiddenformDiv = d3.select(gd).append('div').attr('id', 'hiddenform').style('display', 'none');
  var hiddenform = hiddenformDiv.append('form').attr({
    action: baseUrl + '/external',
    method: 'post',
    target: '_blank'
  });
  var hiddenformInput = hiddenform.append('input').attr({
    type: 'text',
    name: 'data'
  });
  hiddenformInput.node().value = plots.graphJson(gd, false, 'keepdata');
  hiddenform.node().submit();
  hiddenformDiv.remove();
  gd.emit('plotly_afterexport');
  return false;
};
var d3FormatKeys = ['days', 'shortDays', 'months', 'shortMonths', 'periods', 'dateTime', 'date', 'time', 'decimal', 'thousands', 'grouping', 'currency'];
var extraFormatKeys = ['year', 'month', 'dayMonth', 'dayMonthYear'];

/*
 * Fill in default values
 * @param {DOM element} gd
 * @param {object} opts
 * @param {boolean} opts.skipUpdateCalc: normally if the existing gd.calcdata looks
 *   compatible with the new gd._fullData we finish by linking the new _fullData traces
 *   to the old gd.calcdata, so it's correctly set if we're not going to recalc. But also,
 *   if there are calcTransforms on the trace, we first remap data arrays from the old full
 *   trace into the new one. Use skipUpdateCalc to defer this (needed by Plotly.react)
 *
 * gd.data, gd.layout:
 *   are precisely what the user specified (except as modified by cleanData/cleanLayout),
 *   these fields shouldn't be modified (except for filling in some auto values)
 *   nor used directly after the supply defaults step.
 *
 * gd._fullData, gd._fullLayout:
 *   are complete descriptions of how to draw the plot,
 *   use these fields in all required computations.
 *
 * gd._fullLayout._modules
 *   is a list of all the trace modules required to draw the plot.
 *
 * gd._fullLayout._visibleModules
 *   subset of _modules, a list of modules corresponding to visible:true traces.
 *
 * gd._fullLayout._basePlotModules
 *   is a list of all the plot modules required to draw the plot.
 *
 * gd._fullLayout._transformModules
 *   is a list of all the transform modules invoked.
 *
 */
plots.supplyDefaults = function (gd, opts) {
  var skipUpdateCalc = opts && opts.skipUpdateCalc;
  var oldFullLayout = gd._fullLayout || {};
  if (oldFullLayout._skipDefaults) {
    delete oldFullLayout._skipDefaults;
    return;
  }
  var newFullLayout = gd._fullLayout = {};
  var newLayout = gd.layout || {};
  var oldFullData = gd._fullData || [];
  var newFullData = gd._fullData = [];
  var newData = gd.data || [];
  var oldCalcdata = gd.calcdata || [];
  var context = gd._context || {};
  var i;

  // Create all the storage space for frames, but only if doesn't already exist
  if (!gd._transitionData) plots.createTransitionData(gd);

  // So we only need to do this once (and since we have gd here)
  // get the translated placeholder titles.
  // These ones get used as default values so need to be known at supplyDefaults
  // others keep their blank defaults but render the placeholder as desired later
  // TODO: make these work the same way, only inserting the placeholder text at draw time?
  // The challenge is that this has slightly different behavior right now in editable mode:
  // using the placeholder as default makes this text permanently (but lightly) visible,
  // but explicit '' for these titles gives you a placeholder that's hidden until you mouse
  // over it - so you're not distracted by it if you really don't want a title, but if you do
  // and you're new to plotly you may not be able to find it.
  // When editable=false the two behave the same, no title is drawn.
  newFullLayout._dfltTitle = {
    plot: _(gd, 'Click to enter Plot title'),
    x: _(gd, 'Click to enter X axis title'),
    y: _(gd, 'Click to enter Y axis title'),
    colorbar: _(gd, 'Click to enter Colorscale title'),
    annotation: _(gd, 'new text')
  };
  newFullLayout._traceWord = _(gd, 'trace');
  var formatObj = getFormatObj(gd, d3FormatKeys);

  // stash the token from context so mapbox subplots can use it as default
  newFullLayout._mapboxAccessToken = context.mapboxAccessToken;

  // first fill in what we can of layout without looking at data
  // because fullData needs a few things from layout
  if (oldFullLayout._initialAutoSizeIsDone) {
    // coerce the updated layout while preserving width and height
    var oldWidth = oldFullLayout.width;
    var oldHeight = oldFullLayout.height;
    plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);
    if (!newLayout.width) newFullLayout.width = oldWidth;
    if (!newLayout.height) newFullLayout.height = oldHeight;
    plots.sanitizeMargins(newFullLayout);
  } else {
    // coerce the updated layout and autosize if needed
    plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);
    var missingWidthOrHeight = !newLayout.width || !newLayout.height;
    var autosize = newFullLayout.autosize;
    var autosizable = context.autosizable;
    var initialAutoSize = missingWidthOrHeight && (autosize || autosizable);
    if (initialAutoSize) plots.plotAutoSize(gd, newLayout, newFullLayout);else if (missingWidthOrHeight) plots.sanitizeMargins(newFullLayout);

    // for backwards-compatibility with Plotly v1.x.x
    if (!autosize && missingWidthOrHeight) {
      newLayout.width = newFullLayout.width;
      newLayout.height = newFullLayout.height;
    }
  }
  newFullLayout._d3locale = getFormatter(formatObj, newFullLayout.separators);
  newFullLayout._extraFormat = getFormatObj(gd, extraFormatKeys);
  newFullLayout._initialAutoSizeIsDone = true;

  // keep track of how many traces are inputted
  newFullLayout._dataLength = newData.length;

  // clear the lists of trace and baseplot modules, and subplots
  newFullLayout._modules = [];
  newFullLayout._visibleModules = [];
  newFullLayout._basePlotModules = [];
  var subplots = newFullLayout._subplots = emptySubplotLists();

  // initialize axis and subplot hash objects for splom-generated grids
  var splomAxes = newFullLayout._splomAxes = {
    x: {},
    y: {}
  };
  var splomSubplots = newFullLayout._splomSubplots = {};
  // initialize splom grid defaults
  newFullLayout._splomGridDflt = {};

  // for stacked area traces to share config across traces
  newFullLayout._scatterStackOpts = {};
  // for the first scatter trace on each subplot (so it knows tonext->tozero)
  newFullLayout._firstScatter = {};
  // for grouped bar/box/violin trace to share config across traces
  newFullLayout._alignmentOpts = {};
  // track color axes referenced in the data
  newFullLayout._colorAxes = {};

  // for traces to request a default rangeslider on their x axes
  // eg set `_requestRangeslider.x2 = true` for xaxis2
  newFullLayout._requestRangeslider = {};

  // pull uids from old data to use as new defaults
  newFullLayout._traceUids = getTraceUids(oldFullData, newData);

  // then do the data
  newFullLayout._globalTransforms = (gd._context || {}).globalTransforms;
  plots.supplyDataDefaults(newData, newFullData, newLayout, newFullLayout);

  // redo grid size defaults with info about splom x/y axes,
  // and fill in generated cartesian axes and subplots
  var splomXa = Object.keys(splomAxes.x);
  var splomYa = Object.keys(splomAxes.y);
  if (splomXa.length > 1 && splomYa.length > 1) {
    Registry.getComponentMethod('grid', 'sizeDefaults')(newLayout, newFullLayout);
    for (i = 0; i < splomXa.length; i++) {
      Lib.pushUnique(subplots.xaxis, splomXa[i]);
    }
    for (i = 0; i < splomYa.length; i++) {
      Lib.pushUnique(subplots.yaxis, splomYa[i]);
    }
    for (var k in splomSubplots) {
      Lib.pushUnique(subplots.cartesian, k);
    }
  }

  // attach helper method to check whether a plot type is present on graph
  newFullLayout._has = plots._hasPlotType.bind(newFullLayout);
  if (oldFullData.length === newFullData.length) {
    for (i = 0; i < newFullData.length; i++) {
      relinkPrivateKeys(newFullData[i], oldFullData[i]);
    }
  }

  // finally, fill in the pieces of layout that may need to look at data
  plots.supplyLayoutModuleDefaults(newLayout, newFullLayout, newFullData, gd._transitionData);

  // Special cases that introduce interactions between traces.
  // This is after relinkPrivateKeys so we can use those in crossTraceDefaults
  // and after layout module defaults, so we can use eg barmode
  var _modules = newFullLayout._visibleModules;
  var crossTraceDefaultsFuncs = [];
  for (i = 0; i < _modules.length; i++) {
    var funci = _modules[i].crossTraceDefaults;
    // some trace types share crossTraceDefaults (ie histogram2d, histogram2dcontour)
    if (funci) Lib.pushUnique(crossTraceDefaultsFuncs, funci);
  }
  for (i = 0; i < crossTraceDefaultsFuncs.length; i++) {
    crossTraceDefaultsFuncs[i](newFullData, newFullLayout);
  }

  // turn on flag to optimize large splom-only graphs
  // mostly by omitting SVG layers during Cartesian.drawFramework
  newFullLayout._hasOnlyLargeSploms = newFullLayout._basePlotModules.length === 1 && newFullLayout._basePlotModules[0].name === 'splom' && splomXa.length > 15 && splomYa.length > 15 && newFullLayout.shapes.length === 0 && newFullLayout.images.length === 0;

  // relink / initialize subplot axis objects
  plots.linkSubplots(newFullData, newFullLayout, oldFullData, oldFullLayout);

  // clean subplots and other artifacts from previous plot calls
  plots.cleanPlot(newFullData, newFullLayout, oldFullData, oldFullLayout);
  var hadGL2D = !!(oldFullLayout._has && oldFullLayout._has('gl2d'));
  var hasGL2D = !!(newFullLayout._has && newFullLayout._has('gl2d'));
  var hadCartesian = !!(oldFullLayout._has && oldFullLayout._has('cartesian'));
  var hasCartesian = !!(newFullLayout._has && newFullLayout._has('cartesian'));
  var hadBgLayer = hadCartesian || hadGL2D;
  var hasBgLayer = hasCartesian || hasGL2D;
  if (hadBgLayer && !hasBgLayer) {
    // remove bgLayer
    oldFullLayout._bgLayer.remove();
  } else if (hasBgLayer && !hadBgLayer) {
    // create bgLayer
    newFullLayout._shouldCreateBgLayer = true;
  }

  // clear selection outline until we implement persistent selection,
  // don't clear them though when drag handlers (e.g. listening to
  // `plotly_selecting`) update the graph.
  // we should try to come up with a better solution when implementing
  // https://github.com/plotly/plotly.js/issues/1851
  if (oldFullLayout._zoomlayer && !gd._dragging) {
    clearOutline({
      // mock old gd
      _fullLayout: oldFullLayout
    });
  }

  // fill in meta helpers
  fillMetaTextHelpers(newFullData, newFullLayout);

  // relink functions and _ attributes to promote consistency between plots
  relinkPrivateKeys(newFullLayout, oldFullLayout);

  // colorscale crossTraceDefaults needs newFullLayout with relinked keys
  Registry.getComponentMethod('colorscale', 'crossTraceDefaults')(newFullData, newFullLayout);

  // For persisting GUI-driven changes in layout
  // _preGUI and _tracePreGUI were already copied over in relinkPrivateKeys
  if (!newFullLayout._preGUI) newFullLayout._preGUI = {};
  // track trace GUI changes by uid rather than by trace index
  if (!newFullLayout._tracePreGUI) newFullLayout._tracePreGUI = {};
  var tracePreGUI = newFullLayout._tracePreGUI;
  var uids = {};
  var uid;
  for (uid in tracePreGUI) uids[uid] = 'old';
  for (i = 0; i < newFullData.length; i++) {
    uid = newFullData[i]._fullInput.uid;
    if (!uids[uid]) tracePreGUI[uid] = {};
    uids[uid] = 'new';
  }
  for (uid in uids) {
    if (uids[uid] === 'old') delete tracePreGUI[uid];
  }

  // set up containers for margin calculations
  initMargins(newFullLayout);

  // collect and do some initial calculations for rangesliders
  Registry.getComponentMethod('rangeslider', 'makeData')(newFullLayout);

  // update object references in calcdata
  if (!skipUpdateCalc && oldCalcdata.length === newFullData.length) {
    plots.supplyDefaultsUpdateCalc(oldCalcdata, newFullData);
  }
};
plots.supplyDefaultsUpdateCalc = function (oldCalcdata, newFullData) {
  for (var i = 0; i < newFullData.length; i++) {
    var newTrace = newFullData[i];
    var cd0 = (oldCalcdata[i] || [])[0];
    if (cd0 && cd0.trace) {
      var oldTrace = cd0.trace;
      if (oldTrace._hasCalcTransform) {
        var arrayAttrs = oldTrace._arrayAttrs;
        var j, astr, oldArrayVal;
        for (j = 0; j < arrayAttrs.length; j++) {
          astr = arrayAttrs[j];
          oldArrayVal = Lib.nestedProperty(oldTrace, astr).get().slice();
          Lib.nestedProperty(newTrace, astr).set(oldArrayVal);
        }
      }
      cd0.trace = newTrace;
    }
  }
};

/**
 * Create a list of uid strings satisfying (in this order of importance):
 * 1. all unique, all strings
 * 2. matches input uids if provided
 * 3. matches previous data uids
 */
function getTraceUids(oldFullData, newData) {
  var len = newData.length;
  var oldFullInput = [];
  var i, prevFullInput;
  for (i = 0; i < oldFullData.length; i++) {
    var thisFullInput = oldFullData[i]._fullInput;
    if (thisFullInput !== prevFullInput) oldFullInput.push(thisFullInput);
    prevFullInput = thisFullInput;
  }
  var oldLen = oldFullInput.length;
  var out = new Array(len);
  var seenUids = {};
  function setUid(uid, i) {
    out[i] = uid;
    seenUids[uid] = 1;
  }
  function tryUid(uid, i) {
    if (uid && typeof uid === 'string' && !seenUids[uid]) {
      setUid(uid, i);
      return true;
    }
  }
  for (i = 0; i < len; i++) {
    var newUid = newData[i].uid;
    if (typeof newUid === 'number') newUid = String(newUid);
    if (tryUid(newUid, i)) continue;
    if (i < oldLen && tryUid(oldFullInput[i].uid, i)) continue;
    setUid(Lib.randstr(seenUids), i);
  }
  return out;
}

/**
 * Make a container for collecting subplots we need to display.
 *
 * Finds all subplot types we need to enumerate once and caches it,
 * but makes a new output object each time.
 * Single-trace subplots (which have no `id`) such as pie, table, etc
 * do not need to be collected because we just draw all visible traces.
 */
function emptySubplotLists() {
  var collectableSubplotTypes = Registry.collectableSubplotTypes;
  var out = {};
  var i, j;
  if (!collectableSubplotTypes) {
    collectableSubplotTypes = [];
    var subplotsRegistry = Registry.subplotsRegistry;
    for (var subplotType in subplotsRegistry) {
      var subplotModule = subplotsRegistry[subplotType];
      var subplotAttr = subplotModule.attr;
      if (subplotAttr) {
        collectableSubplotTypes.push(subplotType);

        // special case, currently just for cartesian:
        // we need to enumerate axes, not just subplots
        if (Array.isArray(subplotAttr)) {
          for (j = 0; j < subplotAttr.length; j++) {
            Lib.pushUnique(collectableSubplotTypes, subplotAttr[j]);
          }
        }
      }
    }
  }
  for (i = 0; i < collectableSubplotTypes.length; i++) {
    out[collectableSubplotTypes[i]] = [];
  }
  return out;
}

/**
 * getFormatObj: use _context to get the format object from locale.
 * Used to get d3.locale argument object and extraFormat argument object
 *
 * Regarding d3.locale argument :
 * decimal and thousands can be overridden later by layout.separators
 * grouping and currency are not presently used by our automatic number
 * formatting system but can be used by custom formats.
 *
 * @returns {object} d3.locale format object
 */
function getFormatObj(gd, formatKeys) {
  var locale = gd._context.locale;
  if (!locale) locale = 'en-US';
  var formatDone = false;
  var formatObj = {};
  function includeFormat(newFormat) {
    var formatFinished = true;
    for (var i = 0; i < formatKeys.length; i++) {
      var formatKey = formatKeys[i];
      if (!formatObj[formatKey]) {
        if (newFormat[formatKey]) {
          formatObj[formatKey] = newFormat[formatKey];
        } else formatFinished = false;
      }
    }
    if (formatFinished) formatDone = true;
  }

  // same as localize, look for format parts in each format spec in the chain
  for (var i = 0; i < 2; i++) {
    var locales = gd._context.locales;
    for (var j = 0; j < 2; j++) {
      var formatj = (locales[locale] || {}).format;
      if (formatj) {
        includeFormat(formatj);
        if (formatDone) break;
      }
      locales = Registry.localeRegistry;
    }
    var baseLocale = locale.split('-')[0];
    if (formatDone || baseLocale === locale) break;
    locale = baseLocale;
  }

  // lastly pick out defaults from english (non-US, as DMY is so much more common)
  if (!formatDone) includeFormat(Registry.localeRegistry.en.format);
  return formatObj;
}

/**
 * getFormatter: combine the final separators with the locale formatting object
 * we pulled earlier to generate number and time formatters
 * TODO: remove separators in v3, only use locale, so we don't need this step?
 *
 * @param {object} formatObj: d3.locale format object
 * @param {string} separators: length-2 string to override decimal and thousands
 *   separators in number formatting
 *
 * @returns {object} {numberFormat, timeFormat} d3 formatter factory functions
 *   for numbers and time
 */
function getFormatter(formatObj, separators) {
  formatObj.decimal = separators.charAt(0);
  formatObj.thousands = separators.charAt(1);
  return {
    numberFormat: function (formatStr) {
      try {
        formatStr = formatLocale(formatObj).format(Lib.adjustFormat(formatStr));
      } catch (e) {
        Lib.warnBadFormat(formatStr);
        return Lib.noFormat;
      }
      return formatStr;
    },
    timeFormat: timeFormatLocale(formatObj).utcFormat
  };
}
function fillMetaTextHelpers(newFullData, newFullLayout) {
  var _meta;
  var meta4data = [];
  if (newFullLayout.meta) {
    _meta = newFullLayout._meta = {
      meta: newFullLayout.meta,
      layout: {
        meta: newFullLayout.meta
      }
    };
  }
  for (var i = 0; i < newFullData.length; i++) {
    var trace = newFullData[i];
    if (trace.meta) {
      meta4data[trace.index] = trace._meta = {
        meta: trace.meta
      };
    } else if (newFullLayout.meta) {
      trace._meta = {
        meta: newFullLayout.meta
      };
    }
    if (newFullLayout.meta) {
      trace._meta.layout = {
        meta: newFullLayout.meta
      };
    }
  }
  if (meta4data.length) {
    if (!_meta) {
      _meta = newFullLayout._meta = {};
    }
    _meta.data = meta4data;
  }
}

// Create storage for all of the data related to frames and transitions:
plots.createTransitionData = function (gd) {
  // Set up the default keyframe if it doesn't exist:
  if (!gd._transitionData) {
    gd._transitionData = {};
  }
  if (!gd._transitionData._frames) {
    gd._transitionData._frames = [];
  }
  if (!gd._transitionData._frameHash) {
    gd._transitionData._frameHash = {};
  }
  if (!gd._transitionData._counter) {
    gd._transitionData._counter = 0;
  }
  if (!gd._transitionData._interruptCallbacks) {
    gd._transitionData._interruptCallbacks = [];
  }
};

// helper function to be bound to fullLayout to check
// whether a certain plot type is present on plot
// or trace has a category
plots._hasPlotType = function (category) {
  var i;

  // check base plot modules
  var basePlotModules = this._basePlotModules || [];
  for (i = 0; i < basePlotModules.length; i++) {
    if (basePlotModules[i].name === category) return true;
  }

  // check trace modules (including non-visible:true)
  var modules = this._modules || [];
  for (i = 0; i < modules.length; i++) {
    var name = modules[i].name;
    if (name === category) return true;
    // N.B. this is modules[i] along with 'categories' as a hash object
    var _module = Registry.modules[name];
    if (_module && _module.categories[category]) return true;
  }
  return false;
};
plots.cleanPlot = function (newFullData, newFullLayout, oldFullData, oldFullLayout) {
  var i, j;
  var basePlotModules = oldFullLayout._basePlotModules || [];
  for (i = 0; i < basePlotModules.length; i++) {
    var _module = basePlotModules[i];
    if (_module.clean) {
      _module.clean(newFullData, newFullLayout, oldFullData, oldFullLayout);
    }
  }
  var hadGl = oldFullLayout._has && oldFullLayout._has('gl');
  var hasGl = newFullLayout._has && newFullLayout._has('gl');
  if (hadGl && !hasGl) {
    if (oldFullLayout._glcontainer !== undefined) {
      oldFullLayout._glcontainer.selectAll('.gl-canvas').remove();
      oldFullLayout._glcontainer.selectAll('.no-webgl').remove();
      oldFullLayout._glcanvas = null;
    }
  }
  var hasInfoLayer = !!oldFullLayout._infolayer;
  oldLoop: for (i = 0; i < oldFullData.length; i++) {
    var oldTrace = oldFullData[i];
    var oldUid = oldTrace.uid;
    for (j = 0; j < newFullData.length; j++) {
      var newTrace = newFullData[j];
      if (oldUid === newTrace.uid) continue oldLoop;
    }

    // clean old colorbars
    if (hasInfoLayer) {
      oldFullLayout._infolayer.select('.cb' + oldUid).remove();
    }
  }
};
plots.linkSubplots = function (newFullData, newFullLayout, oldFullData, oldFullLayout) {
  var i, j;
  var oldSubplots = oldFullLayout._plots || {};
  var newSubplots = newFullLayout._plots = {};
  var newSubplotList = newFullLayout._subplots;
  var mockGd = {
    _fullData: newFullData,
    _fullLayout: newFullLayout
  };
  var ids = newSubplotList.cartesian.concat(newSubplotList.gl2d || []);
  for (i = 0; i < ids.length; i++) {
    var id = ids[i];
    var oldSubplot = oldSubplots[id];
    var xaxis = axisIDs.getFromId(mockGd, id, 'x');
    var yaxis = axisIDs.getFromId(mockGd, id, 'y');
    var plotinfo;

    // link or create subplot object
    if (oldSubplot) {
      plotinfo = newSubplots[id] = oldSubplot;
    } else {
      plotinfo = newSubplots[id] = {};
      plotinfo.id = id;
    }

    // add these axis ids to each others' subplot lists
    xaxis._counterAxes.push(yaxis._id);
    yaxis._counterAxes.push(xaxis._id);
    xaxis._subplotsWith.push(id);
    yaxis._subplotsWith.push(id);

    // update x and y axis layout object refs
    plotinfo.xaxis = xaxis;
    plotinfo.yaxis = yaxis;

    // By default, we clip at the subplot level,
    // but if one trace on a given subplot has *cliponaxis* set to false,
    // we need to clip at the trace module layer level;
    // find this out here, once of for all.
    plotinfo._hasClipOnAxisFalse = false;
    for (j = 0; j < newFullData.length; j++) {
      var trace = newFullData[j];
      if (trace.xaxis === plotinfo.xaxis._id && trace.yaxis === plotinfo.yaxis._id && trace.cliponaxis === false) {
        plotinfo._hasClipOnAxisFalse = true;
        break;
      }
    }
  }

  // while we're at it, link overlaying axes to their main axes and
  // anchored axes to the axes they're anchored to
  var axList = axisIDs.list(mockGd, null, true);
  var ax;
  for (i = 0; i < axList.length; i++) {
    ax = axList[i];
    var mainAx = null;
    if (ax.overlaying) {
      mainAx = axisIDs.getFromId(mockGd, ax.overlaying);

      // you cannot overlay an axis that's already overlaying another
      if (mainAx && mainAx.overlaying) {
        ax.overlaying = false;
        mainAx = null;
      }
    }
    ax._mainAxis = mainAx || ax;

    /*
     * For now force overlays to overlay completely... so they
     * can drag together correctly and share backgrounds.
     * Later perhaps we make separate axis domain and
     * tick/line domain or something, so they can still share
     * the (possibly larger) dragger and background but don't
     * have to both be drawn over that whole domain
     */
    if (mainAx) ax.domain = mainAx.domain.slice();
    ax._anchorAxis = ax.anchor === 'free' ? null : axisIDs.getFromId(mockGd, ax.anchor);
  }

  // finally, we can find the main subplot for each axis
  // (on which the ticks & labels are drawn)
  for (i = 0; i < axList.length; i++) {
    ax = axList[i];
    ax._counterAxes.sort(axisIDs.idSort);
    ax._subplotsWith.sort(Lib.subplotSort);
    ax._mainSubplot = findMainSubplot(ax, newFullLayout);

    // find "full" domain span of counter axes,
    // this loop can be costly, so only compute it when required
    if (ax._counterAxes.length && (ax.spikemode && ax.spikemode.indexOf('across') !== -1 || ax.automargin && ax.mirror && ax.anchor !== 'free' || Registry.getComponentMethod('rangeslider', 'isVisible')(ax))) {
      var min = 1;
      var max = 0;
      for (j = 0; j < ax._counterAxes.length; j++) {
        var ax2 = axisIDs.getFromId(mockGd, ax._counterAxes[j]);
        min = Math.min(min, ax2.domain[0]);
        max = Math.max(max, ax2.domain[1]);
      }
      if (min < max) {
        ax._counterDomainMin = min;
        ax._counterDomainMax = max;
      }
    }
  }
};
function findMainSubplot(ax, fullLayout) {
  var mockGd = {
    _fullLayout: fullLayout
  };
  var isX = ax._id.charAt(0) === 'x';
  var anchorAx = ax._mainAxis._anchorAxis;
  var mainSubplotID = '';
  var nextBestMainSubplotID = '';
  var anchorID = '';

  // First try the main ID with the anchor
  if (anchorAx) {
    anchorID = anchorAx._mainAxis._id;
    mainSubplotID = isX ? ax._id + anchorID : anchorID + ax._id;
  }

  // Then look for a subplot with the counteraxis overlaying the anchor
  // If that fails just use the first subplot including this axis
  if (!mainSubplotID || !fullLayout._plots[mainSubplotID]) {
    mainSubplotID = '';
    var counterIDs = ax._counterAxes;
    for (var j = 0; j < counterIDs.length; j++) {
      var counterPart = counterIDs[j];
      var id = isX ? ax._id + counterPart : counterPart + ax._id;
      if (!nextBestMainSubplotID) nextBestMainSubplotID = id;
      var counterAx = axisIDs.getFromId(mockGd, counterPart);
      if (anchorID && counterAx.overlaying === anchorID) {
        mainSubplotID = id;
        break;
      }
    }
  }
  return mainSubplotID || nextBestMainSubplotID;
}

// This function clears any trace attributes with valType: color and
// no set dflt filed in the plot schema. This is needed because groupby (which
// is the only transform for which this currently applies) supplies parent
// trace defaults, then expanded trace defaults. The result is that `null`
// colors are default-supplied and inherited as a color instead of a null.
// The result is that expanded trace default colors have no effect, with
// the final result that groups are indistinguishable. This function clears
// those colors so that individual groupby groups get unique colors.
plots.clearExpandedTraceDefaultColors = function (trace) {
  var colorAttrs, path, i;

  // This uses weird closure state in order to satisfy the linter rule
  // that we can't create functions in a loop.
  function locateColorAttrs(attr, attrName, attrs, level) {
    path[level] = attrName;
    path.length = level + 1;
    if (attr.valType === 'color' && attr.dflt === undefined) {
      colorAttrs.push(path.join('.'));
    }
  }
  path = [];

  // Get the cached colorAttrs:
  colorAttrs = trace._module._colorAttrs;

  // Or else compute and cache the colorAttrs on the module:
  if (!colorAttrs) {
    trace._module._colorAttrs = colorAttrs = [];
    PlotSchema.crawl(trace._module.attributes, locateColorAttrs);
  }
  for (i = 0; i < colorAttrs.length; i++) {
    var origprop = Lib.nestedProperty(trace, '_input.' + colorAttrs[i]);
    if (!origprop.get()) {
      Lib.nestedProperty(trace, colorAttrs[i]).set(null);
    }
  }
};
plots.supplyDataDefaults = function (dataIn, dataOut, layout, fullLayout) {
  var modules = fullLayout._modules;
  var visibleModules = fullLayout._visibleModules;
  var basePlotModules = fullLayout._basePlotModules;
  var cnt = 0;
  var colorCnt = 0;
  var i, fullTrace, trace;
  fullLayout._transformModules = [];
  function pushModule(fullTrace) {
    dataOut.push(fullTrace);
    var _module = fullTrace._module;
    if (!_module) return;
    Lib.pushUnique(modules, _module);
    if (fullTrace.visible === true) Lib.pushUnique(visibleModules, _module);
    Lib.pushUnique(basePlotModules, fullTrace._module.basePlotModule);
    cnt++;

    // TODO: do we really want color not to increment for explicitly invisible traces?
    // This logic is weird, but matches previous behavior: traces that you explicitly
    // set to visible:false do not increment the color, but traces WE determine to be
    // empty or invalid (and thus set to visible:false) DO increment color.
    // I kind of think we should just let all traces increment color, visible or not.
    // see mock: axes-autotype-empty vs. a test of restyling visible: false that
    // I can't find right now...
    if (fullTrace._input.visible !== false) colorCnt++;
  }
  var carpetIndex = {};
  var carpetDependents = [];
  var dataTemplate = (layout.template || {}).data || {};
  var templater = Template.traceTemplater(dataTemplate);
  for (i = 0; i < dataIn.length; i++) {
    trace = dataIn[i];

    // reuse uid we may have pulled out of oldFullData
    // Note: templater supplies trace type
    fullTrace = templater.newTrace(trace);
    fullTrace.uid = fullLayout._traceUids[i];
    plots.supplyTraceDefaults(trace, fullTrace, colorCnt, fullLayout, i);
    fullTrace.index = i;
    fullTrace._input = trace;
    fullTrace._expandedIndex = cnt;
    if (fullTrace.transforms && fullTrace.transforms.length) {
      var sdInvisible = trace.visible !== false && fullTrace.visible === false;
      var expandedTraces = applyTransforms(fullTrace, dataOut, layout, fullLayout);
      for (var j = 0; j < expandedTraces.length; j++) {
        var expandedTrace = expandedTraces[j];

        // No further templating during transforms.
        var fullExpandedTrace = {
          _template: fullTrace._template,
          type: fullTrace.type,
          // set uid using parent uid and expanded index
          // to promote consistency between update calls
          uid: fullTrace.uid + j
        };

        // If the first supplyDefaults created `visible: false`,
        // clear it before running supplyDefaults a second time,
        // because sometimes there are items we still want to coerce
        // inside trace modules before determining that the trace is
        // again `visible: false`, for example partial visibilities
        // in `splom` traces.
        if (sdInvisible && expandedTrace.visible === false) {
          delete expandedTrace.visible;
        }
        plots.supplyTraceDefaults(expandedTrace, fullExpandedTrace, cnt, fullLayout, i);

        // relink private (i.e. underscore) keys expanded trace to full expanded trace so
        // that transform supply-default methods can set _ keys for future use.
        relinkPrivateKeys(fullExpandedTrace, expandedTrace);

        // add info about parent data trace
        fullExpandedTrace.index = i;
        fullExpandedTrace._input = trace;
        fullExpandedTrace._fullInput = fullTrace;

        // add info about the expanded data
        fullExpandedTrace._expandedIndex = cnt;
        fullExpandedTrace._expandedInput = expandedTrace;
        pushModule(fullExpandedTrace);
      }
    } else {
      // add identify refs for consistency with transformed traces
      fullTrace._fullInput = fullTrace;
      fullTrace._expandedInput = fullTrace;
      pushModule(fullTrace);
    }
    if (Registry.traceIs(fullTrace, 'carpetAxis')) {
      carpetIndex[fullTrace.carpet] = fullTrace;
    }
    if (Registry.traceIs(fullTrace, 'carpetDependent')) {
      carpetDependents.push(i);
    }
  }
  for (i = 0; i < carpetDependents.length; i++) {
    fullTrace = dataOut[carpetDependents[i]];
    if (!fullTrace.visible) continue;
    var carpetAxis = carpetIndex[fullTrace.carpet];
    fullTrace._carpet = carpetAxis;
    if (!carpetAxis || !carpetAxis.visible) {
      fullTrace.visible = false;
      continue;
    }
    fullTrace.xaxis = carpetAxis.xaxis;
    fullTrace.yaxis = carpetAxis.yaxis;
  }
};
plots.supplyAnimationDefaults = function (opts) {
  opts = opts || {};
  var i;
  var optsOut = {};
  function coerce(attr, dflt) {
    return Lib.coerce(opts || {}, optsOut, animationAttrs, attr, dflt);
  }
  coerce('mode');
  coerce('direction');
  coerce('fromcurrent');
  if (Array.isArray(opts.frame)) {
    optsOut.frame = [];
    for (i = 0; i < opts.frame.length; i++) {
      optsOut.frame[i] = plots.supplyAnimationFrameDefaults(opts.frame[i] || {});
    }
  } else {
    optsOut.frame = plots.supplyAnimationFrameDefaults(opts.frame || {});
  }
  if (Array.isArray(opts.transition)) {
    optsOut.transition = [];
    for (i = 0; i < opts.transition.length; i++) {
      optsOut.transition[i] = plots.supplyAnimationTransitionDefaults(opts.transition[i] || {});
    }
  } else {
    optsOut.transition = plots.supplyAnimationTransitionDefaults(opts.transition || {});
  }
  return optsOut;
};
plots.supplyAnimationFrameDefaults = function (opts) {
  var optsOut = {};
  function coerce(attr, dflt) {
    return Lib.coerce(opts || {}, optsOut, animationAttrs.frame, attr, dflt);
  }
  coerce('duration');
  coerce('redraw');
  return optsOut;
};
plots.supplyAnimationTransitionDefaults = function (opts) {
  var optsOut = {};
  function coerce(attr, dflt) {
    return Lib.coerce(opts || {}, optsOut, animationAttrs.transition, attr, dflt);
  }
  coerce('duration');
  coerce('easing');
  return optsOut;
};
plots.supplyFrameDefaults = function (frameIn) {
  var frameOut = {};
  function coerce(attr, dflt) {
    return Lib.coerce(frameIn, frameOut, frameAttrs, attr, dflt);
  }
  coerce('group');
  coerce('name');
  coerce('traces');
  coerce('baseframe');
  coerce('data');
  coerce('layout');
  return frameOut;
};
plots.supplyTraceDefaults = function (traceIn, traceOut, colorIndex, layout, traceInIndex) {
  var colorway = layout.colorway || Color.defaults;
  var defaultColor = colorway[colorIndex % colorway.length];
  var i;
  function coerce(attr, dflt) {
    return Lib.coerce(traceIn, traceOut, plots.attributes, attr, dflt);
  }
  var visible = coerce('visible');
  coerce('type');
  coerce('name', layout._traceWord + ' ' + traceInIndex);
  coerce('uirevision', layout.uirevision);

  // we want even invisible traces to make their would-be subplots visible
  // so coerce the subplot id(s) now no matter what
  var _module = plots.getModule(traceOut);
  traceOut._module = _module;
  if (_module) {
    var basePlotModule = _module.basePlotModule;
    var subplotAttr = basePlotModule.attr;
    var subplotAttrs = basePlotModule.attributes;
    if (subplotAttr && subplotAttrs) {
      var subplots = layout._subplots;
      var subplotId = '';
      if (visible || basePlotModule.name !== 'gl2d' // for now just drop empty gl2d subplots
      // TODO - currently if we draw an empty gl2d subplot, it draws
      // nothing then gets stuck and you can't get it back without newPlot
      // sort this out in the regl refactor?
      ) {
        if (Array.isArray(subplotAttr)) {
          for (i = 0; i < subplotAttr.length; i++) {
            var attri = subplotAttr[i];
            var vali = Lib.coerce(traceIn, traceOut, subplotAttrs, attri);
            if (subplots[attri]) Lib.pushUnique(subplots[attri], vali);
            subplotId += vali;
          }
        } else {
          subplotId = Lib.coerce(traceIn, traceOut, subplotAttrs, subplotAttr);
        }
        if (subplots[basePlotModule.name]) {
          Lib.pushUnique(subplots[basePlotModule.name], subplotId);
        }
      }
    }
  }
  if (visible) {
    coerce('customdata');
    coerce('ids');
    coerce('meta');
    if (Registry.traceIs(traceOut, 'showLegend')) {
      Lib.coerce(traceIn, traceOut, _module.attributes.showlegend ? _module.attributes : plots.attributes, 'showlegend');
      coerce('legend');
      coerce('legendwidth');
      coerce('legendgroup');
      coerce('legendgrouptitle.text');
      coerce('legendrank');
      traceOut._dfltShowLegend = true;
    } else {
      traceOut._dfltShowLegend = false;
    }
    if (_module) {
      _module.supplyDefaults(traceIn, traceOut, defaultColor, layout);
    }
    if (!Registry.traceIs(traceOut, 'noOpacity')) {
      coerce('opacity');
    }
    if (Registry.traceIs(traceOut, 'notLegendIsolatable')) {
      // This clears out the legendonly state for traces like carpet that
      // cannot be isolated in the legend
      traceOut.visible = !!traceOut.visible;
    }
    if (!Registry.traceIs(traceOut, 'noHover')) {
      if (!traceOut.hovertemplate) Lib.coerceHoverinfo(traceIn, traceOut, layout);

      // parcats support hover, but not hoverlabel stylings (yet)
      if (traceOut.type !== 'parcats') {
        Registry.getComponentMethod('fx', 'supplyDefaults')(traceIn, traceOut, defaultColor, layout);
      }
    }
    if (_module && _module.selectPoints) {
      coerce('selectedpoints');
    }
    plots.supplyTransformDefaults(traceIn, traceOut, layout);
  }
  return traceOut;
};

/**
 * hasMakesDataTransform: does this trace have a transform that makes its own
 * data, either by grabbing it from somewhere else or by creating it from input
 * parameters? If so, we should still keep going with supplyDefaults
 * even if the trace is invisible, which may just be because it has no data yet.
 */
function hasMakesDataTransform(trace) {
  var transforms = trace.transforms;
  if (Array.isArray(transforms) && transforms.length) {
    for (var i = 0; i < transforms.length; i++) {
      var ti = transforms[i];
      var _module = ti._module || transformsRegistry[ti.type];
      if (_module && _module.makesData) return true;
    }
  }
  return false;
}
plots.hasMakesDataTransform = hasMakesDataTransform;
plots.supplyTransformDefaults = function (traceIn, traceOut, layout) {
  // For now we only allow transforms on 1D traces, ie those that specify a _length.
  // If we were to implement 2D transforms, we'd need to have each transform
  // describe its own applicability and disable itself when it doesn't apply.
  // Also allow transforms that make their own data, but not in globalTransforms
  if (!(traceOut._length || hasMakesDataTransform(traceIn))) return;
  var globalTransforms = layout._globalTransforms || [];
  var transformModules = layout._transformModules || [];
  if (!Array.isArray(traceIn.transforms) && globalTransforms.length === 0) return;
  var containerIn = traceIn.transforms || [];
  var transformList = globalTransforms.concat(containerIn);
  var containerOut = traceOut.transforms = [];
  for (var i = 0; i < transformList.length; i++) {
    var transformIn = transformList[i];
    var type = transformIn.type;
    var _module = transformsRegistry[type];
    var transformOut;

    /*
     * Supply defaults may run twice. First pass runs all supply defaults steps
     * and adds the _module to any output transforms.
     * If transforms exist another pass is run so that any generated traces also
     * go through supply defaults. This has the effect of rerunning
     * supplyTransformDefaults. If the transform does not have a `transform`
     * function it could not have generated any new traces and the second stage
     * is unnecessary. We detect this case with the following variables.
     */
    var isFirstStage = !(transformIn._module && transformIn._module === _module);
    var doLaterStages = _module && typeof _module.transform === 'function';
    if (!_module) Lib.warn('Unrecognized transform type ' + type + '.');
    if (_module && _module.supplyDefaults && (isFirstStage || doLaterStages)) {
      transformOut = _module.supplyDefaults(transformIn, traceOut, layout, traceIn);
      transformOut.type = type;
      transformOut._module = _module;
      Lib.pushUnique(transformModules, _module);
    } else {
      transformOut = Lib.extendFlat({}, transformIn);
    }
    containerOut.push(transformOut);
  }
};
function applyTransforms(fullTrace, fullData, layout, fullLayout) {
  var container = fullTrace.transforms;
  var dataOut = [fullTrace];
  for (var i = 0; i < container.length; i++) {
    var transform = container[i];
    var _module = transformsRegistry[transform.type];
    if (_module && _module.transform) {
      dataOut = _module.transform(dataOut, {
        transform: transform,
        fullTrace: fullTrace,
        fullData: fullData,
        layout: layout,
        fullLayout: fullLayout,
        transformIndex: i
      });
    }
  }
  return dataOut;
}
plots.supplyLayoutGlobalDefaults = function (layoutIn, layoutOut, formatObj) {
  function coerce(attr, dflt) {
    return Lib.coerce(layoutIn, layoutOut, plots.layoutAttributes, attr, dflt);
  }
  var template = layoutIn.template;
  if (Lib.isPlainObject(template)) {
    layoutOut.template = template;
    layoutOut._template = template.layout;
    layoutOut._dataTemplate = template.data;
  }
  coerce('autotypenumbers');
  var font = Lib.coerceFont(coerce, 'font');
  var fontSize = font.size;
  Lib.coerceFont(coerce, 'title.font', Lib.extendFlat({}, font, {
    size: Math.round(fontSize * 1.4)
  }));
  coerce('title.text', layoutOut._dfltTitle.plot);
  coerce('title.xref');
  var titleYref = coerce('title.yref');
  coerce('title.pad.t');
  coerce('title.pad.r');
  coerce('title.pad.b');
  coerce('title.pad.l');
  var titleAutomargin = coerce('title.automargin');
  coerce('title.x');
  coerce('title.xanchor');
  coerce('title.y');
  coerce('title.yanchor');
  if (titleAutomargin) {
    // when automargin=true
    // title.y is 1 or 0 if paper ref
    // 'auto' is not supported for either title.y or title.yanchor

    // TODO: mention this smart default in the title.y and title.yanchor descriptions

    if (titleYref === 'paper') {
      if (layoutOut.title.y !== 0) layoutOut.title.y = 1;
      if (layoutOut.title.yanchor === 'auto') {
        layoutOut.title.yanchor = layoutOut.title.y === 0 ? 'top' : 'bottom';
      }
    }
    if (titleYref === 'container') {
      if (layoutOut.title.y === 'auto') layoutOut.title.y = 1;
      if (layoutOut.title.yanchor === 'auto') {
        layoutOut.title.yanchor = layoutOut.title.y < 0.5 ? 'bottom' : 'top';
      }
    }
  }
  var uniformtextMode = coerce('uniformtext.mode');
  if (uniformtextMode) {
    coerce('uniformtext.minsize');
  }

  // Make sure that autosize is defaulted to *true*
  // on layouts with no set width and height for backward compatibly,
  // in particular https://plotly.com/javascript/responsive-fluid-layout/
  //
  // Before https://github.com/plotly/plotly.js/pull/635 ,
  // layouts with no set width and height were set temporary set to 'initial'
  // to pass through the autosize routine
  //
  // This behavior is subject to change in v3.
  coerce('autosize', !(layoutIn.width && layoutIn.height));
  coerce('width');
  coerce('height');
  coerce('minreducedwidth');
  coerce('minreducedheight');
  coerce('margin.l');
  coerce('margin.r');
  coerce('margin.t');
  coerce('margin.b');
  coerce('margin.pad');
  coerce('margin.autoexpand');
  if (layoutIn.width && layoutIn.height) plots.sanitizeMargins(layoutOut);
  Registry.getComponentMethod('grid', 'sizeDefaults')(layoutIn, layoutOut);
  coerce('paper_bgcolor');
  coerce('separators', formatObj.decimal + formatObj.thousands);
  coerce('hidesources');
  coerce('colorway');
  coerce('datarevision');
  var uirevision = coerce('uirevision');
  coerce('editrevision', uirevision);
  coerce('selectionrevision', uirevision);
  Registry.getComponentMethod('modebar', 'supplyLayoutDefaults')(layoutIn, layoutOut);
  Registry.getComponentMethod('shapes', 'supplyDrawNewShapeDefaults')(layoutIn, layoutOut, coerce);
  Registry.getComponentMethod('selections', 'supplyDrawNewSelectionDefaults')(layoutIn, layoutOut, coerce);
  coerce('meta');

  // do not include defaults in fullLayout when users do not set transition
  if (Lib.isPlainObject(layoutIn.transition)) {
    coerce('transition.duration');
    coerce('transition.easing');
    coerce('transition.ordering');
  }
  Registry.getComponentMethod('calendars', 'handleDefaults')(layoutIn, layoutOut, 'calendar');
  Registry.getComponentMethod('fx', 'supplyLayoutGlobalDefaults')(layoutIn, layoutOut, coerce);
  Lib.coerce(layoutIn, layoutOut, scatterAttrs, 'scattermode');
};
function getComputedSize(attr) {
  return typeof attr === 'string' && attr.substr(attr.length - 2) === 'px' && parseFloat(attr);
}
plots.plotAutoSize = function plotAutoSize(gd, layout, fullLayout) {
  var context = gd._context || {};
  var frameMargins = context.frameMargins;
  var newWidth;
  var newHeight;
  var isPlotDiv = Lib.isPlotDiv(gd);
  if (isPlotDiv) gd.emit('plotly_autosize');

  // embedded in an iframe - just take the full iframe size
  // if we get to this point, with no aspect ratio restrictions
  if (context.fillFrame) {
    newWidth = window.innerWidth;
    newHeight = window.innerHeight;

    // somehow we get a few extra px height sometimes...
    // just hide it
    document.body.style.overflow = 'hidden';
  } else {
    // plotly.js - let the developers do what they want, either
    // provide height and width for the container div,
    // specify size in layout, or take the defaults,
    // but don't enforce any ratio restrictions
    var computedStyle = isPlotDiv ? window.getComputedStyle(gd) : {};
    newWidth = getComputedSize(computedStyle.width) || getComputedSize(computedStyle.maxWidth) || fullLayout.width;
    newHeight = getComputedSize(computedStyle.height) || getComputedSize(computedStyle.maxHeight) || fullLayout.height;
    if (isNumeric(frameMargins) && frameMargins > 0) {
      var factor = 1 - 2 * frameMargins;
      newWidth = Math.round(factor * newWidth);
      newHeight = Math.round(factor * newHeight);
    }
  }
  var minWidth = plots.layoutAttributes.width.min;
  var minHeight = plots.layoutAttributes.height.min;
  if (newWidth < minWidth) newWidth = minWidth;
  if (newHeight < minHeight) newHeight = minHeight;
  var widthHasChanged = !layout.width && Math.abs(fullLayout.width - newWidth) > 1;
  var heightHasChanged = !layout.height && Math.abs(fullLayout.height - newHeight) > 1;
  if (heightHasChanged || widthHasChanged) {
    if (widthHasChanged) fullLayout.width = newWidth;
    if (heightHasChanged) fullLayout.height = newHeight;
  }

  // cache initial autosize value, used in relayout when
  // width or height values are set to null
  if (!gd._initialAutoSize) {
    gd._initialAutoSize = {
      width: newWidth,
      height: newHeight
    };
  }
  plots.sanitizeMargins(fullLayout);
};
plots.supplyLayoutModuleDefaults = function (layoutIn, layoutOut, fullData, transitionData) {
  var componentsRegistry = Registry.componentsRegistry;
  var basePlotModules = layoutOut._basePlotModules;
  var component, i, _module;
  var Cartesian = Registry.subplotsRegistry.cartesian;

  // check if any components need to add more base plot modules
  // that weren't captured by traces
  for (component in componentsRegistry) {
    _module = componentsRegistry[component];
    if (_module.includeBasePlot) {
      _module.includeBasePlot(layoutIn, layoutOut);
    }
  }

  // make sure we *at least* have some cartesian axes
  if (!basePlotModules.length) {
    basePlotModules.push(Cartesian);
  }

  // ensure all cartesian axes have at least one subplot
  if (layoutOut._has('cartesian')) {
    Registry.getComponentMethod('grid', 'contentDefaults')(layoutIn, layoutOut);
    Cartesian.finalizeSubplots(layoutIn, layoutOut);
  }

  // sort subplot lists
  for (var subplotType in layoutOut._subplots) {
    layoutOut._subplots[subplotType].sort(Lib.subplotSort);
  }

  // base plot module layout defaults
  for (i = 0; i < basePlotModules.length; i++) {
    _module = basePlotModules[i];

    // e.g. pie does not have a layout-defaults step
    if (_module.supplyLayoutDefaults) {
      _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
    }
  }

  // trace module layout defaults
  // use _modules rather than _visibleModules so that even
  // legendonly traces can include settings - eg barmode, which affects
  // legend.traceorder default value.
  var modules = layoutOut._modules;
  for (i = 0; i < modules.length; i++) {
    _module = modules[i];
    if (_module.supplyLayoutDefaults) {
      _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
    }
  }

  // transform module layout defaults
  var transformModules = layoutOut._transformModules;
  for (i = 0; i < transformModules.length; i++) {
    _module = transformModules[i];
    if (_module.supplyLayoutDefaults) {
      _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData, transitionData);
    }
  }
  for (component in componentsRegistry) {
    _module = componentsRegistry[component];
    if (_module.supplyLayoutDefaults) {
      _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
    }
  }
};

// Remove all plotly attributes from a div so it can be replotted fresh
// TODO: these really need to be encapsulated into a much smaller set...
plots.purge = function (gd) {
  // note: we DO NOT remove _context because it doesn't change when we insert
  // a new plot, and may have been set outside of our scope.

  var fullLayout = gd._fullLayout || {};
  if (fullLayout._glcontainer !== undefined) {
    fullLayout._glcontainer.selectAll('.gl-canvas').remove();
    fullLayout._glcontainer.remove();
    fullLayout._glcanvas = null;
  }

  // remove modebar
  if (fullLayout._modeBar) fullLayout._modeBar.destroy();
  if (gd._transitionData) {
    // Ensure any dangling callbacks are simply dropped if the plot is purged.
    // This is more or less only actually important for testing.
    if (gd._transitionData._interruptCallbacks) {
      gd._transitionData._interruptCallbacks.length = 0;
    }
    if (gd._transitionData._animationRaf) {
      window.cancelAnimationFrame(gd._transitionData._animationRaf);
    }
  }

  // remove any planned throttles
  Lib.clearThrottle();

  // remove responsive handler
  Lib.clearResponsive(gd);

  // data and layout
  delete gd.data;
  delete gd.layout;
  delete gd._fullData;
  delete gd._fullLayout;
  delete gd.calcdata;
  delete gd.empty;
  delete gd.fid;
  delete gd.undoqueue; // action queue
  delete gd.undonum;
  delete gd.autoplay; // are we doing an action that doesn't go in undo queue?
  delete gd.changed;

  // these get recreated on _doPlot anyway, but just to be safe
  // (and to have a record of them...)
  delete gd._promises;
  delete gd._redrawTimer;
  delete gd._hmlumcount;
  delete gd._hmpixcount;
  delete gd._transitionData;
  delete gd._transitioning;
  delete gd._initialAutoSize;
  delete gd._transitioningWithDuration;

  // created during certain events, that *should* clean them up
  // themselves, but may not if there was an error
  delete gd._dragging;
  delete gd._dragged;
  delete gd._dragdata;
  delete gd._hoverdata;
  delete gd._snapshotInProgress;
  delete gd._editing;
  delete gd._mouseDownTime;
  delete gd._legendMouseDownTime;

  // remove all event listeners
  if (gd.removeAllListeners) gd.removeAllListeners();
};
plots.style = function (gd) {
  var _modules = gd._fullLayout._visibleModules;
  var styleModules = [];
  var i;

  // some trace modules reuse the same style method,
  // make sure to not unnecessary call them multiple times.

  for (i = 0; i < _modules.length; i++) {
    var _module = _modules[i];
    if (_module.style) {
      Lib.pushUnique(styleModules, _module.style);
    }
  }
  for (i = 0; i < styleModules.length; i++) {
    styleModules[i](gd);
  }
};
plots.sanitizeMargins = function (fullLayout) {
  // polar doesn't do margins...
  if (!fullLayout || !fullLayout.margin) return;
  var width = fullLayout.width;
  var height = fullLayout.height;
  var margin = fullLayout.margin;
  var plotWidth = width - (margin.l + margin.r);
  var plotHeight = height - (margin.t + margin.b);
  var correction;

  // if margin.l + margin.r = 0 then plotWidth > 0
  // as width >= 10 by supplyDefaults
  // similarly for margin.t + margin.b

  if (plotWidth < 0) {
    correction = (width - 1) / (margin.l + margin.r);
    margin.l = Math.floor(correction * margin.l);
    margin.r = Math.floor(correction * margin.r);
  }
  if (plotHeight < 0) {
    correction = (height - 1) / (margin.t + margin.b);
    margin.t = Math.floor(correction * margin.t);
    margin.b = Math.floor(correction * margin.b);
  }
};
plots.clearAutoMarginIds = function (gd) {
  gd._fullLayout._pushmarginIds = {};
};
plots.allowAutoMargin = function (gd, id) {
  gd._fullLayout._pushmarginIds[id] = 1;
};
function initMargins(fullLayout) {
  var margin = fullLayout.margin;
  if (!fullLayout._size) {
    var gs = fullLayout._size = {
      l: Math.round(margin.l),
      r: Math.round(margin.r),
      t: Math.round(margin.t),
      b: Math.round(margin.b),
      p: Math.round(margin.pad)
    };
    gs.w = Math.round(fullLayout.width) - gs.l - gs.r;
    gs.h = Math.round(fullLayout.height) - gs.t - gs.b;
  }
  if (!fullLayout._pushmargin) fullLayout._pushmargin = {};
  if (!fullLayout._pushmarginIds) fullLayout._pushmarginIds = {};
  if (!fullLayout._reservedMargin) fullLayout._reservedMargin = {};
}

// non-negotiable - this is the smallest height we will allow users to specify via explicit margins
var MIN_SPECIFIED_WIDTH = 2;
var MIN_SPECIFIED_HEIGHT = 2;

/**
 * autoMargin: called by components that may need to expand the margins to
 * be rendered on-plot.
 *
 * @param {DOM element} gd
 * @param {string} id - an identifier unique (within this plot) to this object,
 *     so we can remove a previous margin expansion from the same object.
 * @param {object} o - the margin requirements of this object, or omit to delete
 *     this entry (like if it's hidden). Keys are:
 *     x, y: plot fraction of the anchor point.
 *     xl, xr, yt, yb: if the object has an extent defined in plot fraction,
 *         you can specify both edges as plot fractions in each dimension
 *     l, r, t, b: the pixels to pad past the plot fraction x[l|r] and y[t|b]
 *     pad: extra pixels to add in all directions, default 12 (why?)
 */
plots.autoMargin = function (gd, id, o) {
  var fullLayout = gd._fullLayout;
  var width = fullLayout.width;
  var height = fullLayout.height;
  var margin = fullLayout.margin;
  var minreducedwidth = fullLayout.minreducedwidth;
  var minreducedheight = fullLayout.minreducedheight;
  var minFinalWidth = Lib.constrain(width - margin.l - margin.r, MIN_SPECIFIED_WIDTH, minreducedwidth);
  var minFinalHeight = Lib.constrain(height - margin.t - margin.b, MIN_SPECIFIED_HEIGHT, minreducedheight);
  var maxSpaceW = Math.max(0, width - minFinalWidth);
  var maxSpaceH = Math.max(0, height - minFinalHeight);
  var pushMargin = fullLayout._pushmargin;
  var pushMarginIds = fullLayout._pushmarginIds;
  if (margin.autoexpand !== false) {
    if (!o) {
      delete pushMargin[id];
      delete pushMarginIds[id];
    } else {
      var pad = o.pad;
      if (pad === undefined) {
        // if no explicit pad is given, use 12px unless there's a
        // specified margin that's smaller than that
        pad = Math.min(12, margin.l, margin.r, margin.t, margin.b);
      }

      // if the item is too big, just give it enough automargin to
      // make sure you can still grab it and bring it back
      if (maxSpaceW) {
        var rW = (o.l + o.r) / maxSpaceW;
        if (rW > 1) {
          o.l /= rW;
          o.r /= rW;
        }
      }
      if (maxSpaceH) {
        var rH = (o.t + o.b) / maxSpaceH;
        if (rH > 1) {
          o.t /= rH;
          o.b /= rH;
        }
      }
      var xl = o.xl !== undefined ? o.xl : o.x;
      var xr = o.xr !== undefined ? o.xr : o.x;
      var yt = o.yt !== undefined ? o.yt : o.y;
      var yb = o.yb !== undefined ? o.yb : o.y;
      pushMargin[id] = {
        l: {
          val: xl,
          size: o.l + pad
        },
        r: {
          val: xr,
          size: o.r + pad
        },
        b: {
          val: yb,
          size: o.b + pad
        },
        t: {
          val: yt,
          size: o.t + pad
        }
      };
      pushMarginIds[id] = 1;
    }
    if (!fullLayout._replotting) {
      return plots.doAutoMargin(gd);
    }
  }
};
function needsRedrawForShift(gd) {
  if ('_redrawFromAutoMarginCount' in gd._fullLayout) {
    return false;
  }
  var axList = axisIDs.list(gd, '', true);
  for (var ax in axList) {
    if (axList[ax].autoshift || axList[ax].shift) return true;
  }
  return false;
}
plots.doAutoMargin = function (gd) {
  var fullLayout = gd._fullLayout;
  var width = fullLayout.width;
  var height = fullLayout.height;
  if (!fullLayout._size) fullLayout._size = {};
  initMargins(fullLayout);
  var gs = fullLayout._size;
  var margin = fullLayout.margin;
  var reservedMargins = {
    t: 0,
    b: 0,
    l: 0,
    r: 0
  };
  var oldMargins = Lib.extendFlat({}, gs);

  // adjust margins for outside components
  // fullLayout.margin is the requested margin,
  // fullLayout._size has margins and plotsize after adjustment
  var ml = margin.l;
  var mr = margin.r;
  var mt = margin.t;
  var mb = margin.b;
  var pushMargin = fullLayout._pushmargin;
  var pushMarginIds = fullLayout._pushmarginIds;
  var minreducedwidth = fullLayout.minreducedwidth;
  var minreducedheight = fullLayout.minreducedheight;
  if (margin.autoexpand !== false) {
    for (var k in pushMargin) {
      if (!pushMarginIds[k]) delete pushMargin[k];
    }
    var margins = gd._fullLayout._reservedMargin;
    for (var key in margins) {
      for (var side in margins[key]) {
        var val = margins[key][side];
        reservedMargins[side] = Math.max(reservedMargins[side], val);
      }
    }
    // fill in the requested margins
    pushMargin.base = {
      l: {
        val: 0,
        size: ml
      },
      r: {
        val: 1,
        size: mr
      },
      t: {
        val: 1,
        size: mt
      },
      b: {
        val: 0,
        size: mb
      }
    };

    // make sure that the reservedMargin is the minimum needed
    for (var s in reservedMargins) {
      var autoMarginPush = 0;
      for (var m in pushMargin) {
        if (m !== 'base') {
          if (isNumeric(pushMargin[m][s].size)) {
            autoMarginPush = pushMargin[m][s].size > autoMarginPush ? pushMargin[m][s].size : autoMarginPush;
          }
        }
      }
      var extraMargin = Math.max(0, margin[s] - autoMarginPush);
      reservedMargins[s] = Math.max(0, reservedMargins[s] - extraMargin);
    }

    // now cycle through all the combinations of l and r
    // (and t and b) to find the required margins
    for (var k1 in pushMargin) {
      var pushleft = pushMargin[k1].l || {};
      var pushbottom = pushMargin[k1].b || {};
      var fl = pushleft.val;
      var pl = pushleft.size;
      var fb = pushbottom.val;
      var pb = pushbottom.size;
      var availableWidth = width - reservedMargins.r - reservedMargins.l;
      var availableHeight = height - reservedMargins.t - reservedMargins.b;
      for (var k2 in pushMargin) {
        if (isNumeric(pl) && pushMargin[k2].r) {
          var fr = pushMargin[k2].r.val;
          var pr = pushMargin[k2].r.size;
          if (fr > fl) {
            var newL = (pl * fr + (pr - availableWidth) * fl) / (fr - fl);
            var newR = (pr * (1 - fl) + (pl - availableWidth) * (1 - fr)) / (fr - fl);
            if (newL + newR > ml + mr) {
              ml = newL;
              mr = newR;
            }
          }
        }
        if (isNumeric(pb) && pushMargin[k2].t) {
          var ft = pushMargin[k2].t.val;
          var pt = pushMargin[k2].t.size;
          if (ft > fb) {
            var newB = (pb * ft + (pt - availableHeight) * fb) / (ft - fb);
            var newT = (pt * (1 - fb) + (pb - availableHeight) * (1 - ft)) / (ft - fb);
            if (newB + newT > mb + mt) {
              mb = newB;
              mt = newT;
            }
          }
        }
      }
    }
  }
  var minFinalWidth = Lib.constrain(width - margin.l - margin.r, MIN_SPECIFIED_WIDTH, minreducedwidth);
  var minFinalHeight = Lib.constrain(height - margin.t - margin.b, MIN_SPECIFIED_HEIGHT, minreducedheight);
  var maxSpaceW = Math.max(0, width - minFinalWidth);
  var maxSpaceH = Math.max(0, height - minFinalHeight);
  if (maxSpaceW) {
    var rW = (ml + mr) / maxSpaceW;
    if (rW > 1) {
      ml /= rW;
      mr /= rW;
    }
  }
  if (maxSpaceH) {
    var rH = (mb + mt) / maxSpaceH;
    if (rH > 1) {
      mb /= rH;
      mt /= rH;
    }
  }
  gs.l = Math.round(ml) + reservedMargins.l;
  gs.r = Math.round(mr) + reservedMargins.r;
  gs.t = Math.round(mt) + reservedMargins.t;
  gs.b = Math.round(mb) + reservedMargins.b;
  gs.p = Math.round(margin.pad);
  gs.w = Math.round(width) - gs.l - gs.r;
  gs.h = Math.round(height) - gs.t - gs.b;

  // if things changed and we're not already redrawing, trigger a redraw
  if (!fullLayout._replotting && (plots.didMarginChange(oldMargins, gs) || needsRedrawForShift(gd))) {
    if ('_redrawFromAutoMarginCount' in fullLayout) {
      fullLayout._redrawFromAutoMarginCount++;
    } else {
      fullLayout._redrawFromAutoMarginCount = 1;
    }

    // Always allow at least one redraw and give each margin-push
    // call 3 loops to converge. Of course, for most cases this way too many,
    // but let's keep things on the safe side until we fix our
    // auto-margin pipeline problems:
    // https://github.com/plotly/plotly.js/issues/2704
    var maxNumberOfRedraws = 3 * (1 + Object.keys(pushMarginIds).length);
    if (fullLayout._redrawFromAutoMarginCount < maxNumberOfRedraws) {
      return Registry.call('_doPlot', gd);
    } else {
      fullLayout._size = oldMargins;
      Lib.warn('Too many auto-margin redraws.');
    }
  }
  refineTicks(gd);
};
function refineTicks(gd) {
  var axList = axisIDs.list(gd, '', true);
  ['_adjustTickLabelsOverflow', '_hideCounterAxisInsideTickLabels'].forEach(function (k) {
    for (var i = 0; i < axList.length; i++) {
      var hideFn = axList[i][k];
      if (hideFn) hideFn();
    }
  });
}
var marginKeys = ['l', 'r', 't', 'b', 'p', 'w', 'h'];
plots.didMarginChange = function (margin0, margin1) {
  for (var i = 0; i < marginKeys.length; i++) {
    var k = marginKeys[i];
    var m0 = margin0[k];
    var m1 = margin1[k];
    // use 1px tolerance in case we old/new differ only
    // by rounding errors, which can lead to infinite loops
    if (!isNumeric(m0) || Math.abs(m1 - m0) > 1) {
      return true;
    }
  }
  return false;
};

/**
 * JSONify the graph data and layout
 *
 * This function needs to recurse because some src can be inside
 * sub-objects.
 *
 * It also strips out functions and private (starts with _) elements.
 * Therefore, we can add temporary things to data and layout that don't
 * get saved.
 *
 * @param gd The graphDiv
 * @param {Boolean} dataonly If true, don't return layout.
 * @param {'keepref'|'keepdata'|'keepall'} [mode='keepref'] Filter what's kept
 *      keepref: remove data for which there's a src present
 *          eg if there's xsrc present (and xsrc is well-formed,
 *          ie has : and some chars before it), strip out x
 *      keepdata: remove all src tags, don't remove the data itself
 *      keepall: keep data and src
 * @param {String} output If you specify 'object', the result will not be stringified
 * @param {Boolean} useDefaults If truthy, use _fullLayout and _fullData
 * @param {Boolean} includeConfig If truthy, include _context
 * @returns {Object|String}
 */
plots.graphJson = function (gd, dataonly, mode, output, useDefaults, includeConfig) {
  // if the defaults aren't supplied yet, we need to do that...
  if (useDefaults && dataonly && !gd._fullData || useDefaults && !dataonly && !gd._fullLayout) {
    plots.supplyDefaults(gd);
  }
  var data = useDefaults ? gd._fullData : gd.data;
  var layout = useDefaults ? gd._fullLayout : gd.layout;
  var frames = (gd._transitionData || {})._frames;
  function stripObj(d, keepFunction) {
    if (typeof d === 'function') {
      return keepFunction ? '_function_' : null;
    }
    if (Lib.isPlainObject(d)) {
      var o = {};
      var src;
      Object.keys(d).sort().forEach(function (v) {
        // remove private elements and functions
        // _ is for private, [ is a mistake ie [object Object]
        if (['_', '['].indexOf(v.charAt(0)) !== -1) return;

        // if a function, add if necessary then move on
        if (typeof d[v] === 'function') {
          if (keepFunction) o[v] = '_function';
          return;
        }

        // look for src/data matches and remove the appropriate one
        if (mode === 'keepdata') {
          // keepdata: remove all ...src tags
          if (v.substr(v.length - 3) === 'src') {
            return;
          }
        } else if (mode === 'keepstream') {
          // keep sourced data if it's being streamed.
          // similar to keepref, but if the 'stream' object exists
          // in a trace, we will keep the data array.
          src = d[v + 'src'];
          if (typeof src === 'string' && src.indexOf(':') > 0) {
            if (!Lib.isPlainObject(d.stream)) {
              return;
            }
          }
        } else if (mode !== 'keepall') {
          // keepref: remove sourced data but only
          // if the source tag is well-formed
          src = d[v + 'src'];
          if (typeof src === 'string' && src.indexOf(':') > 0) {
            return;
          }
        }

        // OK, we're including this... recurse into it
        o[v] = stripObj(d[v], keepFunction);
      });
      return o;
    }
    if (Array.isArray(d)) {
      return d.map(function (x) {
        return stripObj(x, keepFunction);
      });
    }
    if (Lib.isTypedArray(d)) {
      return Lib.simpleMap(d, Lib.identity);
    }

    // convert native dates to date strings...
    // mostly for external users exporting to plotly
    if (Lib.isJSDate(d)) return Lib.ms2DateTimeLocal(+d);
    return d;
  }
  var obj = {
    data: (data || []).map(function (v) {
      var d = stripObj(v);
      // fit has some little arrays in it that don't contain data,
      // just fit params and meta
      if (dataonly) {
        delete d.fit;
      }
      return d;
    })
  };
  if (!dataonly) {
    obj.layout = stripObj(layout);
    if (useDefaults) {
      var gs = layout._size;
      obj.layout.computed = {
        margin: {
          b: gs.b,
          l: gs.l,
          r: gs.r,
          t: gs.t
        }
      };
    }
  }
  if (frames) obj.frames = stripObj(frames);
  if (includeConfig) obj.config = stripObj(gd._context, true);
  return output === 'object' ? obj : JSON.stringify(obj);
};

/**
 * Modify a keyframe using a list of operations:
 *
 * @param {array of objects} operations
 *      Sequence of operations to be performed on the keyframes
 */
plots.modifyFrames = function (gd, operations) {
  var i, op, frame;
  var _frames = gd._transitionData._frames;
  var _frameHash = gd._transitionData._frameHash;
  for (i = 0; i < operations.length; i++) {
    op = operations[i];
    switch (op.type) {
      // No reason this couldn't exist, but is currently unused/untested:
      /* case 'rename':
          frame = _frames[op.index];
          delete _frameHash[frame.name];
          _frameHash[op.name] = frame;
          frame.name = op.name;
          break;*/
      case 'replace':
        frame = op.value;
        var oldName = (_frames[op.index] || {}).name;
        var newName = frame.name;
        _frames[op.index] = _frameHash[newName] = frame;
        if (newName !== oldName) {
          // If name has changed in addition to replacement, then update
          // the lookup table:
          delete _frameHash[oldName];
          _frameHash[newName] = frame;
        }
        break;
      case 'insert':
        frame = op.value;
        _frameHash[frame.name] = frame;
        _frames.splice(op.index, 0, frame);
        break;
      case 'delete':
        frame = _frames[op.index];
        delete _frameHash[frame.name];
        _frames.splice(op.index, 1);
        break;
    }
  }
  return Promise.resolve();
};

/*
 * Compute a keyframe. Merge a keyframe into its base frame(s) and
 * expand properties.
 *
 * @param {object} frameLookup
 *      An object containing frames keyed by name (i.e. gd._transitionData._frameHash)
 * @param {string} frame
 *      The name of the keyframe to be computed
 *
 * Returns: a new object with the merged content
 */
plots.computeFrame = function (gd, frameName) {
  var frameLookup = gd._transitionData._frameHash;
  var i, traceIndices, traceIndex, destIndex;

  // Null or undefined will fail on .toString(). We'll allow numbers since we
  // make it clear frames must be given string names, but we'll allow numbers
  // here since they're otherwise fine for looking up frames as long as they're
  // properly cast to strings. We really just want to ensure here that this
  // 1) doesn't fail, and
  // 2) doens't give an incorrect answer (which String(frameName) would)
  if (!frameName) {
    throw new Error('computeFrame must be given a string frame name');
  }
  var framePtr = frameLookup[frameName.toString()];

  // Return false if the name is invalid:
  if (!framePtr) {
    return false;
  }
  var frameStack = [framePtr];
  var frameNameStack = [framePtr.name];

  // Follow frame pointers:
  while (framePtr.baseframe && (framePtr = frameLookup[framePtr.baseframe.toString()])) {
    // Avoid infinite loops:
    if (frameNameStack.indexOf(framePtr.name) !== -1) break;
    frameStack.push(framePtr);
    frameNameStack.push(framePtr.name);
  }

  // A new object for the merged result:
  var result = {};

  // Merge, starting with the last and ending with the desired frame:
  while (framePtr = frameStack.pop()) {
    if (framePtr.layout) {
      result.layout = plots.extendLayout(result.layout, framePtr.layout);
    }
    if (framePtr.data) {
      if (!result.data) {
        result.data = [];
      }
      traceIndices = framePtr.traces;
      if (!traceIndices) {
        // If not defined, assume serial order starting at zero
        traceIndices = [];
        for (i = 0; i < framePtr.data.length; i++) {
          traceIndices[i] = i;
        }
      }
      if (!result.traces) {
        result.traces = [];
      }
      for (i = 0; i < framePtr.data.length; i++) {
        // Loop through this frames data, find out where it should go,
        // and merge it!
        traceIndex = traceIndices[i];
        if (traceIndex === undefined || traceIndex === null) {
          continue;
        }
        destIndex = result.traces.indexOf(traceIndex);
        if (destIndex === -1) {
          destIndex = result.data.length;
          result.traces[destIndex] = traceIndex;
        }
        result.data[destIndex] = plots.extendTrace(result.data[destIndex], framePtr.data[i]);
      }
    }
  }
  return result;
};

/*
 * Recompute the lookup table that maps frame name -> frame object. addFrames/
 * deleteFrames already manages this data one at a time, so the only time this
 * is necessary is if you poke around manually in `gd._transitionData._frames`
 * and create and haven't updated the lookup table.
 */
plots.recomputeFrameHash = function (gd) {
  var hash = gd._transitionData._frameHash = {};
  var frames = gd._transitionData._frames;
  for (var i = 0; i < frames.length; i++) {
    var frame = frames[i];
    if (frame && frame.name) {
      hash[frame.name] = frame;
    }
  }
};

/**
 * Extend an object, treating container arrays very differently by extracting
 * their contents and merging them separately.
 *
 * This exists so that we can extendDeepNoArrays and avoid stepping into data
 * arrays without knowledge of the plot schema, but so that we may also manually
 * recurse into known container arrays, such as transforms.
 *
 * See extendTrace and extendLayout below for usage.
 */
plots.extendObjectWithContainers = function (dest, src, containerPaths) {
  var containerProp, containerVal, i, j, srcProp, destProp, srcContainer, destContainer;
  var copy = Lib.extendDeepNoArrays({}, src || {});
  var expandedObj = Lib.expandObjectPaths(copy);
  var containerObj = {};

  // Step through and extract any container properties. Otherwise extendDeepNoArrays
  // will clobber any existing properties with an empty array and then supplyDefaults
  // will reset everything to defaults.
  if (containerPaths && containerPaths.length) {
    for (i = 0; i < containerPaths.length; i++) {
      containerProp = Lib.nestedProperty(expandedObj, containerPaths[i]);
      containerVal = containerProp.get();
      if (containerVal === undefined) {
        Lib.nestedProperty(containerObj, containerPaths[i]).set(null);
      } else {
        containerProp.set(null);
        Lib.nestedProperty(containerObj, containerPaths[i]).set(containerVal);
      }
    }
  }
  dest = Lib.extendDeepNoArrays(dest || {}, expandedObj);
  if (containerPaths && containerPaths.length) {
    for (i = 0; i < containerPaths.length; i++) {
      srcProp = Lib.nestedProperty(containerObj, containerPaths[i]);
      srcContainer = srcProp.get();
      if (!srcContainer) continue;
      destProp = Lib.nestedProperty(dest, containerPaths[i]);
      destContainer = destProp.get();
      if (!Array.isArray(destContainer)) {
        destContainer = [];
        destProp.set(destContainer);
      }
      for (j = 0; j < srcContainer.length; j++) {
        var srcObj = srcContainer[j];
        if (srcObj === null) destContainer[j] = null;else {
          destContainer[j] = plots.extendObjectWithContainers(destContainer[j], srcObj);
        }
      }
      destProp.set(destContainer);
    }
  }
  return dest;
};
plots.dataArrayContainers = ['transforms', 'dimensions'];
plots.layoutArrayContainers = Registry.layoutArrayContainers;

/*
 * Extend a trace definition. This method:
 *
 *  1. directly transfers any array references
 *  2. manually recurses into container arrays like transforms
 *
 * The result is the original object reference with the new contents merged in.
 */
plots.extendTrace = function (destTrace, srcTrace) {
  return plots.extendObjectWithContainers(destTrace, srcTrace, plots.dataArrayContainers);
};

/*
 * Extend a layout definition. This method:
 *
 *  1. directly transfers any array references (not critically important for
 *     layout since there aren't really data arrays)
 *  2. manually recurses into container arrays like annotations
 *
 * The result is the original object reference with the new contents merged in.
 */
plots.extendLayout = function (destLayout, srcLayout) {
  return plots.extendObjectWithContainers(destLayout, srcLayout, plots.layoutArrayContainers);
};

/**
 * Transition to a set of new data and layout properties from Plotly.animate
 *
 * @param {DOM element} gd
 * @param {Object[]} data
 *      an array of data objects following the normal Plotly data definition format
 * @param {Object} layout
 *      a layout object, following normal Plotly layout format
 * @param {Number[]} traces
 *      indices of the corresponding traces specified in `data`
 * @param {Object} frameOpts
 *      options for the frame (i.e. whether to redraw post-transition)
 * @param {Object} transitionOpts
 *      options for the transition
 */
plots.transition = function (gd, data, layout, traces, frameOpts, transitionOpts) {
  var opts = {
    redraw: frameOpts.redraw
  };
  var transitionedTraces = {};
  var axEdits = [];
  opts.prepareFn = function () {
    var dataLength = Array.isArray(data) ? data.length : 0;
    var traceIndices = traces.slice(0, dataLength);
    for (var i = 0; i < traceIndices.length; i++) {
      var traceIdx = traceIndices[i];
      var trace = gd._fullData[traceIdx];
      var _module = trace._module;

      // There's nothing to do if this module is not defined:
      if (!_module) continue;

      // Don't register the trace as transitioned if it doesn't know what to do.
      // If it *is* registered, it will receive a callback that it's responsible
      // for calling in order to register the transition as having completed.
      if (_module.animatable) {
        var n = _module.basePlotModule.name;
        if (!transitionedTraces[n]) transitionedTraces[n] = [];
        transitionedTraces[n].push(traceIdx);
      }
      gd.data[traceIndices[i]] = plots.extendTrace(gd.data[traceIndices[i]], data[i]);
    }

    // Follow the same procedure. Clone it so we don't mangle the input, then
    // expand any object paths so we can merge deep into gd.layout:
    var layoutUpdate = Lib.expandObjectPaths(Lib.extendDeepNoArrays({}, layout));

    // Before merging though, we need to modify the incoming layout. We only
    // know how to *transition* layout ranges, so it's imperative that a new
    // range not be sent to the layout before the transition has started. So
    // we must remove the things we can transition:
    var axisAttrRe = /^[xy]axis[0-9]*$/;
    for (var attr in layoutUpdate) {
      if (!axisAttrRe.test(attr)) continue;
      delete layoutUpdate[attr].range;
    }
    plots.extendLayout(gd.layout, layoutUpdate);

    // Supply defaults after applying the incoming properties. Note that any attempt
    // to simplify this step and reduce the amount of work resulted in the reconstruction
    // of essentially the whole supplyDefaults step, so that it seems sensible to just use
    // supplyDefaults even though it's heavier than would otherwise be desired for
    // transitions:

    // first delete calcdata so supplyDefaults knows a calc step is coming
    delete gd.calcdata;
    plots.supplyDefaults(gd);
    plots.doCalcdata(gd);
    var newLayout = Lib.expandObjectPaths(layout);
    if (newLayout) {
      var subplots = gd._fullLayout._plots;
      for (var k in subplots) {
        var plotinfo = subplots[k];
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var xr0 = xa.range.slice();
        var yr0 = ya.range.slice();
        var xr1 = null;
        var yr1 = null;
        var editX = null;
        var editY = null;
        if (Array.isArray(newLayout[xa._name + '.range'])) {
          xr1 = newLayout[xa._name + '.range'].slice();
        } else if (Array.isArray((newLayout[xa._name] || {}).range)) {
          xr1 = newLayout[xa._name].range.slice();
        }
        if (Array.isArray(newLayout[ya._name + '.range'])) {
          yr1 = newLayout[ya._name + '.range'].slice();
        } else if (Array.isArray((newLayout[ya._name] || {}).range)) {
          yr1 = newLayout[ya._name].range.slice();
        }
        if (xr0 && xr1 && (xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1]))) {
          editX = {
            xr0: xr0,
            xr1: xr1
          };
        }
        if (yr0 && yr1 && (ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1]))) {
          editY = {
            yr0: yr0,
            yr1: yr1
          };
        }
        if (editX || editY) {
          axEdits.push(Lib.extendFlat({
            plotinfo: plotinfo
          }, editX, editY));
        }
      }
    }
    return Promise.resolve();
  };
  opts.runFn = function (makeCallback) {
    var traceTransitionOpts;
    var basePlotModules = gd._fullLayout._basePlotModules;
    var hasAxisTransition = axEdits.length;
    var i;
    if (layout) {
      for (i = 0; i < basePlotModules.length; i++) {
        if (basePlotModules[i].transitionAxes) {
          basePlotModules[i].transitionAxes(gd, axEdits, transitionOpts, makeCallback);
        }
      }
    }

    // Here handle the exception that we refuse to animate scales and axes at the same
    // time. In other words, if there's an axis transition, then set the data transition
    // to instantaneous.
    if (hasAxisTransition) {
      traceTransitionOpts = Lib.extendFlat({}, transitionOpts);
      traceTransitionOpts.duration = 0;
      // This means do not transition cartesian traces,
      // this happens on layout-only (e.g. axis range) animations
      delete transitionedTraces.cartesian;
    } else {
      traceTransitionOpts = transitionOpts;
    }

    // Note that we pass a callback to *create* the callback that must be invoked on completion.
    // This is since not all traces know about transitions, so it greatly simplifies matters if
    // the trace is responsible for creating a callback, if needed, and then executing it when
    // the time is right.
    for (var n in transitionedTraces) {
      var traceIndices = transitionedTraces[n];
      var _module = gd._fullData[traceIndices[0]]._module;
      _module.basePlotModule.plot(gd, traceIndices, traceTransitionOpts, makeCallback);
    }
  };
  return _transition(gd, transitionOpts, opts);
};

/**
 * Transition to a set of new data and layout properties from Plotly.react
 *
 * @param {DOM element} gd
 * @param {object} restyleFlags
 * - anim {'all'|'some'}
 * @param {object} relayoutFlags
 * - anim {'all'|'some'}
 * @param {object} oldFullLayout : old (pre Plotly.react) fullLayout
 */
plots.transitionFromReact = function (gd, restyleFlags, relayoutFlags, oldFullLayout) {
  var fullLayout = gd._fullLayout;
  var transitionOpts = fullLayout.transition;
  var opts = {};
  var axEdits = [];
  opts.prepareFn = function () {
    var subplots = fullLayout._plots;

    // no need to redraw at end of transition,
    // if all changes are animatable
    opts.redraw = false;
    if (restyleFlags.anim === 'some') opts.redraw = true;
    if (relayoutFlags.anim === 'some') opts.redraw = true;
    for (var k in subplots) {
      var plotinfo = subplots[k];
      var xa = plotinfo.xaxis;
      var ya = plotinfo.yaxis;
      var xr0 = oldFullLayout[xa._name].range.slice();
      var yr0 = oldFullLayout[ya._name].range.slice();
      var xr1 = xa.range.slice();
      var yr1 = ya.range.slice();
      xa.setScale();
      ya.setScale();
      var editX = null;
      var editY = null;
      if (xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1])) {
        editX = {
          xr0: xr0,
          xr1: xr1
        };
      }
      if (ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1])) {
        editY = {
          yr0: yr0,
          yr1: yr1
        };
      }
      if (editX || editY) {
        axEdits.push(Lib.extendFlat({
          plotinfo: plotinfo
        }, editX, editY));
      }
    }
    return Promise.resolve();
  };
  opts.runFn = function (makeCallback) {
    var fullData = gd._fullData;
    var fullLayout = gd._fullLayout;
    var basePlotModules = fullLayout._basePlotModules;
    var axisTransitionOpts;
    var traceTransitionOpts;
    var transitionedTraces;
    var allTraceIndices = [];
    for (var i = 0; i < fullData.length; i++) {
      allTraceIndices.push(i);
    }
    function transitionAxes() {
      if (!gd._fullLayout) return;
      for (var j = 0; j < basePlotModules.length; j++) {
        if (basePlotModules[j].transitionAxes) {
          basePlotModules[j].transitionAxes(gd, axEdits, axisTransitionOpts, makeCallback);
        }
      }
    }
    function transitionTraces() {
      if (!gd._fullLayout) return;
      for (var j = 0; j < basePlotModules.length; j++) {
        basePlotModules[j].plot(gd, transitionedTraces, traceTransitionOpts, makeCallback);
      }
    }
    if (axEdits.length && restyleFlags.anim) {
      if (transitionOpts.ordering === 'traces first') {
        axisTransitionOpts = Lib.extendFlat({}, transitionOpts, {
          duration: 0
        });
        transitionedTraces = allTraceIndices;
        traceTransitionOpts = transitionOpts;
        setTimeout(transitionAxes, transitionOpts.duration);
        transitionTraces();
      } else {
        axisTransitionOpts = transitionOpts;
        transitionedTraces = null;
        traceTransitionOpts = Lib.extendFlat({}, transitionOpts, {
          duration: 0
        });
        setTimeout(transitionTraces, axisTransitionOpts.duration);
        transitionAxes();
      }
    } else if (axEdits.length) {
      axisTransitionOpts = transitionOpts;
      transitionAxes();
    } else if (restyleFlags.anim) {
      transitionedTraces = allTraceIndices;
      traceTransitionOpts = transitionOpts;
      transitionTraces();
    }
  };
  return _transition(gd, transitionOpts, opts);
};

/**
 * trace/layout transition wrapper that works
 * for transitions initiated by Plotly.animate and Plotly.react.
 *
 * @param {DOM element} gd
 * @param {object} transitionOpts
 * @param {object} opts
 * - redraw {boolean}
 * - prepareFn {function} *should return a Promise*
 * - runFn {function} ran inside executeTransitions
 */
function _transition(gd, transitionOpts, opts) {
  var aborted = false;
  function executeCallbacks(list) {
    var p = Promise.resolve();
    if (!list) return p;
    while (list.length) {
      p = p.then(list.shift());
    }
    return p;
  }
  function flushCallbacks(list) {
    if (!list) return;
    while (list.length) {
      list.shift();
    }
  }
  function executeTransitions() {
    gd.emit('plotly_transitioning', []);
    return new Promise(function (resolve) {
      // This flag is used to disabled things like autorange:
      gd._transitioning = true;

      // When instantaneous updates are coming through quickly, it's too much to simply disable
      // all interaction, so store this flag so we can disambiguate whether mouse interactions
      // should be fully disabled or not:
      if (transitionOpts.duration > 0) {
        gd._transitioningWithDuration = true;
      }

      // If another transition is triggered, this callback will be executed simply because it's
      // in the interruptCallbacks queue. If this transition completes, it will instead flush
      // that queue and forget about this callback.
      gd._transitionData._interruptCallbacks.push(function () {
        aborted = true;
      });
      if (opts.redraw) {
        gd._transitionData._interruptCallbacks.push(function () {
          return Registry.call('redraw', gd);
        });
      }

      // Emit this and make sure it happens last:
      gd._transitionData._interruptCallbacks.push(function () {
        gd.emit('plotly_transitioninterrupted', []);
      });

      // Construct callbacks that are executed on transition end. This ensures the d3 transitions
      // are *complete* before anything else is done.
      var numCallbacks = 0;
      var numCompleted = 0;
      function makeCallback() {
        numCallbacks++;
        return function () {
          numCompleted++;
          // When all are complete, perform a redraw:
          if (!aborted && numCompleted === numCallbacks) {
            completeTransition(resolve);
          }
        };
      }
      opts.runFn(makeCallback);

      // If nothing else creates a callback, then this will trigger the completion in the next tick:
      setTimeout(makeCallback());
    });
  }
  function completeTransition(callback) {
    // This a simple workaround for tests which purge the graph before animations
    // have completed. That's not a very common case, so this is the simplest
    // fix.
    if (!gd._transitionData) return;
    flushCallbacks(gd._transitionData._interruptCallbacks);
    return Promise.resolve().then(function () {
      if (opts.redraw) {
        return Registry.call('redraw', gd);
      }
    }).then(function () {
      // Set transitioning false again once the redraw has occurred. This is used, for example,
      // to prevent the trailing redraw from autoranging:
      gd._transitioning = false;
      gd._transitioningWithDuration = false;
      gd.emit('plotly_transitioned', []);
    }).then(callback);
  }
  function interruptPreviousTransitions() {
    // Fail-safe against purged plot:
    if (!gd._transitionData) return;

    // If a transition is interrupted, set this to false. At the moment, the only thing that would
    // interrupt a transition is another transition, so that it will momentarily be set to true
    // again, but this determines whether autorange or dragbox work, so it's for the sake of
    // cleanliness:
    gd._transitioning = false;
    return executeCallbacks(gd._transitionData._interruptCallbacks);
  }
  var seq = [plots.previousPromises, interruptPreviousTransitions, opts.prepareFn, plots.rehover, plots.reselect, executeTransitions];
  var transitionStarting = Lib.syncOrAsync(seq, gd);
  if (!transitionStarting || !transitionStarting.then) {
    transitionStarting = Promise.resolve();
  }
  return transitionStarting.then(function () {
    return gd;
  });
}
plots.doCalcdata = function (gd, traces) {
  var axList = axisIDs.list(gd);
  var fullData = gd._fullData;
  var fullLayout = gd._fullLayout;
  var trace, _module, i, j;

  // XXX: Is this correct? Needs a closer look so that *some* traces can be recomputed without
  // *all* needing doCalcdata:
  var calcdata = new Array(fullData.length);
  var oldCalcdata = (gd.calcdata || []).slice();
  gd.calcdata = calcdata;

  // extra helper variables

  // how many box/violins plots do we have (in case they're grouped)
  fullLayout._numBoxes = 0;
  fullLayout._numViolins = 0;

  // initialize violin per-scale-group stats container
  fullLayout._violinScaleGroupStats = {};

  // for calculating avg luminosity of heatmaps
  gd._hmpixcount = 0;
  gd._hmlumcount = 0;

  // for sharing colors across pies / sunbursts / treemap / icicle / funnelarea (and for legend)
  fullLayout._piecolormap = {};
  fullLayout._sunburstcolormap = {};
  fullLayout._treemapcolormap = {};
  fullLayout._iciclecolormap = {};
  fullLayout._funnelareacolormap = {};

  // If traces were specified and this trace was not included,
  // then transfer it over from the old calcdata:
  for (i = 0; i < fullData.length; i++) {
    if (Array.isArray(traces) && traces.indexOf(i) === -1) {
      calcdata[i] = oldCalcdata[i];
      continue;
    }
  }
  for (i = 0; i < fullData.length; i++) {
    trace = fullData[i];
    trace._arrayAttrs = PlotSchema.findArrayAttributes(trace);

    // keep track of trace extremes (for autorange) in here
    trace._extremes = {};
  }

  // add polar axes to axis list
  var polarIds = fullLayout._subplots.polar || [];
  for (i = 0; i < polarIds.length; i++) {
    axList.push(fullLayout[polarIds[i]].radialaxis, fullLayout[polarIds[i]].angularaxis);
  }

  // clear relinked cmin/cmax values in shared axes to start aggregation from scratch
  for (var k in fullLayout._colorAxes) {
    var cOpts = fullLayout[k];
    if (cOpts.cauto !== false) {
      delete cOpts.cmin;
      delete cOpts.cmax;
    }
  }
  var hasCalcTransform = false;
  function transformCalci(i) {
    trace = fullData[i];
    _module = trace._module;
    if (trace.visible === true && trace.transforms) {
      // we need one round of trace module calc before
      // the calc transform to 'fill in' the categories list
      // used for example in the data-to-coordinate method
      if (_module && _module.calc) {
        var cdi = _module.calc(gd, trace);

        // must clear scene 'batches', so that 2nd
        // _module.calc call starts from scratch
        if (cdi[0] && cdi[0].t && cdi[0].t._scene) {
          delete cdi[0].t._scene.dirty;
        }
      }
      for (j = 0; j < trace.transforms.length; j++) {
        var transform = trace.transforms[j];
        _module = transformsRegistry[transform.type];
        if (_module && _module.calcTransform) {
          trace._hasCalcTransform = true;
          hasCalcTransform = true;
          _module.calcTransform(gd, trace, transform);
        }
      }
    }
  }
  function calci(i, isContainer) {
    trace = fullData[i];
    _module = trace._module;
    if (!!_module.isContainer !== isContainer) return;
    var cd = [];
    if (trace.visible === true && trace._length !== 0) {
      // clear existing ref in case it got relinked
      delete trace._indexToPoints;
      // keep ref of index-to-points map object of the *last* enabled transform,
      // this index-to-points map object is required to determine the calcdata indices
      // that correspond to input indices (e.g. from 'selectedpoints')
      var transforms = trace.transforms || [];
      for (j = transforms.length - 1; j >= 0; j--) {
        if (transforms[j].enabled) {
          trace._indexToPoints = transforms[j]._indexToPoints;
          break;
        }
      }
      if (_module && _module.calc) {
        cd = _module.calc(gd, trace);
      }
    }

    // Make sure there is a first point.
    //
    // This ensures there is a calcdata item for every trace,
    // even if cartesian logic doesn't handle it (for things like legends).
    if (!Array.isArray(cd) || !cd[0]) {
      cd = [{
        x: BADNUM,
        y: BADNUM
      }];
    }

    // add the trace-wide properties to the first point,
    // per point properties to every point
    // t is the holder for trace-wide properties
    if (!cd[0].t) cd[0].t = {};
    cd[0].trace = trace;
    calcdata[i] = cd;
  }
  setupAxisCategories(axList, fullData, fullLayout);

  // 'transform' loop - must calc container traces first
  // so that if their dependent traces can get transform properly
  for (i = 0; i < fullData.length; i++) calci(i, true);
  for (i = 0; i < fullData.length; i++) transformCalci(i);

  // clear stuff that should recomputed in 'regular' loop
  if (hasCalcTransform) setupAxisCategories(axList, fullData, fullLayout);

  // 'regular' loop - make sure container traces (eg carpet) calc before
  // contained traces (eg contourcarpet)
  for (i = 0; i < fullData.length; i++) calci(i, true);
  for (i = 0; i < fullData.length; i++) calci(i, false);
  doCrossTraceCalc(gd);

  // Sort axis categories per value if specified
  var sorted = sortAxisCategoriesByValue(axList, gd);
  if (sorted.length) {
    // how many box/violins plots do we have (in case they're grouped)
    fullLayout._numBoxes = 0;
    fullLayout._numViolins = 0;
    // If a sort operation was performed, run calc() again
    for (i = 0; i < sorted.length; i++) calci(sorted[i], true);
    for (i = 0; i < sorted.length; i++) calci(sorted[i], false);
    doCrossTraceCalc(gd);
  }
  Registry.getComponentMethod('fx', 'calc')(gd);
  Registry.getComponentMethod('errorbars', 'calc')(gd);
};
var sortAxisCategoriesByValueRegex = /(total|sum|min|max|mean|median) (ascending|descending)/;
function sortAxisCategoriesByValue(axList, gd) {
  var affectedTraces = [];
  var i, j, k, l, o;
  function zMapCategory(type, ax, value) {
    var axLetter = ax._id.charAt(0);
    if (type === 'histogram2dcontour') {
      var counterAxLetter = ax._counterAxes[0];
      var counterAx = axisIDs.getFromId(gd, counterAxLetter);
      var xCategorical = axLetter === 'x' || counterAxLetter === 'x' && counterAx.type === 'category';
      var yCategorical = axLetter === 'y' || counterAxLetter === 'y' && counterAx.type === 'category';
      return function (o, l) {
        if (o === 0 || l === 0) return -1; // Skip first row and column
        if (xCategorical && o === value[l].length - 1) return -1;
        if (yCategorical && l === value.length - 1) return -1;
        return (axLetter === 'y' ? l : o) - 1;
      };
    } else {
      return function (o, l) {
        return axLetter === 'y' ? l : o;
      };
    }
  }
  var aggFn = {
    min: function (values) {
      return Lib.aggNums(Math.min, null, values);
    },
    max: function (values) {
      return Lib.aggNums(Math.max, null, values);
    },
    sum: function (values) {
      return Lib.aggNums(function (a, b) {
        return a + b;
      }, null, values);
    },
    total: function (values) {
      return Lib.aggNums(function (a, b) {
        return a + b;
      }, null, values);
    },
    mean: function (values) {
      return Lib.mean(values);
    },
    median: function (values) {
      return Lib.median(values);
    }
  };
  function sortAscending(a, b) {
    return a[1] - b[1];
  }
  function sortDescending(a, b) {
    return b[1] - a[1];
  }
  for (i = 0; i < axList.length; i++) {
    var ax = axList[i];
    if (ax.type !== 'category') continue;

    // Order by value
    var match = ax.categoryorder.match(sortAxisCategoriesByValueRegex);
    if (match) {
      var aggregator = match[1];
      var order = match[2];
      var axLetter = ax._id.charAt(0);
      var isX = axLetter === 'x';

      // Store values associated with each category
      var categoriesValue = [];
      for (j = 0; j < ax._categories.length; j++) {
        categoriesValue.push([ax._categories[j], []]);
      }

      // Collect values across traces
      for (j = 0; j < ax._traceIndices.length; j++) {
        var traceIndex = ax._traceIndices[j];
        var fullTrace = gd._fullData[traceIndex];

        // Skip over invisible traces
        if (fullTrace.visible !== true) continue;
        var type = fullTrace.type;
        if (Registry.traceIs(fullTrace, 'histogram')) {
          delete fullTrace._xautoBinFinished;
          delete fullTrace._yautoBinFinished;
        }
        var isSplom = type === 'splom';
        var isScattergl = type === 'scattergl';
        var cd = gd.calcdata[traceIndex];
        for (k = 0; k < cd.length; k++) {
          var cdi = cd[k];
          var catIndex, value;
          if (isSplom) {
            // If `splom`, collect values across dimensions
            // Find which dimension the current axis is representing
            var currentDimensionIndex = fullTrace._axesDim[ax._id];

            // Apply logic to associated x axis if it's defined
            if (!isX) {
              var associatedXAxisID = fullTrace._diag[currentDimensionIndex][0];
              if (associatedXAxisID) ax = gd._fullLayout[axisIDs.id2name(associatedXAxisID)];
            }
            var categories = cdi.trace.dimensions[currentDimensionIndex].values;
            for (l = 0; l < categories.length; l++) {
              catIndex = ax._categoriesMap[categories[l]];

              // Collect associated values at index `l` over all other dimensions
              for (o = 0; o < cdi.trace.dimensions.length; o++) {
                if (o === currentDimensionIndex) continue;
                var dimension = cdi.trace.dimensions[o];
                categoriesValue[catIndex][1].push(dimension.values[l]);
              }
            }
          } else if (isScattergl) {
            // If `scattergl`, collect all values stashed under cdi.t
            for (l = 0; l < cdi.t.x.length; l++) {
              if (isX) {
                catIndex = cdi.t.x[l];
                value = cdi.t.y[l];
              } else {
                catIndex = cdi.t.y[l];
                value = cdi.t.x[l];
              }
              categoriesValue[catIndex][1].push(value);
            }
            // must clear scene 'batches', so that 2nd
            // _module.calc call starts from scratch
            if (cdi.t && cdi.t._scene) {
              delete cdi.t._scene.dirty;
            }
          } else if (cdi.hasOwnProperty('z')) {
            // If 2dMap, collect values in `z`
            value = cdi.z;
            var mapping = zMapCategory(fullTrace.type, ax, value);
            for (l = 0; l < value.length; l++) {
              for (o = 0; o < value[l].length; o++) {
                catIndex = mapping(o, l);
                if (catIndex + 1) categoriesValue[catIndex][1].push(value[l][o]);
              }
            }
          } else {
            // For all other 2d cartesian traces
            catIndex = cdi.p;
            if (catIndex === undefined) catIndex = cdi[axLetter];
            value = cdi.s;
            if (value === undefined) value = cdi.v;
            if (value === undefined) value = isX ? cdi.y : cdi.x;
            if (!Array.isArray(value)) {
              if (value === undefined) value = [];else value = [value];
            }
            for (l = 0; l < value.length; l++) {
              categoriesValue[catIndex][1].push(value[l]);
            }
          }
        }
      }
      ax._categoriesValue = categoriesValue;
      var categoriesAggregatedValue = [];
      for (j = 0; j < categoriesValue.length; j++) {
        categoriesAggregatedValue.push([categoriesValue[j][0], aggFn[aggregator](categoriesValue[j][1])]);
      }

      // Sort by aggregated value
      categoriesAggregatedValue.sort(order === 'descending' ? sortDescending : sortAscending);
      ax._categoriesAggregatedValue = categoriesAggregatedValue;

      // Set new category order
      ax._initialCategories = categoriesAggregatedValue.map(function (c) {
        return c[0];
      });

      // Sort all matching axes
      affectedTraces = affectedTraces.concat(ax.sortByInitialCategories());
    }
  }
  return affectedTraces;
}
function setupAxisCategories(axList, fullData, fullLayout) {
  var axLookup = {};
  function setupOne(ax) {
    ax.clearCalc();
    if (ax.type === 'multicategory') {
      ax.setupMultiCategory(fullData);
    }
    axLookup[ax._id] = 1;
  }
  Lib.simpleMap(axList, setupOne);

  // look into match groups for 'missing' axes
  var matchGroups = fullLayout._axisMatchGroups || [];
  for (var i = 0; i < matchGroups.length; i++) {
    for (var axId in matchGroups[i]) {
      if (!axLookup[axId]) {
        setupOne(fullLayout[axisIDs.id2name(axId)]);
      }
    }
  }
}
function doCrossTraceCalc(gd) {
  var fullLayout = gd._fullLayout;
  var modules = fullLayout._visibleModules;
  var hash = {};
  var i, j, k;

  // position and range calculations for traces that
  // depend on each other ie bars (stacked or grouped)
  // and boxes (grouped) push each other out of the way

  for (j = 0; j < modules.length; j++) {
    var _module = modules[j];
    var fn = _module.crossTraceCalc;
    if (fn) {
      var spType = _module.basePlotModule.name;
      if (hash[spType]) {
        Lib.pushUnique(hash[spType], fn);
      } else {
        hash[spType] = [fn];
      }
    }
  }
  for (k in hash) {
    var methods = hash[k];
    var subplots = fullLayout._subplots[k];
    if (Array.isArray(subplots)) {
      for (i = 0; i < subplots.length; i++) {
        var sp = subplots[i];
        var spInfo = k === 'cartesian' ? fullLayout._plots[sp] : fullLayout[sp];
        for (j = 0; j < methods.length; j++) {
          methods[j](gd, spInfo, sp);
        }
      }
    } else {
      for (j = 0; j < methods.length; j++) {
        methods[j](gd);
      }
    }
  }
}
plots.rehover = function (gd) {
  if (gd._fullLayout._rehover) {
    gd._fullLayout._rehover();
  }
};
plots.redrag = function (gd) {
  if (gd._fullLayout._redrag) {
    gd._fullLayout._redrag();
  }
};
plots.reselect = function (gd) {
  var fullLayout = gd._fullLayout;
  var A = (gd.layout || {}).selections;
  var B = fullLayout._previousSelections;
  fullLayout._previousSelections = A;
  var mayEmitSelected = fullLayout._reselect || JSON.stringify(A) !== JSON.stringify(B);
  Registry.getComponentMethod('selections', 'reselect')(gd, mayEmitSelected);
};
plots.generalUpdatePerTraceModule = function (gd, subplot, subplotCalcData, subplotLayout) {
  var traceHashOld = subplot.traceHash;
  var traceHash = {};
  var i;

  // build up moduleName -> calcData hash
  for (i = 0; i < subplotCalcData.length; i++) {
    var calcTraces = subplotCalcData[i];
    var trace = calcTraces[0].trace;

    // skip over visible === false traces
    // as they don't have `_module` ref
    if (trace.visible) {
      traceHash[trace.type] = traceHash[trace.type] || [];
      traceHash[trace.type].push(calcTraces);
    }
  }

  // when a trace gets deleted, make sure that its module's
  // plot method is called so that it is properly
  // removed from the DOM.
  for (var moduleNameOld in traceHashOld) {
    if (!traceHash[moduleNameOld]) {
      var fakeCalcTrace = traceHashOld[moduleNameOld][0];
      var fakeTrace = fakeCalcTrace[0].trace;
      fakeTrace.visible = false;
      traceHash[moduleNameOld] = [fakeCalcTrace];
    }
  }

  // call module plot method
  for (var moduleName in traceHash) {
    var moduleCalcData = traceHash[moduleName];
    var _module = moduleCalcData[0][0].trace._module;
    _module.plot(gd, subplot, Lib.filterVisible(moduleCalcData), subplotLayout);
  }

  // update moduleName -> calcData hash
  subplot.traceHash = traceHash;
};
plots.plotBasePlot = function (desiredType, gd, traces, transitionOpts, makeOnCompleteCallback) {
  var _module = Registry.getModule(desiredType);
  var cdmodule = getModuleCalcData(gd.calcdata, _module)[0];
  _module.plot(gd, cdmodule, transitionOpts, makeOnCompleteCallback);
};
plots.cleanBasePlot = function (desiredType, newFullData, newFullLayout, oldFullData, oldFullLayout) {
  var had = oldFullLayout._has && oldFullLayout._has(desiredType);
  var has = newFullLayout._has && newFullLayout._has(desiredType);
  if (had && !has) {
    oldFullLayout['_' + desiredType + 'layer'].selectAll('g.trace').remove();
  }
};

/***/ }),

/***/ 9119:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Template = __webpack_require__(4467);
var handleDomainDefaults = (__webpack_require__(7670)/* .defaults */ .c);

/**
 * Find and supply defaults to all subplots of a given type
 * This handles subplots that are contained within one container - so
 * gl3d, geo, ternary... but not 2d axes which have separate x and y axes
 * finds subplots, coerces their `domain` attributes, then calls the
 * given handleDefaults function to fill in everything else.
 *
 * layoutIn: the complete user-supplied input layout
 * layoutOut: the complete finished layout
 * fullData: the finished data array, used only to find subplots
 * opts: {
 *  type: subplot type string
 *  attributes: subplot attributes object
 *  partition: 'x' or 'y', which direction to divide domain space by default
 *      (default 'x', ie side-by-side subplots)
 *      TODO: this option is only here because 3D and geo made opposite
 *      choices in this regard previously and I didn't want to change it.
 *      Instead we should do:
 *      - something consistent
 *      - something more square (4 cuts 2x2, 5/6 cuts 2x3, etc.)
 *      - something that includes all subplot types in one arrangement,
 *        now that we can have them together!
 *  handleDefaults: function of (subplotLayoutIn, subplotLayoutOut, coerce, opts)
 *      this opts object is passed through to handleDefaults, so attach any
 *      additional items needed by this function here as well
 * }
 */
module.exports = function handleSubplotDefaults(layoutIn, layoutOut, fullData, opts) {
  var subplotType = opts.type;
  var subplotAttributes = opts.attributes;
  var handleDefaults = opts.handleDefaults;
  var partition = opts.partition || 'x';
  var ids = layoutOut._subplots[subplotType];
  var idsLength = ids.length;
  var baseId = idsLength && ids[0].replace(/\d+$/, '');
  var subplotLayoutIn, subplotLayoutOut;
  function coerce(attr, dflt) {
    return Lib.coerce(subplotLayoutIn, subplotLayoutOut, subplotAttributes, attr, dflt);
  }
  for (var i = 0; i < idsLength; i++) {
    var id = ids[i];

    // ternary traces get a layout ternary for free!
    if (layoutIn[id]) subplotLayoutIn = layoutIn[id];else subplotLayoutIn = layoutIn[id] = {};
    subplotLayoutOut = Template.newContainer(layoutOut, id, baseId);
    if (!opts.noUirevision) coerce('uirevision', layoutOut.uirevision);
    var dfltDomains = {};
    dfltDomains[partition] = [i / idsLength, (i + 1) / idsLength];
    handleDomainDefaults(subplotLayoutOut, layoutOut, coerce, dfltDomains);
    opts.id = id;
    handleDefaults(subplotLayoutIn, subplotLayoutOut, coerce, opts);
  }
};

/***/ }),

/***/ 5386:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var docs = __webpack_require__(1562);
var FORMAT_LINK = docs.FORMAT_LINK;
var DATE_FORMAT_LINK = docs.DATE_FORMAT_LINK;
function templateFormatStringDescription(opts) {
  var supportOther = opts && opts.supportOther;
  return ['Variables are inserted using %{variable},', 'for example "y: %{y}"' + (supportOther ? ' as well as %{xother}, {%_xother}, {%_xother_}, {%xother_}. When showing info for several points, *xother* will be added to those with different x positions from the first point. An underscore before or after *(x|y)other* will add a space on that side, only when this field is shown.' : '.'), 'Numbers are formatted using d3-format\'s syntax %{variable:d3-format}, for example "Price: %{y:$.2f}".', FORMAT_LINK, 'for details on the formatting syntax.', 'Dates are formatted using d3-time-format\'s syntax %{variable|d3-time-format}, for example "Day: %{2019-01-01|%A}".', DATE_FORMAT_LINK, 'for details on the date formatting syntax.'].join(' ');
}
function shapeTemplateFormatStringDescription() {
  return ['Variables are inserted using %{variable},', 'for example "x0: %{x0}".', 'Numbers are formatted using d3-format\'s syntax %{variable:d3-format}, for example "Price: %{x0:$.2f}". See', FORMAT_LINK, 'for details on the formatting syntax.', 'Dates are formatted using d3-time-format\'s syntax %{variable|d3-time-format}, for example "Day: %{x0|%m %b %Y}". See', DATE_FORMAT_LINK, 'for details on the date formatting syntax.', 'A single multiplication or division operation may be applied to numeric variables, and combined with', 'd3 number formatting, for example "Length in cm: %{x0*2.54}", "%{slope*60:.1f} meters per second."', 'For log axes, variable values are given in log units.', 'For date axes, x/y coordinate variables and center variables use datetimes, while all other variable values use values in ms.'].join(' ');
}
function describeVariables(extra) {
  var descPart = extra.description ? ' ' + extra.description : '';
  var keys = extra.keys || [];
  if (keys.length > 0) {
    var quotedKeys = [];
    for (var i = 0; i < keys.length; i++) {
      quotedKeys[i] = '`' + keys[i] + '`';
    }
    descPart = descPart + 'Finally, the template string has access to ';
    if (keys.length === 1) {
      descPart = descPart + 'variable ' + quotedKeys[0];
    } else {
      descPart = descPart + 'variables ' + quotedKeys.slice(0, -1).join(', ') + ' and ' + quotedKeys.slice(-1) + '.';
    }
  }
  return descPart;
}
exports.fF = function (opts, extra) {
  opts = opts || {};
  extra = extra || {};
  var descPart = describeVariables(extra);
  var hovertemplate = {
    valType: 'string',
    dflt: '',
    editType: opts.editType || 'none'
  };
  if (opts.arrayOk !== false) {
    hovertemplate.arrayOk = true;
  }
  return hovertemplate;
};
exports.si = function (opts, extra) {
  opts = opts || {};
  extra = extra || {};
  var descPart = describeVariables(extra);
  var texttemplate = {
    valType: 'string',
    dflt: '',
    editType: opts.editType || 'calc'
  };
  if (opts.arrayOk !== false) {
    texttemplate.arrayOk = true;
  }
  return texttemplate;
};
exports.R = function (opts, extra) {
  opts = opts || {};
  extra = extra || {};
  var newStr = opts.newshape ? 'new ' : '';
  var descPart = describeVariables(extra);
  var texttemplate = {
    valType: 'string',
    dflt: '',
    editType: opts.editType || 'arraydraw'
  };
  return texttemplate;
};

/***/ }),

/***/ 3972:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var Loggers = __webpack_require__(7769);
var noop = __webpack_require__(4213);
var pushUnique = __webpack_require__(5138);
var isPlainObject = __webpack_require__(1965);
var addStyleRule = (__webpack_require__(4401).addStyleRule);
var ExtendModule = __webpack_require__(1426);
var basePlotAttributes = __webpack_require__(9012);
var baseLayoutAttributes = __webpack_require__(820);
var extendFlat = ExtendModule.extendFlat;
var extendDeepAll = ExtendModule.extendDeepAll;
exports.modules = {};
exports.allCategories = {};
exports.allTypes = [];
exports.subplotsRegistry = {};
exports.transformsRegistry = {};
exports.componentsRegistry = {};
exports.layoutArrayContainers = [];
exports.layoutArrayRegexes = [];
exports.traceLayoutAttributes = {};
exports.localeRegistry = {};
exports.apiMethodRegistry = {};
exports.collectableSubplotTypes = null;

/**
 * Top-level register routine, exported as Plotly.register
 *
 * @param {object array or array of objects} _modules :
 *  module object or list of module object to register.
 *
 *  A valid `moduleType: 'trace'` module has fields:
 *  - name {string} : the trace type
 *  - categories {array} : categories associated with this trace type,
 *                         tested with Register.traceIs()
 *  - meta {object} : meta info (mostly for plot-schema)
 *
 *  A valid `moduleType: 'locale'` module has fields:
 *  - name {string} : the locale name. Should be a 2-digit language string ('en', 'de')
 *                    optionally with a country/region code ('en-GB', 'de-CH'). If a country
 *                    code is used but the base language locale has not yet been supplied,
 *                    we will use this locale for the base as well.
 *  - dictionary {object} : the dictionary mapping input strings to localized strings
 *                          generally the keys should be the literal input strings, but
 *                          if default translations are provided you can use any string as a key.
 *  - format {object} : a `d3.locale` format specifier for this locale
 *                      any omitted keys we'll fall back on en-US.
 *
 *  A valid `moduleType: 'transform'` module has fields:
 *  - name {string} : transform name
 *  - transform {function} : default-level transform function
 *  - calcTransform {function} : calc-level transform function
 *  - attributes {object} : transform attributes declarations
 *  - supplyDefaults {function} : attributes default-supply function
 *
 *  A valid `moduleType: 'component'` module has fields:
 *  - name {string} : the component name, used it with Register.getComponentMethod()
 *                    to employ component method.
 *
 *  A valid `moduleType: 'apiMethod'` module has fields:
 *  - name {string} : the api method name.
 *  - fn {function} : the api method called with Register.call();
 *
 */
exports.register = function register(_modules) {
  exports.collectableSubplotTypes = null;
  if (!_modules) {
    throw new Error('No argument passed to Plotly.register.');
  } else if (_modules && !Array.isArray(_modules)) {
    _modules = [_modules];
  }
  for (var i = 0; i < _modules.length; i++) {
    var newModule = _modules[i];
    if (!newModule) {
      throw new Error('Invalid module was attempted to be registered!');
    }
    switch (newModule.moduleType) {
      case 'trace':
        registerTraceModule(newModule);
        break;
      case 'transform':
        registerTransformModule(newModule);
        break;
      case 'component':
        registerComponentModule(newModule);
        break;
      case 'locale':
        registerLocale(newModule);
        break;
      case 'apiMethod':
        var name = newModule.name;
        exports.apiMethodRegistry[name] = newModule.fn;
        break;
      default:
        throw new Error('Invalid module was attempted to be registered!');
    }
  }
};

/**
 * Get registered module using trace object or trace type
 *
 * @param {object||string} trace
 *  trace object with prop 'type' or trace type as a string
 * @return {object}
 *  module object corresponding to trace type
 */
exports.getModule = function (trace) {
  var _module = exports.modules[getTraceType(trace)];
  if (!_module) return false;
  return _module._module;
};

/**
 * Determine if this trace type is in a given category
 *
 * @param {object||string} traceType
 *  a trace (object) or trace type (string)
 * @param {string} category
 *  category in question
 * @return {boolean}
 */
exports.traceIs = function (traceType, category) {
  traceType = getTraceType(traceType);

  // old Chart Studio Cloud workspace hack, nothing to see here
  if (traceType === 'various') return false;
  var _module = exports.modules[traceType];
  if (!_module) {
    if (traceType) {
      Loggers.log('Unrecognized trace type ' + traceType + '.');
    }
    _module = exports.modules[basePlotAttributes.type.dflt];
  }
  return !!_module.categories[category];
};

/**
 * Determine if this trace has a transform of the given type and return
 * array of matching indices.
 *
 * @param {object} data
 *  a trace object (member of data or fullData)
 * @param {string} type
 *  type of trace to test
 * @return {array}
 *  array of matching indices. If none found, returns []
 */
exports.getTransformIndices = function (data, type) {
  var indices = [];
  var transforms = data.transforms || [];
  for (var i = 0; i < transforms.length; i++) {
    if (transforms[i].type === type) {
      indices.push(i);
    }
  }
  return indices;
};

/**
 * Determine if this trace has a transform of the given type
 *
 * @param {object} data
 *  a trace object (member of data or fullData)
 * @param {string} type
 *  type of trace to test
 * @return {boolean}
 */
exports.hasTransform = function (data, type) {
  var transforms = data.transforms || [];
  for (var i = 0; i < transforms.length; i++) {
    if (transforms[i].type === type) {
      return true;
    }
  }
  return false;
};

/**
 * Retrieve component module method. Falls back on noop if either the
 * module or the method is missing, so the result can always be safely called
 *
 * @param {string} name
 *  name of component (as declared in component module)
 * @param {string} method
 *  name of component module method
 * @return {function}
 */
exports.getComponentMethod = function (name, method) {
  var _module = exports.componentsRegistry[name];
  if (!_module) return noop;
  return _module[method] || noop;
};

/**
 * Call registered api method.
 *
 * @param {string} name : api method name
 * @param {...array} args : arguments passed to api method
 * @return {any} : returns api method output
 */
exports.call = function () {
  var name = arguments[0];
  var args = [].slice.call(arguments, 1);
  return exports.apiMethodRegistry[name].apply(null, args);
};
function registerTraceModule(_module) {
  var thisType = _module.name;
  var categoriesIn = _module.categories;
  var meta = _module.meta;
  if (exports.modules[thisType]) {
    Loggers.log('Type ' + thisType + ' already registered');
    return;
  }
  if (!exports.subplotsRegistry[_module.basePlotModule.name]) {
    registerSubplot(_module.basePlotModule);
  }
  var categoryObj = {};
  for (var i = 0; i < categoriesIn.length; i++) {
    categoryObj[categoriesIn[i]] = true;
    exports.allCategories[categoriesIn[i]] = true;
  }
  exports.modules[thisType] = {
    _module: _module,
    categories: categoryObj
  };
  if (meta && Object.keys(meta).length) {
    exports.modules[thisType].meta = meta;
  }
  exports.allTypes.push(thisType);
  for (var componentName in exports.componentsRegistry) {
    mergeComponentAttrsToTrace(componentName, thisType);
  }

  /*
   * Collect all trace layout attributes in one place for easier lookup later
   * but don't merge them into the base schema as it would confuse the docs
   * (at least after https://github.com/plotly/documentation/issues/202 gets done!)
   */
  if (_module.layoutAttributes) {
    extendFlat(exports.traceLayoutAttributes, _module.layoutAttributes);
  }
  var basePlotModule = _module.basePlotModule;
  var bpmName = basePlotModule.name;

  // add mapbox-gl CSS here to avoid console warning on instantiation
  if (bpmName === 'mapbox') {
    var styleRules = basePlotModule.constants.styleRules;
    for (var k in styleRules) {
      addStyleRule('.js-plotly-plot .plotly .mapboxgl-' + k, styleRules[k]);
    }
  }

  // if `plotly-geo-assets.js` is not included,
  // add `PlotlyGeoAssets` global to stash references to all fetched
  // topojson / geojson data
  if ((bpmName === 'geo' || bpmName === 'mapbox') && window.PlotlyGeoAssets === undefined) {
    window.PlotlyGeoAssets = {
      topojson: {}
    };
  }
}
function registerSubplot(_module) {
  var plotType = _module.name;
  if (exports.subplotsRegistry[plotType]) {
    Loggers.log('Plot type ' + plotType + ' already registered.');
    return;
  }

  // relayout array handling will look for component module methods with this
  // name and won't find them because this is a subplot module... but that
  // should be fine, it will just fall back on redrawing the plot.
  findArrayRegexps(_module);

  // not sure what's best for the 'cartesian' type at this point
  exports.subplotsRegistry[plotType] = _module;
  for (var componentName in exports.componentsRegistry) {
    mergeComponentAttrsToSubplot(componentName, _module.name);
  }
}
function registerComponentModule(_module) {
  if (typeof _module.name !== 'string') {
    throw new Error('Component module *name* must be a string.');
  }
  var name = _module.name;
  exports.componentsRegistry[name] = _module;
  if (_module.layoutAttributes) {
    if (_module.layoutAttributes._isLinkedToArray) {
      pushUnique(exports.layoutArrayContainers, name);
    }
    findArrayRegexps(_module);
  }
  for (var traceType in exports.modules) {
    mergeComponentAttrsToTrace(name, traceType);
  }
  for (var subplotName in exports.subplotsRegistry) {
    mergeComponentAttrsToSubplot(name, subplotName);
  }
  for (var transformType in exports.transformsRegistry) {
    mergeComponentAttrsToTransform(name, transformType);
  }
  if (_module.schema && _module.schema.layout) {
    extendDeepAll(baseLayoutAttributes, _module.schema.layout);
  }
}
function registerTransformModule(_module) {
  if (typeof _module.name !== 'string') {
    throw new Error('Transform module *name* must be a string.');
  }
  var prefix = 'Transform module ' + _module.name;
  var hasTransform = typeof _module.transform === 'function';
  var hasCalcTransform = typeof _module.calcTransform === 'function';
  if (!hasTransform && !hasCalcTransform) {
    throw new Error(prefix + ' is missing a *transform* or *calcTransform* method.');
  }
  if (hasTransform && hasCalcTransform) {
    Loggers.log([prefix + ' has both a *transform* and *calcTransform* methods.', 'Please note that all *transform* methods are executed', 'before all *calcTransform* methods.'].join(' '));
  }
  if (!isPlainObject(_module.attributes)) {
    Loggers.log(prefix + ' registered without an *attributes* object.');
  }
  if (typeof _module.supplyDefaults !== 'function') {
    Loggers.log(prefix + ' registered without a *supplyDefaults* method.');
  }
  exports.transformsRegistry[_module.name] = _module;
  for (var componentName in exports.componentsRegistry) {
    mergeComponentAttrsToTransform(componentName, _module.name);
  }
}
function registerLocale(_module) {
  var locale = _module.name;
  var baseLocale = locale.split('-')[0];
  var newDict = _module.dictionary;
  var newFormat = _module.format;
  var hasDict = newDict && Object.keys(newDict).length;
  var hasFormat = newFormat && Object.keys(newFormat).length;
  var locales = exports.localeRegistry;
  var localeObj = locales[locale];
  if (!localeObj) locales[locale] = localeObj = {};

  // Should we use this dict for the base locale?
  // In case we're overwriting a previous dict for this locale, check
  // whether the base matches the full locale dict now. If we're not
  // overwriting, locales[locale] is undefined so this just checks if
  // baseLocale already had a dict or not.
  // Same logic for dateFormats
  if (baseLocale !== locale) {
    var baseLocaleObj = locales[baseLocale];
    if (!baseLocaleObj) locales[baseLocale] = baseLocaleObj = {};
    if (hasDict && baseLocaleObj.dictionary === localeObj.dictionary) {
      baseLocaleObj.dictionary = newDict;
    }
    if (hasFormat && baseLocaleObj.format === localeObj.format) {
      baseLocaleObj.format = newFormat;
    }
  }
  if (hasDict) localeObj.dictionary = newDict;
  if (hasFormat) localeObj.format = newFormat;
}
function findArrayRegexps(_module) {
  if (_module.layoutAttributes) {
    var arrayAttrRegexps = _module.layoutAttributes._arrayAttrRegexps;
    if (arrayAttrRegexps) {
      for (var i = 0; i < arrayAttrRegexps.length; i++) {
        pushUnique(exports.layoutArrayRegexes, arrayAttrRegexps[i]);
      }
    }
  }
}
function mergeComponentAttrsToTrace(componentName, traceType) {
  var componentSchema = exports.componentsRegistry[componentName].schema;
  if (!componentSchema || !componentSchema.traces) return;
  var traceAttrs = componentSchema.traces[traceType];
  if (traceAttrs) {
    extendDeepAll(exports.modules[traceType]._module.attributes, traceAttrs);
  }
}
function mergeComponentAttrsToTransform(componentName, transformType) {
  var componentSchema = exports.componentsRegistry[componentName].schema;
  if (!componentSchema || !componentSchema.transforms) return;
  var transformAttrs = componentSchema.transforms[transformType];
  if (transformAttrs) {
    extendDeepAll(exports.transformsRegistry[transformType].attributes, transformAttrs);
  }
}
function mergeComponentAttrsToSubplot(componentName, subplotName) {
  var componentSchema = exports.componentsRegistry[componentName].schema;
  if (!componentSchema || !componentSchema.subplots) return;
  var subplotModule = exports.subplotsRegistry[subplotName];
  var subplotAttrs = subplotModule.layoutAttributes;
  var subplotAttr = subplotModule.attr === 'subplot' ? subplotModule.name : subplotModule.attr;
  if (Array.isArray(subplotAttr)) subplotAttr = subplotAttr[0];
  var componentLayoutAttrs = componentSchema.subplots[subplotAttr];
  if (subplotAttrs && componentLayoutAttrs) {
    extendDeepAll(subplotAttrs, componentLayoutAttrs);
  }
}
function getTraceType(traceType) {
  if (typeof traceType === 'object') traceType = traceType.type;
  return traceType;
}

/***/ }),

/***/ 1914:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var extendFlat = Lib.extendFlat;
var extendDeep = Lib.extendDeep;

// Put default plotTile layouts here
function cloneLayoutOverride(tileClass) {
  var override;
  switch (tileClass) {
    case 'themes__thumb':
      override = {
        autosize: true,
        width: 150,
        height: 150,
        title: {
          text: ''
        },
        showlegend: false,
        margin: {
          l: 5,
          r: 5,
          t: 5,
          b: 5,
          pad: 0
        },
        annotations: []
      };
      break;
    case 'thumbnail':
      override = {
        title: {
          text: ''
        },
        hidesources: true,
        showlegend: false,
        borderwidth: 0,
        bordercolor: '',
        margin: {
          l: 1,
          r: 1,
          t: 1,
          b: 1,
          pad: 0
        },
        annotations: []
      };
      break;
    default:
      override = {};
  }
  return override;
}
function keyIsAxis(keyName) {
  var types = ['xaxis', 'yaxis', 'zaxis'];
  return types.indexOf(keyName.slice(0, 5)) > -1;
}
module.exports = function clonePlot(graphObj, options) {
  var i;
  var oldData = graphObj.data;
  var oldLayout = graphObj.layout;
  var newData = extendDeep([], oldData);
  var newLayout = extendDeep({}, oldLayout, cloneLayoutOverride(options.tileClass));
  var context = graphObj._context || {};
  if (options.width) newLayout.width = options.width;
  if (options.height) newLayout.height = options.height;
  if (options.tileClass === 'thumbnail' || options.tileClass === 'themes__thumb') {
    // kill annotations
    newLayout.annotations = [];
    var keys = Object.keys(newLayout);
    for (i = 0; i < keys.length; i++) {
      if (keyIsAxis(keys[i])) {
        newLayout[keys[i]].title = {
          text: ''
        };
      }
    }

    // kill colorbar and pie labels
    for (i = 0; i < newData.length; i++) {
      var trace = newData[i];
      trace.showscale = false;
      if (trace.marker) trace.marker.showscale = false;
      if (Registry.traceIs(trace, 'pie-like')) trace.textposition = 'none';
    }
  }
  if (Array.isArray(options.annotations)) {
    for (i = 0; i < options.annotations.length; i++) {
      newLayout.annotations.push(options.annotations[i]);
    }
  }

  // TODO: does this scene modification really belong here?
  // If we still need it, can it move into the gl3d module?
  var sceneIds = Object.keys(newLayout).filter(function (key) {
    return key.match(/^scene\d*$/);
  });
  if (sceneIds.length) {
    var axesImageOverride = {};
    if (options.tileClass === 'thumbnail') {
      axesImageOverride = {
        title: {
          text: ''
        },
        showaxeslabels: false,
        showticklabels: false,
        linetickenable: false
      };
    }
    for (i = 0; i < sceneIds.length; i++) {
      var scene = newLayout[sceneIds[i]];
      if (!scene.xaxis) {
        scene.xaxis = {};
      }
      if (!scene.yaxis) {
        scene.yaxis = {};
      }
      if (!scene.zaxis) {
        scene.zaxis = {};
      }
      extendFlat(scene.xaxis, axesImageOverride);
      extendFlat(scene.yaxis, axesImageOverride);
      extendFlat(scene.zaxis, axesImageOverride);

      // TODO what does this do?
      scene._scene = null;
    }
  }
  var gd = document.createElement('div');
  if (options.tileClass) gd.className = options.tileClass;
  var plotTile = {
    gd: gd,
    td: gd,
    // for external (image server) compatibility
    layout: newLayout,
    data: newData,
    config: {
      staticPlot: options.staticPlot === undefined ? true : options.staticPlot,
      plotGlPixelRatio: options.plotGlPixelRatio === undefined ? 2 : options.plotGlPixelRatio,
      displaylogo: options.displaylogo || false,
      showLink: options.showLink || false,
      showTips: options.showTips || false,
      mapboxAccessToken: context.mapboxAccessToken
    }
  };
  if (options.setBackground !== 'transparent') {
    plotTile.config.setBackground = options.setBackground || 'opaque';
  }

  // attaching the default Layout the gd, so you can grab it later
  plotTile.gd.defaultLayout = cloneLayoutOverride(options.tileClass);
  return plotTile;
};

/***/ }),

/***/ 7239:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var toImage = __webpack_require__(403);
var fileSaver = __webpack_require__(2435);
var helpers = __webpack_require__(5095);

/**
 * Plotly.downloadImage
 *
 * @param {object | string | HTML div} gd
 *   can either be a data/layout/config object
 *   or an existing graph <div>
 *   or an id to an existing graph <div>
 * @param {object} opts (see Plotly.toImage in ../plot_api/to_image)
 * @return {promise}
 */
function downloadImage(gd, opts) {
  var _gd;
  if (!Lib.isPlainObject(gd)) _gd = Lib.getGraphDiv(gd);
  opts = opts || {};
  opts.format = opts.format || 'png';
  opts.width = opts.width || null;
  opts.height = opts.height || null;
  opts.imageDataOnly = true;
  return new Promise(function (resolve, reject) {
    if (_gd && _gd._snapshotInProgress) {
      reject(new Error('Snapshotting already in progress.'));
    }

    // see comments within svgtoimg for additional
    //   discussion of problems with IE
    //   can now draw to canvas, but CORS tainted canvas
    //   does not allow toDataURL
    //   svg format will work though
    if (Lib.isIE() && opts.format !== 'svg') {
      reject(new Error(helpers.MSG_IE_BAD_FORMAT));
    }
    if (_gd) _gd._snapshotInProgress = true;
    var promise = toImage(gd, opts);
    var filename = opts.filename || gd.fn || 'newplot';
    filename += '.' + opts.format.replace('-', '.');
    promise.then(function (result) {
      if (_gd) _gd._snapshotInProgress = false;
      return fileSaver(result, filename, opts.format);
    }).then(function (name) {
      resolve(name);
    }).catch(function (err) {
      if (_gd) _gd._snapshotInProgress = false;
      reject(err);
    });
  });
}
module.exports = downloadImage;

/***/ }),

/***/ 2435:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var helpers = __webpack_require__(5095);

/*
* substantial portions of this code from FileSaver.js
* https://github.com/eligrey/FileSaver.js
* License: https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
* FileSaver.js
* A saveAs() FileSaver implementation.
* 1.1.20160328
*
* By Eli Grey, http://eligrey.com
* License: MIT
*   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
*/
function fileSaver(url, name, format) {
  var saveLink = document.createElement('a');
  var canUseSaveLink = ('download' in saveLink);
  var promise = new Promise(function (resolve, reject) {
    var blob;
    var objectUrl;

    // IE 10+ (native saveAs)
    if (Lib.isIE()) {
      // At this point we are only dealing with a decoded SVG as
      // a data URL (since IE only supports SVG)
      blob = helpers.createBlob(url, 'svg');
      window.navigator.msSaveBlob(blob, name);
      blob = null;
      return resolve(name);
    }
    if (canUseSaveLink) {
      blob = helpers.createBlob(url, format);
      objectUrl = helpers.createObjectURL(blob);
      saveLink.href = objectUrl;
      saveLink.download = name;
      document.body.appendChild(saveLink);
      saveLink.click();
      document.body.removeChild(saveLink);
      helpers.revokeObjectURL(objectUrl);
      blob = null;
      return resolve(name);
    }

    // Older versions of Safari did not allow downloading of blob urls
    if (Lib.isSafari()) {
      var prefix = format === 'svg' ? ',' : ';base64,';
      helpers.octetStream(prefix + encodeURIComponent(url));
      return resolve(name);
    }
    reject(new Error('download error'));
  });
  return promise;
}
module.exports = fileSaver;

/***/ }),

/***/ 5095:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);
exports.getDelay = function (fullLayout) {
  if (!fullLayout._has) return 0;
  return fullLayout._has('gl3d') || fullLayout._has('gl2d') || fullLayout._has('mapbox') ? 500 : 0;
};
exports.getRedrawFunc = function (gd) {
  return function () {
    Registry.getComponentMethod('colorbar', 'draw')(gd);
  };
};
exports.encodeSVG = function (svg) {
  return 'data:image/svg+xml,' + encodeURIComponent(svg);
};
exports.encodeJSON = function (json) {
  return 'data:application/json,' + encodeURIComponent(json);
};
var DOM_URL = window.URL || window.webkitURL;
exports.createObjectURL = function (blob) {
  return DOM_URL.createObjectURL(blob);
};
exports.revokeObjectURL = function (url) {
  return DOM_URL.revokeObjectURL(url);
};
exports.createBlob = function (url, format) {
  if (format === 'svg') {
    return new window.Blob([url], {
      type: 'image/svg+xml;charset=utf-8'
    });
  } else if (format === 'full-json') {
    return new window.Blob([url], {
      type: 'application/json;charset=utf-8'
    });
  } else {
    var binary = fixBinary(window.atob(url));
    return new window.Blob([binary], {
      type: 'image/' + format
    });
  }
};
exports.octetStream = function (s) {
  document.location.href = 'data:application/octet-stream' + s;
};

// Taken from https://bl.ocks.org/nolanlawson/0eac306e4dac2114c752
function fixBinary(b) {
  var len = b.length;
  var buf = new ArrayBuffer(len);
  var arr = new Uint8Array(buf);
  for (var i = 0; i < len; i++) {
    arr[i] = b.charCodeAt(i);
  }
  return buf;
}
exports.IMAGE_URL_PREFIX = /^data:image\/\w+;base64,/;
exports.MSG_IE_BAD_FORMAT = 'Sorry IE does not support downloading from canvas. Try {format:\'svg\'} instead.';

/***/ }),

/***/ 4511:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(5095);
var Snapshot = {
  getDelay: helpers.getDelay,
  getRedrawFunc: helpers.getRedrawFunc,
  clone: __webpack_require__(1914),
  toSVG: __webpack_require__(5900),
  svgToImg: __webpack_require__(942),
  toImage: __webpack_require__(6395),
  downloadImage: __webpack_require__(7239)
};
module.exports = Snapshot;

/***/ }),

/***/ 942:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var EventEmitter = (__webpack_require__(5398).EventEmitter);
var helpers = __webpack_require__(5095);
function svgToImg(opts) {
  var ev = opts.emitter || new EventEmitter();
  var promise = new Promise(function (resolve, reject) {
    var Image = window.Image;
    var svg = opts.svg;
    var format = opts.format || 'png';

    // IE only support svg
    if (Lib.isIE() && format !== 'svg') {
      var ieSvgError = new Error(helpers.MSG_IE_BAD_FORMAT);
      reject(ieSvgError);
      // eventually remove the ev
      //  in favor of promises
      if (!opts.promise) {
        return ev.emit('error', ieSvgError);
      } else {
        return promise;
      }
    }
    var canvas = opts.canvas;
    var scale = opts.scale || 1;
    var w0 = opts.width || 300;
    var h0 = opts.height || 150;
    var w1 = scale * w0;
    var h1 = scale * h0;
    var ctx = canvas.getContext('2d', {
      willReadFrequently: true
    });
    var img = new Image();
    var svgBlob, url;
    if (format === 'svg' || Lib.isSafari()) {
      url = helpers.encodeSVG(svg);
    } else {
      svgBlob = helpers.createBlob(svg, 'svg');
      url = helpers.createObjectURL(svgBlob);
    }
    canvas.width = w1;
    canvas.height = h1;
    img.onload = function () {
      var imgData;
      svgBlob = null;
      helpers.revokeObjectURL(url);

      // don't need to draw to canvas if svg
      //  save some time and also avoid failure on IE
      if (format !== 'svg') {
        ctx.drawImage(img, 0, 0, w1, h1);
      }
      switch (format) {
        case 'jpeg':
          imgData = canvas.toDataURL('image/jpeg');
          break;
        case 'png':
          imgData = canvas.toDataURL('image/png');
          break;
        case 'webp':
          imgData = canvas.toDataURL('image/webp');
          break;
        case 'svg':
          imgData = url;
          break;
        default:
          var errorMsg = 'Image format is not jpeg, png, svg or webp.';
          reject(new Error(errorMsg));
          // eventually remove the ev
          //  in favor of promises
          if (!opts.promise) {
            return ev.emit('error', errorMsg);
          }
      }
      resolve(imgData);
      // eventually remove the ev
      //  in favor of promises
      if (!opts.promise) {
        ev.emit('success', imgData);
      }
    };
    img.onerror = function (err) {
      svgBlob = null;
      helpers.revokeObjectURL(url);
      reject(err);
      // eventually remove the ev
      //  in favor of promises
      if (!opts.promise) {
        return ev.emit('error', err);
      }
    };
    img.src = url;
  });

  // temporary for backward compatibility
  //  move to only Promise in 2.0.0
  //  and eliminate the EventEmitter
  if (opts.promise) {
    return promise;
  }
  return ev;
}
module.exports = svgToImg;

/***/ }),

/***/ 6395:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var EventEmitter = (__webpack_require__(5398).EventEmitter);
var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var helpers = __webpack_require__(5095);
var clonePlot = __webpack_require__(1914);
var toSVG = __webpack_require__(5900);
var svgToImg = __webpack_require__(942);

/**
 * @param {object} gd figure Object
 * @param {object} opts option object
 * @param opts.format 'jpeg' | 'png' | 'webp' | 'svg'
 */
function toImage(gd, opts) {
  // first clone the GD so we can operate in a clean environment
  var ev = new EventEmitter();
  var clone = clonePlot(gd, {
    format: 'png'
  });
  var clonedGd = clone.gd;

  // put the cloned div somewhere off screen before attaching to DOM
  clonedGd.style.position = 'absolute';
  clonedGd.style.left = '-5000px';
  document.body.appendChild(clonedGd);
  function wait() {
    var delay = helpers.getDelay(clonedGd._fullLayout);
    setTimeout(function () {
      var svg = toSVG(clonedGd);
      var canvas = document.createElement('canvas');
      canvas.id = Lib.randstr();
      ev = svgToImg({
        format: opts.format,
        width: clonedGd._fullLayout.width,
        height: clonedGd._fullLayout.height,
        canvas: canvas,
        emitter: ev,
        svg: svg
      });
      ev.clean = function () {
        if (clonedGd) document.body.removeChild(clonedGd);
      };
    }, delay);
  }
  var redrawFunc = helpers.getRedrawFunc(clonedGd);
  Registry.call('_doPlot', clonedGd, clone.data, clone.layout, clone.config).then(redrawFunc).then(wait).catch(function (err) {
    ev.emit('error', err);
  });
  return ev;
}
module.exports = toImage;

/***/ }),

/***/ 5900:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Lib = __webpack_require__(1828);
var Drawing = __webpack_require__(1424);
var Color = __webpack_require__(7901);
var xmlnsNamespaces = __webpack_require__(7922);
var DOUBLEQUOTE_REGEX = /"/g;
var DUMMY_SUB = 'TOBESTRIPPED';
var DUMMY_REGEX = new RegExp('("' + DUMMY_SUB + ')|(' + DUMMY_SUB + '")', 'g');
function htmlEntityDecode(s) {
  var hiddenDiv = d3.select('body').append('div').style({
    display: 'none'
  }).html('');
  var replaced = s.replace(/(&[^;]*;)/gi, function (d) {
    if (d === '&lt;') {
      return '&#60;';
    } // special handling for brackets
    if (d === '&rt;') {
      return '&#62;';
    }
    if (d.indexOf('<') !== -1 || d.indexOf('>') !== -1) {
      return '';
    }
    return hiddenDiv.html(d).text(); // everything else, let the browser decode it to unicode
  });

  hiddenDiv.remove();
  return replaced;
}
function xmlEntityEncode(str) {
  return str.replace(/&(?!\w+;|\#[0-9]+;| \#x[0-9A-F]+;)/g, '&amp;');
}
module.exports = function toSVG(gd, format, scale) {
  var fullLayout = gd._fullLayout;
  var svg = fullLayout._paper;
  var toppaper = fullLayout._toppaper;
  var width = fullLayout.width;
  var height = fullLayout.height;
  var i;

  // make background color a rect in the svg, then revert after scraping
  // all other alterations have been dealt with by properly preparing the svg
  // in the first place... like setting cursors with css classes so we don't
  // have to remove them, and providing the right namespaces in the svg to
  // begin with
  svg.insert('rect', ':first-child').call(Drawing.setRect, 0, 0, width, height).call(Color.fill, fullLayout.paper_bgcolor);

  // subplot-specific to-SVG methods
  // which notably add the contents of the gl-container
  // into the main svg node
  var basePlotModules = fullLayout._basePlotModules || [];
  for (i = 0; i < basePlotModules.length; i++) {
    var _module = basePlotModules[i];
    if (_module.toSVG) _module.toSVG(gd);
  }

  // add top items above them assumes everything in toppaper is either
  // a group or a defs, and if it's empty (like hoverlayer) we can ignore it.
  if (toppaper) {
    var nodes = toppaper.node().childNodes;

    // make copy of nodes as childNodes prop gets mutated in loop below
    var topGroups = Array.prototype.slice.call(nodes);
    for (i = 0; i < topGroups.length; i++) {
      var topGroup = topGroups[i];
      if (topGroup.childNodes.length) svg.node().appendChild(topGroup);
    }
  }

  // remove draglayer for Adobe Illustrator compatibility
  if (fullLayout._draggers) {
    fullLayout._draggers.remove();
  }

  // in case the svg element had an explicit background color, remove this
  // we want the rect to get the color so it's the right size; svg bg will
  // fill whatever container it's displayed in regardless of plot size.
  svg.node().style.background = '';
  svg.selectAll('text').attr({
    'data-unformatted': null,
    'data-math': null
  }).each(function () {
    var txt = d3.select(this);

    // hidden text is pre-formatting mathjax, the browser ignores it
    // but in a static plot it's useless and it can confuse batik
    // we've tried to standardize on display:none but make sure we still
    // catch visibility:hidden if it ever arises
    if (this.style.visibility === 'hidden' || this.style.display === 'none') {
      txt.remove();
      return;
    } else {
      // clear other visibility/display values to default
      // to not potentially confuse non-browser SVG implementations
      txt.style({
        visibility: null,
        display: null
      });
    }

    // Font family styles break things because of quotation marks,
    // so we must remove them *after* the SVG DOM has been serialized
    // to a string (browsers convert singles back)
    var ff = this.style.fontFamily;
    if (ff && ff.indexOf('"') !== -1) {
      txt.style('font-family', ff.replace(DOUBLEQUOTE_REGEX, DUMMY_SUB));
    }
  });
  svg.selectAll('.gradient_filled,.pattern_filled').each(function () {
    var pt = d3.select(this);

    // similar to font family styles above,
    // we must remove " after the SVG DOM has been serialized
    var fill = this.style.fill;
    if (fill && fill.indexOf('url(') !== -1) {
      pt.style('fill', fill.replace(DOUBLEQUOTE_REGEX, DUMMY_SUB));
    }
    var stroke = this.style.stroke;
    if (stroke && stroke.indexOf('url(') !== -1) {
      pt.style('stroke', stroke.replace(DOUBLEQUOTE_REGEX, DUMMY_SUB));
    }
  });
  if (format === 'pdf' || format === 'eps') {
    // these formats make the extra line MathJax adds around symbols look super thick in some cases
    // it looks better if this is removed entirely.
    svg.selectAll('#MathJax_SVG_glyphs path').attr('stroke-width', 0);
  }

  // fix for IE namespacing quirk?
  // http://stackoverflow.com/questions/19610089/unwanted-namespaces-on-svg-markup-when-using-xmlserializer-in-javascript-with-ie
  svg.node().setAttributeNS(xmlnsNamespaces.xmlns, 'xmlns', xmlnsNamespaces.svg);
  svg.node().setAttributeNS(xmlnsNamespaces.xmlns, 'xmlns:xlink', xmlnsNamespaces.xlink);
  if (format === 'svg' && scale) {
    svg.attr('width', scale * width);
    svg.attr('height', scale * height);
    svg.attr('viewBox', '0 0 ' + width + ' ' + height);
  }
  var s = new window.XMLSerializer().serializeToString(svg.node());
  s = htmlEntityDecode(s);
  s = xmlEntityEncode(s);

  // Fix quotations around font strings and gradient URLs
  s = s.replace(DUMMY_REGEX, '\'');

  // Do we need this process now that IE9 and IE10 are not supported?

  // IE is very strict, so we will need to clean
  //  svg with the following regex
  //  yes this is messy, but do not know a better way
  // Even with this IE will not work due to tainted canvas
  //  see https://github.com/kangax/fabric.js/issues/1957
  //      http://stackoverflow.com/questions/18112047/canvas-todataurl-working-in-all-browsers-except-ie10
  // Leave here just in case the CORS/tainted IE issue gets resolved
  if (Lib.isIE()) {
    // replace double quote with single quote
    s = s.replace(/"/gi, '\'');
    // url in svg are single quoted
    //   since we changed double to single
    //   we'll need to change these to double-quoted
    s = s.replace(/(\('#)([^']*)('\))/gi, '(\"#$2\")');
    // font names with spaces will be escaped single-quoted
    //   we'll need to change these to double-quoted
    s = s.replace(/(\\')/gi, '\"');
  }
  return s;
};

/***/ }),

/***/ 1661:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var isArrayOrTypedArray = (__webpack_require__(1828).isArrayOrTypedArray);
var BADNUM = (__webpack_require__(606).BADNUM);
var Registry = __webpack_require__(3972);
var Axes = __webpack_require__(9298);
var getAxisGroup = (__webpack_require__(9082).getAxisGroup);
var Sieve = __webpack_require__(1546);

/*
 * Bar chart stacking/grouping positioning and autoscaling calculations
 * for each direction separately calculate the ranges and positions
 * note that this handles histograms too
 * now doing this one subplot at a time
 */

function crossTraceCalc(gd, plotinfo) {
  var xa = plotinfo.xaxis;
  var ya = plotinfo.yaxis;
  var fullLayout = gd._fullLayout;
  var fullTraces = gd._fullData;
  var calcTraces = gd.calcdata;
  var calcTracesHorz = [];
  var calcTracesVert = [];
  for (var i = 0; i < fullTraces.length; i++) {
    var fullTrace = fullTraces[i];
    if (fullTrace.visible === true && Registry.traceIs(fullTrace, 'bar') && fullTrace.xaxis === xa._id && fullTrace.yaxis === ya._id) {
      if (fullTrace.orientation === 'h') {
        calcTracesHorz.push(calcTraces[i]);
      } else {
        calcTracesVert.push(calcTraces[i]);
      }
      if (fullTrace._computePh) {
        var cd = gd.calcdata[i];
        for (var j = 0; j < cd.length; j++) {
          if (typeof cd[j].ph0 === 'function') cd[j].ph0 = cd[j].ph0();
          if (typeof cd[j].ph1 === 'function') cd[j].ph1 = cd[j].ph1();
        }
      }
    }
  }
  var opts = {
    xCat: xa.type === 'category' || xa.type === 'multicategory',
    yCat: ya.type === 'category' || ya.type === 'multicategory',
    mode: fullLayout.barmode,
    norm: fullLayout.barnorm,
    gap: fullLayout.bargap,
    groupgap: fullLayout.bargroupgap
  };
  setGroupPositions(gd, xa, ya, calcTracesVert, opts);
  setGroupPositions(gd, ya, xa, calcTracesHorz, opts);
}
function setGroupPositions(gd, pa, sa, calcTraces, opts) {
  if (!calcTraces.length) return;
  var excluded;
  var included;
  var i, calcTrace, fullTrace;
  initBase(sa, calcTraces);
  switch (opts.mode) {
    case 'overlay':
      setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts);
      break;
    case 'group':
      // exclude from the group those traces for which the user set an offset
      excluded = [];
      included = [];
      for (i = 0; i < calcTraces.length; i++) {
        calcTrace = calcTraces[i];
        fullTrace = calcTrace[0].trace;
        if (fullTrace.offset === undefined) included.push(calcTrace);else excluded.push(calcTrace);
      }
      if (included.length) {
        setGroupPositionsInGroupMode(gd, pa, sa, included, opts);
      }
      if (excluded.length) {
        setGroupPositionsInOverlayMode(pa, sa, excluded, opts);
      }
      break;
    case 'stack':
    case 'relative':
      // exclude from the stack those traces for which the user set a base
      excluded = [];
      included = [];
      for (i = 0; i < calcTraces.length; i++) {
        calcTrace = calcTraces[i];
        fullTrace = calcTrace[0].trace;
        if (fullTrace.base === undefined) included.push(calcTrace);else excluded.push(calcTrace);
      }
      if (included.length) {
        setGroupPositionsInStackOrRelativeMode(gd, pa, sa, included, opts);
      }
      if (excluded.length) {
        setGroupPositionsInOverlayMode(pa, sa, excluded, opts);
      }
      break;
  }
  collectExtents(calcTraces, pa);
}
function initBase(sa, calcTraces) {
  var i, j;
  for (i = 0; i < calcTraces.length; i++) {
    var cd = calcTraces[i];
    var trace = cd[0].trace;
    var base = trace.type === 'funnel' ? trace._base : trace.base;
    var b;

    // not sure if it really makes sense to have dates for bar size data...
    // ideally if we want to make gantt charts or something we'd treat
    // the actual size (trace.x or y) as time delta but base as absolute
    // time. But included here for completeness.
    var scalendar = trace.orientation === 'h' ? trace.xcalendar : trace.ycalendar;

    // 'base' on categorical axes makes no sense
    var d2c = sa.type === 'category' || sa.type === 'multicategory' ? function () {
      return null;
    } : sa.d2c;
    if (isArrayOrTypedArray(base)) {
      for (j = 0; j < Math.min(base.length, cd.length); j++) {
        b = d2c(base[j], 0, scalendar);
        if (isNumeric(b)) {
          cd[j].b = +b;
          cd[j].hasB = 1;
        } else cd[j].b = 0;
      }
      for (; j < cd.length; j++) {
        cd[j].b = 0;
      }
    } else {
      b = d2c(base, 0, scalendar);
      var hasBase = isNumeric(b);
      b = hasBase ? b : 0;
      for (j = 0; j < cd.length; j++) {
        cd[j].b = b;
        if (hasBase) cd[j].hasB = 1;
      }
    }
  }
}
function setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts) {
  // update position axis and set bar offsets and widths
  for (var i = 0; i < calcTraces.length; i++) {
    var calcTrace = calcTraces[i];
    var sieve = new Sieve([calcTrace], {
      posAxis: pa,
      sepNegVal: false,
      overlapNoMerge: !opts.norm
    });

    // set bar offsets and widths, and update position axis
    setOffsetAndWidth(pa, sieve, opts);

    // set bar bases and sizes, and update size axis
    //
    // (note that `setGroupPositionsInOverlayMode` handles the case barnorm
    // is defined, because this function is also invoked for traces that
    // can't be grouped or stacked)
    if (opts.norm) {
      sieveBars(sieve);
      normalizeBars(sa, sieve, opts);
    } else {
      setBaseAndTop(sa, sieve);
    }
  }
}
function setGroupPositionsInGroupMode(gd, pa, sa, calcTraces, opts) {
  var sieve = new Sieve(calcTraces, {
    posAxis: pa,
    sepNegVal: false,
    overlapNoMerge: !opts.norm
  });

  // set bar offsets and widths, and update position axis
  setOffsetAndWidthInGroupMode(gd, pa, sieve, opts);

  // relative-stack bars within the same trace that would otherwise
  // be hidden
  unhideBarsWithinTrace(sieve, pa);

  // set bar bases and sizes, and update size axis
  if (opts.norm) {
    sieveBars(sieve);
    normalizeBars(sa, sieve, opts);
  } else {
    setBaseAndTop(sa, sieve);
  }
}
function setGroupPositionsInStackOrRelativeMode(gd, pa, sa, calcTraces, opts) {
  var sieve = new Sieve(calcTraces, {
    posAxis: pa,
    sepNegVal: opts.mode === 'relative',
    overlapNoMerge: !(opts.norm || opts.mode === 'stack' || opts.mode === 'relative')
  });

  // set bar offsets and widths, and update position axis
  setOffsetAndWidth(pa, sieve, opts);

  // set bar bases and sizes, and update size axis
  stackBars(sa, sieve, opts);

  // flag the outmost bar (for text display purposes)
  for (var i = 0; i < calcTraces.length; i++) {
    var calcTrace = calcTraces[i];
    for (var j = 0; j < calcTrace.length; j++) {
      var bar = calcTrace[j];
      if (bar.s !== BADNUM) {
        var isOutmostBar = bar.b + bar.s === sieve.get(bar.p, bar.s);
        if (isOutmostBar) bar._outmost = true;
      }
    }
  }

  // Note that marking the outmost bars has to be done
  // before `normalizeBars` changes `bar.b` and `bar.s`.
  if (opts.norm) normalizeBars(sa, sieve, opts);
}
function setOffsetAndWidth(pa, sieve, opts) {
  var minDiff = sieve.minDiff;
  var calcTraces = sieve.traces;

  // set bar offsets and widths
  var barGroupWidth = minDiff * (1 - opts.gap);
  var barWidthPlusGap = barGroupWidth;
  var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));

  // computer bar group center and bar offset
  var offsetFromCenter = -barWidth / 2;
  for (var i = 0; i < calcTraces.length; i++) {
    var calcTrace = calcTraces[i];
    var t = calcTrace[0].t;

    // store bar width and offset for this trace
    t.barwidth = barWidth;
    t.poffset = offsetFromCenter;
    t.bargroupwidth = barGroupWidth;
    t.bardelta = minDiff;
  }

  // stack bars that only differ by rounding
  sieve.binWidth = calcTraces[0][0].t.barwidth / 100;

  // if defined, apply trace offset and width
  applyAttributes(sieve);

  // store the bar center in each calcdata item
  setBarCenterAndWidth(pa, sieve);

  // update position axes
  updatePositionAxis(pa, sieve);
}
function setOffsetAndWidthInGroupMode(gd, pa, sieve, opts) {
  var fullLayout = gd._fullLayout;
  var positions = sieve.positions;
  var distinctPositions = sieve.distinctPositions;
  var minDiff = sieve.minDiff;
  var calcTraces = sieve.traces;
  var nTraces = calcTraces.length;

  // if there aren't any overlapping positions,
  // let them have full width even if mode is group
  var overlap = positions.length !== distinctPositions.length;
  var barGroupWidth = minDiff * (1 - opts.gap);
  var groupId = getAxisGroup(fullLayout, pa._id) + calcTraces[0][0].trace.orientation;
  var alignmentGroups = fullLayout._alignmentOpts[groupId] || {};
  for (var i = 0; i < nTraces; i++) {
    var calcTrace = calcTraces[i];
    var trace = calcTrace[0].trace;
    var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};
    var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;
    var barWidthPlusGap;
    if (nOffsetGroups) {
      barWidthPlusGap = barGroupWidth / nOffsetGroups;
    } else {
      barWidthPlusGap = overlap ? barGroupWidth / nTraces : barGroupWidth;
    }
    var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));
    var offsetFromCenter;
    if (nOffsetGroups) {
      offsetFromCenter = ((2 * trace._offsetIndex + 1 - nOffsetGroups) * barWidthPlusGap - barWidth) / 2;
    } else {
      offsetFromCenter = overlap ? ((2 * i + 1 - nTraces) * barWidthPlusGap - barWidth) / 2 : -barWidth / 2;
    }
    var t = calcTrace[0].t;
    t.barwidth = barWidth;
    t.poffset = offsetFromCenter;
    t.bargroupwidth = barGroupWidth;
    t.bardelta = minDiff;
  }

  // stack bars that only differ by rounding
  sieve.binWidth = calcTraces[0][0].t.barwidth / 100;

  // if defined, apply trace width
  applyAttributes(sieve);

  // store the bar center in each calcdata item
  setBarCenterAndWidth(pa, sieve);

  // update position axes
  updatePositionAxis(pa, sieve, overlap);
}
function applyAttributes(sieve) {
  var calcTraces = sieve.traces;
  var i, j;
  for (i = 0; i < calcTraces.length; i++) {
    var calcTrace = calcTraces[i];
    var calcTrace0 = calcTrace[0];
    var fullTrace = calcTrace0.trace;
    var t = calcTrace0.t;
    var offset = fullTrace._offset || fullTrace.offset;
    var initialPoffset = t.poffset;
    var newPoffset;
    if (isArrayOrTypedArray(offset)) {
      // if offset is an array, then clone it into t.poffset.
      newPoffset = Array.prototype.slice.call(offset, 0, calcTrace.length);

      // guard against non-numeric items
      for (j = 0; j < newPoffset.length; j++) {
        if (!isNumeric(newPoffset[j])) {
          newPoffset[j] = initialPoffset;
        }
      }

      // if the length of the array is too short,
      // then extend it with the initial value of t.poffset
      for (j = newPoffset.length; j < calcTrace.length; j++) {
        newPoffset.push(initialPoffset);
      }
      t.poffset = newPoffset;
    } else if (offset !== undefined) {
      t.poffset = offset;
    }
    var width = fullTrace._width || fullTrace.width;
    var initialBarwidth = t.barwidth;
    if (isArrayOrTypedArray(width)) {
      // if width is an array, then clone it into t.barwidth.
      var newBarwidth = Array.prototype.slice.call(width, 0, calcTrace.length);

      // guard against non-numeric items
      for (j = 0; j < newBarwidth.length; j++) {
        if (!isNumeric(newBarwidth[j])) newBarwidth[j] = initialBarwidth;
      }

      // if the length of the array is too short,
      // then extend it with the initial value of t.barwidth
      for (j = newBarwidth.length; j < calcTrace.length; j++) {
        newBarwidth.push(initialBarwidth);
      }
      t.barwidth = newBarwidth;

      // if user didn't set offset,
      // then correct t.poffset to ensure bars remain centered
      if (offset === undefined) {
        newPoffset = [];
        for (j = 0; j < calcTrace.length; j++) {
          newPoffset.push(initialPoffset + (initialBarwidth - newBarwidth[j]) / 2);
        }
        t.poffset = newPoffset;
      }
    } else if (width !== undefined) {
      t.barwidth = width;

      // if user didn't set offset,
      // then correct t.poffset to ensure bars remain centered
      if (offset === undefined) {
        t.poffset = initialPoffset + (initialBarwidth - width) / 2;
      }
    }
  }
}
function setBarCenterAndWidth(pa, sieve) {
  var calcTraces = sieve.traces;
  var pLetter = getAxisLetter(pa);
  for (var i = 0; i < calcTraces.length; i++) {
    var calcTrace = calcTraces[i];
    var t = calcTrace[0].t;
    var poffset = t.poffset;
    var poffsetIsArray = Array.isArray(poffset);
    var barwidth = t.barwidth;
    var barwidthIsArray = Array.isArray(barwidth);
    for (var j = 0; j < calcTrace.length; j++) {
      var calcBar = calcTrace[j];

      // store the actual bar width and position, for use by hover
      var width = calcBar.w = barwidthIsArray ? barwidth[j] : barwidth;
      if (calcBar.p === undefined) {
        calcBar.p = calcBar[pLetter];
        calcBar['orig_' + pLetter] = calcBar[pLetter];
      }
      var delta = (poffsetIsArray ? poffset[j] : poffset) + width / 2;
      calcBar[pLetter] = calcBar.p + delta;
    }
  }
}
function updatePositionAxis(pa, sieve, allowMinDtick) {
  var calcTraces = sieve.traces;
  var minDiff = sieve.minDiff;
  var vpad = minDiff / 2;
  Axes.minDtick(pa, sieve.minDiff, sieve.distinctPositions[0], allowMinDtick);
  for (var i = 0; i < calcTraces.length; i++) {
    var calcTrace = calcTraces[i];
    var calcTrace0 = calcTrace[0];
    var fullTrace = calcTrace0.trace;
    var pts = [];
    var bar, l, r, j;
    for (j = 0; j < calcTrace.length; j++) {
      bar = calcTrace[j];
      l = bar.p - vpad;
      r = bar.p + vpad;
      pts.push(l, r);
    }
    if (fullTrace.width || fullTrace.offset) {
      var t = calcTrace0.t;
      var poffset = t.poffset;
      var barwidth = t.barwidth;
      var poffsetIsArray = Array.isArray(poffset);
      var barwidthIsArray = Array.isArray(barwidth);
      for (j = 0; j < calcTrace.length; j++) {
        bar = calcTrace[j];
        var calcBarOffset = poffsetIsArray ? poffset[j] : poffset;
        var calcBarWidth = barwidthIsArray ? barwidth[j] : barwidth;
        l = bar.p + calcBarOffset;
        r = l + calcBarWidth;
        pts.push(l, r);
      }
    }
    fullTrace._extremes[pa._id] = Axes.findExtremes(pa, pts, {
      padded: false
    });
  }
}

// store these bar bases and tops in calcdata
// and make sure the size axis includes zero,
// along with the bases and tops of each bar.
function setBaseAndTop(sa, sieve) {
  var calcTraces = sieve.traces;
  var sLetter = getAxisLetter(sa);
  for (var i = 0; i < calcTraces.length; i++) {
    var calcTrace = calcTraces[i];
    var fullTrace = calcTrace[0].trace;
    var isScatter = fullTrace.type === 'scatter';
    var isVertical = fullTrace.orientation === 'v';
    var pts = [];
    var tozero = false;
    for (var j = 0; j < calcTrace.length; j++) {
      var bar = calcTrace[j];
      var base = isScatter ? 0 : bar.b;
      var top = isScatter ? isVertical ? bar.y : bar.x : base + bar.s;
      bar[sLetter] = top;
      pts.push(top);
      if (bar.hasB) pts.push(base);
      if (!bar.hasB || !bar.b) {
        tozero = true;
      }
    }
    fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {
      tozero: tozero,
      padded: true
    });
  }
}
function stackBars(sa, sieve, opts) {
  var sLetter = getAxisLetter(sa);
  var calcTraces = sieve.traces;
  var calcTrace;
  var fullTrace;
  var isFunnel;
  var i, j;
  var bar;
  for (i = 0; i < calcTraces.length; i++) {
    calcTrace = calcTraces[i];
    fullTrace = calcTrace[0].trace;
    if (fullTrace.type === 'funnel') {
      for (j = 0; j < calcTrace.length; j++) {
        bar = calcTrace[j];
        if (bar.s !== BADNUM) {
          // create base of funnels
          sieve.put(bar.p, -0.5 * bar.s);
        }
      }
    }
  }
  for (i = 0; i < calcTraces.length; i++) {
    calcTrace = calcTraces[i];
    fullTrace = calcTrace[0].trace;
    isFunnel = fullTrace.type === 'funnel';
    var pts = [];
    for (j = 0; j < calcTrace.length; j++) {
      bar = calcTrace[j];
      if (bar.s !== BADNUM) {
        // stack current bar and get previous sum
        var value;
        if (isFunnel) {
          value = bar.s;
        } else {
          value = bar.s + bar.b;
        }
        var base = sieve.put(bar.p, value);
        var top = base + value;

        // store the bar base and top in each calcdata item
        bar.b = base;
        bar[sLetter] = top;
        if (!opts.norm) {
          pts.push(top);
          if (bar.hasB) {
            pts.push(base);
          }
        }
      }
    }

    // if barnorm is set, let normalizeBars update the axis range
    if (!opts.norm) {
      fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {
        // N.B. we don't stack base with 'base',
        // so set tozero:true always!
        tozero: true,
        padded: true
      });
    }
  }
}
function sieveBars(sieve) {
  var calcTraces = sieve.traces;
  for (var i = 0; i < calcTraces.length; i++) {
    var calcTrace = calcTraces[i];
    for (var j = 0; j < calcTrace.length; j++) {
      var bar = calcTrace[j];
      if (bar.s !== BADNUM) {
        sieve.put(bar.p, bar.b + bar.s);
      }
    }
  }
}
function unhideBarsWithinTrace(sieve, pa) {
  var calcTraces = sieve.traces;
  for (var i = 0; i < calcTraces.length; i++) {
    var calcTrace = calcTraces[i];
    var fullTrace = calcTrace[0].trace;
    if (fullTrace.base === undefined) {
      var inTraceSieve = new Sieve([calcTrace], {
        posAxis: pa,
        sepNegVal: true,
        overlapNoMerge: true
      });
      for (var j = 0; j < calcTrace.length; j++) {
        var bar = calcTrace[j];
        if (bar.p !== BADNUM) {
          // stack current bar and get previous sum
          var base = inTraceSieve.put(bar.p, bar.b + bar.s);

          // if previous sum if non-zero, this means:
          // multiple bars have same starting point are potentially hidden,
          // shift them vertically so that all bars are visible by default
          if (base) bar.b = base;
        }
      }
    }
  }
}

// Note:
//
// normalizeBars requires that either sieveBars or stackBars has been
// previously invoked.
function normalizeBars(sa, sieve, opts) {
  var calcTraces = sieve.traces;
  var sLetter = getAxisLetter(sa);
  var sTop = opts.norm === 'fraction' ? 1 : 100;
  var sTiny = sTop / 1e9; // in case of rounding error in sum
  var sMin = sa.l2c(sa.c2l(0));
  var sMax = opts.mode === 'stack' ? sTop : sMin;
  function needsPadding(v) {
    return isNumeric(sa.c2l(v)) && (v < sMin - sTiny || v > sMax + sTiny || !isNumeric(sMin));
  }
  for (var i = 0; i < calcTraces.length; i++) {
    var calcTrace = calcTraces[i];
    var fullTrace = calcTrace[0].trace;
    var pts = [];
    var tozero = false;
    var padded = false;
    for (var j = 0; j < calcTrace.length; j++) {
      var bar = calcTrace[j];
      if (bar.s !== BADNUM) {
        var scale = Math.abs(sTop / sieve.get(bar.p, bar.s));
        bar.b *= scale;
        bar.s *= scale;
        var base = bar.b;
        var top = base + bar.s;
        bar[sLetter] = top;
        pts.push(top);
        padded = padded || needsPadding(top);
        if (bar.hasB) {
          pts.push(base);
          padded = padded || needsPadding(base);
        }
        if (!bar.hasB || !bar.b) {
          tozero = true;
        }
      }
    }
    fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {
      tozero: tozero,
      padded: padded
    });
  }
}

// find the full position span of bars at each position
// for use by hover, to ensure labels move in if bars are
// narrower than the space they're in.
// run once per trace group (subplot & direction) and
// the same mapping is attached to all calcdata traces
function collectExtents(calcTraces, pa) {
  var pLetter = getAxisLetter(pa);
  var extents = {};
  var i, j, cd;
  var pMin = Infinity;
  var pMax = -Infinity;
  for (i = 0; i < calcTraces.length; i++) {
    cd = calcTraces[i];
    for (j = 0; j < cd.length; j++) {
      var p = cd[j].p;
      if (isNumeric(p)) {
        pMin = Math.min(pMin, p);
        pMax = Math.max(pMax, p);
      }
    }
  }

  // this is just for positioning of hover labels, and nobody will care if
  // the label is 1px too far out; so round positions to 1/10K in case
  // position values don't exactly match from trace to trace
  var roundFactor = 10000 / (pMax - pMin);
  var round = extents.round = function (p) {
    return String(Math.round(roundFactor * (p - pMin)));
  };
  for (i = 0; i < calcTraces.length; i++) {
    cd = calcTraces[i];
    cd[0].t.extents = extents;
    var poffset = cd[0].t.poffset;
    var poffsetIsArray = Array.isArray(poffset);
    for (j = 0; j < cd.length; j++) {
      var di = cd[j];
      var p0 = di[pLetter] - di.w / 2;
      if (isNumeric(p0)) {
        var p1 = di[pLetter] + di.w / 2;
        var pVal = round(di.p);
        if (extents[pVal]) {
          extents[pVal] = [Math.min(p0, extents[pVal][0]), Math.max(p1, extents[pVal][1])];
        } else {
          extents[pVal] = [p0, p1];
        }
      }
      di.p0 = di.p + (poffsetIsArray ? poffset[j] : poffset);
      di.p1 = di.p0 + di.w;
      di.s0 = di.b;
      di.s1 = di.s0 + di.s;
    }
  }
}
function getAxisLetter(ax) {
  return ax._id.charAt(0);
}
module.exports = {
  crossTraceCalc: crossTraceCalc,
  setGroupPositions: setGroupPositions
};

/***/ }),

/***/ 1546:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = Sieve;
var distinctVals = (__webpack_require__(1828).distinctVals);

/**
 * Helper class to sieve data from traces into bins
 *
 * @class
 *
 * @param {Array} traces
*   Array of calculated traces
 * @param {object} opts
 *  - @param {boolean} [sepNegVal]
 *      If true, then split data at the same position into a bar
 *      for positive values and another for negative values
 *  - @param {boolean} [overlapNoMerge]
 *     If true, then don't merge overlapping bars into a single bar
 */
function Sieve(traces, opts) {
  this.traces = traces;
  this.sepNegVal = opts.sepNegVal;
  this.overlapNoMerge = opts.overlapNoMerge;

  // for single-bin histograms - see histogram/calc
  var width1 = Infinity;
  var axLetter = opts.posAxis._id.charAt(0);
  var positions = [];
  for (var i = 0; i < traces.length; i++) {
    var trace = traces[i];
    for (var j = 0; j < trace.length; j++) {
      var bar = trace[j];
      var pos = bar.p;
      if (pos === undefined) {
        pos = bar[axLetter];
      }
      if (pos !== undefined) positions.push(pos);
    }
    if (trace[0] && trace[0].width1) {
      width1 = Math.min(trace[0].width1, width1);
    }
  }
  this.positions = positions;
  var dv = distinctVals(positions);
  this.distinctPositions = dv.vals;
  if (dv.vals.length === 1 && width1 !== Infinity) this.minDiff = width1;else this.minDiff = Math.min(dv.minDiff, width1);
  var type = (opts.posAxis || {}).type;
  if (type === 'category' || type === 'multicategory') {
    this.minDiff = 1;
  }
  this.binWidth = this.minDiff;
  this.bins = {};
}

/**
 * Sieve datum
 *
 * @method
 * @param {number} position
 * @param {number} value
 * @returns {number} Previous bin value
 */
Sieve.prototype.put = function put(position, value) {
  var label = this.getLabel(position, value);
  var oldValue = this.bins[label] || 0;
  this.bins[label] = oldValue + value;
  return oldValue;
};

/**
 * Get current bin value for a given datum
 *
 * @method
 * @param {number} position  Position of datum
 * @param {number} [value]   Value of datum
 *                           (required if this.sepNegVal is true)
 * @returns {number} Current bin value
 */
Sieve.prototype.get = function get(position, value) {
  var label = this.getLabel(position, value);
  return this.bins[label] || 0;
};

/**
 * Get bin label for a given datum
 *
 * @method
 * @param {number} position  Position of datum
 * @param {number} [value]   Value of datum
 *                           (required if this.sepNegVal is true)
 * @returns {string} Bin label
 * (prefixed with a 'v' if value is negative and this.sepNegVal is
 * true; otherwise prefixed with '^')
 */
Sieve.prototype.getLabel = function getLabel(position, value) {
  var prefix = value < 0 && this.sepNegVal ? 'v' : '^';
  var label = this.overlapNoMerge ? position : Math.round(position / this.binWidth);
  return prefix + label;
};

/***/ }),

/***/ 4062:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var colorScaleAttrs = __webpack_require__(693);
var axisHoverFormat = (__webpack_require__(2663).axisHoverFormat);
var hovertemplateAttrs = (__webpack_require__(5386)/* .hovertemplateAttrs */ .fF);
var mesh3dAttrs = __webpack_require__(2418);
var baseAttrs = __webpack_require__(9012);
var extendFlat = (__webpack_require__(1426).extendFlat);
var attrs = {
  x: {
    valType: 'data_array',
    editType: 'calc+clearAxisTypes'
  },
  y: {
    valType: 'data_array',
    editType: 'calc+clearAxisTypes'
  },
  z: {
    valType: 'data_array',
    editType: 'calc+clearAxisTypes'
  },
  u: {
    valType: 'data_array',
    editType: 'calc'
  },
  v: {
    valType: 'data_array',
    editType: 'calc'
  },
  w: {
    valType: 'data_array',
    editType: 'calc'
  },
  // TODO add way to specify cone positions independently of the vector field
  // provided, similar to MATLAB's coneplot Cx/Cy/Cz meshgrids,
  // see https://www.mathworks.com/help/matlab/ref/coneplot.html
  //
  // Alternatively, if our goal is only to 'fill in gaps' in the vector data,
  // we could try to extend the heatmap 'connectgaps' algorithm to 3D.
  // From AJ: this particular algorithm which amounts to a Poisson equation,
  // both for interpolation and extrapolation - is the right one to use for
  // cones too.  It makes a field with zero divergence, which is a good
  // baseline assumption for vector fields.
  //
  // cones: {
  //     // potential attributes to add:
  //     //
  //     // - meshmode: 'cartesian-product', 'pts', 'grid'
  //     //
  //     // under `meshmode: 'grid'`
  //     // - (x|y|z)grid.start
  //     // - (x|y|z)grid.end
  //     // - (x|y|z)grid.size
  //
  //     x: {
  //         valType: 'data_array',
  //         editType: 'calc',
  //
  //     },
  //     y: {
  //         valType: 'data_array',
  //         editType: 'calc',
  //
  //     },
  //     z: {
  //         valType: 'data_array',
  //         editType: 'calc',
  //
  //     },
  //
  //     editType: 'calc',
  //
  // },

  sizemode: {
    valType: 'enumerated',
    values: ['scaled', 'absolute'],
    editType: 'calc',
    dflt: 'scaled'
  },
  sizeref: {
    valType: 'number',
    editType: 'calc',
    min: 0
  },
  anchor: {
    valType: 'enumerated',
    editType: 'calc',
    values: ['tip', 'tail', 'cm', 'center'],
    dflt: 'cm'
  },
  text: {
    valType: 'string',
    dflt: '',
    arrayOk: true,
    editType: 'calc'
  },
  hovertext: {
    valType: 'string',
    dflt: '',
    arrayOk: true,
    editType: 'calc'
  },
  hovertemplate: hovertemplateAttrs({
    editType: 'calc'
  }, {
    keys: ['norm']
  }),
  uhoverformat: axisHoverFormat('u', 1),
  vhoverformat: axisHoverFormat('v', 1),
  whoverformat: axisHoverFormat('w', 1),
  xhoverformat: axisHoverFormat('x'),
  yhoverformat: axisHoverFormat('y'),
  zhoverformat: axisHoverFormat('z'),
  showlegend: extendFlat({}, baseAttrs.showlegend, {
    dflt: false
  })
};
extendFlat(attrs, colorScaleAttrs('', {
  colorAttr: 'u/v/w norm',
  showScaleDflt: true,
  editTypeOverride: 'calc'
}));
var fromMesh3d = ['opacity', 'lightposition', 'lighting'];
fromMesh3d.forEach(function (k) {
  attrs[k] = mesh3dAttrs[k];
});
attrs.hoverinfo = extendFlat({}, baseAttrs.hoverinfo, {
  editType: 'calc',
  flags: ['x', 'y', 'z', 'u', 'v', 'w', 'norm', 'text', 'name'],
  dflt: 'x+y+z+norm+text+name'
});
attrs.transforms = undefined;
module.exports = attrs;

/***/ }),

/***/ 1371:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var colorscaleCalc = __webpack_require__(8803);
module.exports = function calc(gd, trace) {
  var u = trace.u;
  var v = trace.v;
  var w = trace.w;
  var len = Math.min(trace.x.length, trace.y.length, trace.z.length, u.length, v.length, w.length);
  var normMax = -Infinity;
  var normMin = Infinity;
  for (var i = 0; i < len; i++) {
    var uu = u[i];
    var vv = v[i];
    var ww = w[i];
    var norm = Math.sqrt(uu * uu + vv * vv + ww * ww);
    normMax = Math.max(normMax, norm);
    normMin = Math.min(normMin, norm);
  }
  trace._len = len;
  trace._normMax = normMax;
  colorscaleCalc(gd, trace, {
    vals: [normMin, normMax],
    containerStr: '',
    cLetter: 'c'
  });
};

/***/ }),

/***/ 5453:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var conePlot = (__webpack_require__(9330).gl_cone3d);
var createConeMesh = (__webpack_require__(9330).gl_cone3d.createConeMesh);
var simpleMap = (__webpack_require__(1828).simpleMap);
var parseColorScale = (__webpack_require__(1697).parseColorScale);
var extractOpts = (__webpack_require__(1081).extractOpts);
var zip3 = __webpack_require__(60);
function Cone(scene, uid) {
  this.scene = scene;
  this.uid = uid;
  this.mesh = null;
  this.data = null;
}
var proto = Cone.prototype;
proto.handlePick = function (selection) {
  if (selection.object === this.mesh) {
    var selectIndex = selection.index = selection.data.index;
    var xx = this.data.x[selectIndex];
    var yy = this.data.y[selectIndex];
    var zz = this.data.z[selectIndex];
    var uu = this.data.u[selectIndex];
    var vv = this.data.v[selectIndex];
    var ww = this.data.w[selectIndex];
    selection.traceCoordinate = [xx, yy, zz, uu, vv, ww, Math.sqrt(uu * uu + vv * vv + ww * ww)];
    var text = this.data.hovertext || this.data.text;
    if (Array.isArray(text) && text[selectIndex] !== undefined) {
      selection.textLabel = text[selectIndex];
    } else if (text) {
      selection.textLabel = text;
    }
    return true;
  }
};
var axisName2scaleIndex = {
  xaxis: 0,
  yaxis: 1,
  zaxis: 2
};
var anchor2coneOffset = {
  tip: 1,
  tail: 0,
  cm: 0.25,
  center: 0.5
};
var anchor2coneSpan = {
  tip: 1,
  tail: 1,
  cm: 0.75,
  center: 0.5
};
function convert(scene, trace) {
  var sceneLayout = scene.fullSceneLayout;
  var dataScale = scene.dataScale;
  var coneOpts = {};
  function toDataCoords(arr, axisName) {
    var ax = sceneLayout[axisName];
    var scale = dataScale[axisName2scaleIndex[axisName]];
    return simpleMap(arr, function (v) {
      return ax.d2l(v) * scale;
    });
  }
  coneOpts.vectors = zip3(toDataCoords(trace.u, 'xaxis'), toDataCoords(trace.v, 'yaxis'), toDataCoords(trace.w, 'zaxis'), trace._len);
  coneOpts.positions = zip3(toDataCoords(trace.x, 'xaxis'), toDataCoords(trace.y, 'yaxis'), toDataCoords(trace.z, 'zaxis'), trace._len);
  var cOpts = extractOpts(trace);
  coneOpts.colormap = parseColorScale(trace);
  coneOpts.vertexIntensityBounds = [cOpts.min / trace._normMax, cOpts.max / trace._normMax];
  coneOpts.coneOffset = anchor2coneOffset[trace.anchor];
  if (trace.sizemode === 'scaled') {
    // unitless sizeref
    coneOpts.coneSize = trace.sizeref || 0.5;
  } else {
    // sizeref here has unit of velocity
    coneOpts.coneSize = trace.sizeref && trace._normMax ? trace.sizeref / trace._normMax : 0.5;
  }
  var meshData = conePlot(coneOpts);

  // pass gl-mesh3d lighting attributes
  var lp = trace.lightposition;
  meshData.lightPosition = [lp.x, lp.y, lp.z];
  meshData.ambient = trace.lighting.ambient;
  meshData.diffuse = trace.lighting.diffuse;
  meshData.specular = trace.lighting.specular;
  meshData.roughness = trace.lighting.roughness;
  meshData.fresnel = trace.lighting.fresnel;
  meshData.opacity = trace.opacity;

  // stash autorange pad value
  trace._pad = anchor2coneSpan[trace.anchor] * meshData.vectorScale * meshData.coneScale * trace._normMax;
  return meshData;
}
proto.update = function (data) {
  this.data = data;
  var meshData = convert(this.scene, data);
  this.mesh.update(meshData);
};
proto.dispose = function () {
  this.scene.glplot.remove(this.mesh);
  this.mesh.dispose();
};
function createConeTrace(scene, data) {
  var gl = scene.glplot.gl;
  var meshData = convert(scene, data);
  var mesh = createConeMesh(gl, meshData);
  var cone = new Cone(scene, data.uid);
  cone.mesh = mesh;
  cone.data = data;
  mesh._trace = cone;
  scene.glplot.add(mesh);
  return cone;
}
module.exports = createConeTrace;

/***/ }),

/***/ 1750:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var colorscaleDefaults = __webpack_require__(1586);
var attributes = __webpack_require__(4062);
module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
  function coerce(attr, dflt) {
    return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
  }
  var u = coerce('u');
  var v = coerce('v');
  var w = coerce('w');
  var x = coerce('x');
  var y = coerce('y');
  var z = coerce('z');
  if (!u || !u.length || !v || !v.length || !w || !w.length || !x || !x.length || !y || !y.length || !z || !z.length) {
    traceOut.visible = false;
    return;
  }
  coerce('sizeref');
  coerce('sizemode');
  coerce('anchor');
  coerce('lighting.ambient');
  coerce('lighting.diffuse');
  coerce('lighting.specular');
  coerce('lighting.roughness');
  coerce('lighting.fresnel');
  coerce('lightposition.x');
  coerce('lightposition.y');
  coerce('lightposition.z');
  colorscaleDefaults(traceIn, traceOut, layout, coerce, {
    prefix: '',
    cLetter: 'c'
  });
  coerce('text');
  coerce('hovertext');
  coerce('hovertemplate');
  coerce('uhoverformat');
  coerce('vhoverformat');
  coerce('whoverformat');
  coerce('xhoverformat');
  coerce('yhoverformat');
  coerce('zhoverformat');

  // disable 1D transforms (for now)
  traceOut._length = null;
};

/***/ }),

/***/ 8128:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  moduleType: 'trace',
  name: 'cone',
  basePlotModule: __webpack_require__(8547),
  categories: ['gl3d', 'showLegend'],
  attributes: __webpack_require__(4062),
  supplyDefaults: __webpack_require__(1750),
  colorbar: {
    min: 'cmin',
    max: 'cmax'
  },
  calc: __webpack_require__(1371),
  plot: __webpack_require__(5453),
  eventData: function (out, pt) {
    out.norm = pt.traceCoordinate[6];
    return out;
  },
  meta: {}
};

/***/ }),

/***/ 3907:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var maxRowLength = (__webpack_require__(1828).maxRowLength);

/* Return a list of empty points in 2D array z
 * each empty point z[i][j] gives an array [i, j, neighborCount]
 * neighborCount is the count of 4 nearest neighbors that DO exist
 * this is to give us an order of points to evaluate for interpolation.
 * if no neighbors exist, we iteratively look for neighbors that HAVE
 * neighbors, and add a fractional neighborCount
 */
module.exports = function findEmpties(z) {
  var empties = [];
  var neighborHash = {};
  var noNeighborList = [];
  var nextRow = z[0];
  var row = [];
  var blank = [0, 0, 0];
  var rowLength = maxRowLength(z);
  var prevRow;
  var i;
  var j;
  var thisPt;
  var p;
  var neighborCount;
  var newNeighborHash;
  var foundNewNeighbors;
  for (i = 0; i < z.length; i++) {
    prevRow = row;
    row = nextRow;
    nextRow = z[i + 1] || [];
    for (j = 0; j < rowLength; j++) {
      if (row[j] === undefined) {
        neighborCount = (row[j - 1] !== undefined ? 1 : 0) + (row[j + 1] !== undefined ? 1 : 0) + (prevRow[j] !== undefined ? 1 : 0) + (nextRow[j] !== undefined ? 1 : 0);
        if (neighborCount) {
          // for this purpose, don't count off-the-edge points
          // as undefined neighbors
          if (i === 0) neighborCount++;
          if (j === 0) neighborCount++;
          if (i === z.length - 1) neighborCount++;
          if (j === row.length - 1) neighborCount++;

          // if all neighbors that could exist do, we don't
          // need this for finding farther neighbors
          if (neighborCount < 4) {
            neighborHash[[i, j]] = [i, j, neighborCount];
          }
          empties.push([i, j, neighborCount]);
        } else noNeighborList.push([i, j]);
      }
    }
  }
  while (noNeighborList.length) {
    newNeighborHash = {};
    foundNewNeighbors = false;

    // look for cells that now have neighbors but didn't before
    for (p = noNeighborList.length - 1; p >= 0; p--) {
      thisPt = noNeighborList[p];
      i = thisPt[0];
      j = thisPt[1];
      neighborCount = ((neighborHash[[i - 1, j]] || blank)[2] + (neighborHash[[i + 1, j]] || blank)[2] + (neighborHash[[i, j - 1]] || blank)[2] + (neighborHash[[i, j + 1]] || blank)[2]) / 20;
      if (neighborCount) {
        newNeighborHash[thisPt] = [i, j, neighborCount];
        noNeighborList.splice(p, 1);
        foundNewNeighbors = true;
      }
    }
    if (!foundNewNeighbors) {
      throw 'findEmpties iterated with no new neighbors';
    }

    // put these new cells into the main neighbor list
    for (thisPt in newNeighborHash) {
      neighborHash[thisPt] = newNeighborHash[thisPt];
      empties.push(newNeighborHash[thisPt]);
    }
  }

  // sort the full list in descending order of neighbor count
  return empties.sort(function (a, b) {
    return b[2] - a[2];
  });
};

/***/ }),

/***/ 824:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var INTERPTHRESHOLD = 1e-2;
var NEIGHBORSHIFTS = [[-1, 0], [1, 0], [0, -1], [0, 1]];
function correctionOvershoot(maxFractionalChange) {
  // start with less overshoot, until we know it's converging,
  // then ramp up the overshoot for faster convergence
  return 0.5 - 0.25 * Math.min(1, maxFractionalChange * 0.5);
}

/*
 * interp2d: Fill in missing data from a 2D array using an iterative
 *   poisson equation solver with zero-derivative BC at edges.
 *   Amazingly, this just amounts to repeatedly averaging all the existing
 *   nearest neighbors, at least if we don't take x/y scaling into account,
 *   which is the right approach here where x and y may not even have the
 *   same units.
 *
 * @param {array of arrays} z
 *      The 2D array to fill in. Will be mutated here. Assumed to already be
 *      cleaned, so all entries are numbers except gaps, which are `undefined`.
 * @param {array of arrays} emptyPoints
 *      Each entry [i, j, neighborCount] for empty points z[i][j] and the number
 *      of neighbors that are *not* missing. Assumed to be sorted from most to
 *      least neighbors, as produced by heatmap/find_empties.
 */
module.exports = function interp2d(z, emptyPoints) {
  var maxFractionalChange = 1;
  var i;

  // one pass to fill in a starting value for all the empties
  iterateInterp2d(z, emptyPoints);

  // we're don't need to iterate lone empties - remove them
  for (i = 0; i < emptyPoints.length; i++) {
    if (emptyPoints[i][2] < 4) break;
  }
  // but don't remove these points from the original array,
  // we'll use them for masking, so make a copy.
  emptyPoints = emptyPoints.slice(i);
  for (i = 0; i < 100 && maxFractionalChange > INTERPTHRESHOLD; i++) {
    maxFractionalChange = iterateInterp2d(z, emptyPoints, correctionOvershoot(maxFractionalChange));
  }
  if (maxFractionalChange > INTERPTHRESHOLD) {
    Lib.log('interp2d didn\'t converge quickly', maxFractionalChange);
  }
  return z;
};
function iterateInterp2d(z, emptyPoints, overshoot) {
  var maxFractionalChange = 0;
  var thisPt;
  var i;
  var j;
  var p;
  var q;
  var neighborShift;
  var neighborRow;
  var neighborVal;
  var neighborCount;
  var neighborSum;
  var initialVal;
  var minNeighbor;
  var maxNeighbor;
  for (p = 0; p < emptyPoints.length; p++) {
    thisPt = emptyPoints[p];
    i = thisPt[0];
    j = thisPt[1];
    initialVal = z[i][j];
    neighborSum = 0;
    neighborCount = 0;
    for (q = 0; q < 4; q++) {
      neighborShift = NEIGHBORSHIFTS[q];
      neighborRow = z[i + neighborShift[0]];
      if (!neighborRow) continue;
      neighborVal = neighborRow[j + neighborShift[1]];
      if (neighborVal !== undefined) {
        if (neighborSum === 0) {
          minNeighbor = maxNeighbor = neighborVal;
        } else {
          minNeighbor = Math.min(minNeighbor, neighborVal);
          maxNeighbor = Math.max(maxNeighbor, neighborVal);
        }
        neighborCount++;
        neighborSum += neighborVal;
      }
    }
    if (neighborCount === 0) {
      throw 'iterateInterp2d order is wrong: no defined neighbors';
    }

    // this is the laplace equation interpolation:
    // each point is just the average of its neighbors
    // note that this ignores differential x/y scaling
    // which I think is the right approach, since we
    // don't know what that scaling means
    z[i][j] = neighborSum / neighborCount;
    if (initialVal === undefined) {
      if (neighborCount < 4) maxFractionalChange = 1;
    } else {
      // we can make large empty regions converge faster
      // if we overshoot the change vs the previous value
      z[i][j] = (1 + overshoot) * z[i][j] - overshoot * initialVal;
      if (maxNeighbor > minNeighbor) {
        maxFractionalChange = Math.max(maxFractionalChange, Math.abs(z[i][j] - initialVal) / (maxNeighbor - minNeighbor));
      }
    }
  }
  return maxFractionalChange;
}

/***/ }),

/***/ 2810:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var colorScaleAttrs = __webpack_require__(693);
var axisHoverFormat = (__webpack_require__(2663).axisHoverFormat);
var hovertemplateAttrs = (__webpack_require__(5386)/* .hovertemplateAttrs */ .fF);
var meshAttrs = __webpack_require__(2418);
var baseAttrs = __webpack_require__(9012);
var extendFlat = (__webpack_require__(1426).extendFlat);
var overrideAll = (__webpack_require__(962).overrideAll);
function makeSliceAttr(axLetter) {
  return {
    show: {
      valType: 'boolean',
      dflt: false
    },
    locations: {
      valType: 'data_array',
      dflt: []
    },
    fill: {
      valType: 'number',
      min: 0,
      max: 1,
      dflt: 1
    }
  };
}
function makeCapAttr(axLetter) {
  return {
    show: {
      valType: 'boolean',
      dflt: true
    },
    fill: {
      valType: 'number',
      min: 0,
      max: 1,
      dflt: 1
    }
  };
}
var attrs = module.exports = overrideAll(extendFlat({
  x: {
    valType: 'data_array'
  },
  y: {
    valType: 'data_array'
  },
  z: {
    valType: 'data_array'
  },
  value: {
    valType: 'data_array'
  },
  isomin: {
    valType: 'number'
  },
  isomax: {
    valType: 'number'
  },
  surface: {
    show: {
      valType: 'boolean',
      dflt: true
    },
    count: {
      valType: 'integer',
      dflt: 2,
      min: 1
    },
    fill: {
      valType: 'number',
      min: 0,
      max: 1,
      dflt: 1
    },
    pattern: {
      valType: 'flaglist',
      flags: ['A', 'B', 'C', 'D', 'E'],
      extras: ['all', 'odd', 'even'],
      dflt: 'all'
    }
  },
  spaceframe: {
    show: {
      valType: 'boolean',
      dflt: false
    },
    fill: {
      valType: 'number',
      min: 0,
      max: 1,
      dflt: 0.15
    }
  },
  slices: {
    x: makeSliceAttr('x'),
    y: makeSliceAttr('y'),
    z: makeSliceAttr('z')
  },
  caps: {
    x: makeCapAttr('x'),
    y: makeCapAttr('y'),
    z: makeCapAttr('z')
  },
  text: {
    valType: 'string',
    dflt: '',
    arrayOk: true
  },
  hovertext: {
    valType: 'string',
    dflt: '',
    arrayOk: true
  },
  hovertemplate: hovertemplateAttrs(),
  xhoverformat: axisHoverFormat('x'),
  yhoverformat: axisHoverFormat('y'),
  zhoverformat: axisHoverFormat('z'),
  valuehoverformat: axisHoverFormat('value', 1),
  showlegend: extendFlat({}, baseAttrs.showlegend, {
    dflt: false
  })
}, colorScaleAttrs('', {
  colorAttr: '`value`',
  showScaleDflt: true,
  editTypeOverride: 'calc'
}), {
  opacity: meshAttrs.opacity,
  lightposition: meshAttrs.lightposition,
  lighting: meshAttrs.lighting,
  flatshading: meshAttrs.flatshading,
  contour: meshAttrs.contour,
  hoverinfo: extendFlat({}, baseAttrs.hoverinfo)
}), 'calc', 'nested');

// required defaults to speed up surface normal calculations
attrs.flatshading.dflt = true;
attrs.lighting.facenormalsepsilon.dflt = 0;
attrs.x.editType = attrs.y.editType = attrs.z.editType = attrs.value.editType = 'calc+clearAxisTypes';
attrs.transforms = undefined;

/***/ }),

/***/ 6959:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var colorscaleCalc = __webpack_require__(8803);
var processGrid = (__webpack_require__(8489).processGrid);
var filter = (__webpack_require__(8489).filter);
module.exports = function calc(gd, trace) {
  trace._len = Math.min(trace.x.length, trace.y.length, trace.z.length, trace.value.length);
  trace._x = filter(trace.x, trace._len);
  trace._y = filter(trace.y, trace._len);
  trace._z = filter(trace.z, trace._len);
  trace._value = filter(trace.value, trace._len);
  var grid = processGrid(trace);
  trace._gridFill = grid.fill;
  trace._Xs = grid.Xs;
  trace._Ys = grid.Ys;
  trace._Zs = grid.Zs;
  trace._len = grid.len;
  var min = Infinity;
  var max = -Infinity;
  for (var i = 0; i < trace._len; i++) {
    var v = trace._value[i];
    min = Math.min(min, v);
    max = Math.max(max, v);
  }
  trace._minValues = min;
  trace._maxValues = max;
  trace._vMin = trace.isomin === undefined || trace.isomin === null ? min : trace.isomin;
  trace._vMax = trace.isomax === undefined || trace.isomin === null ? max : trace.isomax;
  colorscaleCalc(gd, trace, {
    vals: [trace._vMin, trace._vMax],
    containerStr: '',
    cLetter: 'c'
  });
};

/***/ }),

/***/ 2674:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var createMesh = (__webpack_require__(9330).gl_mesh3d);
var parseColorScale = (__webpack_require__(1697).parseColorScale);
var str2RgbaArray = __webpack_require__(8614);
var extractOpts = (__webpack_require__(1081).extractOpts);
var zip3 = __webpack_require__(60);
var findNearestOnAxis = function (w, arr) {
  for (var q = arr.length - 1; q > 0; q--) {
    var min = Math.min(arr[q], arr[q - 1]);
    var max = Math.max(arr[q], arr[q - 1]);
    if (max > min && min < w && w <= max) {
      return {
        id: q,
        distRatio: (max - w) / (max - min)
      };
    }
  }
  return {
    id: 0,
    distRatio: 0
  };
};
function IsosurfaceTrace(scene, mesh, uid) {
  this.scene = scene;
  this.uid = uid;
  this.mesh = mesh;
  this.name = '';
  this.data = null;
  this.showContour = false;
}
var proto = IsosurfaceTrace.prototype;
proto.handlePick = function (selection) {
  if (selection.object === this.mesh) {
    var rawId = selection.data.index;
    var x = this.data._meshX[rawId];
    var y = this.data._meshY[rawId];
    var z = this.data._meshZ[rawId];
    var height = this.data._Ys.length;
    var depth = this.data._Zs.length;
    var i = findNearestOnAxis(x, this.data._Xs).id;
    var j = findNearestOnAxis(y, this.data._Ys).id;
    var k = findNearestOnAxis(z, this.data._Zs).id;
    var selectIndex = selection.index = k + depth * j + depth * height * i;
    selection.traceCoordinate = [this.data._meshX[selectIndex], this.data._meshY[selectIndex], this.data._meshZ[selectIndex], this.data._value[selectIndex]];
    var text = this.data.hovertext || this.data.text;
    if (Array.isArray(text) && text[selectIndex] !== undefined) {
      selection.textLabel = text[selectIndex];
    } else if (text) {
      selection.textLabel = text;
    }
    return true;
  }
};
proto.update = function (data) {
  var scene = this.scene;
  var layout = scene.fullSceneLayout;
  this.data = generateIsoMeshes(data);

  // Unpack position data
  function toDataCoords(axis, coord, scale, calendar) {
    return coord.map(function (x) {
      return axis.d2l(x, 0, calendar) * scale;
    });
  }
  var positions = zip3(toDataCoords(layout.xaxis, data._meshX, scene.dataScale[0], data.xcalendar), toDataCoords(layout.yaxis, data._meshY, scene.dataScale[1], data.ycalendar), toDataCoords(layout.zaxis, data._meshZ, scene.dataScale[2], data.zcalendar));
  var cells = zip3(data._meshI, data._meshJ, data._meshK);
  var config = {
    positions: positions,
    cells: cells,
    lightPosition: [data.lightposition.x, data.lightposition.y, data.lightposition.z],
    ambient: data.lighting.ambient,
    diffuse: data.lighting.diffuse,
    specular: data.lighting.specular,
    roughness: data.lighting.roughness,
    fresnel: data.lighting.fresnel,
    vertexNormalsEpsilon: data.lighting.vertexnormalsepsilon,
    faceNormalsEpsilon: data.lighting.facenormalsepsilon,
    opacity: data.opacity,
    contourEnable: data.contour.show,
    contourColor: str2RgbaArray(data.contour.color).slice(0, 3),
    contourWidth: data.contour.width,
    useFacetNormals: data.flatshading
  };
  var cOpts = extractOpts(data);
  config.vertexIntensity = data._meshIntensity;
  config.vertexIntensityBounds = [cOpts.min, cOpts.max];
  config.colormap = parseColorScale(data);

  // Update mesh
  this.mesh.update(config);
};
proto.dispose = function () {
  this.scene.glplot.remove(this.mesh);
  this.mesh.dispose();
};
var GRID_TYPES = ['xyz', 'xzy', 'yxz', 'yzx', 'zxy', 'zyx'];
function generateIsoMeshes(data) {
  data._meshI = [];
  data._meshJ = [];
  data._meshK = [];
  var showSurface = data.surface.show;
  var showSpaceframe = data.spaceframe.show;
  var surfaceFill = data.surface.fill;
  var spaceframeFill = data.spaceframe.fill;
  var drawingSurface = false;
  var drawingSpaceframe = false;
  var numFaces = 0;
  var numVertices;
  var beginVertextLength;
  var Xs = data._Xs;
  var Ys = data._Ys;
  var Zs = data._Zs;
  var width = Xs.length;
  var height = Ys.length;
  var depth = Zs.length;
  var filled = GRID_TYPES.indexOf(data._gridFill.replace(/-/g, '').replace(/\+/g, ''));
  var getIndex = function (i, j, k) {
    switch (filled) {
      case 5:
        // 'zyx'
        return k + depth * j + depth * height * i;
      case 4:
        // 'zxy'
        return k + depth * i + depth * width * j;
      case 3:
        // 'yzx'
        return j + height * k + height * depth * i;
      case 2:
        // 'yxz'
        return j + height * i + height * width * k;
      case 1:
        // 'xzy'
        return i + width * k + width * depth * j;
      default:
        // case 0: // 'xyz'
        return i + width * j + width * height * k;
    }
  };
  var minValues = data._minValues;
  var maxValues = data._maxValues;
  var vMin = data._vMin;
  var vMax = data._vMax;
  var allXs;
  var allYs;
  var allZs;
  var allVs;
  function findVertexId(x, y, z) {
    // could be used to find the vertex id of previously generated vertex within the group

    var len = allVs.length;
    for (var f = beginVertextLength; f < len; f++) {
      if (x === allXs[f] && y === allYs[f] && z === allZs[f]) {
        return f;
      }
    }
    return -1;
  }
  function beginGroup() {
    beginVertextLength = numVertices;
  }
  function emptyVertices() {
    allXs = [];
    allYs = [];
    allZs = [];
    allVs = [];
    numVertices = 0;
    beginGroup();
  }
  function addVertex(x, y, z, v) {
    allXs.push(x);
    allYs.push(y);
    allZs.push(z);
    allVs.push(v);
    numVertices++;
    return numVertices - 1;
  }
  function addFace(a, b, c) {
    data._meshI.push(a);
    data._meshJ.push(b);
    data._meshK.push(c);
    numFaces++;
    return numFaces - 1;
  }
  function getCenter(A, B, C) {
    var M = [];
    for (var i = 0; i < A.length; i++) {
      M[i] = (A[i] + B[i] + C[i]) / 3.0;
    }
    return M;
  }
  function getBetween(A, B, r) {
    var M = [];
    for (var i = 0; i < A.length; i++) {
      M[i] = A[i] * (1 - r) + r * B[i];
    }
    return M;
  }
  var activeFill;
  function setFill(fill) {
    activeFill = fill;
  }
  function createOpenTri(xyzv, abc) {
    var A = xyzv[0];
    var B = xyzv[1];
    var C = xyzv[2];
    var G = getCenter(A, B, C);
    var r = Math.sqrt(1 - activeFill);
    var p1 = getBetween(G, A, r);
    var p2 = getBetween(G, B, r);
    var p3 = getBetween(G, C, r);
    var a = abc[0];
    var b = abc[1];
    var c = abc[2];
    return {
      xyzv: [[A, B, p2], [p2, p1, A], [B, C, p3], [p3, p2, B], [C, A, p1], [p1, p3, C]],
      abc: [[a, b, -1], [-1, -1, a], [b, c, -1], [-1, -1, b], [c, a, -1], [-1, -1, c]]
    };
  }
  function styleIncludes(style, char) {
    if (style === 'all' || style === null) return true;
    return style.indexOf(char) > -1;
  }
  function mapValue(style, value) {
    if (style === null) return value;
    return style;
  }
  function drawTri(style, xyzv, abc) {
    beginGroup();
    var allXYZVs = [xyzv];
    var allABCs = [abc];
    if (activeFill >= 1) {
      allXYZVs = [xyzv];
      allABCs = [abc];
    } else if (activeFill > 0) {
      var openTri = createOpenTri(xyzv, abc);
      allXYZVs = openTri.xyzv;
      allABCs = openTri.abc;
    }
    for (var f = 0; f < allXYZVs.length; f++) {
      xyzv = allXYZVs[f];
      abc = allABCs[f];
      var pnts = [];
      for (var i = 0; i < 3; i++) {
        var x = xyzv[i][0];
        var y = xyzv[i][1];
        var z = xyzv[i][2];
        var v = xyzv[i][3];
        var id = abc[i] > -1 ? abc[i] : findVertexId(x, y, z);
        if (id > -1) {
          pnts[i] = id;
        } else {
          pnts[i] = addVertex(x, y, z, mapValue(style, v));
        }
      }
      addFace(pnts[0], pnts[1], pnts[2]);
    }
  }
  function drawQuad(style, xyzv, abcd) {
    var makeTri = function (i, j, k) {
      drawTri(style, [xyzv[i], xyzv[j], xyzv[k]], [abcd[i], abcd[j], abcd[k]]);
    };
    makeTri(0, 1, 2);
    makeTri(2, 3, 0);
  }
  function drawTetra(style, xyzv, abcd) {
    var makeTri = function (i, j, k) {
      drawTri(style, [xyzv[i], xyzv[j], xyzv[k]], [abcd[i], abcd[j], abcd[k]]);
    };
    makeTri(0, 1, 2);
    makeTri(3, 0, 1);
    makeTri(2, 3, 0);
    makeTri(1, 2, 3);
  }
  function calcIntersection(pointOut, pointIn, min, max) {
    var value = pointOut[3];
    if (value < min) value = min;
    if (value > max) value = max;
    var ratio = (pointOut[3] - value) / (pointOut[3] - pointIn[3] + 0.000000001); // we had to add this error to force solve the tiny caps

    var result = [];
    for (var s = 0; s < 4; s++) {
      result[s] = (1 - ratio) * pointOut[s] + ratio * pointIn[s];
    }
    return result;
  }
  function inRange(value, min, max) {
    return value >= min && value <= max;
  }
  function almostInFinalRange(value) {
    var vErr = 0.001 * (vMax - vMin);
    return value >= vMin - vErr && value <= vMax + vErr;
  }
  function getXYZV(indecies) {
    var xyzv = [];
    for (var q = 0; q < 4; q++) {
      var index = indecies[q];
      xyzv.push([data._x[index], data._y[index], data._z[index], data._value[index]]);
    }
    return xyzv;
  }
  var MAX_PASS = 3;
  function tryCreateTri(style, xyzv, abc, min, max, nPass) {
    if (!nPass) nPass = 1;
    abc = [-1, -1, -1]; // Note: for the moment we override indices
    // to run faster! But it is possible to comment this line
    // to reduce the number of vertices.

    var result = false;
    var ok = [inRange(xyzv[0][3], min, max), inRange(xyzv[1][3], min, max), inRange(xyzv[2][3], min, max)];
    if (!ok[0] && !ok[1] && !ok[2]) {
      return false;
    }
    var tryDrawTri = function (style, xyzv, abc) {
      if (
      // we check here if the points are in `real` iso-min/max range
      almostInFinalRange(xyzv[0][3]) && almostInFinalRange(xyzv[1][3]) && almostInFinalRange(xyzv[2][3])) {
        drawTri(style, xyzv, abc);
        return true;
      } else if (nPass < MAX_PASS) {
        return tryCreateTri(style, xyzv, abc, vMin, vMax, ++nPass); // i.e. second pass using actual vMin vMax bounds
      }

      return false;
    };
    if (ok[0] && ok[1] && ok[2]) {
      return tryDrawTri(style, xyzv, abc) || result;
    }
    var interpolated = false;
    [[0, 1, 2], [2, 0, 1], [1, 2, 0]].forEach(function (e) {
      if (ok[e[0]] && ok[e[1]] && !ok[e[2]]) {
        var A = xyzv[e[0]];
        var B = xyzv[e[1]];
        var C = xyzv[e[2]];
        var p1 = calcIntersection(C, A, min, max);
        var p2 = calcIntersection(C, B, min, max);
        result = tryDrawTri(style, [p2, p1, A], [-1, -1, abc[e[0]]]) || result;
        result = tryDrawTri(style, [A, B, p2], [abc[e[0]], abc[e[1]], -1]) || result;
        interpolated = true;
      }
    });
    if (interpolated) return result;
    [[0, 1, 2], [1, 2, 0], [2, 0, 1]].forEach(function (e) {
      if (ok[e[0]] && !ok[e[1]] && !ok[e[2]]) {
        var A = xyzv[e[0]];
        var B = xyzv[e[1]];
        var C = xyzv[e[2]];
        var p1 = calcIntersection(B, A, min, max);
        var p2 = calcIntersection(C, A, min, max);
        result = tryDrawTri(style, [p2, p1, A], [-1, -1, abc[e[0]]]) || result;
        interpolated = true;
      }
    });
    return result;
  }
  function tryCreateTetra(style, abcd, min, max) {
    var result = false;
    var xyzv = getXYZV(abcd);
    var ok = [inRange(xyzv[0][3], min, max), inRange(xyzv[1][3], min, max), inRange(xyzv[2][3], min, max), inRange(xyzv[3][3], min, max)];
    if (!ok[0] && !ok[1] && !ok[2] && !ok[3]) {
      return result;
    }
    if (ok[0] && ok[1] && ok[2] && ok[3]) {
      if (drawingSpaceframe) {
        result = drawTetra(style, xyzv, abcd) || result;
      }
      return result;
    }
    var interpolated = false;
    [[0, 1, 2, 3], [3, 0, 1, 2], [2, 3, 0, 1], [1, 2, 3, 0]].forEach(function (e) {
      if (ok[e[0]] && ok[e[1]] && ok[e[2]] && !ok[e[3]]) {
        var A = xyzv[e[0]];
        var B = xyzv[e[1]];
        var C = xyzv[e[2]];
        var D = xyzv[e[3]];
        if (drawingSpaceframe) {
          result = drawTri(style, [A, B, C], [abcd[e[0]], abcd[e[1]], abcd[e[2]]]) || result;
        } else {
          var p1 = calcIntersection(D, A, min, max);
          var p2 = calcIntersection(D, B, min, max);
          var p3 = calcIntersection(D, C, min, max);
          result = drawTri(null, [p1, p2, p3], [-1, -1, -1]) || result;
        }
        interpolated = true;
      }
    });
    if (interpolated) return result;
    [[0, 1, 2, 3], [1, 2, 3, 0], [2, 3, 0, 1], [3, 0, 1, 2], [0, 2, 3, 1], [1, 3, 2, 0]].forEach(function (e) {
      if (ok[e[0]] && ok[e[1]] && !ok[e[2]] && !ok[e[3]]) {
        var A = xyzv[e[0]];
        var B = xyzv[e[1]];
        var C = xyzv[e[2]];
        var D = xyzv[e[3]];
        var p1 = calcIntersection(C, A, min, max);
        var p2 = calcIntersection(C, B, min, max);
        var p3 = calcIntersection(D, B, min, max);
        var p4 = calcIntersection(D, A, min, max);
        if (drawingSpaceframe) {
          result = drawTri(style, [A, p4, p1], [abcd[e[0]], -1, -1]) || result;
          result = drawTri(style, [B, p2, p3], [abcd[e[1]], -1, -1]) || result;
        } else {
          result = drawQuad(null, [p1, p2, p3, p4], [-1, -1, -1, -1]) || result;
        }
        interpolated = true;
      }
    });
    if (interpolated) return result;
    [[0, 1, 2, 3], [1, 2, 3, 0], [2, 3, 0, 1], [3, 0, 1, 2]].forEach(function (e) {
      if (ok[e[0]] && !ok[e[1]] && !ok[e[2]] && !ok[e[3]]) {
        var A = xyzv[e[0]];
        var B = xyzv[e[1]];
        var C = xyzv[e[2]];
        var D = xyzv[e[3]];
        var p1 = calcIntersection(B, A, min, max);
        var p2 = calcIntersection(C, A, min, max);
        var p3 = calcIntersection(D, A, min, max);
        if (drawingSpaceframe) {
          result = drawTri(style, [A, p1, p2], [abcd[e[0]], -1, -1]) || result;
          result = drawTri(style, [A, p2, p3], [abcd[e[0]], -1, -1]) || result;
          result = drawTri(style, [A, p3, p1], [abcd[e[0]], -1, -1]) || result;
        } else {
          result = drawTri(null, [p1, p2, p3], [-1, -1, -1]) || result;
        }
        interpolated = true;
      }
    });
    return result;
  }
  function addCube(style, p000, p001, p010, p011, p100, p101, p110, p111, min, max) {
    var result = false;
    if (drawingSurface) {
      if (styleIncludes(style, 'A')) {
        result = tryCreateTetra(null, [p000, p001, p010, p100], min, max) || result;
      }
      if (styleIncludes(style, 'B')) {
        result = tryCreateTetra(null, [p001, p010, p011, p111], min, max) || result;
      }
      if (styleIncludes(style, 'C')) {
        result = tryCreateTetra(null, [p001, p100, p101, p111], min, max) || result;
      }
      if (styleIncludes(style, 'D')) {
        result = tryCreateTetra(null, [p010, p100, p110, p111], min, max) || result;
      }
      if (styleIncludes(style, 'E')) {
        result = tryCreateTetra(null, [p001, p010, p100, p111], min, max) || result;
      }
    }
    if (drawingSpaceframe) {
      result = tryCreateTetra(style, [p001, p010, p100, p111], min, max) || result;
    }
    return result;
  }
  function addRect(style, a, b, c, d, min, max, previousResult) {
    return [previousResult[0] === true ? true : tryCreateTri(style, getXYZV([a, b, c]), [a, b, c], min, max), previousResult[1] === true ? true : tryCreateTri(style, getXYZV([c, d, a]), [c, d, a], min, max)];
  }
  function begin2dCell(style, p00, p01, p10, p11, min, max, isEven, previousResult) {
    // used to create caps and/or slices on exact axis points
    if (isEven) {
      return addRect(style, p00, p01, p11, p10, min, max, previousResult);
    } else {
      return addRect(style, p01, p11, p10, p00, min, max, previousResult);
    }
  }
  function beginSection(style, i, j, k, min, max, distRatios) {
    // used to create slices between axis points

    var result = false;
    var A, B, C, D;
    var makeSection = function () {
      result = tryCreateTri(style, [A, B, C], [-1, -1, -1], min, max) || result;
      result = tryCreateTri(style, [C, D, A], [-1, -1, -1], min, max) || result;
    };
    var rX = distRatios[0];
    var rY = distRatios[1];
    var rZ = distRatios[2];
    if (rX) {
      A = getBetween(getXYZV([getIndex(i, j - 0, k - 0)])[0], getXYZV([getIndex(i - 1, j - 0, k - 0)])[0], rX);
      B = getBetween(getXYZV([getIndex(i, j - 0, k - 1)])[0], getXYZV([getIndex(i - 1, j - 0, k - 1)])[0], rX);
      C = getBetween(getXYZV([getIndex(i, j - 1, k - 1)])[0], getXYZV([getIndex(i - 1, j - 1, k - 1)])[0], rX);
      D = getBetween(getXYZV([getIndex(i, j - 1, k - 0)])[0], getXYZV([getIndex(i - 1, j - 1, k - 0)])[0], rX);
      makeSection();
    }
    if (rY) {
      A = getBetween(getXYZV([getIndex(i - 0, j, k - 0)])[0], getXYZV([getIndex(i - 0, j - 1, k - 0)])[0], rY);
      B = getBetween(getXYZV([getIndex(i - 0, j, k - 1)])[0], getXYZV([getIndex(i - 0, j - 1, k - 1)])[0], rY);
      C = getBetween(getXYZV([getIndex(i - 1, j, k - 1)])[0], getXYZV([getIndex(i - 1, j - 1, k - 1)])[0], rY);
      D = getBetween(getXYZV([getIndex(i - 1, j, k - 0)])[0], getXYZV([getIndex(i - 1, j - 1, k - 0)])[0], rY);
      makeSection();
    }
    if (rZ) {
      A = getBetween(getXYZV([getIndex(i - 0, j - 0, k)])[0], getXYZV([getIndex(i - 0, j - 0, k - 1)])[0], rZ);
      B = getBetween(getXYZV([getIndex(i - 0, j - 1, k)])[0], getXYZV([getIndex(i - 0, j - 1, k - 1)])[0], rZ);
      C = getBetween(getXYZV([getIndex(i - 1, j - 1, k)])[0], getXYZV([getIndex(i - 1, j - 1, k - 1)])[0], rZ);
      D = getBetween(getXYZV([getIndex(i - 1, j - 0, k)])[0], getXYZV([getIndex(i - 1, j - 0, k - 1)])[0], rZ);
      makeSection();
    }
    return result;
  }
  function begin3dCell(style, p000, p001, p010, p011, p100, p101, p110, p111, min, max, isEven) {
    // used to create spaceframe and/or iso-surfaces

    var cellStyle = style;
    if (isEven) {
      if (drawingSurface && style === 'even') cellStyle = null;
      return addCube(cellStyle, p000, p001, p010, p011, p100, p101, p110, p111, min, max);
    } else {
      if (drawingSurface && style === 'odd') cellStyle = null;
      return addCube(cellStyle, p111, p110, p101, p100, p011, p010, p001, p000, min, max);
    }
  }
  function draw2dX(style, items, min, max, previousResult) {
    var result = [];
    var n = 0;
    for (var q = 0; q < items.length; q++) {
      var i = items[q];
      for (var k = 1; k < depth; k++) {
        for (var j = 1; j < height; j++) {
          result.push(begin2dCell(style, getIndex(i, j - 1, k - 1), getIndex(i, j - 1, k), getIndex(i, j, k - 1), getIndex(i, j, k), min, max, (i + j + k) % 2, previousResult && previousResult[n] ? previousResult[n] : []));
          n++;
        }
      }
    }
    return result;
  }
  function draw2dY(style, items, min, max, previousResult) {
    var result = [];
    var n = 0;
    for (var q = 0; q < items.length; q++) {
      var j = items[q];
      for (var i = 1; i < width; i++) {
        for (var k = 1; k < depth; k++) {
          result.push(begin2dCell(style, getIndex(i - 1, j, k - 1), getIndex(i, j, k - 1), getIndex(i - 1, j, k), getIndex(i, j, k), min, max, (i + j + k) % 2, previousResult && previousResult[n] ? previousResult[n] : []));
          n++;
        }
      }
    }
    return result;
  }
  function draw2dZ(style, items, min, max, previousResult) {
    var result = [];
    var n = 0;
    for (var q = 0; q < items.length; q++) {
      var k = items[q];
      for (var j = 1; j < height; j++) {
        for (var i = 1; i < width; i++) {
          result.push(begin2dCell(style, getIndex(i - 1, j - 1, k), getIndex(i - 1, j, k), getIndex(i, j - 1, k), getIndex(i, j, k), min, max, (i + j + k) % 2, previousResult && previousResult[n] ? previousResult[n] : []));
          n++;
        }
      }
    }
    return result;
  }
  function draw3d(style, min, max) {
    for (var k = 1; k < depth; k++) {
      for (var j = 1; j < height; j++) {
        for (var i = 1; i < width; i++) {
          begin3dCell(style, getIndex(i - 1, j - 1, k - 1), getIndex(i - 1, j - 1, k), getIndex(i - 1, j, k - 1), getIndex(i - 1, j, k), getIndex(i, j - 1, k - 1), getIndex(i, j - 1, k), getIndex(i, j, k - 1), getIndex(i, j, k), min, max, (i + j + k) % 2);
        }
      }
    }
  }
  function drawSpaceframe(style, min, max) {
    drawingSpaceframe = true;
    draw3d(style, min, max);
    drawingSpaceframe = false;
  }
  function drawSurface(style, min, max) {
    drawingSurface = true;
    draw3d(style, min, max);
    drawingSurface = false;
  }
  function drawSectionX(style, items, min, max, distRatios, previousResult) {
    var result = [];
    var n = 0;
    for (var q = 0; q < items.length; q++) {
      var i = items[q];
      for (var k = 1; k < depth; k++) {
        for (var j = 1; j < height; j++) {
          result.push(beginSection(style, i, j, k, min, max, distRatios[q], previousResult && previousResult[n] ? previousResult[n] : []));
          n++;
        }
      }
    }
    return result;
  }
  function drawSectionY(style, items, min, max, distRatios, previousResult) {
    var result = [];
    var n = 0;
    for (var q = 0; q < items.length; q++) {
      var j = items[q];
      for (var i = 1; i < width; i++) {
        for (var k = 1; k < depth; k++) {
          result.push(beginSection(style, i, j, k, min, max, distRatios[q], previousResult && previousResult[n] ? previousResult[n] : []));
          n++;
        }
      }
    }
    return result;
  }
  function drawSectionZ(style, items, min, max, distRatios, previousResult) {
    var result = [];
    var n = 0;
    for (var q = 0; q < items.length; q++) {
      var k = items[q];
      for (var j = 1; j < height; j++) {
        for (var i = 1; i < width; i++) {
          result.push(beginSection(style, i, j, k, min, max, distRatios[q], previousResult && previousResult[n] ? previousResult[n] : []));
          n++;
        }
      }
    }
    return result;
  }
  function createRange(a, b) {
    var range = [];
    for (var q = a; q < b; q++) {
      range.push(q);
    }
    return range;
  }
  function insertGridPoints() {
    for (var i = 0; i < width; i++) {
      for (var j = 0; j < height; j++) {
        for (var k = 0; k < depth; k++) {
          var index = getIndex(i, j, k);
          addVertex(data._x[index], data._y[index], data._z[index], data._value[index]);
        }
      }
    }
  }
  function drawAll() {
    emptyVertices();

    // insert grid points
    insertGridPoints();
    var activeStyle = null;

    // draw spaceframes
    if (showSpaceframe && spaceframeFill) {
      setFill(spaceframeFill);
      drawSpaceframe(activeStyle, vMin, vMax);
    }

    // draw iso-surfaces
    if (showSurface && surfaceFill) {
      setFill(surfaceFill);
      var surfacePattern = data.surface.pattern;
      var surfaceCount = data.surface.count;
      for (var q = 0; q < surfaceCount; q++) {
        var ratio = surfaceCount === 1 ? 0.5 : q / (surfaceCount - 1);
        var level = (1 - ratio) * vMin + ratio * vMax;
        var d1 = Math.abs(level - minValues);
        var d2 = Math.abs(level - maxValues);
        var ranges = d1 > d2 ? [minValues, level] : [level, maxValues];
        drawSurface(surfacePattern, ranges[0], ranges[1]);
      }
    }
    var setupMinMax = [[Math.min(vMin, maxValues), Math.max(vMin, maxValues)], [Math.min(minValues, vMax), Math.max(minValues, vMax)]];
    ['x', 'y', 'z'].forEach(function (e) {
      var preRes = [];
      for (var s = 0; s < setupMinMax.length; s++) {
        var count = 0;
        var activeMin = setupMinMax[s][0];
        var activeMax = setupMinMax[s][1];

        // draw slices
        var slice = data.slices[e];
        if (slice.show && slice.fill) {
          setFill(slice.fill);
          var exactIndices = [];
          var ceilIndices = [];
          var distRatios = [];
          if (slice.locations.length) {
            for (var q = 0; q < slice.locations.length; q++) {
              var near = findNearestOnAxis(slice.locations[q], e === 'x' ? Xs : e === 'y' ? Ys : Zs);
              if (near.distRatio === 0) {
                exactIndices.push(near.id);
              } else if (near.id > 0) {
                ceilIndices.push(near.id);
                if (e === 'x') {
                  distRatios.push([near.distRatio, 0, 0]);
                } else if (e === 'y') {
                  distRatios.push([0, near.distRatio, 0]);
                } else {
                  distRatios.push([0, 0, near.distRatio]);
                }
              }
            }
          } else {
            if (e === 'x') {
              exactIndices = createRange(1, width - 1);
            } else if (e === 'y') {
              exactIndices = createRange(1, height - 1);
            } else {
              exactIndices = createRange(1, depth - 1);
            }
          }
          if (ceilIndices.length > 0) {
            if (e === 'x') {
              preRes[count] = drawSectionX(activeStyle, ceilIndices, activeMin, activeMax, distRatios, preRes[count]);
            } else if (e === 'y') {
              preRes[count] = drawSectionY(activeStyle, ceilIndices, activeMin, activeMax, distRatios, preRes[count]);
            } else {
              preRes[count] = drawSectionZ(activeStyle, ceilIndices, activeMin, activeMax, distRatios, preRes[count]);
            }
            count++;
          }
          if (exactIndices.length > 0) {
            if (e === 'x') {
              preRes[count] = draw2dX(activeStyle, exactIndices, activeMin, activeMax, preRes[count]);
            } else if (e === 'y') {
              preRes[count] = draw2dY(activeStyle, exactIndices, activeMin, activeMax, preRes[count]);
            } else {
              preRes[count] = draw2dZ(activeStyle, exactIndices, activeMin, activeMax, preRes[count]);
            }
            count++;
          }
        }

        // draw caps
        var cap = data.caps[e];
        if (cap.show && cap.fill) {
          setFill(cap.fill);
          if (e === 'x') {
            preRes[count] = draw2dX(activeStyle, [0, width - 1], activeMin, activeMax, preRes[count]);
          } else if (e === 'y') {
            preRes[count] = draw2dY(activeStyle, [0, height - 1], activeMin, activeMax, preRes[count]);
          } else {
            preRes[count] = draw2dZ(activeStyle, [0, depth - 1], activeMin, activeMax, preRes[count]);
          }
          count++;
        }
      }
    });

    // remove vertices arrays (i.e. grid points) in case no face was created.
    if (numFaces === 0) {
      emptyVertices();
    }
    data._meshX = allXs;
    data._meshY = allYs;
    data._meshZ = allZs;
    data._meshIntensity = allVs;
    data._Xs = Xs;
    data._Ys = Ys;
    data._Zs = Zs;
  }
  drawAll();
  return data;
}
function createIsosurfaceTrace(scene, data) {
  var gl = scene.glplot.gl;
  var mesh = createMesh({
    gl: gl
  });
  var result = new IsosurfaceTrace(scene, mesh, data.uid);
  mesh._trace = result;
  result.update(data);
  scene.glplot.add(mesh);
  return result;
}
module.exports = {
  findNearestOnAxis: findNearestOnAxis,
  generateIsoMeshes: generateIsoMeshes,
  createIsosurfaceTrace: createIsosurfaceTrace
};

/***/ }),

/***/ 2738:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Registry = __webpack_require__(3972);
var attributes = __webpack_require__(2810);
var colorscaleDefaults = __webpack_require__(1586);
function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
  function coerce(attr, dflt) {
    return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
  }
  supplyIsoDefaults(traceIn, traceOut, defaultColor, layout, coerce);
}
function supplyIsoDefaults(traceIn, traceOut, defaultColor, layout, coerce) {
  var isomin = coerce('isomin');
  var isomax = coerce('isomax');
  if (isomax !== undefined && isomax !== null && isomin !== undefined && isomin !== null && isomin > isomax) {
    // applying default values in this case:
    traceOut.isomin = null;
    traceOut.isomax = null;
  }
  var x = coerce('x');
  var y = coerce('y');
  var z = coerce('z');
  var value = coerce('value');
  if (!x || !x.length || !y || !y.length || !z || !z.length || !value || !value.length) {
    traceOut.visible = false;
    return;
  }
  var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleTraceDefaults');
  handleCalendarDefaults(traceIn, traceOut, ['x', 'y', 'z'], layout);
  coerce('valuehoverformat');
  ['x', 'y', 'z'].forEach(function (dim) {
    coerce(dim + 'hoverformat');
    var capDim = 'caps.' + dim;
    var showCap = coerce(capDim + '.show');
    if (showCap) {
      coerce(capDim + '.fill');
    }
    var sliceDim = 'slices.' + dim;
    var showSlice = coerce(sliceDim + '.show');
    if (showSlice) {
      coerce(sliceDim + '.fill');
      coerce(sliceDim + '.locations');
    }
  });
  var showSpaceframe = coerce('spaceframe.show');
  if (showSpaceframe) {
    coerce('spaceframe.fill');
  }
  var showSurface = coerce('surface.show');
  if (showSurface) {
    coerce('surface.count');
    coerce('surface.fill');
    coerce('surface.pattern');
  }
  var showContour = coerce('contour.show');
  if (showContour) {
    coerce('contour.color');
    coerce('contour.width');
  }

  // Coerce remaining properties
  ['text', 'hovertext', 'hovertemplate', 'lighting.ambient', 'lighting.diffuse', 'lighting.specular', 'lighting.roughness', 'lighting.fresnel', 'lighting.vertexnormalsepsilon', 'lighting.facenormalsepsilon', 'lightposition.x', 'lightposition.y', 'lightposition.z', 'flatshading', 'opacity'].forEach(function (x) {
    coerce(x);
  });
  colorscaleDefaults(traceIn, traceOut, layout, coerce, {
    prefix: '',
    cLetter: 'c'
  });

  // disable 1D transforms (for now)
  traceOut._length = null;
}
module.exports = {
  supplyDefaults: supplyDefaults,
  supplyIsoDefaults: supplyIsoDefaults
};

/***/ }),

/***/ 4943:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  attributes: __webpack_require__(2810),
  supplyDefaults: (__webpack_require__(2738).supplyDefaults),
  calc: __webpack_require__(6959),
  colorbar: {
    min: 'cmin',
    max: 'cmax'
  },
  plot: (__webpack_require__(2674).createIsosurfaceTrace),
  moduleType: 'trace',
  name: 'isosurface',
  basePlotModule: __webpack_require__(8547),
  categories: ['gl3d', 'showLegend'],
  meta: {}
};

/***/ }),

/***/ 2418:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var colorScaleAttrs = __webpack_require__(693);
var axisHoverFormat = (__webpack_require__(2663).axisHoverFormat);
var hovertemplateAttrs = (__webpack_require__(5386)/* .hovertemplateAttrs */ .fF);
var surfaceAttrs = __webpack_require__(2897);
var baseAttrs = __webpack_require__(9012);
var extendFlat = (__webpack_require__(1426).extendFlat);
module.exports = extendFlat({
  x: {
    valType: 'data_array',
    editType: 'calc+clearAxisTypes'
  },
  y: {
    valType: 'data_array',
    editType: 'calc+clearAxisTypes'
  },
  z: {
    valType: 'data_array',
    editType: 'calc+clearAxisTypes'
  },
  i: {
    valType: 'data_array',
    editType: 'calc'
  },
  j: {
    valType: 'data_array',
    editType: 'calc'
  },
  k: {
    valType: 'data_array',
    editType: 'calc'
  },
  text: {
    valType: 'string',
    dflt: '',
    arrayOk: true,
    editType: 'calc'
  },
  hovertext: {
    valType: 'string',
    dflt: '',
    arrayOk: true,
    editType: 'calc'
  },
  hovertemplate: hovertemplateAttrs({
    editType: 'calc'
  }),
  xhoverformat: axisHoverFormat('x'),
  yhoverformat: axisHoverFormat('y'),
  zhoverformat: axisHoverFormat('z'),
  delaunayaxis: {
    valType: 'enumerated',
    values: ['x', 'y', 'z'],
    dflt: 'z',
    editType: 'calc'
  },
  alphahull: {
    valType: 'number',
    dflt: -1,
    editType: 'calc'
  },
  intensity: {
    valType: 'data_array',
    editType: 'calc'
  },
  intensitymode: {
    valType: 'enumerated',
    values: ['vertex', 'cell'],
    dflt: 'vertex',
    editType: 'calc'
  },
  // Color field
  color: {
    valType: 'color',
    editType: 'calc'
  },
  vertexcolor: {
    valType: 'data_array',
    editType: 'calc'
  },
  facecolor: {
    valType: 'data_array',
    editType: 'calc'
  },
  transforms: undefined
}, colorScaleAttrs('', {
  colorAttr: '`intensity`',
  showScaleDflt: true,
  editTypeOverride: 'calc'
}), {
  opacity: surfaceAttrs.opacity,
  // Flat shaded mode
  flatshading: {
    valType: 'boolean',
    dflt: false,
    editType: 'calc'
  },
  contour: {
    show: extendFlat({}, surfaceAttrs.contours.x.show, {}),
    color: surfaceAttrs.contours.x.color,
    width: surfaceAttrs.contours.x.width,
    editType: 'calc'
  },
  lightposition: {
    x: extendFlat({}, surfaceAttrs.lightposition.x, {
      dflt: 1e5
    }),
    y: extendFlat({}, surfaceAttrs.lightposition.y, {
      dflt: 1e5
    }),
    z: extendFlat({}, surfaceAttrs.lightposition.z, {
      dflt: 0
    }),
    editType: 'calc'
  },
  lighting: extendFlat({
    vertexnormalsepsilon: {
      valType: 'number',
      min: 0.00,
      max: 1,
      dflt: 1e-12,
      // otherwise finely tessellated things eg. the brain will have no specular light reflection
      editType: 'calc'
    },
    facenormalsepsilon: {
      valType: 'number',
      min: 0.00,
      max: 1,
      dflt: 1e-6,
      // even the brain model doesn't appear to need finer than this
      editType: 'calc'
    },
    editType: 'calc'
  }, surfaceAttrs.lighting),
  hoverinfo: extendFlat({}, baseAttrs.hoverinfo, {
    editType: 'calc'
  }),
  showlegend: extendFlat({}, baseAttrs.showlegend, {
    dflt: false
  })
});

/***/ }),

/***/ 2932:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var colorscaleCalc = __webpack_require__(8803);
module.exports = function calc(gd, trace) {
  if (trace.intensity) {
    colorscaleCalc(gd, trace, {
      vals: trace.intensity,
      containerStr: '',
      cLetter: 'c'
    });
  }
};

/***/ }),

/***/ 1134:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var createMesh = (__webpack_require__(9330).gl_mesh3d);
var triangulate = (__webpack_require__(9330).delaunay_triangulate);
var alphaShape = (__webpack_require__(9330).alpha_shape);
var convexHull = (__webpack_require__(9330).convex_hull);
var parseColorScale = (__webpack_require__(1697).parseColorScale);
var str2RgbaArray = __webpack_require__(8614);
var extractOpts = (__webpack_require__(1081).extractOpts);
var zip3 = __webpack_require__(60);
function Mesh3DTrace(scene, mesh, uid) {
  this.scene = scene;
  this.uid = uid;
  this.mesh = mesh;
  this.name = '';
  this.color = '#fff';
  this.data = null;
  this.showContour = false;
}
var proto = Mesh3DTrace.prototype;
proto.handlePick = function (selection) {
  if (selection.object === this.mesh) {
    var selectIndex = selection.index = selection.data.index;
    if (selection.data._cellCenter) {
      selection.traceCoordinate = selection.data.dataCoordinate;
    } else {
      selection.traceCoordinate = [this.data.x[selectIndex], this.data.y[selectIndex], this.data.z[selectIndex]];
    }
    var text = this.data.hovertext || this.data.text;
    if (Array.isArray(text) && text[selectIndex] !== undefined) {
      selection.textLabel = text[selectIndex];
    } else if (text) {
      selection.textLabel = text;
    }
    return true;
  }
};
function parseColorArray(colors) {
  var b = [];
  var len = colors.length;
  for (var i = 0; i < len; i++) {
    b[i] = str2RgbaArray(colors[i]);
  }
  return b;
}

// Unpack position data
function toDataCoords(axis, coord, scale, calendar) {
  var b = [];
  var len = coord.length;
  for (var i = 0; i < len; i++) {
    b[i] = axis.d2l(coord[i], 0, calendar) * scale;
  }
  return b;
}

// Round indices if passed as floats
function toRoundIndex(a) {
  var b = [];
  var len = a.length;
  for (var i = 0; i < len; i++) {
    b[i] = Math.round(a[i]);
  }
  return b;
}
function delaunayCells(delaunayaxis, positions) {
  var d = ['x', 'y', 'z'].indexOf(delaunayaxis);
  var b = [];
  var len = positions.length;
  for (var i = 0; i < len; i++) {
    b[i] = [positions[i][(d + 1) % 3], positions[i][(d + 2) % 3]];
  }
  return triangulate(b);
}

// Validate indices
function hasValidIndices(list, numVertices) {
  var len = list.length;
  for (var i = 0; i < len; i++) {
    if (list[i] <= -0.5 || list[i] >= numVertices - 0.5) {
      // Note: the indices would be rounded -0.49 is valid.
      return false;
    }
  }
  return true;
}
proto.update = function (data) {
  var scene = this.scene;
  var layout = scene.fullSceneLayout;
  this.data = data;
  var numVertices = data.x.length;
  var positions = zip3(toDataCoords(layout.xaxis, data.x, scene.dataScale[0], data.xcalendar), toDataCoords(layout.yaxis, data.y, scene.dataScale[1], data.ycalendar), toDataCoords(layout.zaxis, data.z, scene.dataScale[2], data.zcalendar));
  var cells;
  if (data.i && data.j && data.k) {
    if (data.i.length !== data.j.length || data.j.length !== data.k.length || !hasValidIndices(data.i, numVertices) || !hasValidIndices(data.j, numVertices) || !hasValidIndices(data.k, numVertices)) {
      return;
    }
    cells = zip3(toRoundIndex(data.i), toRoundIndex(data.j), toRoundIndex(data.k));
  } else if (data.alphahull === 0) {
    cells = convexHull(positions);
  } else if (data.alphahull > 0) {
    cells = alphaShape(data.alphahull, positions);
  } else {
    cells = delaunayCells(data.delaunayaxis, positions);
  }
  var config = {
    positions: positions,
    cells: cells,
    lightPosition: [data.lightposition.x, data.lightposition.y, data.lightposition.z],
    ambient: data.lighting.ambient,
    diffuse: data.lighting.diffuse,
    specular: data.lighting.specular,
    roughness: data.lighting.roughness,
    fresnel: data.lighting.fresnel,
    vertexNormalsEpsilon: data.lighting.vertexnormalsepsilon,
    faceNormalsEpsilon: data.lighting.facenormalsepsilon,
    opacity: data.opacity,
    contourEnable: data.contour.show,
    contourColor: str2RgbaArray(data.contour.color).slice(0, 3),
    contourWidth: data.contour.width,
    useFacetNormals: data.flatshading
  };
  if (data.intensity) {
    var cOpts = extractOpts(data);
    this.color = '#fff';
    var mode = data.intensitymode;
    config[mode + 'Intensity'] = data.intensity;
    config[mode + 'IntensityBounds'] = [cOpts.min, cOpts.max];
    config.colormap = parseColorScale(data);
  } else if (data.vertexcolor) {
    this.color = data.vertexcolor[0];
    config.vertexColors = parseColorArray(data.vertexcolor);
  } else if (data.facecolor) {
    this.color = data.facecolor[0];
    config.cellColors = parseColorArray(data.facecolor);
  } else {
    this.color = data.color;
    config.meshColor = str2RgbaArray(data.color);
  }

  // Update mesh
  this.mesh.update(config);
};
proto.dispose = function () {
  this.scene.glplot.remove(this.mesh);
  this.mesh.dispose();
};
function createMesh3DTrace(scene, data) {
  var gl = scene.glplot.gl;
  var mesh = createMesh({
    gl: gl
  });
  var result = new Mesh3DTrace(scene, mesh, data.uid);
  mesh._trace = result;
  result.update(data);
  scene.glplot.add(mesh);
  return result;
}
module.exports = createMesh3DTrace;

/***/ }),

/***/ 8669:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var colorscaleDefaults = __webpack_require__(1586);
var attributes = __webpack_require__(2418);
module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
  function coerce(attr, dflt) {
    return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
  }

  // read in face/vertex properties
  function readComponents(array) {
    var ret = array.map(function (attr) {
      var result = coerce(attr);
      if (result && Lib.isArrayOrTypedArray(result)) return result;
      return null;
    });
    return ret.every(function (x) {
      return x && x.length === ret[0].length;
    }) && ret;
  }
  var coords = readComponents(['x', 'y', 'z']);
  if (!coords) {
    traceOut.visible = false;
    return;
  }
  readComponents(['i', 'j', 'k']);
  // three indices should be all provided or not
  if (traceOut.i && (!traceOut.j || !traceOut.k) || traceOut.j && (!traceOut.k || !traceOut.i) || traceOut.k && (!traceOut.i || !traceOut.j)) {
    traceOut.visible = false;
    return;
  }
  var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleTraceDefaults');
  handleCalendarDefaults(traceIn, traceOut, ['x', 'y', 'z'], layout);

  // Coerce remaining properties
  ['lighting.ambient', 'lighting.diffuse', 'lighting.specular', 'lighting.roughness', 'lighting.fresnel', 'lighting.vertexnormalsepsilon', 'lighting.facenormalsepsilon', 'lightposition.x', 'lightposition.y', 'lightposition.z', 'flatshading', 'alphahull', 'delaunayaxis', 'opacity'].forEach(function (x) {
    coerce(x);
  });
  var showContour = coerce('contour.show');
  if (showContour) {
    coerce('contour.color');
    coerce('contour.width');
  }
  if ('intensity' in traceIn) {
    coerce('intensity');
    coerce('intensitymode');
    colorscaleDefaults(traceIn, traceOut, layout, coerce, {
      prefix: '',
      cLetter: 'c'
    });
  } else {
    traceOut.showscale = false;
    if ('facecolor' in traceIn) coerce('facecolor');else if ('vertexcolor' in traceIn) coerce('vertexcolor');else coerce('color', defaultColor);
  }
  coerce('text');
  coerce('hovertext');
  coerce('hovertemplate');
  coerce('xhoverformat');
  coerce('yhoverformat');
  coerce('zhoverformat');

  // disable 1D transforms
  // x/y/z should match lengths, and i/j/k should match as well, but
  // the two sets have different lengths so transforms wouldn't work.
  traceOut._length = null;
};

/***/ }),

/***/ 1164:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  attributes: __webpack_require__(2418),
  supplyDefaults: __webpack_require__(8669),
  calc: __webpack_require__(2932),
  colorbar: {
    min: 'cmin',
    max: 'cmax'
  },
  plot: __webpack_require__(1134),
  moduleType: 'trace',
  name: 'mesh3d',
  basePlotModule: __webpack_require__(8547),
  categories: ['gl3d', 'showLegend'],
  meta: {}
};

/***/ }),

/***/ 2209:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Drawing = __webpack_require__(1424);
var Color = __webpack_require__(7901);
module.exports = function fillOne(s, pt, trace, gd) {
  var pattern = trace.marker.pattern;
  if (pattern && pattern.shape) {
    Drawing.pointStyle(s, trace, gd, pt);
  } else {
    Color.fill(s, pt.color);
  }
};

/***/ }),

/***/ 3581:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
function format(vRounded) {
  return vRounded.indexOf('e') !== -1 ? vRounded.replace(/[.]?0+e/, 'e') : vRounded.indexOf('.') !== -1 ? vRounded.replace(/[.]?0+$/, '') : vRounded;
}
exports.formatPiePercent = function formatPiePercent(v, separators) {
  var vRounded = format((v * 100).toPrecision(3));
  return Lib.numSeparate(vRounded, separators) + '%';
};
exports.formatPieValue = function formatPieValue(v, separators) {
  var vRounded = format(v.toPrecision(10));
  return Lib.numSeparate(vRounded, separators);
};
exports.getFirstFilled = function getFirstFilled(array, indices) {
  if (!Array.isArray(array)) return;
  for (var i = 0; i < indices.length; i++) {
    var v = array[indices[i]];
    if (v || v === 0 || v === '') return v;
  }
};
exports.castOption = function castOption(item, indices) {
  if (Array.isArray(item)) return exports.getFirstFilled(item, indices);else if (item) return item;
};
exports.getRotationAngle = function (rotation) {
  return (rotation === 'auto' ? 0 : rotation) * Math.PI / 180;
};

/***/ }),

/***/ 3463:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Color = __webpack_require__(7901);
var castOption = (__webpack_require__(3581).castOption);
var fillOne = __webpack_require__(2209);
module.exports = function styleOne(s, pt, trace, gd) {
  var line = trace.marker.line;
  var lineColor = castOption(line.color, pt.pts) || Color.defaultLine;
  var lineWidth = castOption(line.width, pt.pts) || 0;
  s.call(fillOne, pt, trace, gd).style('stroke-width', lineWidth).call(Color.stroke, lineColor);
};

/***/ }),

/***/ 5225:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);

// arrayOk attributes, merge them into calcdata array
module.exports = function arraysToCalcdata(cd, trace) {
  // so each point knows which index it originally came from
  for (var i = 0; i < cd.length; i++) cd[i].i = i;
  Lib.mergeArray(trace.text, cd, 'tx');
  Lib.mergeArray(trace.texttemplate, cd, 'txt');
  Lib.mergeArray(trace.hovertext, cd, 'htx');
  Lib.mergeArray(trace.customdata, cd, 'data');
  Lib.mergeArray(trace.textposition, cd, 'tp');
  if (trace.textfont) {
    Lib.mergeArrayCastPositive(trace.textfont.size, cd, 'ts');
    Lib.mergeArray(trace.textfont.color, cd, 'tc');
    Lib.mergeArray(trace.textfont.family, cd, 'tf');
  }
  var marker = trace.marker;
  if (marker) {
    Lib.mergeArrayCastPositive(marker.size, cd, 'ms');
    Lib.mergeArrayCastPositive(marker.opacity, cd, 'mo');
    Lib.mergeArray(marker.symbol, cd, 'mx');
    Lib.mergeArray(marker.angle, cd, 'ma');
    Lib.mergeArray(marker.standoff, cd, 'mf');
    Lib.mergeArray(marker.color, cd, 'mc');
    var markerLine = marker.line;
    if (marker.line) {
      Lib.mergeArray(markerLine.color, cd, 'mlc');
      Lib.mergeArrayCastPositive(markerLine.width, cd, 'mlw');
    }
    var markerGradient = marker.gradient;
    if (markerGradient && markerGradient.type !== 'none') {
      Lib.mergeArray(markerGradient.type, cd, 'mgt');
      Lib.mergeArray(markerGradient.color, cd, 'mgc');
    }
  }
};

/***/ }),

/***/ 2196:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var axisHoverFormat = (__webpack_require__(2663).axisHoverFormat);
var texttemplateAttrs = (__webpack_require__(5386)/* .texttemplateAttrs */ .si);
var hovertemplateAttrs = (__webpack_require__(5386)/* .hovertemplateAttrs */ .fF);
var colorScaleAttrs = __webpack_require__(693);
var fontAttrs = __webpack_require__(1940);
var dash = (__webpack_require__(9952)/* .dash */ .P);
var pattern = (__webpack_require__(9952)/* .pattern */ .u);
var Drawing = __webpack_require__(1424);
var constants = __webpack_require__(7581);
var extendFlat = (__webpack_require__(1426).extendFlat);
function axisPeriod(axis) {
  return {
    valType: 'any',
    dflt: 0,
    editType: 'calc'
  };
}
function axisPeriod0(axis) {
  return {
    valType: 'any',
    editType: 'calc'
  };
}
function axisPeriodAlignment(axis) {
  return {
    valType: 'enumerated',
    values: ['start', 'middle', 'end'],
    dflt: 'middle',
    editType: 'calc'
  };
}
module.exports = {
  x: {
    valType: 'data_array',
    editType: 'calc+clearAxisTypes',
    anim: true
  },
  x0: {
    valType: 'any',
    dflt: 0,
    editType: 'calc+clearAxisTypes',
    anim: true
  },
  dx: {
    valType: 'number',
    dflt: 1,
    editType: 'calc',
    anim: true
  },
  y: {
    valType: 'data_array',
    editType: 'calc+clearAxisTypes',
    anim: true
  },
  y0: {
    valType: 'any',
    dflt: 0,
    editType: 'calc+clearAxisTypes',
    anim: true
  },
  dy: {
    valType: 'number',
    dflt: 1,
    editType: 'calc',
    anim: true
  },
  xperiod: axisPeriod('x'),
  yperiod: axisPeriod('y'),
  xperiod0: axisPeriod0('x0'),
  yperiod0: axisPeriod0('y0'),
  xperiodalignment: axisPeriodAlignment('x'),
  yperiodalignment: axisPeriodAlignment('y'),
  xhoverformat: axisHoverFormat('x'),
  yhoverformat: axisHoverFormat('y'),
  offsetgroup: {
    valType: 'string',
    dflt: '',
    editType: 'calc'
  },
  alignmentgroup: {
    valType: 'string',
    dflt: '',
    editType: 'calc'
  },
  stackgroup: {
    valType: 'string',
    dflt: '',
    editType: 'calc'
  },
  orientation: {
    valType: 'enumerated',
    values: ['v', 'h'],
    editType: 'calc'
  },
  groupnorm: {
    valType: 'enumerated',
    values: ['', 'fraction', 'percent'],
    dflt: '',
    editType: 'calc'
  },
  stackgaps: {
    valType: 'enumerated',
    values: ['infer zero', 'interpolate'],
    dflt: 'infer zero',
    editType: 'calc'
  },
  text: {
    valType: 'string',
    dflt: '',
    arrayOk: true,
    editType: 'calc'
  },
  texttemplate: texttemplateAttrs({}, {}),
  hovertext: {
    valType: 'string',
    dflt: '',
    arrayOk: true,
    editType: 'style'
  },
  mode: {
    valType: 'flaglist',
    flags: ['lines', 'markers', 'text'],
    extras: ['none'],
    editType: 'calc'
  },
  hoveron: {
    valType: 'flaglist',
    flags: ['points', 'fills'],
    editType: 'style'
  },
  hovertemplate: hovertemplateAttrs({}, {
    keys: constants.eventDataKeys
  }),
  line: {
    color: {
      valType: 'color',
      editType: 'style',
      anim: true
    },
    width: {
      valType: 'number',
      min: 0,
      dflt: 2,
      editType: 'style',
      anim: true
    },
    shape: {
      valType: 'enumerated',
      values: ['linear', 'spline', 'hv', 'vh', 'hvh', 'vhv'],
      dflt: 'linear',
      editType: 'plot'
    },
    smoothing: {
      valType: 'number',
      min: 0,
      max: 1.3,
      dflt: 1,
      editType: 'plot'
    },
    dash: extendFlat({}, dash, {
      editType: 'style'
    }),
    backoff: {
      // we want to have a similar option for the start of the line
      valType: 'number',
      min: 0,
      dflt: 'auto',
      arrayOk: true,
      editType: 'plot'
    },
    simplify: {
      valType: 'boolean',
      dflt: true,
      editType: 'plot'
    },
    editType: 'plot'
  },
  connectgaps: {
    valType: 'boolean',
    dflt: false,
    editType: 'calc'
  },
  cliponaxis: {
    valType: 'boolean',
    dflt: true,
    editType: 'plot'
  },
  fill: {
    valType: 'enumerated',
    values: ['none', 'tozeroy', 'tozerox', 'tonexty', 'tonextx', 'toself', 'tonext'],
    editType: 'calc'
  },
  fillcolor: {
    valType: 'color',
    editType: 'style',
    anim: true
  },
  fillpattern: pattern,
  marker: extendFlat({
    symbol: {
      valType: 'enumerated',
      values: Drawing.symbolList,
      dflt: 'circle',
      arrayOk: true,
      editType: 'style'
    },
    opacity: {
      valType: 'number',
      min: 0,
      max: 1,
      arrayOk: true,
      editType: 'style',
      anim: true
    },
    angle: {
      valType: 'angle',
      dflt: 0,
      arrayOk: true,
      editType: 'plot',
      anim: false // TODO: possibly set to true in future
    },

    angleref: {
      valType: 'enumerated',
      values: ['previous', 'up'],
      dflt: 'up',
      editType: 'plot',
      anim: false
    },
    standoff: {
      valType: 'number',
      min: 0,
      dflt: 0,
      arrayOk: true,
      editType: 'plot',
      anim: true
    },
    size: {
      valType: 'number',
      min: 0,
      dflt: 6,
      arrayOk: true,
      editType: 'calc',
      anim: true
    },
    maxdisplayed: {
      valType: 'number',
      min: 0,
      dflt: 0,
      editType: 'plot'
    },
    sizeref: {
      valType: 'number',
      dflt: 1,
      editType: 'calc'
    },
    sizemin: {
      valType: 'number',
      min: 0,
      dflt: 0,
      editType: 'calc'
    },
    sizemode: {
      valType: 'enumerated',
      values: ['diameter', 'area'],
      dflt: 'diameter',
      editType: 'calc'
    },
    line: extendFlat({
      width: {
        valType: 'number',
        min: 0,
        arrayOk: true,
        editType: 'style',
        anim: true
      },
      editType: 'calc'
    }, colorScaleAttrs('marker.line', {
      anim: true
    })),
    gradient: {
      type: {
        valType: 'enumerated',
        values: ['radial', 'horizontal', 'vertical', 'none'],
        arrayOk: true,
        dflt: 'none',
        editType: 'calc'
      },
      color: {
        valType: 'color',
        arrayOk: true,
        editType: 'calc'
      },
      editType: 'calc'
    },
    editType: 'calc'
  }, colorScaleAttrs('marker', {
    anim: true
  })),
  selected: {
    marker: {
      opacity: {
        valType: 'number',
        min: 0,
        max: 1,
        editType: 'style'
      },
      color: {
        valType: 'color',
        editType: 'style'
      },
      size: {
        valType: 'number',
        min: 0,
        editType: 'style'
      },
      editType: 'style'
    },
    textfont: {
      color: {
        valType: 'color',
        editType: 'style'
      },
      editType: 'style'
    },
    editType: 'style'
  },
  unselected: {
    marker: {
      opacity: {
        valType: 'number',
        min: 0,
        max: 1,
        editType: 'style'
      },
      color: {
        valType: 'color',
        editType: 'style'
      },
      size: {
        valType: 'number',
        min: 0,
        editType: 'style'
      },
      editType: 'style'
    },
    textfont: {
      color: {
        valType: 'color',
        editType: 'style'
      },
      editType: 'style'
    },
    editType: 'style'
  },
  textposition: {
    valType: 'enumerated',
    values: ['top left', 'top center', 'top right', 'middle left', 'middle center', 'middle right', 'bottom left', 'bottom center', 'bottom right'],
    dflt: 'middle center',
    arrayOk: true,
    editType: 'calc'
  },
  textfont: fontAttrs({
    editType: 'calc',
    colorEditType: 'style',
    arrayOk: true
  })
};

/***/ }),

/***/ 7761:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);
var Lib = __webpack_require__(1828);
var Axes = __webpack_require__(9298);
var alignPeriod = __webpack_require__(2973);
var BADNUM = (__webpack_require__(606).BADNUM);
var subTypes = __webpack_require__(4098);
var calcColorscale = __webpack_require__(6922);
var arraysToCalcdata = __webpack_require__(5225);
var calcSelection = __webpack_require__(6279);
function calc(gd, trace) {
  var fullLayout = gd._fullLayout;
  var xa = trace._xA = Axes.getFromId(gd, trace.xaxis || 'x', 'x');
  var ya = trace._yA = Axes.getFromId(gd, trace.yaxis || 'y', 'y');
  var origX = xa.makeCalcdata(trace, 'x');
  var origY = ya.makeCalcdata(trace, 'y');
  var xObj = alignPeriod(trace, xa, 'x', origX);
  var yObj = alignPeriod(trace, ya, 'y', origY);
  var x = xObj.vals;
  var y = yObj.vals;
  var serieslen = trace._length;
  var cd = new Array(serieslen);
  var ids = trace.ids;
  var stackGroupOpts = getStackOpts(trace, fullLayout, xa, ya);
  var interpolateGaps = false;
  var isV, i, j, k, interpolate, vali;
  setFirstScatter(fullLayout, trace);
  var xAttr = 'x';
  var yAttr = 'y';
  var posAttr;
  if (stackGroupOpts) {
    Lib.pushUnique(stackGroupOpts.traceIndices, trace._expandedIndex);
    isV = stackGroupOpts.orientation === 'v';

    // size, like we use for bar
    if (isV) {
      yAttr = 's';
      posAttr = 'x';
    } else {
      xAttr = 's';
      posAttr = 'y';
    }
    interpolate = stackGroupOpts.stackgaps === 'interpolate';
  } else {
    var ppad = calcMarkerSize(trace, serieslen);
    calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);
  }
  var hasPeriodX = !!trace.xperiodalignment;
  var hasPeriodY = !!trace.yperiodalignment;
  for (i = 0; i < serieslen; i++) {
    var cdi = cd[i] = {};
    var xValid = isNumeric(x[i]);
    var yValid = isNumeric(y[i]);
    if (xValid && yValid) {
      cdi[xAttr] = x[i];
      cdi[yAttr] = y[i];
      if (hasPeriodX) {
        cdi.orig_x = origX[i]; // used by hover
        cdi.xEnd = xObj.ends[i];
        cdi.xStart = xObj.starts[i];
      }
      if (hasPeriodY) {
        cdi.orig_y = origY[i]; // used by hover
        cdi.yEnd = yObj.ends[i];
        cdi.yStart = yObj.starts[i];
      }
    } else if (stackGroupOpts && (isV ? xValid : yValid)) {
      // if we're stacking we need to hold on to all valid positions
      // even with invalid sizes

      cdi[posAttr] = isV ? x[i] : y[i];
      cdi.gap = true;
      if (interpolate) {
        cdi.s = BADNUM;
        interpolateGaps = true;
      } else {
        cdi.s = 0;
      }
    } else {
      cdi[xAttr] = cdi[yAttr] = BADNUM;
    }
    if (ids) {
      cdi.id = String(ids[i]);
    }
  }
  arraysToCalcdata(cd, trace);
  calcColorscale(gd, trace);
  calcSelection(cd, trace);
  if (stackGroupOpts) {
    // remove bad positions and sort
    // note that original indices get added to cd in arraysToCalcdata
    i = 0;
    while (i < cd.length) {
      if (cd[i][posAttr] === BADNUM) {
        cd.splice(i, 1);
      } else i++;
    }
    Lib.sort(cd, function (a, b) {
      return a[posAttr] - b[posAttr] || a.i - b.i;
    });
    if (interpolateGaps) {
      // first fill the beginning with constant from the first point
      i = 0;
      while (i < cd.length - 1 && cd[i].gap) {
        i++;
      }
      vali = cd[i].s;
      if (!vali) vali = cd[i].s = 0; // in case of no data AT ALL in this trace - use 0
      for (j = 0; j < i; j++) {
        cd[j].s = vali;
      }
      // then fill the end with constant from the last point
      k = cd.length - 1;
      while (k > i && cd[k].gap) {
        k--;
      }
      vali = cd[k].s;
      for (j = cd.length - 1; j > k; j--) {
        cd[j].s = vali;
      }
      // now interpolate internal gaps linearly
      while (i < k) {
        i++;
        if (cd[i].gap) {
          j = i + 1;
          while (cd[j].gap) {
            j++;
          }
          var pos0 = cd[i - 1][posAttr];
          var size0 = cd[i - 1].s;
          var m = (cd[j].s - size0) / (cd[j][posAttr] - pos0);
          while (i < j) {
            cd[i].s = size0 + (cd[i][posAttr] - pos0) * m;
            i++;
          }
        }
      }
    }
  }
  return cd;
}
function calcAxisExpansion(gd, trace, xa, ya, x, y, ppad) {
  var serieslen = trace._length;
  var fullLayout = gd._fullLayout;
  var xId = xa._id;
  var yId = ya._id;
  var firstScatter = fullLayout._firstScatter[firstScatterGroup(trace)] === trace.uid;
  var stackOrientation = (getStackOpts(trace, fullLayout, xa, ya) || {}).orientation;
  var fill = trace.fill;

  // cancel minimum tick spacings (only applies to bars and boxes)
  xa._minDtick = 0;
  ya._minDtick = 0;

  // check whether bounds should be tight, padded, extended to zero...
  // most cases both should be padded on both ends, so start with that.
  var xOptions = {
    padded: true
  };
  var yOptions = {
    padded: true
  };
  if (ppad) {
    xOptions.ppad = yOptions.ppad = ppad;
  }

  // TODO: text size

  var openEnded = serieslen < 2 || x[0] !== x[serieslen - 1] || y[0] !== y[serieslen - 1];
  if (openEnded && (fill === 'tozerox' || fill === 'tonextx' && (firstScatter || stackOrientation === 'h'))) {
    // include zero (tight) and extremes (padded) if fill to zero
    // (unless the shape is closed, then it's just filling the shape regardless)

    xOptions.tozero = true;
  } else if (!(trace.error_y || {}).visible && (
  // if no error bars, markers or text, or fill to y=0 remove x padding

  fill === 'tonexty' || fill === 'tozeroy' || !subTypes.hasMarkers(trace) && !subTypes.hasText(trace))) {
    xOptions.padded = false;
    xOptions.ppad = 0;
  }
  if (openEnded && (fill === 'tozeroy' || fill === 'tonexty' && (firstScatter || stackOrientation === 'v'))) {
    // now check for y - rather different logic, though still mostly padded both ends
    // include zero (tight) and extremes (padded) if fill to zero
    // (unless the shape is closed, then it's just filling the shape regardless)

    yOptions.tozero = true;
  } else if (fill === 'tonextx' || fill === 'tozerox') {
    // tight y: any x fill

    yOptions.padded = false;
  }

  // N.B. asymmetric splom traces call this with blank {} xa or ya
  if (xId) trace._extremes[xId] = Axes.findExtremes(xa, x, xOptions);
  if (yId) trace._extremes[yId] = Axes.findExtremes(ya, y, yOptions);
}
function calcMarkerSize(trace, serieslen) {
  if (!subTypes.hasMarkers(trace)) return;

  // Treat size like x or y arrays --- Run d2c
  // this needs to go before ppad computation
  var marker = trace.marker;
  var sizeref = 1.6 * (trace.marker.sizeref || 1);
  var markerTrans;
  if (trace.marker.sizemode === 'area') {
    markerTrans = function (v) {
      return Math.max(Math.sqrt((v || 0) / sizeref), 3);
    };
  } else {
    markerTrans = function (v) {
      return Math.max((v || 0) / sizeref, 3);
    };
  }
  if (Lib.isArrayOrTypedArray(marker.size)) {
    // I tried auto-type but category and dates dont make much sense.
    var ax = {
      type: 'linear'
    };
    Axes.setConvert(ax);
    var s = ax.makeCalcdata(trace.marker, 'size');
    var sizeOut = new Array(serieslen);
    for (var i = 0; i < serieslen; i++) {
      sizeOut[i] = markerTrans(s[i]);
    }
    return sizeOut;
  } else {
    return markerTrans(marker.size);
  }
}

/**
 * mark the first scatter trace for each subplot
 * note that scatter and scattergl each get their own first trace
 * note also that I'm doing this during calc rather than supplyDefaults
 * so I don't need to worry about transforms, but if we ever do
 * per-trace calc this will get confused.
 */
function setFirstScatter(fullLayout, trace) {
  var group = firstScatterGroup(trace);
  var firstScatter = fullLayout._firstScatter;
  if (!firstScatter[group]) firstScatter[group] = trace.uid;
}
function firstScatterGroup(trace) {
  var stackGroup = trace.stackgroup;
  return trace.xaxis + trace.yaxis + trace.type + (stackGroup ? '-' + stackGroup : '');
}
function getStackOpts(trace, fullLayout, xa, ya) {
  var stackGroup = trace.stackgroup;
  if (!stackGroup) return;
  var stackOpts = fullLayout._scatterStackOpts[xa._id + ya._id][stackGroup];
  var stackAx = stackOpts.orientation === 'v' ? ya : xa;
  // Allow stacking only on numeric axes
  // calc is a little late to be figuring this out, but during supplyDefaults
  // we don't know the axis type yet
  if (stackAx.type === 'linear' || stackAx.type === 'log') return stackOpts;
}
module.exports = {
  calc: calc,
  calcMarkerSize: calcMarkerSize,
  calcAxisExpansion: calcAxisExpansion,
  setFirstScatter: setFirstScatter,
  getStackOpts: getStackOpts
};

/***/ }),

/***/ 6279:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
module.exports = function calcSelection(cd, trace) {
  if (Lib.isArrayOrTypedArray(trace.selectedpoints)) {
    Lib.tagSelected(cd, trace);
  }
};

/***/ }),

/***/ 6922:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var hasColorscale = (__webpack_require__(2869).hasColorscale);
var calcColorscale = __webpack_require__(8803);
var subTypes = __webpack_require__(4098);
module.exports = function calcMarkerColorscale(gd, trace) {
  if (subTypes.hasLines(trace) && hasColorscale(trace, 'line')) {
    calcColorscale(gd, trace, {
      vals: trace.line.color,
      containerStr: 'line',
      cLetter: 'c'
    });
  }
  if (subTypes.hasMarkers(trace)) {
    if (hasColorscale(trace, 'marker')) {
      calcColorscale(gd, trace, {
        vals: trace.marker.color,
        containerStr: 'marker',
        cLetter: 'c'
      });
    }
    if (hasColorscale(trace, 'marker.line')) {
      calcColorscale(gd, trace, {
        vals: trace.marker.line.color,
        containerStr: 'marker.line',
        cLetter: 'c'
      });
    }
  }
};

/***/ }),

/***/ 7581:
/***/ (function(module) {

"use strict";


module.exports = {
  PTS_LINESONLY: 20,
  // fixed parameters of clustering and clipping algorithms

  // fraction of clustering tolerance "so close we don't even consider it a new point"
  minTolerance: 0.2,
  // how fast does clustering tolerance increase as you get away from the visible region
  toleranceGrowth: 10,
  // number of viewport sizes away from the visible region
  // at which we clip all lines to the perimeter
  maxScreensAway: 20,
  eventDataKeys: []
};

/***/ }),

/***/ 2626:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var calc = __webpack_require__(7761);
var setGroupPositions = (__webpack_require__(1661).setGroupPositions);
function groupCrossTraceCalc(gd, plotinfo) {
  var xa = plotinfo.xaxis;
  var ya = plotinfo.yaxis;
  var fullLayout = gd._fullLayout;
  var fullTraces = gd._fullData;
  var calcTraces = gd.calcdata;
  var calcTracesHorz = [];
  var calcTracesVert = [];
  for (var i = 0; i < fullTraces.length; i++) {
    var fullTrace = fullTraces[i];
    if (fullTrace.visible === true && fullTrace.type === 'scatter' && fullTrace.xaxis === xa._id && fullTrace.yaxis === ya._id) {
      if (fullTrace.orientation === 'h') {
        calcTracesHorz.push(calcTraces[i]);
      } else if (fullTrace.orientation === 'v') {
        // check for v since certain scatter traces may not have an orientation
        calcTracesVert.push(calcTraces[i]);
      }
    }
  }
  var opts = {
    mode: fullLayout.scattermode,
    gap: fullLayout.scattergap
  };
  setGroupPositions(gd, xa, ya, calcTracesVert, opts);
  setGroupPositions(gd, ya, xa, calcTracesHorz, opts);
}

/*
 * Scatter stacking & normalization calculations
 * runs per subplot, and can handle multiple stacking groups
 */

module.exports = function crossTraceCalc(gd, plotinfo) {
  if (gd._fullLayout.scattermode === 'group') {
    groupCrossTraceCalc(gd, plotinfo);
  }
  var xa = plotinfo.xaxis;
  var ya = plotinfo.yaxis;
  var subplot = xa._id + ya._id;
  var subplotStackOpts = gd._fullLayout._scatterStackOpts[subplot];
  if (!subplotStackOpts) return;
  var calcTraces = gd.calcdata;
  var i, j, k, i2, cd, cd0, posj, sumj, norm;
  var groupOpts, interpolate, groupnorm, posAttr, valAttr;
  var hasAnyBlanks;
  for (var stackGroup in subplotStackOpts) {
    groupOpts = subplotStackOpts[stackGroup];
    var indices = groupOpts.traceIndices;

    // can get here with no indices if the stack axis is non-numeric
    if (!indices.length) continue;
    interpolate = groupOpts.stackgaps === 'interpolate';
    groupnorm = groupOpts.groupnorm;
    if (groupOpts.orientation === 'v') {
      posAttr = 'x';
      valAttr = 'y';
    } else {
      posAttr = 'y';
      valAttr = 'x';
    }
    hasAnyBlanks = new Array(indices.length);
    for (i = 0; i < hasAnyBlanks.length; i++) {
      hasAnyBlanks[i] = false;
    }

    // Collect the complete set of all positions across ALL traces.
    // Start with the first trace, then interleave items from later traces
    // as needed.
    // Fill in mising items as we go.
    cd0 = calcTraces[indices[0]];
    var allPositions = new Array(cd0.length);
    for (i = 0; i < cd0.length; i++) {
      allPositions[i] = cd0[i][posAttr];
    }
    for (i = 1; i < indices.length; i++) {
      cd = calcTraces[indices[i]];
      for (j = k = 0; j < cd.length; j++) {
        posj = cd[j][posAttr];
        for (; posj > allPositions[k] && k < allPositions.length; k++) {
          // the current trace is missing a position from some previous trace(s)
          insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);
          j++;
        }
        if (posj !== allPositions[k]) {
          // previous trace(s) are missing a position from the current trace
          for (i2 = 0; i2 < i; i2++) {
            insertBlank(calcTraces[indices[i2]], k, posj, i2, hasAnyBlanks, interpolate, posAttr);
          }
          allPositions.splice(k, 0, posj);
        }
        k++;
      }
      for (; k < allPositions.length; k++) {
        insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);
        j++;
      }
    }
    var serieslen = allPositions.length;

    // stack (and normalize)!
    for (j = 0; j < cd0.length; j++) {
      sumj = cd0[j][valAttr] = cd0[j].s;
      for (i = 1; i < indices.length; i++) {
        cd = calcTraces[indices[i]];
        cd[0].trace._rawLength = cd[0].trace._length;
        cd[0].trace._length = serieslen;
        sumj += cd[j].s;
        cd[j][valAttr] = sumj;
      }
      if (groupnorm) {
        norm = (groupnorm === 'fraction' ? sumj : sumj / 100) || 1;
        for (i = 0; i < indices.length; i++) {
          var cdj = calcTraces[indices[i]][j];
          cdj[valAttr] /= norm;
          cdj.sNorm = cdj.s / norm;
        }
      }
    }

    // autorange
    for (i = 0; i < indices.length; i++) {
      cd = calcTraces[indices[i]];
      var trace = cd[0].trace;
      var ppad = calc.calcMarkerSize(trace, trace._rawLength);
      var arrayPad = Array.isArray(ppad);
      if (ppad && hasAnyBlanks[i] || arrayPad) {
        var ppadRaw = ppad;
        ppad = new Array(serieslen);
        for (j = 0; j < serieslen; j++) {
          ppad[j] = cd[j].gap ? 0 : arrayPad ? ppadRaw[cd[j].i] : ppadRaw;
        }
      }
      var x = new Array(serieslen);
      var y = new Array(serieslen);
      for (j = 0; j < serieslen; j++) {
        x[j] = cd[j].x;
        y[j] = cd[j].y;
      }
      calc.calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);

      // while we're here (in a loop over all traces in the stack)
      // record the orientation, so hover can find it easily
      cd[0].t.orientation = groupOpts.orientation;
    }
  }
};
function insertBlank(calcTrace, index, position, traceIndex, hasAnyBlanks, interpolate, posAttr) {
  hasAnyBlanks[traceIndex] = true;
  var newEntry = {
    i: null,
    gap: true,
    s: 0
  };
  newEntry[posAttr] = position;
  calcTrace.splice(index, 0, newEntry);
  // Even if we're not interpolating, if one trace has multiple
  // values at the same position and this trace only has one value there,
  // we just duplicate that one value rather than insert a zero.
  // We also make it look like a real point - because it's ambiguous which
  // one really is the real one!
  if (index && position === calcTrace[index - 1][posAttr]) {
    var prevEntry = calcTrace[index - 1];
    newEntry.s = prevEntry.s;
    // TODO is it going to cause any problems to have multiple
    // calcdata points with the same index?
    newEntry.i = prevEntry.i;
    newEntry.gap = prevEntry.gap;
  } else if (interpolate) {
    newEntry.s = getInterp(calcTrace, index, position, posAttr);
  }
  if (!index) {
    // t and trace need to stay on the first cd entry
    calcTrace[0].t = calcTrace[1].t;
    calcTrace[0].trace = calcTrace[1].trace;
    delete calcTrace[1].t;
    delete calcTrace[1].trace;
  }
}
function getInterp(calcTrace, index, position, posAttr) {
  var pt0 = calcTrace[index - 1];
  var pt1 = calcTrace[index + 1];
  if (!pt1) return pt0.s;
  if (!pt0) return pt1.s;
  return pt0.s + (pt1.s - pt0.s) * (position - pt0[posAttr]) / (pt1[posAttr] - pt0[posAttr]);
}

/***/ }),

/***/ 462:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var handleGroupingDefaults = __webpack_require__(6125);
var attributes = __webpack_require__(2196);

// remove opacity for any trace that has a fill or is filled to
module.exports = function crossTraceDefaults(fullData, fullLayout) {
  var traceIn, traceOut, i;
  function coerce(attr) {
    return Lib.coerce(traceOut._input, traceOut, attributes, attr);
  }
  if (fullLayout.scattermode === 'group') {
    for (i = 0; i < fullData.length; i++) {
      traceOut = fullData[i];
      if (traceOut.type === 'scatter') {
        traceIn = traceOut._input;
        handleGroupingDefaults(traceIn, traceOut, fullLayout, coerce);
      }
    }
  }
  for (i = 0; i < fullData.length; i++) {
    var tracei = fullData[i];
    if (tracei.type !== 'scatter') continue;
    var filli = tracei.fill;
    if (filli === 'none' || filli === 'toself') continue;
    tracei.opacity = undefined;
    if (filli === 'tonexty' || filli === 'tonextx') {
      for (var j = i - 1; j >= 0; j--) {
        var tracej = fullData[j];
        if (tracej.type === 'scatter' && tracej.xaxis === tracei.xaxis && tracej.yaxis === tracei.yaxis) {
          tracej.opacity = undefined;
          break;
        }
      }
    }
  }
};

/***/ }),

/***/ 7438:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Registry = __webpack_require__(3972);
var attributes = __webpack_require__(2196);
var constants = __webpack_require__(7581);
var subTypes = __webpack_require__(4098);
var handleXYDefaults = __webpack_require__(7513);
var handlePeriodDefaults = __webpack_require__(3927);
var handleStackDefaults = __webpack_require__(565);
var handleMarkerDefaults = __webpack_require__(9508);
var handleLineDefaults = __webpack_require__(1058);
var handleLineShapeDefaults = __webpack_require__(4039);
var handleTextDefaults = __webpack_require__(2410);
var handleFillColorDefaults = __webpack_require__(8908);
var coercePattern = (__webpack_require__(1828).coercePattern);
module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
  function coerce(attr, dflt) {
    return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
  }
  var len = handleXYDefaults(traceIn, traceOut, layout, coerce);
  if (!len) traceOut.visible = false;
  if (!traceOut.visible) return;
  handlePeriodDefaults(traceIn, traceOut, layout, coerce);
  coerce('xhoverformat');
  coerce('yhoverformat');
  var stackGroupOpts = handleStackDefaults(traceIn, traceOut, layout, coerce);
  if (layout.scattermode === 'group' && traceOut.orientation === undefined) {
    coerce('orientation', 'v');
  }
  var defaultMode = !stackGroupOpts && len < constants.PTS_LINESONLY ? 'lines+markers' : 'lines';
  coerce('text');
  coerce('hovertext');
  coerce('mode', defaultMode);
  if (subTypes.hasLines(traceOut)) {
    handleLineDefaults(traceIn, traceOut, defaultColor, layout, coerce, {
      backoff: true
    });
    handleLineShapeDefaults(traceIn, traceOut, coerce);
    coerce('connectgaps');
    coerce('line.simplify');
  }
  if (subTypes.hasMarkers(traceOut)) {
    handleMarkerDefaults(traceIn, traceOut, defaultColor, layout, coerce, {
      gradient: true
    });
  }
  if (subTypes.hasText(traceOut)) {
    coerce('texttemplate');
    handleTextDefaults(traceIn, traceOut, layout, coerce);
  }
  var dfltHoverOn = [];
  if (subTypes.hasMarkers(traceOut) || subTypes.hasText(traceOut)) {
    coerce('cliponaxis');
    coerce('marker.maxdisplayed');
    dfltHoverOn.push('points');
  }

  // It's possible for this default to be changed by a later trace.
  // We handle that case in some hacky code inside handleStackDefaults.
  coerce('fill', stackGroupOpts ? stackGroupOpts.fillDflt : 'none');
  if (traceOut.fill !== 'none') {
    handleFillColorDefaults(traceIn, traceOut, defaultColor, coerce);
    if (!subTypes.hasLines(traceOut)) handleLineShapeDefaults(traceIn, traceOut, coerce);
    coercePattern(coerce, 'fillpattern', traceOut.fillcolor, false);
  }
  var lineColor = (traceOut.line || {}).color;
  var markerColor = (traceOut.marker || {}).color;
  if (traceOut.fill === 'tonext' || traceOut.fill === 'toself') {
    dfltHoverOn.push('fills');
  }
  coerce('hoveron', dfltHoverOn.join('+') || 'points');
  if (traceOut.hoveron !== 'fills') coerce('hovertemplate');
  var errorBarsSupplyDefaults = Registry.getComponentMethod('errorbars', 'supplyDefaults');
  errorBarsSupplyDefaults(traceIn, traceOut, lineColor || markerColor || defaultColor, {
    axis: 'y'
  });
  errorBarsSupplyDefaults(traceIn, traceOut, lineColor || markerColor || defaultColor, {
    axis: 'x',
    inherit: 'y'
  });
  Lib.coerceSelectionMarkerOpacity(traceOut, coerce);
};

/***/ }),

/***/ 8908:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Color = __webpack_require__(7901);
var isArrayOrTypedArray = (__webpack_require__(1828).isArrayOrTypedArray);
module.exports = function fillColorDefaults(traceIn, traceOut, defaultColor, coerce) {
  var inheritColorFromMarker = false;
  if (traceOut.marker) {
    // don't try to inherit a color array
    var markerColor = traceOut.marker.color;
    var markerLineColor = (traceOut.marker.line || {}).color;
    if (markerColor && !isArrayOrTypedArray(markerColor)) {
      inheritColorFromMarker = markerColor;
    } else if (markerLineColor && !isArrayOrTypedArray(markerLineColor)) {
      inheritColorFromMarker = markerLineColor;
    }
  }
  coerce('fillcolor', Color.addOpacity((traceOut.line || {}).color || inheritColorFromMarker || defaultColor, 0.5));
};

/***/ }),

/***/ 8225:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Axes = __webpack_require__(9298);
module.exports = function formatLabels(cdi, trace, fullLayout) {
  var labels = {};
  var mockGd = {
    _fullLayout: fullLayout
  };
  var xa = Axes.getFromTrace(mockGd, trace, 'x');
  var ya = Axes.getFromTrace(mockGd, trace, 'y');
  var x = cdi.orig_x;
  if (x === undefined) x = cdi.x;
  var y = cdi.orig_y;
  if (y === undefined) y = cdi.y;
  labels.xLabel = Axes.tickText(xa, xa.c2l(x), true).text;
  labels.yLabel = Axes.tickText(ya, ya.c2l(y), true).text;
  return labels;
};

/***/ }),

/***/ 4603:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Color = __webpack_require__(7901);
var subtypes = __webpack_require__(4098);
module.exports = function getTraceColor(trace, di) {
  var lc, tc;

  // TODO: text modes

  if (trace.mode === 'lines') {
    lc = trace.line.color;
    return lc && Color.opacity(lc) ? lc : trace.fillcolor;
  } else if (trace.mode === 'none') {
    return trace.fill ? trace.fillcolor : '';
  } else {
    var mc = di.mcc || (trace.marker || {}).color;
    var mlc = di.mlcc || ((trace.marker || {}).line || {}).color;
    tc = mc && Color.opacity(mc) ? mc : mlc && Color.opacity(mlc) && (di.mlw || ((trace.marker || {}).line || {}).width) ? mlc : '';
    if (tc) {
      // make sure the points aren't TOO transparent
      if (Color.opacity(tc) < 0.3) {
        return Color.addOpacity(tc, 0.3);
      } else return tc;
    } else {
      lc = (trace.line || {}).color;
      return lc && Color.opacity(lc) && subtypes.hasLines(trace) && trace.line.width ? lc : trace.fillcolor;
    }
  }
};

/***/ }),

/***/ 6125:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var getAxisGroup = (__webpack_require__(9082).getAxisGroup);
module.exports = function handleGroupingDefaults(traceIn, traceOut, fullLayout, coerce) {
  var orientation = traceOut.orientation;
  // N.B. grouping is done across all trace types that support it
  var posAxId = traceOut[{
    v: 'x',
    h: 'y'
  }[orientation] + 'axis'];
  var groupId = getAxisGroup(fullLayout, posAxId) + orientation;
  var alignmentOpts = fullLayout._alignmentOpts || {};
  var alignmentgroup = coerce('alignmentgroup');
  var alignmentGroups = alignmentOpts[groupId];
  if (!alignmentGroups) alignmentGroups = alignmentOpts[groupId] = {};
  var alignmentGroupOpts = alignmentGroups[alignmentgroup];
  if (alignmentGroupOpts) {
    alignmentGroupOpts.traces.push(traceOut);
  } else {
    alignmentGroupOpts = alignmentGroups[alignmentgroup] = {
      traces: [traceOut],
      alignmentIndex: Object.keys(alignmentGroups).length,
      offsetGroups: {}
    };
  }
  var offsetgroup = coerce('offsetgroup');
  var offsetGroups = alignmentGroupOpts.offsetGroups;
  var offsetGroupOpts = offsetGroups[offsetgroup];
  if (offsetgroup) {
    if (!offsetGroupOpts) {
      offsetGroupOpts = offsetGroups[offsetgroup] = {
        offsetIndex: Object.keys(offsetGroups).length
      };
    }
    traceOut._offsetIndex = offsetGroupOpts.offsetIndex;
  }
};

/***/ }),

/***/ 3720:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Fx = __webpack_require__(211);
var Registry = __webpack_require__(3972);
var getTraceColor = __webpack_require__(4603);
var Color = __webpack_require__(7901);
var fillText = Lib.fillText;
module.exports = function hoverPoints(pointData, xval, yval, hovermode) {
  var cd = pointData.cd;
  var trace = cd[0].trace;
  var xa = pointData.xa;
  var ya = pointData.ya;
  var xpx = xa.c2p(xval);
  var ypx = ya.c2p(yval);
  var pt = [xpx, ypx];
  var hoveron = trace.hoveron || '';
  var minRad = trace.mode.indexOf('markers') !== -1 ? 3 : 0.5;
  var xPeriod = !!trace.xperiodalignment;
  var yPeriod = !!trace.yperiodalignment;

  // look for points to hover on first, then take fills only if we
  // didn't find a point

  if (hoveron.indexOf('points') !== -1) {
    // dx and dy are used in compare modes - here we want to always
    // prioritize the closest data point, at least as long as markers are
    // the same size or nonexistent, but still try to prioritize small markers too.
    var dx = function (di) {
      if (xPeriod) {
        var x0 = xa.c2p(di.xStart);
        var x1 = xa.c2p(di.xEnd);
        return xpx >= Math.min(x0, x1) && xpx <= Math.max(x0, x1) ? 0 : Infinity;
      }
      var rad = Math.max(3, di.mrc || 0);
      var kink = 1 - 1 / rad;
      var dxRaw = Math.abs(xa.c2p(di.x) - xpx);
      return dxRaw < rad ? kink * dxRaw / rad : dxRaw - rad + kink;
    };
    var dy = function (di) {
      if (yPeriod) {
        var y0 = ya.c2p(di.yStart);
        var y1 = ya.c2p(di.yEnd);
        return ypx >= Math.min(y0, y1) && ypx <= Math.max(y0, y1) ? 0 : Infinity;
      }
      var rad = Math.max(3, di.mrc || 0);
      var kink = 1 - 1 / rad;
      var dyRaw = Math.abs(ya.c2p(di.y) - ypx);
      return dyRaw < rad ? kink * dyRaw / rad : dyRaw - rad + kink;
    };

    // scatter points: d.mrc is the calculated marker radius
    // adjust the distance so if you're inside the marker it
    // always will show up regardless of point size, but
    // prioritize smaller points
    var dxy = function (di) {
      var rad = Math.max(minRad, di.mrc || 0);
      var dx = xa.c2p(di.x) - xpx;
      var dy = ya.c2p(di.y) - ypx;
      return Math.max(Math.sqrt(dx * dx + dy * dy) - rad, 1 - minRad / rad);
    };
    var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);
    Fx.getClosest(cd, distfn, pointData);

    // skip the rest (for this trace) if we didn't find a close point
    if (pointData.index !== false) {
      // the closest data point
      var di = cd[pointData.index];
      var xc = xa.c2p(di.x, true);
      var yc = ya.c2p(di.y, true);
      var rad = di.mrc || 1;

      // now we're done using the whole `calcdata` array, replace the
      // index with the original index (in case of inserted point from
      // stacked area)
      pointData.index = di.i;
      var orientation = cd[0].t.orientation;
      // TODO: for scatter and bar, option to show (sub)totals and
      // raw data? Currently stacked and/or normalized bars just show
      // the normalized individual sizes, so that's what I'm doing here
      // for now.
      var sizeVal = orientation && (di.sNorm || di.s);
      var xLabelVal = orientation === 'h' ? sizeVal : di.orig_x !== undefined ? di.orig_x : di.x;
      var yLabelVal = orientation === 'v' ? sizeVal : di.orig_y !== undefined ? di.orig_y : di.y;
      Lib.extendFlat(pointData, {
        color: getTraceColor(trace, di),
        x0: xc - rad,
        x1: xc + rad,
        xLabelVal: xLabelVal,
        y0: yc - rad,
        y1: yc + rad,
        yLabelVal: yLabelVal,
        spikeDistance: dxy(di),
        hovertemplate: trace.hovertemplate
      });
      fillText(di, trace, pointData);
      Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, pointData);
      return [pointData];
    }
  }

  // even if hoveron is 'fills', only use it if we have polygons too
  if (hoveron.indexOf('fills') !== -1 && trace._polygons) {
    var polygons = trace._polygons;
    var polygonsIn = [];
    var inside = false;
    var xmin = Infinity;
    var xmax = -Infinity;
    var ymin = Infinity;
    var ymax = -Infinity;
    var i, j, polygon, pts, xCross, x0, x1, y0, y1;
    for (i = 0; i < polygons.length; i++) {
      polygon = polygons[i];
      // TODO: this is not going to work right for curved edges, it will
      // act as though they're straight. That's probably going to need
      // the elements themselves to capture the events. Worth it?
      if (polygon.contains(pt)) {
        inside = !inside;
        // TODO: need better than just the overall bounding box
        polygonsIn.push(polygon);
        ymin = Math.min(ymin, polygon.ymin);
        ymax = Math.max(ymax, polygon.ymax);
      }
    }
    if (inside) {
      // constrain ymin/max to the visible plot, so the label goes
      // at the middle of the piece you can see
      ymin = Math.max(ymin, 0);
      ymax = Math.min(ymax, ya._length);

      // find the overall left-most and right-most points of the
      // polygon(s) we're inside at their combined vertical midpoint.
      // This is where we will draw the hover label.
      // Note that this might not be the vertical midpoint of the
      // whole trace, if it's disjoint.
      var yAvg = (ymin + ymax) / 2;
      for (i = 0; i < polygonsIn.length; i++) {
        pts = polygonsIn[i].pts;
        for (j = 1; j < pts.length; j++) {
          y0 = pts[j - 1][1];
          y1 = pts[j][1];
          if (y0 > yAvg !== y1 >= yAvg) {
            x0 = pts[j - 1][0];
            x1 = pts[j][0];
            if (y1 - y0) {
              xCross = x0 + (x1 - x0) * (yAvg - y0) / (y1 - y0);
              xmin = Math.min(xmin, xCross);
              xmax = Math.max(xmax, xCross);
            }
          }
        }
      }

      // constrain xmin/max to the visible plot now too
      xmin = Math.max(xmin, 0);
      xmax = Math.min(xmax, xa._length);

      // get only fill or line color for the hover color
      var color = Color.defaultLine;
      if (Color.opacity(trace.fillcolor)) color = trace.fillcolor;else if (Color.opacity((trace.line || {}).color)) {
        color = trace.line.color;
      }
      Lib.extendFlat(pointData, {
        // never let a 2D override 1D type as closest point
        // also: no spikeDistance, it's not allowed for fills
        distance: pointData.maxHoverDistance,
        x0: xmin,
        x1: xmax,
        y0: yAvg,
        y1: yAvg,
        color: color,
        hovertemplate: false
      });
      delete pointData.index;
      if (trace.text && !Array.isArray(trace.text)) {
        pointData.text = String(trace.text);
      } else pointData.text = trace.name;
      return [pointData];
    }
  }
};

/***/ }),

/***/ 7368:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var subtypes = __webpack_require__(4098);
module.exports = {
  hasLines: subtypes.hasLines,
  hasMarkers: subtypes.hasMarkers,
  hasText: subtypes.hasText,
  isBubble: subtypes.isBubble,
  attributes: __webpack_require__(2196),
  layoutAttributes: __webpack_require__(1479),
  supplyDefaults: __webpack_require__(7438),
  crossTraceDefaults: __webpack_require__(462),
  supplyLayoutDefaults: __webpack_require__(9334),
  calc: (__webpack_require__(7761).calc),
  crossTraceCalc: __webpack_require__(2626),
  arraysToCalcdata: __webpack_require__(5225),
  plot: __webpack_require__(7399),
  colorbar: __webpack_require__(4898),
  formatLabels: __webpack_require__(8225),
  style: (__webpack_require__(6296).style),
  styleOnSelect: (__webpack_require__(6296).styleOnSelect),
  hoverPoints: __webpack_require__(3720),
  selectPoints: __webpack_require__(8002),
  animatable: true,
  moduleType: 'trace',
  name: 'scatter',
  basePlotModule: __webpack_require__(3612),
  categories: ['cartesian', 'svg', 'symbols', 'errorBarsOK', 'showLegend', 'scatter-like', 'zoomScale'],
  meta: {}
};

/***/ }),

/***/ 1479:
/***/ (function(module) {

"use strict";


module.exports = {
  scattermode: {
    valType: 'enumerated',
    values: ['group', 'overlay'],
    dflt: 'overlay',
    editType: 'calc'
  },
  scattergap: {
    valType: 'number',
    min: 0,
    max: 1,
    editType: 'calc'
  }
};

/***/ }),

/***/ 9334:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var layoutAttributes = __webpack_require__(1479);
module.exports = function (layoutIn, layoutOut) {
  function coerce(attr, dflt) {
    return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
  }
  var groupBarmode = layoutOut.barmode === 'group';
  if (layoutOut.scattermode === 'group') {
    coerce('scattergap', groupBarmode ? layoutOut.bargap : 0.2);
  }
};

/***/ }),

/***/ 1058:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isArrayOrTypedArray = (__webpack_require__(1828).isArrayOrTypedArray);
var hasColorscale = (__webpack_require__(2869).hasColorscale);
var colorscaleDefaults = __webpack_require__(1586);
module.exports = function lineDefaults(traceIn, traceOut, defaultColor, layout, coerce, opts) {
  if (!opts) opts = {};
  var markerColor = (traceIn.marker || {}).color;
  coerce('line.color', defaultColor);
  if (hasColorscale(traceIn, 'line')) {
    colorscaleDefaults(traceIn, traceOut, layout, coerce, {
      prefix: 'line.',
      cLetter: 'c'
    });
  } else {
    var lineColorDflt = (isArrayOrTypedArray(markerColor) ? false : markerColor) || defaultColor;
    coerce('line.color', lineColorDflt);
  }
  coerce('line.width');
  if (!opts.noDash) coerce('line.dash');
  if (opts.backoff) coerce('line.backoff');
};

/***/ }),

/***/ 4621:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Drawing = __webpack_require__(1424);
var numConstants = __webpack_require__(606);
var BADNUM = numConstants.BADNUM;
var LOG_CLIP = numConstants.LOG_CLIP;
var LOG_CLIP_PLUS = LOG_CLIP + 0.5;
var LOG_CLIP_MINUS = LOG_CLIP - 0.5;
var Lib = __webpack_require__(1828);
var segmentsIntersect = Lib.segmentsIntersect;
var constrain = Lib.constrain;
var constants = __webpack_require__(7581);
module.exports = function linePoints(d, opts) {
  var trace = opts.trace || {};
  var xa = opts.xaxis;
  var ya = opts.yaxis;
  var xLog = xa.type === 'log';
  var yLog = ya.type === 'log';
  var xLen = xa._length;
  var yLen = ya._length;
  var backoff = opts.backoff;
  var marker = trace.marker;
  var connectGaps = opts.connectGaps;
  var baseTolerance = opts.baseTolerance;
  var shape = opts.shape;
  var linear = shape === 'linear';
  var fill = trace.fill && trace.fill !== 'none';
  var segments = [];
  var minTolerance = constants.minTolerance;
  var len = d.length;
  var pts = new Array(len);
  var pti = 0;
  var i;

  // pt variables are pixel coordinates [x,y] of one point
  // these four are the outputs of clustering on a line
  var clusterStartPt, clusterEndPt, clusterHighPt, clusterLowPt;

  // "this" is the next point we're considering adding to the cluster
  var thisPt;

  // did we encounter the high point first, then a low point, or vice versa?
  var clusterHighFirst;

  // the first two points in the cluster determine its unit vector
  // so the second is always in the "High" direction
  var clusterUnitVector;

  // the pixel delta from clusterStartPt
  var thisVector;

  // val variables are (signed) pixel distances along the cluster vector
  var clusterRefDist, clusterHighVal, clusterLowVal, thisVal;

  // deviation variables are (signed) pixel distances normal to the cluster vector
  var clusterMinDeviation, clusterMaxDeviation, thisDeviation;

  // turn one calcdata point into pixel coordinates
  function getPt(index) {
    var di = d[index];
    if (!di) return false;
    var x = opts.linearized ? xa.l2p(di.x) : xa.c2p(di.x);
    var y = opts.linearized ? ya.l2p(di.y) : ya.c2p(di.y);

    // if non-positive log values, set them VERY far off-screen
    // so the line looks essentially straight from the previous point.
    if (x === BADNUM) {
      if (xLog) x = xa.c2p(di.x, true);
      if (x === BADNUM) return false;
      // If BOTH were bad log values, make the line follow a constant
      // exponent rather than a constant slope
      if (yLog && y === BADNUM) {
        x *= Math.abs(xa._m * yLen * (xa._m > 0 ? LOG_CLIP_PLUS : LOG_CLIP_MINUS) / (ya._m * xLen * (ya._m > 0 ? LOG_CLIP_PLUS : LOG_CLIP_MINUS)));
      }
      x *= 1000;
    }
    if (y === BADNUM) {
      if (yLog) y = ya.c2p(di.y, true);
      if (y === BADNUM) return false;
      y *= 1000;
    }
    return [x, y];
  }
  function crossesViewport(xFrac0, yFrac0, xFrac1, yFrac1) {
    var dx = xFrac1 - xFrac0;
    var dy = yFrac1 - yFrac0;
    var dx0 = 0.5 - xFrac0;
    var dy0 = 0.5 - yFrac0;
    var norm2 = dx * dx + dy * dy;
    var dot = dx * dx0 + dy * dy0;
    if (dot > 0 && dot < norm2) {
      var cross = dx0 * dy - dy0 * dx;
      if (cross * cross < norm2) return true;
    }
  }
  var latestXFrac, latestYFrac;
  // if we're off-screen, increase tolerance over baseTolerance
  function getTolerance(pt, nextPt) {
    var xFrac = pt[0] / xLen;
    var yFrac = pt[1] / yLen;
    var offScreenFraction = Math.max(0, -xFrac, xFrac - 1, -yFrac, yFrac - 1);
    if (offScreenFraction && latestXFrac !== undefined && crossesViewport(xFrac, yFrac, latestXFrac, latestYFrac)) {
      offScreenFraction = 0;
    }
    if (offScreenFraction && nextPt && crossesViewport(xFrac, yFrac, nextPt[0] / xLen, nextPt[1] / yLen)) {
      offScreenFraction = 0;
    }
    return (1 + constants.toleranceGrowth * offScreenFraction) * baseTolerance;
  }
  function ptDist(pt1, pt2) {
    var dx = pt1[0] - pt2[0];
    var dy = pt1[1] - pt2[1];
    return Math.sqrt(dx * dx + dy * dy);
  }

  // last bit of filtering: clip paths that are VERY far off-screen
  // so we don't get near the browser's hard limit (+/- 2^29 px in Chrome and FF)

  var maxScreensAway = constants.maxScreensAway;

  // find the intersections between the segment from pt1 to pt2
  // and the large rectangle maxScreensAway around the viewport
  // if one of pt1 and pt2 is inside and the other outside, there
  // will be only one intersection.
  // if both are outside there will be 0 or 2 intersections
  // (or 1 if it's right at a corner - we'll treat that like 0)
  // returns an array of intersection pts
  var xEdge0 = -xLen * maxScreensAway;
  var xEdge1 = xLen * (1 + maxScreensAway);
  var yEdge0 = -yLen * maxScreensAway;
  var yEdge1 = yLen * (1 + maxScreensAway);
  var edges = [[xEdge0, yEdge0, xEdge1, yEdge0], [xEdge1, yEdge0, xEdge1, yEdge1], [xEdge1, yEdge1, xEdge0, yEdge1], [xEdge0, yEdge1, xEdge0, yEdge0]];
  var xEdge, yEdge, lastXEdge, lastYEdge, lastFarPt, edgePt;

  // for linear line shape, edge intersections should be linearly interpolated
  // spline uses this too, which isn't precisely correct but is actually pretty
  // good, because Catmull-Rom weights far-away points less in creating the curvature
  function getLinearEdgeIntersections(pt1, pt2) {
    var out = [];
    var ptCount = 0;
    for (var i = 0; i < 4; i++) {
      var edge = edges[i];
      var ptInt = segmentsIntersect(pt1[0], pt1[1], pt2[0], pt2[1], edge[0], edge[1], edge[2], edge[3]);
      if (ptInt && (!ptCount || Math.abs(ptInt.x - out[0][0]) > 1 || Math.abs(ptInt.y - out[0][1]) > 1)) {
        ptInt = [ptInt.x, ptInt.y];
        // if we have 2 intersections, make sure the closest one to pt1 comes first
        if (ptCount && ptDist(ptInt, pt1) < ptDist(out[0], pt1)) out.unshift(ptInt);else out.push(ptInt);
        ptCount++;
      }
    }
    return out;
  }
  function onlyConstrainedPoint(pt) {
    if (pt[0] < xEdge0 || pt[0] > xEdge1 || pt[1] < yEdge0 || pt[1] > yEdge1) {
      return [constrain(pt[0], xEdge0, xEdge1), constrain(pt[1], yEdge0, yEdge1)];
    }
  }
  function sameEdge(pt1, pt2) {
    if (pt1[0] === pt2[0] && (pt1[0] === xEdge0 || pt1[0] === xEdge1)) return true;
    if (pt1[1] === pt2[1] && (pt1[1] === yEdge0 || pt1[1] === yEdge1)) return true;
  }

  // for line shapes hv and vh, movement in the two dimensions is decoupled,
  // so all we need to do is constrain each dimension independently
  function getHVEdgeIntersections(pt1, pt2) {
    var out = [];
    var ptInt1 = onlyConstrainedPoint(pt1);
    var ptInt2 = onlyConstrainedPoint(pt2);
    if (ptInt1 && ptInt2 && sameEdge(ptInt1, ptInt2)) return out;
    if (ptInt1) out.push(ptInt1);
    if (ptInt2) out.push(ptInt2);
    return out;
  }

  // hvh and vhv we sometimes have to move one of the intersection points
  // out BEYOND the clipping rect, by a maximum of a factor of 2, so that
  // the midpoint line is drawn in the right place
  function getABAEdgeIntersections(dim, limit0, limit1) {
    return function (pt1, pt2) {
      var ptInt1 = onlyConstrainedPoint(pt1);
      var ptInt2 = onlyConstrainedPoint(pt2);
      var out = [];
      if (ptInt1 && ptInt2 && sameEdge(ptInt1, ptInt2)) return out;
      if (ptInt1) out.push(ptInt1);
      if (ptInt2) out.push(ptInt2);
      var midShift = 2 * Lib.constrain((pt1[dim] + pt2[dim]) / 2, limit0, limit1) - ((ptInt1 || pt1)[dim] + (ptInt2 || pt2)[dim]);
      if (midShift) {
        var ptToAlter;
        if (ptInt1 && ptInt2) {
          ptToAlter = midShift > 0 === ptInt1[dim] > ptInt2[dim] ? ptInt1 : ptInt2;
        } else ptToAlter = ptInt1 || ptInt2;
        ptToAlter[dim] += midShift;
      }
      return out;
    };
  }
  var getEdgeIntersections;
  if (shape === 'linear' || shape === 'spline') {
    getEdgeIntersections = getLinearEdgeIntersections;
  } else if (shape === 'hv' || shape === 'vh') {
    getEdgeIntersections = getHVEdgeIntersections;
  } else if (shape === 'hvh') getEdgeIntersections = getABAEdgeIntersections(0, xEdge0, xEdge1);else if (shape === 'vhv') getEdgeIntersections = getABAEdgeIntersections(1, yEdge0, yEdge1);

  // a segment pt1->pt2 entirely outside the nearby region:
  // find the corner it gets closest to touching
  function getClosestCorner(pt1, pt2) {
    var dx = pt2[0] - pt1[0];
    var m = (pt2[1] - pt1[1]) / dx;
    var b = (pt1[1] * pt2[0] - pt2[1] * pt1[0]) / dx;
    if (b > 0) return [m > 0 ? xEdge0 : xEdge1, yEdge1];else return [m > 0 ? xEdge1 : xEdge0, yEdge0];
  }
  function updateEdge(pt) {
    var x = pt[0];
    var y = pt[1];
    var xSame = x === pts[pti - 1][0];
    var ySame = y === pts[pti - 1][1];
    // duplicate point?
    if (xSame && ySame) return;
    if (pti > 1) {
      // backtracking along an edge?
      var xSame2 = x === pts[pti - 2][0];
      var ySame2 = y === pts[pti - 2][1];
      if (xSame && (x === xEdge0 || x === xEdge1) && xSame2) {
        if (ySame2) pti--; // backtracking exactly - drop prev pt and don't add
        else pts[pti - 1] = pt; // not exact: replace the prev pt
      } else if (ySame && (y === yEdge0 || y === yEdge1) && ySame2) {
        if (xSame2) pti--;else pts[pti - 1] = pt;
      } else pts[pti++] = pt;
    } else pts[pti++] = pt;
  }
  function updateEdgesForReentry(pt) {
    // if we're outside the nearby region and going back in,
    // we may need to loop around a corner point
    if (pts[pti - 1][0] !== pt[0] && pts[pti - 1][1] !== pt[1]) {
      updateEdge([lastXEdge, lastYEdge]);
    }
    updateEdge(pt);
    lastFarPt = null;
    lastXEdge = lastYEdge = 0;
  }
  var arrayMarker = Lib.isArrayOrTypedArray(marker);
  function addPt(pt) {
    if (pt && backoff) {
      pt.i = i;
      pt.d = d;
      pt.trace = trace;
      pt.marker = arrayMarker ? marker[pt.i] : marker;
      pt.backoff = backoff;
    }
    latestXFrac = pt[0] / xLen;
    latestYFrac = pt[1] / yLen;
    // Are we more than maxScreensAway off-screen any direction?
    // if so, clip to this box, but in such a way that on-screen
    // drawing is unchanged
    xEdge = pt[0] < xEdge0 ? xEdge0 : pt[0] > xEdge1 ? xEdge1 : 0;
    yEdge = pt[1] < yEdge0 ? yEdge0 : pt[1] > yEdge1 ? yEdge1 : 0;
    if (xEdge || yEdge) {
      if (!pti) {
        // to get fills right - if first point is far, push it toward the
        // screen in whichever direction(s) are far

        pts[pti++] = [xEdge || pt[0], yEdge || pt[1]];
      } else if (lastFarPt) {
        // both this point and the last are outside the nearby region
        // check if we're crossing the nearby region
        var intersections = getEdgeIntersections(lastFarPt, pt);
        if (intersections.length > 1) {
          updateEdgesForReentry(intersections[0]);
          pts[pti++] = intersections[1];
        }
      } else {
        // we're leaving the nearby region - add the point where we left it

        edgePt = getEdgeIntersections(pts[pti - 1], pt)[0];
        pts[pti++] = edgePt;
      }
      var lastPt = pts[pti - 1];
      if (xEdge && yEdge && (lastPt[0] !== xEdge || lastPt[1] !== yEdge)) {
        // we've gone out beyond a new corner: add the corner too
        // so that the next point will take the right winding
        if (lastFarPt) {
          if (lastXEdge !== xEdge && lastYEdge !== yEdge) {
            if (lastXEdge && lastYEdge) {
              // we've gone around to an opposite corner - we
              // need to add the correct extra corner
              // in order to get the right winding
              updateEdge(getClosestCorner(lastFarPt, pt));
            } else {
              // we're coming from a far edge - the extra corner
              // we need is determined uniquely by the sectors
              updateEdge([lastXEdge || xEdge, lastYEdge || yEdge]);
            }
          } else if (lastXEdge && lastYEdge) {
            updateEdge([lastXEdge, lastYEdge]);
          }
        }
        updateEdge([xEdge, yEdge]);
      } else if (lastXEdge - xEdge && lastYEdge - yEdge) {
        // we're coming from an edge or far corner to an edge - again the
        // extra corner we need is uniquely determined by the sectors
        updateEdge([xEdge || lastXEdge, yEdge || lastYEdge]);
      }
      lastFarPt = pt;
      lastXEdge = xEdge;
      lastYEdge = yEdge;
    } else {
      if (lastFarPt) {
        // this point is in range but the previous wasn't: add its entry pt first
        updateEdgesForReentry(getEdgeIntersections(lastFarPt, pt)[0]);
      }
      pts[pti++] = pt;
    }
  }

  // loop over ALL points in this trace
  for (i = 0; i < len; i++) {
    clusterStartPt = getPt(i);
    if (!clusterStartPt) continue;
    pti = 0;
    lastFarPt = null;
    addPt(clusterStartPt);

    // loop over one segment of the trace
    for (i++; i < len; i++) {
      clusterHighPt = getPt(i);
      if (!clusterHighPt) {
        if (connectGaps) continue;else break;
      }

      // can't decimate if nonlinear line shape
      // TODO: we *could* decimate [hv]{2,3} shapes if we restricted clusters to horz or vert again
      // but spline would be verrry awkward to decimate
      if (!linear || !opts.simplify) {
        addPt(clusterHighPt);
        continue;
      }
      var nextPt = getPt(i + 1);
      clusterRefDist = ptDist(clusterHighPt, clusterStartPt);

      // #3147 - always include the very first and last points for fills
      if (!(fill && (pti === 0 || pti === len - 1)) && clusterRefDist < getTolerance(clusterHighPt, nextPt) * minTolerance) continue;
      clusterUnitVector = [(clusterHighPt[0] - clusterStartPt[0]) / clusterRefDist, (clusterHighPt[1] - clusterStartPt[1]) / clusterRefDist];
      clusterLowPt = clusterStartPt;
      clusterHighVal = clusterRefDist;
      clusterLowVal = clusterMinDeviation = clusterMaxDeviation = 0;
      clusterHighFirst = false;
      clusterEndPt = clusterHighPt;

      // loop over one cluster of points that collapse onto one line
      for (i++; i < d.length; i++) {
        thisPt = nextPt;
        nextPt = getPt(i + 1);
        if (!thisPt) {
          if (connectGaps) continue;else break;
        }
        thisVector = [thisPt[0] - clusterStartPt[0], thisPt[1] - clusterStartPt[1]];
        // cross product (or dot with normal to the cluster vector)
        thisDeviation = thisVector[0] * clusterUnitVector[1] - thisVector[1] * clusterUnitVector[0];
        clusterMinDeviation = Math.min(clusterMinDeviation, thisDeviation);
        clusterMaxDeviation = Math.max(clusterMaxDeviation, thisDeviation);
        if (clusterMaxDeviation - clusterMinDeviation > getTolerance(thisPt, nextPt)) break;
        clusterEndPt = thisPt;
        thisVal = thisVector[0] * clusterUnitVector[0] + thisVector[1] * clusterUnitVector[1];
        if (thisVal > clusterHighVal) {
          clusterHighVal = thisVal;
          clusterHighPt = thisPt;
          clusterHighFirst = false;
        } else if (thisVal < clusterLowVal) {
          clusterLowVal = thisVal;
          clusterLowPt = thisPt;
          clusterHighFirst = true;
        }
      }

      // insert this cluster into pts
      // we've already inserted the start pt, now check if we have high and low pts
      if (clusterHighFirst) {
        addPt(clusterHighPt);
        if (clusterEndPt !== clusterLowPt) addPt(clusterLowPt);
      } else {
        if (clusterLowPt !== clusterStartPt) addPt(clusterLowPt);
        if (clusterEndPt !== clusterHighPt) addPt(clusterHighPt);
      }
      // and finally insert the end pt
      addPt(clusterEndPt);

      // have we reached the end of this segment?
      if (i >= d.length || !thisPt) break;

      // otherwise we have an out-of-cluster point to insert as next clusterStartPt
      addPt(thisPt);
      clusterStartPt = thisPt;
    }

    // to get fills right - repeat what we did at the start
    if (lastFarPt) updateEdge([lastXEdge || lastFarPt[0], lastYEdge || lastFarPt[1]]);
    segments.push(pts.slice(0, pti));
  }
  var lastShapeChar = shape.slice(shape.length - 1);
  if (backoff && lastShapeChar !== 'h' && lastShapeChar !== 'v') {
    var trimmed = false;
    var n = -1;
    var newSegments = [];
    for (var j = 0; j < segments.length; j++) {
      for (var k = 0; k < segments[j].length - 1; k++) {
        var start = segments[j][k];
        var end = segments[j][k + 1];
        var xy = Drawing.applyBackoff(end, start);
        if (xy[0] !== end[0] || xy[1] !== end[1]) {
          trimmed = true;
        }
        if (!newSegments[n + 1]) {
          n++;
          newSegments[n] = [start, [xy[0], xy[1]]];
        }
      }
    }
    return trimmed ? newSegments : segments;
  }
  return segments;
};

/***/ }),

/***/ 4039:
/***/ (function(module) {

"use strict";


// common to 'scatter' and 'scatterternary'
module.exports = function handleLineShapeDefaults(traceIn, traceOut, coerce) {
  var shape = coerce('line.shape');
  if (shape === 'spline') coerce('line.smoothing');
};

/***/ }),

/***/ 8687:
/***/ (function(module) {

"use strict";


var LINKEDFILLS = {
  tonextx: 1,
  tonexty: 1,
  tonext: 1
};
module.exports = function linkTraces(gd, plotinfo, cdscatter) {
  var trace, i, group, prevtrace, groupIndex;

  // first sort traces to keep stacks & filled-together groups together
  var groupIndices = {};
  var needsSort = false;
  var prevGroupIndex = -1;
  var nextGroupIndex = 0;
  var prevUnstackedGroupIndex = -1;
  for (i = 0; i < cdscatter.length; i++) {
    trace = cdscatter[i][0].trace;
    group = trace.stackgroup || '';
    if (group) {
      if (group in groupIndices) {
        groupIndex = groupIndices[group];
      } else {
        groupIndex = groupIndices[group] = nextGroupIndex;
        nextGroupIndex++;
      }
    } else if (trace.fill in LINKEDFILLS && prevUnstackedGroupIndex >= 0) {
      groupIndex = prevUnstackedGroupIndex;
    } else {
      groupIndex = prevUnstackedGroupIndex = nextGroupIndex;
      nextGroupIndex++;
    }
    if (groupIndex < prevGroupIndex) needsSort = true;
    trace._groupIndex = prevGroupIndex = groupIndex;
  }
  var cdscatterSorted = cdscatter.slice();
  if (needsSort) {
    cdscatterSorted.sort(function (a, b) {
      var traceA = a[0].trace;
      var traceB = b[0].trace;
      return traceA._groupIndex - traceB._groupIndex || traceA.index - traceB.index;
    });
  }

  // now link traces to each other
  var prevtraces = {};
  for (i = 0; i < cdscatterSorted.length; i++) {
    trace = cdscatterSorted[i][0].trace;
    group = trace.stackgroup || '';

    // Note: The check which ensures all cdscatter here are for the same axis and
    // are either cartesian or scatterternary has been removed. This code assumes
    // the passed scattertraces have been filtered to the proper plot types and
    // the proper subplots.
    if (trace.visible === true) {
      trace._nexttrace = null;
      if (trace.fill in LINKEDFILLS) {
        prevtrace = prevtraces[group];
        trace._prevtrace = prevtrace || null;
        if (prevtrace) {
          prevtrace._nexttrace = trace;
        }
      }
      trace._ownfill = trace.fill && (trace.fill.substr(0, 6) === 'tozero' || trace.fill === 'toself' || trace.fill.substr(0, 2) === 'to' && !trace._prevtrace);
      prevtraces[group] = trace;
    } else {
      trace._prevtrace = trace._nexttrace = trace._ownfill = null;
    }
  }
  return cdscatterSorted;
};

/***/ }),

/***/ 9984:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isNumeric = __webpack_require__(2770);

// used in the drawing step for 'scatter' and 'scattegeo' and
// in the convert step for 'scatter3d'
module.exports = function makeBubbleSizeFn(trace, factor) {
  if (!factor) {
    factor = 2;
  }
  var marker = trace.marker;
  var sizeRef = marker.sizeref || 1;
  var sizeMin = marker.sizemin || 0;

  // for bubble charts, allow scaling the provided value linearly
  // and by area or diameter.
  // Note this only applies to the array-value sizes

  var baseFn = marker.sizemode === 'area' ? function (v) {
    return Math.sqrt(v / sizeRef);
  } : function (v) {
    return v / sizeRef;
  };

  // TODO add support for position/negative bubbles?
  // TODO add 'sizeoffset' attribute?
  return function (v) {
    var baseSize = baseFn(v / factor);

    // don't show non-numeric and negative sizes
    return isNumeric(baseSize) && baseSize > 0 ? Math.max(baseSize, sizeMin) : 0;
  };
};

/***/ }),

/***/ 4898:
/***/ (function(module) {

"use strict";


module.exports = {
  container: 'marker',
  min: 'cmin',
  max: 'cmax'
};

/***/ }),

/***/ 9508:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Color = __webpack_require__(7901);
var hasColorscale = (__webpack_require__(2869).hasColorscale);
var colorscaleDefaults = __webpack_require__(1586);
var subTypes = __webpack_require__(4098);

/*
 * opts: object of flags to control features not all marker users support
 *   noLine: caller does not support marker lines
 *   gradient: caller supports gradients
 *   noSelect: caller does not support selected/unselected attribute containers
 */
module.exports = function markerDefaults(traceIn, traceOut, defaultColor, layout, coerce, opts) {
  var isBubble = subTypes.isBubble(traceIn);
  var lineColor = (traceIn.line || {}).color;
  var defaultMLC;
  opts = opts || {};

  // marker.color inherit from line.color (even if line.color is an array)
  if (lineColor) defaultColor = lineColor;
  coerce('marker.symbol');
  coerce('marker.opacity', isBubble ? 0.7 : 1);
  coerce('marker.size');
  if (!opts.noAngle) {
    coerce('marker.angle');
    if (!opts.noAngleRef) {
      coerce('marker.angleref');
    }
    if (!opts.noStandOff) {
      coerce('marker.standoff');
    }
  }
  coerce('marker.color', defaultColor);
  if (hasColorscale(traceIn, 'marker')) {
    colorscaleDefaults(traceIn, traceOut, layout, coerce, {
      prefix: 'marker.',
      cLetter: 'c'
    });
  }
  if (!opts.noSelect) {
    coerce('selected.marker.color');
    coerce('unselected.marker.color');
    coerce('selected.marker.size');
    coerce('unselected.marker.size');
  }
  if (!opts.noLine) {
    // if there's a line with a different color than the marker, use
    // that line color as the default marker line color
    // (except when it's an array)
    // mostly this is for transparent markers to behave nicely
    if (lineColor && !Array.isArray(lineColor) && traceOut.marker.color !== lineColor) {
      defaultMLC = lineColor;
    } else if (isBubble) defaultMLC = Color.background;else defaultMLC = Color.defaultLine;
    coerce('marker.line.color', defaultMLC);
    if (hasColorscale(traceIn, 'marker.line')) {
      colorscaleDefaults(traceIn, traceOut, layout, coerce, {
        prefix: 'marker.line.',
        cLetter: 'c'
      });
    }
    coerce('marker.line.width', isBubble ? 1 : 0);
  }
  if (isBubble) {
    coerce('marker.sizeref');
    coerce('marker.sizemin');
    coerce('marker.sizemode');
  }
  if (opts.gradient) {
    var gradientType = coerce('marker.gradient.type');
    if (gradientType !== 'none') {
      coerce('marker.gradient.color');
    }
  }
};

/***/ }),

/***/ 3927:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var dateTick0 = (__webpack_require__(1828).dateTick0);
var numConstants = __webpack_require__(606);
var ONEWEEK = numConstants.ONEWEEK;
function getPeriod0Dflt(period, calendar) {
  if (period % ONEWEEK === 0) {
    return dateTick0(calendar, 1); // Sunday
  }

  return dateTick0(calendar, 0);
}
module.exports = function handlePeriodDefaults(traceIn, traceOut, layout, coerce, opts) {
  if (!opts) {
    opts = {
      x: true,
      y: true
    };
  }
  if (opts.x) {
    var xperiod = coerce('xperiod');
    if (xperiod) {
      coerce('xperiod0', getPeriod0Dflt(xperiod, traceOut.xcalendar));
      coerce('xperiodalignment');
    }
  }
  if (opts.y) {
    var yperiod = coerce('yperiod');
    if (yperiod) {
      coerce('yperiod0', getPeriod0Dflt(yperiod, traceOut.ycalendar));
      coerce('yperiodalignment');
    }
  }
};

/***/ }),

/***/ 7399:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var ensureSingle = Lib.ensureSingle;
var identity = Lib.identity;
var Drawing = __webpack_require__(1424);
var subTypes = __webpack_require__(4098);
var linePoints = __webpack_require__(4621);
var linkTraces = __webpack_require__(8687);
var polygonTester = (__webpack_require__(1082).tester);
module.exports = function plot(gd, plotinfo, cdscatter, scatterLayer, transitionOpts, makeOnCompleteCallback) {
  var join, onComplete;

  // If transition config is provided, then it is only a partial replot and traces not
  // updated are removed.
  var isFullReplot = !transitionOpts;
  var hasTransition = !!transitionOpts && transitionOpts.duration > 0;

  // Link traces so the z-order of fill layers is correct
  var cdscatterSorted = linkTraces(gd, plotinfo, cdscatter);
  join = scatterLayer.selectAll('g.trace').data(cdscatterSorted, function (d) {
    return d[0].trace.uid;
  });

  // Append new traces:
  join.enter().append('g').attr('class', function (d) {
    return 'trace scatter trace' + d[0].trace.uid;
  }).style('stroke-miterlimit', 2);
  join.order();
  createFills(gd, join, plotinfo);
  if (hasTransition) {
    if (makeOnCompleteCallback) {
      // If it was passed a callback to register completion, make a callback. If
      // this is created, then it must be executed on completion, otherwise the
      // pos-transition redraw will not execute:
      onComplete = makeOnCompleteCallback();
    }
    var transition = d3.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each('end', function () {
      onComplete && onComplete();
    }).each('interrupt', function () {
      onComplete && onComplete();
    });
    transition.each(function () {
      // Must run the selection again since otherwise enters/updates get grouped together
      // and these get executed out of order. Except we need them in order!
      scatterLayer.selectAll('g.trace').each(function (d, i) {
        plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);
      });
    });
  } else {
    join.each(function (d, i) {
      plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);
    });
  }
  if (isFullReplot) {
    join.exit().remove();
  }

  // remove paths that didn't get used
  scatterLayer.selectAll('path:not([d])').remove();
};
function createFills(gd, traceJoin, plotinfo) {
  traceJoin.each(function (d) {
    var fills = ensureSingle(d3.select(this), 'g', 'fills');
    Drawing.setClipUrl(fills, plotinfo.layerClipId, gd);
    var trace = d[0].trace;
    var fillData = [];
    if (trace._ownfill) fillData.push('_ownFill');
    if (trace._nexttrace) fillData.push('_nextFill');
    var fillJoin = fills.selectAll('g').data(fillData, identity);
    fillJoin.enter().append('g');
    fillJoin.exit().each(function (d) {
      trace[d] = null;
    }).remove();
    fillJoin.order().each(function (d) {
      // make a path element inside the fill group, just so
      // we can give it its own data later on and the group can
      // keep its simple '_*Fill' data
      trace[d] = ensureSingle(d3.select(this), 'path', 'js-fill');
    });
  });
}
function plotOne(gd, idx, plotinfo, cdscatter, cdscatterAll, element, transitionOpts) {
  var isStatic = gd._context.staticPlot;
  var i;

  // Since this has been reorganized and we're executing this on individual traces,
  // we need to pass it the full list of cdscatter as well as this trace's index (idx)
  // since it does an internal n^2 loop over comparisons with other traces:
  selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll);
  var hasTransition = !!transitionOpts && transitionOpts.duration > 0;
  function transition(selection) {
    return hasTransition ? selection.transition() : selection;
  }
  var xa = plotinfo.xaxis;
  var ya = plotinfo.yaxis;
  var trace = cdscatter[0].trace;
  var line = trace.line;
  var tr = d3.select(element);
  var errorBarGroup = ensureSingle(tr, 'g', 'errorbars');
  var lines = ensureSingle(tr, 'g', 'lines');
  var points = ensureSingle(tr, 'g', 'points');
  var text = ensureSingle(tr, 'g', 'text');

  // error bars are at the bottom
  Registry.getComponentMethod('errorbars', 'plot')(gd, errorBarGroup, plotinfo, transitionOpts);
  if (trace.visible !== true) return;
  transition(tr).style('opacity', trace.opacity);

  // BUILD LINES AND FILLS
  var ownFillEl3, tonext;
  var ownFillDir = trace.fill.charAt(trace.fill.length - 1);
  if (ownFillDir !== 'x' && ownFillDir !== 'y') ownFillDir = '';

  // store node for tweaking by selectPoints
  cdscatter[0][plotinfo.isRangePlot ? 'nodeRangePlot3' : 'node3'] = tr;
  var prevRevpath = '';
  var prevPolygons = [];
  var prevtrace = trace._prevtrace;
  if (prevtrace) {
    prevRevpath = prevtrace._prevRevpath || '';
    tonext = prevtrace._nextFill;
    prevPolygons = prevtrace._polygons;
  }
  var thispath;
  var thisrevpath;
  // fullpath is all paths for this curve, joined together straight
  // across gaps, for filling
  var fullpath = '';
  // revpath is fullpath reversed, for fill-to-next
  var revpath = '';
  // functions for converting a point array to a path
  var pathfn, revpathbase, revpathfn;
  // variables used before and after the data join
  var pt0, lastSegment, pt1, thisPolygons;

  // initialize line join data / method
  var segments = [];
  var makeUpdate = Lib.noop;
  ownFillEl3 = trace._ownFill;
  if (subTypes.hasLines(trace) || trace.fill !== 'none') {
    if (tonext) {
      // This tells .style which trace to use for fill information:
      tonext.datum(cdscatter);
    }
    if (['hv', 'vh', 'hvh', 'vhv'].indexOf(line.shape) !== -1) {
      pathfn = Drawing.steps(line.shape);
      revpathbase = Drawing.steps(line.shape.split('').reverse().join(''));
    } else if (line.shape === 'spline') {
      pathfn = revpathbase = function (pts) {
        var pLast = pts[pts.length - 1];
        if (pts.length > 1 && pts[0][0] === pLast[0] && pts[0][1] === pLast[1]) {
          // identical start and end points: treat it as a
          // closed curve so we don't get a kink
          return Drawing.smoothclosed(pts.slice(1), line.smoothing);
        } else {
          return Drawing.smoothopen(pts, line.smoothing);
        }
      };
    } else {
      pathfn = revpathbase = function (pts) {
        return 'M' + pts.join('L');
      };
    }
    revpathfn = function (pts) {
      // note: this is destructive (reverses pts in place) so can't use pts after this
      return revpathbase(pts.reverse());
    };
    segments = linePoints(cdscatter, {
      xaxis: xa,
      yaxis: ya,
      trace: trace,
      connectGaps: trace.connectgaps,
      baseTolerance: Math.max(line.width || 1, 3) / 4,
      shape: line.shape,
      backoff: line.backoff,
      simplify: line.simplify,
      fill: trace.fill
    });

    // since we already have the pixel segments here, use them to make
    // polygons for hover on fill
    // TODO: can we skip this if hoveron!=fills? That would mean we
    // need to redraw when you change hoveron...
    thisPolygons = trace._polygons = new Array(segments.length);
    for (i = 0; i < segments.length; i++) {
      trace._polygons[i] = polygonTester(segments[i]);
    }
    if (segments.length) {
      pt0 = segments[0][0];
      lastSegment = segments[segments.length - 1];
      pt1 = lastSegment[lastSegment.length - 1];
    }
    makeUpdate = function (isEnter) {
      return function (pts) {
        thispath = pathfn(pts);
        thisrevpath = revpathfn(pts);
        if (!fullpath) {
          fullpath = thispath;
          revpath = thisrevpath;
        } else if (ownFillDir) {
          fullpath += 'L' + thispath.substr(1);
          revpath = thisrevpath + ('L' + revpath.substr(1));
        } else {
          fullpath += 'Z' + thispath;
          revpath = thisrevpath + 'Z' + revpath;
        }
        if (subTypes.hasLines(trace)) {
          var el = d3.select(this);

          // This makes the coloring work correctly:
          el.datum(cdscatter);
          if (isEnter) {
            transition(el.style('opacity', 0).attr('d', thispath).call(Drawing.lineGroupStyle)).style('opacity', 1);
          } else {
            var sel = transition(el);
            sel.attr('d', thispath);
            Drawing.singleLineStyle(cdscatter, sel);
          }
        }
      };
    };
  }
  var lineJoin = lines.selectAll('.js-line').data(segments);
  transition(lineJoin.exit()).style('opacity', 0).remove();
  lineJoin.each(makeUpdate(false));
  lineJoin.enter().append('path').classed('js-line', true).style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke').call(Drawing.lineGroupStyle).each(makeUpdate(true));
  Drawing.setClipUrl(lineJoin, plotinfo.layerClipId, gd);
  function clearFill(selection) {
    transition(selection).attr('d', 'M0,0Z');
  }
  if (segments.length) {
    if (ownFillEl3) {
      ownFillEl3.datum(cdscatter);
      if (pt0 && pt1) {
        if (ownFillDir) {
          if (ownFillDir === 'y') {
            pt0[1] = pt1[1] = ya.c2p(0, true);
          } else if (ownFillDir === 'x') {
            pt0[0] = pt1[0] = xa.c2p(0, true);
          }

          // fill to zero: full trace path, plus extension of
          // the endpoints to the appropriate axis
          // For the sake of animations, wrap the points around so that
          // the points on the axes are the first two points. Otherwise
          // animations get a little crazy if the number of points changes.
          transition(ownFillEl3).attr('d', 'M' + pt1 + 'L' + pt0 + 'L' + fullpath.substr(1)).call(Drawing.singleFillStyle, gd);
        } else {
          // fill to self: just join the path to itself
          transition(ownFillEl3).attr('d', fullpath + 'Z').call(Drawing.singleFillStyle, gd);
        }
      }
    } else if (tonext) {
      if (trace.fill.substr(0, 6) === 'tonext' && fullpath && prevRevpath) {
        // fill to next: full trace path, plus the previous path reversed
        if (trace.fill === 'tonext') {
          // tonext: for use by concentric shapes, like manually constructed
          // contours, we just add the two paths closed on themselves.
          // This makes strange results if one path is *not* entirely
          // inside the other, but then that is a strange usage.
          transition(tonext).attr('d', fullpath + 'Z' + prevRevpath + 'Z').call(Drawing.singleFillStyle, gd);
        } else {
          // tonextx/y: for now just connect endpoints with lines. This is
          // the correct behavior if the endpoints are at the same value of
          // y/x, but if they *aren't*, we should ideally do more complicated
          // things depending on whether the new endpoint projects onto the
          // existing curve or off the end of it
          transition(tonext).attr('d', fullpath + 'L' + prevRevpath.substr(1) + 'Z').call(Drawing.singleFillStyle, gd);
        }
        trace._polygons = trace._polygons.concat(prevPolygons);
      } else {
        clearFill(tonext);
        trace._polygons = null;
      }
    }
    trace._prevRevpath = revpath;
    trace._prevPolygons = thisPolygons;
  } else {
    if (ownFillEl3) clearFill(ownFillEl3);else if (tonext) clearFill(tonext);
    trace._polygons = trace._prevRevpath = trace._prevPolygons = null;
  }
  function visFilter(d) {
    return d.filter(function (v) {
      return !v.gap && v.vis;
    });
  }
  function visFilterWithGaps(d) {
    return d.filter(function (v) {
      return v.vis;
    });
  }
  function gapFilter(d) {
    return d.filter(function (v) {
      return !v.gap;
    });
  }
  function keyFunc(d) {
    return d.id;
  }

  // Returns a function if the trace is keyed, otherwise returns undefined
  function getKeyFunc(trace) {
    if (trace.ids) {
      return keyFunc;
    }
  }
  function hideFilter() {
    return false;
  }
  function makePoints(points, text, cdscatter) {
    var join, selection, hasNode;
    var trace = cdscatter[0].trace;
    var showMarkers = subTypes.hasMarkers(trace);
    var showText = subTypes.hasText(trace);
    var keyFunc = getKeyFunc(trace);
    var markerFilter = hideFilter;
    var textFilter = hideFilter;
    if (showMarkers || showText) {
      var showFilter = identity;
      // if we're stacking, "infer zero" gap mode gets markers in the
      // gap points - because we've inferred a zero there - but other
      // modes (currently "interpolate", later "interrupt" hopefully)
      // we don't draw generated markers
      var stackGroup = trace.stackgroup;
      var isInferZero = stackGroup && gd._fullLayout._scatterStackOpts[xa._id + ya._id][stackGroup].stackgaps === 'infer zero';
      if (trace.marker.maxdisplayed || trace._needsCull) {
        showFilter = isInferZero ? visFilterWithGaps : visFilter;
      } else if (stackGroup && !isInferZero) {
        showFilter = gapFilter;
      }
      if (showMarkers) markerFilter = showFilter;
      if (showText) textFilter = showFilter;
    }

    // marker points

    selection = points.selectAll('path.point');
    join = selection.data(markerFilter, keyFunc);
    var enter = join.enter().append('path').classed('point', true);
    if (hasTransition) {
      enter.call(Drawing.pointStyle, trace, gd).call(Drawing.translatePoints, xa, ya).style('opacity', 0).transition().style('opacity', 1);
    }
    join.order();
    var styleFns;
    if (showMarkers) {
      styleFns = Drawing.makePointStyleFns(trace);
    }
    join.each(function (d) {
      var el = d3.select(this);
      var sel = transition(el);
      hasNode = Drawing.translatePoint(d, sel, xa, ya);
      if (hasNode) {
        Drawing.singlePointStyle(d, sel, trace, styleFns, gd);
        if (plotinfo.layerClipId) {
          Drawing.hideOutsideRangePoint(d, sel, xa, ya, trace.xcalendar, trace.ycalendar);
        }
        if (trace.customdata) {
          el.classed('plotly-customdata', d.data !== null && d.data !== undefined);
        }
      } else {
        sel.remove();
      }
    });
    if (hasTransition) {
      join.exit().transition().style('opacity', 0).remove();
    } else {
      join.exit().remove();
    }

    // text points
    selection = text.selectAll('g');
    join = selection.data(textFilter, keyFunc);

    // each text needs to go in its own 'g' in case
    // it gets converted to mathjax
    join.enter().append('g').classed('textpoint', true).append('text');
    join.order();
    join.each(function (d) {
      var g = d3.select(this);
      var sel = transition(g.select('text'));
      hasNode = Drawing.translatePoint(d, sel, xa, ya);
      if (hasNode) {
        if (plotinfo.layerClipId) {
          Drawing.hideOutsideRangePoint(d, g, xa, ya, trace.xcalendar, trace.ycalendar);
        }
      } else {
        g.remove();
      }
    });
    join.selectAll('text').call(Drawing.textPointStyle, trace, gd).each(function (d) {
      // This just *has* to be totally custom because of SVG text positioning :(
      // It's obviously copied from translatePoint; we just can't use that
      var x = xa.c2p(d.x);
      var y = ya.c2p(d.y);
      d3.select(this).selectAll('tspan.line').each(function () {
        transition(d3.select(this)).attr({
          x: x,
          y: y
        });
      });
    });
    join.exit().remove();
  }
  points.datum(cdscatter);
  text.datum(cdscatter);
  makePoints(points, text, cdscatter);

  // lastly, clip points groups of `cliponaxis !== false` traces
  // on `plotinfo._hasClipOnAxisFalse === true` subplots
  var hasClipOnAxisFalse = trace.cliponaxis === false;
  var clipUrl = hasClipOnAxisFalse ? null : plotinfo.layerClipId;
  Drawing.setClipUrl(points, clipUrl, gd);
  Drawing.setClipUrl(text, clipUrl, gd);
}
function selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll) {
  var xa = plotinfo.xaxis;
  var ya = plotinfo.yaxis;
  var xr = d3.extent(Lib.simpleMap(xa.range, xa.r2c));
  var yr = d3.extent(Lib.simpleMap(ya.range, ya.r2c));
  var trace = cdscatter[0].trace;
  if (!subTypes.hasMarkers(trace)) return;
  // if marker.maxdisplayed is used, select a maximum of
  // mnum markers to show, from the set that are in the viewport
  var mnum = trace.marker.maxdisplayed;

  // TODO: remove some as we get away from the viewport?
  if (mnum === 0) return;
  var cd = cdscatter.filter(function (v) {
    return v.x >= xr[0] && v.x <= xr[1] && v.y >= yr[0] && v.y <= yr[1];
  });
  var inc = Math.ceil(cd.length / mnum);
  var tnum = 0;
  cdscatterAll.forEach(function (cdj, j) {
    var tracei = cdj[0].trace;
    if (subTypes.hasMarkers(tracei) && tracei.marker.maxdisplayed > 0 && j < idx) {
      tnum++;
    }
  });

  // if multiple traces use maxdisplayed, stagger which markers we
  // display this formula offsets successive traces by 1/3 of the
  // increment, adding an extra small amount after each triplet so
  // it's not quite periodic
  var i0 = Math.round(tnum * inc / 3 + Math.floor(tnum / 3) * inc / 7.1);

  // for error bars: save in cd which markers to show
  // so we don't have to repeat this
  cdscatter.forEach(function (v) {
    delete v.vis;
  });
  cd.forEach(function (v, i) {
    if (Math.round((i + i0) % inc) === 0) v.vis = true;
  });
}

/***/ }),

/***/ 8002:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var subtypes = __webpack_require__(4098);
module.exports = function selectPoints(searchInfo, selectionTester) {
  var cd = searchInfo.cd;
  var xa = searchInfo.xaxis;
  var ya = searchInfo.yaxis;
  var selection = [];
  var trace = cd[0].trace;
  var i;
  var di;
  var x;
  var y;
  var hasOnlyLines = !subtypes.hasMarkers(trace) && !subtypes.hasText(trace);
  if (hasOnlyLines) return [];
  if (selectionTester === false) {
    // clear selection
    for (i = 0; i < cd.length; i++) {
      cd[i].selected = 0;
    }
  } else {
    for (i = 0; i < cd.length; i++) {
      di = cd[i];
      x = xa.c2p(di.x);
      y = ya.c2p(di.y);
      if (di.i !== null && selectionTester.contains([x, y], false, i, searchInfo)) {
        selection.push({
          pointNumber: di.i,
          x: xa.c2d(di.x),
          y: ya.c2d(di.y)
        });
        di.selected = 1;
      } else {
        di.selected = 0;
      }
    }
  }
  return selection;
};

/***/ }),

/***/ 565:
/***/ (function(module) {

"use strict";


var perStackAttrs = ['orientation', 'groupnorm', 'stackgaps'];
module.exports = function handleStackDefaults(traceIn, traceOut, layout, coerce) {
  var stackOpts = layout._scatterStackOpts;
  var stackGroup = coerce('stackgroup');
  if (stackGroup) {
    // use independent stacking options per subplot
    var subplot = traceOut.xaxis + traceOut.yaxis;
    var subplotStackOpts = stackOpts[subplot];
    if (!subplotStackOpts) subplotStackOpts = stackOpts[subplot] = {};
    var groupOpts = subplotStackOpts[stackGroup];
    var firstTrace = false;
    if (groupOpts) {
      groupOpts.traces.push(traceOut);
    } else {
      groupOpts = subplotStackOpts[stackGroup] = {
        // keep track of trace indices for use during stacking calculations
        // this will be filled in during `calc` and used during `crossTraceCalc`
        // so it's OK if we don't recreate it during a non-calc edit
        traceIndices: [],
        // Hold on to the whole set of prior traces
        // First one is most important, so we can clear defaults
        // there if we find explicit values only in later traces.
        // We're only going to *use* the values stored in groupOpts,
        // but for the editor and validate we want things self-consistent
        // The full set of traces is used only to fix `fill` default if
        // we find `orientation: 'h'` beyond the first trace
        traces: [traceOut]
      };
      firstTrace = true;
    }
    // TODO: how is this going to work with groupby transforms?
    // in principle it should be OK I guess, as long as explicit group styles
    // don't override explicit base-trace styles?

    var dflts = {
      orientation: traceOut.x && !traceOut.y ? 'h' : 'v'
    };
    for (var i = 0; i < perStackAttrs.length; i++) {
      var attr = perStackAttrs[i];
      var attrFound = attr + 'Found';
      if (!groupOpts[attrFound]) {
        var traceHasAttr = traceIn[attr] !== undefined;
        var isOrientation = attr === 'orientation';
        if (traceHasAttr || firstTrace) {
          groupOpts[attr] = coerce(attr, dflts[attr]);
          if (isOrientation) {
            groupOpts.fillDflt = groupOpts[attr] === 'h' ? 'tonextx' : 'tonexty';
          }
          if (traceHasAttr) {
            // Note: this will show a value here even if it's invalid
            // in which case it will revert to default.
            groupOpts[attrFound] = true;

            // Note: only one trace in the stack will get a _fullData
            // entry for a given stack-wide attribute. If no traces
            // (or the first trace) specify that attribute, the
            // first trace will get it. If the first trace does NOT
            // specify it but some later trace does, then it gets
            // removed from the first trace and only included in the
            // one that specified it. This is mostly important for
            // editors (that want to see the full values to know
            // what settings are available) and Plotly.react diffing.
            // Editors may want to use fullLayout._scatterStackOpts
            // directly and make these settings available from all
            // traces in the stack... then set the new value into
            // the first trace, and clear all later traces.
            if (!firstTrace) {
              delete groupOpts.traces[0][attr];

              // orientation can affect default fill of previous traces
              if (isOrientation) {
                for (var j = 0; j < groupOpts.traces.length - 1; j++) {
                  var trace2 = groupOpts.traces[j];
                  if (trace2._input.fill !== trace2.fill) {
                    trace2.fill = groupOpts.fillDflt;
                  }
                }
              }
            }
          }
        }
      }
    }
    return groupOpts;
  }
};

/***/ }),

/***/ 6296:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d3 = __webpack_require__(9898);
var Drawing = __webpack_require__(1424);
var Registry = __webpack_require__(3972);
function style(gd) {
  var s = d3.select(gd).selectAll('g.trace.scatter');
  s.style('opacity', function (d) {
    return d[0].trace.opacity;
  });
  s.selectAll('g.points').each(function (d) {
    var sel = d3.select(this);
    var trace = d.trace || d[0].trace;
    stylePoints(sel, trace, gd);
  });
  s.selectAll('g.text').each(function (d) {
    var sel = d3.select(this);
    var trace = d.trace || d[0].trace;
    styleText(sel, trace, gd);
  });
  s.selectAll('g.trace path.js-line').call(Drawing.lineGroupStyle);
  s.selectAll('g.trace path.js-fill').call(Drawing.fillGroupStyle, gd);
  Registry.getComponentMethod('errorbars', 'style')(s);
}
function stylePoints(sel, trace, gd) {
  Drawing.pointStyle(sel.selectAll('path.point'), trace, gd);
}
function styleText(sel, trace, gd) {
  Drawing.textPointStyle(sel.selectAll('text'), trace, gd);
}
function styleOnSelect(gd, cd, sel) {
  var trace = cd[0].trace;
  if (trace.selectedpoints) {
    Drawing.selectedPointStyle(sel.selectAll('path.point'), trace);
    Drawing.selectedTextStyle(sel.selectAll('text'), trace);
  } else {
    stylePoints(sel, trace, gd);
    styleText(sel, trace, gd);
  }
}
module.exports = {
  style: style,
  stylePoints: stylePoints,
  styleText: styleText,
  styleOnSelect: styleOnSelect
};

/***/ }),

/***/ 4098:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
module.exports = {
  hasLines: function (trace) {
    return trace.visible && trace.mode && trace.mode.indexOf('lines') !== -1;
  },
  hasMarkers: function (trace) {
    return trace.visible && (trace.mode && trace.mode.indexOf('markers') !== -1 ||
    // until splom implements 'mode'
    trace.type === 'splom');
  },
  hasText: function (trace) {
    return trace.visible && trace.mode && trace.mode.indexOf('text') !== -1;
  },
  isBubble: function (trace) {
    return Lib.isPlainObject(trace.marker) && Lib.isArrayOrTypedArray(trace.marker.size);
  }
};

/***/ }),

/***/ 2410:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);

/*
 * opts: object of flags to control features not all text users support
 *   noSelect: caller does not support selected/unselected attribute containers
 */
module.exports = function (traceIn, traceOut, layout, coerce, opts) {
  opts = opts || {};
  coerce('textposition');
  Lib.coerceFont(coerce, 'textfont', opts.font || layout.font);
  if (!opts.noSelect) {
    coerce('selected.textfont.color');
    coerce('unselected.textfont.color');
  }
};

/***/ }),

/***/ 7513:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Registry = __webpack_require__(3972);
module.exports = function handleXYDefaults(traceIn, traceOut, layout, coerce) {
  var x = coerce('x');
  var y = coerce('y');
  var len;
  var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleTraceDefaults');
  handleCalendarDefaults(traceIn, traceOut, ['x', 'y'], layout);
  if (x) {
    var xlen = Lib.minRowLength(x);
    if (y) {
      len = Math.min(xlen, Lib.minRowLength(y));
    } else {
      len = xlen;
      coerce('y0');
      coerce('dy');
    }
  } else {
    if (!y) return 0;
    len = Lib.minRowLength(y);
    coerce('x0');
    coerce('dx');
  }
  traceOut._length = len;
  return len;
};

/***/ }),

/***/ 4542:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var scatterAttrs = __webpack_require__(2196);
var colorAttributes = __webpack_require__(693);
var axisHoverFormat = (__webpack_require__(2663).axisHoverFormat);
var hovertemplateAttrs = (__webpack_require__(5386)/* .hovertemplateAttrs */ .fF);
var texttemplateAttrs = (__webpack_require__(5386)/* .texttemplateAttrs */ .si);
var baseAttrs = __webpack_require__(9012);
var DASHES = __webpack_require__(9659);
var MARKER_SYMBOLS = __webpack_require__(7381);
var extendFlat = (__webpack_require__(1426).extendFlat);
var overrideAll = (__webpack_require__(962).overrideAll);
var sortObjectKeys = __webpack_require__(8607);
var scatterLineAttrs = scatterAttrs.line;
var scatterMarkerAttrs = scatterAttrs.marker;
var scatterMarkerLineAttrs = scatterMarkerAttrs.line;
var lineAttrs = extendFlat({
  width: scatterLineAttrs.width,
  dash: {
    valType: 'enumerated',
    values: sortObjectKeys(DASHES),
    dflt: 'solid'
  }
}, colorAttributes('line'));
function makeProjectionAttr(axLetter) {
  return {
    show: {
      valType: 'boolean',
      dflt: false
    },
    opacity: {
      valType: 'number',
      min: 0,
      max: 1,
      dflt: 1
    },
    scale: {
      valType: 'number',
      min: 0,
      max: 10,
      dflt: 2 / 3
    }
  };
}
var attrs = module.exports = overrideAll({
  x: scatterAttrs.x,
  y: scatterAttrs.y,
  z: {
    valType: 'data_array'
  },
  text: extendFlat({}, scatterAttrs.text, {}),
  texttemplate: texttemplateAttrs({}, {}),
  hovertext: extendFlat({}, scatterAttrs.hovertext, {}),
  hovertemplate: hovertemplateAttrs(),
  xhoverformat: axisHoverFormat('x'),
  yhoverformat: axisHoverFormat('y'),
  zhoverformat: axisHoverFormat('z'),
  mode: extendFlat({}, scatterAttrs.mode,
  // shouldn't this be on-par with 2D?
  {
    dflt: 'lines+markers'
  }),
  surfaceaxis: {
    valType: 'enumerated',
    values: [-1, 0, 1, 2],
    dflt: -1
  },
  surfacecolor: {
    valType: 'color'
  },
  projection: {
    x: makeProjectionAttr('x'),
    y: makeProjectionAttr('y'),
    z: makeProjectionAttr('z')
  },
  connectgaps: scatterAttrs.connectgaps,
  line: lineAttrs,
  marker: extendFlat({
    // Parity with scatter.js?
    symbol: {
      valType: 'enumerated',
      values: sortObjectKeys(MARKER_SYMBOLS),
      dflt: 'circle',
      arrayOk: true
    },
    size: extendFlat({}, scatterMarkerAttrs.size, {
      dflt: 8
    }),
    sizeref: scatterMarkerAttrs.sizeref,
    sizemin: scatterMarkerAttrs.sizemin,
    sizemode: scatterMarkerAttrs.sizemode,
    opacity: extendFlat({}, scatterMarkerAttrs.opacity, {
      arrayOk: false
    }),
    colorbar: scatterMarkerAttrs.colorbar,
    line: extendFlat({
      width: extendFlat({}, scatterMarkerLineAttrs.width, {
        arrayOk: false
      })
    }, colorAttributes('marker.line'))
  }, colorAttributes('marker')),
  textposition: extendFlat({}, scatterAttrs.textposition, {
    dflt: 'top center'
  }),
  textfont: {
    color: scatterAttrs.textfont.color,
    size: scatterAttrs.textfont.size,
    family: extendFlat({}, scatterAttrs.textfont.family, {
      arrayOk: false
    })
  },
  opacity: baseAttrs.opacity,
  hoverinfo: extendFlat({}, baseAttrs.hoverinfo)
}, 'calc', 'nested');
attrs.x.editType = attrs.y.editType = attrs.z.editType = 'calc+clearAxisTypes';

/***/ }),

/***/ 6563:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var arraysToCalcdata = __webpack_require__(5225);
var calcColorscale = __webpack_require__(6922);

/**
 * This is a kludge to put the array attributes into
 * calcdata the way Scatter.plot does, so that legends and
 * popovers know what to do with them.
 */
module.exports = function calc(gd, trace) {
  var cd = [{
    x: false,
    y: false,
    trace: trace,
    t: {}
  }];
  arraysToCalcdata(cd, trace);
  calcColorscale(gd, trace);
  return cd;
};

/***/ }),

/***/ 7336:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);
function calculateAxisErrors(data, params, scaleFactor, axis) {
  if (!params || !params.visible) return null;
  var computeError = Registry.getComponentMethod('errorbars', 'makeComputeError')(params);
  var result = new Array(data.length);
  for (var i = 0; i < data.length; i++) {
    var errors = computeError(+data[i], i);
    if (axis.type === 'log') {
      var point = axis.c2l(data[i]);
      var min = data[i] - errors[0];
      var max = data[i] + errors[1];
      result[i] = [(axis.c2l(min, true) - point) * scaleFactor, (axis.c2l(max, true) - point) * scaleFactor];

      // Keep track of the lower error bound which isn't negative!
      if (min > 0) {
        var lower = axis.c2l(min);
        if (!axis._lowerLogErrorBound) axis._lowerLogErrorBound = lower;
        axis._lowerErrorBound = Math.min(axis._lowerLogErrorBound, lower);
      }
    } else {
      result[i] = [-errors[0] * scaleFactor, errors[1] * scaleFactor];
    }
  }
  return result;
}
function dataLength(array) {
  for (var i = 0; i < array.length; i++) {
    if (array[i]) return array[i].length;
  }
  return 0;
}
function calculateErrors(data, scaleFactor, sceneLayout) {
  var errors = [calculateAxisErrors(data.x, data.error_x, scaleFactor[0], sceneLayout.xaxis), calculateAxisErrors(data.y, data.error_y, scaleFactor[1], sceneLayout.yaxis), calculateAxisErrors(data.z, data.error_z, scaleFactor[2], sceneLayout.zaxis)];
  var n = dataLength(errors);
  if (n === 0) return null;
  var errorBounds = new Array(n);
  for (var i = 0; i < n; i++) {
    var bound = [[0, 0, 0], [0, 0, 0]];
    for (var j = 0; j < 3; j++) {
      if (errors[j]) {
        for (var k = 0; k < 2; k++) {
          bound[k][j] = errors[j][i][k];
        }
      }
    }
    errorBounds[i] = bound;
  }
  return errorBounds;
}
module.exports = calculateErrors;

/***/ }),

/***/ 8925:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var createLinePlot = (__webpack_require__(9330).gl_line3d);
var createScatterPlot = (__webpack_require__(9330).gl_scatter3d);
var createErrorBars = (__webpack_require__(9330).gl_error3d);
var createMesh = (__webpack_require__(9330).gl_mesh3d);
var triangulate = (__webpack_require__(9330).delaunay_triangulate);
var Lib = __webpack_require__(1828);
var str2RgbaArray = __webpack_require__(8614);
var formatColor = (__webpack_require__(1697).formatColor);
var makeBubbleSizeFn = __webpack_require__(9984);
var DASH_PATTERNS = __webpack_require__(9659);
var MARKER_SYMBOLS = __webpack_require__(7381);
var Axes = __webpack_require__(9298);
var appendArrayPointValue = (__webpack_require__(3469).appendArrayPointValue);
var calculateError = __webpack_require__(7336);
function LineWithMarkers(scene, uid) {
  this.scene = scene;
  this.uid = uid;
  this.linePlot = null;
  this.scatterPlot = null;
  this.errorBars = null;
  this.textMarkers = null;
  this.delaunayMesh = null;
  this.color = null;
  this.mode = '';
  this.dataPoints = [];
  this.axesBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];
  this.textLabels = null;
  this.data = null;
}
var proto = LineWithMarkers.prototype;
proto.handlePick = function (selection) {
  if (selection.object && (selection.object === this.linePlot || selection.object === this.delaunayMesh || selection.object === this.textMarkers || selection.object === this.scatterPlot)) {
    var ind = selection.index = selection.data.index;
    if (selection.object.highlight) {
      selection.object.highlight(null);
    }
    if (this.scatterPlot) {
      selection.object = this.scatterPlot;
      this.scatterPlot.highlight(selection.data);
    }
    selection.textLabel = '';
    if (this.textLabels) {
      if (Array.isArray(this.textLabels)) {
        if (this.textLabels[ind] || this.textLabels[ind] === 0) {
          selection.textLabel = this.textLabels[ind];
        }
      } else {
        selection.textLabel = this.textLabels;
      }
    }
    selection.traceCoordinate = [this.data.x[ind], this.data.y[ind], this.data.z[ind]];
    return true;
  }
};
function constructDelaunay(points, color, axis) {
  var u = (axis + 1) % 3;
  var v = (axis + 2) % 3;
  var filteredPoints = [];
  var filteredIds = [];
  var i;
  for (i = 0; i < points.length; ++i) {
    var p = points[i];
    if (isNaN(p[u]) || !isFinite(p[u]) || isNaN(p[v]) || !isFinite(p[v])) {
      continue;
    }
    filteredPoints.push([p[u], p[v]]);
    filteredIds.push(i);
  }
  var cells = triangulate(filteredPoints);
  for (i = 0; i < cells.length; ++i) {
    var c = cells[i];
    for (var j = 0; j < c.length; ++j) {
      c[j] = filteredIds[c[j]];
    }
  }
  return {
    positions: points,
    cells: cells,
    meshColor: color
  };
}
function calculateErrorParams(errors) {
  var capSize = [0.0, 0.0, 0.0];
  var color = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
  var lineWidth = [1.0, 1.0, 1.0];
  for (var i = 0; i < 3; i++) {
    var e = errors[i];
    if (e && e.copy_zstyle !== false && errors[2].visible !== false) e = errors[2];
    if (!e || !e.visible) continue;
    capSize[i] = e.width / 2; // ballpark rescaling
    color[i] = str2RgbaArray(e.color);
    lineWidth[i] = e.thickness;
  }
  return {
    capSize: capSize,
    color: color,
    lineWidth: lineWidth
  };
}
function parseAlignmentX(a) {
  if (a === null || a === undefined) return 0;
  return a.indexOf('left') > -1 ? -1 : a.indexOf('right') > -1 ? 1 : 0;
}
function parseAlignmentY(a) {
  if (a === null || a === undefined) return 0;
  return a.indexOf('top') > -1 ? -1 : a.indexOf('bottom') > -1 ? 1 : 0;
}
function calculateTextOffset(tp) {
  // Read out text properties

  var defaultAlignmentX = 0;
  var defaultAlignmentY = 0;
  var textOffset = [defaultAlignmentX, defaultAlignmentY];
  if (Array.isArray(tp)) {
    for (var i = 0; i < tp.length; i++) {
      textOffset[i] = [defaultAlignmentX, defaultAlignmentY];
      if (tp[i]) {
        textOffset[i][0] = parseAlignmentX(tp[i]);
        textOffset[i][1] = parseAlignmentY(tp[i]);
      }
    }
  } else {
    textOffset[0] = parseAlignmentX(tp);
    textOffset[1] = parseAlignmentY(tp);
  }
  return textOffset;
}
function calculateSize(sizeIn, sizeFn) {
  // rough parity with Plotly 2D markers
  return sizeFn(sizeIn * 4);
}
function calculateSymbol(symbolIn) {
  return MARKER_SYMBOLS[symbolIn];
}
function formatParam(paramIn, len, calculate, dflt, extraFn) {
  var paramOut = null;
  if (Lib.isArrayOrTypedArray(paramIn)) {
    paramOut = [];
    for (var i = 0; i < len; i++) {
      if (paramIn[i] === undefined) paramOut[i] = dflt;else paramOut[i] = calculate(paramIn[i], extraFn);
    }
  } else paramOut = calculate(paramIn, Lib.identity);
  return paramOut;
}
function convertPlotlyOptions(scene, data) {
  var points = [];
  var sceneLayout = scene.fullSceneLayout;
  var scaleFactor = scene.dataScale;
  var xaxis = sceneLayout.xaxis;
  var yaxis = sceneLayout.yaxis;
  var zaxis = sceneLayout.zaxis;
  var marker = data.marker;
  var line = data.line;
  var x = data.x || [];
  var y = data.y || [];
  var z = data.z || [];
  var len = x.length;
  var xcalendar = data.xcalendar;
  var ycalendar = data.ycalendar;
  var zcalendar = data.zcalendar;
  var xc, yc, zc;
  var params, i;
  var text;

  // Convert points
  for (i = 0; i < len; i++) {
    // sanitize numbers and apply transforms based on axes.type
    xc = xaxis.d2l(x[i], 0, xcalendar) * scaleFactor[0];
    yc = yaxis.d2l(y[i], 0, ycalendar) * scaleFactor[1];
    zc = zaxis.d2l(z[i], 0, zcalendar) * scaleFactor[2];
    points[i] = [xc, yc, zc];
  }

  // convert text
  if (Array.isArray(data.text)) text = data.text;else if (data.text !== undefined) {
    text = new Array(len);
    for (i = 0; i < len; i++) text[i] = data.text;
  }
  function formatter(axName, val) {
    var ax = sceneLayout[axName];
    return Axes.tickText(ax, ax.d2l(val), true).text;
  }

  // check texttemplate
  var texttemplate = data.texttemplate;
  if (texttemplate) {
    var fullLayout = scene.fullLayout;
    var d3locale = fullLayout._d3locale;
    var isArray = Array.isArray(texttemplate);
    var N = isArray ? Math.min(texttemplate.length, len) : len;
    var txt = isArray ? function (i) {
      return texttemplate[i];
    } : function () {
      return texttemplate;
    };
    text = new Array(N);
    for (i = 0; i < N; i++) {
      var d = {
        x: x[i],
        y: y[i],
        z: z[i]
      };
      var labels = {
        xLabel: formatter('xaxis', x[i]),
        yLabel: formatter('yaxis', y[i]),
        zLabel: formatter('zaxis', z[i])
      };
      var pointValues = {};
      appendArrayPointValue(pointValues, data, i);
      var meta = data._meta || {};
      text[i] = Lib.texttemplateString(txt(i), labels, d3locale, pointValues, d, meta);
    }
  }

  // Build object parameters
  params = {
    position: points,
    mode: data.mode,
    text: text
  };
  if ('line' in data) {
    params.lineColor = formatColor(line, 1, len);
    params.lineWidth = line.width;
    params.lineDashes = line.dash;
  }
  if ('marker' in data) {
    var sizeFn = makeBubbleSizeFn(data);
    params.scatterColor = formatColor(marker, 1, len);
    params.scatterSize = formatParam(marker.size, len, calculateSize, 20, sizeFn);
    params.scatterMarker = formatParam(marker.symbol, len, calculateSymbol, '●');
    params.scatterLineWidth = marker.line.width; // arrayOk === false
    params.scatterLineColor = formatColor(marker.line, 1, len);
    params.scatterAngle = 0;
  }
  if ('textposition' in data) {
    params.textOffset = calculateTextOffset(data.textposition);
    params.textColor = formatColor(data.textfont, 1, len);
    params.textSize = formatParam(data.textfont.size, len, Lib.identity, 12);
    params.textFont = data.textfont.family; // arrayOk === false
    params.textAngle = 0;
  }
  var dims = ['x', 'y', 'z'];
  params.project = [false, false, false];
  params.projectScale = [1, 1, 1];
  params.projectOpacity = [1, 1, 1];
  for (i = 0; i < 3; ++i) {
    var projection = data.projection[dims[i]];
    if (params.project[i] = projection.show) {
      params.projectOpacity[i] = projection.opacity;
      params.projectScale[i] = projection.scale;
    }
  }
  params.errorBounds = calculateError(data, scaleFactor, sceneLayout);
  var errorParams = calculateErrorParams([data.error_x, data.error_y, data.error_z]);
  params.errorColor = errorParams.color;
  params.errorLineWidth = errorParams.lineWidth;
  params.errorCapSize = errorParams.capSize;
  params.delaunayAxis = data.surfaceaxis;
  params.delaunayColor = str2RgbaArray(data.surfacecolor);
  return params;
}
function _arrayToColor(color) {
  if (Lib.isArrayOrTypedArray(color)) {
    var c = color[0];
    if (Lib.isArrayOrTypedArray(c)) color = c;
    return 'rgb(' + color.slice(0, 3).map(function (x) {
      return Math.round(x * 255);
    }) + ')';
  }
  return null;
}
function arrayToColor(colors) {
  if (!Lib.isArrayOrTypedArray(colors)) {
    return null;
  }
  if (colors.length === 4 && typeof colors[0] === 'number') {
    return _arrayToColor(colors);
  }
  return colors.map(_arrayToColor);
}
proto.update = function (data) {
  var gl = this.scene.glplot.gl;
  var lineOptions;
  var scatterOptions;
  var errorOptions;
  var textOptions;
  var dashPattern = DASH_PATTERNS.solid;

  // Save data
  this.data = data;

  // Run data conversion
  var options = convertPlotlyOptions(this.scene, data);
  if ('mode' in options) {
    this.mode = options.mode;
  }
  if ('lineDashes' in options) {
    if (options.lineDashes in DASH_PATTERNS) {
      dashPattern = DASH_PATTERNS[options.lineDashes];
    }
  }
  this.color = arrayToColor(options.scatterColor) || arrayToColor(options.lineColor);

  // Save data points
  this.dataPoints = options.position;
  lineOptions = {
    gl: this.scene.glplot.gl,
    position: options.position,
    color: options.lineColor,
    lineWidth: options.lineWidth || 1,
    dashes: dashPattern[0],
    dashScale: dashPattern[1],
    opacity: data.opacity,
    connectGaps: data.connectgaps
  };
  if (this.mode.indexOf('lines') !== -1) {
    if (this.linePlot) this.linePlot.update(lineOptions);else {
      this.linePlot = createLinePlot(lineOptions);
      this.linePlot._trace = this;
      this.scene.glplot.add(this.linePlot);
    }
  } else if (this.linePlot) {
    this.scene.glplot.remove(this.linePlot);
    this.linePlot.dispose();
    this.linePlot = null;
  }

  // N.B. marker.opacity must be a scalar for performance
  var scatterOpacity = data.opacity;
  if (data.marker && data.marker.opacity !== undefined) scatterOpacity *= data.marker.opacity;
  scatterOptions = {
    gl: this.scene.glplot.gl,
    position: options.position,
    color: options.scatterColor,
    size: options.scatterSize,
    glyph: options.scatterMarker,
    opacity: scatterOpacity,
    orthographic: true,
    lineWidth: options.scatterLineWidth,
    lineColor: options.scatterLineColor,
    project: options.project,
    projectScale: options.projectScale,
    projectOpacity: options.projectOpacity
  };
  if (this.mode.indexOf('markers') !== -1) {
    if (this.scatterPlot) this.scatterPlot.update(scatterOptions);else {
      this.scatterPlot = createScatterPlot(scatterOptions);
      this.scatterPlot._trace = this;
      this.scatterPlot.highlightScale = 1;
      this.scene.glplot.add(this.scatterPlot);
    }
  } else if (this.scatterPlot) {
    this.scene.glplot.remove(this.scatterPlot);
    this.scatterPlot.dispose();
    this.scatterPlot = null;
  }
  textOptions = {
    gl: this.scene.glplot.gl,
    position: options.position,
    glyph: options.text,
    color: options.textColor,
    size: options.textSize,
    angle: options.textAngle,
    alignment: options.textOffset,
    font: options.textFont,
    orthographic: true,
    lineWidth: 0,
    project: false,
    opacity: data.opacity
  };
  this.textLabels = data.hovertext || data.text;
  if (this.mode.indexOf('text') !== -1) {
    if (this.textMarkers) this.textMarkers.update(textOptions);else {
      this.textMarkers = createScatterPlot(textOptions);
      this.textMarkers._trace = this;
      this.textMarkers.highlightScale = 1;
      this.scene.glplot.add(this.textMarkers);
    }
  } else if (this.textMarkers) {
    this.scene.glplot.remove(this.textMarkers);
    this.textMarkers.dispose();
    this.textMarkers = null;
  }
  errorOptions = {
    gl: this.scene.glplot.gl,
    position: options.position,
    color: options.errorColor,
    error: options.errorBounds,
    lineWidth: options.errorLineWidth,
    capSize: options.errorCapSize,
    opacity: data.opacity
  };
  if (this.errorBars) {
    if (options.errorBounds) {
      this.errorBars.update(errorOptions);
    } else {
      this.scene.glplot.remove(this.errorBars);
      this.errorBars.dispose();
      this.errorBars = null;
    }
  } else if (options.errorBounds) {
    this.errorBars = createErrorBars(errorOptions);
    this.errorBars._trace = this;
    this.scene.glplot.add(this.errorBars);
  }
  if (options.delaunayAxis >= 0) {
    var delaunayOptions = constructDelaunay(options.position, options.delaunayColor, options.delaunayAxis);
    delaunayOptions.opacity = data.opacity;
    if (this.delaunayMesh) {
      this.delaunayMesh.update(delaunayOptions);
    } else {
      delaunayOptions.gl = gl;
      this.delaunayMesh = createMesh(delaunayOptions);
      this.delaunayMesh._trace = this;
      this.scene.glplot.add(this.delaunayMesh);
    }
  } else if (this.delaunayMesh) {
    this.scene.glplot.remove(this.delaunayMesh);
    this.delaunayMesh.dispose();
    this.delaunayMesh = null;
  }
};
proto.dispose = function () {
  if (this.linePlot) {
    this.scene.glplot.remove(this.linePlot);
    this.linePlot.dispose();
  }
  if (this.scatterPlot) {
    this.scene.glplot.remove(this.scatterPlot);
    this.scatterPlot.dispose();
  }
  if (this.errorBars) {
    this.scene.glplot.remove(this.errorBars);
    this.errorBars.dispose();
  }
  if (this.textMarkers) {
    this.scene.glplot.remove(this.textMarkers);
    this.textMarkers.dispose();
  }
  if (this.delaunayMesh) {
    this.scene.glplot.remove(this.delaunayMesh);
    this.delaunayMesh.dispose();
  }
};
function createLineWithMarkers(scene, data) {
  var plot = new LineWithMarkers(scene, data.uid);
  plot.update(data);
  return plot;
}
module.exports = createLineWithMarkers;

/***/ }),

/***/ 1428:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var subTypes = __webpack_require__(4098);
var handleMarkerDefaults = __webpack_require__(9508);
var handleLineDefaults = __webpack_require__(1058);
var handleTextDefaults = __webpack_require__(2410);
var attributes = __webpack_require__(4542);
module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
  function coerce(attr, dflt) {
    return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
  }
  var len = handleXYZDefaults(traceIn, traceOut, coerce, layout);
  if (!len) {
    traceOut.visible = false;
    return;
  }
  coerce('text');
  coerce('hovertext');
  coerce('hovertemplate');
  coerce('xhoverformat');
  coerce('yhoverformat');
  coerce('zhoverformat');
  coerce('mode');
  if (subTypes.hasLines(traceOut)) {
    coerce('connectgaps');
    handleLineDefaults(traceIn, traceOut, defaultColor, layout, coerce);
  }
  if (subTypes.hasMarkers(traceOut)) {
    handleMarkerDefaults(traceIn, traceOut, defaultColor, layout, coerce, {
      noSelect: true,
      noAngle: true
    });
  }
  if (subTypes.hasText(traceOut)) {
    coerce('texttemplate');
    handleTextDefaults(traceIn, traceOut, layout, coerce, {
      noSelect: true
    });
  }
  var lineColor = (traceOut.line || {}).color;
  var markerColor = (traceOut.marker || {}).color;
  if (coerce('surfaceaxis') >= 0) coerce('surfacecolor', lineColor || markerColor);
  var dims = ['x', 'y', 'z'];
  for (var i = 0; i < 3; ++i) {
    var projection = 'projection.' + dims[i];
    if (coerce(projection + '.show')) {
      coerce(projection + '.opacity');
      coerce(projection + '.scale');
    }
  }
  var errorBarsSupplyDefaults = Registry.getComponentMethod('errorbars', 'supplyDefaults');
  errorBarsSupplyDefaults(traceIn, traceOut, lineColor || markerColor || defaultColor, {
    axis: 'z'
  });
  errorBarsSupplyDefaults(traceIn, traceOut, lineColor || markerColor || defaultColor, {
    axis: 'y',
    inherit: 'z'
  });
  errorBarsSupplyDefaults(traceIn, traceOut, lineColor || markerColor || defaultColor, {
    axis: 'x',
    inherit: 'z'
  });
};
function handleXYZDefaults(traceIn, traceOut, coerce, layout) {
  var len = 0;
  var x = coerce('x');
  var y = coerce('y');
  var z = coerce('z');
  var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleTraceDefaults');
  handleCalendarDefaults(traceIn, traceOut, ['x', 'y', 'z'], layout);
  if (x && y && z) {
    // TODO: what happens if one is missing?
    len = Math.min(x.length, y.length, z.length);
    traceOut._length = traceOut._xlength = traceOut._ylength = traceOut._zlength = len;
  }
  return len;
}

/***/ }),

/***/ 3551:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  plot: __webpack_require__(8925),
  attributes: __webpack_require__(4542),
  markerSymbols: __webpack_require__(7381),
  supplyDefaults: __webpack_require__(1428),
  colorbar: [{
    container: 'marker',
    min: 'cmin',
    max: 'cmax'
  }, {
    container: 'line',
    min: 'cmin',
    max: 'cmax'
  }],
  calc: __webpack_require__(6563),
  moduleType: 'trace',
  name: 'scatter3d',
  basePlotModule: __webpack_require__(8547),
  categories: ['gl3d', 'symbols', 'showLegend', 'scatter-like'],
  meta: {}
};

/***/ }),

/***/ 1850:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var colorScaleAttrs = __webpack_require__(693);
var axisHoverFormat = (__webpack_require__(2663).axisHoverFormat);
var hovertemplateAttrs = (__webpack_require__(5386)/* .hovertemplateAttrs */ .fF);
var mesh3dAttrs = __webpack_require__(2418);
var baseAttrs = __webpack_require__(9012);
var extendFlat = (__webpack_require__(1426).extendFlat);
var attrs = {
  x: {
    valType: 'data_array',
    editType: 'calc+clearAxisTypes'
  },
  y: {
    valType: 'data_array',
    editType: 'calc+clearAxisTypes'
  },
  z: {
    valType: 'data_array',
    editType: 'calc+clearAxisTypes'
  },
  u: {
    valType: 'data_array',
    editType: 'calc'
  },
  v: {
    valType: 'data_array',
    editType: 'calc'
  },
  w: {
    valType: 'data_array',
    editType: 'calc'
  },
  starts: {
    x: {
      valType: 'data_array',
      editType: 'calc'
    },
    y: {
      valType: 'data_array',
      editType: 'calc'
    },
    z: {
      valType: 'data_array',
      editType: 'calc'
    },
    editType: 'calc'
  },
  maxdisplayed: {
    valType: 'integer',
    min: 0,
    dflt: 1000,
    editType: 'calc'
  },
  // TODO
  //
  // Should add 'absolute' (like cone traces have), but currently gl-streamtube3d's
  // `absoluteTubeSize` doesn't behave well enough for our needs.
  //
  // 'fixed' would be a nice addition to plot stream 'lines', see
  // https://github.com/plotly/plotly.js/commit/812be20750e21e0a1831975001c248d365850f73#r29129877
  //
  // sizemode: {
  //     valType: 'enumerated',
  //     values: ['scaled', 'absolute', 'fixed'],
  //     dflt: 'scaled',
  //     editType: 'calc',
  //
  // },

  sizeref: {
    valType: 'number',
    editType: 'calc',
    min: 0,
    dflt: 1
  },
  text: {
    valType: 'string',
    dflt: '',
    editType: 'calc'
  },
  hovertext: {
    valType: 'string',
    dflt: '',
    editType: 'calc'
  },
  hovertemplate: hovertemplateAttrs({
    editType: 'calc'
  }, {
    keys: ['tubex', 'tubey', 'tubez', 'tubeu', 'tubev', 'tubew', 'norm', 'divergence']
  }),
  uhoverformat: axisHoverFormat('u', 1),
  vhoverformat: axisHoverFormat('v', 1),
  whoverformat: axisHoverFormat('w', 1),
  xhoverformat: axisHoverFormat('x'),
  yhoverformat: axisHoverFormat('y'),
  zhoverformat: axisHoverFormat('z'),
  showlegend: extendFlat({}, baseAttrs.showlegend, {
    dflt: false
  })
};
extendFlat(attrs, colorScaleAttrs('', {
  colorAttr: 'u/v/w norm',
  showScaleDflt: true,
  editTypeOverride: 'calc'
}));
var fromMesh3d = ['opacity', 'lightposition', 'lighting'];
fromMesh3d.forEach(function (k) {
  attrs[k] = mesh3dAttrs[k];
});
attrs.hoverinfo = extendFlat({}, baseAttrs.hoverinfo, {
  editType: 'calc',
  flags: ['x', 'y', 'z', 'u', 'v', 'w', 'norm', 'divergence', 'text', 'name'],
  dflt: 'x+y+z+norm+text+name'
});
attrs.transforms = undefined;
module.exports = attrs;

/***/ }),

/***/ 8489:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var colorscaleCalc = __webpack_require__(8803);
function calc(gd, trace) {
  trace._len = Math.min(trace.u.length, trace.v.length, trace.w.length, trace.x.length, trace.y.length, trace.z.length);
  trace._u = filter(trace.u, trace._len);
  trace._v = filter(trace.v, trace._len);
  trace._w = filter(trace.w, trace._len);
  trace._x = filter(trace.x, trace._len);
  trace._y = filter(trace.y, trace._len);
  trace._z = filter(trace.z, trace._len);
  var grid = processGrid(trace);
  trace._gridFill = grid.fill;
  trace._Xs = grid.Xs;
  trace._Ys = grid.Ys;
  trace._Zs = grid.Zs;
  trace._len = grid.len;
  var slen = 0;
  var startx, starty, startz;
  if (trace.starts) {
    startx = filter(trace.starts.x || []);
    starty = filter(trace.starts.y || []);
    startz = filter(trace.starts.z || []);
    slen = Math.min(startx.length, starty.length, startz.length);
  }
  trace._startsX = startx || [];
  trace._startsY = starty || [];
  trace._startsZ = startz || [];
  var normMax = 0;
  var normMin = Infinity;
  var i;
  for (i = 0; i < trace._len; i++) {
    var u = trace._u[i];
    var v = trace._v[i];
    var w = trace._w[i];
    var norm = Math.sqrt(u * u + v * v + w * w);
    normMax = Math.max(normMax, norm);
    normMin = Math.min(normMin, norm);
  }
  colorscaleCalc(gd, trace, {
    vals: [normMin, normMax],
    containerStr: '',
    cLetter: 'c'
  });
  for (i = 0; i < slen; i++) {
    var sx = startx[i];
    grid.xMax = Math.max(grid.xMax, sx);
    grid.xMin = Math.min(grid.xMin, sx);
    var sy = starty[i];
    grid.yMax = Math.max(grid.yMax, sy);
    grid.yMin = Math.min(grid.yMin, sy);
    var sz = startz[i];
    grid.zMax = Math.max(grid.zMax, sz);
    grid.zMin = Math.min(grid.zMin, sz);
  }
  trace._slen = slen;
  trace._normMax = normMax;
  trace._xbnds = [grid.xMin, grid.xMax];
  trace._ybnds = [grid.yMin, grid.yMax];
  trace._zbnds = [grid.zMin, grid.zMax];
}
function processGrid(trace) {
  var x = trace._x;
  var y = trace._y;
  var z = trace._z;
  var len = trace._len;
  var i, j, k;
  var xMax = -Infinity;
  var xMin = Infinity;
  var yMax = -Infinity;
  var yMin = Infinity;
  var zMax = -Infinity;
  var zMin = Infinity;
  var gridFill = '';
  var filledX;
  var filledY;
  var filledZ;
  var firstX, lastX;
  var firstY, lastY;
  var firstZ, lastZ;
  if (len) {
    firstX = x[0];
    firstY = y[0];
    firstZ = z[0];
  }
  if (len > 1) {
    lastX = x[len - 1];
    lastY = y[len - 1];
    lastZ = z[len - 1];
  }
  for (i = 0; i < len; i++) {
    xMax = Math.max(xMax, x[i]);
    xMin = Math.min(xMin, x[i]);
    yMax = Math.max(yMax, y[i]);
    yMin = Math.min(yMin, y[i]);
    zMax = Math.max(zMax, z[i]);
    zMin = Math.min(zMin, z[i]);
    if (!filledX && x[i] !== firstX) {
      filledX = true;
      gridFill += 'x';
    }
    if (!filledY && y[i] !== firstY) {
      filledY = true;
      gridFill += 'y';
    }
    if (!filledZ && z[i] !== firstZ) {
      filledZ = true;
      gridFill += 'z';
    }
  }
  // fill if not filled - case of having dimension(s) with one item
  if (!filledX) gridFill += 'x';
  if (!filledY) gridFill += 'y';
  if (!filledZ) gridFill += 'z';
  var Xs = distinctVals(trace._x);
  var Ys = distinctVals(trace._y);
  var Zs = distinctVals(trace._z);
  gridFill = gridFill.replace('x', (firstX > lastX ? '-' : '+') + 'x');
  gridFill = gridFill.replace('y', (firstY > lastY ? '-' : '+') + 'y');
  gridFill = gridFill.replace('z', (firstZ > lastZ ? '-' : '+') + 'z');
  var empty = function () {
    len = 0;
    Xs = [];
    Ys = [];
    Zs = [];
  };

  // Over-specified mesh case, this would error in tube2mesh
  if (!len || len < Xs.length * Ys.length * Zs.length) empty();
  var getArray = function (c) {
    return c === 'x' ? x : c === 'y' ? y : z;
  };
  var getVals = function (c) {
    return c === 'x' ? Xs : c === 'y' ? Ys : Zs;
  };
  var getDir = function (c) {
    return c[len - 1] < c[0] ? -1 : 1;
  };
  var arrK = getArray(gridFill[1]);
  var arrJ = getArray(gridFill[3]);
  var arrI = getArray(gridFill[5]);
  var nk = getVals(gridFill[1]).length;
  var nj = getVals(gridFill[3]).length;
  var ni = getVals(gridFill[5]).length;
  var arbitrary = false;
  var getIndex = function (_i, _j, _k) {
    return nk * (nj * _i + _j) + _k;
  };
  var dirK = getDir(getArray(gridFill[1]));
  var dirJ = getDir(getArray(gridFill[3]));
  var dirI = getDir(getArray(gridFill[5]));
  for (i = 0; i < ni - 1; i++) {
    for (j = 0; j < nj - 1; j++) {
      for (k = 0; k < nk - 1; k++) {
        var q000 = getIndex(i, j, k);
        var q001 = getIndex(i, j, k + 1);
        var q010 = getIndex(i, j + 1, k);
        var q100 = getIndex(i + 1, j, k);
        if (!(arrK[q000] * dirK < arrK[q001] * dirK) || !(arrJ[q000] * dirJ < arrJ[q010] * dirJ) || !(arrI[q000] * dirI < arrI[q100] * dirI)) {
          arbitrary = true;
        }
        if (arbitrary) break;
      }
      if (arbitrary) break;
    }
    if (arbitrary) break;
  }
  if (arbitrary) {
    Lib.warn('Encountered arbitrary coordinates! Unable to input data grid.');
    empty();
  }
  return {
    xMin: xMin,
    yMin: yMin,
    zMin: zMin,
    xMax: xMax,
    yMax: yMax,
    zMax: zMax,
    Xs: Xs,
    Ys: Ys,
    Zs: Zs,
    len: len,
    fill: gridFill
  };
}
function distinctVals(col) {
  return Lib.distinctVals(col).vals;
}
function filter(arr, len) {
  if (len === undefined) len = arr.length;

  // no need for casting typed arrays to numbers
  if (Lib.isTypedArray(arr)) return arr.subarray(0, len);
  var values = [];
  for (var i = 0; i < len; i++) {
    values[i] = +arr[i];
  }
  return values;
}
module.exports = {
  calc: calc,
  filter: filter,
  processGrid: processGrid
};

/***/ }),

/***/ 154:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var tube2mesh = (__webpack_require__(9330).gl_streamtube3d);
var createTubeMesh = tube2mesh.createTubeMesh;
var Lib = __webpack_require__(1828);
var parseColorScale = (__webpack_require__(1697).parseColorScale);
var extractOpts = (__webpack_require__(1081).extractOpts);
var zip3 = __webpack_require__(60);
var axisName2scaleIndex = {
  xaxis: 0,
  yaxis: 1,
  zaxis: 2
};
function Streamtube(scene, uid) {
  this.scene = scene;
  this.uid = uid;
  this.mesh = null;
  this.data = null;
}
var proto = Streamtube.prototype;
proto.handlePick = function (selection) {
  var sceneLayout = this.scene.fullSceneLayout;
  var dataScale = this.scene.dataScale;
  function fromDataScale(v, axisName) {
    var ax = sceneLayout[axisName];
    var scale = dataScale[axisName2scaleIndex[axisName]];
    return ax.l2c(v) / scale;
  }
  if (selection.object === this.mesh) {
    var pos = selection.data.position;
    var uvx = selection.data.velocity;
    selection.traceCoordinate = [fromDataScale(pos[0], 'xaxis'), fromDataScale(pos[1], 'yaxis'), fromDataScale(pos[2], 'zaxis'), fromDataScale(uvx[0], 'xaxis'), fromDataScale(uvx[1], 'yaxis'), fromDataScale(uvx[2], 'zaxis'),
    // u/v/w norm
    selection.data.intensity * this.data._normMax,
    // divergence
    selection.data.divergence];
    selection.textLabel = this.data.hovertext || this.data.text;
    return true;
  }
};
function getDfltStartingPositions(vec) {
  var len = vec.length;
  var s;
  if (len > 2) {
    s = vec.slice(1, len - 1);
  } else if (len === 2) {
    s = [(vec[0] + vec[1]) / 2];
  } else {
    s = vec;
  }
  return s;
}
function getBoundPads(vec) {
  var len = vec.length;
  if (len === 1) {
    return [0.5, 0.5];
  } else {
    return [vec[1] - vec[0], vec[len - 1] - vec[len - 2]];
  }
}
function convert(scene, trace) {
  var sceneLayout = scene.fullSceneLayout;
  var dataScale = scene.dataScale;
  var len = trace._len;
  var tubeOpts = {};
  function toDataCoords(arr, axisName) {
    var ax = sceneLayout[axisName];
    var scale = dataScale[axisName2scaleIndex[axisName]];
    return Lib.simpleMap(arr, function (v) {
      return ax.d2l(v) * scale;
    });
  }
  tubeOpts.vectors = zip3(toDataCoords(trace._u, 'xaxis'), toDataCoords(trace._v, 'yaxis'), toDataCoords(trace._w, 'zaxis'), len);

  // Over-specified mesh case, this would error in tube2mesh
  if (!len) {
    return {
      positions: [],
      cells: []
    };
  }
  var meshx = toDataCoords(trace._Xs, 'xaxis');
  var meshy = toDataCoords(trace._Ys, 'yaxis');
  var meshz = toDataCoords(trace._Zs, 'zaxis');
  tubeOpts.meshgrid = [meshx, meshy, meshz];
  tubeOpts.gridFill = trace._gridFill;
  var slen = trace._slen;
  if (slen) {
    tubeOpts.startingPositions = zip3(toDataCoords(trace._startsX, 'xaxis'), toDataCoords(trace._startsY, 'yaxis'), toDataCoords(trace._startsZ, 'zaxis'));
  } else {
    // Default starting positions:
    //
    // if len>2, cut xz plane at min-y,
    // takes all x/y/z pts on that plane except those on the edges
    // to generate "well-defined" tubes,
    //
    // if len=2, take position halfway between two the pts,
    //
    // if len=1, take that pt
    var sy0 = meshy[0];
    var sx = getDfltStartingPositions(meshx);
    var sz = getDfltStartingPositions(meshz);
    var startingPositions = new Array(sx.length * sz.length);
    var m = 0;
    for (var i = 0; i < sx.length; i++) {
      for (var k = 0; k < sz.length; k++) {
        startingPositions[m++] = [sx[i], sy0, sz[k]];
      }
    }
    tubeOpts.startingPositions = startingPositions;
  }
  tubeOpts.colormap = parseColorScale(trace);
  tubeOpts.tubeSize = trace.sizeref;
  tubeOpts.maxLength = trace.maxdisplayed;

  // add some padding around the bounds
  // to e.g. allow tubes starting from a slice of the x/y/z mesh
  // to go beyond bounds a little bit w/o getting clipped
  var xbnds = toDataCoords(trace._xbnds, 'xaxis');
  var ybnds = toDataCoords(trace._ybnds, 'yaxis');
  var zbnds = toDataCoords(trace._zbnds, 'zaxis');
  var xpads = getBoundPads(meshx);
  var ypads = getBoundPads(meshy);
  var zpads = getBoundPads(meshz);
  var bounds = [[xbnds[0] - xpads[0], ybnds[0] - ypads[0], zbnds[0] - zpads[0]], [xbnds[1] + xpads[1], ybnds[1] + ypads[1], zbnds[1] + zpads[1]]];
  var meshData = tube2mesh(tubeOpts, bounds);

  // N.B. cmin/cmax correspond to the min/max vector norm
  // in the u/v/w arrays, which in general is NOT equal to max
  // intensity that colors the tubes.
  var cOpts = extractOpts(trace);
  meshData.vertexIntensityBounds = [cOpts.min / trace._normMax, cOpts.max / trace._normMax];

  // pass gl-mesh3d lighting attributes
  var lp = trace.lightposition;
  meshData.lightPosition = [lp.x, lp.y, lp.z];
  meshData.ambient = trace.lighting.ambient;
  meshData.diffuse = trace.lighting.diffuse;
  meshData.specular = trace.lighting.specular;
  meshData.roughness = trace.lighting.roughness;
  meshData.fresnel = trace.lighting.fresnel;
  meshData.opacity = trace.opacity;

  // stash autorange pad value
  trace._pad = meshData.tubeScale * trace.sizeref * 2;
  return meshData;
}
proto.update = function (data) {
  this.data = data;
  var meshData = convert(this.scene, data);
  this.mesh.update(meshData);
};
proto.dispose = function () {
  this.scene.glplot.remove(this.mesh);
  this.mesh.dispose();
};
function createStreamtubeTrace(scene, data) {
  var gl = scene.glplot.gl;
  var meshData = convert(scene, data);
  var mesh = createTubeMesh(gl, meshData);
  var streamtube = new Streamtube(scene, data.uid);
  streamtube.mesh = mesh;
  streamtube.data = data;
  mesh._trace = streamtube;
  scene.glplot.add(mesh);
  return streamtube;
}
module.exports = createStreamtubeTrace;

/***/ }),

/***/ 2459:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var colorscaleDefaults = __webpack_require__(1586);
var attributes = __webpack_require__(1850);
module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
  function coerce(attr, dflt) {
    return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
  }
  var u = coerce('u');
  var v = coerce('v');
  var w = coerce('w');
  var x = coerce('x');
  var y = coerce('y');
  var z = coerce('z');
  if (!u || !u.length || !v || !v.length || !w || !w.length || !x || !x.length || !y || !y.length || !z || !z.length) {
    traceOut.visible = false;
    return;
  }
  coerce('starts.x');
  coerce('starts.y');
  coerce('starts.z');
  coerce('maxdisplayed');
  coerce('sizeref');
  coerce('lighting.ambient');
  coerce('lighting.diffuse');
  coerce('lighting.specular');
  coerce('lighting.roughness');
  coerce('lighting.fresnel');
  coerce('lightposition.x');
  coerce('lightposition.y');
  coerce('lightposition.z');
  colorscaleDefaults(traceIn, traceOut, layout, coerce, {
    prefix: '',
    cLetter: 'c'
  });
  coerce('text');
  coerce('hovertext');
  coerce('hovertemplate');
  coerce('uhoverformat');
  coerce('vhoverformat');
  coerce('whoverformat');
  coerce('xhoverformat');
  coerce('yhoverformat');
  coerce('zhoverformat');

  // disable 1D transforms (for now)
  // x/y/z and u/v/w have matching lengths,
  // but they don't have to match with starts.(x|y|z)
  traceOut._length = null;
};

/***/ }),

/***/ 1510:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  moduleType: 'trace',
  name: 'streamtube',
  basePlotModule: __webpack_require__(8547),
  categories: ['gl3d', 'showLegend'],
  attributes: __webpack_require__(1850),
  supplyDefaults: __webpack_require__(2459),
  colorbar: {
    min: 'cmin',
    max: 'cmax'
  },
  calc: (__webpack_require__(8489).calc),
  plot: __webpack_require__(154),
  eventData: function (out, pt) {
    out.tubex = out.x;
    out.tubey = out.y;
    out.tubez = out.z;
    out.tubeu = pt.traceCoordinate[3];
    out.tubev = pt.traceCoordinate[4];
    out.tubew = pt.traceCoordinate[5];
    out.norm = pt.traceCoordinate[6];
    out.divergence = pt.traceCoordinate[7];

    // Does not correspond to input x/y/z, so delete them
    delete out.x;
    delete out.y;
    delete out.z;
    return out;
  },
  meta: {}
};

/***/ }),

/***/ 2897:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Color = __webpack_require__(7901);
var colorScaleAttrs = __webpack_require__(693);
var axisHoverFormat = (__webpack_require__(2663).axisHoverFormat);
var hovertemplateAttrs = (__webpack_require__(5386)/* .hovertemplateAttrs */ .fF);
var baseAttrs = __webpack_require__(9012);
var extendFlat = (__webpack_require__(1426).extendFlat);
var overrideAll = (__webpack_require__(962).overrideAll);
function makeContourProjAttr(axLetter) {
  return {
    valType: 'boolean',
    dflt: false
  };
}
function makeContourAttr(axLetter) {
  return {
    show: {
      valType: 'boolean',
      dflt: false
    },
    start: {
      valType: 'number',
      dflt: null,
      editType: 'plot'
      // impliedEdits: {'^autocontour': false},
    },

    end: {
      valType: 'number',
      dflt: null,
      editType: 'plot'
      // impliedEdits: {'^autocontour': false},
    },

    size: {
      valType: 'number',
      dflt: null,
      min: 0,
      editType: 'plot'
      // impliedEdits: {'^autocontour': false},
    },

    project: {
      x: makeContourProjAttr('x'),
      y: makeContourProjAttr('y'),
      z: makeContourProjAttr('z')
    },
    color: {
      valType: 'color',
      dflt: Color.defaultLine
    },
    usecolormap: {
      valType: 'boolean',
      dflt: false
    },
    width: {
      valType: 'number',
      min: 1,
      max: 16,
      dflt: 2
    },
    highlight: {
      valType: 'boolean',
      dflt: true
    },
    highlightcolor: {
      valType: 'color',
      dflt: Color.defaultLine
    },
    highlightwidth: {
      valType: 'number',
      min: 1,
      max: 16,
      dflt: 2
    }
  };
}
var attrs = module.exports = overrideAll(extendFlat({
  z: {
    valType: 'data_array'
  },
  x: {
    valType: 'data_array'
  },
  y: {
    valType: 'data_array'
  },
  text: {
    valType: 'string',
    dflt: '',
    arrayOk: true
  },
  hovertext: {
    valType: 'string',
    dflt: '',
    arrayOk: true
  },
  hovertemplate: hovertemplateAttrs(),
  xhoverformat: axisHoverFormat('x'),
  yhoverformat: axisHoverFormat('y'),
  zhoverformat: axisHoverFormat('z'),
  connectgaps: {
    valType: 'boolean',
    dflt: false,
    editType: 'calc'
  },
  surfacecolor: {
    valType: 'data_array'
  }
}, colorScaleAttrs('', {
  colorAttr: 'z or surfacecolor',
  showScaleDflt: true,
  autoColorDflt: false,
  editTypeOverride: 'calc'
}), {
  contours: {
    x: makeContourAttr('x'),
    y: makeContourAttr('y'),
    z: makeContourAttr('z')
  },
  hidesurface: {
    valType: 'boolean',
    dflt: false
  },
  lightposition: {
    x: {
      valType: 'number',
      min: -1e5,
      max: 1e5,
      dflt: 10
    },
    y: {
      valType: 'number',
      min: -1e5,
      max: 1e5,
      dflt: 1e4
    },
    z: {
      valType: 'number',
      min: -1e5,
      max: 1e5,
      dflt: 0
    }
  },
  lighting: {
    ambient: {
      valType: 'number',
      min: 0.00,
      max: 1.0,
      dflt: 0.8
    },
    diffuse: {
      valType: 'number',
      min: 0.00,
      max: 1.00,
      dflt: 0.8
    },
    specular: {
      valType: 'number',
      min: 0.00,
      max: 2.00,
      dflt: 0.05
    },
    roughness: {
      valType: 'number',
      min: 0.00,
      max: 1.00,
      dflt: 0.5
    },
    fresnel: {
      valType: 'number',
      min: 0.00,
      max: 5.00,
      dflt: 0.2
    }
  },
  opacity: {
    valType: 'number',
    min: 0,
    max: 1,
    dflt: 1
  },
  opacityscale: {
    valType: 'any',
    editType: 'calc'
  },
  _deprecated: {
    zauto: extendFlat({}, colorScaleAttrs.zauto, {}),
    zmin: extendFlat({}, colorScaleAttrs.zmin, {}),
    zmax: extendFlat({}, colorScaleAttrs.zmax, {})
  },
  hoverinfo: extendFlat({}, baseAttrs.hoverinfo),
  showlegend: extendFlat({}, baseAttrs.showlegend, {
    dflt: false
  })
}), 'calc', 'nested');
attrs.x.editType = attrs.y.editType = attrs.z.editType = 'calc+clearAxisTypes';
attrs.transforms = undefined;

/***/ }),

/***/ 8396:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var colorscaleCalc = __webpack_require__(8803);

// Compute auto-z and autocolorscale if applicable
module.exports = function calc(gd, trace) {
  if (trace.surfacecolor) {
    colorscaleCalc(gd, trace, {
      vals: trace.surfacecolor,
      containerStr: '',
      cLetter: 'c'
    });
  } else {
    colorscaleCalc(gd, trace, {
      vals: trace.z,
      containerStr: '',
      cLetter: 'c'
    });
  }
};

/***/ }),

/***/ 3768:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var createSurface = (__webpack_require__(9330).gl_surface3d);
var ndarray = (__webpack_require__(9330).ndarray);
var ndarrayInterp2d = (__webpack_require__(9330).ndarray_linear_interpolate.d2);
var interp2d = __webpack_require__(824);
var findEmpties = __webpack_require__(3907);
var isArrayOrTypedArray = (__webpack_require__(1828).isArrayOrTypedArray);
var parseColorScale = (__webpack_require__(1697).parseColorScale);
var str2RgbaArray = __webpack_require__(8614);
var extractOpts = (__webpack_require__(1081).extractOpts);
function SurfaceTrace(scene, surface, uid) {
  this.scene = scene;
  this.uid = uid;
  this.surface = surface;
  this.data = null;
  this.showContour = [false, false, false];
  this.contourStart = [null, null, null];
  this.contourEnd = [null, null, null];
  this.contourSize = [0, 0, 0];
  this.minValues = [Infinity, Infinity, Infinity];
  this.maxValues = [-Infinity, -Infinity, -Infinity];
  this.dataScaleX = 1.0;
  this.dataScaleY = 1.0;
  this.refineData = true;
  this.objectOffset = [0, 0, 0];
}
var proto = SurfaceTrace.prototype;
proto.getXat = function (a, b, calendar, axis) {
  var v = !isArrayOrTypedArray(this.data.x) ? a : isArrayOrTypedArray(this.data.x[0]) ? this.data.x[b][a] : this.data.x[a];
  return calendar === undefined ? v : axis.d2l(v, 0, calendar);
};
proto.getYat = function (a, b, calendar, axis) {
  var v = !isArrayOrTypedArray(this.data.y) ? b : isArrayOrTypedArray(this.data.y[0]) ? this.data.y[b][a] : this.data.y[b];
  return calendar === undefined ? v : axis.d2l(v, 0, calendar);
};
proto.getZat = function (a, b, calendar, axis) {
  var v = this.data.z[b][a];
  if (v === null && this.data.connectgaps && this.data._interpolatedZ) {
    v = this.data._interpolatedZ[b][a];
  }
  return calendar === undefined ? v : axis.d2l(v, 0, calendar);
};
proto.handlePick = function (selection) {
  if (selection.object === this.surface) {
    var xRatio = (selection.data.index[0] - 1) / this.dataScaleX - 1;
    var yRatio = (selection.data.index[1] - 1) / this.dataScaleY - 1;
    var j = Math.max(Math.min(Math.round(xRatio), this.data.z[0].length - 1), 0);
    var k = Math.max(Math.min(Math.round(yRatio), this.data._ylength - 1), 0);
    selection.index = [j, k];
    selection.traceCoordinate = [this.getXat(j, k), this.getYat(j, k), this.getZat(j, k)];
    selection.dataCoordinate = [this.getXat(j, k, this.data.xcalendar, this.scene.fullSceneLayout.xaxis), this.getYat(j, k, this.data.ycalendar, this.scene.fullSceneLayout.yaxis), this.getZat(j, k, this.data.zcalendar, this.scene.fullSceneLayout.zaxis)];
    for (var i = 0; i < 3; i++) {
      var v = selection.dataCoordinate[i];
      if (v !== null && v !== undefined) {
        selection.dataCoordinate[i] *= this.scene.dataScale[i];
      }
    }
    var text = this.data.hovertext || this.data.text;
    if (Array.isArray(text) && text[k] && text[k][j] !== undefined) {
      selection.textLabel = text[k][j];
    } else if (text) {
      selection.textLabel = text;
    } else {
      selection.textLabel = '';
    }
    selection.data.dataCoordinate = selection.dataCoordinate.slice();
    this.surface.highlight(selection.data);

    // Snap spikes to data coordinate
    this.scene.glplot.spikes.position = selection.dataCoordinate;
    return true;
  }
};
function isColormapCircular(colormap) {
  var first = colormap[0].rgb;
  var last = colormap[colormap.length - 1].rgb;
  return first[0] === last[0] && first[1] === last[1] && first[2] === last[2] && first[3] === last[3];
}
var shortPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999];
function getPow(a, b) {
  if (a < b) return 0;
  var n = 0;
  while (Math.floor(a % b) === 0) {
    a /= b;
    n++;
  }
  return n;
}
function getFactors(a) {
  var powers = [];
  for (var i = 0; i < shortPrimes.length; i++) {
    var b = shortPrimes[i];
    powers.push(getPow(a, b));
  }
  return powers;
}
function smallestDivisor(a) {
  var A = getFactors(a);
  var result = a;
  for (var i = 0; i < shortPrimes.length; i++) {
    if (A[i] > 0) {
      result = shortPrimes[i];
      break;
    }
  }
  return result;
}
function leastCommonMultiple(a, b) {
  if (a < 1 || b < 1) return undefined;
  var A = getFactors(a);
  var B = getFactors(b);
  var n = 1;
  for (var i = 0; i < shortPrimes.length; i++) {
    n *= Math.pow(shortPrimes[i], Math.max(A[i], B[i]));
  }
  return n;
}
function arrayLCM(A) {
  if (A.length === 0) return undefined;
  var n = 1;
  for (var i = 0; i < A.length; i++) {
    n = leastCommonMultiple(n, A[i]);
  }
  return n;
}
proto.calcXnums = function (xlen) {
  var i;
  var nums = [];
  for (i = 1; i < xlen; i++) {
    var a = this.getXat(i - 1, 0);
    var b = this.getXat(i, 0);
    if (b !== a && a !== undefined && a !== null && b !== undefined && b !== null) {
      nums[i - 1] = Math.abs(b - a);
    } else {
      nums[i - 1] = 0;
    }
  }
  var totalDist = 0;
  for (i = 1; i < xlen; i++) {
    totalDist += nums[i - 1];
  }
  for (i = 1; i < xlen; i++) {
    if (nums[i - 1] === 0) {
      nums[i - 1] = 1;
    } else {
      nums[i - 1] = Math.round(totalDist / nums[i - 1]);
    }
  }
  return nums;
};
proto.calcYnums = function (ylen) {
  var i;
  var nums = [];
  for (i = 1; i < ylen; i++) {
    var a = this.getYat(0, i - 1);
    var b = this.getYat(0, i);
    if (b !== a && a !== undefined && a !== null && b !== undefined && b !== null) {
      nums[i - 1] = Math.abs(b - a);
    } else {
      nums[i - 1] = 0;
    }
  }
  var totalDist = 0;
  for (i = 1; i < ylen; i++) {
    totalDist += nums[i - 1];
  }
  for (i = 1; i < ylen; i++) {
    if (nums[i - 1] === 0) {
      nums[i - 1] = 1;
    } else {
      nums[i - 1] = Math.round(totalDist / nums[i - 1]);
    }
  }
  return nums;
};
var highlyComposites = [1, 2, 4, 6, 12, 24, 36, 48, 60, 120, 180, 240, 360, 720, 840, 1260];
var MIN_RESOLUTION = highlyComposites[9];
var MAX_RESOLUTION = highlyComposites[13];
proto.estimateScale = function (resSrc, axis) {
  var nums = axis === 0 ? this.calcXnums(resSrc) : this.calcYnums(resSrc);
  var resDst = 1 + arrayLCM(nums);
  while (resDst < MIN_RESOLUTION) {
    resDst *= 2;
  }
  while (resDst > MAX_RESOLUTION) {
    resDst--;
    resDst /= smallestDivisor(resDst);
    resDst++;
    if (resDst < MIN_RESOLUTION) {
      // resDst = MIN_RESOLUTION; // option 1: use min resolution
      resDst = MAX_RESOLUTION; // option 2: use max resolution
    }
  }

  var scale = Math.round(resDst / resSrc);
  return scale > 1 ? scale : 1;
};

// based on Mikola Lysenko's ndarray-homography
// see https://github.com/scijs/ndarray-homography

function fnHomography(out, inp, X) {
  var w = X[8] + X[2] * inp[0] + X[5] * inp[1];
  out[0] = (X[6] + X[0] * inp[0] + X[3] * inp[1]) / w;
  out[1] = (X[7] + X[1] * inp[0] + X[4] * inp[1]) / w;
  return out;
}
function homography(dest, src, X) {
  warp(dest, src, fnHomography, X);
  return dest;
}

// based on Mikola Lysenko's ndarray-warp
// see https://github.com/scijs/ndarray-warp

function warp(dest, src, func, X) {
  var warped = [0, 0];
  var ni = dest.shape[0];
  var nj = dest.shape[1];
  for (var i = 0; i < ni; i++) {
    for (var j = 0; j < nj; j++) {
      func(warped, [i, j], X);
      dest.set(i, j, ndarrayInterp2d(src, warped[0], warped[1]));
    }
  }
  return dest;
}
proto.refineCoords = function (coords) {
  var scaleW = this.dataScaleX;
  var scaleH = this.dataScaleY;
  var width = coords[0].shape[0];
  var height = coords[0].shape[1];
  var newWidth = Math.floor(coords[0].shape[0] * scaleW + 1) | 0;
  var newHeight = Math.floor(coords[0].shape[1] * scaleH + 1) | 0;

  // Pad coords by +1
  var padWidth = 1 + width + 1;
  var padHeight = 1 + height + 1;
  var padImg = ndarray(new Float32Array(padWidth * padHeight), [padWidth, padHeight]);
  var X = [1 / scaleW, 0, 0, 0, 1 / scaleH, 0, 0, 0, 1];
  for (var i = 0; i < coords.length; ++i) {
    this.surface.padField(padImg, coords[i]);
    var scaledImg = ndarray(new Float32Array(newWidth * newHeight), [newWidth, newHeight]);
    homography(scaledImg, padImg, X);
    coords[i] = scaledImg;
  }
};
function insertIfNewLevel(arr, newValue) {
  var found = false;
  for (var k = 0; k < arr.length; k++) {
    if (newValue === arr[k]) {
      found = true;
      break;
    }
  }
  if (found === false) arr.push(newValue);
}
proto.setContourLevels = function () {
  var newLevels = [[], [], []];
  var useNewLevels = [false, false, false];
  var needsUpdate = false;
  var i, j, value;
  for (i = 0; i < 3; ++i) {
    if (this.showContour[i]) {
      needsUpdate = true;
      if (this.contourSize[i] > 0 && this.contourStart[i] !== null && this.contourEnd[i] !== null && this.contourEnd[i] > this.contourStart[i]) {
        useNewLevels[i] = true;
        for (j = this.contourStart[i]; j < this.contourEnd[i]; j += this.contourSize[i]) {
          value = j * this.scene.dataScale[i];
          insertIfNewLevel(newLevels[i], value);
        }
      }
    }
  }
  if (needsUpdate) {
    var allLevels = [[], [], []];
    for (i = 0; i < 3; ++i) {
      if (this.showContour[i]) {
        allLevels[i] = useNewLevels[i] ? newLevels[i] : this.scene.contourLevels[i];
      }
    }
    this.surface.update({
      levels: allLevels
    });
  }
};
proto.update = function (data) {
  var scene = this.scene;
  var sceneLayout = scene.fullSceneLayout;
  var surface = this.surface;
  var colormap = parseColorScale(data);
  var scaleFactor = scene.dataScale;
  var xlen = data.z[0].length;
  var ylen = data._ylength;
  var contourLevels = scene.contourLevels;

  // Save data
  this.data = data;

  /*
   * Fill and transpose zdata.
   * Consistent with 'heatmap' and 'contour', plotly 'surface'
   * 'z' are such that sub-arrays correspond to y-coords
   * and that the sub-array entries correspond to a x-coords,
   * which is the transpose of 'gl-surface-plot'.
   */

  var i, j, k, v;
  var rawCoords = [];
  for (i = 0; i < 3; i++) {
    rawCoords[i] = [];
    for (j = 0; j < xlen; j++) {
      rawCoords[i][j] = [];
      /*
      for(k = 0; k < ylen; k++) {
          rawCoords[i][j][k] = undefined;
      }
      */
    }
  }

  // coords x, y & z
  for (j = 0; j < xlen; j++) {
    for (k = 0; k < ylen; k++) {
      rawCoords[0][j][k] = this.getXat(j, k, data.xcalendar, sceneLayout.xaxis);
      rawCoords[1][j][k] = this.getYat(j, k, data.ycalendar, sceneLayout.yaxis);
      rawCoords[2][j][k] = this.getZat(j, k, data.zcalendar, sceneLayout.zaxis);
    }
  }
  if (data.connectgaps) {
    data._emptypoints = findEmpties(rawCoords[2]);
    interp2d(rawCoords[2], data._emptypoints);
    data._interpolatedZ = [];
    for (j = 0; j < xlen; j++) {
      data._interpolatedZ[j] = [];
      for (k = 0; k < ylen; k++) {
        data._interpolatedZ[j][k] = rawCoords[2][j][k];
      }
    }
  }

  // Note: log axes are not defined in surfaces yet.
  // but they could be defined here...

  for (i = 0; i < 3; i++) {
    for (j = 0; j < xlen; j++) {
      for (k = 0; k < ylen; k++) {
        v = rawCoords[i][j][k];
        if (v === null || v === undefined) {
          rawCoords[i][j][k] = NaN;
        } else {
          v = rawCoords[i][j][k] *= scaleFactor[i];
        }
      }
    }
  }
  for (i = 0; i < 3; i++) {
    for (j = 0; j < xlen; j++) {
      for (k = 0; k < ylen; k++) {
        v = rawCoords[i][j][k];
        if (v !== null && v !== undefined) {
          if (this.minValues[i] > v) {
            this.minValues[i] = v;
          }
          if (this.maxValues[i] < v) {
            this.maxValues[i] = v;
          }
        }
      }
    }
  }
  for (i = 0; i < 3; i++) {
    this.objectOffset[i] = 0.5 * (this.minValues[i] + this.maxValues[i]);
  }
  for (i = 0; i < 3; i++) {
    for (j = 0; j < xlen; j++) {
      for (k = 0; k < ylen; k++) {
        v = rawCoords[i][j][k];
        if (v !== null && v !== undefined) {
          rawCoords[i][j][k] -= this.objectOffset[i];
        }
      }
    }
  }

  // convert processed raw data to Float32 matrices
  var coords = [ndarray(new Float32Array(xlen * ylen), [xlen, ylen]), ndarray(new Float32Array(xlen * ylen), [xlen, ylen]), ndarray(new Float32Array(xlen * ylen), [xlen, ylen])];
  for (i = 0; i < 3; i++) {
    for (j = 0; j < xlen; j++) {
      for (k = 0; k < ylen; k++) {
        coords[i].set(j, k, rawCoords[i][j][k]);
      }
    }
  }
  rawCoords = []; // free memory

  var params = {
    colormap: colormap,
    levels: [[], [], []],
    showContour: [true, true, true],
    showSurface: !data.hidesurface,
    contourProject: [[false, false, false], [false, false, false], [false, false, false]],
    contourWidth: [1, 1, 1],
    contourColor: [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],
    contourTint: [1, 1, 1],
    dynamicColor: [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],
    dynamicWidth: [1, 1, 1],
    dynamicTint: [1, 1, 1],
    opacityscale: data.opacityscale,
    opacity: data.opacity
  };
  var cOpts = extractOpts(data);
  params.intensityBounds = [cOpts.min, cOpts.max];

  // Refine surface color if necessary
  if (data.surfacecolor) {
    var intensity = ndarray(new Float32Array(xlen * ylen), [xlen, ylen]);
    for (j = 0; j < xlen; j++) {
      for (k = 0; k < ylen; k++) {
        intensity.set(j, k, data.surfacecolor[k][j]);
      }
    }
    coords.push(intensity);
  } else {
    // when 'z' is used as 'intensity',
    // we must scale its value
    params.intensityBounds[0] *= scaleFactor[2];
    params.intensityBounds[1] *= scaleFactor[2];
  }
  if (MAX_RESOLUTION < coords[0].shape[0] || MAX_RESOLUTION < coords[0].shape[1]) {
    this.refineData = false;
  }
  if (this.refineData === true) {
    this.dataScaleX = this.estimateScale(coords[0].shape[0], 0);
    this.dataScaleY = this.estimateScale(coords[0].shape[1], 1);
    if (this.dataScaleX !== 1 || this.dataScaleY !== 1) {
      this.refineCoords(coords);
    }
  }
  if (data.surfacecolor) {
    params.intensity = coords.pop();
  }
  var highlightEnable = [true, true, true];
  var axis = ['x', 'y', 'z'];
  for (i = 0; i < 3; ++i) {
    var contourParams = data.contours[axis[i]];
    highlightEnable[i] = contourParams.highlight;
    params.showContour[i] = contourParams.show || contourParams.highlight;
    if (!params.showContour[i]) continue;
    params.contourProject[i] = [contourParams.project.x, contourParams.project.y, contourParams.project.z];
    if (contourParams.show) {
      this.showContour[i] = true;
      params.levels[i] = contourLevels[i];
      surface.highlightColor[i] = params.contourColor[i] = str2RgbaArray(contourParams.color);
      if (contourParams.usecolormap) {
        surface.highlightTint[i] = params.contourTint[i] = 0;
      } else {
        surface.highlightTint[i] = params.contourTint[i] = 1;
      }
      params.contourWidth[i] = contourParams.width;
      this.contourStart[i] = contourParams.start;
      this.contourEnd[i] = contourParams.end;
      this.contourSize[i] = contourParams.size;
    } else {
      this.showContour[i] = false;
      this.contourStart[i] = null;
      this.contourEnd[i] = null;
      this.contourSize[i] = 0;
    }
    if (contourParams.highlight) {
      params.dynamicColor[i] = str2RgbaArray(contourParams.highlightcolor);
      params.dynamicWidth[i] = contourParams.highlightwidth;
    }
  }

  // see https://github.com/plotly/plotly.js/issues/940
  if (isColormapCircular(colormap)) {
    params.vertexColor = true;
  }
  params.objectOffset = this.objectOffset;
  params.coords = coords;
  surface.update(params);
  surface.visible = data.visible;
  surface.enableDynamic = highlightEnable;
  surface.enableHighlight = highlightEnable;
  surface.snapToData = true;
  if ('lighting' in data) {
    surface.ambientLight = data.lighting.ambient;
    surface.diffuseLight = data.lighting.diffuse;
    surface.specularLight = data.lighting.specular;
    surface.roughness = data.lighting.roughness;
    surface.fresnel = data.lighting.fresnel;
  }
  if ('lightposition' in data) {
    surface.lightPosition = [data.lightposition.x, data.lightposition.y, data.lightposition.z];
  }
};
proto.dispose = function () {
  this.scene.glplot.remove(this.surface);
  this.surface.dispose();
};
function createSurfaceTrace(scene, data) {
  var gl = scene.glplot.gl;
  var surface = createSurface({
    gl: gl
  });
  var result = new SurfaceTrace(scene, surface, data.uid);
  surface._trace = result;
  result.update(data);
  scene.glplot.add(surface);
  return result;
}
module.exports = createSurfaceTrace;

/***/ }),

/***/ 1831:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Registry = __webpack_require__(3972);
var Lib = __webpack_require__(1828);
var colorscaleDefaults = __webpack_require__(1586);
var attributes = __webpack_require__(2897);
var MIN = 0.1; // Note: often we don't want the data cube to be disappeared

function createWave(n, minOpacity) {
  var arr = [];
  var steps = 32; // Max: 256
  for (var i = 0; i < steps; i++) {
    var u = i / (steps - 1);
    var v = minOpacity + (1 - minOpacity) * (1 - Math.pow(Math.sin(n * u * Math.PI), 2));
    arr.push([u, Math.max(0, Math.min(1, v))]);
  }
  return arr;
}
function isValidScaleArray(scl) {
  var highestVal = 0;
  if (!Array.isArray(scl) || scl.length < 2) return false;
  if (!scl[0] || !scl[scl.length - 1]) return false;
  if (+scl[0][0] !== 0 || +scl[scl.length - 1][0] !== 1) return false;
  for (var i = 0; i < scl.length; i++) {
    var si = scl[i];
    if (si.length !== 2 || +si[0] < highestVal) {
      return false;
    }
    highestVal = +si[0];
  }
  return true;
}
function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
  var i, j;
  function coerce(attr, dflt) {
    return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
  }
  var x = coerce('x');
  var y = coerce('y');
  var z = coerce('z');
  if (!z || !z.length || (x ? x.length < 1 : false) || (y ? y.length < 1 : false)) {
    traceOut.visible = false;
    return;
  }
  traceOut._xlength = Array.isArray(x) && Lib.isArrayOrTypedArray(x[0]) ? z.length : z[0].length;
  traceOut._ylength = z.length;
  var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleTraceDefaults');
  handleCalendarDefaults(traceIn, traceOut, ['x', 'y', 'z'], layout);
  coerce('text');
  coerce('hovertext');
  coerce('hovertemplate');
  coerce('xhoverformat');
  coerce('yhoverformat');
  coerce('zhoverformat');

  // Coerce remaining properties
  ['lighting.ambient', 'lighting.diffuse', 'lighting.specular', 'lighting.roughness', 'lighting.fresnel', 'lightposition.x', 'lightposition.y', 'lightposition.z', 'hidesurface', 'connectgaps', 'opacity'].forEach(function (x) {
    coerce(x);
  });
  var surfaceColor = coerce('surfacecolor');
  var dims = ['x', 'y', 'z'];
  for (i = 0; i < 3; ++i) {
    var contourDim = 'contours.' + dims[i];
    var show = coerce(contourDim + '.show');
    var highlight = coerce(contourDim + '.highlight');
    if (show || highlight) {
      for (j = 0; j < 3; ++j) {
        coerce(contourDim + '.project.' + dims[j]);
      }
    }
    if (show) {
      coerce(contourDim + '.color');
      coerce(contourDim + '.width');
      coerce(contourDim + '.usecolormap');
    }
    if (highlight) {
      coerce(contourDim + '.highlightcolor');
      coerce(contourDim + '.highlightwidth');
    }
    coerce(contourDim + '.start');
    coerce(contourDim + '.end');
    coerce(contourDim + '.size');
  }

  // backward compatibility block
  if (!surfaceColor) {
    mapLegacy(traceIn, 'zmin', 'cmin');
    mapLegacy(traceIn, 'zmax', 'cmax');
    mapLegacy(traceIn, 'zauto', 'cauto');
  }

  // TODO if contours.?.usecolormap are false and hidesurface is true
  // the colorbar shouldn't be shown by default

  colorscaleDefaults(traceIn, traceOut, layout, coerce, {
    prefix: '',
    cLetter: 'c'
  });
  opacityscaleDefaults(traceIn, traceOut, layout, coerce);

  // disable 1D transforms - currently surface does NOT support column data like heatmap does
  // you can use mesh3d for this use case, but not surface
  traceOut._length = null;
}
function opacityscaleDefaults(traceIn, traceOut, layout, coerce) {
  var opacityscale = coerce('opacityscale');
  if (opacityscale === 'max') {
    traceOut.opacityscale = [[0, MIN], [1, 1]];
  } else if (opacityscale === 'min') {
    traceOut.opacityscale = [[0, 1], [1, MIN]];
  } else if (opacityscale === 'extremes') {
    traceOut.opacityscale = createWave(1, MIN);
  } else if (!isValidScaleArray(opacityscale)) {
    traceOut.opacityscale = undefined;
  }
}
function mapLegacy(traceIn, oldAttr, newAttr) {
  if (oldAttr in traceIn && !(newAttr in traceIn)) {
    traceIn[newAttr] = traceIn[oldAttr];
  }
}
module.exports = {
  supplyDefaults: supplyDefaults,
  opacityscaleDefaults: opacityscaleDefaults
};

/***/ }),

/***/ 3601:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  attributes: __webpack_require__(2897),
  supplyDefaults: (__webpack_require__(1831).supplyDefaults),
  colorbar: {
    min: 'cmin',
    max: 'cmax'
  },
  calc: __webpack_require__(8396),
  plot: __webpack_require__(3768),
  moduleType: 'trace',
  name: 'surface',
  basePlotModule: __webpack_require__(8547),
  categories: ['gl3d', '2dMap', 'showLegend'],
  meta: {}
};

/***/ }),

/***/ 6336:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var colorScaleAttrs = __webpack_require__(693);
var isosurfaceAttrs = __webpack_require__(2810);
var surfaceAttrs = __webpack_require__(2897);
var baseAttrs = __webpack_require__(9012);
var extendFlat = (__webpack_require__(1426).extendFlat);
var overrideAll = (__webpack_require__(962).overrideAll);
var attrs = module.exports = overrideAll(extendFlat({
  x: isosurfaceAttrs.x,
  y: isosurfaceAttrs.y,
  z: isosurfaceAttrs.z,
  value: isosurfaceAttrs.value,
  isomin: isosurfaceAttrs.isomin,
  isomax: isosurfaceAttrs.isomax,
  surface: isosurfaceAttrs.surface,
  spaceframe: {
    show: {
      valType: 'boolean',
      dflt: false
    },
    fill: {
      valType: 'number',
      min: 0,
      max: 1,
      dflt: 1
    }
  },
  slices: isosurfaceAttrs.slices,
  caps: isosurfaceAttrs.caps,
  text: isosurfaceAttrs.text,
  hovertext: isosurfaceAttrs.hovertext,
  xhoverformat: isosurfaceAttrs.xhoverformat,
  yhoverformat: isosurfaceAttrs.yhoverformat,
  zhoverformat: isosurfaceAttrs.zhoverformat,
  valuehoverformat: isosurfaceAttrs.valuehoverformat,
  hovertemplate: isosurfaceAttrs.hovertemplate
}, colorScaleAttrs('', {
  colorAttr: '`value`',
  showScaleDflt: true,
  editTypeOverride: 'calc'
}), {
  colorbar: isosurfaceAttrs.colorbar,
  opacity: isosurfaceAttrs.opacity,
  opacityscale: surfaceAttrs.opacityscale,
  lightposition: isosurfaceAttrs.lightposition,
  lighting: isosurfaceAttrs.lighting,
  flatshading: isosurfaceAttrs.flatshading,
  contour: isosurfaceAttrs.contour,
  hoverinfo: extendFlat({}, baseAttrs.hoverinfo),
  showlegend: extendFlat({}, baseAttrs.showlegend, {
    dflt: false
  })
}), 'calc', 'nested');
attrs.x.editType = attrs.y.editType = attrs.z.editType = attrs.value.editType = 'calc+clearAxisTypes';
attrs.transforms = undefined;

/***/ }),

/***/ 4809:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var createMesh = (__webpack_require__(9330).gl_mesh3d);
var parseColorScale = (__webpack_require__(1697).parseColorScale);
var str2RgbaArray = __webpack_require__(8614);
var extractOpts = (__webpack_require__(1081).extractOpts);
var zip3 = __webpack_require__(60);
var findNearestOnAxis = (__webpack_require__(2674).findNearestOnAxis);
var generateIsoMeshes = (__webpack_require__(2674).generateIsoMeshes);
function VolumeTrace(scene, mesh, uid) {
  this.scene = scene;
  this.uid = uid;
  this.mesh = mesh;
  this.name = '';
  this.data = null;
  this.showContour = false;
}
var proto = VolumeTrace.prototype;
proto.handlePick = function (selection) {
  if (selection.object === this.mesh) {
    var rawId = selection.data.index;
    var x = this.data._meshX[rawId];
    var y = this.data._meshY[rawId];
    var z = this.data._meshZ[rawId];
    var height = this.data._Ys.length;
    var depth = this.data._Zs.length;
    var i = findNearestOnAxis(x, this.data._Xs).id;
    var j = findNearestOnAxis(y, this.data._Ys).id;
    var k = findNearestOnAxis(z, this.data._Zs).id;
    var selectIndex = selection.index = k + depth * j + depth * height * i;
    selection.traceCoordinate = [this.data._meshX[selectIndex], this.data._meshY[selectIndex], this.data._meshZ[selectIndex], this.data._value[selectIndex]];
    var text = this.data.hovertext || this.data.text;
    if (Array.isArray(text) && text[selectIndex] !== undefined) {
      selection.textLabel = text[selectIndex];
    } else if (text) {
      selection.textLabel = text;
    }
    return true;
  }
};
proto.update = function (data) {
  var scene = this.scene;
  var layout = scene.fullSceneLayout;
  this.data = generateIsoMeshes(data);

  // Unpack position data
  function toDataCoords(axis, coord, scale, calendar) {
    return coord.map(function (x) {
      return axis.d2l(x, 0, calendar) * scale;
    });
  }
  var positions = zip3(toDataCoords(layout.xaxis, data._meshX, scene.dataScale[0], data.xcalendar), toDataCoords(layout.yaxis, data._meshY, scene.dataScale[1], data.ycalendar), toDataCoords(layout.zaxis, data._meshZ, scene.dataScale[2], data.zcalendar));
  var cells = zip3(data._meshI, data._meshJ, data._meshK);
  var config = {
    positions: positions,
    cells: cells,
    lightPosition: [data.lightposition.x, data.lightposition.y, data.lightposition.z],
    ambient: data.lighting.ambient,
    diffuse: data.lighting.diffuse,
    specular: data.lighting.specular,
    roughness: data.lighting.roughness,
    fresnel: data.lighting.fresnel,
    vertexNormalsEpsilon: data.lighting.vertexnormalsepsilon,
    faceNormalsEpsilon: data.lighting.facenormalsepsilon,
    opacity: data.opacity,
    opacityscale: data.opacityscale,
    contourEnable: data.contour.show,
    contourColor: str2RgbaArray(data.contour.color).slice(0, 3),
    contourWidth: data.contour.width,
    useFacetNormals: data.flatshading
  };
  var cOpts = extractOpts(data);
  config.vertexIntensity = data._meshIntensity;
  config.vertexIntensityBounds = [cOpts.min, cOpts.max];
  config.colormap = parseColorScale(data);

  // Update mesh
  this.mesh.update(config);
};
proto.dispose = function () {
  this.scene.glplot.remove(this.mesh);
  this.mesh.dispose();
};
function createVolumeTrace(scene, data) {
  var gl = scene.glplot.gl;
  var mesh = createMesh({
    gl: gl
  });
  var result = new VolumeTrace(scene, mesh, data.uid);
  mesh._trace = result;
  result.update(data);
  scene.glplot.add(mesh);
  return result;
}
module.exports = createVolumeTrace;

/***/ }),

/***/ 7651:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var attributes = __webpack_require__(6336);
var supplyIsoDefaults = (__webpack_require__(2738).supplyIsoDefaults);
var opacityscaleDefaults = (__webpack_require__(1831).opacityscaleDefaults);
module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
  function coerce(attr, dflt) {
    return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
  }
  supplyIsoDefaults(traceIn, traceOut, defaultColor, layout, coerce);
  opacityscaleDefaults(traceIn, traceOut, layout, coerce);
};

/***/ }),

/***/ 1410:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  attributes: __webpack_require__(6336),
  supplyDefaults: __webpack_require__(7651),
  calc: __webpack_require__(6959),
  colorbar: {
    min: 'cmin',
    max: 'cmax'
  },
  plot: __webpack_require__(4809),
  moduleType: 'trace',
  name: 'volume',
  basePlotModule: __webpack_require__(8547),
  categories: ['gl3d', 'showLegend'],
  meta: {}
};

/***/ }),

/***/ 2887:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var Axes = __webpack_require__(9298);
var Lib = __webpack_require__(1828);
var PlotSchema = __webpack_require__(6281);
var pointsAccessorFunction = (__webpack_require__(9344)/* .pointsAccessorFunction */ .p);
var BADNUM = (__webpack_require__(606).BADNUM);
exports.moduleType = 'transform';
exports.name = 'aggregate';
var attrs = exports.attributes = {
  enabled: {
    valType: 'boolean',
    dflt: true,
    editType: 'calc'
  },
  groups: {
    // TODO: groupby should support string or array grouping this way too
    // currently groupby only allows a grouping array
    valType: 'string',
    strict: true,
    noBlank: true,
    arrayOk: true,
    dflt: 'x',
    editType: 'calc'
  },
  aggregations: {
    _isLinkedToArray: 'aggregation',
    target: {
      valType: 'string',
      editType: 'calc'
    },
    func: {
      valType: 'enumerated',
      values: ['count', 'sum', 'avg', 'median', 'mode', 'rms', 'stddev', 'min', 'max', 'first', 'last', 'change', 'range'],
      dflt: 'first',
      editType: 'calc'
    },
    funcmode: {
      valType: 'enumerated',
      values: ['sample', 'population'],
      dflt: 'sample',
      editType: 'calc'
    },
    enabled: {
      valType: 'boolean',
      dflt: true,
      editType: 'calc'
    },
    editType: 'calc'
  },
  editType: 'calc'
};
var aggAttrs = attrs.aggregations;

/**
 * Supply transform attributes defaults
 *
 * @param {object} transformIn
 *  object linked to trace.transforms[i] with 'func' set to exports.name
 * @param {object} traceOut
 *  the _fullData trace this transform applies to
 * @param {object} layout
 *  the plot's (not-so-full) layout
 * @param {object} traceIn
 *  the input data trace this transform applies to
 *
 * @return {object} transformOut
 *  copy of transformIn that contains attribute defaults
 */
exports.supplyDefaults = function (transformIn, traceOut) {
  var transformOut = {};
  var i;
  function coerce(attr, dflt) {
    return Lib.coerce(transformIn, transformOut, attrs, attr, dflt);
  }
  var enabled = coerce('enabled');
  if (!enabled) return transformOut;

  /*
   * Normally _arrayAttrs is calculated during doCalc, but that comes later.
   * Anyway this can change due to *count* aggregations (see below) so it's not
   * necessarily the same set.
   *
   * For performance we turn it into an object of truthy values
   * we'll use 1 for arrays we haven't aggregated yet, 0 for finished arrays,
   * as distinct from undefined which means this array isn't present in the input
   * missing arrays can still be aggregate outputs for *count* aggregations.
   */
  var arrayAttrArray = PlotSchema.findArrayAttributes(traceOut);
  var arrayAttrs = {};
  for (i = 0; i < arrayAttrArray.length; i++) arrayAttrs[arrayAttrArray[i]] = 1;
  var groups = coerce('groups');
  if (!Array.isArray(groups)) {
    if (!arrayAttrs[groups]) {
      transformOut.enabled = false;
      return transformOut;
    }
    arrayAttrs[groups] = 0;
  }
  var aggregationsIn = transformIn.aggregations || [];
  var aggregationsOut = transformOut.aggregations = new Array(aggregationsIn.length);
  var aggregationOut;
  function coercei(attr, dflt) {
    return Lib.coerce(aggregationsIn[i], aggregationOut, aggAttrs, attr, dflt);
  }
  for (i = 0; i < aggregationsIn.length; i++) {
    aggregationOut = {
      _index: i
    };
    var target = coercei('target');
    var func = coercei('func');
    var enabledi = coercei('enabled');

    // add this aggregation to the output only if it's the first instance
    // of a valid target attribute - or an unused target attribute with "count"
    if (enabledi && target && (arrayAttrs[target] || func === 'count' && arrayAttrs[target] === undefined)) {
      if (func === 'stddev') coercei('funcmode');
      arrayAttrs[target] = 0;
      aggregationsOut[i] = aggregationOut;
    } else aggregationsOut[i] = {
      enabled: false,
      _index: i
    };
  }

  // any array attributes we haven't yet covered, fill them with the default aggregation
  for (i = 0; i < arrayAttrArray.length; i++) {
    if (arrayAttrs[arrayAttrArray[i]]) {
      aggregationsOut.push({
        target: arrayAttrArray[i],
        func: aggAttrs.func.dflt,
        enabled: true,
        _index: -1
      });
    }
  }
  return transformOut;
};
exports.calcTransform = function (gd, trace, opts) {
  if (!opts.enabled) return;
  var groups = opts.groups;
  var groupArray = Lib.getTargetArray(trace, {
    target: groups
  });
  if (!groupArray) return;
  var i, vi, groupIndex, newGrouping;
  var groupIndices = {};
  var indexToPoints = {};
  var groupings = [];
  var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);
  var len = groupArray.length;
  if (trace._length) len = Math.min(len, trace._length);
  for (i = 0; i < len; i++) {
    vi = groupArray[i];
    groupIndex = groupIndices[vi];
    if (groupIndex === undefined) {
      groupIndices[vi] = groupings.length;
      newGrouping = [i];
      groupings.push(newGrouping);
      indexToPoints[groupIndices[vi]] = originalPointsAccessor(i);
    } else {
      groupings[groupIndex].push(i);
      indexToPoints[groupIndices[vi]] = (indexToPoints[groupIndices[vi]] || []).concat(originalPointsAccessor(i));
    }
  }
  opts._indexToPoints = indexToPoints;
  var aggregations = opts.aggregations;
  for (i = 0; i < aggregations.length; i++) {
    aggregateOneArray(gd, trace, groupings, aggregations[i]);
  }
  if (typeof groups === 'string') {
    aggregateOneArray(gd, trace, groupings, {
      target: groups,
      func: 'first',
      enabled: true
    });
  }
  trace._length = groupings.length;
};
function aggregateOneArray(gd, trace, groupings, aggregation) {
  if (!aggregation.enabled) return;
  var attr = aggregation.target;
  var targetNP = Lib.nestedProperty(trace, attr);
  var arrayIn = targetNP.get();
  var conversions = Axes.getDataConversions(gd, trace, attr, arrayIn);
  var func = getAggregateFunction(aggregation, conversions);
  var arrayOut = new Array(groupings.length);
  for (var i = 0; i < groupings.length; i++) {
    arrayOut[i] = func(arrayIn, groupings[i]);
  }
  targetNP.set(arrayOut);
  if (aggregation.func === 'count') {
    // count does not depend on an input array, so it's likely not part of _arrayAttrs yet
    // but after this transform it most definitely *is* an array attribute.
    Lib.pushUnique(trace._arrayAttrs, attr);
  }
}
function getAggregateFunction(opts, conversions) {
  var func = opts.func;
  var d2c = conversions.d2c;
  var c2d = conversions.c2d;
  switch (func) {
    // count, first, and last don't depend on anything about the data
    // point back to pure functions for performance
    case 'count':
      return count;
    case 'first':
      return first;
    case 'last':
      return last;
    case 'sum':
      // This will produce output in all cases even though it's nonsensical
      // for date or category data.
      return function (array, indices) {
        var total = 0;
        for (var i = 0; i < indices.length; i++) {
          var vi = d2c(array[indices[i]]);
          if (vi !== BADNUM) total += vi;
        }
        return c2d(total);
      };
    case 'avg':
      // Generally meaningless for category data but it still does something.
      return function (array, indices) {
        var total = 0;
        var cnt = 0;
        for (var i = 0; i < indices.length; i++) {
          var vi = d2c(array[indices[i]]);
          if (vi !== BADNUM) {
            total += vi;
            cnt++;
          }
        }
        return cnt ? c2d(total / cnt) : BADNUM;
      };
    case 'min':
      return function (array, indices) {
        var out = Infinity;
        for (var i = 0; i < indices.length; i++) {
          var vi = d2c(array[indices[i]]);
          if (vi !== BADNUM) out = Math.min(out, vi);
        }
        return out === Infinity ? BADNUM : c2d(out);
      };
    case 'max':
      return function (array, indices) {
        var out = -Infinity;
        for (var i = 0; i < indices.length; i++) {
          var vi = d2c(array[indices[i]]);
          if (vi !== BADNUM) out = Math.max(out, vi);
        }
        return out === -Infinity ? BADNUM : c2d(out);
      };
    case 'range':
      return function (array, indices) {
        var min = Infinity;
        var max = -Infinity;
        for (var i = 0; i < indices.length; i++) {
          var vi = d2c(array[indices[i]]);
          if (vi !== BADNUM) {
            min = Math.min(min, vi);
            max = Math.max(max, vi);
          }
        }
        return max === -Infinity || min === Infinity ? BADNUM : c2d(max - min);
      };
    case 'change':
      return function (array, indices) {
        var first = d2c(array[indices[0]]);
        var last = d2c(array[indices[indices.length - 1]]);
        return first === BADNUM || last === BADNUM ? BADNUM : c2d(last - first);
      };
    case 'median':
      return function (array, indices) {
        var sortCalc = [];
        for (var i = 0; i < indices.length; i++) {
          var vi = d2c(array[indices[i]]);
          if (vi !== BADNUM) sortCalc.push(vi);
        }
        if (!sortCalc.length) return BADNUM;
        sortCalc.sort(Lib.sorterAsc);
        var mid = (sortCalc.length - 1) / 2;
        return c2d((sortCalc[Math.floor(mid)] + sortCalc[Math.ceil(mid)]) / 2);
      };
    case 'mode':
      return function (array, indices) {
        var counts = {};
        var maxCnt = 0;
        var out = BADNUM;
        for (var i = 0; i < indices.length; i++) {
          var vi = d2c(array[indices[i]]);
          if (vi !== BADNUM) {
            var counti = counts[vi] = (counts[vi] || 0) + 1;
            if (counti > maxCnt) {
              maxCnt = counti;
              out = vi;
            }
          }
        }
        return maxCnt ? c2d(out) : BADNUM;
      };
    case 'rms':
      return function (array, indices) {
        var total = 0;
        var cnt = 0;
        for (var i = 0; i < indices.length; i++) {
          var vi = d2c(array[indices[i]]);
          if (vi !== BADNUM) {
            total += vi * vi;
            cnt++;
          }
        }
        return cnt ? c2d(Math.sqrt(total / cnt)) : BADNUM;
      };
    case 'stddev':
      return function (array, indices) {
        // balance numerical stability with performance:
        // so that we call d2c once per element but don't need to
        // store them, reference all to the first element
        var total = 0;
        var total2 = 0;
        var cnt = 1;
        var v0 = BADNUM;
        var i;
        for (i = 0; i < indices.length && v0 === BADNUM; i++) {
          v0 = d2c(array[indices[i]]);
        }
        if (v0 === BADNUM) return BADNUM;
        for (; i < indices.length; i++) {
          var vi = d2c(array[indices[i]]);
          if (vi !== BADNUM) {
            var dv = vi - v0;
            total += dv;
            total2 += dv * dv;
            cnt++;
          }
        }

        // This is population std dev, if we want sample std dev
        // we would need (...) / (cnt - 1)
        // Also note there's no c2d here - that means for dates the result
        // is a number of milliseconds, and for categories it's a number
        // of category differences, which is not generically meaningful but
        // as in other cases we don't forbid it.
        var norm = opts.funcmode === 'sample' ? cnt - 1 : cnt;
        // this is debatable: should a count of 1 return sample stddev of
        // 0 or undefined?
        if (!norm) return 0;
        return Math.sqrt((total2 - total * total / cnt) / norm);
      };
  }
}
function count(array, indices) {
  return indices.length;
}
function first(array, indices) {
  return array[indices[0]];
}
function last(array, indices) {
  return array[indices[indices.length - 1]];
}

/***/ }),

/***/ 4382:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Registry = __webpack_require__(3972);
var Axes = __webpack_require__(9298);
var pointsAccessorFunction = (__webpack_require__(9344)/* .pointsAccessorFunction */ .p);
var filterOps = __webpack_require__(4808);
var COMPARISON_OPS = filterOps.COMPARISON_OPS;
var INTERVAL_OPS = filterOps.INTERVAL_OPS;
var SET_OPS = filterOps.SET_OPS;
exports.moduleType = 'transform';
exports.name = 'filter';
exports.attributes = {
  enabled: {
    valType: 'boolean',
    dflt: true,
    editType: 'calc'
  },
  target: {
    valType: 'string',
    strict: true,
    noBlank: true,
    arrayOk: true,
    dflt: 'x',
    editType: 'calc'
  },
  operation: {
    valType: 'enumerated',
    values: [].concat(COMPARISON_OPS).concat(INTERVAL_OPS).concat(SET_OPS),
    dflt: '=',
    editType: 'calc'
  },
  value: {
    valType: 'any',
    dflt: 0,
    editType: 'calc'
  },
  preservegaps: {
    valType: 'boolean',
    dflt: false,
    editType: 'calc'
  },
  editType: 'calc'
};
exports.supplyDefaults = function (transformIn) {
  var transformOut = {};
  function coerce(attr, dflt) {
    return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);
  }
  var enabled = coerce('enabled');
  if (enabled) {
    var target = coerce('target');
    if (Lib.isArrayOrTypedArray(target) && target.length === 0) {
      transformOut.enabled = false;
      return transformOut;
    }
    coerce('preservegaps');
    coerce('operation');
    coerce('value');
    var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleDefaults');
    handleCalendarDefaults(transformIn, transformOut, 'valuecalendar', null);
    handleCalendarDefaults(transformIn, transformOut, 'targetcalendar', null);
  }
  return transformOut;
};
exports.calcTransform = function (gd, trace, opts) {
  if (!opts.enabled) return;
  var targetArray = Lib.getTargetArray(trace, opts);
  if (!targetArray) return;
  var target = opts.target;
  var len = targetArray.length;
  if (trace._length) len = Math.min(len, trace._length);
  var targetCalendar = opts.targetcalendar;
  var arrayAttrs = trace._arrayAttrs;
  var preservegaps = opts.preservegaps;

  // even if you provide targetcalendar, if target is a string and there
  // is a calendar attribute matching target it will get used instead.
  if (typeof target === 'string') {
    var attrTargetCalendar = Lib.nestedProperty(trace, target + 'calendar').get();
    if (attrTargetCalendar) targetCalendar = attrTargetCalendar;
  }
  var d2c = Axes.getDataToCoordFunc(gd, trace, target, targetArray);
  var filterFunc = getFilterFunc(opts, d2c, targetCalendar);
  var originalArrays = {};
  var indexToPoints = {};
  var index = 0;
  function forAllAttrs(fn, index) {
    for (var j = 0; j < arrayAttrs.length; j++) {
      var np = Lib.nestedProperty(trace, arrayAttrs[j]);
      fn(np, index);
    }
  }
  var initFn;
  var fillFn;
  if (preservegaps) {
    initFn = function (np) {
      originalArrays[np.astr] = Lib.extendDeep([], np.get());
      np.set(new Array(len));
    };
    fillFn = function (np, index) {
      var val = originalArrays[np.astr][index];
      np.get()[index] = val;
    };
  } else {
    initFn = function (np) {
      originalArrays[np.astr] = Lib.extendDeep([], np.get());
      np.set([]);
    };
    fillFn = function (np, index) {
      var val = originalArrays[np.astr][index];
      np.get().push(val);
    };
  }

  // copy all original array attribute values, and clear arrays in trace
  forAllAttrs(initFn);
  var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);

  // loop through filter array, fill trace arrays if passed
  for (var i = 0; i < len; i++) {
    var passed = filterFunc(targetArray[i]);
    if (passed) {
      forAllAttrs(fillFn, i);
      indexToPoints[index++] = originalPointsAccessor(i);
    } else if (preservegaps) index++;
  }
  opts._indexToPoints = indexToPoints;
  trace._length = index;
};
function getFilterFunc(opts, d2c, targetCalendar) {
  var operation = opts.operation;
  var value = opts.value;
  var hasArrayValue = Array.isArray(value);
  function isOperationIn(array) {
    return array.indexOf(operation) !== -1;
  }
  var d2cValue = function (v) {
    return d2c(v, 0, opts.valuecalendar);
  };
  var d2cTarget = function (v) {
    return d2c(v, 0, targetCalendar);
  };
  var coercedValue;
  if (isOperationIn(COMPARISON_OPS)) {
    coercedValue = hasArrayValue ? d2cValue(value[0]) : d2cValue(value);
  } else if (isOperationIn(INTERVAL_OPS)) {
    coercedValue = hasArrayValue ? [d2cValue(value[0]), d2cValue(value[1])] : [d2cValue(value), d2cValue(value)];
  } else if (isOperationIn(SET_OPS)) {
    coercedValue = hasArrayValue ? value.map(d2cValue) : [d2cValue(value)];
  }
  switch (operation) {
    case '=':
      return function (v) {
        return d2cTarget(v) === coercedValue;
      };
    case '!=':
      return function (v) {
        return d2cTarget(v) !== coercedValue;
      };
    case '<':
      return function (v) {
        return d2cTarget(v) < coercedValue;
      };
    case '<=':
      return function (v) {
        return d2cTarget(v) <= coercedValue;
      };
    case '>':
      return function (v) {
        return d2cTarget(v) > coercedValue;
      };
    case '>=':
      return function (v) {
        return d2cTarget(v) >= coercedValue;
      };
    case '[]':
      return function (v) {
        var cv = d2cTarget(v);
        return cv >= coercedValue[0] && cv <= coercedValue[1];
      };
    case '()':
      return function (v) {
        var cv = d2cTarget(v);
        return cv > coercedValue[0] && cv < coercedValue[1];
      };
    case '[)':
      return function (v) {
        var cv = d2cTarget(v);
        return cv >= coercedValue[0] && cv < coercedValue[1];
      };
    case '(]':
      return function (v) {
        var cv = d2cTarget(v);
        return cv > coercedValue[0] && cv <= coercedValue[1];
      };
    case '][':
      return function (v) {
        var cv = d2cTarget(v);
        return cv <= coercedValue[0] || cv >= coercedValue[1];
      };
    case ')(':
      return function (v) {
        var cv = d2cTarget(v);
        return cv < coercedValue[0] || cv > coercedValue[1];
      };
    case '](':
      return function (v) {
        var cv = d2cTarget(v);
        return cv <= coercedValue[0] || cv > coercedValue[1];
      };
    case ')[':
      return function (v) {
        var cv = d2cTarget(v);
        return cv < coercedValue[0] || cv >= coercedValue[1];
      };
    case '{}':
      return function (v) {
        return coercedValue.indexOf(d2cTarget(v)) !== -1;
      };
    case '}{':
      return function (v) {
        return coercedValue.indexOf(d2cTarget(v)) === -1;
      };
  }
}

/***/ }),

/***/ 3102:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var PlotSchema = __webpack_require__(6281);
var Plots = __webpack_require__(4875);
var pointsAccessorFunction = (__webpack_require__(9344)/* .pointsAccessorFunction */ .p);
exports.moduleType = 'transform';
exports.name = 'groupby';
exports.attributes = {
  enabled: {
    valType: 'boolean',
    dflt: true,
    editType: 'calc'
  },
  groups: {
    valType: 'data_array',
    dflt: [],
    editType: 'calc'
  },
  nameformat: {
    valType: 'string',
    editType: 'calc'
  },
  styles: {
    _isLinkedToArray: 'style',
    target: {
      valType: 'string',
      editType: 'calc'
    },
    value: {
      valType: 'any',
      dflt: {},
      editType: 'calc',
      _compareAsJSON: true
    },
    editType: 'calc'
  },
  editType: 'calc'
};

/**
 * Supply transform attributes defaults
 *
 * @param {object} transformIn
 *  object linked to trace.transforms[i] with 'type' set to exports.name
 * @param {object} traceOut
 *  the _fullData trace this transform applies to
 * @param {object} layout
 *  the plot's (not-so-full) layout
 * @param {object} traceIn
 *  the input data trace this transform applies to
 *
 * @return {object} transformOut
 *  copy of transformIn that contains attribute defaults
 */
exports.supplyDefaults = function (transformIn, traceOut, layout) {
  var i;
  var transformOut = {};
  function coerce(attr, dflt) {
    return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);
  }
  var enabled = coerce('enabled');
  if (!enabled) return transformOut;
  coerce('groups');
  coerce('nameformat', layout._dataLength > 1 ? '%{group} (%{trace})' : '%{group}');
  var styleIn = transformIn.styles;
  var styleOut = transformOut.styles = [];
  if (styleIn) {
    for (i = 0; i < styleIn.length; i++) {
      var thisStyle = styleOut[i] = {};
      Lib.coerce(styleIn[i], styleOut[i], exports.attributes.styles, 'target');
      var value = Lib.coerce(styleIn[i], styleOut[i], exports.attributes.styles, 'value');

      // so that you can edit value in place and have Plotly.react notice it, or
      // rebuild it every time and have Plotly.react NOT think it changed:
      // use _compareAsJSON to say we should diff the _JSON_value
      if (Lib.isPlainObject(value)) thisStyle.value = Lib.extendDeep({}, value);else if (value) delete thisStyle.value;
    }
  }
  return transformOut;
};

/**
 * Apply transform !!!
 *
 * @param {array} data
 *  array of transformed traces (is [fullTrace] upon first transform)
 *
 * @param {object} state
 *  state object which includes:
 *      - transform {object} full transform attributes
 *      - fullTrace {object} full trace object which is being transformed
 *      - fullData {array} full pre-transform(s) data array
 *      - layout {object} the plot's (not-so-full) layout
 *
 * @return {object} newData
 *  array of transformed traces
 */
exports.transform = function (data, state) {
  var newTraces, i, j;
  var newData = [];
  for (i = 0; i < data.length; i++) {
    newTraces = transformOne(data[i], state);
    for (j = 0; j < newTraces.length; j++) {
      newData.push(newTraces[j]);
    }
  }
  return newData;
};
function transformOne(trace, state) {
  var i, j, k, attr, srcArray, groupName, newTrace, transforms, arrayLookup;
  var groupNameObj;
  var opts = state.transform;
  var transformIndex = state.transformIndex;
  var groups = trace.transforms[transformIndex].groups;
  var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);
  if (!Lib.isArrayOrTypedArray(groups) || groups.length === 0) {
    return [trace];
  }
  var groupNames = Lib.filterUnique(groups);
  var newData = new Array(groupNames.length);
  var len = groups.length;
  var arrayAttrs = PlotSchema.findArrayAttributes(trace);
  var styles = opts.styles || [];
  var styleLookup = {};
  for (i = 0; i < styles.length; i++) {
    styleLookup[styles[i].target] = styles[i].value;
  }
  if (opts.styles) {
    groupNameObj = Lib.keyedContainer(opts, 'styles', 'target', 'value.name');
  }

  // An index to map group name --> expanded trace index
  var indexLookup = {};
  var indexCnts = {};
  for (i = 0; i < groupNames.length; i++) {
    groupName = groupNames[i];
    indexLookup[groupName] = i;
    indexCnts[groupName] = 0;

    // Start with a deep extend that just copies array references.
    newTrace = newData[i] = Lib.extendDeepNoArrays({}, trace);
    newTrace._group = groupName;
    newTrace.transforms[transformIndex]._indexToPoints = {};
    var suppliedName = null;
    if (groupNameObj) {
      suppliedName = groupNameObj.get(groupName);
    }
    if (suppliedName || suppliedName === '') {
      newTrace.name = suppliedName;
    } else {
      newTrace.name = Lib.templateString(opts.nameformat, {
        trace: trace.name,
        group: groupName
      });
    }

    // In order for groups to apply correctly to other transform data (e.g.
    // a filter transform), we have to break the connection and clone the
    // transforms so that each group writes grouped values into a different
    // destination. This function does not break the array reference
    // connection between the split transforms it creates. That's handled in
    // initialize, which creates a new empty array for each arrayAttr.
    transforms = newTrace.transforms;
    newTrace.transforms = [];
    for (j = 0; j < transforms.length; j++) {
      newTrace.transforms[j] = Lib.extendDeepNoArrays({}, transforms[j]);
    }

    // Initialize empty arrays for the arrayAttrs, to be split in the next step
    for (j = 0; j < arrayAttrs.length; j++) {
      Lib.nestedProperty(newTrace, arrayAttrs[j]).set([]);
    }
  }

  // For each array attribute including those nested inside this and other
  // transforms (small note that we technically only need to do this for
  // transforms that have not yet been applied):
  for (k = 0; k < arrayAttrs.length; k++) {
    attr = arrayAttrs[k];

    // Cache all the arrays to which we'll push:
    for (j = 0, arrayLookup = []; j < groupNames.length; j++) {
      arrayLookup[j] = Lib.nestedProperty(newData[j], attr).get();
    }

    // Get the input data:
    srcArray = Lib.nestedProperty(trace, attr).get();

    // Send each data point to the appropriate expanded trace:
    for (j = 0; j < len; j++) {
      // Map group data --> trace index --> array and push data onto it
      arrayLookup[indexLookup[groups[j]]].push(srcArray[j]);
    }
  }
  for (j = 0; j < len; j++) {
    newTrace = newData[indexLookup[groups[j]]];
    var indexToPoints = newTrace.transforms[transformIndex]._indexToPoints;
    indexToPoints[indexCnts[groups[j]]] = originalPointsAccessor(j);
    indexCnts[groups[j]]++;
  }
  for (i = 0; i < groupNames.length; i++) {
    groupName = groupNames[i];
    newTrace = newData[i];
    Plots.clearExpandedTraceDefaultColors(newTrace);

    // there's no need to coerce styleLookup[groupName] here
    // as another round of supplyDefaults is done on the transformed traces
    newTrace = Lib.extendDeepNoArrays(newTrace, styleLookup[groupName] || {});
  }
  return newData;
}

/***/ }),

/***/ 9344:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.p = function (transforms, opts) {
  var tr;
  var prevIndexToPoints;
  for (var i = 0; i < transforms.length; i++) {
    tr = transforms[i];
    if (tr === opts) break;
    if (!tr._indexToPoints || tr.enabled === false) continue;
    prevIndexToPoints = tr._indexToPoints;
  }
  var originalPointsAccessor = prevIndexToPoints ? function (i) {
    return prevIndexToPoints[i];
  } : function (i) {
    return [i];
  };
  return originalPointsAccessor;
};

/***/ }),

/***/ 2275:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var Lib = __webpack_require__(1828);
var Axes = __webpack_require__(9298);
var pointsAccessorFunction = (__webpack_require__(9344)/* .pointsAccessorFunction */ .p);
var BADNUM = (__webpack_require__(606).BADNUM);
exports.moduleType = 'transform';
exports.name = 'sort';
exports.attributes = {
  enabled: {
    valType: 'boolean',
    dflt: true,
    editType: 'calc'
  },
  target: {
    valType: 'string',
    strict: true,
    noBlank: true,
    arrayOk: true,
    dflt: 'x',
    editType: 'calc'
  },
  order: {
    valType: 'enumerated',
    values: ['ascending', 'descending'],
    dflt: 'ascending',
    editType: 'calc'
  },
  editType: 'calc'
};
exports.supplyDefaults = function (transformIn) {
  var transformOut = {};
  function coerce(attr, dflt) {
    return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);
  }
  var enabled = coerce('enabled');
  if (enabled) {
    coerce('target');
    coerce('order');
  }
  return transformOut;
};
exports.calcTransform = function (gd, trace, opts) {
  if (!opts.enabled) return;
  var targetArray = Lib.getTargetArray(trace, opts);
  if (!targetArray) return;
  var target = opts.target;
  var len = targetArray.length;
  if (trace._length) len = Math.min(len, trace._length);
  var arrayAttrs = trace._arrayAttrs;
  var d2c = Axes.getDataToCoordFunc(gd, trace, target, targetArray);
  var indices = getIndices(opts, targetArray, d2c, len);
  var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);
  var indexToPoints = {};
  var i, j;
  for (i = 0; i < arrayAttrs.length; i++) {
    var np = Lib.nestedProperty(trace, arrayAttrs[i]);
    var arrayOld = np.get();
    var arrayNew = new Array(len);
    for (j = 0; j < len; j++) {
      arrayNew[j] = arrayOld[indices[j]];
    }
    np.set(arrayNew);
  }
  for (j = 0; j < len; j++) {
    indexToPoints[j] = originalPointsAccessor(indices[j]);
  }
  opts._indexToPoints = indexToPoints;
  trace._length = len;
};
function getIndices(opts, targetArray, d2c, len) {
  var sortedArray = new Array(len);
  var indices = new Array(len);
  var i;
  for (i = 0; i < len; i++) {
    sortedArray[i] = {
      v: targetArray[i],
      i: i
    };
  }
  sortedArray.sort(getSortFunc(opts, d2c));
  for (i = 0; i < len; i++) {
    indices[i] = sortedArray[i].i;
  }
  return indices;
}
function getSortFunc(opts, d2c) {
  switch (opts.order) {
    case 'ascending':
      return function (a, b) {
        var ac = d2c(a.v);
        var bc = d2c(b.v);
        if (ac === BADNUM) {
          return 1;
        }
        if (bc === BADNUM) {
          return -1;
        }
        return ac - bc;
      };
    case 'descending':
      return function (a, b) {
        var ac = d2c(a.v);
        var bc = d2c(b.v);
        if (ac === BADNUM) {
          return 1;
        }
        if (bc === BADNUM) {
          return -1;
        }
        return bc - ac;
      };
  }
}

/***/ }),

/***/ 1506:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


// package version injected by `npm run preprocess`
exports.version = '2.27.1';

/***/ }),

/***/ 9330:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* provided dependency */ var process = __webpack_require__(386);
(function webpackUniversalModuleDefinition(root,factory){if(true)module.exports=factory();else {}})(self,function(){return(/******/function(){// webpackBootstrap
/******/var __webpack_modules__={/***/7386:/***/function(module,__unused_webpack_exports,__nested_webpack_require_451__){module.exports={alpha_shape:__nested_webpack_require_451__(2350),convex_hull:__nested_webpack_require_451__(5537),delaunay_triangulate:__nested_webpack_require_451__(4419),gl_cone3d:__nested_webpack_require_451__(1140),gl_error3d:__nested_webpack_require_451__(3110),gl_heatmap2d:__nested_webpack_require_451__(6386),gl_line3d:__nested_webpack_require_451__(6086),gl_mesh3d:__nested_webpack_require_451__(8116),gl_plot2d:__nested_webpack_require_451__(2117),gl_plot3d:__nested_webpack_require_451__(1059),gl_pointcloud2d:__nested_webpack_require_451__(8271),gl_scatter3d:__nested_webpack_require_451__(2182),gl_select_box:__nested_webpack_require_451__(6623),gl_spikes2d:__nested_webpack_require_451__(3050),gl_streamtube3d:__nested_webpack_require_451__(7307),gl_surface3d:__nested_webpack_require_451__(3754),ndarray:__nested_webpack_require_451__(5050),ndarray_linear_interpolate:__nested_webpack_require_451__(3581)};/***/},/***/2146:/***/function(__unused_webpack_module,exports,__nested_webpack_require_1258__){"use strict";var __webpack_unused_export__;/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);Object.defineProperty(Constructor,"prototype",{writable:false});return Constructor;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function");}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:true,configurable:true}});Object.defineProperty(subClass,"prototype",{writable:false});if(superClass)_setPrototypeOf(subClass,superClass);}function _setPrototypeOf(o,p){_setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function _setPrototypeOf(o,p){o.__proto__=p;return o;};return _setPrototypeOf(o,p);}function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _possibleConstructorReturn(self,call){if(call&&(_typeof(call)==="object"||typeof call==="function")){return call;}else if(call!==void 0){throw new TypeError("Derived constructors may only return object or undefined");}return _assertThisInitialized(self);}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _typeof(obj){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj;}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;},_typeof(obj);}var base64=__nested_webpack_require_1258__(3910);var ieee754=__nested_webpack_require_1258__(3187);var customInspectSymbol=typeof Symbol==='function'&&typeof Symbol['for']==='function'// eslint-disable-line dot-notation
?Symbol['for']('nodejs.util.inspect.custom')// eslint-disable-line dot-notation
:null;exports.lW=Buffer;__webpack_unused_export__=SlowBuffer;exports.h2=50;var K_MAX_LENGTH=0x7fffffff;__webpack_unused_export__=K_MAX_LENGTH;/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!=='undefined'&&typeof console.error==='function'){console.error('This browser lacks typed array (Uint8Array) support which is required by '+'`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');}function typedArraySupport(){// Can typed array instances can be augmented?
try{var arr=new Uint8Array(1);var proto={foo:function foo(){return 42;}};Object.setPrototypeOf(proto,Uint8Array.prototype);Object.setPrototypeOf(arr,proto);return arr.foo()===42;}catch(e){return false;}}Object.defineProperty(Buffer.prototype,'parent',{enumerable:true,get:function get(){if(!Buffer.isBuffer(this))return undefined;return this.buffer;}});Object.defineProperty(Buffer.prototype,'offset',{enumerable:true,get:function get(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset;}});function createBuffer(length){if(length>K_MAX_LENGTH){throw new RangeError('The value "'+length+'" is invalid for option "size"');}// Return an augmented `Uint8Array` instance
var buf=new Uint8Array(length);Object.setPrototypeOf(buf,Buffer.prototype);return buf;}/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */function Buffer(arg,encodingOrOffset,length){// Common case.
if(typeof arg==='number'){if(typeof encodingOrOffset==='string'){throw new TypeError('The "string" argument must be of type string. Received type number');}return allocUnsafe(arg);}return from(arg,encodingOrOffset,length);}Buffer.poolSize=8192;// not used by this implementation
function from(value,encodingOrOffset,length){if(typeof value==='string'){return fromString(value,encodingOrOffset);}if(ArrayBuffer.isView(value)){return fromArrayView(value);}if(value==null){throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, '+'or Array-like Object. Received type '+_typeof(value));}if(isInstance(value,ArrayBuffer)||value&&isInstance(value.buffer,ArrayBuffer)){return fromArrayBuffer(value,encodingOrOffset,length);}if(typeof SharedArrayBuffer!=='undefined'&&(isInstance(value,SharedArrayBuffer)||value&&isInstance(value.buffer,SharedArrayBuffer))){return fromArrayBuffer(value,encodingOrOffset,length);}if(typeof value==='number'){throw new TypeError('The "value" argument must not be of type number. Received type number');}var valueOf=value.valueOf&&value.valueOf();if(valueOf!=null&&valueOf!==value){return Buffer.from(valueOf,encodingOrOffset,length);}var b=fromObject(value);if(b)return b;if(typeof Symbol!=='undefined'&&Symbol.toPrimitive!=null&&typeof value[Symbol.toPrimitive]==='function'){return Buffer.from(value[Symbol.toPrimitive]('string'),encodingOrOffset,length);}throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, '+'or Array-like Object. Received type '+_typeof(value));}/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/Buffer.from=function(value,encodingOrOffset,length){return from(value,encodingOrOffset,length);};// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);function assertSize(size){if(typeof size!=='number'){throw new TypeError('"size" argument must be of type number');}else if(size<0){throw new RangeError('The value "'+size+'" is invalid for option "size"');}}function alloc(size,fill,encoding){assertSize(size);if(size<=0){return createBuffer(size);}if(fill!==undefined){// Only pay attention to encoding if it's a string. This
// prevents accidentally sending in a number that would
// be interpreted as a start offset.
return typeof encoding==='string'?createBuffer(size).fill(fill,encoding):createBuffer(size).fill(fill);}return createBuffer(size);}/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/Buffer.alloc=function(size,fill,encoding){return alloc(size,fill,encoding);};function allocUnsafe(size){assertSize(size);return createBuffer(size<0?0:checked(size)|0);}/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */Buffer.allocUnsafe=function(size){return allocUnsafe(size);};/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */Buffer.allocUnsafeSlow=function(size){return allocUnsafe(size);};function fromString(string,encoding){if(typeof encoding!=='string'||encoding===''){encoding='utf8';}if(!Buffer.isEncoding(encoding)){throw new TypeError('Unknown encoding: '+encoding);}var length=byteLength(string,encoding)|0;var buf=createBuffer(length);var actual=buf.write(string,encoding);if(actual!==length){// Writing a hex string, for example, that contains invalid characters will
// cause everything after the first invalid character to be ignored. (e.g.
// 'abxxcd' will be treated as 'ab')
buf=buf.slice(0,actual);}return buf;}function fromArrayLike(array){var length=array.length<0?0:checked(array.length)|0;var buf=createBuffer(length);for(var i=0;i<length;i+=1){buf[i]=array[i]&255;}return buf;}function fromArrayView(arrayView){if(isInstance(arrayView,Uint8Array)){var copy=new Uint8Array(arrayView);return fromArrayBuffer(copy.buffer,copy.byteOffset,copy.byteLength);}return fromArrayLike(arrayView);}function fromArrayBuffer(array,byteOffset,length){if(byteOffset<0||array.byteLength<byteOffset){throw new RangeError('"offset" is outside of buffer bounds');}if(array.byteLength<byteOffset+(length||0)){throw new RangeError('"length" is outside of buffer bounds');}var buf;if(byteOffset===undefined&&length===undefined){buf=new Uint8Array(array);}else if(length===undefined){buf=new Uint8Array(array,byteOffset);}else{buf=new Uint8Array(array,byteOffset,length);}// Return an augmented `Uint8Array` instance
Object.setPrototypeOf(buf,Buffer.prototype);return buf;}function fromObject(obj){if(Buffer.isBuffer(obj)){var len=checked(obj.length)|0;var buf=createBuffer(len);if(buf.length===0){return buf;}obj.copy(buf,0,0,len);return buf;}if(obj.length!==undefined){if(typeof obj.length!=='number'||numberIsNaN(obj.length)){return createBuffer(0);}return fromArrayLike(obj);}if(obj.type==='Buffer'&&Array.isArray(obj.data)){return fromArrayLike(obj.data);}}function checked(length){// Note: cannot use `length < K_MAX_LENGTH` here because that fails when
// length is NaN (which is otherwise coerced to zero.)
if(length>=K_MAX_LENGTH){throw new RangeError('Attempt to allocate Buffer larger than maximum '+'size: 0x'+K_MAX_LENGTH.toString(16)+' bytes');}return length|0;}function SlowBuffer(length){if(+length!=length){// eslint-disable-line eqeqeq
length=0;}return Buffer.alloc(+length);}Buffer.isBuffer=function isBuffer(b){return b!=null&&b._isBuffer===true&&b!==Buffer.prototype;// so Buffer.isBuffer(Buffer.prototype) will be false
};Buffer.compare=function compare(a,b){if(isInstance(a,Uint8Array))a=Buffer.from(a,a.offset,a.byteLength);if(isInstance(b,Uint8Array))b=Buffer.from(b,b.offset,b.byteLength);if(!Buffer.isBuffer(a)||!Buffer.isBuffer(b)){throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');}if(a===b)return 0;var x=a.length;var y=b.length;for(var i=0,len=Math.min(x,y);i<len;++i){if(a[i]!==b[i]){x=a[i];y=b[i];break;}}if(x<y)return-1;if(y<x)return 1;return 0;};Buffer.isEncoding=function isEncoding(encoding){switch(String(encoding).toLowerCase()){case'hex':case'utf8':case'utf-8':case'ascii':case'latin1':case'binary':case'base64':case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return true;default:return false;}};Buffer.concat=function concat(list,length){if(!Array.isArray(list)){throw new TypeError('"list" argument must be an Array of Buffers');}if(list.length===0){return Buffer.alloc(0);}var i;if(length===undefined){length=0;for(i=0;i<list.length;++i){length+=list[i].length;}}var buffer=Buffer.allocUnsafe(length);var pos=0;for(i=0;i<list.length;++i){var buf=list[i];if(isInstance(buf,Uint8Array)){if(pos+buf.length>buffer.length){if(!Buffer.isBuffer(buf))buf=Buffer.from(buf);buf.copy(buffer,pos);}else{Uint8Array.prototype.set.call(buffer,buf,pos);}}else if(!Buffer.isBuffer(buf)){throw new TypeError('"list" argument must be an Array of Buffers');}else{buf.copy(buffer,pos);}pos+=buf.length;}return buffer;};function byteLength(string,encoding){if(Buffer.isBuffer(string)){return string.length;}if(ArrayBuffer.isView(string)||isInstance(string,ArrayBuffer)){return string.byteLength;}if(typeof string!=='string'){throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. '+'Received type '+_typeof(string));}var len=string.length;var mustMatch=arguments.length>2&&arguments[2]===true;if(!mustMatch&&len===0)return 0;// Use a for loop to avoid recursion
var loweredCase=false;for(;;){switch(encoding){case'ascii':case'latin1':case'binary':return len;case'utf8':case'utf-8':return utf8ToBytes(string).length;case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return len*2;case'hex':return len>>>1;case'base64':return base64ToBytes(string).length;default:if(loweredCase){return mustMatch?-1:utf8ToBytes(string).length;// assume utf8
}encoding=(''+encoding).toLowerCase();loweredCase=true;}}}Buffer.byteLength=byteLength;function slowToString(encoding,start,end){var loweredCase=false;// No need to verify that "this.length <= MAX_UINT32" since it's a read-only
// property of a typed array.
// This behaves neither like String nor Uint8Array in that we set start/end
// to their upper/lower bounds if the value passed is out of range.
// undefined is handled specially as per ECMA-262 6th Edition,
// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
if(start===undefined||start<0){start=0;}// Return early if start > this.length. Done here to prevent potential uint32
// coercion fail below.
if(start>this.length){return'';}if(end===undefined||end>this.length){end=this.length;}if(end<=0){return'';}// Force coercion to uint32. This will also coerce falsey/NaN values to 0.
end>>>=0;start>>>=0;if(end<=start){return'';}if(!encoding)encoding='utf8';while(true){switch(encoding){case'hex':return hexSlice(this,start,end);case'utf8':case'utf-8':return utf8Slice(this,start,end);case'ascii':return asciiSlice(this,start,end);case'latin1':case'binary':return latin1Slice(this,start,end);case'base64':return base64Slice(this,start,end);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return utf16leSlice(this,start,end);default:if(loweredCase)throw new TypeError('Unknown encoding: '+encoding);encoding=(encoding+'').toLowerCase();loweredCase=true;}}}// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer=true;function swap(b,n,m){var i=b[n];b[n]=b[m];b[m]=i;}Buffer.prototype.swap16=function swap16(){var len=this.length;if(len%2!==0){throw new RangeError('Buffer size must be a multiple of 16-bits');}for(var i=0;i<len;i+=2){swap(this,i,i+1);}return this;};Buffer.prototype.swap32=function swap32(){var len=this.length;if(len%4!==0){throw new RangeError('Buffer size must be a multiple of 32-bits');}for(var i=0;i<len;i+=4){swap(this,i,i+3);swap(this,i+1,i+2);}return this;};Buffer.prototype.swap64=function swap64(){var len=this.length;if(len%8!==0){throw new RangeError('Buffer size must be a multiple of 64-bits');}for(var i=0;i<len;i+=8){swap(this,i,i+7);swap(this,i+1,i+6);swap(this,i+2,i+5);swap(this,i+3,i+4);}return this;};Buffer.prototype.toString=function toString(){var length=this.length;if(length===0)return'';if(arguments.length===0)return utf8Slice(this,0,length);return slowToString.apply(this,arguments);};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(b){if(!Buffer.isBuffer(b))throw new TypeError('Argument must be a Buffer');if(this===b)return true;return Buffer.compare(this,b)===0;};Buffer.prototype.inspect=function inspect(){var str='';var max=exports.h2;str=this.toString('hex',0,max).replace(/(.{2})/g,'$1 ').trim();if(this.length>max)str+=' ... ';return'<Buffer '+str+'>';};if(customInspectSymbol){Buffer.prototype[customInspectSymbol]=Buffer.prototype.inspect;}Buffer.prototype.compare=function compare(target,start,end,thisStart,thisEnd){if(isInstance(target,Uint8Array)){target=Buffer.from(target,target.offset,target.byteLength);}if(!Buffer.isBuffer(target)){throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. '+'Received type '+_typeof(target));}if(start===undefined){start=0;}if(end===undefined){end=target?target.length:0;}if(thisStart===undefined){thisStart=0;}if(thisEnd===undefined){thisEnd=this.length;}if(start<0||end>target.length||thisStart<0||thisEnd>this.length){throw new RangeError('out of range index');}if(thisStart>=thisEnd&&start>=end){return 0;}if(thisStart>=thisEnd){return-1;}if(start>=end){return 1;}start>>>=0;end>>>=0;thisStart>>>=0;thisEnd>>>=0;if(this===target)return 0;var x=thisEnd-thisStart;var y=end-start;var len=Math.min(x,y);var thisCopy=this.slice(thisStart,thisEnd);var targetCopy=target.slice(start,end);for(var i=0;i<len;++i){if(thisCopy[i]!==targetCopy[i]){x=thisCopy[i];y=targetCopy[i];break;}}if(x<y)return-1;if(y<x)return 1;return 0;};// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer,val,byteOffset,encoding,dir){// Empty buffer means no match
if(buffer.length===0)return-1;// Normalize byteOffset
if(typeof byteOffset==='string'){encoding=byteOffset;byteOffset=0;}else if(byteOffset>0x7fffffff){byteOffset=0x7fffffff;}else if(byteOffset<-0x80000000){byteOffset=-0x80000000;}byteOffset=+byteOffset;// Coerce to Number.
if(numberIsNaN(byteOffset)){// byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
byteOffset=dir?0:buffer.length-1;}// Normalize byteOffset: negative offsets start from the end of the buffer
if(byteOffset<0)byteOffset=buffer.length+byteOffset;if(byteOffset>=buffer.length){if(dir)return-1;else byteOffset=buffer.length-1;}else if(byteOffset<0){if(dir)byteOffset=0;else return-1;}// Normalize val
if(typeof val==='string'){val=Buffer.from(val,encoding);}// Finally, search either indexOf (if dir is true) or lastIndexOf
if(Buffer.isBuffer(val)){// Special case: looking for empty string/buffer always fails
if(val.length===0){return-1;}return arrayIndexOf(buffer,val,byteOffset,encoding,dir);}else if(typeof val==='number'){val=val&0xFF;// Search for a byte value [0-255]
if(typeof Uint8Array.prototype.indexOf==='function'){if(dir){return Uint8Array.prototype.indexOf.call(buffer,val,byteOffset);}else{return Uint8Array.prototype.lastIndexOf.call(buffer,val,byteOffset);}}return arrayIndexOf(buffer,[val],byteOffset,encoding,dir);}throw new TypeError('val must be string, number or Buffer');}function arrayIndexOf(arr,val,byteOffset,encoding,dir){var indexSize=1;var arrLength=arr.length;var valLength=val.length;if(encoding!==undefined){encoding=String(encoding).toLowerCase();if(encoding==='ucs2'||encoding==='ucs-2'||encoding==='utf16le'||encoding==='utf-16le'){if(arr.length<2||val.length<2){return-1;}indexSize=2;arrLength/=2;valLength/=2;byteOffset/=2;}}function read(buf,i){if(indexSize===1){return buf[i];}else{return buf.readUInt16BE(i*indexSize);}}var i;if(dir){var foundIndex=-1;for(i=byteOffset;i<arrLength;i++){if(read(arr,i)===read(val,foundIndex===-1?0:i-foundIndex)){if(foundIndex===-1)foundIndex=i;if(i-foundIndex+1===valLength)return foundIndex*indexSize;}else{if(foundIndex!==-1)i-=i-foundIndex;foundIndex=-1;}}}else{if(byteOffset+valLength>arrLength)byteOffset=arrLength-valLength;for(i=byteOffset;i>=0;i--){var found=true;for(var j=0;j<valLength;j++){if(read(arr,i+j)!==read(val,j)){found=false;break;}}if(found)return i;}}return-1;}Buffer.prototype.includes=function includes(val,byteOffset,encoding){return this.indexOf(val,byteOffset,encoding)!==-1;};Buffer.prototype.indexOf=function indexOf(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,true);};Buffer.prototype.lastIndexOf=function lastIndexOf(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,false);};function hexWrite(buf,string,offset,length){offset=Number(offset)||0;var remaining=buf.length-offset;if(!length){length=remaining;}else{length=Number(length);if(length>remaining){length=remaining;}}var strLen=string.length;if(length>strLen/2){length=strLen/2;}var i;for(i=0;i<length;++i){var parsed=parseInt(string.substr(i*2,2),16);if(numberIsNaN(parsed))return i;buf[offset+i]=parsed;}return i;}function utf8Write(buf,string,offset,length){return blitBuffer(utf8ToBytes(string,buf.length-offset),buf,offset,length);}function asciiWrite(buf,string,offset,length){return blitBuffer(asciiToBytes(string),buf,offset,length);}function base64Write(buf,string,offset,length){return blitBuffer(base64ToBytes(string),buf,offset,length);}function ucs2Write(buf,string,offset,length){return blitBuffer(utf16leToBytes(string,buf.length-offset),buf,offset,length);}Buffer.prototype.write=function write(string,offset,length,encoding){// Buffer#write(string)
if(offset===undefined){encoding='utf8';length=this.length;offset=0;// Buffer#write(string, encoding)
}else if(length===undefined&&typeof offset==='string'){encoding=offset;length=this.length;offset=0;// Buffer#write(string, offset[, length][, encoding])
}else if(isFinite(offset)){offset=offset>>>0;if(isFinite(length)){length=length>>>0;if(encoding===undefined)encoding='utf8';}else{encoding=length;length=undefined;}}else{throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');}var remaining=this.length-offset;if(length===undefined||length>remaining)length=remaining;if(string.length>0&&(length<0||offset<0)||offset>this.length){throw new RangeError('Attempt to write outside buffer bounds');}if(!encoding)encoding='utf8';var loweredCase=false;for(;;){switch(encoding){case'hex':return hexWrite(this,string,offset,length);case'utf8':case'utf-8':return utf8Write(this,string,offset,length);case'ascii':case'latin1':case'binary':return asciiWrite(this,string,offset,length);case'base64':// Warning: maxLength not taken into account in base64Write
return base64Write(this,string,offset,length);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return ucs2Write(this,string,offset,length);default:if(loweredCase)throw new TypeError('Unknown encoding: '+encoding);encoding=(''+encoding).toLowerCase();loweredCase=true;}}};Buffer.prototype.toJSON=function toJSON(){return{type:'Buffer',data:Array.prototype.slice.call(this._arr||this,0)};};function base64Slice(buf,start,end){if(start===0&&end===buf.length){return base64.fromByteArray(buf);}else{return base64.fromByteArray(buf.slice(start,end));}}function utf8Slice(buf,start,end){end=Math.min(buf.length,end);var res=[];var i=start;while(i<end){var firstByte=buf[i];var codePoint=null;var bytesPerSequence=firstByte>0xEF?4:firstByte>0xDF?3:firstByte>0xBF?2:1;if(i+bytesPerSequence<=end){var secondByte=void 0,thirdByte=void 0,fourthByte=void 0,tempCodePoint=void 0;switch(bytesPerSequence){case 1:if(firstByte<0x80){codePoint=firstByte;}break;case 2:secondByte=buf[i+1];if((secondByte&0xC0)===0x80){tempCodePoint=(firstByte&0x1F)<<0x6|secondByte&0x3F;if(tempCodePoint>0x7F){codePoint=tempCodePoint;}}break;case 3:secondByte=buf[i+1];thirdByte=buf[i+2];if((secondByte&0xC0)===0x80&&(thirdByte&0xC0)===0x80){tempCodePoint=(firstByte&0xF)<<0xC|(secondByte&0x3F)<<0x6|thirdByte&0x3F;if(tempCodePoint>0x7FF&&(tempCodePoint<0xD800||tempCodePoint>0xDFFF)){codePoint=tempCodePoint;}}break;case 4:secondByte=buf[i+1];thirdByte=buf[i+2];fourthByte=buf[i+3];if((secondByte&0xC0)===0x80&&(thirdByte&0xC0)===0x80&&(fourthByte&0xC0)===0x80){tempCodePoint=(firstByte&0xF)<<0x12|(secondByte&0x3F)<<0xC|(thirdByte&0x3F)<<0x6|fourthByte&0x3F;if(tempCodePoint>0xFFFF&&tempCodePoint<0x110000){codePoint=tempCodePoint;}}}}if(codePoint===null){// we did not generate a valid codePoint so insert a
// replacement char (U+FFFD) and advance only 1 byte
codePoint=0xFFFD;bytesPerSequence=1;}else if(codePoint>0xFFFF){// encode to utf16 (surrogate pair dance)
codePoint-=0x10000;res.push(codePoint>>>10&0x3FF|0xD800);codePoint=0xDC00|codePoint&0x3FF;}res.push(codePoint);i+=bytesPerSequence;}return decodeCodePointsArray(res);}// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH=0x1000;function decodeCodePointsArray(codePoints){var len=codePoints.length;if(len<=MAX_ARGUMENTS_LENGTH){return String.fromCharCode.apply(String,codePoints);// avoid extra slice()
}// Decode in chunks to avoid "call stack size exceeded".
var res='';var i=0;while(i<len){res+=String.fromCharCode.apply(String,codePoints.slice(i,i+=MAX_ARGUMENTS_LENGTH));}return res;}function asciiSlice(buf,start,end){var ret='';end=Math.min(buf.length,end);for(var i=start;i<end;++i){ret+=String.fromCharCode(buf[i]&0x7F);}return ret;}function latin1Slice(buf,start,end){var ret='';end=Math.min(buf.length,end);for(var i=start;i<end;++i){ret+=String.fromCharCode(buf[i]);}return ret;}function hexSlice(buf,start,end){var len=buf.length;if(!start||start<0)start=0;if(!end||end<0||end>len)end=len;var out='';for(var i=start;i<end;++i){out+=hexSliceLookupTable[buf[i]];}return out;}function utf16leSlice(buf,start,end){var bytes=buf.slice(start,end);var res='';// If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
for(var i=0;i<bytes.length-1;i+=2){res+=String.fromCharCode(bytes[i]+bytes[i+1]*256);}return res;}Buffer.prototype.slice=function slice(start,end){var len=this.length;start=~~start;end=end===undefined?len:~~end;if(start<0){start+=len;if(start<0)start=0;}else if(start>len){start=len;}if(end<0){end+=len;if(end<0)end=0;}else if(end>len){end=len;}if(end<start)end=start;var newBuf=this.subarray(start,end);// Return an augmented `Uint8Array` instance
Object.setPrototypeOf(newBuf,Buffer.prototype);return newBuf;};/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */function checkOffset(offset,ext,length){if(offset%1!==0||offset<0)throw new RangeError('offset is not uint');if(offset+ext>length)throw new RangeError('Trying to access beyond buffer length');}Buffer.prototype.readUintLE=Buffer.prototype.readUIntLE=function readUIntLE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var val=this[offset];var mul=1;var i=0;while(++i<byteLength&&(mul*=0x100)){val+=this[offset+i]*mul;}return val;};Buffer.prototype.readUintBE=Buffer.prototype.readUIntBE=function readUIntBE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){checkOffset(offset,byteLength,this.length);}var val=this[offset+--byteLength];var mul=1;while(byteLength>0&&(mul*=0x100)){val+=this[offset+--byteLength]*mul;}return val;};Buffer.prototype.readUint8=Buffer.prototype.readUInt8=function readUInt8(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,1,this.length);return this[offset];};Buffer.prototype.readUint16LE=Buffer.prototype.readUInt16LE=function readUInt16LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);return this[offset]|this[offset+1]<<8;};Buffer.prototype.readUint16BE=Buffer.prototype.readUInt16BE=function readUInt16BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);return this[offset]<<8|this[offset+1];};Buffer.prototype.readUint32LE=Buffer.prototype.readUInt32LE=function readUInt32LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return(this[offset]|this[offset+1]<<8|this[offset+2]<<16)+this[offset+3]*0x1000000;};Buffer.prototype.readUint32BE=Buffer.prototype.readUInt32BE=function readUInt32BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]*0x1000000+(this[offset+1]<<16|this[offset+2]<<8|this[offset+3]);};Buffer.prototype.readBigUInt64LE=defineBigIntMethod(function readBigUInt64LE(offset){offset=offset>>>0;validateNumber(offset,'offset');var first=this[offset];var last=this[offset+7];if(first===undefined||last===undefined){boundsError(offset,this.length-8);}var lo=first+this[++offset]*Math.pow(2,8)+this[++offset]*Math.pow(2,16)+this[++offset]*Math.pow(2,24);var hi=this[++offset]+this[++offset]*Math.pow(2,8)+this[++offset]*Math.pow(2,16)+last*Math.pow(2,24);return BigInt(lo)+(BigInt(hi)<<BigInt(32));});Buffer.prototype.readBigUInt64BE=defineBigIntMethod(function readBigUInt64BE(offset){offset=offset>>>0;validateNumber(offset,'offset');var first=this[offset];var last=this[offset+7];if(first===undefined||last===undefined){boundsError(offset,this.length-8);}var hi=first*Math.pow(2,24)+this[++offset]*Math.pow(2,16)+this[++offset]*Math.pow(2,8)+this[++offset];var lo=this[++offset]*Math.pow(2,24)+this[++offset]*Math.pow(2,16)+this[++offset]*Math.pow(2,8)+last;return(BigInt(hi)<<BigInt(32))+BigInt(lo);});Buffer.prototype.readIntLE=function readIntLE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var val=this[offset];var mul=1;var i=0;while(++i<byteLength&&(mul*=0x100)){val+=this[offset+i]*mul;}mul*=0x80;if(val>=mul)val-=Math.pow(2,8*byteLength);return val;};Buffer.prototype.readIntBE=function readIntBE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var i=byteLength;var mul=1;var val=this[offset+--i];while(i>0&&(mul*=0x100)){val+=this[offset+--i]*mul;}mul*=0x80;if(val>=mul)val-=Math.pow(2,8*byteLength);return val;};Buffer.prototype.readInt8=function readInt8(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,1,this.length);if(!(this[offset]&0x80))return this[offset];return(0xff-this[offset]+1)*-1;};Buffer.prototype.readInt16LE=function readInt16LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);var val=this[offset]|this[offset+1]<<8;return val&0x8000?val|0xFFFF0000:val;};Buffer.prototype.readInt16BE=function readInt16BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);var val=this[offset+1]|this[offset]<<8;return val&0x8000?val|0xFFFF0000:val;};Buffer.prototype.readInt32LE=function readInt32LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]|this[offset+1]<<8|this[offset+2]<<16|this[offset+3]<<24;};Buffer.prototype.readInt32BE=function readInt32BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]<<24|this[offset+1]<<16|this[offset+2]<<8|this[offset+3];};Buffer.prototype.readBigInt64LE=defineBigIntMethod(function readBigInt64LE(offset){offset=offset>>>0;validateNumber(offset,'offset');var first=this[offset];var last=this[offset+7];if(first===undefined||last===undefined){boundsError(offset,this.length-8);}var val=this[offset+4]+this[offset+5]*Math.pow(2,8)+this[offset+6]*Math.pow(2,16)+(last<<24);// Overflow
return(BigInt(val)<<BigInt(32))+BigInt(first+this[++offset]*Math.pow(2,8)+this[++offset]*Math.pow(2,16)+this[++offset]*Math.pow(2,24));});Buffer.prototype.readBigInt64BE=defineBigIntMethod(function readBigInt64BE(offset){offset=offset>>>0;validateNumber(offset,'offset');var first=this[offset];var last=this[offset+7];if(first===undefined||last===undefined){boundsError(offset,this.length-8);}var val=(first<<24)+// Overflow
this[++offset]*Math.pow(2,16)+this[++offset]*Math.pow(2,8)+this[++offset];return(BigInt(val)<<BigInt(32))+BigInt(this[++offset]*Math.pow(2,24)+this[++offset]*Math.pow(2,16)+this[++offset]*Math.pow(2,8)+last);});Buffer.prototype.readFloatLE=function readFloatLE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return ieee754.read(this,offset,true,23,4);};Buffer.prototype.readFloatBE=function readFloatBE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return ieee754.read(this,offset,false,23,4);};Buffer.prototype.readDoubleLE=function readDoubleLE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,8,this.length);return ieee754.read(this,offset,true,52,8);};Buffer.prototype.readDoubleBE=function readDoubleBE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,8,this.length);return ieee754.read(this,offset,false,52,8);};function checkInt(buf,value,offset,ext,max,min){if(!Buffer.isBuffer(buf))throw new TypeError('"buffer" argument must be a Buffer instance');if(value>max||value<min)throw new RangeError('"value" argument is out of bounds');if(offset+ext>buf.length)throw new RangeError('Index out of range');}Buffer.prototype.writeUintLE=Buffer.prototype.writeUIntLE=function writeUIntLE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){var maxBytes=Math.pow(2,8*byteLength)-1;checkInt(this,value,offset,byteLength,maxBytes,0);}var mul=1;var i=0;this[offset]=value&0xFF;while(++i<byteLength&&(mul*=0x100)){this[offset+i]=value/mul&0xFF;}return offset+byteLength;};Buffer.prototype.writeUintBE=Buffer.prototype.writeUIntBE=function writeUIntBE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){var maxBytes=Math.pow(2,8*byteLength)-1;checkInt(this,value,offset,byteLength,maxBytes,0);}var i=byteLength-1;var mul=1;this[offset+i]=value&0xFF;while(--i>=0&&(mul*=0x100)){this[offset+i]=value/mul&0xFF;}return offset+byteLength;};Buffer.prototype.writeUint8=Buffer.prototype.writeUInt8=function writeUInt8(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,1,0xff,0);this[offset]=value&0xff;return offset+1;};Buffer.prototype.writeUint16LE=Buffer.prototype.writeUInt16LE=function writeUInt16LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0xffff,0);this[offset]=value&0xff;this[offset+1]=value>>>8;return offset+2;};Buffer.prototype.writeUint16BE=Buffer.prototype.writeUInt16BE=function writeUInt16BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0xffff,0);this[offset]=value>>>8;this[offset+1]=value&0xff;return offset+2;};Buffer.prototype.writeUint32LE=Buffer.prototype.writeUInt32LE=function writeUInt32LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0xffffffff,0);this[offset+3]=value>>>24;this[offset+2]=value>>>16;this[offset+1]=value>>>8;this[offset]=value&0xff;return offset+4;};Buffer.prototype.writeUint32BE=Buffer.prototype.writeUInt32BE=function writeUInt32BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0xffffffff,0);this[offset]=value>>>24;this[offset+1]=value>>>16;this[offset+2]=value>>>8;this[offset+3]=value&0xff;return offset+4;};function wrtBigUInt64LE(buf,value,offset,min,max){checkIntBI(value,min,max,buf,offset,7);var lo=Number(value&BigInt(0xffffffff));buf[offset++]=lo;lo=lo>>8;buf[offset++]=lo;lo=lo>>8;buf[offset++]=lo;lo=lo>>8;buf[offset++]=lo;var hi=Number(value>>BigInt(32)&BigInt(0xffffffff));buf[offset++]=hi;hi=hi>>8;buf[offset++]=hi;hi=hi>>8;buf[offset++]=hi;hi=hi>>8;buf[offset++]=hi;return offset;}function wrtBigUInt64BE(buf,value,offset,min,max){checkIntBI(value,min,max,buf,offset,7);var lo=Number(value&BigInt(0xffffffff));buf[offset+7]=lo;lo=lo>>8;buf[offset+6]=lo;lo=lo>>8;buf[offset+5]=lo;lo=lo>>8;buf[offset+4]=lo;var hi=Number(value>>BigInt(32)&BigInt(0xffffffff));buf[offset+3]=hi;hi=hi>>8;buf[offset+2]=hi;hi=hi>>8;buf[offset+1]=hi;hi=hi>>8;buf[offset]=hi;return offset+8;}Buffer.prototype.writeBigUInt64LE=defineBigIntMethod(function writeBigUInt64LE(value){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;return wrtBigUInt64LE(this,value,offset,BigInt(0),BigInt('0xffffffffffffffff'));});Buffer.prototype.writeBigUInt64BE=defineBigIntMethod(function writeBigUInt64BE(value){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;return wrtBigUInt64BE(this,value,offset,BigInt(0),BigInt('0xffffffffffffffff'));});Buffer.prototype.writeIntLE=function writeIntLE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;if(!noAssert){var limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit);}var i=0;var mul=1;var sub=0;this[offset]=value&0xFF;while(++i<byteLength&&(mul*=0x100)){if(value<0&&sub===0&&this[offset+i-1]!==0){sub=1;}this[offset+i]=(value/mul>>0)-sub&0xFF;}return offset+byteLength;};Buffer.prototype.writeIntBE=function writeIntBE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;if(!noAssert){var limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit);}var i=byteLength-1;var mul=1;var sub=0;this[offset+i]=value&0xFF;while(--i>=0&&(mul*=0x100)){if(value<0&&sub===0&&this[offset+i+1]!==0){sub=1;}this[offset+i]=(value/mul>>0)-sub&0xFF;}return offset+byteLength;};Buffer.prototype.writeInt8=function writeInt8(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,1,0x7f,-0x80);if(value<0)value=0xff+value+1;this[offset]=value&0xff;return offset+1;};Buffer.prototype.writeInt16LE=function writeInt16LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0x7fff,-0x8000);this[offset]=value&0xff;this[offset+1]=value>>>8;return offset+2;};Buffer.prototype.writeInt16BE=function writeInt16BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0x7fff,-0x8000);this[offset]=value>>>8;this[offset+1]=value&0xff;return offset+2;};Buffer.prototype.writeInt32LE=function writeInt32LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0x7fffffff,-0x80000000);this[offset]=value&0xff;this[offset+1]=value>>>8;this[offset+2]=value>>>16;this[offset+3]=value>>>24;return offset+4;};Buffer.prototype.writeInt32BE=function writeInt32BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0x7fffffff,-0x80000000);if(value<0)value=0xffffffff+value+1;this[offset]=value>>>24;this[offset+1]=value>>>16;this[offset+2]=value>>>8;this[offset+3]=value&0xff;return offset+4;};Buffer.prototype.writeBigInt64LE=defineBigIntMethod(function writeBigInt64LE(value){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;return wrtBigUInt64LE(this,value,offset,-BigInt('0x8000000000000000'),BigInt('0x7fffffffffffffff'));});Buffer.prototype.writeBigInt64BE=defineBigIntMethod(function writeBigInt64BE(value){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;return wrtBigUInt64BE(this,value,offset,-BigInt('0x8000000000000000'),BigInt('0x7fffffffffffffff'));});function checkIEEE754(buf,value,offset,ext,max,min){if(offset+ext>buf.length)throw new RangeError('Index out of range');if(offset<0)throw new RangeError('Index out of range');}function writeFloat(buf,value,offset,littleEndian,noAssert){value=+value;offset=offset>>>0;if(!noAssert){checkIEEE754(buf,value,offset,4,3.4028234663852886e+38,-3.4028234663852886e+38);}ieee754.write(buf,value,offset,littleEndian,23,4);return offset+4;}Buffer.prototype.writeFloatLE=function writeFloatLE(value,offset,noAssert){return writeFloat(this,value,offset,true,noAssert);};Buffer.prototype.writeFloatBE=function writeFloatBE(value,offset,noAssert){return writeFloat(this,value,offset,false,noAssert);};function writeDouble(buf,value,offset,littleEndian,noAssert){value=+value;offset=offset>>>0;if(!noAssert){checkIEEE754(buf,value,offset,8,1.7976931348623157E+308,-1.7976931348623157E+308);}ieee754.write(buf,value,offset,littleEndian,52,8);return offset+8;}Buffer.prototype.writeDoubleLE=function writeDoubleLE(value,offset,noAssert){return writeDouble(this,value,offset,true,noAssert);};Buffer.prototype.writeDoubleBE=function writeDoubleBE(value,offset,noAssert){return writeDouble(this,value,offset,false,noAssert);};// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy=function copy(target,targetStart,start,end){if(!Buffer.isBuffer(target))throw new TypeError('argument should be a Buffer');if(!start)start=0;if(!end&&end!==0)end=this.length;if(targetStart>=target.length)targetStart=target.length;if(!targetStart)targetStart=0;if(end>0&&end<start)end=start;// Copy 0 bytes; we're done
if(end===start)return 0;if(target.length===0||this.length===0)return 0;// Fatal error conditions
if(targetStart<0){throw new RangeError('targetStart out of bounds');}if(start<0||start>=this.length)throw new RangeError('Index out of range');if(end<0)throw new RangeError('sourceEnd out of bounds');// Are we oob?
if(end>this.length)end=this.length;if(target.length-targetStart<end-start){end=target.length-targetStart+start;}var len=end-start;if(this===target&&typeof Uint8Array.prototype.copyWithin==='function'){// Use built-in when available, missing from IE11
this.copyWithin(targetStart,start,end);}else{Uint8Array.prototype.set.call(target,this.subarray(start,end),targetStart);}return len;};// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill=function fill(val,start,end,encoding){// Handle string cases:
if(typeof val==='string'){if(typeof start==='string'){encoding=start;start=0;end=this.length;}else if(typeof end==='string'){encoding=end;end=this.length;}if(encoding!==undefined&&typeof encoding!=='string'){throw new TypeError('encoding must be a string');}if(typeof encoding==='string'&&!Buffer.isEncoding(encoding)){throw new TypeError('Unknown encoding: '+encoding);}if(val.length===1){var code=val.charCodeAt(0);if(encoding==='utf8'&&code<128||encoding==='latin1'){// Fast path: If `val` fits into a single byte, use that numeric value.
val=code;}}}else if(typeof val==='number'){val=val&255;}else if(typeof val==='boolean'){val=Number(val);}// Invalid ranges are not set to a default, so can range check early.
if(start<0||this.length<start||this.length<end){throw new RangeError('Out of range index');}if(end<=start){return this;}start=start>>>0;end=end===undefined?this.length:end>>>0;if(!val)val=0;var i;if(typeof val==='number'){for(i=start;i<end;++i){this[i]=val;}}else{var bytes=Buffer.isBuffer(val)?val:Buffer.from(val,encoding);var len=bytes.length;if(len===0){throw new TypeError('The value "'+val+'" is invalid for argument "value"');}for(i=0;i<end-start;++i){this[i+start]=bytes[i%len];}}return this;};// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
var errors={};function E(sym,getMessage,Base){errors[sym]=/*#__PURE__*/function(_Base){_inherits(NodeError,_Base);var _super=_createSuper(NodeError);function NodeError(){var _this;_classCallCheck(this,NodeError);_this=_super.call(this);Object.defineProperty(_assertThisInitialized(_this),'message',{value:getMessage.apply(_assertThisInitialized(_this),arguments),writable:true,configurable:true});// Add the error code to the name to include it in the stack trace.
_this.name="".concat(_this.name," [").concat(sym,"]");// Access the stack to generate the error message including the error code
// from the name.
_this.stack;// eslint-disable-line no-unused-expressions
// Reset the name to the actual name.
delete _this.name;return _this;}_createClass(NodeError,[{key:"code",get:function get(){return sym;},set:function set(value){Object.defineProperty(this,'code',{configurable:true,enumerable:true,value:value,writable:true});}},{key:"toString",value:function toString(){return"".concat(this.name," [").concat(sym,"]: ").concat(this.message);}}]);return NodeError;}(Base);}E('ERR_BUFFER_OUT_OF_BOUNDS',function(name){if(name){return"".concat(name," is outside of buffer bounds");}return'Attempt to access memory outside buffer bounds';},RangeError);E('ERR_INVALID_ARG_TYPE',function(name,actual){return"The \"".concat(name,"\" argument must be of type number. Received type ").concat(_typeof(actual));},TypeError);E('ERR_OUT_OF_RANGE',function(str,range,input){var msg="The value of \"".concat(str,"\" is out of range.");var received=input;if(Number.isInteger(input)&&Math.abs(input)>Math.pow(2,32)){received=addNumericalSeparator(String(input));}else if(typeof input==='bigint'){received=String(input);if(input>Math.pow(BigInt(2),BigInt(32))||input<-Math.pow(BigInt(2),BigInt(32))){received=addNumericalSeparator(received);}received+='n';}msg+=" It must be ".concat(range,". Received ").concat(received);return msg;},RangeError);function addNumericalSeparator(val){var res='';var i=val.length;var start=val[0]==='-'?1:0;for(;i>=start+4;i-=3){res="_".concat(val.slice(i-3,i)).concat(res);}return"".concat(val.slice(0,i)).concat(res);}// CHECK FUNCTIONS
// ===============
function checkBounds(buf,offset,byteLength){validateNumber(offset,'offset');if(buf[offset]===undefined||buf[offset+byteLength]===undefined){boundsError(offset,buf.length-(byteLength+1));}}function checkIntBI(value,min,max,buf,offset,byteLength){if(value>max||value<min){var n=typeof min==='bigint'?'n':'';var range;if(byteLength>3){if(min===0||min===BigInt(0)){range=">= 0".concat(n," and < 2").concat(n," ** ").concat((byteLength+1)*8).concat(n);}else{range=">= -(2".concat(n," ** ").concat((byteLength+1)*8-1).concat(n,") and < 2 ** ")+"".concat((byteLength+1)*8-1).concat(n);}}else{range=">= ".concat(min).concat(n," and <= ").concat(max).concat(n);}throw new errors.ERR_OUT_OF_RANGE('value',range,value);}checkBounds(buf,offset,byteLength);}function validateNumber(value,name){if(typeof value!=='number'){throw new errors.ERR_INVALID_ARG_TYPE(name,'number',value);}}function boundsError(value,length,type){if(Math.floor(value)!==value){validateNumber(value,type);throw new errors.ERR_OUT_OF_RANGE(type||'offset','an integer',value);}if(length<0){throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();}throw new errors.ERR_OUT_OF_RANGE(type||'offset',">= ".concat(type?1:0," and <= ").concat(length),value);}// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE=/[^+/0-9A-Za-z-_]/g;function base64clean(str){// Node takes equal signs as end of the Base64 encoding
str=str.split('=')[0];// Node strips out invalid characters like \n and \t from the string, base64-js does not
str=str.trim().replace(INVALID_BASE64_RE,'');// Node converts strings with length < 2 to ''
if(str.length<2)return'';// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
while(str.length%4!==0){str=str+'=';}return str;}function utf8ToBytes(string,units){units=units||Infinity;var codePoint;var length=string.length;var leadSurrogate=null;var bytes=[];for(var i=0;i<length;++i){codePoint=string.charCodeAt(i);// is surrogate component
if(codePoint>0xD7FF&&codePoint<0xE000){// last char was a lead
if(!leadSurrogate){// no lead yet
if(codePoint>0xDBFF){// unexpected trail
if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);continue;}else if(i+1===length){// unpaired lead
if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);continue;}// valid lead
leadSurrogate=codePoint;continue;}// 2 leads in a row
if(codePoint<0xDC00){if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);leadSurrogate=codePoint;continue;}// valid surrogate pair
codePoint=(leadSurrogate-0xD800<<10|codePoint-0xDC00)+0x10000;}else if(leadSurrogate){// valid bmp char, but last char was a lead
if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);}leadSurrogate=null;// encode utf8
if(codePoint<0x80){if((units-=1)<0)break;bytes.push(codePoint);}else if(codePoint<0x800){if((units-=2)<0)break;bytes.push(codePoint>>0x6|0xC0,codePoint&0x3F|0x80);}else if(codePoint<0x10000){if((units-=3)<0)break;bytes.push(codePoint>>0xC|0xE0,codePoint>>0x6&0x3F|0x80,codePoint&0x3F|0x80);}else if(codePoint<0x110000){if((units-=4)<0)break;bytes.push(codePoint>>0x12|0xF0,codePoint>>0xC&0x3F|0x80,codePoint>>0x6&0x3F|0x80,codePoint&0x3F|0x80);}else{throw new Error('Invalid code point');}}return bytes;}function asciiToBytes(str){var byteArray=[];for(var i=0;i<str.length;++i){// Node's code seems to be doing this and not & 0x7F..
byteArray.push(str.charCodeAt(i)&0xFF);}return byteArray;}function utf16leToBytes(str,units){var c,hi,lo;var byteArray=[];for(var i=0;i<str.length;++i){if((units-=2)<0)break;c=str.charCodeAt(i);hi=c>>8;lo=c%256;byteArray.push(lo);byteArray.push(hi);}return byteArray;}function base64ToBytes(str){return base64.toByteArray(base64clean(str));}function blitBuffer(src,dst,offset,length){var i;for(i=0;i<length;++i){if(i+offset>=dst.length||i>=src.length)break;dst[i+offset]=src[i];}return i;}// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj,type){return obj instanceof type||obj!=null&&obj.constructor!=null&&obj.constructor.name!=null&&obj.constructor.name===type.name;}function numberIsNaN(obj){// For IE11 support
return obj!==obj;// eslint-disable-line no-self-compare
}// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable=function(){var alphabet='0123456789abcdef';var table=new Array(256);for(var i=0;i<16;++i){var i16=i*16;for(var j=0;j<16;++j){table[i16+j]=alphabet[i]+alphabet[j];}}return table;}();// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn){return typeof BigInt==='undefined'?BufferBigIntNotDefined:fn;}function BufferBigIntNotDefined(){throw new Error('BigInt not supported');}/***/},/***/2321:/***/function(module){"use strict";module.exports=isMobile;module.exports.isMobile=isMobile;module.exports["default"]=isMobile;var mobileRE=/(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;var notMobileRE=/CrOS/;var tabletRE=/android|ipad|playbook|silk/i;function isMobile(opts){if(!opts)opts={};var ua=opts.ua;if(!ua&&typeof navigator!=='undefined')ua=navigator.userAgent;if(ua&&ua.headers&&typeof ua.headers['user-agent']==='string'){ua=ua.headers['user-agent'];}if(typeof ua!=='string')return false;var result=mobileRE.test(ua)&&!notMobileRE.test(ua)||!!opts.tablet&&tabletRE.test(ua);if(!result&&opts.tablet&&opts.featureDetect&&navigator&&navigator.maxTouchPoints>1&&ua.indexOf('Macintosh')!==-1&&ua.indexOf('Safari')!==-1){result=true;}return result;}/***/},/***/3910:/***/function(__unused_webpack_module,exports){"use strict";exports.byteLength=byteLength;exports.toByteArray=toByteArray;exports.fromByteArray=fromByteArray;var lookup=[];var revLookup=[];var Arr=typeof Uint8Array!=='undefined'?Uint8Array:Array;var code='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';for(var i=0,len=code.length;i<len;++i){lookup[i]=code[i];revLookup[code.charCodeAt(i)]=i;}// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)]=62;revLookup['_'.charCodeAt(0)]=63;function getLens(b64){var len=b64.length;if(len%4>0){throw new Error('Invalid string. Length must be a multiple of 4');}// Trim off extra bytes after placeholder bytes are found
// See: https://github.com/beatgammit/base64-js/issues/42
var validLen=b64.indexOf('=');if(validLen===-1)validLen=len;var placeHoldersLen=validLen===len?0:4-validLen%4;return[validLen,placeHoldersLen];}// base64 is 4/3 + up to two characters of the original data
function byteLength(b64){var lens=getLens(b64);var validLen=lens[0];var placeHoldersLen=lens[1];return(validLen+placeHoldersLen)*3/4-placeHoldersLen;}function _byteLength(b64,validLen,placeHoldersLen){return(validLen+placeHoldersLen)*3/4-placeHoldersLen;}function toByteArray(b64){var tmp;var lens=getLens(b64);var validLen=lens[0];var placeHoldersLen=lens[1];var arr=new Arr(_byteLength(b64,validLen,placeHoldersLen));var curByte=0;// if there are placeholders, only get up to the last complete 4 chars
var len=placeHoldersLen>0?validLen-4:validLen;var i;for(i=0;i<len;i+=4){tmp=revLookup[b64.charCodeAt(i)]<<18|revLookup[b64.charCodeAt(i+1)]<<12|revLookup[b64.charCodeAt(i+2)]<<6|revLookup[b64.charCodeAt(i+3)];arr[curByte++]=tmp>>16&0xFF;arr[curByte++]=tmp>>8&0xFF;arr[curByte++]=tmp&0xFF;}if(placeHoldersLen===2){tmp=revLookup[b64.charCodeAt(i)]<<2|revLookup[b64.charCodeAt(i+1)]>>4;arr[curByte++]=tmp&0xFF;}if(placeHoldersLen===1){tmp=revLookup[b64.charCodeAt(i)]<<10|revLookup[b64.charCodeAt(i+1)]<<4|revLookup[b64.charCodeAt(i+2)]>>2;arr[curByte++]=tmp>>8&0xFF;arr[curByte++]=tmp&0xFF;}return arr;}function tripletToBase64(num){return lookup[num>>18&0x3F]+lookup[num>>12&0x3F]+lookup[num>>6&0x3F]+lookup[num&0x3F];}function encodeChunk(uint8,start,end){var tmp;var output=[];for(var i=start;i<end;i+=3){tmp=(uint8[i]<<16&0xFF0000)+(uint8[i+1]<<8&0xFF00)+(uint8[i+2]&0xFF);output.push(tripletToBase64(tmp));}return output.join('');}function fromByteArray(uint8){var tmp;var len=uint8.length;var extraBytes=len%3;// if we have 1 byte left, pad 2 bytes
var parts=[];var maxChunkLength=16383;// must be multiple of 3
// go through the array every three bytes, we'll deal with trailing stuff later
for(var i=0,len2=len-extraBytes;i<len2;i+=maxChunkLength){parts.push(encodeChunk(uint8,i,i+maxChunkLength>len2?len2:i+maxChunkLength));}// pad the end with zeros, but make sure to not forget the extra bytes
if(extraBytes===1){tmp=uint8[len-1];parts.push(lookup[tmp>>2]+lookup[tmp<<4&0x3F]+'==');}else if(extraBytes===2){tmp=(uint8[len-2]<<8)+uint8[len-1];parts.push(lookup[tmp>>10]+lookup[tmp>>4&0x3F]+lookup[tmp<<2&0x3F]+'=');}return parts.join('');}/***/},/***/3187:/***/function(__unused_webpack_module,exports){/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */exports.read=function(buffer,offset,isLE,mLen,nBytes){var e,m;var eLen=nBytes*8-mLen-1;var eMax=(1<<eLen)-1;var eBias=eMax>>1;var nBits=-7;var i=isLE?nBytes-1:0;var d=isLE?-1:1;var s=buffer[offset+i];i+=d;e=s&(1<<-nBits)-1;s>>=-nBits;nBits+=eLen;for(;nBits>0;e=e*256+buffer[offset+i],i+=d,nBits-=8){}m=e&(1<<-nBits)-1;e>>=-nBits;nBits+=mLen;for(;nBits>0;m=m*256+buffer[offset+i],i+=d,nBits-=8){}if(e===0){e=1-eBias;}else if(e===eMax){return m?NaN:(s?-1:1)*Infinity;}else{m=m+Math.pow(2,mLen);e=e-eBias;}return(s?-1:1)*m*Math.pow(2,e-mLen);};exports.write=function(buffer,value,offset,isLE,mLen,nBytes){var e,m,c;var eLen=nBytes*8-mLen-1;var eMax=(1<<eLen)-1;var eBias=eMax>>1;var rt=mLen===23?Math.pow(2,-24)-Math.pow(2,-77):0;var i=isLE?0:nBytes-1;var d=isLE?1:-1;var s=value<0||value===0&&1/value<0?1:0;value=Math.abs(value);if(isNaN(value)||value===Infinity){m=isNaN(value)?1:0;e=eMax;}else{e=Math.floor(Math.log(value)/Math.LN2);if(value*(c=Math.pow(2,-e))<1){e--;c*=2;}if(e+eBias>=1){value+=rt/c;}else{value+=rt*Math.pow(2,1-eBias);}if(value*c>=2){e++;c/=2;}if(e+eBias>=eMax){m=0;e=eMax;}else if(e+eBias>=1){m=(value*c-1)*Math.pow(2,mLen);e=e+eBias;}else{m=value*Math.pow(2,eBias-1)*Math.pow(2,mLen);e=0;}}for(;mLen>=8;buffer[offset+i]=m&0xff,i+=d,m/=256,mLen-=8){}e=e<<mLen|m;eLen+=mLen;for(;eLen>0;buffer[offset+i]=e&0xff,i+=d,e/=256,eLen-=8){}buffer[offset+i-d]|=s*128;};/***/},/***/1152:/***/function(module,__unused_webpack_exports,__nested_webpack_require_58199__){"use strict";module.exports=createViewController;var createTurntable=__nested_webpack_require_58199__(3440);var createOrbit=__nested_webpack_require_58199__(7774);var createMatrix=__nested_webpack_require_58199__(9298);function ViewController(controllers,mode){this._controllerNames=Object.keys(controllers);this._controllerList=this._controllerNames.map(function(n){return controllers[n];});this._mode=mode;this._active=controllers[mode];if(!this._active){this._mode='turntable';this._active=controllers.turntable;}this.modes=this._controllerNames;this.computedMatrix=this._active.computedMatrix;this.computedEye=this._active.computedEye;this.computedUp=this._active.computedUp;this.computedCenter=this._active.computedCenter;this.computedRadius=this._active.computedRadius;}var proto=ViewController.prototype;proto.flush=function(a0){var cc=this._controllerList;for(var i=0;i<cc.length;++i){cc[i].flush(a0);}};proto.idle=function(a0){var cc=this._controllerList;for(var i=0;i<cc.length;++i){cc[i].idle(a0);}};proto.lookAt=function(a0,a1,a2,a3){var cc=this._controllerList;for(var i=0;i<cc.length;++i){cc[i].lookAt(a0,a1,a2,a3);}};proto.rotate=function(a0,a1,a2,a3){var cc=this._controllerList;for(var i=0;i<cc.length;++i){cc[i].rotate(a0,a1,a2,a3);}};proto.pan=function(a0,a1,a2,a3){var cc=this._controllerList;for(var i=0;i<cc.length;++i){cc[i].pan(a0,a1,a2,a3);}};proto.translate=function(a0,a1,a2,a3){var cc=this._controllerList;for(var i=0;i<cc.length;++i){cc[i].translate(a0,a1,a2,a3);}};proto.setMatrix=function(a0,a1){var cc=this._controllerList;for(var i=0;i<cc.length;++i){cc[i].setMatrix(a0,a1);}};proto.setDistanceLimits=function(a0,a1){var cc=this._controllerList;for(var i=0;i<cc.length;++i){cc[i].setDistanceLimits(a0,a1);}};proto.setDistance=function(a0,a1){var cc=this._controllerList;for(var i=0;i<cc.length;++i){cc[i].setDistance(a0,a1);}};proto.recalcMatrix=function(t){this._active.recalcMatrix(t);};proto.getDistance=function(t){return this._active.getDistance(t);};proto.getDistanceLimits=function(out){return this._active.getDistanceLimits(out);};proto.lastT=function(){return this._active.lastT();};proto.setMode=function(mode){if(mode===this._mode){return;}var idx=this._controllerNames.indexOf(mode);if(idx<0){return;}var prev=this._active;var next=this._controllerList[idx];var lastT=Math.max(prev.lastT(),next.lastT());prev.recalcMatrix(lastT);next.setMatrix(lastT,prev.computedMatrix);this._active=next;this._mode=mode;//Update matrix properties
this.computedMatrix=this._active.computedMatrix;this.computedEye=this._active.computedEye;this.computedUp=this._active.computedUp;this.computedCenter=this._active.computedCenter;this.computedRadius=this._active.computedRadius;};proto.getMode=function(){return this._mode;};function createViewController(options){options=options||{};var eye=options.eye||[0,0,1];var center=options.center||[0,0,0];var up=options.up||[0,1,0];var limits=options.distanceLimits||[0,Infinity];var mode=options.mode||'turntable';var turntable=createTurntable();var orbit=createOrbit();var matrix=createMatrix();turntable.setDistanceLimits(limits[0],limits[1]);turntable.lookAt(0,eye,center,up);orbit.setDistanceLimits(limits[0],limits[1]);orbit.lookAt(0,eye,center,up);matrix.setDistanceLimits(limits[0],limits[1]);matrix.lookAt(0,eye,center,up);return new ViewController({turntable:turntable,orbit:orbit,matrix:matrix},mode);}/***/},/***/8126:/***/function(module,__unused_webpack_exports,__nested_webpack_require_61625__){"use strict";var weakMap=typeof WeakMap==='undefined'?__nested_webpack_require_61625__(5346):WeakMap;var createBuffer=__nested_webpack_require_61625__(5827);var createVAO=__nested_webpack_require_61625__(2944);var TriangleCache=new weakMap();function createABigTriangle(gl){var triangleVAO=TriangleCache.get(gl);var handle=triangleVAO&&(triangleVAO._triangleBuffer.handle||triangleVAO._triangleBuffer.buffer);if(!handle||!gl.isBuffer(handle)){var buf=createBuffer(gl,new Float32Array([-1,-1,-1,4,4,-1]));triangleVAO=createVAO(gl,[{buffer:buf,type:gl.FLOAT,size:2}]);triangleVAO._triangleBuffer=buf;TriangleCache.set(gl,triangleVAO);}triangleVAO.bind();gl.drawArrays(gl.TRIANGLES,0,3);triangleVAO.unbind();}module.exports=createABigTriangle;/***/},/***/8008:/***/function(module,__unused_webpack_exports,__nested_webpack_require_62410__){var padLeft=__nested_webpack_require_62410__(4930);module.exports=addLineNumbers;function addLineNumbers(string,start,delim){start=typeof start==='number'?start:1;delim=delim||': ';var lines=string.split(/\r?\n/);var totalDigits=String(lines.length+start-1).length;return lines.map(function(line,i){var c=i+start;var digits=String(c).length;var prefix=padLeft(c,totalDigits-digits);return prefix+delim+line;}).join('\n');}/***/},/***/2153:/***/function(module,__unused_webpack_exports,__nested_webpack_require_62903__){"use strict";module.exports=affineHull;var orient=__nested_webpack_require_62903__(417);function linearlyIndependent(points,d){var nhull=new Array(d+1);for(var i=0;i<points.length;++i){nhull[i]=points[i];}for(var i=0;i<=points.length;++i){for(var j=points.length;j<=d;++j){var x=new Array(d);for(var k=0;k<d;++k){x[k]=Math.pow(j+1-i,k);}nhull[j]=x;}var o=orient.apply(void 0,nhull);if(o){return true;}}return false;}function affineHull(points){var n=points.length;if(n===0){return[];}if(n===1){return[0];}var d=points[0].length;var frame=[points[0]];var index=[0];for(var i=1;i<n;++i){frame.push(points[i]);if(!linearlyIndependent(frame,d)){frame.pop();continue;}index.push(i);if(index.length===d+1){return index;}}return index;}/***/},/***/4653:/***/function(module,__unused_webpack_exports,__nested_webpack_require_63703__){"use strict";module.exports=alphaComplex;var delaunay=__nested_webpack_require_63703__(4419);var circumradius=__nested_webpack_require_63703__(1778);function alphaComplex(alpha,points){return delaunay(points).filter(function(cell){var simplex=new Array(cell.length);for(var i=0;i<cell.length;++i){simplex[i]=points[cell[i]];}return circumradius(simplex)*alpha<1;});}/***/},/***/2350:/***/function(module,__unused_webpack_exports,__nested_webpack_require_64127__){module.exports=alphaShape;var ac=__nested_webpack_require_64127__(4653);var bnd=__nested_webpack_require_64127__(8691);function alphaShape(alpha,points){return bnd(ac(alpha,points));}/***/},/***/7896:/***/function(module){module.exports=function _atob(str){return atob(str);};/***/},/***/957:/***/function(module,__unused_webpack_exports,__nested_webpack_require_64460__){"use strict";module.exports=barycentric;var solve=__nested_webpack_require_64460__(6606);function reduce(x){var r=0;for(var i=0;i<x.length;++i){r+=x[i];}return r;}function barycentric(simplex,point){var d=point.length;var A=new Array(d+1);for(var i=0;i<d;++i){var row=new Array(d+1);for(var j=0;j<=d;++j){row[j]=simplex[j][i];}A[i]=row;}A[d]=new Array(d+1);for(var i=0;i<=d;++i){A[d][i]=1;}var b=new Array(d+1);for(var i=0;i<d;++i){b[i]=point[i];}b[d]=1.0;var x=solve(A,b);var w=reduce(x[d+1]);if(w===0){w=1.0;}var y=new Array(d+1);for(var i=0;i<=d;++i){y[i]=reduce(x[i])/w;}return y;}/***/},/***/1539:/***/function(module,__unused_webpack_exports,__nested_webpack_require_65116__){"use strict";var rationalize=__nested_webpack_require_65116__(8524);module.exports=add;function add(a,b){return rationalize(a[0].mul(b[1]).add(b[0].mul(a[1])),a[1].mul(b[1]));}/***/},/***/8846:/***/function(module){"use strict";module.exports=cmp;function cmp(a,b){return a[0].mul(b[1]).cmp(b[0].mul(a[1]));}/***/},/***/9189:/***/function(module,__unused_webpack_exports,__nested_webpack_require_65495__){"use strict";var rationalize=__nested_webpack_require_65495__(8524);module.exports=div;function div(a,b){return rationalize(a[0].mul(b[1]),a[1].mul(b[0]));}/***/},/***/5125:/***/function(module,__unused_webpack_exports,__nested_webpack_require_65722__){"use strict";var isRat=__nested_webpack_require_65722__(234);var isBN=__nested_webpack_require_65722__(3218);var num2bn=__nested_webpack_require_65722__(5514);var str2bn=__nested_webpack_require_65722__(2813);var rationalize=__nested_webpack_require_65722__(8524);var div=__nested_webpack_require_65722__(9189);module.exports=makeRational;function makeRational(numer,denom){if(isRat(numer)){if(denom){return div(numer,makeRational(denom));}return[numer[0].clone(),numer[1].clone()];}var shift=0;var a,b;if(isBN(numer)){a=numer.clone();}else if(typeof numer==='string'){a=str2bn(numer);}else if(numer===0){return[num2bn(0),num2bn(1)];}else if(numer===Math.floor(numer)){a=num2bn(numer);}else{while(numer!==Math.floor(numer)){numer=numer*Math.pow(2,256);shift-=256;}a=num2bn(numer);}if(isRat(denom)){a.mul(denom[1]);b=denom[0].clone();}else if(isBN(denom)){b=denom.clone();}else if(typeof denom==='string'){b=str2bn(denom);}else if(!denom){b=num2bn(1);}else if(denom===Math.floor(denom)){b=num2bn(denom);}else{while(denom!==Math.floor(denom)){denom=denom*Math.pow(2,256);shift+=256;}b=num2bn(denom);}if(shift>0){a=a.ushln(shift);}else if(shift<0){b=b.ushln(-shift);}return rationalize(a,b);}/***/},/***/234:/***/function(module,__unused_webpack_exports,__nested_webpack_require_66916__){"use strict";var isBN=__nested_webpack_require_66916__(3218);module.exports=isRat;function isRat(x){return Array.isArray(x)&&x.length===2&&isBN(x[0])&&isBN(x[1]);}/***/},/***/4275:/***/function(module,__unused_webpack_exports,__nested_webpack_require_67150__){"use strict";var BN=__nested_webpack_require_67150__(1928);module.exports=sign;function sign(x){return x.cmp(new BN(0));}/***/},/***/9958:/***/function(module,__unused_webpack_exports,__nested_webpack_require_67342__){"use strict";var sign=__nested_webpack_require_67342__(4275);module.exports=bn2num;//TODO: Make this better
function bn2num(b){var l=b.length;var words=b.words;var out=0;if(l===1){out=words[0];}else if(l===2){out=words[0]+words[1]*0x4000000;}else{for(var i=0;i<l;i++){var w=words[i];out+=w*Math.pow(0x4000000,i);}}return sign(b)*out;}/***/},/***/1112:/***/function(module,__unused_webpack_exports,__nested_webpack_require_67747__){"use strict";var db=__nested_webpack_require_67747__(8362);var ctz=__nested_webpack_require_67747__(2288).countTrailingZeros;module.exports=ctzNumber;//Counts the number of trailing zeros
function ctzNumber(x){var l=ctz(db.lo(x));if(l<32){return l;}var h=ctz(db.hi(x));if(h>20){return 52;}return h+32;}/***/},/***/3218:/***/function(module,__unused_webpack_exports,__nested_webpack_require_68107__){"use strict";var BN=__nested_webpack_require_68107__(1928);module.exports=isBN;//Test if x is a bignumber
//FIXME: obviously this is the wrong way to do it
function isBN(x){return x&&typeof x==='object'&&Boolean(x.words);}/***/},/***/5514:/***/function(module,__unused_webpack_exports,__nested_webpack_require_68400__){"use strict";var BN=__nested_webpack_require_68400__(1928);var db=__nested_webpack_require_68400__(8362);module.exports=num2bn;function num2bn(x){var e=db.exponent(x);if(e<52){return new BN(x);}else{return new BN(x*Math.pow(2,52-e)).ushln(e-52);}}/***/},/***/8524:/***/function(module,__unused_webpack_exports,__nested_webpack_require_68705__){"use strict";var num2bn=__nested_webpack_require_68705__(5514);var sign=__nested_webpack_require_68705__(4275);module.exports=rationalize;function rationalize(numer,denom){var snumer=sign(numer);var sdenom=sign(denom);if(snumer===0){return[num2bn(0),num2bn(1)];}if(sdenom===0){return[num2bn(0),num2bn(0)];}if(sdenom<0){numer=numer.neg();denom=denom.neg();}var d=numer.gcd(denom);if(d.cmpn(1)){return[numer.div(d),denom.div(d)];}return[numer,denom];}/***/},/***/2813:/***/function(module,__unused_webpack_exports,__nested_webpack_require_69212__){"use strict";var BN=__nested_webpack_require_69212__(1928);module.exports=str2BN;function str2BN(x){return new BN(x);}/***/},/***/3962:/***/function(module,__unused_webpack_exports,__nested_webpack_require_69401__){"use strict";var rationalize=__nested_webpack_require_69401__(8524);module.exports=mul;function mul(a,b){return rationalize(a[0].mul(b[0]),a[1].mul(b[1]));}/***/},/***/4951:/***/function(module,__unused_webpack_exports,__nested_webpack_require_69628__){"use strict";var bnsign=__nested_webpack_require_69628__(4275);module.exports=sign;function sign(x){return bnsign(x[0])*bnsign(x[1]);}/***/},/***/4354:/***/function(module,__unused_webpack_exports,__nested_webpack_require_69833__){"use strict";var rationalize=__nested_webpack_require_69833__(8524);module.exports=sub;function sub(a,b){return rationalize(a[0].mul(b[1]).sub(a[1].mul(b[0])),a[1].mul(b[1]));}/***/},/***/7999:/***/function(module,__unused_webpack_exports,__nested_webpack_require_70080__){"use strict";var bn2num=__nested_webpack_require_70080__(9958);var ctz=__nested_webpack_require_70080__(1112);module.exports=roundRat;// Round a rational to the closest float
function roundRat(f){var a=f[0];var b=f[1];if(a.cmpn(0)===0){return 0;}var h=a.abs().divmod(b.abs());var iv=h.div;var x=bn2num(iv);var ir=h.mod;var sgn=a.negative!==b.negative?-1:1;if(ir.cmpn(0)===0){return sgn*x;}if(x){var s=ctz(x)+4;var y=bn2num(ir.ushln(s).divRound(b));return sgn*(x+y*Math.pow(2,-s));}else{var ybits=b.bitLength()-ir.bitLength()+53;var y=bn2num(ir.ushln(ybits).divRound(b));if(ybits<1023){return sgn*y*Math.pow(2,-ybits);}y*=Math.pow(2,-1023);return sgn*y*Math.pow(2,1023-ybits);}}/***/},/***/5070:/***/function(module){"use strict";// (a, y, c, l, h) = (array, y[, cmp, lo, hi])
function ge(a,y,c,l,h){var i=h+1;while(l<=h){var m=l+h>>>1,x=a[m];var p=c!==undefined?c(x,y):x-y;if(p>=0){i=m;h=m-1;}else{l=m+1;}}return i;};function gt(a,y,c,l,h){var i=h+1;while(l<=h){var m=l+h>>>1,x=a[m];var p=c!==undefined?c(x,y):x-y;if(p>0){i=m;h=m-1;}else{l=m+1;}}return i;};function lt(a,y,c,l,h){var i=l-1;while(l<=h){var m=l+h>>>1,x=a[m];var p=c!==undefined?c(x,y):x-y;if(p<0){i=m;l=m+1;}else{h=m-1;}}return i;};function le(a,y,c,l,h){var i=l-1;while(l<=h){var m=l+h>>>1,x=a[m];var p=c!==undefined?c(x,y):x-y;if(p<=0){i=m;l=m+1;}else{h=m-1;}}return i;};function eq(a,y,c,l,h){while(l<=h){var m=l+h>>>1,x=a[m];var p=c!==undefined?c(x,y):x-y;if(p===0){return m;}if(p<=0){l=m+1;}else{h=m-1;}}return-1;};function norm(a,y,c,l,h,f){if(typeof c==='function'){return f(a,y,c,l===undefined?0:l|0,h===undefined?a.length-1:h|0);}return f(a,y,undefined,c===undefined?0:c|0,l===undefined?a.length-1:l|0);}module.exports={ge:function(a,y,c,l,h){return norm(a,y,c,l,h,ge);},gt:function(a,y,c,l,h){return norm(a,y,c,l,h,gt);},lt:function(a,y,c,l,h){return norm(a,y,c,l,h,lt);},le:function(a,y,c,l,h){return norm(a,y,c,l,h,le);},eq:function(a,y,c,l,h){return norm(a,y,c,l,h,eq);}};/***/},/***/2288:/***/function(__unused_webpack_module,exports){"use strict";/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */"use restrict";//Number of bits in an integer
var INT_BITS=32;//Constants
exports.INT_BITS=INT_BITS;exports.INT_MAX=0x7fffffff;exports.INT_MIN=-1<<INT_BITS-1;//Returns -1, 0, +1 depending on sign of x
exports.sign=function(v){return(v>0)-(v<0);};//Computes absolute value of integer
exports.abs=function(v){var mask=v>>INT_BITS-1;return(v^mask)-mask;};//Computes minimum of integers x and y
exports.min=function(x,y){return y^(x^y)&-(x<y);};//Computes maximum of integers x and y
exports.max=function(x,y){return x^(x^y)&-(x<y);};//Checks if a number is a power of two
exports.isPow2=function(v){return!(v&v-1)&&!!v;};//Computes log base 2 of v
exports.log2=function(v){var r,shift;r=(v>0xFFFF)<<4;v>>>=r;shift=(v>0xFF)<<3;v>>>=shift;r|=shift;shift=(v>0xF)<<2;v>>>=shift;r|=shift;shift=(v>0x3)<<1;v>>>=shift;r|=shift;return r|v>>1;};//Computes log base 10 of v
exports.log10=function(v){return v>=1000000000?9:v>=100000000?8:v>=10000000?7:v>=1000000?6:v>=100000?5:v>=10000?4:v>=1000?3:v>=100?2:v>=10?1:0;};//Counts number of bits
exports.popCount=function(v){v=v-(v>>>1&0x55555555);v=(v&0x33333333)+(v>>>2&0x33333333);return(v+(v>>>4)&0xF0F0F0F)*0x1010101>>>24;};//Counts number of trailing zeros
function countTrailingZeros(v){var c=32;v&=-v;if(v)c--;if(v&0x0000FFFF)c-=16;if(v&0x00FF00FF)c-=8;if(v&0x0F0F0F0F)c-=4;if(v&0x33333333)c-=2;if(v&0x55555555)c-=1;return c;}exports.countTrailingZeros=countTrailingZeros;//Rounds to next power of 2
exports.nextPow2=function(v){v+=v===0;--v;v|=v>>>1;v|=v>>>2;v|=v>>>4;v|=v>>>8;v|=v>>>16;return v+1;};//Rounds down to previous power of 2
exports.prevPow2=function(v){v|=v>>>1;v|=v>>>2;v|=v>>>4;v|=v>>>8;v|=v>>>16;return v-(v>>>1);};//Computes parity of word
exports.parity=function(v){v^=v>>>16;v^=v>>>8;v^=v>>>4;v&=0xf;return 0x6996>>>v&1;};var REVERSE_TABLE=new Array(256);(function(tab){for(var i=0;i<256;++i){var v=i,r=i,s=7;for(v>>>=1;v;v>>>=1){r<<=1;r|=v&1;--s;}tab[i]=r<<s&0xff;}})(REVERSE_TABLE);//Reverse bits in a 32 bit word
exports.reverse=function(v){return REVERSE_TABLE[v&0xff]<<24|REVERSE_TABLE[v>>>8&0xff]<<16|REVERSE_TABLE[v>>>16&0xff]<<8|REVERSE_TABLE[v>>>24&0xff];};//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2=function(x,y){x&=0xFFFF;x=(x|x<<8)&0x00FF00FF;x=(x|x<<4)&0x0F0F0F0F;x=(x|x<<2)&0x33333333;x=(x|x<<1)&0x55555555;y&=0xFFFF;y=(y|y<<8)&0x00FF00FF;y=(y|y<<4)&0x0F0F0F0F;y=(y|y<<2)&0x33333333;y=(y|y<<1)&0x55555555;return x|y<<1;};//Extracts the nth interleaved component
exports.deinterleave2=function(v,n){v=v>>>n&0x55555555;v=(v|v>>>1)&0x33333333;v=(v|v>>>2)&0x0F0F0F0F;v=(v|v>>>4)&0x00FF00FF;v=(v|v>>>16)&0x000FFFF;return v<<16>>16;};//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3=function(x,y,z){x&=0x3FF;x=(x|x<<16)&4278190335;x=(x|x<<8)&251719695;x=(x|x<<4)&3272356035;x=(x|x<<2)&1227133513;y&=0x3FF;y=(y|y<<16)&4278190335;y=(y|y<<8)&251719695;y=(y|y<<4)&3272356035;y=(y|y<<2)&1227133513;x|=y<<1;z&=0x3FF;z=(z|z<<16)&4278190335;z=(z|z<<8)&251719695;z=(z|z<<4)&3272356035;z=(z|z<<2)&1227133513;return x|z<<2;};//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3=function(v,n){v=v>>>n&1227133513;v=(v|v>>>2)&3272356035;v=(v|v>>>4)&251719695;v=(v|v>>>8)&4278190335;v=(v|v>>>16)&0x3FF;return v<<22>>22;};//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination=function(v){var t=v|v-1;return t+1|(~t&-~t)-1>>>countTrailingZeros(v)+1;};/***/},/***/1928:/***/function(module,__unused_webpack_exports,__nested_webpack_require_75889__){/* module decorator */module=__nested_webpack_require_75889__.nmd(module);(function(module,exports){'use strict';// Utils
function assert(val,msg){if(!val)throw new Error(msg||'Assertion failed');}// Could use `inherits` module, but don't want to move from single file
// architecture yet.
function inherits(ctor,superCtor){ctor.super_=superCtor;var TempCtor=function(){};TempCtor.prototype=superCtor.prototype;ctor.prototype=new TempCtor();ctor.prototype.constructor=ctor;}// BN
function BN(number,base,endian){if(BN.isBN(number)){return number;}this.negative=0;this.words=null;this.length=0;// Reduction context
this.red=null;if(number!==null){if(base==='le'||base==='be'){endian=base;base=10;}this._init(number||0,base||10,endian||'be');}}if(typeof module==='object'){module.exports=BN;}else{exports.BN=BN;}BN.BN=BN;BN.wordSize=26;var Buffer;try{if(typeof window!=='undefined'&&typeof window.Buffer!=='undefined'){Buffer=window.Buffer;}else{Buffer=__nested_webpack_require_75889__(6601).Buffer;}}catch(e){}BN.isBN=function isBN(num){if(num instanceof BN){return true;}return num!==null&&typeof num==='object'&&num.constructor.wordSize===BN.wordSize&&Array.isArray(num.words);};BN.max=function max(left,right){if(left.cmp(right)>0)return left;return right;};BN.min=function min(left,right){if(left.cmp(right)<0)return left;return right;};BN.prototype._init=function init(number,base,endian){if(typeof number==='number'){return this._initNumber(number,base,endian);}if(typeof number==='object'){return this._initArray(number,base,endian);}if(base==='hex'){base=16;}assert(base===(base|0)&&base>=2&&base<=36);number=number.toString().replace(/\s+/g,'');var start=0;if(number[0]==='-'){start++;this.negative=1;}if(start<number.length){if(base===16){this._parseHex(number,start,endian);}else{this._parseBase(number,base,start);if(endian==='le'){this._initArray(this.toArray(),base,endian);}}}};BN.prototype._initNumber=function _initNumber(number,base,endian){if(number<0){this.negative=1;number=-number;}if(number<0x4000000){this.words=[number&0x3ffffff];this.length=1;}else if(number<0x10000000000000){this.words=[number&0x3ffffff,number/0x4000000&0x3ffffff];this.length=2;}else{assert(number<0x20000000000000);// 2 ^ 53 (unsafe)
this.words=[number&0x3ffffff,number/0x4000000&0x3ffffff,1];this.length=3;}if(endian!=='le')return;// Reverse the bytes
this._initArray(this.toArray(),base,endian);};BN.prototype._initArray=function _initArray(number,base,endian){// Perhaps a Uint8Array
assert(typeof number.length==='number');if(number.length<=0){this.words=[0];this.length=1;return this;}this.length=Math.ceil(number.length/3);this.words=new Array(this.length);for(var i=0;i<this.length;i++){this.words[i]=0;}var j,w;var off=0;if(endian==='be'){for(i=number.length-1,j=0;i>=0;i-=3){w=number[i]|number[i-1]<<8|number[i-2]<<16;this.words[j]|=w<<off&0x3ffffff;this.words[j+1]=w>>>26-off&0x3ffffff;off+=24;if(off>=26){off-=26;j++;}}}else if(endian==='le'){for(i=0,j=0;i<number.length;i+=3){w=number[i]|number[i+1]<<8|number[i+2]<<16;this.words[j]|=w<<off&0x3ffffff;this.words[j+1]=w>>>26-off&0x3ffffff;off+=24;if(off>=26){off-=26;j++;}}}return this.strip();};function parseHex4Bits(string,index){var c=string.charCodeAt(index);// 'A' - 'F'
if(c>=65&&c<=70){return c-55;// 'a' - 'f'
}else if(c>=97&&c<=102){return c-87;// '0' - '9'
}else{return c-48&0xf;}}function parseHexByte(string,lowerBound,index){var r=parseHex4Bits(string,index);if(index-1>=lowerBound){r|=parseHex4Bits(string,index-1)<<4;}return r;}BN.prototype._parseHex=function _parseHex(number,start,endian){// Create possibly bigger array to ensure that it fits the number
this.length=Math.ceil((number.length-start)/6);this.words=new Array(this.length);for(var i=0;i<this.length;i++){this.words[i]=0;}// 24-bits chunks
var off=0;var j=0;var w;if(endian==='be'){for(i=number.length-1;i>=start;i-=2){w=parseHexByte(number,start,i)<<off;this.words[j]|=w&0x3ffffff;if(off>=18){off-=18;j+=1;this.words[j]|=w>>>26;}else{off+=8;}}}else{var parseLength=number.length-start;for(i=parseLength%2===0?start+1:start;i<number.length;i+=2){w=parseHexByte(number,start,i)<<off;this.words[j]|=w&0x3ffffff;if(off>=18){off-=18;j+=1;this.words[j]|=w>>>26;}else{off+=8;}}}this.strip();};function parseBase(str,start,end,mul){var r=0;var len=Math.min(str.length,end);for(var i=start;i<len;i++){var c=str.charCodeAt(i)-48;r*=mul;// 'a'
if(c>=49){r+=c-49+0xa;// 'A'
}else if(c>=17){r+=c-17+0xa;// '0' - '9'
}else{r+=c;}}return r;}BN.prototype._parseBase=function _parseBase(number,base,start){// Initialize as zero
this.words=[0];this.length=1;// Find length of limb in base
for(var limbLen=0,limbPow=1;limbPow<=0x3ffffff;limbPow*=base){limbLen++;}limbLen--;limbPow=limbPow/base|0;var total=number.length-start;var mod=total%limbLen;var end=Math.min(total,total-mod)+start;var word=0;for(var i=start;i<end;i+=limbLen){word=parseBase(number,i,i+limbLen,base);this.imuln(limbPow);if(this.words[0]+word<0x4000000){this.words[0]+=word;}else{this._iaddn(word);}}if(mod!==0){var pow=1;word=parseBase(number,i,number.length,base);for(i=0;i<mod;i++){pow*=base;}this.imuln(pow);if(this.words[0]+word<0x4000000){this.words[0]+=word;}else{this._iaddn(word);}}this.strip();};BN.prototype.copy=function copy(dest){dest.words=new Array(this.length);for(var i=0;i<this.length;i++){dest.words[i]=this.words[i];}dest.length=this.length;dest.negative=this.negative;dest.red=this.red;};BN.prototype.clone=function clone(){var r=new BN(null);this.copy(r);return r;};BN.prototype._expand=function _expand(size){while(this.length<size){this.words[this.length++]=0;}return this;};// Remove leading `0` from `this`
BN.prototype.strip=function strip(){while(this.length>1&&this.words[this.length-1]===0){this.length--;}return this._normSign();};BN.prototype._normSign=function _normSign(){// -0 = 0
if(this.length===1&&this.words[0]===0){this.negative=0;}return this;};BN.prototype.inspect=function inspect(){return(this.red?'<BN-R: ':'<BN: ')+this.toString(16)+'>';};/*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */var zeros=['','0','00','000','0000','00000','000000','0000000','00000000','000000000','0000000000','00000000000','000000000000','0000000000000','00000000000000','000000000000000','0000000000000000','00000000000000000','000000000000000000','0000000000000000000','00000000000000000000','000000000000000000000','0000000000000000000000','00000000000000000000000','000000000000000000000000','0000000000000000000000000'];var groupSizes=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5];var groupBases=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,10000000,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64000000,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,24300000,28629151,33554432,39135393,45435424,52521875,60466176];BN.prototype.toString=function toString(base,padding){base=base||10;padding=padding|0||1;var out;if(base===16||base==='hex'){out='';var off=0;var carry=0;for(var i=0;i<this.length;i++){var w=this.words[i];var word=((w<<off|carry)&0xffffff).toString(16);carry=w>>>24-off&0xffffff;if(carry!==0||i!==this.length-1){out=zeros[6-word.length]+word+out;}else{out=word+out;}off+=2;if(off>=26){off-=26;i--;}}if(carry!==0){out=carry.toString(16)+out;}while(out.length%padding!==0){out='0'+out;}if(this.negative!==0){out='-'+out;}return out;}if(base===(base|0)&&base>=2&&base<=36){// var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
var groupSize=groupSizes[base];// var groupBase = Math.pow(base, groupSize);
var groupBase=groupBases[base];out='';var c=this.clone();c.negative=0;while(!c.isZero()){var r=c.modn(groupBase).toString(base);c=c.idivn(groupBase);if(!c.isZero()){out=zeros[groupSize-r.length]+r+out;}else{out=r+out;}}if(this.isZero()){out='0'+out;}while(out.length%padding!==0){out='0'+out;}if(this.negative!==0){out='-'+out;}return out;}assert(false,'Base should be between 2 and 36');};BN.prototype.toNumber=function toNumber(){var ret=this.words[0];if(this.length===2){ret+=this.words[1]*0x4000000;}else if(this.length===3&&this.words[2]===0x01){// NOTE: at this stage it is known that the top bit is set
ret+=0x10000000000000+this.words[1]*0x4000000;}else if(this.length>2){assert(false,'Number can only safely store up to 53 bits');}return this.negative!==0?-ret:ret;};BN.prototype.toJSON=function toJSON(){return this.toString(16);};BN.prototype.toBuffer=function toBuffer(endian,length){assert(typeof Buffer!=='undefined');return this.toArrayLike(Buffer,endian,length);};BN.prototype.toArray=function toArray(endian,length){return this.toArrayLike(Array,endian,length);};BN.prototype.toArrayLike=function toArrayLike(ArrayType,endian,length){var byteLength=this.byteLength();var reqLength=length||Math.max(1,byteLength);assert(byteLength<=reqLength,'byte array longer than desired length');assert(reqLength>0,'Requested array length <= 0');this.strip();var littleEndian=endian==='le';var res=new ArrayType(reqLength);var b,i;var q=this.clone();if(!littleEndian){// Assume big-endian
for(i=0;i<reqLength-byteLength;i++){res[i]=0;}for(i=0;!q.isZero();i++){b=q.andln(0xff);q.iushrn(8);res[reqLength-i-1]=b;}}else{for(i=0;!q.isZero();i++){b=q.andln(0xff);q.iushrn(8);res[i]=b;}for(;i<reqLength;i++){res[i]=0;}}return res;};if(Math.clz32){BN.prototype._countBits=function _countBits(w){return 32-Math.clz32(w);};}else{BN.prototype._countBits=function _countBits(w){var t=w;var r=0;if(t>=0x1000){r+=13;t>>>=13;}if(t>=0x40){r+=7;t>>>=7;}if(t>=0x8){r+=4;t>>>=4;}if(t>=0x02){r+=2;t>>>=2;}return r+t;};}BN.prototype._zeroBits=function _zeroBits(w){// Short-cut
if(w===0)return 26;var t=w;var r=0;if((t&0x1fff)===0){r+=13;t>>>=13;}if((t&0x7f)===0){r+=7;t>>>=7;}if((t&0xf)===0){r+=4;t>>>=4;}if((t&0x3)===0){r+=2;t>>>=2;}if((t&0x1)===0){r++;}return r;};// Return number of used bits in a BN
BN.prototype.bitLength=function bitLength(){var w=this.words[this.length-1];var hi=this._countBits(w);return(this.length-1)*26+hi;};function toBitArray(num){var w=new Array(num.bitLength());for(var bit=0;bit<w.length;bit++){var off=bit/26|0;var wbit=bit%26;w[bit]=(num.words[off]&1<<wbit)>>>wbit;}return w;}// Number of trailing zero bits
BN.prototype.zeroBits=function zeroBits(){if(this.isZero())return 0;var r=0;for(var i=0;i<this.length;i++){var b=this._zeroBits(this.words[i]);r+=b;if(b!==26)break;}return r;};BN.prototype.byteLength=function byteLength(){return Math.ceil(this.bitLength()/8);};BN.prototype.toTwos=function toTwos(width){if(this.negative!==0){return this.abs().inotn(width).iaddn(1);}return this.clone();};BN.prototype.fromTwos=function fromTwos(width){if(this.testn(width-1)){return this.notn(width).iaddn(1).ineg();}return this.clone();};BN.prototype.isNeg=function isNeg(){return this.negative!==0;};// Return negative clone of `this`
BN.prototype.neg=function neg(){return this.clone().ineg();};BN.prototype.ineg=function ineg(){if(!this.isZero()){this.negative^=1;}return this;};// Or `num` with `this` in-place
BN.prototype.iuor=function iuor(num){while(this.length<num.length){this.words[this.length++]=0;}for(var i=0;i<num.length;i++){this.words[i]=this.words[i]|num.words[i];}return this.strip();};BN.prototype.ior=function ior(num){assert((this.negative|num.negative)===0);return this.iuor(num);};// Or `num` with `this`
BN.prototype.or=function or(num){if(this.length>num.length)return this.clone().ior(num);return num.clone().ior(this);};BN.prototype.uor=function uor(num){if(this.length>num.length)return this.clone().iuor(num);return num.clone().iuor(this);};// And `num` with `this` in-place
BN.prototype.iuand=function iuand(num){// b = min-length(num, this)
var b;if(this.length>num.length){b=num;}else{b=this;}for(var i=0;i<b.length;i++){this.words[i]=this.words[i]&num.words[i];}this.length=b.length;return this.strip();};BN.prototype.iand=function iand(num){assert((this.negative|num.negative)===0);return this.iuand(num);};// And `num` with `this`
BN.prototype.and=function and(num){if(this.length>num.length)return this.clone().iand(num);return num.clone().iand(this);};BN.prototype.uand=function uand(num){if(this.length>num.length)return this.clone().iuand(num);return num.clone().iuand(this);};// Xor `num` with `this` in-place
BN.prototype.iuxor=function iuxor(num){// a.length > b.length
var a;var b;if(this.length>num.length){a=this;b=num;}else{a=num;b=this;}for(var i=0;i<b.length;i++){this.words[i]=a.words[i]^b.words[i];}if(this!==a){for(;i<a.length;i++){this.words[i]=a.words[i];}}this.length=a.length;return this.strip();};BN.prototype.ixor=function ixor(num){assert((this.negative|num.negative)===0);return this.iuxor(num);};// Xor `num` with `this`
BN.prototype.xor=function xor(num){if(this.length>num.length)return this.clone().ixor(num);return num.clone().ixor(this);};BN.prototype.uxor=function uxor(num){if(this.length>num.length)return this.clone().iuxor(num);return num.clone().iuxor(this);};// Not ``this`` with ``width`` bitwidth
BN.prototype.inotn=function inotn(width){assert(typeof width==='number'&&width>=0);var bytesNeeded=Math.ceil(width/26)|0;var bitsLeft=width%26;// Extend the buffer with leading zeroes
this._expand(bytesNeeded);if(bitsLeft>0){bytesNeeded--;}// Handle complete words
for(var i=0;i<bytesNeeded;i++){this.words[i]=~this.words[i]&0x3ffffff;}// Handle the residue
if(bitsLeft>0){this.words[i]=~this.words[i]&0x3ffffff>>26-bitsLeft;}// And remove leading zeroes
return this.strip();};BN.prototype.notn=function notn(width){return this.clone().inotn(width);};// Set `bit` of `this`
BN.prototype.setn=function setn(bit,val){assert(typeof bit==='number'&&bit>=0);var off=bit/26|0;var wbit=bit%26;this._expand(off+1);if(val){this.words[off]=this.words[off]|1<<wbit;}else{this.words[off]=this.words[off]&~(1<<wbit);}return this.strip();};// Add `num` to `this` in-place
BN.prototype.iadd=function iadd(num){var r;// negative + positive
if(this.negative!==0&&num.negative===0){this.negative=0;r=this.isub(num);this.negative^=1;return this._normSign();// positive + negative
}else if(this.negative===0&&num.negative!==0){num.negative=0;r=this.isub(num);num.negative=1;return r._normSign();}// a.length > b.length
var a,b;if(this.length>num.length){a=this;b=num;}else{a=num;b=this;}var carry=0;for(var i=0;i<b.length;i++){r=(a.words[i]|0)+(b.words[i]|0)+carry;this.words[i]=r&0x3ffffff;carry=r>>>26;}for(;carry!==0&&i<a.length;i++){r=(a.words[i]|0)+carry;this.words[i]=r&0x3ffffff;carry=r>>>26;}this.length=a.length;if(carry!==0){this.words[this.length]=carry;this.length++;// Copy the rest of the words
}else if(a!==this){for(;i<a.length;i++){this.words[i]=a.words[i];}}return this;};// Add `num` to `this`
BN.prototype.add=function add(num){var res;if(num.negative!==0&&this.negative===0){num.negative=0;res=this.sub(num);num.negative^=1;return res;}else if(num.negative===0&&this.negative!==0){this.negative=0;res=num.sub(this);this.negative=1;return res;}if(this.length>num.length)return this.clone().iadd(num);return num.clone().iadd(this);};// Subtract `num` from `this` in-place
BN.prototype.isub=function isub(num){// this - (-num) = this + num
if(num.negative!==0){num.negative=0;var r=this.iadd(num);num.negative=1;return r._normSign();// -this - num = -(this + num)
}else if(this.negative!==0){this.negative=0;this.iadd(num);this.negative=1;return this._normSign();}// At this point both numbers are positive
var cmp=this.cmp(num);// Optimization - zeroify
if(cmp===0){this.negative=0;this.length=1;this.words[0]=0;return this;}// a > b
var a,b;if(cmp>0){a=this;b=num;}else{a=num;b=this;}var carry=0;for(var i=0;i<b.length;i++){r=(a.words[i]|0)-(b.words[i]|0)+carry;carry=r>>26;this.words[i]=r&0x3ffffff;}for(;carry!==0&&i<a.length;i++){r=(a.words[i]|0)+carry;carry=r>>26;this.words[i]=r&0x3ffffff;}// Copy rest of the words
if(carry===0&&i<a.length&&a!==this){for(;i<a.length;i++){this.words[i]=a.words[i];}}this.length=Math.max(this.length,i);if(a!==this){this.negative=1;}return this.strip();};// Subtract `num` from `this`
BN.prototype.sub=function sub(num){return this.clone().isub(num);};function smallMulTo(self,num,out){out.negative=num.negative^self.negative;var len=self.length+num.length|0;out.length=len;len=len-1|0;// Peel one iteration (compiler can't do it, because of code complexity)
var a=self.words[0]|0;var b=num.words[0]|0;var r=a*b;var lo=r&0x3ffffff;var carry=r/0x4000000|0;out.words[0]=lo;for(var k=1;k<len;k++){// Sum all words with the same `i + j = k` and accumulate `ncarry`,
// note that ncarry could be >= 0x3ffffff
var ncarry=carry>>>26;var rword=carry&0x3ffffff;var maxJ=Math.min(k,num.length-1);for(var j=Math.max(0,k-self.length+1);j<=maxJ;j++){var i=k-j|0;a=self.words[i]|0;b=num.words[j]|0;r=a*b+rword;ncarry+=r/0x4000000|0;rword=r&0x3ffffff;}out.words[k]=rword|0;carry=ncarry|0;}if(carry!==0){out.words[k]=carry|0;}else{out.length--;}return out.strip();}// TODO(indutny): it may be reasonable to omit it for users who don't need
// to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
// multiplication (like elliptic secp256k1).
var comb10MulTo=function comb10MulTo(self,num,out){var a=self.words;var b=num.words;var o=out.words;var c=0;var lo;var mid;var hi;var a0=a[0]|0;var al0=a0&0x1fff;var ah0=a0>>>13;var a1=a[1]|0;var al1=a1&0x1fff;var ah1=a1>>>13;var a2=a[2]|0;var al2=a2&0x1fff;var ah2=a2>>>13;var a3=a[3]|0;var al3=a3&0x1fff;var ah3=a3>>>13;var a4=a[4]|0;var al4=a4&0x1fff;var ah4=a4>>>13;var a5=a[5]|0;var al5=a5&0x1fff;var ah5=a5>>>13;var a6=a[6]|0;var al6=a6&0x1fff;var ah6=a6>>>13;var a7=a[7]|0;var al7=a7&0x1fff;var ah7=a7>>>13;var a8=a[8]|0;var al8=a8&0x1fff;var ah8=a8>>>13;var a9=a[9]|0;var al9=a9&0x1fff;var ah9=a9>>>13;var b0=b[0]|0;var bl0=b0&0x1fff;var bh0=b0>>>13;var b1=b[1]|0;var bl1=b1&0x1fff;var bh1=b1>>>13;var b2=b[2]|0;var bl2=b2&0x1fff;var bh2=b2>>>13;var b3=b[3]|0;var bl3=b3&0x1fff;var bh3=b3>>>13;var b4=b[4]|0;var bl4=b4&0x1fff;var bh4=b4>>>13;var b5=b[5]|0;var bl5=b5&0x1fff;var bh5=b5>>>13;var b6=b[6]|0;var bl6=b6&0x1fff;var bh6=b6>>>13;var b7=b[7]|0;var bl7=b7&0x1fff;var bh7=b7>>>13;var b8=b[8]|0;var bl8=b8&0x1fff;var bh8=b8>>>13;var b9=b[9]|0;var bl9=b9&0x1fff;var bh9=b9>>>13;out.negative=self.negative^num.negative;out.length=19;/* k = 0 */lo=Math.imul(al0,bl0);mid=Math.imul(al0,bh0);mid=mid+Math.imul(ah0,bl0)|0;hi=Math.imul(ah0,bh0);var w0=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w0>>>26)|0;w0&=0x3ffffff;/* k = 1 */lo=Math.imul(al1,bl0);mid=Math.imul(al1,bh0);mid=mid+Math.imul(ah1,bl0)|0;hi=Math.imul(ah1,bh0);lo=lo+Math.imul(al0,bl1)|0;mid=mid+Math.imul(al0,bh1)|0;mid=mid+Math.imul(ah0,bl1)|0;hi=hi+Math.imul(ah0,bh1)|0;var w1=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w1>>>26)|0;w1&=0x3ffffff;/* k = 2 */lo=Math.imul(al2,bl0);mid=Math.imul(al2,bh0);mid=mid+Math.imul(ah2,bl0)|0;hi=Math.imul(ah2,bh0);lo=lo+Math.imul(al1,bl1)|0;mid=mid+Math.imul(al1,bh1)|0;mid=mid+Math.imul(ah1,bl1)|0;hi=hi+Math.imul(ah1,bh1)|0;lo=lo+Math.imul(al0,bl2)|0;mid=mid+Math.imul(al0,bh2)|0;mid=mid+Math.imul(ah0,bl2)|0;hi=hi+Math.imul(ah0,bh2)|0;var w2=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w2>>>26)|0;w2&=0x3ffffff;/* k = 3 */lo=Math.imul(al3,bl0);mid=Math.imul(al3,bh0);mid=mid+Math.imul(ah3,bl0)|0;hi=Math.imul(ah3,bh0);lo=lo+Math.imul(al2,bl1)|0;mid=mid+Math.imul(al2,bh1)|0;mid=mid+Math.imul(ah2,bl1)|0;hi=hi+Math.imul(ah2,bh1)|0;lo=lo+Math.imul(al1,bl2)|0;mid=mid+Math.imul(al1,bh2)|0;mid=mid+Math.imul(ah1,bl2)|0;hi=hi+Math.imul(ah1,bh2)|0;lo=lo+Math.imul(al0,bl3)|0;mid=mid+Math.imul(al0,bh3)|0;mid=mid+Math.imul(ah0,bl3)|0;hi=hi+Math.imul(ah0,bh3)|0;var w3=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w3>>>26)|0;w3&=0x3ffffff;/* k = 4 */lo=Math.imul(al4,bl0);mid=Math.imul(al4,bh0);mid=mid+Math.imul(ah4,bl0)|0;hi=Math.imul(ah4,bh0);lo=lo+Math.imul(al3,bl1)|0;mid=mid+Math.imul(al3,bh1)|0;mid=mid+Math.imul(ah3,bl1)|0;hi=hi+Math.imul(ah3,bh1)|0;lo=lo+Math.imul(al2,bl2)|0;mid=mid+Math.imul(al2,bh2)|0;mid=mid+Math.imul(ah2,bl2)|0;hi=hi+Math.imul(ah2,bh2)|0;lo=lo+Math.imul(al1,bl3)|0;mid=mid+Math.imul(al1,bh3)|0;mid=mid+Math.imul(ah1,bl3)|0;hi=hi+Math.imul(ah1,bh3)|0;lo=lo+Math.imul(al0,bl4)|0;mid=mid+Math.imul(al0,bh4)|0;mid=mid+Math.imul(ah0,bl4)|0;hi=hi+Math.imul(ah0,bh4)|0;var w4=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w4>>>26)|0;w4&=0x3ffffff;/* k = 5 */lo=Math.imul(al5,bl0);mid=Math.imul(al5,bh0);mid=mid+Math.imul(ah5,bl0)|0;hi=Math.imul(ah5,bh0);lo=lo+Math.imul(al4,bl1)|0;mid=mid+Math.imul(al4,bh1)|0;mid=mid+Math.imul(ah4,bl1)|0;hi=hi+Math.imul(ah4,bh1)|0;lo=lo+Math.imul(al3,bl2)|0;mid=mid+Math.imul(al3,bh2)|0;mid=mid+Math.imul(ah3,bl2)|0;hi=hi+Math.imul(ah3,bh2)|0;lo=lo+Math.imul(al2,bl3)|0;mid=mid+Math.imul(al2,bh3)|0;mid=mid+Math.imul(ah2,bl3)|0;hi=hi+Math.imul(ah2,bh3)|0;lo=lo+Math.imul(al1,bl4)|0;mid=mid+Math.imul(al1,bh4)|0;mid=mid+Math.imul(ah1,bl4)|0;hi=hi+Math.imul(ah1,bh4)|0;lo=lo+Math.imul(al0,bl5)|0;mid=mid+Math.imul(al0,bh5)|0;mid=mid+Math.imul(ah0,bl5)|0;hi=hi+Math.imul(ah0,bh5)|0;var w5=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w5>>>26)|0;w5&=0x3ffffff;/* k = 6 */lo=Math.imul(al6,bl0);mid=Math.imul(al6,bh0);mid=mid+Math.imul(ah6,bl0)|0;hi=Math.imul(ah6,bh0);lo=lo+Math.imul(al5,bl1)|0;mid=mid+Math.imul(al5,bh1)|0;mid=mid+Math.imul(ah5,bl1)|0;hi=hi+Math.imul(ah5,bh1)|0;lo=lo+Math.imul(al4,bl2)|0;mid=mid+Math.imul(al4,bh2)|0;mid=mid+Math.imul(ah4,bl2)|0;hi=hi+Math.imul(ah4,bh2)|0;lo=lo+Math.imul(al3,bl3)|0;mid=mid+Math.imul(al3,bh3)|0;mid=mid+Math.imul(ah3,bl3)|0;hi=hi+Math.imul(ah3,bh3)|0;lo=lo+Math.imul(al2,bl4)|0;mid=mid+Math.imul(al2,bh4)|0;mid=mid+Math.imul(ah2,bl4)|0;hi=hi+Math.imul(ah2,bh4)|0;lo=lo+Math.imul(al1,bl5)|0;mid=mid+Math.imul(al1,bh5)|0;mid=mid+Math.imul(ah1,bl5)|0;hi=hi+Math.imul(ah1,bh5)|0;lo=lo+Math.imul(al0,bl6)|0;mid=mid+Math.imul(al0,bh6)|0;mid=mid+Math.imul(ah0,bl6)|0;hi=hi+Math.imul(ah0,bh6)|0;var w6=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w6>>>26)|0;w6&=0x3ffffff;/* k = 7 */lo=Math.imul(al7,bl0);mid=Math.imul(al7,bh0);mid=mid+Math.imul(ah7,bl0)|0;hi=Math.imul(ah7,bh0);lo=lo+Math.imul(al6,bl1)|0;mid=mid+Math.imul(al6,bh1)|0;mid=mid+Math.imul(ah6,bl1)|0;hi=hi+Math.imul(ah6,bh1)|0;lo=lo+Math.imul(al5,bl2)|0;mid=mid+Math.imul(al5,bh2)|0;mid=mid+Math.imul(ah5,bl2)|0;hi=hi+Math.imul(ah5,bh2)|0;lo=lo+Math.imul(al4,bl3)|0;mid=mid+Math.imul(al4,bh3)|0;mid=mid+Math.imul(ah4,bl3)|0;hi=hi+Math.imul(ah4,bh3)|0;lo=lo+Math.imul(al3,bl4)|0;mid=mid+Math.imul(al3,bh4)|0;mid=mid+Math.imul(ah3,bl4)|0;hi=hi+Math.imul(ah3,bh4)|0;lo=lo+Math.imul(al2,bl5)|0;mid=mid+Math.imul(al2,bh5)|0;mid=mid+Math.imul(ah2,bl5)|0;hi=hi+Math.imul(ah2,bh5)|0;lo=lo+Math.imul(al1,bl6)|0;mid=mid+Math.imul(al1,bh6)|0;mid=mid+Math.imul(ah1,bl6)|0;hi=hi+Math.imul(ah1,bh6)|0;lo=lo+Math.imul(al0,bl7)|0;mid=mid+Math.imul(al0,bh7)|0;mid=mid+Math.imul(ah0,bl7)|0;hi=hi+Math.imul(ah0,bh7)|0;var w7=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w7>>>26)|0;w7&=0x3ffffff;/* k = 8 */lo=Math.imul(al8,bl0);mid=Math.imul(al8,bh0);mid=mid+Math.imul(ah8,bl0)|0;hi=Math.imul(ah8,bh0);lo=lo+Math.imul(al7,bl1)|0;mid=mid+Math.imul(al7,bh1)|0;mid=mid+Math.imul(ah7,bl1)|0;hi=hi+Math.imul(ah7,bh1)|0;lo=lo+Math.imul(al6,bl2)|0;mid=mid+Math.imul(al6,bh2)|0;mid=mid+Math.imul(ah6,bl2)|0;hi=hi+Math.imul(ah6,bh2)|0;lo=lo+Math.imul(al5,bl3)|0;mid=mid+Math.imul(al5,bh3)|0;mid=mid+Math.imul(ah5,bl3)|0;hi=hi+Math.imul(ah5,bh3)|0;lo=lo+Math.imul(al4,bl4)|0;mid=mid+Math.imul(al4,bh4)|0;mid=mid+Math.imul(ah4,bl4)|0;hi=hi+Math.imul(ah4,bh4)|0;lo=lo+Math.imul(al3,bl5)|0;mid=mid+Math.imul(al3,bh5)|0;mid=mid+Math.imul(ah3,bl5)|0;hi=hi+Math.imul(ah3,bh5)|0;lo=lo+Math.imul(al2,bl6)|0;mid=mid+Math.imul(al2,bh6)|0;mid=mid+Math.imul(ah2,bl6)|0;hi=hi+Math.imul(ah2,bh6)|0;lo=lo+Math.imul(al1,bl7)|0;mid=mid+Math.imul(al1,bh7)|0;mid=mid+Math.imul(ah1,bl7)|0;hi=hi+Math.imul(ah1,bh7)|0;lo=lo+Math.imul(al0,bl8)|0;mid=mid+Math.imul(al0,bh8)|0;mid=mid+Math.imul(ah0,bl8)|0;hi=hi+Math.imul(ah0,bh8)|0;var w8=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w8>>>26)|0;w8&=0x3ffffff;/* k = 9 */lo=Math.imul(al9,bl0);mid=Math.imul(al9,bh0);mid=mid+Math.imul(ah9,bl0)|0;hi=Math.imul(ah9,bh0);lo=lo+Math.imul(al8,bl1)|0;mid=mid+Math.imul(al8,bh1)|0;mid=mid+Math.imul(ah8,bl1)|0;hi=hi+Math.imul(ah8,bh1)|0;lo=lo+Math.imul(al7,bl2)|0;mid=mid+Math.imul(al7,bh2)|0;mid=mid+Math.imul(ah7,bl2)|0;hi=hi+Math.imul(ah7,bh2)|0;lo=lo+Math.imul(al6,bl3)|0;mid=mid+Math.imul(al6,bh3)|0;mid=mid+Math.imul(ah6,bl3)|0;hi=hi+Math.imul(ah6,bh3)|0;lo=lo+Math.imul(al5,bl4)|0;mid=mid+Math.imul(al5,bh4)|0;mid=mid+Math.imul(ah5,bl4)|0;hi=hi+Math.imul(ah5,bh4)|0;lo=lo+Math.imul(al4,bl5)|0;mid=mid+Math.imul(al4,bh5)|0;mid=mid+Math.imul(ah4,bl5)|0;hi=hi+Math.imul(ah4,bh5)|0;lo=lo+Math.imul(al3,bl6)|0;mid=mid+Math.imul(al3,bh6)|0;mid=mid+Math.imul(ah3,bl6)|0;hi=hi+Math.imul(ah3,bh6)|0;lo=lo+Math.imul(al2,bl7)|0;mid=mid+Math.imul(al2,bh7)|0;mid=mid+Math.imul(ah2,bl7)|0;hi=hi+Math.imul(ah2,bh7)|0;lo=lo+Math.imul(al1,bl8)|0;mid=mid+Math.imul(al1,bh8)|0;mid=mid+Math.imul(ah1,bl8)|0;hi=hi+Math.imul(ah1,bh8)|0;lo=lo+Math.imul(al0,bl9)|0;mid=mid+Math.imul(al0,bh9)|0;mid=mid+Math.imul(ah0,bl9)|0;hi=hi+Math.imul(ah0,bh9)|0;var w9=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w9>>>26)|0;w9&=0x3ffffff;/* k = 10 */lo=Math.imul(al9,bl1);mid=Math.imul(al9,bh1);mid=mid+Math.imul(ah9,bl1)|0;hi=Math.imul(ah9,bh1);lo=lo+Math.imul(al8,bl2)|0;mid=mid+Math.imul(al8,bh2)|0;mid=mid+Math.imul(ah8,bl2)|0;hi=hi+Math.imul(ah8,bh2)|0;lo=lo+Math.imul(al7,bl3)|0;mid=mid+Math.imul(al7,bh3)|0;mid=mid+Math.imul(ah7,bl3)|0;hi=hi+Math.imul(ah7,bh3)|0;lo=lo+Math.imul(al6,bl4)|0;mid=mid+Math.imul(al6,bh4)|0;mid=mid+Math.imul(ah6,bl4)|0;hi=hi+Math.imul(ah6,bh4)|0;lo=lo+Math.imul(al5,bl5)|0;mid=mid+Math.imul(al5,bh5)|0;mid=mid+Math.imul(ah5,bl5)|0;hi=hi+Math.imul(ah5,bh5)|0;lo=lo+Math.imul(al4,bl6)|0;mid=mid+Math.imul(al4,bh6)|0;mid=mid+Math.imul(ah4,bl6)|0;hi=hi+Math.imul(ah4,bh6)|0;lo=lo+Math.imul(al3,bl7)|0;mid=mid+Math.imul(al3,bh7)|0;mid=mid+Math.imul(ah3,bl7)|0;hi=hi+Math.imul(ah3,bh7)|0;lo=lo+Math.imul(al2,bl8)|0;mid=mid+Math.imul(al2,bh8)|0;mid=mid+Math.imul(ah2,bl8)|0;hi=hi+Math.imul(ah2,bh8)|0;lo=lo+Math.imul(al1,bl9)|0;mid=mid+Math.imul(al1,bh9)|0;mid=mid+Math.imul(ah1,bl9)|0;hi=hi+Math.imul(ah1,bh9)|0;var w10=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w10>>>26)|0;w10&=0x3ffffff;/* k = 11 */lo=Math.imul(al9,bl2);mid=Math.imul(al9,bh2);mid=mid+Math.imul(ah9,bl2)|0;hi=Math.imul(ah9,bh2);lo=lo+Math.imul(al8,bl3)|0;mid=mid+Math.imul(al8,bh3)|0;mid=mid+Math.imul(ah8,bl3)|0;hi=hi+Math.imul(ah8,bh3)|0;lo=lo+Math.imul(al7,bl4)|0;mid=mid+Math.imul(al7,bh4)|0;mid=mid+Math.imul(ah7,bl4)|0;hi=hi+Math.imul(ah7,bh4)|0;lo=lo+Math.imul(al6,bl5)|0;mid=mid+Math.imul(al6,bh5)|0;mid=mid+Math.imul(ah6,bl5)|0;hi=hi+Math.imul(ah6,bh5)|0;lo=lo+Math.imul(al5,bl6)|0;mid=mid+Math.imul(al5,bh6)|0;mid=mid+Math.imul(ah5,bl6)|0;hi=hi+Math.imul(ah5,bh6)|0;lo=lo+Math.imul(al4,bl7)|0;mid=mid+Math.imul(al4,bh7)|0;mid=mid+Math.imul(ah4,bl7)|0;hi=hi+Math.imul(ah4,bh7)|0;lo=lo+Math.imul(al3,bl8)|0;mid=mid+Math.imul(al3,bh8)|0;mid=mid+Math.imul(ah3,bl8)|0;hi=hi+Math.imul(ah3,bh8)|0;lo=lo+Math.imul(al2,bl9)|0;mid=mid+Math.imul(al2,bh9)|0;mid=mid+Math.imul(ah2,bl9)|0;hi=hi+Math.imul(ah2,bh9)|0;var w11=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w11>>>26)|0;w11&=0x3ffffff;/* k = 12 */lo=Math.imul(al9,bl3);mid=Math.imul(al9,bh3);mid=mid+Math.imul(ah9,bl3)|0;hi=Math.imul(ah9,bh3);lo=lo+Math.imul(al8,bl4)|0;mid=mid+Math.imul(al8,bh4)|0;mid=mid+Math.imul(ah8,bl4)|0;hi=hi+Math.imul(ah8,bh4)|0;lo=lo+Math.imul(al7,bl5)|0;mid=mid+Math.imul(al7,bh5)|0;mid=mid+Math.imul(ah7,bl5)|0;hi=hi+Math.imul(ah7,bh5)|0;lo=lo+Math.imul(al6,bl6)|0;mid=mid+Math.imul(al6,bh6)|0;mid=mid+Math.imul(ah6,bl6)|0;hi=hi+Math.imul(ah6,bh6)|0;lo=lo+Math.imul(al5,bl7)|0;mid=mid+Math.imul(al5,bh7)|0;mid=mid+Math.imul(ah5,bl7)|0;hi=hi+Math.imul(ah5,bh7)|0;lo=lo+Math.imul(al4,bl8)|0;mid=mid+Math.imul(al4,bh8)|0;mid=mid+Math.imul(ah4,bl8)|0;hi=hi+Math.imul(ah4,bh8)|0;lo=lo+Math.imul(al3,bl9)|0;mid=mid+Math.imul(al3,bh9)|0;mid=mid+Math.imul(ah3,bl9)|0;hi=hi+Math.imul(ah3,bh9)|0;var w12=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w12>>>26)|0;w12&=0x3ffffff;/* k = 13 */lo=Math.imul(al9,bl4);mid=Math.imul(al9,bh4);mid=mid+Math.imul(ah9,bl4)|0;hi=Math.imul(ah9,bh4);lo=lo+Math.imul(al8,bl5)|0;mid=mid+Math.imul(al8,bh5)|0;mid=mid+Math.imul(ah8,bl5)|0;hi=hi+Math.imul(ah8,bh5)|0;lo=lo+Math.imul(al7,bl6)|0;mid=mid+Math.imul(al7,bh6)|0;mid=mid+Math.imul(ah7,bl6)|0;hi=hi+Math.imul(ah7,bh6)|0;lo=lo+Math.imul(al6,bl7)|0;mid=mid+Math.imul(al6,bh7)|0;mid=mid+Math.imul(ah6,bl7)|0;hi=hi+Math.imul(ah6,bh7)|0;lo=lo+Math.imul(al5,bl8)|0;mid=mid+Math.imul(al5,bh8)|0;mid=mid+Math.imul(ah5,bl8)|0;hi=hi+Math.imul(ah5,bh8)|0;lo=lo+Math.imul(al4,bl9)|0;mid=mid+Math.imul(al4,bh9)|0;mid=mid+Math.imul(ah4,bl9)|0;hi=hi+Math.imul(ah4,bh9)|0;var w13=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w13>>>26)|0;w13&=0x3ffffff;/* k = 14 */lo=Math.imul(al9,bl5);mid=Math.imul(al9,bh5);mid=mid+Math.imul(ah9,bl5)|0;hi=Math.imul(ah9,bh5);lo=lo+Math.imul(al8,bl6)|0;mid=mid+Math.imul(al8,bh6)|0;mid=mid+Math.imul(ah8,bl6)|0;hi=hi+Math.imul(ah8,bh6)|0;lo=lo+Math.imul(al7,bl7)|0;mid=mid+Math.imul(al7,bh7)|0;mid=mid+Math.imul(ah7,bl7)|0;hi=hi+Math.imul(ah7,bh7)|0;lo=lo+Math.imul(al6,bl8)|0;mid=mid+Math.imul(al6,bh8)|0;mid=mid+Math.imul(ah6,bl8)|0;hi=hi+Math.imul(ah6,bh8)|0;lo=lo+Math.imul(al5,bl9)|0;mid=mid+Math.imul(al5,bh9)|0;mid=mid+Math.imul(ah5,bl9)|0;hi=hi+Math.imul(ah5,bh9)|0;var w14=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w14>>>26)|0;w14&=0x3ffffff;/* k = 15 */lo=Math.imul(al9,bl6);mid=Math.imul(al9,bh6);mid=mid+Math.imul(ah9,bl6)|0;hi=Math.imul(ah9,bh6);lo=lo+Math.imul(al8,bl7)|0;mid=mid+Math.imul(al8,bh7)|0;mid=mid+Math.imul(ah8,bl7)|0;hi=hi+Math.imul(ah8,bh7)|0;lo=lo+Math.imul(al7,bl8)|0;mid=mid+Math.imul(al7,bh8)|0;mid=mid+Math.imul(ah7,bl8)|0;hi=hi+Math.imul(ah7,bh8)|0;lo=lo+Math.imul(al6,bl9)|0;mid=mid+Math.imul(al6,bh9)|0;mid=mid+Math.imul(ah6,bl9)|0;hi=hi+Math.imul(ah6,bh9)|0;var w15=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w15>>>26)|0;w15&=0x3ffffff;/* k = 16 */lo=Math.imul(al9,bl7);mid=Math.imul(al9,bh7);mid=mid+Math.imul(ah9,bl7)|0;hi=Math.imul(ah9,bh7);lo=lo+Math.imul(al8,bl8)|0;mid=mid+Math.imul(al8,bh8)|0;mid=mid+Math.imul(ah8,bl8)|0;hi=hi+Math.imul(ah8,bh8)|0;lo=lo+Math.imul(al7,bl9)|0;mid=mid+Math.imul(al7,bh9)|0;mid=mid+Math.imul(ah7,bl9)|0;hi=hi+Math.imul(ah7,bh9)|0;var w16=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w16>>>26)|0;w16&=0x3ffffff;/* k = 17 */lo=Math.imul(al9,bl8);mid=Math.imul(al9,bh8);mid=mid+Math.imul(ah9,bl8)|0;hi=Math.imul(ah9,bh8);lo=lo+Math.imul(al8,bl9)|0;mid=mid+Math.imul(al8,bh9)|0;mid=mid+Math.imul(ah8,bl9)|0;hi=hi+Math.imul(ah8,bh9)|0;var w17=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w17>>>26)|0;w17&=0x3ffffff;/* k = 18 */lo=Math.imul(al9,bl9);mid=Math.imul(al9,bh9);mid=mid+Math.imul(ah9,bl9)|0;hi=Math.imul(ah9,bh9);var w18=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w18>>>26)|0;w18&=0x3ffffff;o[0]=w0;o[1]=w1;o[2]=w2;o[3]=w3;o[4]=w4;o[5]=w5;o[6]=w6;o[7]=w7;o[8]=w8;o[9]=w9;o[10]=w10;o[11]=w11;o[12]=w12;o[13]=w13;o[14]=w14;o[15]=w15;o[16]=w16;o[17]=w17;o[18]=w18;if(c!==0){o[19]=c;out.length++;}return out;};// Polyfill comb
if(!Math.imul){comb10MulTo=smallMulTo;}function bigMulTo(self,num,out){out.negative=num.negative^self.negative;out.length=self.length+num.length;var carry=0;var hncarry=0;for(var k=0;k<out.length-1;k++){// Sum all words with the same `i + j = k` and accumulate `ncarry`,
// note that ncarry could be >= 0x3ffffff
var ncarry=hncarry;hncarry=0;var rword=carry&0x3ffffff;var maxJ=Math.min(k,num.length-1);for(var j=Math.max(0,k-self.length+1);j<=maxJ;j++){var i=k-j;var a=self.words[i]|0;var b=num.words[j]|0;var r=a*b;var lo=r&0x3ffffff;ncarry=ncarry+(r/0x4000000|0)|0;lo=lo+rword|0;rword=lo&0x3ffffff;ncarry=ncarry+(lo>>>26)|0;hncarry+=ncarry>>>26;ncarry&=0x3ffffff;}out.words[k]=rword;carry=ncarry;ncarry=hncarry;}if(carry!==0){out.words[k]=carry;}else{out.length--;}return out.strip();}function jumboMulTo(self,num,out){var fftm=new FFTM();return fftm.mulp(self,num,out);}BN.prototype.mulTo=function mulTo(num,out){var res;var len=this.length+num.length;if(this.length===10&&num.length===10){res=comb10MulTo(this,num,out);}else if(len<63){res=smallMulTo(this,num,out);}else if(len<1024){res=bigMulTo(this,num,out);}else{res=jumboMulTo(this,num,out);}return res;};// Cooley-Tukey algorithm for FFT
// slightly revisited to rely on looping instead of recursion
function FFTM(x,y){this.x=x;this.y=y;}FFTM.prototype.makeRBT=function makeRBT(N){var t=new Array(N);var l=BN.prototype._countBits(N)-1;for(var i=0;i<N;i++){t[i]=this.revBin(i,l,N);}return t;};// Returns binary-reversed representation of `x`
FFTM.prototype.revBin=function revBin(x,l,N){if(x===0||x===N-1)return x;var rb=0;for(var i=0;i<l;i++){rb|=(x&1)<<l-i-1;x>>=1;}return rb;};// Performs "tweedling" phase, therefore 'emulating'
// behaviour of the recursive algorithm
FFTM.prototype.permute=function permute(rbt,rws,iws,rtws,itws,N){for(var i=0;i<N;i++){rtws[i]=rws[rbt[i]];itws[i]=iws[rbt[i]];}};FFTM.prototype.transform=function transform(rws,iws,rtws,itws,N,rbt){this.permute(rbt,rws,iws,rtws,itws,N);for(var s=1;s<N;s<<=1){var l=s<<1;var rtwdf=Math.cos(2*Math.PI/l);var itwdf=Math.sin(2*Math.PI/l);for(var p=0;p<N;p+=l){var rtwdf_=rtwdf;var itwdf_=itwdf;for(var j=0;j<s;j++){var re=rtws[p+j];var ie=itws[p+j];var ro=rtws[p+j+s];var io=itws[p+j+s];var rx=rtwdf_*ro-itwdf_*io;io=rtwdf_*io+itwdf_*ro;ro=rx;rtws[p+j]=re+ro;itws[p+j]=ie+io;rtws[p+j+s]=re-ro;itws[p+j+s]=ie-io;/* jshint maxdepth : false */if(j!==l){rx=rtwdf*rtwdf_-itwdf*itwdf_;itwdf_=rtwdf*itwdf_+itwdf*rtwdf_;rtwdf_=rx;}}}}};FFTM.prototype.guessLen13b=function guessLen13b(n,m){var N=Math.max(m,n)|1;var odd=N&1;var i=0;for(N=N/2|0;N;N=N>>>1){i++;}return 1<<i+1+odd;};FFTM.prototype.conjugate=function conjugate(rws,iws,N){if(N<=1)return;for(var i=0;i<N/2;i++){var t=rws[i];rws[i]=rws[N-i-1];rws[N-i-1]=t;t=iws[i];iws[i]=-iws[N-i-1];iws[N-i-1]=-t;}};FFTM.prototype.normalize13b=function normalize13b(ws,N){var carry=0;for(var i=0;i<N/2;i++){var w=Math.round(ws[2*i+1]/N)*0x2000+Math.round(ws[2*i]/N)+carry;ws[i]=w&0x3ffffff;if(w<0x4000000){carry=0;}else{carry=w/0x4000000|0;}}return ws;};FFTM.prototype.convert13b=function convert13b(ws,len,rws,N){var carry=0;for(var i=0;i<len;i++){carry=carry+(ws[i]|0);rws[2*i]=carry&0x1fff;carry=carry>>>13;rws[2*i+1]=carry&0x1fff;carry=carry>>>13;}// Pad with zeroes
for(i=2*len;i<N;++i){rws[i]=0;}assert(carry===0);assert((carry&~0x1fff)===0);};FFTM.prototype.stub=function stub(N){var ph=new Array(N);for(var i=0;i<N;i++){ph[i]=0;}return ph;};FFTM.prototype.mulp=function mulp(x,y,out){var N=2*this.guessLen13b(x.length,y.length);var rbt=this.makeRBT(N);var _=this.stub(N);var rws=new Array(N);var rwst=new Array(N);var iwst=new Array(N);var nrws=new Array(N);var nrwst=new Array(N);var niwst=new Array(N);var rmws=out.words;rmws.length=N;this.convert13b(x.words,x.length,rws,N);this.convert13b(y.words,y.length,nrws,N);this.transform(rws,_,rwst,iwst,N,rbt);this.transform(nrws,_,nrwst,niwst,N,rbt);for(var i=0;i<N;i++){var rx=rwst[i]*nrwst[i]-iwst[i]*niwst[i];iwst[i]=rwst[i]*niwst[i]+iwst[i]*nrwst[i];rwst[i]=rx;}this.conjugate(rwst,iwst,N);this.transform(rwst,iwst,rmws,_,N,rbt);this.conjugate(rmws,_,N);this.normalize13b(rmws,N);out.negative=x.negative^y.negative;out.length=x.length+y.length;return out.strip();};// Multiply `this` by `num`
BN.prototype.mul=function mul(num){var out=new BN(null);out.words=new Array(this.length+num.length);return this.mulTo(num,out);};// Multiply employing FFT
BN.prototype.mulf=function mulf(num){var out=new BN(null);out.words=new Array(this.length+num.length);return jumboMulTo(this,num,out);};// In-place Multiplication
BN.prototype.imul=function imul(num){return this.clone().mulTo(num,this);};BN.prototype.imuln=function imuln(num){assert(typeof num==='number');assert(num<0x4000000);// Carry
var carry=0;for(var i=0;i<this.length;i++){var w=(this.words[i]|0)*num;var lo=(w&0x3ffffff)+(carry&0x3ffffff);carry>>=26;carry+=w/0x4000000|0;// NOTE: lo is 27bit maximum
carry+=lo>>>26;this.words[i]=lo&0x3ffffff;}if(carry!==0){this.words[i]=carry;this.length++;}return this;};BN.prototype.muln=function muln(num){return this.clone().imuln(num);};// `this` * `this`
BN.prototype.sqr=function sqr(){return this.mul(this);};// `this` * `this` in-place
BN.prototype.isqr=function isqr(){return this.imul(this.clone());};// Math.pow(`this`, `num`)
BN.prototype.pow=function pow(num){var w=toBitArray(num);if(w.length===0)return new BN(1);// Skip leading zeroes
var res=this;for(var i=0;i<w.length;i++,res=res.sqr()){if(w[i]!==0)break;}if(++i<w.length){for(var q=res.sqr();i<w.length;i++,q=q.sqr()){if(w[i]===0)continue;res=res.mul(q);}}return res;};// Shift-left in-place
BN.prototype.iushln=function iushln(bits){assert(typeof bits==='number'&&bits>=0);var r=bits%26;var s=(bits-r)/26;var carryMask=0x3ffffff>>>26-r<<26-r;var i;if(r!==0){var carry=0;for(i=0;i<this.length;i++){var newCarry=this.words[i]&carryMask;var c=(this.words[i]|0)-newCarry<<r;this.words[i]=c|carry;carry=newCarry>>>26-r;}if(carry){this.words[i]=carry;this.length++;}}if(s!==0){for(i=this.length-1;i>=0;i--){this.words[i+s]=this.words[i];}for(i=0;i<s;i++){this.words[i]=0;}this.length+=s;}return this.strip();};BN.prototype.ishln=function ishln(bits){// TODO(indutny): implement me
assert(this.negative===0);return this.iushln(bits);};// Shift-right in-place
// NOTE: `hint` is a lowest bit before trailing zeroes
// NOTE: if `extended` is present - it will be filled with destroyed bits
BN.prototype.iushrn=function iushrn(bits,hint,extended){assert(typeof bits==='number'&&bits>=0);var h;if(hint){h=(hint-hint%26)/26;}else{h=0;}var r=bits%26;var s=Math.min((bits-r)/26,this.length);var mask=0x3ffffff^0x3ffffff>>>r<<r;var maskedWords=extended;h-=s;h=Math.max(0,h);// Extended mode, copy masked part
if(maskedWords){for(var i=0;i<s;i++){maskedWords.words[i]=this.words[i];}maskedWords.length=s;}if(s===0){// No-op, we should not move anything at all
}else if(this.length>s){this.length-=s;for(i=0;i<this.length;i++){this.words[i]=this.words[i+s];}}else{this.words[0]=0;this.length=1;}var carry=0;for(i=this.length-1;i>=0&&(carry!==0||i>=h);i--){var word=this.words[i]|0;this.words[i]=carry<<26-r|word>>>r;carry=word&mask;}// Push carried bits as a mask
if(maskedWords&&carry!==0){maskedWords.words[maskedWords.length++]=carry;}if(this.length===0){this.words[0]=0;this.length=1;}return this.strip();};BN.prototype.ishrn=function ishrn(bits,hint,extended){// TODO(indutny): implement me
assert(this.negative===0);return this.iushrn(bits,hint,extended);};// Shift-left
BN.prototype.shln=function shln(bits){return this.clone().ishln(bits);};BN.prototype.ushln=function ushln(bits){return this.clone().iushln(bits);};// Shift-right
BN.prototype.shrn=function shrn(bits){return this.clone().ishrn(bits);};BN.prototype.ushrn=function ushrn(bits){return this.clone().iushrn(bits);};// Test if n bit is set
BN.prototype.testn=function testn(bit){assert(typeof bit==='number'&&bit>=0);var r=bit%26;var s=(bit-r)/26;var q=1<<r;// Fast case: bit is much higher than all existing words
if(this.length<=s)return false;// Check bit and return
var w=this.words[s];return!!(w&q);};// Return only lowers bits of number (in-place)
BN.prototype.imaskn=function imaskn(bits){assert(typeof bits==='number'&&bits>=0);var r=bits%26;var s=(bits-r)/26;assert(this.negative===0,'imaskn works only with positive numbers');if(this.length<=s){return this;}if(r!==0){s++;}this.length=Math.min(s,this.length);if(r!==0){var mask=0x3ffffff^0x3ffffff>>>r<<r;this.words[this.length-1]&=mask;}return this.strip();};// Return only lowers bits of number
BN.prototype.maskn=function maskn(bits){return this.clone().imaskn(bits);};// Add plain number `num` to `this`
BN.prototype.iaddn=function iaddn(num){assert(typeof num==='number');assert(num<0x4000000);if(num<0)return this.isubn(-num);// Possible sign change
if(this.negative!==0){if(this.length===1&&(this.words[0]|0)<num){this.words[0]=num-(this.words[0]|0);this.negative=0;return this;}this.negative=0;this.isubn(num);this.negative=1;return this;}// Add without checks
return this._iaddn(num);};BN.prototype._iaddn=function _iaddn(num){this.words[0]+=num;// Carry
for(var i=0;i<this.length&&this.words[i]>=0x4000000;i++){this.words[i]-=0x4000000;if(i===this.length-1){this.words[i+1]=1;}else{this.words[i+1]++;}}this.length=Math.max(this.length,i+1);return this;};// Subtract plain number `num` from `this`
BN.prototype.isubn=function isubn(num){assert(typeof num==='number');assert(num<0x4000000);if(num<0)return this.iaddn(-num);if(this.negative!==0){this.negative=0;this.iaddn(num);this.negative=1;return this;}this.words[0]-=num;if(this.length===1&&this.words[0]<0){this.words[0]=-this.words[0];this.negative=1;}else{// Carry
for(var i=0;i<this.length&&this.words[i]<0;i++){this.words[i]+=0x4000000;this.words[i+1]-=1;}}return this.strip();};BN.prototype.addn=function addn(num){return this.clone().iaddn(num);};BN.prototype.subn=function subn(num){return this.clone().isubn(num);};BN.prototype.iabs=function iabs(){this.negative=0;return this;};BN.prototype.abs=function abs(){return this.clone().iabs();};BN.prototype._ishlnsubmul=function _ishlnsubmul(num,mul,shift){var len=num.length+shift;var i;this._expand(len);var w;var carry=0;for(i=0;i<num.length;i++){w=(this.words[i+shift]|0)+carry;var right=(num.words[i]|0)*mul;w-=right&0x3ffffff;carry=(w>>26)-(right/0x4000000|0);this.words[i+shift]=w&0x3ffffff;}for(;i<this.length-shift;i++){w=(this.words[i+shift]|0)+carry;carry=w>>26;this.words[i+shift]=w&0x3ffffff;}if(carry===0)return this.strip();// Subtraction overflow
assert(carry===-1);carry=0;for(i=0;i<this.length;i++){w=-(this.words[i]|0)+carry;carry=w>>26;this.words[i]=w&0x3ffffff;}this.negative=1;return this.strip();};BN.prototype._wordDiv=function _wordDiv(num,mode){var shift=this.length-num.length;var a=this.clone();var b=num;// Normalize
var bhi=b.words[b.length-1]|0;var bhiBits=this._countBits(bhi);shift=26-bhiBits;if(shift!==0){b=b.ushln(shift);a.iushln(shift);bhi=b.words[b.length-1]|0;}// Initialize quotient
var m=a.length-b.length;var q;if(mode!=='mod'){q=new BN(null);q.length=m+1;q.words=new Array(q.length);for(var i=0;i<q.length;i++){q.words[i]=0;}}var diff=a.clone()._ishlnsubmul(b,1,m);if(diff.negative===0){a=diff;if(q){q.words[m]=1;}}for(var j=m-1;j>=0;j--){var qj=(a.words[b.length+j]|0)*0x4000000+(a.words[b.length+j-1]|0);// NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
// (0x7ffffff)
qj=Math.min(qj/bhi|0,0x3ffffff);a._ishlnsubmul(b,qj,j);while(a.negative!==0){qj--;a.negative=0;a._ishlnsubmul(b,1,j);if(!a.isZero()){a.negative^=1;}}if(q){q.words[j]=qj;}}if(q){q.strip();}a.strip();// Denormalize
if(mode!=='div'&&shift!==0){a.iushrn(shift);}return{div:q||null,mod:a};};// NOTE: 1) `mode` can be set to `mod` to request mod only,
//       to `div` to request div only, or be absent to
//       request both div & mod
//       2) `positive` is true if unsigned mod is requested
BN.prototype.divmod=function divmod(num,mode,positive){assert(!num.isZero());if(this.isZero()){return{div:new BN(0),mod:new BN(0)};}var div,mod,res;if(this.negative!==0&&num.negative===0){res=this.neg().divmod(num,mode);if(mode!=='mod'){div=res.div.neg();}if(mode!=='div'){mod=res.mod.neg();if(positive&&mod.negative!==0){mod.iadd(num);}}return{div:div,mod:mod};}if(this.negative===0&&num.negative!==0){res=this.divmod(num.neg(),mode);if(mode!=='mod'){div=res.div.neg();}return{div:div,mod:res.mod};}if((this.negative&num.negative)!==0){res=this.neg().divmod(num.neg(),mode);if(mode!=='div'){mod=res.mod.neg();if(positive&&mod.negative!==0){mod.isub(num);}}return{div:res.div,mod:mod};}// Both numbers are positive at this point
// Strip both numbers to approximate shift value
if(num.length>this.length||this.cmp(num)<0){return{div:new BN(0),mod:this};}// Very short reduction
if(num.length===1){if(mode==='div'){return{div:this.divn(num.words[0]),mod:null};}if(mode==='mod'){return{div:null,mod:new BN(this.modn(num.words[0]))};}return{div:this.divn(num.words[0]),mod:new BN(this.modn(num.words[0]))};}return this._wordDiv(num,mode);};// Find `this` / `num`
BN.prototype.div=function div(num){return this.divmod(num,'div',false).div;};// Find `this` % `num`
BN.prototype.mod=function mod(num){return this.divmod(num,'mod',false).mod;};BN.prototype.umod=function umod(num){return this.divmod(num,'mod',true).mod;};// Find Round(`this` / `num`)
BN.prototype.divRound=function divRound(num){var dm=this.divmod(num);// Fast case - exact division
if(dm.mod.isZero())return dm.div;var mod=dm.div.negative!==0?dm.mod.isub(num):dm.mod;var half=num.ushrn(1);var r2=num.andln(1);var cmp=mod.cmp(half);// Round down
if(cmp<0||r2===1&&cmp===0)return dm.div;// Round up
return dm.div.negative!==0?dm.div.isubn(1):dm.div.iaddn(1);};BN.prototype.modn=function modn(num){assert(num<=0x3ffffff);var p=(1<<26)%num;var acc=0;for(var i=this.length-1;i>=0;i--){acc=(p*acc+(this.words[i]|0))%num;}return acc;};// In-place division by number
BN.prototype.idivn=function idivn(num){assert(num<=0x3ffffff);var carry=0;for(var i=this.length-1;i>=0;i--){var w=(this.words[i]|0)+carry*0x4000000;this.words[i]=w/num|0;carry=w%num;}return this.strip();};BN.prototype.divn=function divn(num){return this.clone().idivn(num);};BN.prototype.egcd=function egcd(p){assert(p.negative===0);assert(!p.isZero());var x=this;var y=p.clone();if(x.negative!==0){x=x.umod(p);}else{x=x.clone();}// A * x + B * y = x
var A=new BN(1);var B=new BN(0);// C * x + D * y = y
var C=new BN(0);var D=new BN(1);var g=0;while(x.isEven()&&y.isEven()){x.iushrn(1);y.iushrn(1);++g;}var yp=y.clone();var xp=x.clone();while(!x.isZero()){for(var i=0,im=1;(x.words[0]&im)===0&&i<26;++i,im<<=1);if(i>0){x.iushrn(i);while(i-->0){if(A.isOdd()||B.isOdd()){A.iadd(yp);B.isub(xp);}A.iushrn(1);B.iushrn(1);}}for(var j=0,jm=1;(y.words[0]&jm)===0&&j<26;++j,jm<<=1);if(j>0){y.iushrn(j);while(j-->0){if(C.isOdd()||D.isOdd()){C.iadd(yp);D.isub(xp);}C.iushrn(1);D.iushrn(1);}}if(x.cmp(y)>=0){x.isub(y);A.isub(C);B.isub(D);}else{y.isub(x);C.isub(A);D.isub(B);}}return{a:C,b:D,gcd:y.iushln(g)};};// This is reduced incarnation of the binary EEA
// above, designated to invert members of the
// _prime_ fields F(p) at a maximal speed
BN.prototype._invmp=function _invmp(p){assert(p.negative===0);assert(!p.isZero());var a=this;var b=p.clone();if(a.negative!==0){a=a.umod(p);}else{a=a.clone();}var x1=new BN(1);var x2=new BN(0);var delta=b.clone();while(a.cmpn(1)>0&&b.cmpn(1)>0){for(var i=0,im=1;(a.words[0]&im)===0&&i<26;++i,im<<=1);if(i>0){a.iushrn(i);while(i-->0){if(x1.isOdd()){x1.iadd(delta);}x1.iushrn(1);}}for(var j=0,jm=1;(b.words[0]&jm)===0&&j<26;++j,jm<<=1);if(j>0){b.iushrn(j);while(j-->0){if(x2.isOdd()){x2.iadd(delta);}x2.iushrn(1);}}if(a.cmp(b)>=0){a.isub(b);x1.isub(x2);}else{b.isub(a);x2.isub(x1);}}var res;if(a.cmpn(1)===0){res=x1;}else{res=x2;}if(res.cmpn(0)<0){res.iadd(p);}return res;};BN.prototype.gcd=function gcd(num){if(this.isZero())return num.abs();if(num.isZero())return this.abs();var a=this.clone();var b=num.clone();a.negative=0;b.negative=0;// Remove common factor of two
for(var shift=0;a.isEven()&&b.isEven();shift++){a.iushrn(1);b.iushrn(1);}do{while(a.isEven()){a.iushrn(1);}while(b.isEven()){b.iushrn(1);}var r=a.cmp(b);if(r<0){// Swap `a` and `b` to make `a` always bigger than `b`
var t=a;a=b;b=t;}else if(r===0||b.cmpn(1)===0){break;}a.isub(b);}while(true);return b.iushln(shift);};// Invert number in the field F(num)
BN.prototype.invm=function invm(num){return this.egcd(num).a.umod(num);};BN.prototype.isEven=function isEven(){return(this.words[0]&1)===0;};BN.prototype.isOdd=function isOdd(){return(this.words[0]&1)===1;};// And first word and num
BN.prototype.andln=function andln(num){return this.words[0]&num;};// Increment at the bit position in-line
BN.prototype.bincn=function bincn(bit){assert(typeof bit==='number');var r=bit%26;var s=(bit-r)/26;var q=1<<r;// Fast case: bit is much higher than all existing words
if(this.length<=s){this._expand(s+1);this.words[s]|=q;return this;}// Add bit and propagate, if needed
var carry=q;for(var i=s;carry!==0&&i<this.length;i++){var w=this.words[i]|0;w+=carry;carry=w>>>26;w&=0x3ffffff;this.words[i]=w;}if(carry!==0){this.words[i]=carry;this.length++;}return this;};BN.prototype.isZero=function isZero(){return this.length===1&&this.words[0]===0;};BN.prototype.cmpn=function cmpn(num){var negative=num<0;if(this.negative!==0&&!negative)return-1;if(this.negative===0&&negative)return 1;this.strip();var res;if(this.length>1){res=1;}else{if(negative){num=-num;}assert(num<=0x3ffffff,'Number is too big');var w=this.words[0]|0;res=w===num?0:w<num?-1:1;}if(this.negative!==0)return-res|0;return res;};// Compare two numbers and return:
// 1 - if `this` > `num`
// 0 - if `this` == `num`
// -1 - if `this` < `num`
BN.prototype.cmp=function cmp(num){if(this.negative!==0&&num.negative===0)return-1;if(this.negative===0&&num.negative!==0)return 1;var res=this.ucmp(num);if(this.negative!==0)return-res|0;return res;};// Unsigned comparison
BN.prototype.ucmp=function ucmp(num){// At this point both numbers have the same sign
if(this.length>num.length)return 1;if(this.length<num.length)return-1;var res=0;for(var i=this.length-1;i>=0;i--){var a=this.words[i]|0;var b=num.words[i]|0;if(a===b)continue;if(a<b){res=-1;}else if(a>b){res=1;}break;}return res;};BN.prototype.gtn=function gtn(num){return this.cmpn(num)===1;};BN.prototype.gt=function gt(num){return this.cmp(num)===1;};BN.prototype.gten=function gten(num){return this.cmpn(num)>=0;};BN.prototype.gte=function gte(num){return this.cmp(num)>=0;};BN.prototype.ltn=function ltn(num){return this.cmpn(num)===-1;};BN.prototype.lt=function lt(num){return this.cmp(num)===-1;};BN.prototype.lten=function lten(num){return this.cmpn(num)<=0;};BN.prototype.lte=function lte(num){return this.cmp(num)<=0;};BN.prototype.eqn=function eqn(num){return this.cmpn(num)===0;};BN.prototype.eq=function eq(num){return this.cmp(num)===0;};//
// A reduce context, could be using montgomery or something better, depending
// on the `m` itself.
//
BN.red=function red(num){return new Red(num);};BN.prototype.toRed=function toRed(ctx){assert(!this.red,'Already a number in reduction context');assert(this.negative===0,'red works only with positives');return ctx.convertTo(this)._forceRed(ctx);};BN.prototype.fromRed=function fromRed(){assert(this.red,'fromRed works only with numbers in reduction context');return this.red.convertFrom(this);};BN.prototype._forceRed=function _forceRed(ctx){this.red=ctx;return this;};BN.prototype.forceRed=function forceRed(ctx){assert(!this.red,'Already a number in reduction context');return this._forceRed(ctx);};BN.prototype.redAdd=function redAdd(num){assert(this.red,'redAdd works only with red numbers');return this.red.add(this,num);};BN.prototype.redIAdd=function redIAdd(num){assert(this.red,'redIAdd works only with red numbers');return this.red.iadd(this,num);};BN.prototype.redSub=function redSub(num){assert(this.red,'redSub works only with red numbers');return this.red.sub(this,num);};BN.prototype.redISub=function redISub(num){assert(this.red,'redISub works only with red numbers');return this.red.isub(this,num);};BN.prototype.redShl=function redShl(num){assert(this.red,'redShl works only with red numbers');return this.red.shl(this,num);};BN.prototype.redMul=function redMul(num){assert(this.red,'redMul works only with red numbers');this.red._verify2(this,num);return this.red.mul(this,num);};BN.prototype.redIMul=function redIMul(num){assert(this.red,'redMul works only with red numbers');this.red._verify2(this,num);return this.red.imul(this,num);};BN.prototype.redSqr=function redSqr(){assert(this.red,'redSqr works only with red numbers');this.red._verify1(this);return this.red.sqr(this);};BN.prototype.redISqr=function redISqr(){assert(this.red,'redISqr works only with red numbers');this.red._verify1(this);return this.red.isqr(this);};// Square root over p
BN.prototype.redSqrt=function redSqrt(){assert(this.red,'redSqrt works only with red numbers');this.red._verify1(this);return this.red.sqrt(this);};BN.prototype.redInvm=function redInvm(){assert(this.red,'redInvm works only with red numbers');this.red._verify1(this);return this.red.invm(this);};// Return negative clone of `this` % `red modulo`
BN.prototype.redNeg=function redNeg(){assert(this.red,'redNeg works only with red numbers');this.red._verify1(this);return this.red.neg(this);};BN.prototype.redPow=function redPow(num){assert(this.red&&!num.red,'redPow(normalNum)');this.red._verify1(this);return this.red.pow(this,num);};// Prime numbers with efficient reduction
var primes={k256:null,p224:null,p192:null,p25519:null};// Pseudo-Mersenne prime
function MPrime(name,p){// P = 2 ^ N - K
this.name=name;this.p=new BN(p,16);this.n=this.p.bitLength();this.k=new BN(1).iushln(this.n).isub(this.p);this.tmp=this._tmp();}MPrime.prototype._tmp=function _tmp(){var tmp=new BN(null);tmp.words=new Array(Math.ceil(this.n/13));return tmp;};MPrime.prototype.ireduce=function ireduce(num){// Assumes that `num` is less than `P^2`
// num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
var r=num;var rlen;do{this.split(r,this.tmp);r=this.imulK(r);r=r.iadd(this.tmp);rlen=r.bitLength();}while(rlen>this.n);var cmp=rlen<this.n?-1:r.ucmp(this.p);if(cmp===0){r.words[0]=0;r.length=1;}else if(cmp>0){r.isub(this.p);}else{if(r.strip!==undefined){// r is BN v4 instance
r.strip();}else{// r is BN v5 instance
r._strip();}}return r;};MPrime.prototype.split=function split(input,out){input.iushrn(this.n,0,out);};MPrime.prototype.imulK=function imulK(num){return num.imul(this.k);};function K256(){MPrime.call(this,'k256','ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');}inherits(K256,MPrime);K256.prototype.split=function split(input,output){// 256 = 9 * 26 + 22
var mask=0x3fffff;var outLen=Math.min(input.length,9);for(var i=0;i<outLen;i++){output.words[i]=input.words[i];}output.length=outLen;if(input.length<=9){input.words[0]=0;input.length=1;return;}// Shift by 9 limbs
var prev=input.words[9];output.words[output.length++]=prev&mask;for(i=10;i<input.length;i++){var next=input.words[i]|0;input.words[i-10]=(next&mask)<<4|prev>>>22;prev=next;}prev>>>=22;input.words[i-10]=prev;if(prev===0&&input.length>10){input.length-=10;}else{input.length-=9;}};K256.prototype.imulK=function imulK(num){// K = 0x1000003d1 = [ 0x40, 0x3d1 ]
num.words[num.length]=0;num.words[num.length+1]=0;num.length+=2;// bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
var lo=0;for(var i=0;i<num.length;i++){var w=num.words[i]|0;lo+=w*0x3d1;num.words[i]=lo&0x3ffffff;lo=w*0x40+(lo/0x4000000|0);}// Fast length reduction
if(num.words[num.length-1]===0){num.length--;if(num.words[num.length-1]===0){num.length--;}}return num;};function P224(){MPrime.call(this,'p224','ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');}inherits(P224,MPrime);function P192(){MPrime.call(this,'p192','ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');}inherits(P192,MPrime);function P25519(){// 2 ^ 255 - 19
MPrime.call(this,'25519','7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');}inherits(P25519,MPrime);P25519.prototype.imulK=function imulK(num){// K = 0x13
var carry=0;for(var i=0;i<num.length;i++){var hi=(num.words[i]|0)*0x13+carry;var lo=hi&0x3ffffff;hi>>>=26;num.words[i]=lo;carry=hi;}if(carry!==0){num.words[num.length++]=carry;}return num;};// Exported mostly for testing purposes, use plain name instead
BN._prime=function prime(name){// Cached version of prime
if(primes[name])return primes[name];var prime;if(name==='k256'){prime=new K256();}else if(name==='p224'){prime=new P224();}else if(name==='p192'){prime=new P192();}else if(name==='p25519'){prime=new P25519();}else{throw new Error('Unknown prime '+name);}primes[name]=prime;return prime;};//
// Base reduction engine
//
function Red(m){if(typeof m==='string'){var prime=BN._prime(m);this.m=prime.p;this.prime=prime;}else{assert(m.gtn(1),'modulus must be greater than 1');this.m=m;this.prime=null;}}Red.prototype._verify1=function _verify1(a){assert(a.negative===0,'red works only with positives');assert(a.red,'red works only with red numbers');};Red.prototype._verify2=function _verify2(a,b){assert((a.negative|b.negative)===0,'red works only with positives');assert(a.red&&a.red===b.red,'red works only with red numbers');};Red.prototype.imod=function imod(a){if(this.prime)return this.prime.ireduce(a)._forceRed(this);return a.umod(this.m)._forceRed(this);};Red.prototype.neg=function neg(a){if(a.isZero()){return a.clone();}return this.m.sub(a)._forceRed(this);};Red.prototype.add=function add(a,b){this._verify2(a,b);var res=a.add(b);if(res.cmp(this.m)>=0){res.isub(this.m);}return res._forceRed(this);};Red.prototype.iadd=function iadd(a,b){this._verify2(a,b);var res=a.iadd(b);if(res.cmp(this.m)>=0){res.isub(this.m);}return res;};Red.prototype.sub=function sub(a,b){this._verify2(a,b);var res=a.sub(b);if(res.cmpn(0)<0){res.iadd(this.m);}return res._forceRed(this);};Red.prototype.isub=function isub(a,b){this._verify2(a,b);var res=a.isub(b);if(res.cmpn(0)<0){res.iadd(this.m);}return res;};Red.prototype.shl=function shl(a,num){this._verify1(a);return this.imod(a.ushln(num));};Red.prototype.imul=function imul(a,b){this._verify2(a,b);return this.imod(a.imul(b));};Red.prototype.mul=function mul(a,b){this._verify2(a,b);return this.imod(a.mul(b));};Red.prototype.isqr=function isqr(a){return this.imul(a,a.clone());};Red.prototype.sqr=function sqr(a){return this.mul(a,a);};Red.prototype.sqrt=function sqrt(a){if(a.isZero())return a.clone();var mod3=this.m.andln(3);assert(mod3%2===1);// Fast case
if(mod3===3){var pow=this.m.add(new BN(1)).iushrn(2);return this.pow(a,pow);}// Tonelli-Shanks algorithm (Totally unoptimized and slow)
//
// Find Q and S, that Q * 2 ^ S = (P - 1)
var q=this.m.subn(1);var s=0;while(!q.isZero()&&q.andln(1)===0){s++;q.iushrn(1);}assert(!q.isZero());var one=new BN(1).toRed(this);var nOne=one.redNeg();// Find quadratic non-residue
// NOTE: Max is such because of generalized Riemann hypothesis.
var lpow=this.m.subn(1).iushrn(1);var z=this.m.bitLength();z=new BN(2*z*z).toRed(this);while(this.pow(z,lpow).cmp(nOne)!==0){z.redIAdd(nOne);}var c=this.pow(z,q);var r=this.pow(a,q.addn(1).iushrn(1));var t=this.pow(a,q);var m=s;while(t.cmp(one)!==0){var tmp=t;for(var i=0;tmp.cmp(one)!==0;i++){tmp=tmp.redSqr();}assert(i<m);var b=this.pow(c,new BN(1).iushln(m-i-1));r=r.redMul(b);c=b.redSqr();t=t.redMul(c);m=i;}return r;};Red.prototype.invm=function invm(a){var inv=a._invmp(this.m);if(inv.negative!==0){inv.negative=0;return this.imod(inv).redNeg();}else{return this.imod(inv);}};Red.prototype.pow=function pow(a,num){if(num.isZero())return new BN(1).toRed(this);if(num.cmpn(1)===0)return a.clone();var windowSize=4;var wnd=new Array(1<<windowSize);wnd[0]=new BN(1).toRed(this);wnd[1]=a;for(var i=2;i<wnd.length;i++){wnd[i]=this.mul(wnd[i-1],a);}var res=wnd[0];var current=0;var currentLen=0;var start=num.bitLength()%26;if(start===0){start=26;}for(i=num.length-1;i>=0;i--){var word=num.words[i];for(var j=start-1;j>=0;j--){var bit=word>>j&1;if(res!==wnd[0]){res=this.sqr(res);}if(bit===0&&current===0){currentLen=0;continue;}current<<=1;current|=bit;currentLen++;if(currentLen!==windowSize&&(i!==0||j!==0))continue;res=this.mul(res,wnd[current]);currentLen=0;current=0;}start=26;}return res;};Red.prototype.convertTo=function convertTo(num){var r=num.umod(this.m);return r===num?r.clone():r;};Red.prototype.convertFrom=function convertFrom(num){var res=num.clone();res.red=null;return res;};//
// Montgomery method engine
//
BN.mont=function mont(num){return new Mont(num);};function Mont(m){Red.call(this,m);this.shift=this.m.bitLength();if(this.shift%26!==0){this.shift+=26-this.shift%26;}this.r=new BN(1).iushln(this.shift);this.r2=this.imod(this.r.sqr());this.rinv=this.r._invmp(this.m);this.minv=this.rinv.mul(this.r).isubn(1).div(this.m);this.minv=this.minv.umod(this.r);this.minv=this.r.sub(this.minv);}inherits(Mont,Red);Mont.prototype.convertTo=function convertTo(num){return this.imod(num.ushln(this.shift));};Mont.prototype.convertFrom=function convertFrom(num){var r=this.imod(num.mul(this.rinv));r.red=null;return r;};Mont.prototype.imul=function imul(a,b){if(a.isZero()||b.isZero()){a.words[0]=0;a.length=1;return a;}var t=a.imul(b);var c=t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);var u=t.isub(c).iushrn(this.shift);var res=u;if(u.cmp(this.m)>=0){res=u.isub(this.m);}else if(u.cmpn(0)<0){res=u.iadd(this.m);}return res._forceRed(this);};Mont.prototype.mul=function mul(a,b){if(a.isZero()||b.isZero())return new BN(0)._forceRed(this);var t=a.mul(b);var c=t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);var u=t.isub(c).iushrn(this.shift);var res=u;if(u.cmp(this.m)>=0){res=u.isub(this.m);}else if(u.cmpn(0)<0){res=u.iadd(this.m);}return res._forceRed(this);};Mont.prototype.invm=function invm(a){// (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
var res=this.imod(a._invmp(this.m).mul(this.r2));return res._forceRed(this);};})( false||module,this);/***/},/***/2692:/***/function(module){"use strict";module.exports=boundary;function boundary(cells){var i,j,k;var n=cells.length;var sz=0;for(i=0;i<n;++i){sz+=cells[i].length;}var result=new Array(sz);var ptr=0;for(i=0;i<n;++i){var c=cells[i];var d=c.length;for(j=0;j<d;++j){var b=result[ptr++]=new Array(d-1);var p=0;for(k=0;k<d;++k){if(k===j){continue;}b[p++]=c[k];}if(j&1){var tmp=b[1];b[1]=b[0];b[0]=tmp;}}}return result;}/***/},/***/2569:/***/function(module,__unused_webpack_exports,__nested_webpack_require_137948__){"use strict";module.exports=boxIntersectWrapper;var pool=__nested_webpack_require_137948__(5306);var sweep=__nested_webpack_require_137948__(1390);var boxIntersectIter=__nested_webpack_require_137948__(2337);function boxEmpty(d,box){for(var j=0;j<d;++j){if(!(box[j]<=box[j+d])){return true;}}return false;}//Unpack boxes into a flat typed array, remove empty boxes
function convertBoxes(boxes,d,data,ids){var ptr=0;var count=0;for(var i=0,n=boxes.length;i<n;++i){var b=boxes[i];if(boxEmpty(d,b)){continue;}for(var j=0;j<2*d;++j){data[ptr++]=b[j];}ids[count++]=i;}return count;}//Perform type conversions, check bounds
function boxIntersect(red,blue,visit,full){var n=red.length;var m=blue.length;//If either array is empty, then we can skip this whole thing
if(n<=0||m<=0){return;}//Compute dimension, if it is 0 then we skip
var d=red[0].length>>>1;if(d<=0){return;}var retval;//Convert red boxes
var redList=pool.mallocDouble(2*d*n);var redIds=pool.mallocInt32(n);n=convertBoxes(red,d,redList,redIds);if(n>0){if(d===1&&full){//Special case: 1d complete
sweep.init(n);retval=sweep.sweepComplete(d,visit,0,n,redList,redIds,0,n,redList,redIds);}else{//Convert blue boxes
var blueList=pool.mallocDouble(2*d*m);var blueIds=pool.mallocInt32(m);m=convertBoxes(blue,d,blueList,blueIds);if(m>0){sweep.init(n+m);if(d===1){//Special case: 1d bipartite
retval=sweep.sweepBipartite(d,visit,0,n,redList,redIds,0,m,blueList,blueIds);}else{//General case:  d>1
retval=boxIntersectIter(d,visit,full,n,redList,redIds,m,blueList,blueIds);}pool.free(blueList);pool.free(blueIds);}}pool.free(redList);pool.free(redIds);}return retval;}var RESULT;function appendItem(i,j){RESULT.push([i,j]);}function intersectFullArray(x){RESULT=[];boxIntersect(x,x,appendItem,true);return RESULT;}function intersectBipartiteArray(x,y){RESULT=[];boxIntersect(x,y,appendItem,false);return RESULT;}//User-friendly wrapper, handle full input and no-visitor cases
function boxIntersectWrapper(arg0,arg1,arg2){switch(arguments.length){case 1:return intersectFullArray(arg0);case 2:if(typeof arg1==='function'){return boxIntersect(arg0,arg0,arg1,true);}else{return intersectBipartiteArray(arg0,arg1);}case 3:return boxIntersect(arg0,arg1,arg2,false);default:throw new Error('box-intersect: Invalid arguments');}}/***/},/***/7333:/***/function(__unused_webpack_module,exports){"use strict";function full(){function bruteForceRedFull(d,ax,vv,rs,re,rb,ri,bs,be,bb,bi){var es=2*d;for(var i=rs,rp=es*rs;i<re;++i,rp+=es){var x0=rb[ax+rp],x1=rb[ax+rp+d],xi=ri[i];Q:for(var j=bs,bp=es*bs;j<be;++j,bp+=es){var y0=bb[ax+bp],y1=bb[ax+bp+d],yi=bi[j];if(y1<x0||x1<y0)continue;for(var k=ax+1;k<d;++k){var r0=rb[k+rp],r1=rb[k+d+rp],b0=bb[k+bp],b1=bb[k+d+bp];if(r1<b0||b1<r0)continue Q;}var rv=vv(xi,yi);if(rv!==void 0)return rv;}}}function bruteForceBlueFull(d,ax,vv,rs,re,rb,ri,bs,be,bb,bi){var es=2*d;for(var j=bs,bp=es*bs;j<be;++j,bp+=es){var y0=bb[ax+bp],y1=bb[ax+bp+d],yi=bi[j];Q:for(var i=rs,rp=es*rs;i<re;++i,rp+=es){var x0=rb[ax+rp],x1=rb[ax+rp+d],xi=ri[i];if(y1<x0||x1<y0)continue;for(var k=ax+1;k<d;++k){var r0=rb[k+rp],r1=rb[k+d+rp],b0=bb[k+bp],b1=bb[k+d+bp];if(r1<b0||b1<r0)continue Q;}var rv=vv(xi,yi);if(rv!==void 0)return rv;}}}function bruteForceFull(d,ax,vv,rs,re,rb,ri,bs,be,bb,bi){if(re-rs>be-bs){return bruteForceRedFull(d,ax,vv,rs,re,rb,ri,bs,be,bb,bi);}else{return bruteForceBlueFull(d,ax,vv,rs,re,rb,ri,bs,be,bb,bi);}}return bruteForceFull;}function partial(){function bruteForceRedFlip(d,ax,vv,rs,re,rb,ri,bs,be,bb,bi){var es=2*d;for(var i=rs,rp=es*rs;i<re;++i,rp+=es){var x0=rb[ax+rp],x1=rb[ax+rp+d],xi=ri[i];Q:for(var j=bs,bp=es*bs;j<be;++j,bp+=es){var y0=bb[ax+bp],yi=bi[j];if(y0<=x0||x1<y0)continue;for(var k=ax+1;k<d;++k){var r0=rb[k+rp],r1=rb[k+d+rp],b0=bb[k+bp],b1=bb[k+d+bp];if(r1<b0||b1<r0)continue Q;}var rv=vv(yi,xi);if(rv!==void 0)return rv;}}}function bruteForceRed(d,ax,vv,rs,re,rb,ri,bs,be,bb,bi){var es=2*d;for(var i=rs,rp=es*rs;i<re;++i,rp+=es){var x0=rb[ax+rp],x1=rb[ax+rp+d],xi=ri[i];Q:for(var j=bs,bp=es*bs;j<be;++j,bp+=es){var y0=bb[ax+bp],yi=bi[j];if(y0<x0||x1<y0)continue;for(var k=ax+1;k<d;++k){var r0=rb[k+rp],r1=rb[k+d+rp],b0=bb[k+bp],b1=bb[k+d+bp];if(r1<b0||b1<r0)continue Q;}var rv=vv(xi,yi);if(rv!==void 0)return rv;}}}function bruteForceBlueFlip(d,ax,vv,rs,re,rb,ri,bs,be,bb,bi){var es=2*d;for(var j=bs,bp=es*bs;j<be;++j,bp+=es){var y0=bb[ax+bp],yi=bi[j];Q:for(var i=rs,rp=es*rs;i<re;++i,rp+=es){var x0=rb[ax+rp],x1=rb[ax+rp+d],xi=ri[i];if(y0<=x0||x1<y0)continue;for(var k=ax+1;k<d;++k){var r0=rb[k+rp],r1=rb[k+d+rp],b0=bb[k+bp],b1=bb[k+d+bp];if(r1<b0||b1<r0)continue Q;}var rv=vv(yi,xi);if(rv!==void 0)return rv;}}}function bruteForceBlue(d,ax,vv,rs,re,rb,ri,bs,be,bb,bi){var es=2*d;for(var j=bs,bp=es*bs;j<be;++j,bp+=es){var y0=bb[ax+bp],yi=bi[j];Q:for(var i=rs,rp=es*rs;i<re;++i,rp+=es){var x0=rb[ax+rp],x1=rb[ax+rp+d],xi=ri[i];if(y0<x0||x1<y0)continue;for(var k=ax+1;k<d;++k){var r0=rb[k+rp],r1=rb[k+d+rp],b0=bb[k+bp],b1=bb[k+d+bp];if(r1<b0||b1<r0)continue Q;}var rv=vv(xi,yi);if(rv!==void 0)return rv;}}}function bruteForcePartial(d,ax,vv,fp,rs,re,rb,ri,bs,be,bb,bi){if(re-rs>be-bs){if(fp){return bruteForceRedFlip(d,ax,vv,rs,re,rb,ri,bs,be,bb,bi);}else{return bruteForceRed(d,ax,vv,rs,re,rb,ri,bs,be,bb,bi);}}else{if(fp){return bruteForceBlueFlip(d,ax,vv,rs,re,rb,ri,bs,be,bb,bi);}else{return bruteForceBlue(d,ax,vv,rs,re,rb,ri,bs,be,bb,bi);}}}return bruteForcePartial;}function bruteForcePlanner(isFull){return isFull?full():partial();}exports.partial=bruteForcePlanner(false);exports.full=bruteForcePlanner(true);/***/},/***/2337:/***/function(module,__unused_webpack_exports,__nested_webpack_require_143508__){"use strict";module.exports=boxIntersectIter;var pool=__nested_webpack_require_143508__(5306);var bits=__nested_webpack_require_143508__(2288);var bruteForce=__nested_webpack_require_143508__(7333);var bruteForcePartial=bruteForce.partial;var bruteForceFull=bruteForce.full;var sweep=__nested_webpack_require_143508__(1390);var findMedian=__nested_webpack_require_143508__(2464);var genPartition=__nested_webpack_require_143508__(122);//Twiddle parameters
var BRUTE_FORCE_CUTOFF=128;//Cut off for brute force search
var SCAN_CUTOFF=1<<22;//Cut off for two way scan
var SCAN_COMPLETE_CUTOFF=1<<22;//Partition functions
var partitionInteriorContainsInterval=genPartition('!(lo>=p0)&&!(p1>=hi)');var partitionStartEqual=genPartition('lo===p0');var partitionStartLessThan=genPartition('lo<p0');var partitionEndLessThanEqual=genPartition('hi<=p0');var partitionContainsPoint=genPartition('lo<=p0&&p0<=hi');var partitionContainsPointProper=genPartition('lo<p0&&p0<=hi');//Frame size for iterative loop
var IFRAME_SIZE=6;var DFRAME_SIZE=2;//Data for box statck
var INIT_CAPACITY=1024;var BOX_ISTACK=pool.mallocInt32(INIT_CAPACITY);var BOX_DSTACK=pool.mallocDouble(INIT_CAPACITY);//Initialize iterative loop queue
function iterInit(d,count){var levels=8*bits.log2(count+1)*(d+1)|0;var maxInts=bits.nextPow2(IFRAME_SIZE*levels);if(BOX_ISTACK.length<maxInts){pool.free(BOX_ISTACK);BOX_ISTACK=pool.mallocInt32(maxInts);}var maxDoubles=bits.nextPow2(DFRAME_SIZE*levels);if(BOX_DSTACK.length<maxDoubles){pool.free(BOX_DSTACK);BOX_DSTACK=pool.mallocDouble(maxDoubles);}}//Append item to queue
function iterPush(ptr,axis,redStart,redEnd,blueStart,blueEnd,state,lo,hi){var iptr=IFRAME_SIZE*ptr;BOX_ISTACK[iptr]=axis;BOX_ISTACK[iptr+1]=redStart;BOX_ISTACK[iptr+2]=redEnd;BOX_ISTACK[iptr+3]=blueStart;BOX_ISTACK[iptr+4]=blueEnd;BOX_ISTACK[iptr+5]=state;var dptr=DFRAME_SIZE*ptr;BOX_DSTACK[dptr]=lo;BOX_DSTACK[dptr+1]=hi;}//Special case:  Intersect single point with list of intervals
function onePointPartial(d,axis,visit,flip,redStart,redEnd,red,redIndex,blueOffset,blue,blueId){var elemSize=2*d;var bluePtr=blueOffset*elemSize;var blueX=blue[bluePtr+axis];red_loop:for(var i=redStart,redPtr=redStart*elemSize;i<redEnd;++i,redPtr+=elemSize){var r0=red[redPtr+axis];var r1=red[redPtr+axis+d];if(blueX<r0||r1<blueX){continue;}if(flip&&blueX===r0){continue;}var redId=redIndex[i];for(var j=axis+1;j<d;++j){var r0=red[redPtr+j];var r1=red[redPtr+j+d];var b0=blue[bluePtr+j];var b1=blue[bluePtr+j+d];if(r1<b0||b1<r0){continue red_loop;}}var retval;if(flip){retval=visit(blueId,redId);}else{retval=visit(redId,blueId);}if(retval!==void 0){return retval;}}}//Special case:  Intersect one point with list of intervals
function onePointFull(d,axis,visit,redStart,redEnd,red,redIndex,blueOffset,blue,blueId){var elemSize=2*d;var bluePtr=blueOffset*elemSize;var blueX=blue[bluePtr+axis];red_loop:for(var i=redStart,redPtr=redStart*elemSize;i<redEnd;++i,redPtr+=elemSize){var redId=redIndex[i];if(redId===blueId){continue;}var r0=red[redPtr+axis];var r1=red[redPtr+axis+d];if(blueX<r0||r1<blueX){continue;}for(var j=axis+1;j<d;++j){var r0=red[redPtr+j];var r1=red[redPtr+j+d];var b0=blue[bluePtr+j];var b1=blue[bluePtr+j+d];if(r1<b0||b1<r0){continue red_loop;}}var retval=visit(redId,blueId);if(retval!==void 0){return retval;}}}//The main box intersection routine
function boxIntersectIter(d,visit,initFull,xSize,xBoxes,xIndex,ySize,yBoxes,yIndex){//Reserve memory for stack
iterInit(d,xSize+ySize);var top=0;var elemSize=2*d;var retval;iterPush(top++,0,0,xSize,0,ySize,initFull?16:0,-Infinity,Infinity);if(!initFull){iterPush(top++,0,0,ySize,0,xSize,1,-Infinity,Infinity);}while(top>0){top-=1;var iptr=top*IFRAME_SIZE;var axis=BOX_ISTACK[iptr];var redStart=BOX_ISTACK[iptr+1];var redEnd=BOX_ISTACK[iptr+2];var blueStart=BOX_ISTACK[iptr+3];var blueEnd=BOX_ISTACK[iptr+4];var state=BOX_ISTACK[iptr+5];var dptr=top*DFRAME_SIZE;var lo=BOX_DSTACK[dptr];var hi=BOX_DSTACK[dptr+1];//Unpack state info
var flip=state&1;var full=!!(state&16);//Unpack indices
var red=xBoxes;var redIndex=xIndex;var blue=yBoxes;var blueIndex=yIndex;if(flip){red=yBoxes;redIndex=yIndex;blue=xBoxes;blueIndex=xIndex;}if(state&2){redEnd=partitionStartLessThan(d,axis,redStart,redEnd,red,redIndex,hi);if(redStart>=redEnd){continue;}}if(state&4){redStart=partitionEndLessThanEqual(d,axis,redStart,redEnd,red,redIndex,lo);if(redStart>=redEnd){continue;}}var redCount=redEnd-redStart;var blueCount=blueEnd-blueStart;if(full){if(d*redCount*(redCount+blueCount)<SCAN_COMPLETE_CUTOFF){retval=sweep.scanComplete(d,axis,visit,redStart,redEnd,red,redIndex,blueStart,blueEnd,blue,blueIndex);if(retval!==void 0){return retval;}continue;}}else{if(d*Math.min(redCount,blueCount)<BRUTE_FORCE_CUTOFF){//If input small, then use brute force
retval=bruteForcePartial(d,axis,visit,flip,redStart,redEnd,red,redIndex,blueStart,blueEnd,blue,blueIndex);if(retval!==void 0){return retval;}continue;}else if(d*redCount*blueCount<SCAN_CUTOFF){//If input medium sized, then use sweep and prune
retval=sweep.scanBipartite(d,axis,visit,flip,redStart,redEnd,red,redIndex,blueStart,blueEnd,blue,blueIndex);if(retval!==void 0){return retval;}continue;}}//First, find all red intervals whose interior contains (lo,hi)
var red0=partitionInteriorContainsInterval(d,axis,redStart,redEnd,red,redIndex,lo,hi);//Lower dimensional case
if(redStart<red0){if(d*(red0-redStart)<BRUTE_FORCE_CUTOFF){//Special case for small inputs: use brute force
retval=bruteForceFull(d,axis+1,visit,redStart,red0,red,redIndex,blueStart,blueEnd,blue,blueIndex);if(retval!==void 0){return retval;}}else if(axis===d-2){if(flip){retval=sweep.sweepBipartite(d,visit,blueStart,blueEnd,blue,blueIndex,redStart,red0,red,redIndex);}else{retval=sweep.sweepBipartite(d,visit,redStart,red0,red,redIndex,blueStart,blueEnd,blue,blueIndex);}if(retval!==void 0){return retval;}}else{iterPush(top++,axis+1,redStart,red0,blueStart,blueEnd,flip,-Infinity,Infinity);iterPush(top++,axis+1,blueStart,blueEnd,redStart,red0,flip^1,-Infinity,Infinity);}}//Divide and conquer phase
if(red0<redEnd){//Cut blue into 3 parts:
//
//  Points < mid point
//  Points = mid point
//  Points > mid point
//
var blue0=findMedian(d,axis,blueStart,blueEnd,blue,blueIndex);var mid=blue[elemSize*blue0+axis];var blue1=partitionStartEqual(d,axis,blue0,blueEnd,blue,blueIndex,mid);//Right case
if(blue1<blueEnd){iterPush(top++,axis,red0,redEnd,blue1,blueEnd,(flip|4)+(full?16:0),mid,hi);}//Left case
if(blueStart<blue0){iterPush(top++,axis,red0,redEnd,blueStart,blue0,(flip|2)+(full?16:0),lo,mid);}//Center case (the hard part)
if(blue0+1===blue1){//Optimization: Range with exactly 1 point, use a brute force scan
if(full){retval=onePointFull(d,axis,visit,red0,redEnd,red,redIndex,blue0,blue,blueIndex[blue0]);}else{retval=onePointPartial(d,axis,visit,flip,red0,redEnd,red,redIndex,blue0,blue,blueIndex[blue0]);}if(retval!==void 0){return retval;}}else if(blue0<blue1){var red1;if(full){//If full intersection, need to handle special case
red1=partitionContainsPoint(d,axis,red0,redEnd,red,redIndex,mid);if(red0<red1){var redX=partitionStartEqual(d,axis,red0,red1,red,redIndex,mid);if(axis===d-2){//Degenerate sweep intersection:
//  [red0, redX] with [blue0, blue1]
if(red0<redX){retval=sweep.sweepComplete(d,visit,red0,redX,red,redIndex,blue0,blue1,blue,blueIndex);if(retval!==void 0){return retval;}}//Normal sweep intersection:
//  [redX, red1] with [blue0, blue1]
if(redX<red1){retval=sweep.sweepBipartite(d,visit,redX,red1,red,redIndex,blue0,blue1,blue,blueIndex);if(retval!==void 0){return retval;}}}else{if(red0<redX){iterPush(top++,axis+1,red0,redX,blue0,blue1,16,-Infinity,Infinity);}if(redX<red1){iterPush(top++,axis+1,redX,red1,blue0,blue1,0,-Infinity,Infinity);iterPush(top++,axis+1,blue0,blue1,redX,red1,1,-Infinity,Infinity);}}}}else{if(flip){red1=partitionContainsPointProper(d,axis,red0,redEnd,red,redIndex,mid);}else{red1=partitionContainsPoint(d,axis,red0,redEnd,red,redIndex,mid);}if(red0<red1){if(axis===d-2){if(flip){retval=sweep.sweepBipartite(d,visit,blue0,blue1,blue,blueIndex,red0,red1,red,redIndex);}else{retval=sweep.sweepBipartite(d,visit,red0,red1,red,redIndex,blue0,blue1,blue,blueIndex);}}else{iterPush(top++,axis+1,red0,red1,blue0,blue1,flip,-Infinity,Infinity);iterPush(top++,axis+1,blue0,blue1,red0,red1,flip^1,-Infinity,Infinity);}}}}}}}/***/},/***/2464:/***/function(module,__unused_webpack_exports,__nested_webpack_require_151825__){"use strict";module.exports=findMedian;var genPartition=__nested_webpack_require_151825__(122);var partitionStartLessThan=genPartition('lo<p0');var PARTITION_THRESHOLD=8;//Cut off for using insertion sort in findMedian
//Base case for median finding:  Use insertion sort
function insertionSort(d,axis,start,end,boxes,ids){var elemSize=2*d;var boxPtr=elemSize*(start+1)+axis;for(var i=start+1;i<end;++i,boxPtr+=elemSize){var x=boxes[boxPtr];for(var j=i,ptr=elemSize*(i-1);j>start&&boxes[ptr+axis]>x;--j,ptr-=elemSize){//Swap
var aPtr=ptr;var bPtr=ptr+elemSize;for(var k=0;k<elemSize;++k,++aPtr,++bPtr){var y=boxes[aPtr];boxes[aPtr]=boxes[bPtr];boxes[bPtr]=y;}var tmp=ids[j];ids[j]=ids[j-1];ids[j-1]=tmp;}}}//Find median using quick select algorithm
//  takes O(n) time with high probability
function findMedian(d,axis,start,end,boxes,ids){if(end<=start+1){return start;}var lo=start;var hi=end;var mid=end+start>>>1;var elemSize=2*d;var pivot=mid;var value=boxes[elemSize*mid+axis];while(lo<hi){if(hi-lo<PARTITION_THRESHOLD){insertionSort(d,axis,lo,hi,boxes,ids);value=boxes[elemSize*mid+axis];break;}//Select pivot using median-of-3
var count=hi-lo;var pivot0=Math.random()*count+lo|0;var value0=boxes[elemSize*pivot0+axis];var pivot1=Math.random()*count+lo|0;var value1=boxes[elemSize*pivot1+axis];var pivot2=Math.random()*count+lo|0;var value2=boxes[elemSize*pivot2+axis];if(value0<=value1){if(value2>=value1){pivot=pivot1;value=value1;}else if(value0>=value2){pivot=pivot0;value=value0;}else{pivot=pivot2;value=value2;}}else{if(value1>=value2){pivot=pivot1;value=value1;}else if(value2>=value0){pivot=pivot0;value=value0;}else{pivot=pivot2;value=value2;}}//Swap pivot to end of array
var aPtr=elemSize*(hi-1);var bPtr=elemSize*pivot;for(var i=0;i<elemSize;++i,++aPtr,++bPtr){var x=boxes[aPtr];boxes[aPtr]=boxes[bPtr];boxes[bPtr]=x;}var y=ids[hi-1];ids[hi-1]=ids[pivot];ids[pivot]=y;//Partition using pivot
pivot=partitionStartLessThan(d,axis,lo,hi-1,boxes,ids,value);//Swap pivot back
var aPtr=elemSize*(hi-1);var bPtr=elemSize*pivot;for(var i=0;i<elemSize;++i,++aPtr,++bPtr){var x=boxes[aPtr];boxes[aPtr]=boxes[bPtr];boxes[bPtr]=x;}var y=ids[hi-1];ids[hi-1]=ids[pivot];ids[pivot]=y;//Swap pivot to last pivot
if(mid<pivot){hi=pivot-1;while(lo<hi&&boxes[elemSize*(hi-1)+axis]===value){hi-=1;}hi+=1;}else if(pivot<mid){lo=pivot+1;while(lo<hi&&boxes[elemSize*lo+axis]===value){lo+=1;}}else{break;}}//Make sure pivot is at start
return partitionStartLessThan(d,axis,start,mid,boxes,ids,boxes[elemSize*mid+axis]);}/***/},/***/122:/***/function(module){"use strict";module.exports=genPartition;var P2F={'lo===p0':lo_equal_p0,'lo<p0':lo_lessThan_p0,'lo<=p0':lo_lessOrEqual_p0,'hi<=p0':hi_lessOrEqual_p0,'lo<p0&&p0<=hi':lo_lessThan_p0_and_p0_lessOrEqual_hi,'lo<=p0&&p0<=hi':lo_lassOrEqual_p0_and_p0_lessOrEqual_hi,'!(lo>=p0)&&!(p1>=hi)':lo_lessThan_p0_and_p1_lessThan_hi};function genPartition(predicate){return P2F[predicate];}// lo===p0
function lo_equal_p0(a,b,c,d,e,f,p0){for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var lo=e[k+n];if(lo===p0)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t;}var u=f[p];f[p]=f[m],f[m++]=u;}}return m;}// lo<p0
function lo_lessThan_p0(a,b,c,d,e,f,p0){for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var lo=e[k+n];if(lo<p0)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t;}var u=f[p];f[p]=f[m],f[m++]=u;}}return m;}// lo<=p0
function lo_lessOrEqual_p0(a,b,c,d,e,f,p0){for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var hi=e[k+o];if(hi<=p0)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t;}var u=f[p];f[p]=f[m],f[m++]=u;}}return m;}// hi<=p0
function hi_lessOrEqual_p0(a,b,c,d,e,f,p0){for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var hi=e[k+o];if(hi<=p0)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t;}var u=f[p];f[p]=f[m],f[m++]=u;}}return m;}// lo<=p0&&p0<=hi
function lo_lassOrEqual_p0_and_p0_lessOrEqual_hi(a,b,c,d,e,f,p0){for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var lo=e[k+n],hi=e[k+o];if(lo<=p0&&p0<=hi)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t;}var u=f[p];f[p]=f[m],f[m++]=u;}}return m;}// lo<p0&&p0<=hi
function lo_lessThan_p0_and_p0_lessOrEqual_hi(a,b,c,d,e,f,p0){for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var lo=e[k+n],hi=e[k+o];if(lo<p0&&p0<=hi)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t;}var u=f[p];f[p]=f[m],f[m++]=u;}}return m;}// !(lo>=p0)&&!(p1>=hi)
function lo_lessThan_p0_and_p1_lessThan_hi(a,b,c,d,e,f,p0,p1){for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var lo=e[k+n],hi=e[k+o];if(!(lo>=p0)&&!(p1>=hi))if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t;}var u=f[p];f[p]=f[m],f[m++]=u;}}return m;}/***/},/***/309:/***/function(module){"use strict";//This code is extracted from ndarray-sort
//It is inlined here as a temporary workaround
module.exports=wrapper;var INSERT_SORT_CUTOFF=32;function wrapper(data,n0){if(n0<=4*INSERT_SORT_CUTOFF){insertionSort(0,n0-1,data);}else{quickSort(0,n0-1,data);}}function insertionSort(left,right,data){var ptr=2*(left+1);for(var i=left+1;i<=right;++i){var a=data[ptr++];var b=data[ptr++];var j=i;var jptr=ptr-2;while(j-->left){var x=data[jptr-2];var y=data[jptr-1];if(x<a){break;}else if(x===a&&y<b){break;}data[jptr]=x;data[jptr+1]=y;jptr-=2;}data[jptr]=a;data[jptr+1]=b;}}function swap(i,j,data){i*=2;j*=2;var x=data[i];var y=data[i+1];data[i]=data[j];data[i+1]=data[j+1];data[j]=x;data[j+1]=y;}function move(i,j,data){i*=2;j*=2;data[i]=data[j];data[i+1]=data[j+1];}function rotate(i,j,k,data){i*=2;j*=2;k*=2;var x=data[i];var y=data[i+1];data[i]=data[j];data[i+1]=data[j+1];data[j]=data[k];data[j+1]=data[k+1];data[k]=x;data[k+1]=y;}function shufflePivot(i,j,px,py,data){i*=2;j*=2;data[i]=data[j];data[j]=px;data[i+1]=data[j+1];data[j+1]=py;}function compare(i,j,data){i*=2;j*=2;var x=data[i],y=data[j];if(x<y){return false;}else if(x===y){return data[i+1]>data[j+1];}return true;}function comparePivot(i,y,b,data){i*=2;var x=data[i];if(x<y){return true;}else if(x===y){return data[i+1]<b;}return false;}function quickSort(left,right,data){var sixth=(right-left+1)/6|0,index1=left+sixth,index5=right-sixth,index3=left+right>>1,index2=index3-sixth,index4=index3+sixth,el1=index1,el2=index2,el3=index3,el4=index4,el5=index5,less=left+1,great=right-1,tmp=0;if(compare(el1,el2,data)){tmp=el1;el1=el2;el2=tmp;}if(compare(el4,el5,data)){tmp=el4;el4=el5;el5=tmp;}if(compare(el1,el3,data)){tmp=el1;el1=el3;el3=tmp;}if(compare(el2,el3,data)){tmp=el2;el2=el3;el3=tmp;}if(compare(el1,el4,data)){tmp=el1;el1=el4;el4=tmp;}if(compare(el3,el4,data)){tmp=el3;el3=el4;el4=tmp;}if(compare(el2,el5,data)){tmp=el2;el2=el5;el5=tmp;}if(compare(el2,el3,data)){tmp=el2;el2=el3;el3=tmp;}if(compare(el4,el5,data)){tmp=el4;el4=el5;el5=tmp;}var pivot1X=data[2*el2];var pivot1Y=data[2*el2+1];var pivot2X=data[2*el4];var pivot2Y=data[2*el4+1];var ptr0=2*el1;var ptr2=2*el3;var ptr4=2*el5;var ptr5=2*index1;var ptr6=2*index3;var ptr7=2*index5;for(var i1=0;i1<2;++i1){var x=data[ptr0+i1];var y=data[ptr2+i1];var z=data[ptr4+i1];data[ptr5+i1]=x;data[ptr6+i1]=y;data[ptr7+i1]=z;}move(index2,left,data);move(index4,right,data);for(var k=less;k<=great;++k){if(comparePivot(k,pivot1X,pivot1Y,data)){if(k!==less){swap(k,less,data);}++less;}else{if(!comparePivot(k,pivot2X,pivot2Y,data)){while(true){if(!comparePivot(great,pivot2X,pivot2Y,data)){if(--great<k){break;}continue;}else{if(comparePivot(great,pivot1X,pivot1Y,data)){rotate(k,less,great,data);++less;--great;}else{swap(k,great,data);--great;}break;}}}}}shufflePivot(left,less-1,pivot1X,pivot1Y,data);shufflePivot(right,great+1,pivot2X,pivot2Y,data);if(less-2-left<=INSERT_SORT_CUTOFF){insertionSort(left,less-2,data);}else{quickSort(left,less-2,data);}if(right-(great+2)<=INSERT_SORT_CUTOFF){insertionSort(great+2,right,data);}else{quickSort(great+2,right,data);}if(great-less<=INSERT_SORT_CUTOFF){insertionSort(less,great,data);}else{quickSort(less,great,data);}}/***/},/***/1390:/***/function(module,__unused_webpack_exports,__nested_webpack_require_159972__){"use strict";module.exports={init:sqInit,sweepBipartite:sweepBipartite,sweepComplete:sweepComplete,scanBipartite:scanBipartite,scanComplete:scanComplete};var pool=__nested_webpack_require_159972__(5306);var bits=__nested_webpack_require_159972__(2288);var isort=__nested_webpack_require_159972__(309);//Flag for blue
var BLUE_FLAG=1<<28;//1D sweep event queue stuff (use pool to save space)
var INIT_CAPACITY=1024;var RED_SWEEP_QUEUE=pool.mallocInt32(INIT_CAPACITY);var RED_SWEEP_INDEX=pool.mallocInt32(INIT_CAPACITY);var BLUE_SWEEP_QUEUE=pool.mallocInt32(INIT_CAPACITY);var BLUE_SWEEP_INDEX=pool.mallocInt32(INIT_CAPACITY);var COMMON_SWEEP_QUEUE=pool.mallocInt32(INIT_CAPACITY);var COMMON_SWEEP_INDEX=pool.mallocInt32(INIT_CAPACITY);var SWEEP_EVENTS=pool.mallocDouble(INIT_CAPACITY*8);//Reserves memory for the 1D sweep data structures
function sqInit(count){var rcount=bits.nextPow2(count);if(RED_SWEEP_QUEUE.length<rcount){pool.free(RED_SWEEP_QUEUE);RED_SWEEP_QUEUE=pool.mallocInt32(rcount);}if(RED_SWEEP_INDEX.length<rcount){pool.free(RED_SWEEP_INDEX);RED_SWEEP_INDEX=pool.mallocInt32(rcount);}if(BLUE_SWEEP_QUEUE.length<rcount){pool.free(BLUE_SWEEP_QUEUE);BLUE_SWEEP_QUEUE=pool.mallocInt32(rcount);}if(BLUE_SWEEP_INDEX.length<rcount){pool.free(BLUE_SWEEP_INDEX);BLUE_SWEEP_INDEX=pool.mallocInt32(rcount);}if(COMMON_SWEEP_QUEUE.length<rcount){pool.free(COMMON_SWEEP_QUEUE);COMMON_SWEEP_QUEUE=pool.mallocInt32(rcount);}if(COMMON_SWEEP_INDEX.length<rcount){pool.free(COMMON_SWEEP_INDEX);COMMON_SWEEP_INDEX=pool.mallocInt32(rcount);}var eventLength=8*rcount;if(SWEEP_EVENTS.length<eventLength){pool.free(SWEEP_EVENTS);SWEEP_EVENTS=pool.mallocDouble(eventLength);}}//Remove an item from the active queue in O(1)
function sqPop(queue,index,count,item){var idx=index[item];var top=queue[count-1];queue[idx]=top;index[top]=idx;}//Insert an item into the active queue in O(1)
function sqPush(queue,index,count,item){queue[count]=item;index[item]=count;}//Recursion base case: use 1D sweep algorithm
function sweepBipartite(d,visit,redStart,redEnd,red,redIndex,blueStart,blueEnd,blue,blueIndex){//store events as pairs [coordinate, idx]
//
//  red create:  -(idx+1)
//  red destroy: idx
//  blue create: -(idx+BLUE_FLAG)
//  blue destroy: idx+BLUE_FLAG
//
var ptr=0;var elemSize=2*d;var istart=d-1;var iend=elemSize-1;for(var i=redStart;i<redEnd;++i){var idx=redIndex[i];var redOffset=elemSize*i;SWEEP_EVENTS[ptr++]=red[redOffset+istart];SWEEP_EVENTS[ptr++]=-(idx+1);SWEEP_EVENTS[ptr++]=red[redOffset+iend];SWEEP_EVENTS[ptr++]=idx;}for(var i=blueStart;i<blueEnd;++i){var idx=blueIndex[i]+BLUE_FLAG;var blueOffset=elemSize*i;SWEEP_EVENTS[ptr++]=blue[blueOffset+istart];SWEEP_EVENTS[ptr++]=-idx;SWEEP_EVENTS[ptr++]=blue[blueOffset+iend];SWEEP_EVENTS[ptr++]=idx;}//process events from left->right
var n=ptr>>>1;isort(SWEEP_EVENTS,n);var redActive=0;var blueActive=0;for(var i=0;i<n;++i){var e=SWEEP_EVENTS[2*i+1]|0;if(e>=BLUE_FLAG){//blue destroy event
e=e-BLUE_FLAG|0;sqPop(BLUE_SWEEP_QUEUE,BLUE_SWEEP_INDEX,blueActive--,e);}else if(e>=0){//red destroy event
sqPop(RED_SWEEP_QUEUE,RED_SWEEP_INDEX,redActive--,e);}else if(e<=-BLUE_FLAG){//blue create event
e=-e-BLUE_FLAG|0;for(var j=0;j<redActive;++j){var retval=visit(RED_SWEEP_QUEUE[j],e);if(retval!==void 0){return retval;}}sqPush(BLUE_SWEEP_QUEUE,BLUE_SWEEP_INDEX,blueActive++,e);}else{//red create event
e=-e-1|0;for(var j=0;j<blueActive;++j){var retval=visit(e,BLUE_SWEEP_QUEUE[j]);if(retval!==void 0){return retval;}}sqPush(RED_SWEEP_QUEUE,RED_SWEEP_INDEX,redActive++,e);}}}//Complete sweep
function sweepComplete(d,visit,redStart,redEnd,red,redIndex,blueStart,blueEnd,blue,blueIndex){var ptr=0;var elemSize=2*d;var istart=d-1;var iend=elemSize-1;for(var i=redStart;i<redEnd;++i){var idx=redIndex[i]+1<<1;var redOffset=elemSize*i;SWEEP_EVENTS[ptr++]=red[redOffset+istart];SWEEP_EVENTS[ptr++]=-idx;SWEEP_EVENTS[ptr++]=red[redOffset+iend];SWEEP_EVENTS[ptr++]=idx;}for(var i=blueStart;i<blueEnd;++i){var idx=blueIndex[i]+1<<1;var blueOffset=elemSize*i;SWEEP_EVENTS[ptr++]=blue[blueOffset+istart];SWEEP_EVENTS[ptr++]=-idx|1;SWEEP_EVENTS[ptr++]=blue[blueOffset+iend];SWEEP_EVENTS[ptr++]=idx|1;}//process events from left->right
var n=ptr>>>1;isort(SWEEP_EVENTS,n);var redActive=0;var blueActive=0;var commonActive=0;for(var i=0;i<n;++i){var e=SWEEP_EVENTS[2*i+1]|0;var color=e&1;if(i<n-1&&e>>1===SWEEP_EVENTS[2*i+3]>>1){color=2;i+=1;}if(e<0){//Create event
var id=-(e>>1)-1;//Intersect with common
for(var j=0;j<commonActive;++j){var retval=visit(COMMON_SWEEP_QUEUE[j],id);if(retval!==void 0){return retval;}}if(color!==0){//Intersect with red
for(var j=0;j<redActive;++j){var retval=visit(RED_SWEEP_QUEUE[j],id);if(retval!==void 0){return retval;}}}if(color!==1){//Intersect with blue
for(var j=0;j<blueActive;++j){var retval=visit(BLUE_SWEEP_QUEUE[j],id);if(retval!==void 0){return retval;}}}if(color===0){//Red
sqPush(RED_SWEEP_QUEUE,RED_SWEEP_INDEX,redActive++,id);}else if(color===1){//Blue
sqPush(BLUE_SWEEP_QUEUE,BLUE_SWEEP_INDEX,blueActive++,id);}else if(color===2){//Both
sqPush(COMMON_SWEEP_QUEUE,COMMON_SWEEP_INDEX,commonActive++,id);}}else{//Destroy event
var id=(e>>1)-1;if(color===0){//Red
sqPop(RED_SWEEP_QUEUE,RED_SWEEP_INDEX,redActive--,id);}else if(color===1){//Blue
sqPop(BLUE_SWEEP_QUEUE,BLUE_SWEEP_INDEX,blueActive--,id);}else if(color===2){//Both
sqPop(COMMON_SWEEP_QUEUE,COMMON_SWEEP_INDEX,commonActive--,id);}}}}//Sweep and prune/scanline algorithm:
//  Scan along axis, detect intersections
//  Brute force all boxes along axis
function scanBipartite(d,axis,visit,flip,redStart,redEnd,red,redIndex,blueStart,blueEnd,blue,blueIndex){var ptr=0;var elemSize=2*d;var istart=axis;var iend=axis+d;var redShift=1;var blueShift=1;if(flip){blueShift=BLUE_FLAG;}else{redShift=BLUE_FLAG;}for(var i=redStart;i<redEnd;++i){var idx=i+redShift;var redOffset=elemSize*i;SWEEP_EVENTS[ptr++]=red[redOffset+istart];SWEEP_EVENTS[ptr++]=-idx;SWEEP_EVENTS[ptr++]=red[redOffset+iend];SWEEP_EVENTS[ptr++]=idx;}for(var i=blueStart;i<blueEnd;++i){var idx=i+blueShift;var blueOffset=elemSize*i;SWEEP_EVENTS[ptr++]=blue[blueOffset+istart];SWEEP_EVENTS[ptr++]=-idx;}//process events from left->right
var n=ptr>>>1;isort(SWEEP_EVENTS,n);var redActive=0;for(var i=0;i<n;++i){var e=SWEEP_EVENTS[2*i+1]|0;if(e<0){var idx=-e;var isRed=false;if(idx>=BLUE_FLAG){isRed=!flip;idx-=BLUE_FLAG;}else{isRed=!!flip;idx-=1;}if(isRed){sqPush(RED_SWEEP_QUEUE,RED_SWEEP_INDEX,redActive++,idx);}else{var blueId=blueIndex[idx];var bluePtr=elemSize*idx;var b0=blue[bluePtr+axis+1];var b1=blue[bluePtr+axis+1+d];red_loop:for(var j=0;j<redActive;++j){var oidx=RED_SWEEP_QUEUE[j];var redPtr=elemSize*oidx;if(b1<red[redPtr+axis+1]||red[redPtr+axis+1+d]<b0){continue;}for(var k=axis+2;k<d;++k){if(blue[bluePtr+k+d]<red[redPtr+k]||red[redPtr+k+d]<blue[bluePtr+k]){continue red_loop;}}var redId=redIndex[oidx];var retval;if(flip){retval=visit(blueId,redId);}else{retval=visit(redId,blueId);}if(retval!==void 0){return retval;}}}}else{sqPop(RED_SWEEP_QUEUE,RED_SWEEP_INDEX,redActive--,e-redShift);}}}function scanComplete(d,axis,visit,redStart,redEnd,red,redIndex,blueStart,blueEnd,blue,blueIndex){var ptr=0;var elemSize=2*d;var istart=axis;var iend=axis+d;for(var i=redStart;i<redEnd;++i){var idx=i+BLUE_FLAG;var redOffset=elemSize*i;SWEEP_EVENTS[ptr++]=red[redOffset+istart];SWEEP_EVENTS[ptr++]=-idx;SWEEP_EVENTS[ptr++]=red[redOffset+iend];SWEEP_EVENTS[ptr++]=idx;}for(var i=blueStart;i<blueEnd;++i){var idx=i+1;var blueOffset=elemSize*i;SWEEP_EVENTS[ptr++]=blue[blueOffset+istart];SWEEP_EVENTS[ptr++]=-idx;}//process events from left->right
var n=ptr>>>1;isort(SWEEP_EVENTS,n);var redActive=0;for(var i=0;i<n;++i){var e=SWEEP_EVENTS[2*i+1]|0;if(e<0){var idx=-e;if(idx>=BLUE_FLAG){RED_SWEEP_QUEUE[redActive++]=idx-BLUE_FLAG;}else{idx-=1;var blueId=blueIndex[idx];var bluePtr=elemSize*idx;var b0=blue[bluePtr+axis+1];var b1=blue[bluePtr+axis+1+d];red_loop:for(var j=0;j<redActive;++j){var oidx=RED_SWEEP_QUEUE[j];var redId=redIndex[oidx];if(redId===blueId){break;}var redPtr=elemSize*oidx;if(b1<red[redPtr+axis+1]||red[redPtr+axis+1+d]<b0){continue;}for(var k=axis+2;k<d;++k){if(blue[bluePtr+k+d]<red[redPtr+k]||red[redPtr+k+d]<blue[bluePtr+k]){continue red_loop;}}var retval=visit(redId,blueId);if(retval!==void 0){return retval;}}}}else{var idx=e-BLUE_FLAG;for(var j=redActive-1;j>=0;--j){if(RED_SWEEP_QUEUE[j]===idx){for(var k=j+1;k<redActive;++k){RED_SWEEP_QUEUE[k-1]=RED_SWEEP_QUEUE[k];}break;}}--redActive;}}}/***/},/***/7761:/***/function(module,__unused_webpack_exports,__nested_webpack_require_168442__){"use strict";var monotoneTriangulate=__nested_webpack_require_168442__(9971);var makeIndex=__nested_webpack_require_168442__(743);var delaunayFlip=__nested_webpack_require_168442__(2161);var filterTriangulation=__nested_webpack_require_168442__(7098);module.exports=cdt2d;function canonicalizeEdge(e){return[Math.min(e[0],e[1]),Math.max(e[0],e[1])];}function compareEdge(a,b){return a[0]-b[0]||a[1]-b[1];}function canonicalizeEdges(edges){return edges.map(canonicalizeEdge).sort(compareEdge);}function getDefault(options,property,dflt){if(property in options){return options[property];}return dflt;}function cdt2d(points,edges,options){if(!Array.isArray(edges)){options=edges||{};edges=[];}else{options=options||{};edges=edges||[];}//Parse out options
var delaunay=!!getDefault(options,'delaunay',true);var interior=!!getDefault(options,'interior',true);var exterior=!!getDefault(options,'exterior',true);var infinity=!!getDefault(options,'infinity',false);//Handle trivial case
if(!interior&&!exterior||points.length===0){return[];}//Construct initial triangulation
var cells=monotoneTriangulate(points,edges);//If delaunay refinement needed, then improve quality by edge flipping
if(delaunay||interior!==exterior||infinity){//Index all of the cells to support fast neighborhood queries
var triangulation=makeIndex(points.length,canonicalizeEdges(edges));for(var i=0;i<cells.length;++i){var f=cells[i];triangulation.addTriangle(f[0],f[1],f[2]);}//Run edge flipping
if(delaunay){delaunayFlip(points,triangulation);}//Filter points
if(!exterior){return filterTriangulation(triangulation,-1);}else if(!interior){return filterTriangulation(triangulation,1,infinity);}else if(infinity){return filterTriangulation(triangulation,0,infinity);}else{return triangulation.cells();}}else{return cells;}}/***/},/***/2161:/***/function(module,__unused_webpack_exports,__nested_webpack_require_170262__){"use strict";var inCircle=__nested_webpack_require_170262__(2227)[4];var bsearch=__nested_webpack_require_170262__(5070);module.exports=delaunayRefine;function testFlip(points,triangulation,stack,a,b,x){var y=triangulation.opposite(a,b);//Test boundary edge
if(y<0){return;}//Swap edge if order flipped
if(b<a){var tmp=a;a=b;b=tmp;tmp=x;x=y;y=tmp;}//Test if edge is constrained
if(triangulation.isConstraint(a,b)){return;}//Test if edge is delaunay
if(inCircle(points[a],points[b],points[x],points[y])<0){stack.push(a,b);}}//Assume edges are sorted lexicographically
function delaunayRefine(points,triangulation){var stack=[];var numPoints=points.length;var stars=triangulation.stars;for(var a=0;a<numPoints;++a){var star=stars[a];for(var j=1;j<star.length;j+=2){var b=star[j];//If order is not consistent, then skip edge
if(b<a){continue;}//Check if edge is constrained
if(triangulation.isConstraint(a,b)){continue;}//Find opposite edge
var x=star[j-1],y=-1;for(var k=1;k<star.length;k+=2){if(star[k-1]===b){y=star[k];break;}}//If this is a boundary edge, don't flip it
if(y<0){continue;}//If edge is in circle, flip it
if(inCircle(points[a],points[b],points[x],points[y])<0){stack.push(a,b);}}}while(stack.length>0){var b=stack.pop();var a=stack.pop();//Find opposite pairs
var x=-1,y=-1;var star=stars[a];for(var i=1;i<star.length;i+=2){var s=star[i-1];var t=star[i];if(s===b){y=t;}else if(t===b){x=s;}}//If x/y are both valid then skip edge
if(x<0||y<0){continue;}//If edge is now delaunay, then don't flip it
if(inCircle(points[a],points[b],points[x],points[y])>=0){continue;}//Flip the edge
triangulation.flip(a,b);//Test flipping neighboring edges
testFlip(points,triangulation,stack,x,a,y);testFlip(points,triangulation,stack,a,y,x);testFlip(points,triangulation,stack,y,b,x);testFlip(points,triangulation,stack,b,x,y);}}/***/},/***/7098:/***/function(module,__unused_webpack_exports,__nested_webpack_require_172147__){"use strict";var bsearch=__nested_webpack_require_172147__(5070);module.exports=classifyFaces;function FaceIndex(cells,neighbor,constraint,flags,active,next,boundary){this.cells=cells;this.neighbor=neighbor;this.flags=flags;this.constraint=constraint;this.active=active;this.next=next;this.boundary=boundary;}var proto=FaceIndex.prototype;function compareCell(a,b){return a[0]-b[0]||a[1]-b[1]||a[2]-b[2];}proto.locate=function(){var key=[0,0,0];return function(a,b,c){var x=a,y=b,z=c;if(b<c){if(b<a){x=b;y=c;z=a;}}else if(c<a){x=c;y=a;z=b;}if(x<0){return-1;}key[0]=x;key[1]=y;key[2]=z;return bsearch.eq(this.cells,key,compareCell);};}();function indexCells(triangulation,infinity){//First get cells and canonicalize
var cells=triangulation.cells();var nc=cells.length;for(var i=0;i<nc;++i){var c=cells[i];var x=c[0],y=c[1],z=c[2];if(y<z){if(y<x){c[0]=y;c[1]=z;c[2]=x;}}else if(z<x){c[0]=z;c[1]=x;c[2]=y;}}cells.sort(compareCell);//Initialize flag array
var flags=new Array(nc);for(var i=0;i<flags.length;++i){flags[i]=0;}//Build neighbor index, initialize queues
var active=[];var next=[];var neighbor=new Array(3*nc);var constraint=new Array(3*nc);var boundary=null;if(infinity){boundary=[];}var index=new FaceIndex(cells,neighbor,constraint,flags,active,next,boundary);for(var i=0;i<nc;++i){var c=cells[i];for(var j=0;j<3;++j){var x=c[j],y=c[(j+1)%3];var a=neighbor[3*i+j]=index.locate(y,x,triangulation.opposite(y,x));var b=constraint[3*i+j]=triangulation.isConstraint(x,y);if(a<0){if(b){next.push(i);}else{active.push(i);flags[i]=1;}if(infinity){boundary.push([y,x,-1]);}}}}return index;}function filterCells(cells,flags,target){var ptr=0;for(var i=0;i<cells.length;++i){if(flags[i]===target){cells[ptr++]=cells[i];}}cells.length=ptr;return cells;}function classifyFaces(triangulation,target,infinity){var index=indexCells(triangulation,infinity);if(target===0){if(infinity){return index.cells.concat(index.boundary);}else{return index.cells;}}var side=1;var active=index.active;var next=index.next;var flags=index.flags;var cells=index.cells;var constraint=index.constraint;var neighbor=index.neighbor;while(active.length>0||next.length>0){while(active.length>0){var t=active.pop();if(flags[t]===-side){continue;}flags[t]=side;var c=cells[t];for(var j=0;j<3;++j){var f=neighbor[3*t+j];if(f>=0&&flags[f]===0){if(constraint[3*t+j]){next.push(f);}else{active.push(f);flags[f]=side;}}}}//Swap arrays and loop
var tmp=next;next=active;active=tmp;next.length=0;side=-side;}var result=filterCells(cells,flags,target);if(infinity){return result.concat(index.boundary);}return result;}/***/},/***/9971:/***/function(module,__unused_webpack_exports,__nested_webpack_require_174798__){"use strict";var bsearch=__nested_webpack_require_174798__(5070);var orient=__nested_webpack_require_174798__(417)[3];var EVENT_POINT=0;var EVENT_END=1;var EVENT_START=2;module.exports=monotoneTriangulate;//A partial convex hull fragment, made of two unimonotone polygons
function PartialHull(a,b,idx,lowerIds,upperIds){this.a=a;this.b=b;this.idx=idx;this.lowerIds=lowerIds;this.upperIds=upperIds;}//An event in the sweep line procedure
function Event(a,b,type,idx){this.a=a;this.b=b;this.type=type;this.idx=idx;}//This is used to compare events for the sweep line procedure
// Points are:
//  1. sorted lexicographically
//  2. sorted by type  (point < end < start)
//  3. segments sorted by winding order
//  4. sorted by index
function compareEvent(a,b){var d=a.a[0]-b.a[0]||a.a[1]-b.a[1]||a.type-b.type;if(d){return d;}if(a.type!==EVENT_POINT){d=orient(a.a,a.b,b.b);if(d){return d;}}return a.idx-b.idx;}function testPoint(hull,p){return orient(hull.a,hull.b,p);}function addPoint(cells,hulls,points,p,idx){var lo=bsearch.lt(hulls,p,testPoint);var hi=bsearch.gt(hulls,p,testPoint);for(var i=lo;i<hi;++i){var hull=hulls[i];//Insert p into lower hull
var lowerIds=hull.lowerIds;var m=lowerIds.length;while(m>1&&orient(points[lowerIds[m-2]],points[lowerIds[m-1]],p)>0){cells.push([lowerIds[m-1],lowerIds[m-2],idx]);m-=1;}lowerIds.length=m;lowerIds.push(idx);//Insert p into upper hull
var upperIds=hull.upperIds;var m=upperIds.length;while(m>1&&orient(points[upperIds[m-2]],points[upperIds[m-1]],p)<0){cells.push([upperIds[m-2],upperIds[m-1],idx]);m-=1;}upperIds.length=m;upperIds.push(idx);}}function findSplit(hull,edge){var d;if(hull.a[0]<edge.a[0]){d=orient(hull.a,hull.b,edge.a);}else{d=orient(edge.b,edge.a,hull.a);}if(d){return d;}if(edge.b[0]<hull.b[0]){d=orient(hull.a,hull.b,edge.b);}else{d=orient(edge.b,edge.a,hull.b);}return d||hull.idx-edge.idx;}function splitHulls(hulls,points,event){var splitIdx=bsearch.le(hulls,event,findSplit);var hull=hulls[splitIdx];var upperIds=hull.upperIds;var x=upperIds[upperIds.length-1];hull.upperIds=[x];hulls.splice(splitIdx+1,0,new PartialHull(event.a,event.b,event.idx,[x],upperIds));}function mergeHulls(hulls,points,event){//Swap pointers for merge search
var tmp=event.a;event.a=event.b;event.b=tmp;var mergeIdx=bsearch.eq(hulls,event,findSplit);var upper=hulls[mergeIdx];var lower=hulls[mergeIdx-1];lower.upperIds=upper.upperIds;hulls.splice(mergeIdx,1);}function monotoneTriangulate(points,edges){var numPoints=points.length;var numEdges=edges.length;var events=[];//Create point events
for(var i=0;i<numPoints;++i){events.push(new Event(points[i],null,EVENT_POINT,i));}//Create edge events
for(var i=0;i<numEdges;++i){var e=edges[i];var a=points[e[0]];var b=points[e[1]];if(a[0]<b[0]){events.push(new Event(a,b,EVENT_START,i),new Event(b,a,EVENT_END,i));}else if(a[0]>b[0]){events.push(new Event(b,a,EVENT_START,i),new Event(a,b,EVENT_END,i));}}//Sort events
events.sort(compareEvent);//Initialize hull
var minX=events[0].a[0]-(1+Math.abs(events[0].a[0]))*Math.pow(2,-52);var hull=[new PartialHull([minX,1],[minX,0],-1,[],[],[],[])];//Process events in order
var cells=[];for(var i=0,numEvents=events.length;i<numEvents;++i){var event=events[i];var type=event.type;if(type===EVENT_POINT){addPoint(cells,hull,points,event.a,event.idx);}else if(type===EVENT_START){splitHulls(hull,points,event);}else{mergeHulls(hull,points,event);}}//Return triangulation
return cells;}/***/},/***/743:/***/function(module,__unused_webpack_exports,__nested_webpack_require_178277__){"use strict";var bsearch=__nested_webpack_require_178277__(5070);module.exports=createTriangulation;function Triangulation(stars,edges){this.stars=stars;this.edges=edges;}var proto=Triangulation.prototype;function removePair(list,j,k){for(var i=1,n=list.length;i<n;i+=2){if(list[i-1]===j&&list[i]===k){list[i-1]=list[n-2];list[i]=list[n-1];list.length=n-2;return;}}}proto.isConstraint=function(){var e=[0,0];function compareLex(a,b){return a[0]-b[0]||a[1]-b[1];}return function(i,j){e[0]=Math.min(i,j);e[1]=Math.max(i,j);return bsearch.eq(this.edges,e,compareLex)>=0;};}();proto.removeTriangle=function(i,j,k){var stars=this.stars;removePair(stars[i],j,k);removePair(stars[j],k,i);removePair(stars[k],i,j);};proto.addTriangle=function(i,j,k){var stars=this.stars;stars[i].push(j,k);stars[j].push(k,i);stars[k].push(i,j);};proto.opposite=function(j,i){var list=this.stars[i];for(var k=1,n=list.length;k<n;k+=2){if(list[k]===j){return list[k-1];}}return-1;};proto.flip=function(i,j){var a=this.opposite(i,j);var b=this.opposite(j,i);this.removeTriangle(i,j,a);this.removeTriangle(j,i,b);this.addTriangle(i,b,a);this.addTriangle(j,a,b);};proto.edges=function(){var stars=this.stars;var result=[];for(var i=0,n=stars.length;i<n;++i){var list=stars[i];for(var j=0,m=list.length;j<m;j+=2){result.push([list[j],list[j+1]]);}}return result;};proto.cells=function(){var stars=this.stars;var result=[];for(var i=0,n=stars.length;i<n;++i){var list=stars[i];for(var j=0,m=list.length;j<m;j+=2){var s=list[j];var t=list[j+1];if(i<Math.min(s,t)){result.push([i,s,t]);}}}return result;};function createTriangulation(numVerts,edges){var stars=new Array(numVerts);for(var i=0;i<numVerts;++i){stars[i]=[];}return new Triangulation(stars,edges);}/***/},/***/9887:/***/function(module){"use strict";module.exports=orientation;function orientation(s){var p=1;for(var i=1;i<s.length;++i){for(var j=0;j<i;++j){if(s[i]<s[j]){p=-p;}else if(s[j]===s[i]){return 0;}}}return p;}/***/},/***/9243:/***/function(module,__unused_webpack_exports,__nested_webpack_require_180297__){"use strict";var dup=__nested_webpack_require_180297__(3094);var solve=__nested_webpack_require_180297__(6606);function dot(a,b){var s=0.0;var d=a.length;for(var i=0;i<d;++i){s+=a[i]*b[i];}return s;}function barycentricCircumcenter(points){var N=points.length;if(N===0){return[];}var D=points[0].length;var A=dup([points.length+1,points.length+1],1.0);var b=dup([points.length+1],1.0);A[N][N]=0.0;for(var i=0;i<N;++i){for(var j=0;j<=i;++j){A[j][i]=A[i][j]=2.0*dot(points[i],points[j]);}b[i]=dot(points[i],points[i]);}var x=solve(A,b);var denom=0.0;var h=x[N+1];for(var i=0;i<h.length;++i){denom+=h[i];}var y=new Array(N);for(var i=0;i<N;++i){var h=x[i];var numer=0.0;for(var j=0;j<h.length;++j){numer+=h[j];}y[i]=numer/denom;}return y;}function circumcenter(points){if(points.length===0){return[];}var D=points[0].length;var result=dup([D]);var weights=barycentricCircumcenter(points);for(var i=0;i<points.length;++i){for(var j=0;j<D;++j){result[j]+=points[i][j]*weights[i];}}return result;}circumcenter.barycenetric=barycentricCircumcenter;module.exports=circumcenter;/***/},/***/1778:/***/function(module,__unused_webpack_exports,__nested_webpack_require_181422__){module.exports=circumradius;var circumcenter=__nested_webpack_require_181422__(9243);function circumradius(points){var center=circumcenter(points);var avgDist=0.0;for(var i=0;i<points.length;++i){var p=points[i];for(var j=0;j<center.length;++j){avgDist+=Math.pow(p[j]-center[j],2);}}return Math.sqrt(avgDist/points.length);}/***/},/***/197:/***/function(module,__unused_webpack_exports,__nested_webpack_require_181815__){"use strict";module.exports=cleanPSLG;var UnionFind=__nested_webpack_require_181815__(1731);var boxIntersect=__nested_webpack_require_181815__(2569);var segseg=__nested_webpack_require_181815__(4434);var rat=__nested_webpack_require_181815__(5125);var ratCmp=__nested_webpack_require_181815__(8846);var ratToFloat=__nested_webpack_require_181815__(7999);var ratVec=__nested_webpack_require_181815__(2826);var nextafter=__nested_webpack_require_181815__(8551);var solveIntersection=__nested_webpack_require_181815__(5528);// Bounds on a rational number when rounded to a float
function boundRat(r){var f=ratToFloat(r);return[nextafter(f,-Infinity),nextafter(f,Infinity)];}// Convert a list of edges in a pslg to bounding boxes
function boundEdges(points,edges){var bounds=new Array(edges.length);for(var i=0;i<edges.length;++i){var e=edges[i];var a=points[e[0]];var b=points[e[1]];bounds[i]=[nextafter(Math.min(a[0],b[0]),-Infinity),nextafter(Math.min(a[1],b[1]),-Infinity),nextafter(Math.max(a[0],b[0]),Infinity),nextafter(Math.max(a[1],b[1]),Infinity)];}return bounds;}// Convert a list of points into bounding boxes by duplicating coords
function boundPoints(points){var bounds=new Array(points.length);for(var i=0;i<points.length;++i){var p=points[i];bounds[i]=[nextafter(p[0],-Infinity),nextafter(p[1],-Infinity),nextafter(p[0],Infinity),nextafter(p[1],Infinity)];}return bounds;}// Find all pairs of crossing edges in a pslg (given edge bounds)
function getCrossings(points,edges,edgeBounds){var result=[];boxIntersect(edgeBounds,function(i,j){var e=edges[i];var f=edges[j];if(e[0]===f[0]||e[0]===f[1]||e[1]===f[0]||e[1]===f[1]){return;}var a=points[e[0]];var b=points[e[1]];var c=points[f[0]];var d=points[f[1]];if(segseg(a,b,c,d)){result.push([i,j]);}});return result;}// Find all pairs of crossing vertices in a pslg (given edge/vert bounds)
function getTJunctions(points,edges,edgeBounds,vertBounds){var result=[];boxIntersect(edgeBounds,vertBounds,function(i,v){var e=edges[i];if(e[0]===v||e[1]===v){return;}var p=points[v];var a=points[e[0]];var b=points[e[1]];if(segseg(a,b,p,p)){result.push([i,v]);}});return result;}// Cut edges along crossings/tjunctions
function cutEdges(floatPoints,edges,crossings,junctions,useColor){var i,e;// Convert crossings into tjunctions by constructing rational points
var ratPoints=floatPoints.map(function(p){return[rat(p[0]),rat(p[1])];});for(i=0;i<crossings.length;++i){var crossing=crossings[i];e=crossing[0];var f=crossing[1];var ee=edges[e];var ef=edges[f];var x=solveIntersection(ratVec(floatPoints[ee[0]]),ratVec(floatPoints[ee[1]]),ratVec(floatPoints[ef[0]]),ratVec(floatPoints[ef[1]]));if(!x){// Segments are parallel, should already be handled by t-junctions
continue;}var idx=floatPoints.length;floatPoints.push([ratToFloat(x[0]),ratToFloat(x[1])]);ratPoints.push(x);junctions.push([e,idx],[f,idx]);}// Sort tjunctions
junctions.sort(function(a,b){if(a[0]!==b[0]){return a[0]-b[0];}var u=ratPoints[a[1]];var v=ratPoints[b[1]];return ratCmp(u[0],v[0])||ratCmp(u[1],v[1]);});// Split edges along junctions
for(i=junctions.length-1;i>=0;--i){var junction=junctions[i];e=junction[0];var edge=edges[e];var s=edge[0];var t=edge[1];// Check if edge is not lexicographically sorted
var a=floatPoints[s];var b=floatPoints[t];if((a[0]-b[0]||a[1]-b[1])<0){var tmp=s;s=t;t=tmp;}// Split leading edge
edge[0]=s;var last=edge[1]=junction[1];// If we are grouping edges by color, remember to track data
var color;if(useColor){color=edge[2];}// Split other edges
while(i>0&&junctions[i-1][0]===e){var junction=junctions[--i];var next=junction[1];if(useColor){edges.push([last,next,color]);}else{edges.push([last,next]);}last=next;}// Add final edge
if(useColor){edges.push([last,t,color]);}else{edges.push([last,t]);}}// Return constructed rational points
return ratPoints;}// Merge overlapping points
function dedupPoints(floatPoints,ratPoints,floatBounds){var numPoints=ratPoints.length;var uf=new UnionFind(numPoints);// Compute rational bounds
var bounds=[];for(var i=0;i<ratPoints.length;++i){var p=ratPoints[i];var xb=boundRat(p[0]);var yb=boundRat(p[1]);bounds.push([nextafter(xb[0],-Infinity),nextafter(yb[0],-Infinity),nextafter(xb[1],Infinity),nextafter(yb[1],Infinity)]);}// Link all points with over lapping boxes
boxIntersect(bounds,function(i,j){uf.link(i,j);});// Do 1 pass over points to combine points in label sets
var noDupes=true;var labels=new Array(numPoints);for(var i=0;i<numPoints;++i){var j=uf.find(i);if(j!==i){// Clear no-dupes flag, zero out label
noDupes=false;// Make each point the top-left point from its cell
floatPoints[j]=[Math.min(floatPoints[i][0],floatPoints[j][0]),Math.min(floatPoints[i][1],floatPoints[j][1])];}}// If no duplicates, return null to signal termination
if(noDupes){return null;}var ptr=0;for(var i=0;i<numPoints;++i){var j=uf.find(i);if(j===i){labels[i]=ptr;floatPoints[ptr++]=floatPoints[i];}else{labels[i]=-1;}}floatPoints.length=ptr;// Do a second pass to fix up missing labels
for(var i=0;i<numPoints;++i){if(labels[i]<0){labels[i]=labels[uf.find(i)];}}// Return resulting union-find data structure
return labels;}function compareLex2(a,b){return a[0]-b[0]||a[1]-b[1];}function compareLex3(a,b){var d=a[0]-b[0]||a[1]-b[1];if(d){return d;}if(a[2]<b[2]){return-1;}else if(a[2]>b[2]){return 1;}return 0;}// Remove duplicate edge labels
function dedupEdges(edges,labels,useColor){if(edges.length===0){return;}if(labels){for(var i=0;i<edges.length;++i){var e=edges[i];var a=labels[e[0]];var b=labels[e[1]];e[0]=Math.min(a,b);e[1]=Math.max(a,b);}}else{for(var i=0;i<edges.length;++i){var e=edges[i];var a=e[0];var b=e[1];e[0]=Math.min(a,b);e[1]=Math.max(a,b);}}if(useColor){edges.sort(compareLex3);}else{edges.sort(compareLex2);}var ptr=1;for(var i=1;i<edges.length;++i){var prev=edges[i-1];var next=edges[i];if(next[0]===prev[0]&&next[1]===prev[1]&&(!useColor||next[2]===prev[2])){continue;}edges[ptr++]=next;}edges.length=ptr;}function preRound(points,edges,useColor){var labels=dedupPoints(points,[],boundPoints(points));dedupEdges(edges,labels,useColor);return!!labels;}// Repeat until convergence
function snapRound(points,edges,useColor){// 1. find edge crossings
var edgeBounds=boundEdges(points,edges);var crossings=getCrossings(points,edges,edgeBounds);// 2. find t-junctions
var vertBounds=boundPoints(points);var tjunctions=getTJunctions(points,edges,edgeBounds,vertBounds);// 3. cut edges, construct rational points
var ratPoints=cutEdges(points,edges,crossings,tjunctions,useColor);// 4. dedupe verts
var labels=dedupPoints(points,ratPoints,vertBounds);// 5. dedupe edges
dedupEdges(edges,labels,useColor);// 6. check termination
if(!labels){return crossings.length>0||tjunctions.length>0;}// More iterations necessary
return true;}// Main loop, runs PSLG clean up until completion
function cleanPSLG(points,edges,colors){// If using colors, augment edges with color data
var prevEdges;if(colors){prevEdges=edges;var augEdges=new Array(edges.length);for(var i=0;i<edges.length;++i){var e=edges[i];augEdges[i]=[e[0],e[1],colors[i]];}edges=augEdges;}// First round: remove duplicate edges and points
var modified=preRound(points,edges,!!colors);// Run snap rounding until convergence
while(snapRound(points,edges,!!colors)){modified=true;}// Strip color tags
if(!!colors&&modified){prevEdges.length=0;colors.length=0;for(var i=0;i<edges.length;++i){var e=edges[i];prevEdges.push([e[0],e[1]]);colors.push(e[2]);}}return modified;}/***/},/***/5528:/***/function(module,__unused_webpack_exports,__nested_webpack_require_189208__){"use strict";module.exports=solveIntersection;var ratMul=__nested_webpack_require_189208__(3962);var ratDiv=__nested_webpack_require_189208__(9189);var ratSub=__nested_webpack_require_189208__(4354);var ratSign=__nested_webpack_require_189208__(4951);var rvSub=__nested_webpack_require_189208__(6695);var rvAdd=__nested_webpack_require_189208__(7584);var rvMuls=__nested_webpack_require_189208__(4469);function ratPerp(a,b){return ratSub(ratMul(a[0],b[1]),ratMul(a[1],b[0]));}// Solve for intersection
//  x = a + t (b-a)
//  (x - c) ^ (d-c) = 0
//  (t * (b-a) + (a-c) ) ^ (d-c) = 0
//  t * (b-a)^(d-c) = (d-c)^(a-c)
//  t = (d-c)^(a-c) / (b-a)^(d-c)
function solveIntersection(a,b,c,d){var ba=rvSub(b,a);var dc=rvSub(d,c);var baXdc=ratPerp(ba,dc);if(ratSign(baXdc)===0){return null;}var ac=rvSub(a,c);var dcXac=ratPerp(dc,ac);var t=ratDiv(dcXac,baXdc);var s=rvMuls(ba,t);var r=rvAdd(a,s);return r;}/***/},/***/5692:/***/function(module){module.exports={"jet":[{"index":0,"rgb":[0,0,131]},{"index":0.125,"rgb":[0,60,170]},{"index":0.375,"rgb":[5,255,255]},{"index":0.625,"rgb":[255,255,0]},{"index":0.875,"rgb":[250,0,0]},{"index":1,"rgb":[128,0,0]}],"hsv":[{"index":0,"rgb":[255,0,0]},{"index":0.169,"rgb":[253,255,2]},{"index":0.173,"rgb":[247,255,2]},{"index":0.337,"rgb":[0,252,4]},{"index":0.341,"rgb":[0,252,10]},{"index":0.506,"rgb":[1,249,255]},{"index":0.671,"rgb":[2,0,253]},{"index":0.675,"rgb":[8,0,253]},{"index":0.839,"rgb":[255,0,251]},{"index":0.843,"rgb":[255,0,245]},{"index":1,"rgb":[255,0,6]}],"hot":[{"index":0,"rgb":[0,0,0]},{"index":0.3,"rgb":[230,0,0]},{"index":0.6,"rgb":[255,210,0]},{"index":1,"rgb":[255,255,255]}],"spring":[{"index":0,"rgb":[255,0,255]},{"index":1,"rgb":[255,255,0]}],"summer":[{"index":0,"rgb":[0,128,102]},{"index":1,"rgb":[255,255,102]}],"autumn":[{"index":0,"rgb":[255,0,0]},{"index":1,"rgb":[255,255,0]}],"winter":[{"index":0,"rgb":[0,0,255]},{"index":1,"rgb":[0,255,128]}],"bone":[{"index":0,"rgb":[0,0,0]},{"index":0.376,"rgb":[84,84,116]},{"index":0.753,"rgb":[169,200,200]},{"index":1,"rgb":[255,255,255]}],"copper":[{"index":0,"rgb":[0,0,0]},{"index":0.804,"rgb":[255,160,102]},{"index":1,"rgb":[255,199,127]}],"greys":[{"index":0,"rgb":[0,0,0]},{"index":1,"rgb":[255,255,255]}],"yignbu":[{"index":0,"rgb":[8,29,88]},{"index":0.125,"rgb":[37,52,148]},{"index":0.25,"rgb":[34,94,168]},{"index":0.375,"rgb":[29,145,192]},{"index":0.5,"rgb":[65,182,196]},{"index":0.625,"rgb":[127,205,187]},{"index":0.75,"rgb":[199,233,180]},{"index":0.875,"rgb":[237,248,217]},{"index":1,"rgb":[255,255,217]}],"greens":[{"index":0,"rgb":[0,68,27]},{"index":0.125,"rgb":[0,109,44]},{"index":0.25,"rgb":[35,139,69]},{"index":0.375,"rgb":[65,171,93]},{"index":0.5,"rgb":[116,196,118]},{"index":0.625,"rgb":[161,217,155]},{"index":0.75,"rgb":[199,233,192]},{"index":0.875,"rgb":[229,245,224]},{"index":1,"rgb":[247,252,245]}],"yiorrd":[{"index":0,"rgb":[128,0,38]},{"index":0.125,"rgb":[189,0,38]},{"index":0.25,"rgb":[227,26,28]},{"index":0.375,"rgb":[252,78,42]},{"index":0.5,"rgb":[253,141,60]},{"index":0.625,"rgb":[254,178,76]},{"index":0.75,"rgb":[254,217,118]},{"index":0.875,"rgb":[255,237,160]},{"index":1,"rgb":[255,255,204]}],"bluered":[{"index":0,"rgb":[0,0,255]},{"index":1,"rgb":[255,0,0]}],"rdbu":[{"index":0,"rgb":[5,10,172]},{"index":0.35,"rgb":[106,137,247]},{"index":0.5,"rgb":[190,190,190]},{"index":0.6,"rgb":[220,170,132]},{"index":0.7,"rgb":[230,145,90]},{"index":1,"rgb":[178,10,28]}],"picnic":[{"index":0,"rgb":[0,0,255]},{"index":0.1,"rgb":[51,153,255]},{"index":0.2,"rgb":[102,204,255]},{"index":0.3,"rgb":[153,204,255]},{"index":0.4,"rgb":[204,204,255]},{"index":0.5,"rgb":[255,255,255]},{"index":0.6,"rgb":[255,204,255]},{"index":0.7,"rgb":[255,153,255]},{"index":0.8,"rgb":[255,102,204]},{"index":0.9,"rgb":[255,102,102]},{"index":1,"rgb":[255,0,0]}],"rainbow":[{"index":0,"rgb":[150,0,90]},{"index":0.125,"rgb":[0,0,200]},{"index":0.25,"rgb":[0,25,255]},{"index":0.375,"rgb":[0,152,255]},{"index":0.5,"rgb":[44,255,150]},{"index":0.625,"rgb":[151,255,0]},{"index":0.75,"rgb":[255,234,0]},{"index":0.875,"rgb":[255,111,0]},{"index":1,"rgb":[255,0,0]}],"portland":[{"index":0,"rgb":[12,51,131]},{"index":0.25,"rgb":[10,136,186]},{"index":0.5,"rgb":[242,211,56]},{"index":0.75,"rgb":[242,143,56]},{"index":1,"rgb":[217,30,30]}],"blackbody":[{"index":0,"rgb":[0,0,0]},{"index":0.2,"rgb":[230,0,0]},{"index":0.4,"rgb":[230,210,0]},{"index":0.7,"rgb":[255,255,255]},{"index":1,"rgb":[160,200,255]}],"earth":[{"index":0,"rgb":[0,0,130]},{"index":0.1,"rgb":[0,180,180]},{"index":0.2,"rgb":[40,210,40]},{"index":0.4,"rgb":[230,230,50]},{"index":0.6,"rgb":[120,70,20]},{"index":1,"rgb":[255,255,255]}],"electric":[{"index":0,"rgb":[0,0,0]},{"index":0.15,"rgb":[30,0,100]},{"index":0.4,"rgb":[120,0,100]},{"index":0.6,"rgb":[160,90,0]},{"index":0.8,"rgb":[230,200,0]},{"index":1,"rgb":[255,250,220]}],"alpha":[{"index":0,"rgb":[255,255,255,0]},{"index":1,"rgb":[255,255,255,1]}],"viridis":[{"index":0,"rgb":[68,1,84]},{"index":0.13,"rgb":[71,44,122]},{"index":0.25,"rgb":[59,81,139]},{"index":0.38,"rgb":[44,113,142]},{"index":0.5,"rgb":[33,144,141]},{"index":0.63,"rgb":[39,173,129]},{"index":0.75,"rgb":[92,200,99]},{"index":0.88,"rgb":[170,220,50]},{"index":1,"rgb":[253,231,37]}],"inferno":[{"index":0,"rgb":[0,0,4]},{"index":0.13,"rgb":[31,12,72]},{"index":0.25,"rgb":[85,15,109]},{"index":0.38,"rgb":[136,34,106]},{"index":0.5,"rgb":[186,54,85]},{"index":0.63,"rgb":[227,89,51]},{"index":0.75,"rgb":[249,140,10]},{"index":0.88,"rgb":[249,201,50]},{"index":1,"rgb":[252,255,164]}],"magma":[{"index":0,"rgb":[0,0,4]},{"index":0.13,"rgb":[28,16,68]},{"index":0.25,"rgb":[79,18,123]},{"index":0.38,"rgb":[129,37,129]},{"index":0.5,"rgb":[181,54,122]},{"index":0.63,"rgb":[229,80,100]},{"index":0.75,"rgb":[251,135,97]},{"index":0.88,"rgb":[254,194,135]},{"index":1,"rgb":[252,253,191]}],"plasma":[{"index":0,"rgb":[13,8,135]},{"index":0.13,"rgb":[75,3,161]},{"index":0.25,"rgb":[125,3,168]},{"index":0.38,"rgb":[168,34,150]},{"index":0.5,"rgb":[203,70,121]},{"index":0.63,"rgb":[229,107,93]},{"index":0.75,"rgb":[248,148,65]},{"index":0.88,"rgb":[253,195,40]},{"index":1,"rgb":[240,249,33]}],"warm":[{"index":0,"rgb":[125,0,179]},{"index":0.13,"rgb":[172,0,187]},{"index":0.25,"rgb":[219,0,170]},{"index":0.38,"rgb":[255,0,130]},{"index":0.5,"rgb":[255,63,74]},{"index":0.63,"rgb":[255,123,0]},{"index":0.75,"rgb":[234,176,0]},{"index":0.88,"rgb":[190,228,0]},{"index":1,"rgb":[147,255,0]}],"cool":[{"index":0,"rgb":[125,0,179]},{"index":0.13,"rgb":[116,0,218]},{"index":0.25,"rgb":[98,74,237]},{"index":0.38,"rgb":[68,146,231]},{"index":0.5,"rgb":[0,204,197]},{"index":0.63,"rgb":[0,247,146]},{"index":0.75,"rgb":[0,255,88]},{"index":0.88,"rgb":[40,255,8]},{"index":1,"rgb":[147,255,0]}],"rainbow-soft":[{"index":0,"rgb":[125,0,179]},{"index":0.1,"rgb":[199,0,180]},{"index":0.2,"rgb":[255,0,121]},{"index":0.3,"rgb":[255,108,0]},{"index":0.4,"rgb":[222,194,0]},{"index":0.5,"rgb":[150,255,0]},{"index":0.6,"rgb":[0,255,55]},{"index":0.7,"rgb":[0,246,150]},{"index":0.8,"rgb":[50,167,222]},{"index":0.9,"rgb":[103,51,235]},{"index":1,"rgb":[124,0,186]}],"bathymetry":[{"index":0,"rgb":[40,26,44]},{"index":0.13,"rgb":[59,49,90]},{"index":0.25,"rgb":[64,76,139]},{"index":0.38,"rgb":[63,110,151]},{"index":0.5,"rgb":[72,142,158]},{"index":0.63,"rgb":[85,174,163]},{"index":0.75,"rgb":[120,206,163]},{"index":0.88,"rgb":[187,230,172]},{"index":1,"rgb":[253,254,204]}],"cdom":[{"index":0,"rgb":[47,15,62]},{"index":0.13,"rgb":[87,23,86]},{"index":0.25,"rgb":[130,28,99]},{"index":0.38,"rgb":[171,41,96]},{"index":0.5,"rgb":[206,67,86]},{"index":0.63,"rgb":[230,106,84]},{"index":0.75,"rgb":[242,149,103]},{"index":0.88,"rgb":[249,193,135]},{"index":1,"rgb":[254,237,176]}],"chlorophyll":[{"index":0,"rgb":[18,36,20]},{"index":0.13,"rgb":[25,63,41]},{"index":0.25,"rgb":[24,91,59]},{"index":0.38,"rgb":[13,119,72]},{"index":0.5,"rgb":[18,148,80]},{"index":0.63,"rgb":[80,173,89]},{"index":0.75,"rgb":[132,196,122]},{"index":0.88,"rgb":[175,221,162]},{"index":1,"rgb":[215,249,208]}],"density":[{"index":0,"rgb":[54,14,36]},{"index":0.13,"rgb":[89,23,80]},{"index":0.25,"rgb":[110,45,132]},{"index":0.38,"rgb":[120,77,178]},{"index":0.5,"rgb":[120,113,213]},{"index":0.63,"rgb":[115,151,228]},{"index":0.75,"rgb":[134,185,227]},{"index":0.88,"rgb":[177,214,227]},{"index":1,"rgb":[230,241,241]}],"freesurface-blue":[{"index":0,"rgb":[30,4,110]},{"index":0.13,"rgb":[47,14,176]},{"index":0.25,"rgb":[41,45,236]},{"index":0.38,"rgb":[25,99,212]},{"index":0.5,"rgb":[68,131,200]},{"index":0.63,"rgb":[114,156,197]},{"index":0.75,"rgb":[157,181,203]},{"index":0.88,"rgb":[200,208,216]},{"index":1,"rgb":[241,237,236]}],"freesurface-red":[{"index":0,"rgb":[60,9,18]},{"index":0.13,"rgb":[100,17,27]},{"index":0.25,"rgb":[142,20,29]},{"index":0.38,"rgb":[177,43,27]},{"index":0.5,"rgb":[192,87,63]},{"index":0.63,"rgb":[205,125,105]},{"index":0.75,"rgb":[216,162,148]},{"index":0.88,"rgb":[227,199,193]},{"index":1,"rgb":[241,237,236]}],"oxygen":[{"index":0,"rgb":[64,5,5]},{"index":0.13,"rgb":[106,6,15]},{"index":0.25,"rgb":[144,26,7]},{"index":0.38,"rgb":[168,64,3]},{"index":0.5,"rgb":[188,100,4]},{"index":0.63,"rgb":[206,136,11]},{"index":0.75,"rgb":[220,174,25]},{"index":0.88,"rgb":[231,215,44]},{"index":1,"rgb":[248,254,105]}],"par":[{"index":0,"rgb":[51,20,24]},{"index":0.13,"rgb":[90,32,35]},{"index":0.25,"rgb":[129,44,34]},{"index":0.38,"rgb":[159,68,25]},{"index":0.5,"rgb":[182,99,19]},{"index":0.63,"rgb":[199,134,22]},{"index":0.75,"rgb":[212,171,35]},{"index":0.88,"rgb":[221,210,54]},{"index":1,"rgb":[225,253,75]}],"phase":[{"index":0,"rgb":[145,105,18]},{"index":0.13,"rgb":[184,71,38]},{"index":0.25,"rgb":[186,58,115]},{"index":0.38,"rgb":[160,71,185]},{"index":0.5,"rgb":[110,97,218]},{"index":0.63,"rgb":[50,123,164]},{"index":0.75,"rgb":[31,131,110]},{"index":0.88,"rgb":[77,129,34]},{"index":1,"rgb":[145,105,18]}],"salinity":[{"index":0,"rgb":[42,24,108]},{"index":0.13,"rgb":[33,50,162]},{"index":0.25,"rgb":[15,90,145]},{"index":0.38,"rgb":[40,118,137]},{"index":0.5,"rgb":[59,146,135]},{"index":0.63,"rgb":[79,175,126]},{"index":0.75,"rgb":[120,203,104]},{"index":0.88,"rgb":[193,221,100]},{"index":1,"rgb":[253,239,154]}],"temperature":[{"index":0,"rgb":[4,35,51]},{"index":0.13,"rgb":[23,51,122]},{"index":0.25,"rgb":[85,59,157]},{"index":0.38,"rgb":[129,79,143]},{"index":0.5,"rgb":[175,95,130]},{"index":0.63,"rgb":[222,112,101]},{"index":0.75,"rgb":[249,146,66]},{"index":0.88,"rgb":[249,196,65]},{"index":1,"rgb":[232,250,91]}],"turbidity":[{"index":0,"rgb":[34,31,27]},{"index":0.13,"rgb":[65,50,41]},{"index":0.25,"rgb":[98,69,52]},{"index":0.38,"rgb":[131,89,57]},{"index":0.5,"rgb":[161,112,59]},{"index":0.63,"rgb":[185,140,66]},{"index":0.75,"rgb":[202,174,88]},{"index":0.88,"rgb":[216,209,126]},{"index":1,"rgb":[233,246,171]}],"velocity-blue":[{"index":0,"rgb":[17,32,64]},{"index":0.13,"rgb":[35,52,116]},{"index":0.25,"rgb":[29,81,156]},{"index":0.38,"rgb":[31,113,162]},{"index":0.5,"rgb":[50,144,169]},{"index":0.63,"rgb":[87,173,176]},{"index":0.75,"rgb":[149,196,189]},{"index":0.88,"rgb":[203,221,211]},{"index":1,"rgb":[254,251,230]}],"velocity-green":[{"index":0,"rgb":[23,35,19]},{"index":0.13,"rgb":[24,64,38]},{"index":0.25,"rgb":[11,95,45]},{"index":0.38,"rgb":[39,123,35]},{"index":0.5,"rgb":[95,146,12]},{"index":0.63,"rgb":[152,165,18]},{"index":0.75,"rgb":[201,186,69]},{"index":0.88,"rgb":[233,216,137]},{"index":1,"rgb":[255,253,205]}],"cubehelix":[{"index":0,"rgb":[0,0,0]},{"index":0.07,"rgb":[22,5,59]},{"index":0.13,"rgb":[60,4,105]},{"index":0.2,"rgb":[109,1,135]},{"index":0.27,"rgb":[161,0,147]},{"index":0.33,"rgb":[210,2,142]},{"index":0.4,"rgb":[251,11,123]},{"index":0.47,"rgb":[255,29,97]},{"index":0.53,"rgb":[255,54,69]},{"index":0.6,"rgb":[255,85,46]},{"index":0.67,"rgb":[255,120,34]},{"index":0.73,"rgb":[255,157,37]},{"index":0.8,"rgb":[241,191,57]},{"index":0.87,"rgb":[224,220,93]},{"index":0.93,"rgb":[218,241,142]},{"index":1,"rgb":[227,253,198]}]};/***/},/***/9156:/***/function(module,__unused_webpack_exports,__nested_webpack_require_201177__){"use strict";/*
 * Ben Postlethwaite
 * January 2013
 * License MIT
 */var colorScale=__nested_webpack_require_201177__(5692);var lerp=__nested_webpack_require_201177__(3578);module.exports=createColormap;function createColormap(spec){/*
     * Default Options
     */var indicies,fromrgba,torgba,nsteps,cmap,colormap,format,nshades,colors,alpha,i;if(!spec)spec={};nshades=(spec.nshades||72)-1;format=spec.format||'hex';colormap=spec.colormap;if(!colormap)colormap='jet';if(typeof colormap==='string'){colormap=colormap.toLowerCase();if(!colorScale[colormap]){throw Error(colormap+' not a supported colorscale');}cmap=colorScale[colormap];}else if(Array.isArray(colormap)){cmap=colormap.slice();}else{throw Error('unsupported colormap option',colormap);}if(cmap.length>nshades+1){throw new Error(colormap+' map requires nshades to be at least size '+cmap.length);}if(!Array.isArray(spec.alpha)){if(typeof spec.alpha==='number'){alpha=[spec.alpha,spec.alpha];}else{alpha=[1,1];}}else if(spec.alpha.length!==2){alpha=[1,1];}else{alpha=spec.alpha.slice();}// map index points from 0..1 to 0..n-1
indicies=cmap.map(function(c){return Math.round(c.index*nshades);});// Add alpha channel to the map
alpha[0]=Math.min(Math.max(alpha[0],0),1);alpha[1]=Math.min(Math.max(alpha[1],0),1);var steps=cmap.map(function(c,i){var index=cmap[i].index;var rgba=cmap[i].rgb.slice();// if user supplies their own map use it
if(rgba.length===4&&rgba[3]>=0&&rgba[3]<=1){return rgba;}rgba[3]=alpha[0]+(alpha[1]-alpha[0])*index;return rgba;});/*
     * map increasing linear values between indicies to
     * linear steps in colorvalues
     */var colors=[];for(i=0;i<indicies.length-1;++i){nsteps=indicies[i+1]-indicies[i];fromrgba=steps[i];torgba=steps[i+1];for(var j=0;j<nsteps;j++){var amt=j/nsteps;colors.push([Math.round(lerp(fromrgba[0],torgba[0],amt)),Math.round(lerp(fromrgba[1],torgba[1],amt)),Math.round(lerp(fromrgba[2],torgba[2],amt)),lerp(fromrgba[3],torgba[3],amt)]);}}//add 1 step as last value
colors.push(cmap[cmap.length-1].rgb.concat(alpha[1]));if(format==='hex')colors=colors.map(rgb2hex);else if(format==='rgbaString')colors=colors.map(rgbaStr);else if(format==='float')colors=colors.map(rgb2float);return colors;};function rgb2float(rgba){return[rgba[0]/255,rgba[1]/255,rgba[2]/255,rgba[3]];}function rgb2hex(rgba){var dig,hex='#';for(var i=0;i<3;++i){dig=rgba[i];dig=dig.toString(16);hex+=('00'+dig).substr(dig.length);}return hex;}function rgbaStr(rgba){return'rgba('+rgba.join(',')+')';}/***/},/***/9398:/***/function(module,__unused_webpack_exports,__nested_webpack_require_203722__){"use strict";module.exports=compareAngle;var orient=__nested_webpack_require_203722__(417);var sgn=__nested_webpack_require_203722__(7538);var twoSum=__nested_webpack_require_203722__(87);var robustProduct=__nested_webpack_require_203722__(2019);var robustSum=__nested_webpack_require_203722__(9662);function testInterior(a,b,c){var x0=twoSum(a[0],-b[0]);var y0=twoSum(a[1],-b[1]);var x1=twoSum(c[0],-b[0]);var y1=twoSum(c[1],-b[1]);var d=robustSum(robustProduct(x0,x1),robustProduct(y0,y1));return d[d.length-1]>=0;}function compareAngle(a,b,c,d){var bcd=orient(b,c,d);if(bcd===0){//Handle degenerate cases
var sabc=sgn(orient(a,b,c));var sabd=sgn(orient(a,b,d));if(sabc===sabd){if(sabc===0){var ic=testInterior(a,b,c);var id=testInterior(a,b,d);if(ic===id){return 0;}else if(ic){return 1;}else{return-1;}}return 0;}else if(sabd===0){if(sabc>0){return-1;}else if(testInterior(a,b,d)){return-1;}else{return 1;}}else if(sabc===0){if(sabd>0){return 1;}else if(testInterior(a,b,c)){return 1;}else{return-1;}}return sgn(sabd-sabc);}var abc=orient(a,b,c);if(abc>0){if(bcd>0&&orient(a,b,d)>0){return 1;}return-1;}else if(abc<0){if(bcd>0||orient(a,b,d)>0){return 1;}return-1;}else{var abd=orient(a,b,d);if(abd>0){return 1;}else{if(testInterior(a,b,c)){return 1;}else{return-1;}}}}/***/},/***/7538:/***/function(module){"use strict";module.exports=function signum(x){if(x<0){return-1;}if(x>0){return 1;}return 0.0;};/***/},/***/9209:/***/function(module){module.exports=compareCells;var min=Math.min;function compareInt(a,b){return a-b;}function compareCells(a,b){var n=a.length,t=a.length-b.length;if(t){return t;}switch(n){case 0:return 0;case 1:return a[0]-b[0];case 2:return a[0]+a[1]-b[0]-b[1]||min(a[0],a[1])-min(b[0],b[1]);case 3:var l1=a[0]+a[1],m1=b[0]+b[1];t=l1+a[2]-(m1+b[2]);if(t){return t;}var l0=min(a[0],a[1]),m0=min(b[0],b[1]);return min(l0,a[2])-min(m0,b[2])||min(l0+a[2],l1)-min(m0+b[2],m1);case 4:var aw=a[0],ax=a[1],ay=a[2],az=a[3],bw=b[0],bx=b[1],by=b[2],bz=b[3];return aw+ax+ay+az-(bw+bx+by+bz)||min(aw,ax,ay,az)-min(bw,bx,by,bz,bw)||min(aw+ax,aw+ay,aw+az,ax+ay,ax+az,ay+az)-min(bw+bx,bw+by,bw+bz,bx+by,bx+bz,by+bz)||min(aw+ax+ay,aw+ax+az,aw+ay+az,ax+ay+az)-min(bw+bx+by,bw+bx+bz,bw+by+bz,bx+by+bz);default:var as=a.slice().sort(compareInt);var bs=b.slice().sort(compareInt);for(var i=0;i<n;++i){t=as[i]-bs[i];if(t){return t;}}return 0;}}/***/},/***/1284:/***/function(module,__unused_webpack_exports,__nested_webpack_require_206088__){"use strict";var compareCells=__nested_webpack_require_206088__(9209);var parity=__nested_webpack_require_206088__(9887);module.exports=compareOrientedCells;function compareOrientedCells(a,b){return compareCells(a,b)||parity(a)-parity(b);}/***/},/***/5537:/***/function(module,__unused_webpack_exports,__nested_webpack_require_206383__){"use strict";var convexHull1d=__nested_webpack_require_206383__(8950);var convexHull2d=__nested_webpack_require_206383__(8722);var convexHullnd=__nested_webpack_require_206383__(3332);module.exports=convexHull;function convexHull(points){var n=points.length;if(n===0){return[];}else if(n===1){return[[0]];}var d=points[0].length;if(d===0){return[];}else if(d===1){return convexHull1d(points);}else if(d===2){return convexHull2d(points);}return convexHullnd(points,d);}/***/},/***/8950:/***/function(module){"use strict";module.exports=convexHull1d;function convexHull1d(points){var lo=0;var hi=0;for(var i=1;i<points.length;++i){if(points[i][0]<points[lo][0]){lo=i;}if(points[i][0]>points[hi][0]){hi=i;}}if(lo<hi){return[[lo],[hi]];}else if(lo>hi){return[[hi],[lo]];}else{return[[lo]];}}/***/},/***/8722:/***/function(module,__unused_webpack_exports,__nested_webpack_require_207212__){"use strict";module.exports=convexHull2D;var monotoneHull=__nested_webpack_require_207212__(3266);function convexHull2D(points){var hull=monotoneHull(points);var h=hull.length;if(h<=2){return[];}var edges=new Array(h);var a=hull[h-1];for(var i=0;i<h;++i){var b=hull[i];edges[i]=[a,b];a=b;}return edges;}/***/},/***/3332:/***/function(module,__unused_webpack_exports,__nested_webpack_require_207585__){"use strict";module.exports=convexHullnD;var ich=__nested_webpack_require_207585__(2183);var aff=__nested_webpack_require_207585__(2153);function permute(points,front){var n=points.length;var npoints=new Array(n);for(var i=0;i<front.length;++i){npoints[i]=points[front[i]];}var ptr=front.length;for(var i=0;i<n;++i){if(front.indexOf(i)<0){npoints[ptr++]=points[i];}}return npoints;}function invPermute(cells,front){var nc=cells.length;var nf=front.length;for(var i=0;i<nc;++i){var c=cells[i];for(var j=0;j<c.length;++j){var x=c[j];if(x<nf){c[j]=front[x];}else{x=x-nf;for(var k=0;k<nf;++k){if(x>=front[k]){x+=1;}}c[j]=x;}}}return cells;}function convexHullnD(points,d){try{return ich(points,true);}catch(e){//If point set is degenerate, try to find a basis and rerun it
var ah=aff(points);if(ah.length<=d){//No basis, no try
return[];}var npoints=permute(points,ah);var nhull=ich(npoints,true);return invPermute(nhull,ah);}}/***/},/***/9680:/***/function(module){"use strict";function dcubicHermite(p0,v0,p1,v1,t,f){var dh00=6*t*t-6*t,dh10=3*t*t-4*t+1,dh01=-6*t*t+6*t,dh11=3*t*t-2*t;if(p0.length){if(!f){f=new Array(p0.length);}for(var i=p0.length-1;i>=0;--i){f[i]=dh00*p0[i]+dh10*v0[i]+dh01*p1[i]+dh11*v1[i];}return f;}return dh00*p0+dh10*v0+dh01*p1[i]+dh11*v1;}function cubicHermite(p0,v0,p1,v1,t,f){var ti=t-1,t2=t*t,ti2=ti*ti,h00=(1+2*t)*ti2,h10=t*ti2,h01=t2*(3-2*t),h11=t2*ti;if(p0.length){if(!f){f=new Array(p0.length);}for(var i=p0.length-1;i>=0;--i){f[i]=h00*p0[i]+h10*v0[i]+h01*p1[i]+h11*v1[i];}return f;}return h00*p0+h10*v0+h01*p1+h11*v1;}module.exports=cubicHermite;module.exports.derivative=dcubicHermite;/***/},/***/4419:/***/function(module,__unused_webpack_exports,__nested_webpack_require_209258__){"use strict";var ch=__nested_webpack_require_209258__(2183);var uniq=__nested_webpack_require_209258__(1215);module.exports=triangulate;function LiftedPoint(p,i){this.point=p;this.index=i;}function compareLifted(a,b){var ap=a.point;var bp=b.point;var d=ap.length;for(var i=0;i<d;++i){var s=bp[i]-ap[i];if(s){return s;}}return 0;}function triangulate1D(n,points,includePointAtInfinity){if(n===1){if(includePointAtInfinity){return[[-1,0]];}else{return[];}}var lifted=points.map(function(p,i){return[p[0],i];});lifted.sort(function(a,b){return a[0]-b[0];});var cells=new Array(n-1);for(var i=1;i<n;++i){var a=lifted[i-1];var b=lifted[i];cells[i-1]=[a[1],b[1]];}if(includePointAtInfinity){cells.push([-1,cells[0][1]],[cells[n-1][1],-1]);}return cells;}function triangulate(points,includePointAtInfinity){var n=points.length;if(n===0){return[];}var d=points[0].length;if(d<1){return[];}//Special case:  For 1D we can just sort the points
if(d===1){return triangulate1D(n,points,includePointAtInfinity);}//Lift points, sort
var lifted=new Array(n);var upper=1.0;for(var i=0;i<n;++i){var p=points[i];var x=new Array(d+1);var l=0.0;for(var j=0;j<d;++j){var v=p[j];x[j]=v;l+=v*v;}x[d]=l;lifted[i]=new LiftedPoint(x,i);upper=Math.max(l,upper);}uniq(lifted,compareLifted);//Double points
n=lifted.length;//Create new list of points
var dpoints=new Array(n+d+1);var dindex=new Array(n+d+1);//Add steiner points at top
var u=(d+1)*(d+1)*upper;var y=new Array(d+1);for(var i=0;i<=d;++i){y[i]=0.0;}y[d]=u;dpoints[0]=y.slice();dindex[0]=-1;for(var i=0;i<=d;++i){var x=y.slice();x[i]=1;dpoints[i+1]=x;dindex[i+1]=-1;}//Copy rest of the points over
for(var i=0;i<n;++i){var h=lifted[i];dpoints[i+d+1]=h.point;dindex[i+d+1]=h.index;}//Construct convex hull
var hull=ch(dpoints,false);if(includePointAtInfinity){hull=hull.filter(function(cell){var count=0;for(var j=0;j<=d;++j){var v=dindex[cell[j]];if(v<0){if(++count>=2){return false;}}cell[j]=v;}return true;});}else{hull=hull.filter(function(cell){for(var i=0;i<=d;++i){var v=dindex[cell[i]];if(v<0){return false;}cell[i]=v;}return true;});}if(d&1){for(var i=0;i<hull.length;++i){var h=hull[i];var x=h[0];h[0]=h[1];h[1]=x;}}return hull;}/***/},/***/8362:/***/function(module){var hasTypedArrays=false;if(typeof Float64Array!=="undefined"){var DOUBLE_VIEW=new Float64Array(1),UINT_VIEW=new Uint32Array(DOUBLE_VIEW.buffer);DOUBLE_VIEW[0]=1.0;hasTypedArrays=true;if(UINT_VIEW[1]===0x3ff00000){//Use little endian
module.exports=function doubleBitsLE(n){DOUBLE_VIEW[0]=n;return[UINT_VIEW[0],UINT_VIEW[1]];};function toDoubleLE(lo,hi){UINT_VIEW[0]=lo;UINT_VIEW[1]=hi;return DOUBLE_VIEW[0];}module.exports.pack=toDoubleLE;function lowUintLE(n){DOUBLE_VIEW[0]=n;return UINT_VIEW[0];}module.exports.lo=lowUintLE;function highUintLE(n){DOUBLE_VIEW[0]=n;return UINT_VIEW[1];}module.exports.hi=highUintLE;}else if(UINT_VIEW[0]===0x3ff00000){//Use big endian
module.exports=function doubleBitsBE(n){DOUBLE_VIEW[0]=n;return[UINT_VIEW[1],UINT_VIEW[0]];};function toDoubleBE(lo,hi){UINT_VIEW[1]=lo;UINT_VIEW[0]=hi;return DOUBLE_VIEW[0];}module.exports.pack=toDoubleBE;function lowUintBE(n){DOUBLE_VIEW[0]=n;return UINT_VIEW[1];}module.exports.lo=lowUintBE;function highUintBE(n){DOUBLE_VIEW[0]=n;return UINT_VIEW[0];}module.exports.hi=highUintBE;}else{hasTypedArrays=false;}}if(!hasTypedArrays){var buffer=new Buffer(8);module.exports=function doubleBits(n){buffer.writeDoubleLE(n,0,true);return[buffer.readUInt32LE(0,true),buffer.readUInt32LE(4,true)];};function toDouble(lo,hi){buffer.writeUInt32LE(lo,0,true);buffer.writeUInt32LE(hi,4,true);return buffer.readDoubleLE(0,true);}module.exports.pack=toDouble;function lowUint(n){buffer.writeDoubleLE(n,0,true);return buffer.readUInt32LE(0,true);}module.exports.lo=lowUint;function highUint(n){buffer.writeDoubleLE(n,0,true);return buffer.readUInt32LE(4,true);}module.exports.hi=highUint;}module.exports.sign=function(n){return module.exports.hi(n)>>>31;};module.exports.exponent=function(n){var b=module.exports.hi(n);return(b<<1>>>21)-1023;};module.exports.fraction=function(n){var lo=module.exports.lo(n);var hi=module.exports.hi(n);var b=hi&(1<<20)-1;if(hi&0x7ff00000){b+=1<<20;}return[lo,b];};module.exports.denormalized=function(n){var hi=module.exports.hi(n);return!(hi&0x7ff00000);};/***/},/***/3094:/***/function(module){"use strict";function dupe_array(count,value,i){var c=count[i]|0;if(c<=0){return[];}var result=new Array(c),j;if(i===count.length-1){for(j=0;j<c;++j){result[j]=value;}}else{for(j=0;j<c;++j){result[j]=dupe_array(count,value,i+1);}}return result;}function dupe_number(count,value){var result,i;result=new Array(count);for(i=0;i<count;++i){result[i]=value;}return result;}function dupe(count,value){if(typeof value==="undefined"){value=0;}switch(typeof count){case"number":if(count>0){return dupe_number(count|0,value);}break;case"object":if(typeof count.length==="number"){return dupe_array(count,value,0);}break;}return[];}module.exports=dupe;/***/},/***/8348:/***/function(module,__unused_webpack_exports,__nested_webpack_require_214254__){"use strict";module.exports=edgeToAdjacency;var uniq=__nested_webpack_require_214254__(1215);function edgeToAdjacency(edges,numVertices){var numEdges=edges.length;if(typeof numVertices!=="number"){numVertices=0;for(var i=0;i<numEdges;++i){var e=edges[i];numVertices=Math.max(numVertices,e[0],e[1]);}numVertices=(numVertices|0)+1;}numVertices=numVertices|0;var adj=new Array(numVertices);for(var i=0;i<numVertices;++i){adj[i]=[];}for(var i=0;i<numEdges;++i){var e=edges[i];adj[e[0]].push(e[1]);adj[e[1]].push(e[0]);}for(var j=0;j<numVertices;++j){uniq(adj[j],function(a,b){return a-b;});}return adj;}/***/},/***/5795:/***/function(module){"use strict";module.exports=extractPlanes;function extractPlanes(M,zNear,zFar){var z=zNear||0.0;var zf=zFar||1.0;return[[M[12]+M[0],M[13]+M[1],M[14]+M[2],M[15]+M[3]],[M[12]-M[0],M[13]-M[1],M[14]-M[2],M[15]-M[3]],[M[12]+M[4],M[13]+M[5],M[14]+M[6],M[15]+M[7]],[M[12]-M[4],M[13]-M[5],M[14]-M[6],M[15]-M[7]],[z*M[12]+M[8],z*M[13]+M[9],z*M[14]+M[10],z*M[15]+M[11]],[zf*M[12]-M[8],zf*M[13]-M[9],zf*M[14]-M[10],zf*M[15]-M[11]]];}/***/},/***/8444:/***/function(module,__unused_webpack_exports,__nested_webpack_require_215384__){"use strict";module.exports=createFilteredVector;var cubicHermite=__nested_webpack_require_215384__(9680);var bsearch=__nested_webpack_require_215384__(5070);function clamp(lo,hi,x){return Math.min(hi,Math.max(lo,x));}function FilteredVector(state0,velocity0,t0){this.dimension=state0.length;this.bounds=[new Array(this.dimension),new Array(this.dimension)];for(var i=0;i<this.dimension;++i){this.bounds[0][i]=-Infinity;this.bounds[1][i]=Infinity;}this._state=state0.slice().reverse();this._velocity=velocity0.slice().reverse();this._time=[t0];this._scratch=[state0.slice(),state0.slice(),state0.slice(),state0.slice(),state0.slice()];}var proto=FilteredVector.prototype;proto.flush=function(t){var idx=bsearch.gt(this._time,t)-1;if(idx<=0){return;}this._time.splice(0,idx);this._state.splice(0,idx*this.dimension);this._velocity.splice(0,idx*this.dimension);};proto.curve=function(t){var time=this._time;var n=time.length;var idx=bsearch.le(time,t);var result=this._scratch[0];var state=this._state;var velocity=this._velocity;var d=this.dimension;var bounds=this.bounds;if(idx<0){var ptr=d-1;for(var i=0;i<d;++i,--ptr){result[i]=state[ptr];}}else if(idx>=n-1){var ptr=state.length-1;var tf=t-time[n-1];for(var i=0;i<d;++i,--ptr){result[i]=state[ptr]+tf*velocity[ptr];}}else{var ptr=d*(idx+1)-1;var t0=time[idx];var t1=time[idx+1];var dt=t1-t0||1.0;var x0=this._scratch[1];var x1=this._scratch[2];var v0=this._scratch[3];var v1=this._scratch[4];var steady=true;for(var i=0;i<d;++i,--ptr){x0[i]=state[ptr];v0[i]=velocity[ptr]*dt;x1[i]=state[ptr+d];v1[i]=velocity[ptr+d]*dt;steady=steady&&x0[i]===x1[i]&&v0[i]===v1[i]&&v0[i]===0.0;}if(steady){for(var i=0;i<d;++i){result[i]=x0[i];}}else{cubicHermite(x0,v0,x1,v1,(t-t0)/dt,result);}}var lo=bounds[0];var hi=bounds[1];for(var i=0;i<d;++i){result[i]=clamp(lo[i],hi[i],result[i]);}return result;};proto.dcurve=function(t){var time=this._time;var n=time.length;var idx=bsearch.le(time,t);var result=this._scratch[0];var state=this._state;var velocity=this._velocity;var d=this.dimension;if(idx>=n-1){var ptr=state.length-1;var tf=t-time[n-1];for(var i=0;i<d;++i,--ptr){result[i]=velocity[ptr];}}else{var ptr=d*(idx+1)-1;var t0=time[idx];var t1=time[idx+1];var dt=t1-t0||1.0;var x0=this._scratch[1];var x1=this._scratch[2];var v0=this._scratch[3];var v1=this._scratch[4];var steady=true;for(var i=0;i<d;++i,--ptr){x0[i]=state[ptr];v0[i]=velocity[ptr]*dt;x1[i]=state[ptr+d];v1[i]=velocity[ptr+d]*dt;steady=steady&&x0[i]===x1[i]&&v0[i]===v1[i]&&v0[i]===0.0;}if(steady){for(var i=0;i<d;++i){result[i]=0.0;}}else{cubicHermite.derivative(x0,v0,x1,v1,(t-t0)/dt,result);for(var i=0;i<d;++i){result[i]/=dt;}}}return result;};proto.lastT=function(){var time=this._time;return time[time.length-1];};proto.stable=function(){var velocity=this._velocity;var ptr=velocity.length;for(var i=this.dimension-1;i>=0;--i){if(velocity[--ptr]){return false;}}return true;};proto.jump=function(t){var t0=this.lastT();var d=this.dimension;if(t<t0||arguments.length!==d+1){return;}var state=this._state;var velocity=this._velocity;var ptr=state.length-this.dimension;var bounds=this.bounds;var lo=bounds[0];var hi=bounds[1];this._time.push(t0,t);for(var j=0;j<2;++j){for(var i=0;i<d;++i){state.push(state[ptr++]);velocity.push(0);}}this._time.push(t);for(var i=d;i>0;--i){state.push(clamp(lo[i-1],hi[i-1],arguments[i]));velocity.push(0);}};proto.push=function(t){var t0=this.lastT();var d=this.dimension;if(t<t0||arguments.length!==d+1){return;}var state=this._state;var velocity=this._velocity;var ptr=state.length-this.dimension;var dt=t-t0;var bounds=this.bounds;var lo=bounds[0];var hi=bounds[1];var sf=dt>1e-6?1/dt:0;this._time.push(t);for(var i=d;i>0;--i){var xc=clamp(lo[i-1],hi[i-1],arguments[i]);state.push(xc);velocity.push((xc-state[ptr++])*sf);}};proto.set=function(t){var d=this.dimension;if(t<this.lastT()||arguments.length!==d+1){return;}var state=this._state;var velocity=this._velocity;var bounds=this.bounds;var lo=bounds[0];var hi=bounds[1];this._time.push(t);for(var i=d;i>0;--i){state.push(clamp(lo[i-1],hi[i-1],arguments[i]));velocity.push(0);}};proto.move=function(t){var t0=this.lastT();var d=this.dimension;if(t<=t0||arguments.length!==d+1){return;}var state=this._state;var velocity=this._velocity;var statePtr=state.length-this.dimension;var bounds=this.bounds;var lo=bounds[0];var hi=bounds[1];var dt=t-t0;var sf=dt>1e-6?1/dt:0.0;this._time.push(t);for(var i=d;i>0;--i){var dx=arguments[i];state.push(clamp(lo[i-1],hi[i-1],state[statePtr++]+dx));velocity.push(dx*sf);}};proto.idle=function(t){var t0=this.lastT();if(t<t0){return;}var d=this.dimension;var state=this._state;var velocity=this._velocity;var statePtr=state.length-d;var bounds=this.bounds;var lo=bounds[0];var hi=bounds[1];var dt=t-t0;this._time.push(t);for(var i=d-1;i>=0;--i){state.push(clamp(lo[i],hi[i],state[statePtr]+dt*velocity[statePtr]));velocity.push(0);statePtr+=1;}};function getZero(d){var result=new Array(d);for(var i=0;i<d;++i){result[i]=0.0;}return result;}function createFilteredVector(initState,initVelocity,initTime){switch(arguments.length){case 0:return new FilteredVector([0],[0],0);case 1:if(typeof initState==='number'){var zero=getZero(initState);return new FilteredVector(zero,zero,0);}else{return new FilteredVector(initState,getZero(initState.length),0);}case 2:if(typeof initVelocity==='number'){var zero=getZero(initState.length);return new FilteredVector(initState,zero,+initVelocity);}else{initTime=0;}case 3:if(initState.length!==initVelocity.length){throw new Error('state and velocity lengths must match');}return new FilteredVector(initState,initVelocity,initTime);}}/***/},/***/7080:/***/function(module){"use strict";module.exports=createRBTree;var RED=0;var BLACK=1;function RBNode(color,key,value,left,right,count){this._color=color;this.key=key;this.value=value;this.left=left;this.right=right;this._count=count;}function cloneNode(node){return new RBNode(node._color,node.key,node.value,node.left,node.right,node._count);}function repaint(color,node){return new RBNode(color,node.key,node.value,node.left,node.right,node._count);}function recount(node){node._count=1+(node.left?node.left._count:0)+(node.right?node.right._count:0);}function RedBlackTree(compare,root){this._compare=compare;this.root=root;}var proto=RedBlackTree.prototype;Object.defineProperty(proto,"keys",{get:function(){var result=[];this.forEach(function(k,v){result.push(k);});return result;}});Object.defineProperty(proto,"values",{get:function(){var result=[];this.forEach(function(k,v){result.push(v);});return result;}});//Returns the number of nodes in the tree
Object.defineProperty(proto,"length",{get:function(){if(this.root){return this.root._count;}return 0;}});//Insert a new item into the tree
proto.insert=function(key,value){var cmp=this._compare;//Find point to insert new node at
var n=this.root;var n_stack=[];var d_stack=[];while(n){var d=cmp(key,n.key);n_stack.push(n);d_stack.push(d);if(d<=0){n=n.left;}else{n=n.right;}}//Rebuild path to leaf node
n_stack.push(new RBNode(RED,key,value,null,null,1));for(var s=n_stack.length-2;s>=0;--s){var n=n_stack[s];if(d_stack[s]<=0){n_stack[s]=new RBNode(n._color,n.key,n.value,n_stack[s+1],n.right,n._count+1);}else{n_stack[s]=new RBNode(n._color,n.key,n.value,n.left,n_stack[s+1],n._count+1);}}//Rebalance tree using rotations
//console.log("start insert", key, d_stack)
for(var s=n_stack.length-1;s>1;--s){var p=n_stack[s-1];var n=n_stack[s];if(p._color===BLACK||n._color===BLACK){break;}var pp=n_stack[s-2];if(pp.left===p){if(p.left===n){var y=pp.right;if(y&&y._color===RED){//console.log("LLr")
p._color=BLACK;pp.right=repaint(BLACK,y);pp._color=RED;s-=1;}else{//console.log("LLb")
pp._color=RED;pp.left=p.right;p._color=BLACK;p.right=pp;n_stack[s-2]=p;n_stack[s-1]=n;recount(pp);recount(p);if(s>=3){var ppp=n_stack[s-3];if(ppp.left===pp){ppp.left=p;}else{ppp.right=p;}}break;}}else{var y=pp.right;if(y&&y._color===RED){//console.log("LRr")
p._color=BLACK;pp.right=repaint(BLACK,y);pp._color=RED;s-=1;}else{//console.log("LRb")
p.right=n.left;pp._color=RED;pp.left=n.right;n._color=BLACK;n.left=p;n.right=pp;n_stack[s-2]=n;n_stack[s-1]=p;recount(pp);recount(p);recount(n);if(s>=3){var ppp=n_stack[s-3];if(ppp.left===pp){ppp.left=n;}else{ppp.right=n;}}break;}}}else{if(p.right===n){var y=pp.left;if(y&&y._color===RED){//console.log("RRr", y.key)
p._color=BLACK;pp.left=repaint(BLACK,y);pp._color=RED;s-=1;}else{//console.log("RRb")
pp._color=RED;pp.right=p.left;p._color=BLACK;p.left=pp;n_stack[s-2]=p;n_stack[s-1]=n;recount(pp);recount(p);if(s>=3){var ppp=n_stack[s-3];if(ppp.right===pp){ppp.right=p;}else{ppp.left=p;}}break;}}else{var y=pp.left;if(y&&y._color===RED){//console.log("RLr")
p._color=BLACK;pp.left=repaint(BLACK,y);pp._color=RED;s-=1;}else{//console.log("RLb")
p.left=n.right;pp._color=RED;pp.right=n.left;n._color=BLACK;n.right=p;n.left=pp;n_stack[s-2]=n;n_stack[s-1]=p;recount(pp);recount(p);recount(n);if(s>=3){var ppp=n_stack[s-3];if(ppp.right===pp){ppp.right=n;}else{ppp.left=n;}}break;}}}}//Return new tree
n_stack[0]._color=BLACK;return new RedBlackTree(cmp,n_stack[0]);};//Visit all nodes inorder
function doVisitFull(visit,node){if(node.left){var v=doVisitFull(visit,node.left);if(v){return v;}}var v=visit(node.key,node.value);if(v){return v;}if(node.right){return doVisitFull(visit,node.right);}}//Visit half nodes in order
function doVisitHalf(lo,compare,visit,node){var l=compare(lo,node.key);if(l<=0){if(node.left){var v=doVisitHalf(lo,compare,visit,node.left);if(v){return v;}}var v=visit(node.key,node.value);if(v){return v;}}if(node.right){return doVisitHalf(lo,compare,visit,node.right);}}//Visit all nodes within a range
function doVisit(lo,hi,compare,visit,node){var l=compare(lo,node.key);var h=compare(hi,node.key);var v;if(l<=0){if(node.left){v=doVisit(lo,hi,compare,visit,node.left);if(v){return v;}}if(h>0){v=visit(node.key,node.value);if(v){return v;}}}if(h>0&&node.right){return doVisit(lo,hi,compare,visit,node.right);}}proto.forEach=function rbTreeForEach(visit,lo,hi){if(!this.root){return;}switch(arguments.length){case 1:return doVisitFull(visit,this.root);break;case 2:return doVisitHalf(lo,this._compare,visit,this.root);break;case 3:if(this._compare(lo,hi)>=0){return;}return doVisit(lo,hi,this._compare,visit,this.root);break;}};//First item in list
Object.defineProperty(proto,"begin",{get:function(){var stack=[];var n=this.root;while(n){stack.push(n);n=n.left;}return new RedBlackTreeIterator(this,stack);}});//Last item in list
Object.defineProperty(proto,"end",{get:function(){var stack=[];var n=this.root;while(n){stack.push(n);n=n.right;}return new RedBlackTreeIterator(this,stack);}});//Find the ith item in the tree
proto.at=function(idx){if(idx<0){return new RedBlackTreeIterator(this,[]);}var n=this.root;var stack=[];while(true){stack.push(n);if(n.left){if(idx<n.left._count){n=n.left;continue;}idx-=n.left._count;}if(!idx){return new RedBlackTreeIterator(this,stack);}idx-=1;if(n.right){if(idx>=n.right._count){break;}n=n.right;}else{break;}}return new RedBlackTreeIterator(this,[]);};proto.ge=function(key){var cmp=this._compare;var n=this.root;var stack=[];var last_ptr=0;while(n){var d=cmp(key,n.key);stack.push(n);if(d<=0){last_ptr=stack.length;}if(d<=0){n=n.left;}else{n=n.right;}}stack.length=last_ptr;return new RedBlackTreeIterator(this,stack);};proto.gt=function(key){var cmp=this._compare;var n=this.root;var stack=[];var last_ptr=0;while(n){var d=cmp(key,n.key);stack.push(n);if(d<0){last_ptr=stack.length;}if(d<0){n=n.left;}else{n=n.right;}}stack.length=last_ptr;return new RedBlackTreeIterator(this,stack);};proto.lt=function(key){var cmp=this._compare;var n=this.root;var stack=[];var last_ptr=0;while(n){var d=cmp(key,n.key);stack.push(n);if(d>0){last_ptr=stack.length;}if(d<=0){n=n.left;}else{n=n.right;}}stack.length=last_ptr;return new RedBlackTreeIterator(this,stack);};proto.le=function(key){var cmp=this._compare;var n=this.root;var stack=[];var last_ptr=0;while(n){var d=cmp(key,n.key);stack.push(n);if(d>=0){last_ptr=stack.length;}if(d<0){n=n.left;}else{n=n.right;}}stack.length=last_ptr;return new RedBlackTreeIterator(this,stack);};//Finds the item with key if it exists
proto.find=function(key){var cmp=this._compare;var n=this.root;var stack=[];while(n){var d=cmp(key,n.key);stack.push(n);if(d===0){return new RedBlackTreeIterator(this,stack);}if(d<=0){n=n.left;}else{n=n.right;}}return new RedBlackTreeIterator(this,[]);};//Removes item with key from tree
proto.remove=function(key){var iter=this.find(key);if(iter){return iter.remove();}return this;};//Returns the item at `key`
proto.get=function(key){var cmp=this._compare;var n=this.root;while(n){var d=cmp(key,n.key);if(d===0){return n.value;}if(d<=0){n=n.left;}else{n=n.right;}}return;};//Iterator for red black tree
function RedBlackTreeIterator(tree,stack){this.tree=tree;this._stack=stack;}var iproto=RedBlackTreeIterator.prototype;//Test if iterator is valid
Object.defineProperty(iproto,"valid",{get:function(){return this._stack.length>0;}});//Node of the iterator
Object.defineProperty(iproto,"node",{get:function(){if(this._stack.length>0){return this._stack[this._stack.length-1];}return null;},enumerable:true});//Makes a copy of an iterator
iproto.clone=function(){return new RedBlackTreeIterator(this.tree,this._stack.slice());};//Swaps two nodes
function swapNode(n,v){n.key=v.key;n.value=v.value;n.left=v.left;n.right=v.right;n._color=v._color;n._count=v._count;}//Fix up a double black node in a tree
function fixDoubleBlack(stack){var n,p,s,z;for(var i=stack.length-1;i>=0;--i){n=stack[i];if(i===0){n._color=BLACK;return;}//console.log("visit node:", n.key, i, stack[i].key, stack[i-1].key)
p=stack[i-1];if(p.left===n){//console.log("left child")
s=p.right;if(s.right&&s.right._color===RED){//console.log("case 1: right sibling child red")
s=p.right=cloneNode(s);z=s.right=cloneNode(s.right);p.right=s.left;s.left=p;s.right=z;s._color=p._color;n._color=BLACK;p._color=BLACK;z._color=BLACK;recount(p);recount(s);if(i>1){var pp=stack[i-2];if(pp.left===p){pp.left=s;}else{pp.right=s;}}stack[i-1]=s;return;}else if(s.left&&s.left._color===RED){//console.log("case 1: left sibling child red")
s=p.right=cloneNode(s);z=s.left=cloneNode(s.left);p.right=z.left;s.left=z.right;z.left=p;z.right=s;z._color=p._color;p._color=BLACK;s._color=BLACK;n._color=BLACK;recount(p);recount(s);recount(z);if(i>1){var pp=stack[i-2];if(pp.left===p){pp.left=z;}else{pp.right=z;}}stack[i-1]=z;return;}if(s._color===BLACK){if(p._color===RED){//console.log("case 2: black sibling, red parent", p.right.value)
p._color=BLACK;p.right=repaint(RED,s);return;}else{//console.log("case 2: black sibling, black parent", p.right.value)
p.right=repaint(RED,s);continue;}}else{//console.log("case 3: red sibling")
s=cloneNode(s);p.right=s.left;s.left=p;s._color=p._color;p._color=RED;recount(p);recount(s);if(i>1){var pp=stack[i-2];if(pp.left===p){pp.left=s;}else{pp.right=s;}}stack[i-1]=s;stack[i]=p;if(i+1<stack.length){stack[i+1]=n;}else{stack.push(n);}i=i+2;}}else{//console.log("right child")
s=p.left;if(s.left&&s.left._color===RED){//console.log("case 1: left sibling child red", p.value, p._color)
s=p.left=cloneNode(s);z=s.left=cloneNode(s.left);p.left=s.right;s.right=p;s.left=z;s._color=p._color;n._color=BLACK;p._color=BLACK;z._color=BLACK;recount(p);recount(s);if(i>1){var pp=stack[i-2];if(pp.right===p){pp.right=s;}else{pp.left=s;}}stack[i-1]=s;return;}else if(s.right&&s.right._color===RED){//console.log("case 1: right sibling child red")
s=p.left=cloneNode(s);z=s.right=cloneNode(s.right);p.left=z.right;s.right=z.left;z.right=p;z.left=s;z._color=p._color;p._color=BLACK;s._color=BLACK;n._color=BLACK;recount(p);recount(s);recount(z);if(i>1){var pp=stack[i-2];if(pp.right===p){pp.right=z;}else{pp.left=z;}}stack[i-1]=z;return;}if(s._color===BLACK){if(p._color===RED){//console.log("case 2: black sibling, red parent")
p._color=BLACK;p.left=repaint(RED,s);return;}else{//console.log("case 2: black sibling, black parent")
p.left=repaint(RED,s);continue;}}else{//console.log("case 3: red sibling")
s=cloneNode(s);p.left=s.right;s.right=p;s._color=p._color;p._color=RED;recount(p);recount(s);if(i>1){var pp=stack[i-2];if(pp.right===p){pp.right=s;}else{pp.left=s;}}stack[i-1]=s;stack[i]=p;if(i+1<stack.length){stack[i+1]=n;}else{stack.push(n);}i=i+2;}}}}//Removes item at iterator from tree
iproto.remove=function(){var stack=this._stack;if(stack.length===0){return this.tree;}//First copy path to node
var cstack=new Array(stack.length);var n=stack[stack.length-1];cstack[cstack.length-1]=new RBNode(n._color,n.key,n.value,n.left,n.right,n._count);for(var i=stack.length-2;i>=0;--i){var n=stack[i];if(n.left===stack[i+1]){cstack[i]=new RBNode(n._color,n.key,n.value,cstack[i+1],n.right,n._count);}else{cstack[i]=new RBNode(n._color,n.key,n.value,n.left,cstack[i+1],n._count);}}//Get node
n=cstack[cstack.length-1];//console.log("start remove: ", n.value)
//If not leaf, then swap with previous node
if(n.left&&n.right){//console.log("moving to leaf")
//First walk to previous leaf
var split=cstack.length;n=n.left;while(n.right){cstack.push(n);n=n.right;}//Copy path to leaf
var v=cstack[split-1];cstack.push(new RBNode(n._color,v.key,v.value,n.left,n.right,n._count));cstack[split-1].key=n.key;cstack[split-1].value=n.value;//Fix up stack
for(var i=cstack.length-2;i>=split;--i){n=cstack[i];cstack[i]=new RBNode(n._color,n.key,n.value,n.left,cstack[i+1],n._count);}cstack[split-1].left=cstack[split];}//console.log("stack=", cstack.map(function(v) { return v.value }))
//Remove leaf node
n=cstack[cstack.length-1];if(n._color===RED){//Easy case: removing red leaf
//console.log("RED leaf")
var p=cstack[cstack.length-2];if(p.left===n){p.left=null;}else if(p.right===n){p.right=null;}cstack.pop();for(var i=0;i<cstack.length;++i){cstack[i]._count--;}return new RedBlackTree(this.tree._compare,cstack[0]);}else{if(n.left||n.right){//Second easy case:  Single child black parent
//console.log("BLACK single child")
if(n.left){swapNode(n,n.left);}else if(n.right){swapNode(n,n.right);}//Child must be red, so repaint it black to balance color
n._color=BLACK;for(var i=0;i<cstack.length-1;++i){cstack[i]._count--;}return new RedBlackTree(this.tree._compare,cstack[0]);}else if(cstack.length===1){//Third easy case: root
//console.log("ROOT")
return new RedBlackTree(this.tree._compare,null);}else{//Hard case: Repaint n, and then do some nasty stuff
//console.log("BLACK leaf no children")
for(var i=0;i<cstack.length;++i){cstack[i]._count--;}var parent=cstack[cstack.length-2];fixDoubleBlack(cstack);//Fix up links
if(parent.left===n){parent.left=null;}else{parent.right=null;}}}return new RedBlackTree(this.tree._compare,cstack[0]);};//Returns key
Object.defineProperty(iproto,"key",{get:function(){if(this._stack.length>0){return this._stack[this._stack.length-1].key;}return;},enumerable:true});//Returns value
Object.defineProperty(iproto,"value",{get:function(){if(this._stack.length>0){return this._stack[this._stack.length-1].value;}return;},enumerable:true});//Returns the position of this iterator in the sorted list
Object.defineProperty(iproto,"index",{get:function(){var idx=0;var stack=this._stack;if(stack.length===0){var r=this.tree.root;if(r){return r._count;}return 0;}else if(stack[stack.length-1].left){idx=stack[stack.length-1].left._count;}for(var s=stack.length-2;s>=0;--s){if(stack[s+1]===stack[s].right){++idx;if(stack[s].left){idx+=stack[s].left._count;}}}return idx;},enumerable:true});//Advances iterator to next element in list
iproto.next=function(){var stack=this._stack;if(stack.length===0){return;}var n=stack[stack.length-1];if(n.right){n=n.right;while(n){stack.push(n);n=n.left;}}else{stack.pop();while(stack.length>0&&stack[stack.length-1].right===n){n=stack[stack.length-1];stack.pop();}}};//Checks if iterator is at end of tree
Object.defineProperty(iproto,"hasNext",{get:function(){var stack=this._stack;if(stack.length===0){return false;}if(stack[stack.length-1].right){return true;}for(var s=stack.length-1;s>0;--s){if(stack[s-1].left===stack[s]){return true;}}return false;}});//Update value
iproto.update=function(value){var stack=this._stack;if(stack.length===0){throw new Error("Can't update empty node!");}var cstack=new Array(stack.length);var n=stack[stack.length-1];cstack[cstack.length-1]=new RBNode(n._color,n.key,value,n.left,n.right,n._count);for(var i=stack.length-2;i>=0;--i){n=stack[i];if(n.left===stack[i+1]){cstack[i]=new RBNode(n._color,n.key,n.value,cstack[i+1],n.right,n._count);}else{cstack[i]=new RBNode(n._color,n.key,n.value,n.left,cstack[i+1],n._count);}}return new RedBlackTree(this.tree._compare,cstack[0]);};//Moves iterator backward one element
iproto.prev=function(){var stack=this._stack;if(stack.length===0){return;}var n=stack[stack.length-1];if(n.left){n=n.left;while(n){stack.push(n);n=n.right;}}else{stack.pop();while(stack.length>0&&stack[stack.length-1].left===n){n=stack[stack.length-1];stack.pop();}}};//Checks if iterator is at start of tree
Object.defineProperty(iproto,"hasPrev",{get:function(){var stack=this._stack;if(stack.length===0){return false;}if(stack[stack.length-1].left){return true;}for(var s=stack.length-1;s>0;--s){if(stack[s-1].right===stack[s]){return true;}}return false;}});//Default comparison function
function defaultCompare(a,b){if(a<b){return-1;}if(a>b){return 1;}return 0;}//Build a tree
function createRBTree(compare){return new RedBlackTree(compare||defaultCompare,null);}/***/},/***/7453:/***/function(module,__unused_webpack_exports,__nested_webpack_require_236846__){"use strict";module.exports=createAxes;var createText=__nested_webpack_require_236846__(9557);var createLines=__nested_webpack_require_236846__(1681);var createBackground=__nested_webpack_require_236846__(1011);var getCubeProperties=__nested_webpack_require_236846__(2864);var Ticks=__nested_webpack_require_236846__(8468);var identity=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);function copyVec3(a,b){a[0]=b[0];a[1]=b[1];a[2]=b[2];return a;}function Axes(gl){this.gl=gl;this.pixelRatio=1;this.bounds=[[-10,-10,-10],[10,10,10]];this.ticks=[[],[],[]];this.autoTicks=true;this.tickSpacing=[1,1,1];this.tickEnable=[true,true,true];this.tickFont=['sans-serif','sans-serif','sans-serif'];this.tickSize=[12,12,12];this.tickAngle=[0,0,0];this.tickAlign=['auto','auto','auto'];this.tickColor=[[0,0,0,1],[0,0,0,1],[0,0,0,1]];this.tickPad=[10,10,10];this.lastCubeProps={cubeEdges:[0,0,0],axis:[0,0,0]};this.labels=['x','y','z'];this.labelEnable=[true,true,true];this.labelFont='sans-serif';this.labelSize=[20,20,20];this.labelAngle=[0,0,0];this.labelAlign=['auto','auto','auto'];this.labelColor=[[0,0,0,1],[0,0,0,1],[0,0,0,1]];this.labelPad=[10,10,10];this.lineEnable=[true,true,true];this.lineMirror=[false,false,false];this.lineWidth=[1,1,1];this.lineColor=[[0,0,0,1],[0,0,0,1],[0,0,0,1]];this.lineTickEnable=[true,true,true];this.lineTickMirror=[false,false,false];this.lineTickLength=[0,0,0];this.lineTickWidth=[1,1,1];this.lineTickColor=[[0,0,0,1],[0,0,0,1],[0,0,0,1]];this.gridEnable=[true,true,true];this.gridWidth=[1,1,1];this.gridColor=[[0,0,0,1],[0,0,0,1],[0,0,0,1]];this.zeroEnable=[true,true,true];this.zeroLineColor=[[0,0,0,1],[0,0,0,1],[0,0,0,1]];this.zeroLineWidth=[2,2,2];this.backgroundEnable=[false,false,false];this.backgroundColor=[[0.8,0.8,0.8,0.5],[0.8,0.8,0.8,0.5],[0.8,0.8,0.8,0.5]];this._firstInit=true;this._text=null;this._lines=null;this._background=createBackground(gl);}var proto=Axes.prototype;proto.update=function(options){options=options||{};//Option parsing helper functions
function parseOption(nest,cons,name){if(name in options){var opt=options[name];var prev=this[name];var next;if(nest?Array.isArray(opt)&&Array.isArray(opt[0]):Array.isArray(opt)){this[name]=next=[cons(opt[0]),cons(opt[1]),cons(opt[2])];}else{this[name]=next=[cons(opt),cons(opt),cons(opt)];}for(var i=0;i<3;++i){if(next[i]!==prev[i]){return true;}}}return false;}var NUMBER=parseOption.bind(this,false,Number);var BOOLEAN=parseOption.bind(this,false,Boolean);var STRING=parseOption.bind(this,false,String);var COLOR=parseOption.bind(this,true,function(v){if(Array.isArray(v)){if(v.length===3){return[+v[0],+v[1],+v[2],1.0];}else if(v.length===4){return[+v[0],+v[1],+v[2],+v[3]];}}return[0,0,0,1];});//Tick marks and bounds
var nextTicks;var ticksUpdate=false;var boundsChanged=false;if('bounds'in options){var bounds=options.bounds;i_loop:for(var i=0;i<2;++i){for(var j=0;j<3;++j){if(bounds[i][j]!==this.bounds[i][j]){boundsChanged=true;}this.bounds[i][j]=bounds[i][j];}}}if('ticks'in options){nextTicks=options.ticks;ticksUpdate=true;this.autoTicks=false;for(var i=0;i<3;++i){this.tickSpacing[i]=0.0;}}else if(NUMBER('tickSpacing')){this.autoTicks=true;boundsChanged=true;}if(this._firstInit){if(!('ticks'in options||'tickSpacing'in options)){this.autoTicks=true;}//Force tick recomputation on first update
boundsChanged=true;ticksUpdate=true;this._firstInit=false;}if(boundsChanged&&this.autoTicks){nextTicks=Ticks.create(this.bounds,this.tickSpacing);ticksUpdate=true;}//Compare next ticks to previous ticks, only update if needed
if(ticksUpdate){for(var i=0;i<3;++i){nextTicks[i].sort(function(a,b){return a.x-b.x;});}if(Ticks.equal(nextTicks,this.ticks)){ticksUpdate=false;}else{this.ticks=nextTicks;}}//Parse tick properties
BOOLEAN('tickEnable');if(STRING('tickFont')){ticksUpdate=true;//If font changes, must rebuild vbo
}NUMBER('tickSize');NUMBER('tickAngle');NUMBER('tickPad');COLOR('tickColor');//Axis labels
var labelUpdate=STRING('labels');if(STRING('labelFont')){labelUpdate=true;}BOOLEAN('labelEnable');NUMBER('labelSize');NUMBER('labelPad');COLOR('labelColor');//Axis lines
BOOLEAN('lineEnable');BOOLEAN('lineMirror');NUMBER('lineWidth');COLOR('lineColor');//Axis line ticks
BOOLEAN('lineTickEnable');BOOLEAN('lineTickMirror');NUMBER('lineTickLength');NUMBER('lineTickWidth');COLOR('lineTickColor');//Grid lines
BOOLEAN('gridEnable');NUMBER('gridWidth');COLOR('gridColor');//Zero line
BOOLEAN('zeroEnable');COLOR('zeroLineColor');NUMBER('zeroLineWidth');//Background
BOOLEAN('backgroundEnable');COLOR('backgroundColor');//Update text if necessary
if(!this._text){this._text=createText(this.gl,this.bounds,this.labels,this.labelFont,this.ticks,this.tickFont);}else if(this._text&&(labelUpdate||ticksUpdate)){this._text.update(this.bounds,this.labels,this.labelFont,this.ticks,this.tickFont);}//Update lines if necessary
if(this._lines&&ticksUpdate){this._lines.dispose();this._lines=null;}if(!this._lines){this._lines=createLines(this.gl,this.bounds,this.ticks);}};function OffsetInfo(){this.primalOffset=[0,0,0];this.primalMinor=[0,0,0];this.mirrorOffset=[0,0,0];this.mirrorMinor=[0,0,0];}var LINE_OFFSET=[new OffsetInfo(),new OffsetInfo(),new OffsetInfo()];function computeLineOffset(result,i,bounds,cubeEdges,cubeAxis){var primalOffset=result.primalOffset;var primalMinor=result.primalMinor;var dualOffset=result.mirrorOffset;var dualMinor=result.mirrorMinor;var e=cubeEdges[i];//Calculate offsets
for(var j=0;j<3;++j){if(i===j){continue;}var a=primalOffset,b=dualOffset,c=primalMinor,d=dualMinor;if(e&1<<j){a=dualOffset;b=primalOffset;c=dualMinor;d=primalMinor;}a[j]=bounds[0][j];b[j]=bounds[1][j];if(cubeAxis[j]>0){c[j]=-1;d[j]=0;}else{c[j]=0;d[j]=+1;}}}var CUBE_ENABLE=[0,0,0];var DEFAULT_PARAMS={model:identity,view:identity,projection:identity,_ortho:false};proto.isOpaque=function(){return true;};proto.isTransparent=function(){return false;};proto.drawTransparent=function(params){};var ALIGN_OPTION_AUTO=0;// i.e. as defined in the shader the text would rotate to stay upwards range: [-90,90]
var PRIMAL_MINOR=[0,0,0];var MIRROR_MINOR=[0,0,0];var PRIMAL_OFFSET=[0,0,0];proto.draw=function(params){params=params||DEFAULT_PARAMS;var gl=this.gl;//Geometry for camera and axes
var model=params.model||identity;var view=params.view||identity;var projection=params.projection||identity;var bounds=this.bounds;var isOrtho=params._ortho||false;//Unpack axis info
var cubeParams=getCubeProperties(model,view,projection,bounds,isOrtho);var cubeEdges=cubeParams.cubeEdges;var cubeAxis=cubeParams.axis;var cx=view[12];var cy=view[13];var cz=view[14];var cw=view[15];var orthoFix=isOrtho?2:1;// double up padding for orthographic ticks & labels
var pixelScaleF=orthoFix*this.pixelRatio*(projection[3]*cx+projection[7]*cy+projection[11]*cz+projection[15]*cw)/gl.drawingBufferHeight;for(var i=0;i<3;++i){this.lastCubeProps.cubeEdges[i]=cubeEdges[i];this.lastCubeProps.axis[i]=cubeAxis[i];}//Compute axis info
var lineOffset=LINE_OFFSET;for(var i=0;i<3;++i){computeLineOffset(LINE_OFFSET[i],i,this.bounds,cubeEdges,cubeAxis);}//Set up state parameters
var gl=this.gl;//Draw background first
var cubeEnable=CUBE_ENABLE;for(var i=0;i<3;++i){if(this.backgroundEnable[i]){cubeEnable[i]=cubeAxis[i];}else{cubeEnable[i]=0;}}this._background.draw(model,view,projection,bounds,cubeEnable,this.backgroundColor);//Draw lines
this._lines.bind(model,view,projection,this);//First draw grid lines and zero lines
for(var i=0;i<3;++i){var x=[0,0,0];if(cubeAxis[i]>0){x[i]=bounds[1][i];}else{x[i]=bounds[0][i];}//Draw grid lines
for(var j=0;j<2;++j){var u=(i+1+j)%3;var v=(i+1+(j^1))%3;if(this.gridEnable[u]){this._lines.drawGrid(u,v,this.bounds,x,this.gridColor[u],this.gridWidth[u]*this.pixelRatio);}}//Draw zero lines (need to do this AFTER all grid lines are drawn)
for(var j=0;j<2;++j){var u=(i+1+j)%3;var v=(i+1+(j^1))%3;if(this.zeroEnable[v]){//Check if zero line in bounds
if(Math.min(bounds[0][v],bounds[1][v])<=0&&Math.max(bounds[0][v],bounds[1][v])>=0){this._lines.drawZero(u,v,this.bounds,x,this.zeroLineColor[v],this.zeroLineWidth[v]*this.pixelRatio);}}}}//Then draw axis lines and tick marks
for(var i=0;i<3;++i){//Draw axis lines
if(this.lineEnable[i]){this._lines.drawAxisLine(i,this.bounds,lineOffset[i].primalOffset,this.lineColor[i],this.lineWidth[i]*this.pixelRatio);}if(this.lineMirror[i]){this._lines.drawAxisLine(i,this.bounds,lineOffset[i].mirrorOffset,this.lineColor[i],this.lineWidth[i]*this.pixelRatio);}//Compute minor axes
var primalMinor=copyVec3(PRIMAL_MINOR,lineOffset[i].primalMinor);var mirrorMinor=copyVec3(MIRROR_MINOR,lineOffset[i].mirrorMinor);var tickLength=this.lineTickLength;for(var j=0;j<3;++j){var scaleFactor=pixelScaleF/model[5*j];primalMinor[j]*=tickLength[j]*scaleFactor;mirrorMinor[j]*=tickLength[j]*scaleFactor;}//Draw axis line ticks
if(this.lineTickEnable[i]){this._lines.drawAxisTicks(i,lineOffset[i].primalOffset,primalMinor,this.lineTickColor[i],this.lineTickWidth[i]*this.pixelRatio);}if(this.lineTickMirror[i]){this._lines.drawAxisTicks(i,lineOffset[i].mirrorOffset,mirrorMinor,this.lineTickColor[i],this.lineTickWidth[i]*this.pixelRatio);}}this._lines.unbind();//Draw text sprites
this._text.bind(model,view,projection,this.pixelRatio);var alignOpt;// options in shader are from this list {-1, 0, 1, 2, 3, ..., n}
// -1: backward compatible
//  0: raw data
//  1: auto align, free angles
//  2: auto align, horizontal or vertical
//3-n: auto align, round to n directions e.g. 12 -> round to angles with 30-degree steps
var hv_ratio=0.5;// can have an effect on the ratio between horizontals and verticals when using option 2
var enableAlign;var alignDir;function alignTo(i){alignDir=[0,0,0];alignDir[i]=1;}function solveTickAlignments(i,minor,major){var i1=(i+1)%3;var i2=(i+2)%3;var A=minor[i1];var B=minor[i2];var C=major[i1];var D=major[i2];if(A>0&&D>0){alignTo(i1);return;}else if(A>0&&D<0){alignTo(i1);return;}else if(A<0&&D>0){alignTo(i1);return;}else if(A<0&&D<0){alignTo(i1);return;}else if(B>0&&C>0){alignTo(i2);return;}else if(B>0&&C<0){alignTo(i2);return;}else if(B<0&&C>0){alignTo(i2);return;}else if(B<0&&C<0){alignTo(i2);return;}}for(var i=0;i<3;++i){var minor=lineOffset[i].primalMinor;var major=lineOffset[i].mirrorMinor;var offset=copyVec3(PRIMAL_OFFSET,lineOffset[i].primalOffset);for(var j=0;j<3;++j){if(this.lineTickEnable[i]){offset[j]+=pixelScaleF*minor[j]*Math.max(this.lineTickLength[j],0)/model[5*j];}}var axis=[0,0,0];axis[i]=1;//Draw tick text
if(this.tickEnable[i]){if(this.tickAngle[i]===-3600){this.tickAngle[i]=0;this.tickAlign[i]='auto';}else{this.tickAlign[i]=-1;}enableAlign=1;alignOpt=[this.tickAlign[i],hv_ratio,enableAlign];if(alignOpt[0]==='auto')alignOpt[0]=ALIGN_OPTION_AUTO;else alignOpt[0]=parseInt(''+alignOpt[0]);alignDir=[0,0,0];solveTickAlignments(i,minor,major);//Add tick padding
for(var j=0;j<3;++j){offset[j]+=pixelScaleF*minor[j]*this.tickPad[j]/model[5*j];}//Draw axis
this._text.drawTicks(i,this.tickSize[i],this.tickAngle[i],offset,this.tickColor[i],axis,alignDir,alignOpt);}//Draw labels
if(this.labelEnable[i]){enableAlign=0;alignDir=[0,0,0];if(this.labels[i].length>4){// for large label axis enable alignDir to axis
alignTo(i);enableAlign=1;}alignOpt=[this.labelAlign[i],hv_ratio,enableAlign];if(alignOpt[0]==='auto')alignOpt[0]=ALIGN_OPTION_AUTO;else alignOpt[0]=parseInt(''+alignOpt[0]);//Add label padding
for(var j=0;j<3;++j){offset[j]+=pixelScaleF*minor[j]*this.labelPad[j]/model[5*j];}offset[i]+=0.5*(bounds[0][i]+bounds[1][i]);//Draw axis
this._text.drawLabel(i,this.labelSize[i],this.labelAngle[i],offset,this.labelColor[i],[0,0,0],alignDir,alignOpt);}}this._text.unbind();};proto.dispose=function(){this._text.dispose();this._lines.dispose();this._background.dispose();this._lines=null;this._text=null;this._background=null;this.gl=null;};function createAxes(gl,options){var axes=new Axes(gl);axes.update(options);return axes;}/***/},/***/1011:/***/function(module,__unused_webpack_exports,__nested_webpack_require_248714__){"use strict";module.exports=createBackgroundCube;var createBuffer=__nested_webpack_require_248714__(5827);var createVAO=__nested_webpack_require_248714__(2944);var createShader=__nested_webpack_require_248714__(1943).bg;function BackgroundCube(gl,buffer,vao,shader){this.gl=gl;this.buffer=buffer;this.vao=vao;this.shader=shader;}var proto=BackgroundCube.prototype;proto.draw=function(model,view,projection,bounds,enable,colors){var needsBG=false;for(var i=0;i<3;++i){needsBG=needsBG||enable[i];}if(!needsBG){return;}var gl=this.gl;gl.enable(gl.POLYGON_OFFSET_FILL);gl.polygonOffset(1,2);this.shader.bind();this.shader.uniforms={model:model,view:view,projection:projection,bounds:bounds,enable:enable,colors:colors};this.vao.bind();this.vao.draw(this.gl.TRIANGLES,36);this.vao.unbind();gl.disable(gl.POLYGON_OFFSET_FILL);};proto.dispose=function(){this.vao.dispose();this.buffer.dispose();this.shader.dispose();};function createBackgroundCube(gl){//Create cube vertices
var vertices=[];var indices=[];var ptr=0;for(var d=0;d<3;++d){var u=(d+1)%3;var v=(d+2)%3;var x=[0,0,0];var c=[0,0,0];for(var s=-1;s<=1;s+=2){indices.push(ptr,ptr+2,ptr+1,ptr+1,ptr+2,ptr+3);x[d]=s;c[d]=s;for(var i=-1;i<=1;i+=2){x[u]=i;for(var j=-1;j<=1;j+=2){x[v]=j;vertices.push(x[0],x[1],x[2],c[0],c[1],c[2]);ptr+=1;}}//Swap u and v
var tt=u;u=v;v=tt;}}//Allocate buffer and vertex array
var buffer=createBuffer(gl,new Float32Array(vertices));var elements=createBuffer(gl,new Uint16Array(indices),gl.ELEMENT_ARRAY_BUFFER);var vao=createVAO(gl,[{buffer:buffer,type:gl.FLOAT,size:3,offset:0,stride:24},{buffer:buffer,type:gl.FLOAT,size:3,offset:12,stride:24}],elements);//Create shader object
var shader=createShader(gl);shader.attributes.position.location=0;shader.attributes.normal.location=1;return new BackgroundCube(gl,buffer,vao,shader);}/***/},/***/2864:/***/function(module,__unused_webpack_exports,__nested_webpack_require_250569__){"use strict";module.exports=getCubeEdges;var bits=__nested_webpack_require_250569__(2288);var multiply=__nested_webpack_require_250569__(104);var splitPoly=__nested_webpack_require_250569__(4670);var orient=__nested_webpack_require_250569__(417);var mvp=new Array(16);var pCubeVerts=new Array(8);var cubeVerts=new Array(8);var x=new Array(3);var zero3=[0,0,0];(function(){for(var i=0;i<8;++i){pCubeVerts[i]=[1,1,1,1];cubeVerts[i]=[1,1,1];}})();function transformHg(result,x,mat){for(var i=0;i<4;++i){result[i]=mat[12+i];for(var j=0;j<3;++j){result[i]+=x[j]*mat[4*j+i];}}}var FRUSTUM_PLANES=[[0,0,1,0,0],[0,0,-1,1,0],[0,-1,0,1,0],[0,1,0,1,0],[-1,0,0,1,0],[1,0,0,1,0]];function polygonArea(p){for(var i=0;i<FRUSTUM_PLANES.length;++i){p=splitPoly.positive(p,FRUSTUM_PLANES[i]);if(p.length<3){return 0;}}var base=p[0];var ax=base[0]/base[3];var ay=base[1]/base[3];var area=0.0;for(var i=1;i+1<p.length;++i){var b=p[i];var c=p[i+1];var bx=b[0]/b[3];var by=b[1]/b[3];var cx=c[0]/c[3];var cy=c[1]/c[3];var ux=bx-ax;var uy=by-ay;var vx=cx-ax;var vy=cy-ay;area+=Math.abs(ux*vy-uy*vx);}return area;}var CUBE_EDGES=[1,1,1];var CUBE_AXIS=[0,0,0];var CUBE_RESULT={cubeEdges:CUBE_EDGES,axis:CUBE_AXIS};function getCubeEdges(model,view,projection,bounds,ortho){//Concatenate matrices
multiply(mvp,view,model);multiply(mvp,projection,mvp);//First project cube vertices
var ptr=0;for(var i=0;i<2;++i){x[2]=bounds[i][2];for(var j=0;j<2;++j){x[1]=bounds[j][1];for(var k=0;k<2;++k){x[0]=bounds[k][0];transformHg(pCubeVerts[ptr],x,mvp);ptr+=1;}}}//Classify camera against cube faces
var closest=-1;for(var i=0;i<8;++i){var w=pCubeVerts[i][3];for(var l=0;l<3;++l){cubeVerts[i][l]=pCubeVerts[i][l]/w;}if(ortho)cubeVerts[i][2]*=-1;if(w<0){if(closest<0){closest=i;}else if(cubeVerts[i][2]<cubeVerts[closest][2]){closest=i;}}}if(closest<0){closest=0;for(var d=0;d<3;++d){var u=(d+2)%3;var v=(d+1)%3;var o0=-1;var o1=-1;for(var s=0;s<2;++s){var f0=s<<d;var f1=f0+(s<<u)+(1-s<<v);var f2=f0+(1-s<<u)+(s<<v);if(orient(cubeVerts[f0],cubeVerts[f1],cubeVerts[f2],zero3)<0){continue;}if(s){o0=1;}else{o1=1;}}if(o0<0||o1<0){if(o1>o0){closest|=1<<d;}continue;}for(var s=0;s<2;++s){var f0=s<<d;var f1=f0+(s<<u)+(1-s<<v);var f2=f0+(1-s<<u)+(s<<v);var o=polygonArea([pCubeVerts[f0],pCubeVerts[f1],pCubeVerts[f2],pCubeVerts[f0+(1<<u)+(1<<v)]]);if(s){o0=o;}else{o1=o;}}if(o1>o0){closest|=1<<d;continue;}}}var farthest=7^closest;//Find lowest vertex which is not closest closest
var bottom=-1;for(var i=0;i<8;++i){if(i===closest||i===farthest){continue;}if(bottom<0){bottom=i;}else if(cubeVerts[bottom][1]>cubeVerts[i][1]){bottom=i;}}//Find left/right neighbors of bottom vertex
var left=-1;for(var i=0;i<3;++i){var idx=bottom^1<<i;if(idx===closest||idx===farthest){continue;}if(left<0){left=idx;}var v=cubeVerts[idx];if(v[0]<cubeVerts[left][0]){left=idx;}}var right=-1;for(var i=0;i<3;++i){var idx=bottom^1<<i;if(idx===closest||idx===farthest||idx===left){continue;}if(right<0){right=idx;}var v=cubeVerts[idx];if(v[0]>cubeVerts[right][0]){right=idx;}}//Determine edge axis coordinates
var cubeEdges=CUBE_EDGES;cubeEdges[0]=cubeEdges[1]=cubeEdges[2]=0;cubeEdges[bits.log2(left^bottom)]=bottom&left;cubeEdges[bits.log2(bottom^right)]=bottom&right;var top=right^7;if(top===closest||top===farthest){top=left^7;cubeEdges[bits.log2(right^top)]=top&right;}else{cubeEdges[bits.log2(left^top)]=top&left;}//Determine visible faces
var axis=CUBE_AXIS;var cutCorner=closest;for(var d=0;d<3;++d){if(cutCorner&1<<d){axis[d]=-1;}else{axis[d]=1;}}//Return result
return CUBE_RESULT;}/***/},/***/1681:/***/function(module,__unused_webpack_exports,__nested_webpack_require_254123__){"use strict";module.exports=createLines;var createBuffer=__nested_webpack_require_254123__(5827);var createVAO=__nested_webpack_require_254123__(2944);var createShader=__nested_webpack_require_254123__(1943)/* .line */.j;var MAJOR_AXIS=[0,0,0];var MINOR_AXIS=[0,0,0];var SCREEN_AXIS=[0,0,0];var OFFSET_VEC=[0,0,0];var SHAPE=[1,1];function zeroVec(a){a[0]=a[1]=a[2]=0;return a;}function copyVec(a,b){a[0]=b[0];a[1]=b[1];a[2]=b[2];return a;}function Lines(gl,vertBuffer,vao,shader,tickCount,tickOffset,gridCount,gridOffset){this.gl=gl;this.vertBuffer=vertBuffer;this.vao=vao;this.shader=shader;this.tickCount=tickCount;this.tickOffset=tickOffset;this.gridCount=gridCount;this.gridOffset=gridOffset;}var proto=Lines.prototype;proto.bind=function(model,view,projection){this.shader.bind();this.shader.uniforms.model=model;this.shader.uniforms.view=view;this.shader.uniforms.projection=projection;SHAPE[0]=this.gl.drawingBufferWidth;SHAPE[1]=this.gl.drawingBufferHeight;this.shader.uniforms.screenShape=SHAPE;this.vao.bind();};proto.unbind=function(){this.vao.unbind();};proto.drawAxisLine=function(j,bounds,offset,color,lineWidth){var minorAxis=zeroVec(MINOR_AXIS);this.shader.uniforms.majorAxis=MINOR_AXIS;minorAxis[j]=bounds[1][j]-bounds[0][j];this.shader.uniforms.minorAxis=minorAxis;var noffset=copyVec(OFFSET_VEC,offset);noffset[j]+=bounds[0][j];this.shader.uniforms.offset=noffset;this.shader.uniforms.lineWidth=lineWidth;this.shader.uniforms.color=color;var screenAxis=zeroVec(SCREEN_AXIS);screenAxis[(j+2)%3]=1;this.shader.uniforms.screenAxis=screenAxis;this.vao.draw(this.gl.TRIANGLES,6);var screenAxis=zeroVec(SCREEN_AXIS);screenAxis[(j+1)%3]=1;this.shader.uniforms.screenAxis=screenAxis;this.vao.draw(this.gl.TRIANGLES,6);};proto.drawAxisTicks=function(j,offset,minorAxis,color,lineWidth){if(!this.tickCount[j]){return;}var majorAxis=zeroVec(MAJOR_AXIS);majorAxis[j]=1;this.shader.uniforms.majorAxis=majorAxis;this.shader.uniforms.offset=offset;this.shader.uniforms.minorAxis=minorAxis;this.shader.uniforms.color=color;this.shader.uniforms.lineWidth=lineWidth;var screenAxis=zeroVec(SCREEN_AXIS);screenAxis[j]=1;this.shader.uniforms.screenAxis=screenAxis;this.vao.draw(this.gl.TRIANGLES,this.tickCount[j],this.tickOffset[j]);};proto.drawGrid=function(i,j,bounds,offset,color,lineWidth){if(!this.gridCount[i]){return;}var minorAxis=zeroVec(MINOR_AXIS);minorAxis[j]=bounds[1][j]-bounds[0][j];this.shader.uniforms.minorAxis=minorAxis;var noffset=copyVec(OFFSET_VEC,offset);noffset[j]+=bounds[0][j];this.shader.uniforms.offset=noffset;var majorAxis=zeroVec(MAJOR_AXIS);majorAxis[i]=1;this.shader.uniforms.majorAxis=majorAxis;var screenAxis=zeroVec(SCREEN_AXIS);screenAxis[i]=1;this.shader.uniforms.screenAxis=screenAxis;this.shader.uniforms.lineWidth=lineWidth;this.shader.uniforms.color=color;this.vao.draw(this.gl.TRIANGLES,this.gridCount[i],this.gridOffset[i]);};proto.drawZero=function(j,i,bounds,offset,color,lineWidth){var minorAxis=zeroVec(MINOR_AXIS);this.shader.uniforms.majorAxis=minorAxis;minorAxis[j]=bounds[1][j]-bounds[0][j];this.shader.uniforms.minorAxis=minorAxis;var noffset=copyVec(OFFSET_VEC,offset);noffset[j]+=bounds[0][j];this.shader.uniforms.offset=noffset;var screenAxis=zeroVec(SCREEN_AXIS);screenAxis[i]=1;this.shader.uniforms.screenAxis=screenAxis;this.shader.uniforms.lineWidth=lineWidth;this.shader.uniforms.color=color;this.vao.draw(this.gl.TRIANGLES,6);};proto.dispose=function(){this.vao.dispose();this.vertBuffer.dispose();this.shader.dispose();};function createLines(gl,bounds,ticks){var vertices=[];var tickOffset=[0,0,0];var tickCount=[0,0,0];//Create grid lines for each axis/direction
var gridOffset=[0,0,0];var gridCount=[0,0,0];//Add zero line
vertices.push(0,0,1,0,1,1,0,0,-1,0,0,-1,0,1,1,0,1,-1);for(var i=0;i<3;++i){//Axis tick marks
var start=vertices.length/3|0;for(var j=0;j<ticks[i].length;++j){var x=+ticks[i][j].x;vertices.push(x,0,1,x,1,1,x,0,-1,x,0,-1,x,1,1,x,1,-1);}var end=vertices.length/3|0;tickOffset[i]=start;tickCount[i]=end-start;//Grid lines
var start=vertices.length/3|0;for(var k=0;k<ticks[i].length;++k){var x=+ticks[i][k].x;vertices.push(x,0,1,x,1,1,x,0,-1,x,0,-1,x,1,1,x,1,-1);}var end=vertices.length/3|0;gridOffset[i]=start;gridCount[i]=end-start;}//Create cube VAO
var vertBuf=createBuffer(gl,new Float32Array(vertices));var vao=createVAO(gl,[{"buffer":vertBuf,"type":gl.FLOAT,"size":3,"stride":0,"offset":0}]);var shader=createShader(gl);shader.attributes.position.location=0;return new Lines(gl,vertBuf,vao,shader,tickCount,tickOffset,gridCount,gridOffset);}/***/},/***/1943:/***/function(__unused_webpack_module,exports,__nested_webpack_require_258696__){"use strict";var glslify=__nested_webpack_require_258696__(6832);var createShader=__nested_webpack_require_258696__(5158);var lineVert=glslify(["precision highp float;\n#define GLSLIFY 1\n\nattribute vec3 position;\n\nuniform mat4 model, view, projection;\nuniform vec3 offset, majorAxis, minorAxis, screenAxis;\nuniform float lineWidth;\nuniform vec2 screenShape;\n\nvec3 project(vec3 p) {\n  vec4 pp = projection * view * model * vec4(p, 1.0);\n  return pp.xyz / max(pp.w, 0.0001);\n}\n\nvoid main() {\n  vec3 major = position.x * majorAxis;\n  vec3 minor = position.y * minorAxis;\n\n  vec3 vPosition = major + minor + offset;\n  vec3 pPosition = project(vPosition);\n  vec3 offset = project(vPosition + screenAxis * position.z);\n\n  vec2 screen = normalize((offset - pPosition).xy * screenShape) / screenShape;\n\n  gl_Position = vec4(pPosition + vec3(0.5 * screen * lineWidth, 0), 1.0);\n}\n"]);var lineFrag=glslify(["precision highp float;\n#define GLSLIFY 1\n\nuniform vec4 color;\nvoid main() {\n  gl_FragColor = color;\n}"]);exports.j=function(gl){return createShader(gl,lineVert,lineFrag,null,[{name:'position',type:'vec3'}]);};var textVert=glslify(["precision highp float;\n#define GLSLIFY 1\n\nattribute vec3 position;\n\nuniform mat4 model, view, projection;\nuniform vec3 offset, axis, alignDir, alignOpt;\nuniform float scale, angle, pixelScale;\nuniform vec2 resolution;\n\nvec3 project(vec3 p) {\n  vec4 pp = projection * view * model * vec4(p, 1.0);\n  return pp.xyz / max(pp.w, 0.0001);\n}\n\nfloat computeViewAngle(vec3 a, vec3 b) {\n  vec3 A = project(a);\n  vec3 B = project(b);\n\n  return atan(\n    (B.y - A.y) * resolution.y,\n    (B.x - A.x) * resolution.x\n  );\n}\n\nconst float PI = 3.141592;\nconst float TWO_PI = 2.0 * PI;\nconst float HALF_PI = 0.5 * PI;\nconst float ONE_AND_HALF_PI = 1.5 * PI;\n\nint option = int(floor(alignOpt.x + 0.001));\nfloat hv_ratio =       alignOpt.y;\nbool enableAlign =    (alignOpt.z != 0.0);\n\nfloat mod_angle(float a) {\n  return mod(a, PI);\n}\n\nfloat positive_angle(float a) {\n  return mod_angle((a < 0.0) ?\n    a + TWO_PI :\n    a\n  );\n}\n\nfloat look_upwards(float a) {\n  float b = positive_angle(a);\n  return ((b > HALF_PI) && (b <= ONE_AND_HALF_PI)) ?\n    b - PI :\n    b;\n}\n\nfloat look_horizontal_or_vertical(float a, float ratio) {\n  // ratio controls the ratio between being horizontal to (vertical + horizontal)\n  // if ratio is set to 0.5 then it is 50%, 50%.\n  // when using a higher ratio e.g. 0.75 the result would\n  // likely be more horizontal than vertical.\n\n  float b = positive_angle(a);\n\n  return\n    (b < (      ratio) * HALF_PI) ? 0.0 :\n    (b < (2.0 - ratio) * HALF_PI) ? -HALF_PI :\n    (b < (2.0 + ratio) * HALF_PI) ? 0.0 :\n    (b < (4.0 - ratio) * HALF_PI) ? HALF_PI :\n                                    0.0;\n}\n\nfloat roundTo(float a, float b) {\n  return float(b * floor((a + 0.5 * b) / b));\n}\n\nfloat look_round_n_directions(float a, int n) {\n  float b = positive_angle(a);\n  float div = TWO_PI / float(n);\n  float c = roundTo(b, div);\n  return look_upwards(c);\n}\n\nfloat applyAlignOption(float rawAngle, float delta) {\n  return\n    (option >  2) ? look_round_n_directions(rawAngle + delta, option) :       // option 3-n: round to n directions\n    (option == 2) ? look_horizontal_or_vertical(rawAngle + delta, hv_ratio) : // horizontal or vertical\n    (option == 1) ? rawAngle + delta :       // use free angle, and flip to align with one direction of the axis\n    (option == 0) ? look_upwards(rawAngle) : // use free angle, and stay upwards\n    (option ==-1) ? 0.0 :                    // useful for backward compatibility, all texts remains horizontal\n                    rawAngle;                // otherwise return back raw input angle\n}\n\nbool isAxisTitle = (axis.x == 0.0) &&\n                   (axis.y == 0.0) &&\n                   (axis.z == 0.0);\n\nvoid main() {\n  //Compute world offset\n  float axisDistance = position.z;\n  vec3 dataPosition = axisDistance * axis + offset;\n\n  float beta = angle; // i.e. user defined attributes for each tick\n\n  float axisAngle;\n  float clipAngle;\n  float flip;\n\n  if (enableAlign) {\n    axisAngle = (isAxisTitle) ? HALF_PI :\n                      computeViewAngle(dataPosition, dataPosition + axis);\n    clipAngle = computeViewAngle(dataPosition, dataPosition + alignDir);\n\n    axisAngle += (sin(axisAngle) < 0.0) ? PI : 0.0;\n    clipAngle += (sin(clipAngle) < 0.0) ? PI : 0.0;\n\n    flip = (dot(vec2(cos(axisAngle), sin(axisAngle)),\n                vec2(sin(clipAngle),-cos(clipAngle))) > 0.0) ? 1.0 : 0.0;\n\n    beta += applyAlignOption(clipAngle, flip * PI);\n  }\n\n  //Compute plane offset\n  vec2 planeCoord = position.xy * pixelScale;\n\n  mat2 planeXform = scale * mat2(\n     cos(beta), sin(beta),\n    -sin(beta), cos(beta)\n  );\n\n  vec2 viewOffset = 2.0 * planeXform * planeCoord / resolution;\n\n  //Compute clip position\n  vec3 clipPosition = project(dataPosition);\n\n  //Apply text offset in clip coordinates\n  clipPosition += vec3(viewOffset, 0.0);\n\n  //Done\n  gl_Position = vec4(clipPosition, 1.0);\n}"]);var textFrag=glslify(["precision highp float;\n#define GLSLIFY 1\n\nuniform vec4 color;\nvoid main() {\n  gl_FragColor = color;\n}"]);exports.f=function(gl){return createShader(gl,textVert,textFrag,null,[{name:'position',type:'vec3'}]);};var bgVert=glslify(["precision highp float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec3 normal;\n\nuniform mat4 model, view, projection;\nuniform vec3 enable;\nuniform vec3 bounds[2];\n\nvarying vec3 colorChannel;\n\nvoid main() {\n\n  vec3 signAxis = sign(bounds[1] - bounds[0]);\n\n  vec3 realNormal = signAxis * normal;\n\n  if(dot(realNormal, enable) > 0.0) {\n    vec3 minRange = min(bounds[0], bounds[1]);\n    vec3 maxRange = max(bounds[0], bounds[1]);\n    vec3 nPosition = mix(minRange, maxRange, 0.5 * (position + 1.0));\n    gl_Position = projection * view * model * vec4(nPosition, 1.0);\n  } else {\n    gl_Position = vec4(0,0,0,0);\n  }\n\n  colorChannel = abs(realNormal);\n}"]);var bgFrag=glslify(["precision highp float;\n#define GLSLIFY 1\n\nuniform vec4 colors[3];\n\nvarying vec3 colorChannel;\n\nvoid main() {\n  gl_FragColor = colorChannel.x * colors[0] +\n                 colorChannel.y * colors[1] +\n                 colorChannel.z * colors[2];\n}"]);exports.bg=function(gl){return createShader(gl,bgVert,bgFrag,null,[{name:'position',type:'vec3'},{name:'normal',type:'vec3'}]);};/***/},/***/9557:/***/function(module,__unused_webpack_exports,__nested_webpack_require_265252__){"use strict";module.exports=createTextSprites;var createBuffer=__nested_webpack_require_265252__(5827);var createVAO=__nested_webpack_require_265252__(2944);var vectorizeText=__nested_webpack_require_265252__(875);var createShader=__nested_webpack_require_265252__(1943)/* .text */.f;var globals=window||process.global||{};var __TEXT_CACHE=globals.__TEXT_CACHE||{};globals.__TEXT_CACHE={};//Vertex buffer format for text is:
//
/// [x,y,z] = Spatial coordinate
//
var VERTEX_SIZE=3;function TextSprites(gl,shader,buffer,vao){this.gl=gl;this.shader=shader;this.buffer=buffer;this.vao=vao;this.tickOffset=this.tickCount=this.labelOffset=this.labelCount=null;}var proto=TextSprites.prototype;//Bind textures for rendering
var SHAPE=[0,0];proto.bind=function(model,view,projection,pixelScale){this.vao.bind();this.shader.bind();var uniforms=this.shader.uniforms;uniforms.model=model;uniforms.view=view;uniforms.projection=projection;uniforms.pixelScale=pixelScale;SHAPE[0]=this.gl.drawingBufferWidth;SHAPE[1]=this.gl.drawingBufferHeight;this.shader.uniforms.resolution=SHAPE;};proto.unbind=function(){this.vao.unbind();};proto.update=function(bounds,labels,labelFont,ticks,tickFont){var data=[];function addItem(t,text,font,size,lineSpacing,styletags){var fontcache=__TEXT_CACHE[font];if(!fontcache){fontcache=__TEXT_CACHE[font]={};}var mesh=fontcache[text];if(!mesh){mesh=fontcache[text]=tryVectorizeText(text,{triangles:true,font:font,textAlign:'center',textBaseline:'middle',lineSpacing:lineSpacing,styletags:styletags});}var scale=(size||12)/12;var positions=mesh.positions;var cells=mesh.cells;for(var i=0,nc=cells.length;i<nc;++i){var c=cells[i];for(var j=2;j>=0;--j){var p=positions[c[j]];data.push(scale*p[0],-scale*p[1],t);}}}//Generate sprites for all 3 axes, store data in texture atlases
var tickOffset=[0,0,0];var tickCount=[0,0,0];var labelOffset=[0,0,0];var labelCount=[0,0,0];var lineSpacing=1.25;var styletags={breaklines:true,bolds:true,italics:true,subscripts:true,superscripts:true};for(var d=0;d<3;++d){//Generate label
labelOffset[d]=data.length/VERTEX_SIZE|0;addItem(0.5*(bounds[0][d]+bounds[1][d]),labels[d],labelFont[d],12,// labelFontSize
lineSpacing,styletags);labelCount[d]=(data.length/VERTEX_SIZE|0)-labelOffset[d];//Generate sprites for tick marks
tickOffset[d]=data.length/VERTEX_SIZE|0;for(var i=0;i<ticks[d].length;++i){if(!ticks[d][i].text){continue;}addItem(ticks[d][i].x,ticks[d][i].text,ticks[d][i].font||tickFont,ticks[d][i].fontSize||12,lineSpacing,styletags);}tickCount[d]=(data.length/VERTEX_SIZE|0)-tickOffset[d];}this.buffer.update(data);this.tickOffset=tickOffset;this.tickCount=tickCount;this.labelOffset=labelOffset;this.labelCount=labelCount;};//Draws the tick marks for an axis
proto.drawTicks=function(d,scale,angle,offset,color,axis,alignDir,alignOpt){if(!this.tickCount[d]){return;}this.shader.uniforms.axis=axis;this.shader.uniforms.color=color;this.shader.uniforms.angle=angle;this.shader.uniforms.scale=scale;this.shader.uniforms.offset=offset;this.shader.uniforms.alignDir=alignDir;this.shader.uniforms.alignOpt=alignOpt;this.vao.draw(this.gl.TRIANGLES,this.tickCount[d],this.tickOffset[d]);};//Draws the text label for an axis
proto.drawLabel=function(d,scale,angle,offset,color,axis,alignDir,alignOpt){if(!this.labelCount[d]){return;}this.shader.uniforms.axis=axis;this.shader.uniforms.color=color;this.shader.uniforms.angle=angle;this.shader.uniforms.scale=scale;this.shader.uniforms.offset=offset;this.shader.uniforms.alignDir=alignDir;this.shader.uniforms.alignOpt=alignOpt;this.vao.draw(this.gl.TRIANGLES,this.labelCount[d],this.labelOffset[d]);};//Releases all resources attached to this object
proto.dispose=function(){this.shader.dispose();this.vao.dispose();this.buffer.dispose();};function tryVectorizeText(text,options){try{return vectorizeText(text,options);}catch(e){console.warn('error vectorizing text:"'+text+'" error:',e);return{cells:[],positions:[]};}}function createTextSprites(gl,bounds,labels,labelFont,ticks,tickFont){var buffer=createBuffer(gl);var vao=createVAO(gl,[{"buffer":buffer,"size":3}]);var shader=createShader(gl);shader.attributes.position.location=0;var result=new TextSprites(gl,shader,buffer,vao);result.update(bounds,labels,labelFont,ticks,tickFont);return result;}/***/},/***/8468:/***/function(__unused_webpack_module,exports){"use strict";exports.create=defaultTicks;exports.equal=ticksEqual;function prettyPrint(spacing,i){var stepStr=spacing+"";var u=stepStr.indexOf(".");var sigFigs=0;if(u>=0){sigFigs=stepStr.length-u-1;}var shift=Math.pow(10,sigFigs);var x=Math.round(spacing*i*shift);var xstr=x+"";if(xstr.indexOf("e")>=0){return xstr;}var xi=x/shift,xf=x%shift;if(x<0){xi=-Math.ceil(xi)|0;xf=-xf|0;}else{xi=Math.floor(xi)|0;xf=xf|0;}var xis=""+xi;if(x<0){xis="-"+xis;}if(sigFigs){var xs=""+xf;while(xs.length<sigFigs){xs="0"+xs;}return xis+"."+xs;}else{return xis;}}function defaultTicks(bounds,tickSpacing){var array=[];for(var d=0;d<3;++d){var ticks=[];var m=0.5*(bounds[0][d]+bounds[1][d]);for(var t=0;t*tickSpacing[d]<=bounds[1][d];++t){ticks.push({x:t*tickSpacing[d],text:prettyPrint(tickSpacing[d],t)});}for(var t=-1;t*tickSpacing[d]>=bounds[0][d];--t){ticks.push({x:t*tickSpacing[d],text:prettyPrint(tickSpacing[d],t)});}array.push(ticks);}return array;}function ticksEqual(ticksA,ticksB){for(var i=0;i<3;++i){if(ticksA[i].length!==ticksB[i].length){return false;}for(var j=0;j<ticksA[i].length;++j){var a=ticksA[i][j];var b=ticksB[i][j];if(a.x!==b.x||a.text!==b.text||a.font!==b.font||a.fontColor!==b.fontColor||a.fontSize!==b.fontSize||a.dx!==b.dx||a.dy!==b.dy){return false;}}}return true;}/***/},/***/2771:/***/function(module,__unused_webpack_exports,__nested_webpack_require_270882__){"use strict";module.exports=axesProperties;var getPlanes=__nested_webpack_require_270882__(5795);var splitPoly=__nested_webpack_require_270882__(4670);var cubeParams=__nested_webpack_require_270882__(2864);var m4mul=__nested_webpack_require_270882__(104);var m4transpose=__nested_webpack_require_270882__(2142);var v4transformMat4=__nested_webpack_require_270882__(6342);var identity=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);var mvp=new Float32Array(16);function AxesRange3D(lo,hi,pixelsPerDataUnit){this.lo=lo;this.hi=hi;this.pixelsPerDataUnit=pixelsPerDataUnit;}var SCRATCH_P=[0,0,0,1];var SCRATCH_Q=[0,0,0,1];function gradient(result,M,v,width,height){for(var i=0;i<3;++i){var p=SCRATCH_P;var q=SCRATCH_Q;for(var j=0;j<3;++j){q[j]=p[j]=v[j];}q[3]=p[3]=1;q[i]+=1;v4transformMat4(q,q,M);if(q[3]<0){result[i]=Infinity;}p[i]-=1;v4transformMat4(p,p,M);if(p[3]<0){result[i]=Infinity;}var dx=(p[0]/p[3]-q[0]/q[3])*width;var dy=(p[1]/p[3]-q[1]/q[3])*height;result[i]=0.25*Math.sqrt(dx*dx+dy*dy);}return result;}var RANGES=[new AxesRange3D(Infinity,-Infinity,Infinity),new AxesRange3D(Infinity,-Infinity,Infinity),new AxesRange3D(Infinity,-Infinity,Infinity)];var SCRATCH_X=[0,0,0];function axesProperties(axes,camera,width,height,params){var model=camera.model||identity;var view=camera.view||identity;var projection=camera.projection||identity;var isOrtho=camera._ortho||false;var bounds=axes.bounds;var params=params||cubeParams(model,view,projection,bounds,isOrtho);var axis=params.axis;m4mul(mvp,view,model);m4mul(mvp,projection,mvp);//Calculate the following properties for each axis:
//
// * lo - start of visible range for each axis in tick coordinates
// * hi - end of visible range for each axis in tick coordinates
// * ticksPerPixel - pixel density of tick marks for the axis
//
var ranges=RANGES;for(var i=0;i<3;++i){ranges[i].lo=Infinity;ranges[i].hi=-Infinity;ranges[i].pixelsPerDataUnit=Infinity;}//Compute frustum planes, intersect with box
var frustum=getPlanes(m4transpose(mvp,mvp));m4transpose(mvp,mvp);//Loop over vertices of viewable box
for(var d=0;d<3;++d){var u=(d+1)%3;var v=(d+2)%3;var x=SCRATCH_X;i_loop:for(var i=0;i<2;++i){var poly=[];if(axis[d]<0===!!i){continue;}x[d]=bounds[i][d];for(var j=0;j<2;++j){x[u]=bounds[j^i][u];for(var k=0;k<2;++k){x[v]=bounds[k^j^i][v];poly.push(x.slice());}}var Q=isOrtho?5:4;for(var j=Q;j===Q;++j){// Note: using only near plane here (& for orthographic projection we use the far).
if(poly.length===0){continue i_loop;}poly=splitPoly.positive(poly,frustum[j]);}//Loop over vertices of polygon to find extremal points
for(var j=0;j<poly.length;++j){var v=poly[j];var grad=gradient(SCRATCH_X,mvp,v,width,height);for(var k=0;k<3;++k){ranges[k].lo=Math.min(ranges[k].lo,v[k]);ranges[k].hi=Math.max(ranges[k].hi,v[k]);if(k!==d){ranges[k].pixelsPerDataUnit=Math.min(ranges[k].pixelsPerDataUnit,Math.abs(grad[k]));}}}}}return ranges;}/***/},/***/5827:/***/function(module,__unused_webpack_exports,__nested_webpack_require_273777__){"use strict";var pool=__nested_webpack_require_273777__(5306);var ops=__nested_webpack_require_273777__(7498);var ndarray=__nested_webpack_require_273777__(5050);var SUPPORTED_TYPES=["uint8","uint8_clamped","uint16","uint32","int8","int16","int32","float32"];function GLBuffer(gl,type,handle,length,usage){this.gl=gl;this.type=type;this.handle=handle;this.length=length;this.usage=usage;}var proto=GLBuffer.prototype;proto.bind=function(){this.gl.bindBuffer(this.type,this.handle);};proto.unbind=function(){this.gl.bindBuffer(this.type,null);};proto.dispose=function(){this.gl.deleteBuffer(this.handle);};function updateTypeArray(gl,type,len,usage,data,offset){var dataLen=data.length*data.BYTES_PER_ELEMENT;if(offset<0){gl.bufferData(type,data,usage);return dataLen;}if(dataLen+offset>len){throw new Error("gl-buffer: If resizing buffer, must not specify offset");}gl.bufferSubData(type,offset,data);return len;}function makeScratchTypeArray(array,dtype){var res=pool.malloc(array.length,dtype);var n=array.length;for(var i=0;i<n;++i){res[i]=array[i];}return res;}function isPacked(shape,stride){var n=1;for(var i=stride.length-1;i>=0;--i){if(stride[i]!==n){return false;}n*=shape[i];}return true;}proto.update=function(array,offset){if(typeof offset!=="number"){offset=-1;}this.bind();if(typeof array==="object"&&typeof array.shape!=="undefined"){//ndarray
var dtype=array.dtype;if(SUPPORTED_TYPES.indexOf(dtype)<0){dtype="float32";}if(this.type===this.gl.ELEMENT_ARRAY_BUFFER){var ext=gl.getExtension('OES_element_index_uint');if(ext&&dtype!=="uint16"){dtype="uint32";}else{dtype="uint16";}}if(dtype===array.dtype&&isPacked(array.shape,array.stride)){if(array.offset===0&&array.data.length===array.shape[0]){this.length=updateTypeArray(this.gl,this.type,this.length,this.usage,array.data,offset);}else{this.length=updateTypeArray(this.gl,this.type,this.length,this.usage,array.data.subarray(array.offset,array.shape[0]),offset);}}else{var tmp=pool.malloc(array.size,dtype);var ndt=ndarray(tmp,array.shape);ops.assign(ndt,array);if(offset<0){this.length=updateTypeArray(this.gl,this.type,this.length,this.usage,tmp,offset);}else{this.length=updateTypeArray(this.gl,this.type,this.length,this.usage,tmp.subarray(0,array.size),offset);}pool.free(tmp);}}else if(Array.isArray(array)){//Vanilla array
var t;if(this.type===this.gl.ELEMENT_ARRAY_BUFFER){t=makeScratchTypeArray(array,"uint16");}else{t=makeScratchTypeArray(array,"float32");}if(offset<0){this.length=updateTypeArray(this.gl,this.type,this.length,this.usage,t,offset);}else{this.length=updateTypeArray(this.gl,this.type,this.length,this.usage,t.subarray(0,array.length),offset);}pool.free(t);}else if(typeof array==="object"&&typeof array.length==="number"){//Typed array
this.length=updateTypeArray(this.gl,this.type,this.length,this.usage,array,offset);}else if(typeof array==="number"||array===undefined){//Number/default
if(offset>=0){throw new Error("gl-buffer: Cannot specify offset when resizing buffer");}array=array|0;if(array<=0){array=1;}this.gl.bufferData(this.type,array|0,this.usage);this.length=array;}else{//Error, case should not happen
throw new Error("gl-buffer: Invalid data type");}};function createBuffer(gl,data,type,usage){type=type||gl.ARRAY_BUFFER;usage=usage||gl.DYNAMIC_DRAW;if(type!==gl.ARRAY_BUFFER&&type!==gl.ELEMENT_ARRAY_BUFFER){throw new Error("gl-buffer: Invalid type for webgl buffer, must be either gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER");}if(usage!==gl.DYNAMIC_DRAW&&usage!==gl.STATIC_DRAW&&usage!==gl.STREAM_DRAW){throw new Error("gl-buffer: Invalid usage for buffer, must be either gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW");}var handle=gl.createBuffer();var result=new GLBuffer(gl,type,handle,0,usage);result.update(data);return result;}module.exports=createBuffer;/***/},/***/1140:/***/function(module,__unused_webpack_exports,__nested_webpack_require_277599__){"use strict";var vec3=__nested_webpack_require_277599__(2858);module.exports=function(vectorfield,bounds){var positions=vectorfield.positions;var vectors=vectorfield.vectors;var geo={positions:[],vertexIntensity:[],vertexIntensityBounds:vectorfield.vertexIntensityBounds,vectors:[],cells:[],coneOffset:vectorfield.coneOffset,colormap:vectorfield.colormap};if(vectorfield.positions.length===0){if(bounds){bounds[0]=[0,0,0];bounds[1]=[0,0,0];}return geo;}// Compute bounding box for the dataset.
// Compute maximum velocity for the dataset to use for scaling the cones.
var maxNorm=0;var minX=Infinity,maxX=-Infinity;var minY=Infinity,maxY=-Infinity;var minZ=Infinity,maxZ=-Infinity;var p2=null;var u2=null;var positionVectors=[];var vectorScale=Infinity;var skipIt=false;for(var i=0;i<positions.length;i++){var p=positions[i];minX=Math.min(p[0],minX);maxX=Math.max(p[0],maxX);minY=Math.min(p[1],minY);maxY=Math.max(p[1],maxY);minZ=Math.min(p[2],minZ);maxZ=Math.max(p[2],maxZ);var u=vectors[i];if(vec3.length(u)>maxNorm){maxNorm=vec3.length(u);}if(i){// Find vector scale [w/ units of time] using "successive" positions
// (not "adjacent" with would be O(n^2)),
//
// The vector scale corresponds to the minimum "time" to travel across two
// two adjacent positions at the average velocity of those two adjacent positions
var q=2*vec3.distance(p2,p)/(vec3.length(u2)+vec3.length(u));if(q){vectorScale=Math.min(vectorScale,q);skipIt=false;}else{skipIt=true;}}if(!skipIt){p2=p;u2=u;}positionVectors.push(u);}var minV=[minX,minY,minZ];var maxV=[maxX,maxY,maxZ];if(bounds){bounds[0]=minV;bounds[1]=maxV;}if(maxNorm===0){maxNorm=1;}// Inverted max norm would map vector with norm maxNorm to 1 coord space units in length
var invertedMaxNorm=1/maxNorm;if(!isFinite(vectorScale)){vectorScale=1.0;}geo.vectorScale=vectorScale;var coneScale=vectorfield.coneSize||0.5;if(vectorfield.absoluteConeSize){coneScale=vectorfield.absoluteConeSize*invertedMaxNorm;}geo.coneScale=coneScale;// Build the cone model.
for(var i=0,j=0;i<positions.length;i++){var p=positions[i];var x=p[0],y=p[1],z=p[2];var d=positionVectors[i];var intensity=vec3.length(d)*invertedMaxNorm;for(var k=0,l=8;k<l;k++){geo.positions.push([x,y,z,j++]);geo.positions.push([x,y,z,j++]);geo.positions.push([x,y,z,j++]);geo.positions.push([x,y,z,j++]);geo.positions.push([x,y,z,j++]);geo.positions.push([x,y,z,j++]);geo.vectors.push(d);geo.vectors.push(d);geo.vectors.push(d);geo.vectors.push(d);geo.vectors.push(d);geo.vectors.push(d);geo.vertexIntensity.push(intensity,intensity,intensity);geo.vertexIntensity.push(intensity,intensity,intensity);var m=geo.positions.length;geo.cells.push([m-6,m-5,m-4],[m-3,m-2,m-1]);}}return geo;};var shaders=__nested_webpack_require_277599__(7234);module.exports.createMesh=__nested_webpack_require_277599__(5028);module.exports.createConeMesh=function(gl,params){return module.exports.createMesh(gl,params,{shaders:shaders,traceType:'cone'});};/***/},/***/5028:/***/function(module,__unused_webpack_exports,__nested_webpack_require_280573__){"use strict";var createShader=__nested_webpack_require_280573__(5158);var createBuffer=__nested_webpack_require_280573__(5827);var createVAO=__nested_webpack_require_280573__(2944);var createTexture=__nested_webpack_require_280573__(8931);var multiply=__nested_webpack_require_280573__(104);var invert=__nested_webpack_require_280573__(7437);var ndarray=__nested_webpack_require_280573__(5050);var colormap=__nested_webpack_require_280573__(9156);var IDENTITY=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];function VectorMesh(gl,texture,triShader,pickShader,trianglePositions,triangleVectors,triangleIds,triangleColors,triangleUVs,triangleVAO,traceType){this.gl=gl;this.pixelRatio=1;this.cells=[];this.positions=[];this.intensity=[];this.texture=texture;this.dirty=true;this.triShader=triShader;this.pickShader=pickShader;this.trianglePositions=trianglePositions;this.triangleVectors=triangleVectors;this.triangleColors=triangleColors;this.triangleUVs=triangleUVs;this.triangleIds=triangleIds;this.triangleVAO=triangleVAO;this.triangleCount=0;this.pickId=1;this.bounds=[[Infinity,Infinity,Infinity],[-Infinity,-Infinity,-Infinity]];this.clipBounds=[[-Infinity,-Infinity,-Infinity],[Infinity,Infinity,Infinity]];this.lightPosition=[1e5,1e5,0];this.ambientLight=0.8;this.diffuseLight=0.8;this.specularLight=2.0;this.roughness=0.5;this.fresnel=1.5;this.opacity=1;this.traceType=traceType;this.tubeScale=1;// used in streamtube
this.coneScale=2;// used in cone
this.vectorScale=1;// used in cone
this.coneOffset=0.25;// used in cone
this._model=IDENTITY;this._view=IDENTITY;this._projection=IDENTITY;this._resolution=[1,1];}var proto=VectorMesh.prototype;proto.isOpaque=function(){return this.opacity>=1;};proto.isTransparent=function(){return this.opacity<1;};proto.pickSlots=1;proto.setPickBase=function(id){this.pickId=id;};function genColormap(param){var colors=colormap({colormap:param,nshades:256,format:'rgba'});var result=new Uint8Array(256*4);for(var i=0;i<256;++i){var c=colors[i];for(var j=0;j<3;++j){result[4*i+j]=c[j];}result[4*i+3]=c[3]*255;}return ndarray(result,[256,256,4],[4,0,1]);}function takeZComponent(array){var n=array.length;var result=new Array(n);for(var i=0;i<n;++i){result[i]=array[i][2];}return result;}proto.update=function(params){params=params||{};var gl=this.gl;this.dirty=true;if('lightPosition'in params){this.lightPosition=params.lightPosition;}if('opacity'in params){this.opacity=params.opacity;}if('ambient'in params){this.ambientLight=params.ambient;}if('diffuse'in params){this.diffuseLight=params.diffuse;}if('specular'in params){this.specularLight=params.specular;}if('roughness'in params){this.roughness=params.roughness;}if('fresnel'in params){this.fresnel=params.fresnel;}// use in streamtube
if(params.tubeScale!==undefined){this.tubeScale=params.tubeScale;}// used in cone
if(params.vectorScale!==undefined){this.vectorScale=params.vectorScale;}if(params.coneScale!==undefined){this.coneScale=params.coneScale;}if(params.coneOffset!==undefined){this.coneOffset=params.coneOffset;}if(params.colormap){this.texture.shape=[256,256];this.texture.minFilter=gl.LINEAR_MIPMAP_LINEAR;this.texture.magFilter=gl.LINEAR;this.texture.setPixels(genColormap(params.colormap));this.texture.generateMipmap();}var cells=params.cells;var positions=params.positions;var vectors=params.vectors;if(!positions||!cells||!vectors){return;}var tPos=[];var tVec=[];var tCol=[];var tUVs=[];var tIds=[];//Save geometry data for picking calculations
this.cells=cells;this.positions=positions;this.vectors=vectors;//Compute colors
var meshColor=params.meshColor||[1,1,1,1];//UVs
var vertexIntensity=params.vertexIntensity;var intensityLo=Infinity;var intensityHi=-Infinity;if(vertexIntensity){if(params.vertexIntensityBounds){intensityLo=+params.vertexIntensityBounds[0];intensityHi=+params.vertexIntensityBounds[1];}else{for(var i=0;i<vertexIntensity.length;++i){var f=vertexIntensity[i];intensityLo=Math.min(intensityLo,f);intensityHi=Math.max(intensityHi,f);}}}else{for(var i=0;i<positions.length;++i){var f=positions[i][2];intensityLo=Math.min(intensityLo,f);intensityHi=Math.max(intensityHi,f);}}if(vertexIntensity){this.intensity=vertexIntensity;}else{this.intensity=takeZComponent(positions);}//Update bounds
this.bounds=[[Infinity,Infinity,Infinity],[-Infinity,-Infinity,-Infinity]];for(var i=0;i<positions.length;++i){var p=positions[i];for(var j=0;j<3;++j){if(isNaN(p[j])||!isFinite(p[j])){continue;}this.bounds[0][j]=Math.min(this.bounds[0][j],p[j]);this.bounds[1][j]=Math.max(this.bounds[1][j],p[j]);}}//Pack cells into buffers
var triangleCount=0;fill_loop:for(var i=0;i<cells.length;++i){var cell=cells[i];switch(cell.length){case 3://Check NaNs
for(var j=0;j<3;++j){var v=cell[j];var p=positions[v];for(var k=0;k<3;++k){if(isNaN(p[k])||!isFinite(p[k])){continue fill_loop;}}}for(var j=0;j<3;++j){var v=cell[2-j];var p=positions[v];tPos.push(p[0],p[1],p[2],p[3]);var w=vectors[v];tVec.push(w[0],w[1],w[2],w[3]||0);var c=meshColor;if(c.length===3){tCol.push(c[0],c[1],c[2],1);}else{tCol.push(c[0],c[1],c[2],c[3]);}var uv;if(vertexIntensity){uv=[(vertexIntensity[v]-intensityLo)/(intensityHi-intensityLo),0];}else{uv=[(p[2]-intensityLo)/(intensityHi-intensityLo),0];}tUVs.push(uv[0],uv[1]);tIds.push(i);}triangleCount+=1;break;default:break;}}this.triangleCount=triangleCount;this.trianglePositions.update(tPos);this.triangleVectors.update(tVec);this.triangleColors.update(tCol);this.triangleUVs.update(tUVs);this.triangleIds.update(new Uint32Array(tIds));};proto.drawTransparent=proto.draw=function(params){params=params||{};var gl=this.gl;var model=params.model||IDENTITY;var view=params.view||IDENTITY;var projection=params.projection||IDENTITY;var clipBounds=[[-1e6,-1e6,-1e6],[1e6,1e6,1e6]];for(var i=0;i<3;++i){clipBounds[0][i]=Math.max(clipBounds[0][i],this.clipBounds[0][i]);clipBounds[1][i]=Math.min(clipBounds[1][i],this.clipBounds[1][i]);}var uniforms={model:model,view:view,projection:projection,inverseModel:IDENTITY.slice(),clipBounds:clipBounds,kambient:this.ambientLight,kdiffuse:this.diffuseLight,kspecular:this.specularLight,roughness:this.roughness,fresnel:this.fresnel,eyePosition:[0,0,0],lightPosition:[0,0,0],opacity:this.opacity,tubeScale:this.tubeScale,vectorScale:this.vectorScale,coneScale:this.coneScale,coneOffset:this.coneOffset,texture:0};uniforms.inverseModel=invert(uniforms.inverseModel,uniforms.model);gl.disable(gl.CULL_FACE);this.texture.bind(0);var invCameraMatrix=new Array(16);multiply(invCameraMatrix,uniforms.view,uniforms.model);multiply(invCameraMatrix,uniforms.projection,invCameraMatrix);invert(invCameraMatrix,invCameraMatrix);for(var i=0;i<3;++i){uniforms.eyePosition[i]=invCameraMatrix[12+i]/invCameraMatrix[15];}var w=invCameraMatrix[15];for(var i=0;i<3;++i){w+=this.lightPosition[i]*invCameraMatrix[4*i+3];}for(var i=0;i<3;++i){var s=invCameraMatrix[12+i];for(var j=0;j<3;++j){s+=invCameraMatrix[4*j+i]*this.lightPosition[j];}uniforms.lightPosition[i]=s/w;}if(this.triangleCount>0){var shader=this.triShader;shader.bind();shader.uniforms=uniforms;this.triangleVAO.bind();gl.drawArrays(gl.TRIANGLES,0,this.triangleCount*3);this.triangleVAO.unbind();}};proto.drawPick=function(params){params=params||{};var gl=this.gl;var model=params.model||IDENTITY;var view=params.view||IDENTITY;var projection=params.projection||IDENTITY;var clipBounds=[[-1e6,-1e6,-1e6],[1e6,1e6,1e6]];for(var i=0;i<3;++i){clipBounds[0][i]=Math.max(clipBounds[0][i],this.clipBounds[0][i]);clipBounds[1][i]=Math.min(clipBounds[1][i],this.clipBounds[1][i]);}//Save camera parameters
this._model=[].slice.call(model);this._view=[].slice.call(view);this._projection=[].slice.call(projection);this._resolution=[gl.drawingBufferWidth,gl.drawingBufferHeight];var uniforms={model:model,view:view,projection:projection,clipBounds:clipBounds,tubeScale:this.tubeScale,vectorScale:this.vectorScale,coneScale:this.coneScale,coneOffset:this.coneOffset,pickId:this.pickId/255.0};var shader=this.pickShader;shader.bind();shader.uniforms=uniforms;if(this.triangleCount>0){this.triangleVAO.bind();gl.drawArrays(gl.TRIANGLES,0,this.triangleCount*3);this.triangleVAO.unbind();}};proto.pick=function(pickData){if(!pickData){return null;}if(pickData.id!==this.pickId){return null;}var cellId=pickData.value[0]+256*pickData.value[1]+65536*pickData.value[2];var cell=this.cells[cellId];var pos=this.positions[cell[1]].slice(0,3);var result={position:pos,dataCoordinate:pos,index:Math.floor(cell[1]/48)};if(this.traceType==='cone'){result.index=Math.floor(cell[1]/48);}else if(this.traceType==='streamtube'){result.intensity=this.intensity[cell[1]];result.velocity=this.vectors[cell[1]].slice(0,3);result.divergence=this.vectors[cell[1]][3];result.index=cellId;}return result;};proto.dispose=function(){this.texture.dispose();this.triShader.dispose();this.pickShader.dispose();this.triangleVAO.dispose();this.trianglePositions.dispose();this.triangleVectors.dispose();this.triangleColors.dispose();this.triangleUVs.dispose();this.triangleIds.dispose();};function createMeshShader(gl,shaders){var shader=createShader(gl,shaders.meshShader.vertex,shaders.meshShader.fragment,null,shaders.meshShader.attributes);shader.attributes.position.location=0;shader.attributes.color.location=2;shader.attributes.uv.location=3;shader.attributes.vector.location=4;return shader;}function createPickShader(gl,shaders){var shader=createShader(gl,shaders.pickShader.vertex,shaders.pickShader.fragment,null,shaders.pickShader.attributes);shader.attributes.position.location=0;shader.attributes.id.location=1;shader.attributes.vector.location=4;return shader;}function createVectorMesh(gl,params,opts){var shaders=opts.shaders;if(arguments.length===1){params=gl;gl=params.gl;}var triShader=createMeshShader(gl,shaders);var pickShader=createPickShader(gl,shaders);var meshTexture=createTexture(gl,ndarray(new Uint8Array([255,255,255,255]),[1,1,4]));meshTexture.generateMipmap();meshTexture.minFilter=gl.LINEAR_MIPMAP_LINEAR;meshTexture.magFilter=gl.LINEAR;var trianglePositions=createBuffer(gl);var triangleVectors=createBuffer(gl);var triangleColors=createBuffer(gl);var triangleUVs=createBuffer(gl);var triangleIds=createBuffer(gl);var triangleVAO=createVAO(gl,[{buffer:trianglePositions,type:gl.FLOAT,size:4},{buffer:triangleIds,type:gl.UNSIGNED_BYTE,size:4,normalized:true},{buffer:triangleColors,type:gl.FLOAT,size:4},{buffer:triangleUVs,type:gl.FLOAT,size:2},{buffer:triangleVectors,type:gl.FLOAT,size:4}]);var mesh=new VectorMesh(gl,meshTexture,triShader,pickShader,trianglePositions,triangleVectors,triangleIds,triangleColors,triangleUVs,triangleVAO,opts.traceType||'cone');mesh.update(params);return mesh;}module.exports=createVectorMesh;/***/},/***/7234:/***/function(__unused_webpack_module,exports,__nested_webpack_require_291180__){var glslify=__nested_webpack_require_291180__(6832);var triVertSrc=glslify(["precision highp float;\n\nprecision highp float;\n#define GLSLIFY 1\n\nvec3 getOrthogonalVector(vec3 v) {\n  // Return up-vector for only-z vector.\n  // Return ax + by + cz = 0, a point that lies on the plane that has v as a normal and that isn't (0,0,0).\n  // From the above if-statement we have ||a|| > 0  U  ||b|| > 0.\n  // Assign z = 0, x = -b, y = a:\n  // a*-b + b*a + c*0 = -ba + ba + 0 = 0\n  if (v.x*v.x > v.z*v.z || v.y*v.y > v.z*v.z) {\n    return normalize(vec3(-v.y, v.x, 0.0));\n  } else {\n    return normalize(vec3(0.0, v.z, -v.y));\n  }\n}\n\n// Calculate the cone vertex and normal at the given index.\n//\n// The returned vertex is for a cone with its top at origin and height of 1.0,\n// pointing in the direction of the vector attribute.\n//\n// Each cone is made up of a top vertex, a center base vertex and base perimeter vertices.\n// These vertices are used to make up the triangles of the cone by the following:\n//   segment + 0 top vertex\n//   segment + 1 perimeter vertex a+1\n//   segment + 2 perimeter vertex a\n//   segment + 3 center base vertex\n//   segment + 4 perimeter vertex a\n//   segment + 5 perimeter vertex a+1\n// Where segment is the number of the radial segment * 6 and a is the angle at that radial segment.\n// To go from index to segment, floor(index / 6)\n// To go from segment to angle, 2*pi * (segment/segmentCount)\n// To go from index to segment index, index - (segment*6)\n//\nvec3 getConePosition(vec3 d, float rawIndex, float coneOffset, out vec3 normal) {\n\n  const float segmentCount = 8.0;\n\n  float index = rawIndex - floor(rawIndex /\n    (segmentCount * 6.0)) *\n    (segmentCount * 6.0);\n\n  float segment = floor(0.001 + index/6.0);\n  float segmentIndex = index - (segment*6.0);\n\n  normal = -normalize(d);\n\n  if (segmentIndex > 2.99 && segmentIndex < 3.01) {\n    return mix(vec3(0.0), -d, coneOffset);\n  }\n\n  float nextAngle = (\n    (segmentIndex > 0.99 &&  segmentIndex < 1.01) ||\n    (segmentIndex > 4.99 &&  segmentIndex < 5.01)\n  ) ? 1.0 : 0.0;\n  float angle = 2.0 * 3.14159 * ((segment + nextAngle) / segmentCount);\n\n  vec3 v1 = mix(d, vec3(0.0), coneOffset);\n  vec3 v2 = v1 - d;\n\n  vec3 u = getOrthogonalVector(d);\n  vec3 v = normalize(cross(u, d));\n\n  vec3 x = u * cos(angle) * length(d)*0.25;\n  vec3 y = v * sin(angle) * length(d)*0.25;\n  vec3 v3 = v2 + x + y;\n  if (segmentIndex < 3.0) {\n    vec3 tx = u * sin(angle);\n    vec3 ty = v * -cos(angle);\n    vec3 tangent = tx + ty;\n    normal = normalize(cross(v3 - v1, tangent));\n  }\n\n  if (segmentIndex == 0.0) {\n    return mix(d, vec3(0.0), coneOffset);\n  }\n  return v3;\n}\n\nattribute vec3 vector;\nattribute vec4 color, position;\nattribute vec2 uv;\n\nuniform float vectorScale, coneScale, coneOffset;\nuniform mat4 model, view, projection, inverseModel;\nuniform vec3 eyePosition, lightPosition;\n\nvarying vec3 f_normal, f_lightDirection, f_eyeDirection, f_data, f_position;\nvarying vec4 f_color;\nvarying vec2 f_uv;\n\nvoid main() {\n  // Scale the vector magnitude to stay constant with\n  // model & view changes.\n  vec3 normal;\n  vec3 XYZ = getConePosition(mat3(model) * ((vectorScale * coneScale) * vector), position.w, coneOffset, normal);\n  vec4 conePosition = model * vec4(position.xyz, 1.0) + vec4(XYZ, 0.0);\n\n  //Lighting geometry parameters\n  vec4 cameraCoordinate = view * conePosition;\n  cameraCoordinate.xyz /= cameraCoordinate.w;\n  f_lightDirection = lightPosition - cameraCoordinate.xyz;\n  f_eyeDirection   = eyePosition - cameraCoordinate.xyz;\n  f_normal = normalize((vec4(normal, 0.0) * inverseModel).xyz);\n\n  // vec4 m_position  = model * vec4(conePosition, 1.0);\n  vec4 t_position  = view * conePosition;\n  gl_Position      = projection * t_position;\n\n  f_color          = color;\n  f_data           = conePosition.xyz;\n  f_position       = position.xyz;\n  f_uv             = uv;\n}\n"]);var triFragSrc=glslify(["#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n#define GLSLIFY 1\n\nfloat beckmannDistribution(float x, float roughness) {\n  float NdotH = max(x, 0.0001);\n  float cos2Alpha = NdotH * NdotH;\n  float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;\n  float roughness2 = roughness * roughness;\n  float denom = 3.141592653589793 * roughness2 * cos2Alpha * cos2Alpha;\n  return exp(tan2Alpha / roughness2) / denom;\n}\n\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.0);\n  float VdotH = max(dot(viewDirection, H), 0.000001);\n  float LdotH = max(dot(lightDirection, H), 0.000001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = min(1.0, min(G1, G2));\n  \n  //Distribution term\n  float D = beckmannDistribution(NdotH, roughness);\n\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  G * F * D / max(3.14159265 * VdotN, 0.000001);\n}\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nuniform vec3 clipBounds[2];\nuniform float roughness, fresnel, kambient, kdiffuse, kspecular, opacity;\nuniform sampler2D texture;\n\nvarying vec3 f_normal, f_lightDirection, f_eyeDirection, f_data, f_position;\nvarying vec4 f_color;\nvarying vec2 f_uv;\n\nvoid main() {\n  if (outOfRange(clipBounds[0], clipBounds[1], f_position)) discard;\n  vec3 N = normalize(f_normal);\n  vec3 L = normalize(f_lightDirection);\n  vec3 V = normalize(f_eyeDirection);\n\n  if(gl_FrontFacing) {\n    N = -N;\n  }\n\n  float specular = min(1.0, max(0.0, cookTorranceSpecular(L, V, N, roughness, fresnel)));\n  float diffuse  = min(kambient + kdiffuse * max(dot(N, L), 0.0), 1.0);\n\n  vec4 surfaceColor = f_color * texture2D(texture, f_uv);\n  vec4 litColor = surfaceColor.a * vec4(diffuse * surfaceColor.rgb + kspecular * vec3(1,1,1) * specular,  1.0);\n\n  gl_FragColor = litColor * opacity;\n}\n"]);var pickVertSrc=glslify(["precision highp float;\n\nprecision highp float;\n#define GLSLIFY 1\n\nvec3 getOrthogonalVector(vec3 v) {\n  // Return up-vector for only-z vector.\n  // Return ax + by + cz = 0, a point that lies on the plane that has v as a normal and that isn't (0,0,0).\n  // From the above if-statement we have ||a|| > 0  U  ||b|| > 0.\n  // Assign z = 0, x = -b, y = a:\n  // a*-b + b*a + c*0 = -ba + ba + 0 = 0\n  if (v.x*v.x > v.z*v.z || v.y*v.y > v.z*v.z) {\n    return normalize(vec3(-v.y, v.x, 0.0));\n  } else {\n    return normalize(vec3(0.0, v.z, -v.y));\n  }\n}\n\n// Calculate the cone vertex and normal at the given index.\n//\n// The returned vertex is for a cone with its top at origin and height of 1.0,\n// pointing in the direction of the vector attribute.\n//\n// Each cone is made up of a top vertex, a center base vertex and base perimeter vertices.\n// These vertices are used to make up the triangles of the cone by the following:\n//   segment + 0 top vertex\n//   segment + 1 perimeter vertex a+1\n//   segment + 2 perimeter vertex a\n//   segment + 3 center base vertex\n//   segment + 4 perimeter vertex a\n//   segment + 5 perimeter vertex a+1\n// Where segment is the number of the radial segment * 6 and a is the angle at that radial segment.\n// To go from index to segment, floor(index / 6)\n// To go from segment to angle, 2*pi * (segment/segmentCount)\n// To go from index to segment index, index - (segment*6)\n//\nvec3 getConePosition(vec3 d, float rawIndex, float coneOffset, out vec3 normal) {\n\n  const float segmentCount = 8.0;\n\n  float index = rawIndex - floor(rawIndex /\n    (segmentCount * 6.0)) *\n    (segmentCount * 6.0);\n\n  float segment = floor(0.001 + index/6.0);\n  float segmentIndex = index - (segment*6.0);\n\n  normal = -normalize(d);\n\n  if (segmentIndex > 2.99 && segmentIndex < 3.01) {\n    return mix(vec3(0.0), -d, coneOffset);\n  }\n\n  float nextAngle = (\n    (segmentIndex > 0.99 &&  segmentIndex < 1.01) ||\n    (segmentIndex > 4.99 &&  segmentIndex < 5.01)\n  ) ? 1.0 : 0.0;\n  float angle = 2.0 * 3.14159 * ((segment + nextAngle) / segmentCount);\n\n  vec3 v1 = mix(d, vec3(0.0), coneOffset);\n  vec3 v2 = v1 - d;\n\n  vec3 u = getOrthogonalVector(d);\n  vec3 v = normalize(cross(u, d));\n\n  vec3 x = u * cos(angle) * length(d)*0.25;\n  vec3 y = v * sin(angle) * length(d)*0.25;\n  vec3 v3 = v2 + x + y;\n  if (segmentIndex < 3.0) {\n    vec3 tx = u * sin(angle);\n    vec3 ty = v * -cos(angle);\n    vec3 tangent = tx + ty;\n    normal = normalize(cross(v3 - v1, tangent));\n  }\n\n  if (segmentIndex == 0.0) {\n    return mix(d, vec3(0.0), coneOffset);\n  }\n  return v3;\n}\n\nattribute vec4 vector;\nattribute vec4 position;\nattribute vec4 id;\n\nuniform mat4 model, view, projection;\nuniform float vectorScale, coneScale, coneOffset;\n\nvarying vec3 f_position;\nvarying vec4 f_id;\n\nvoid main() {\n  vec3 normal;\n  vec3 XYZ = getConePosition(mat3(model) * ((vectorScale * coneScale) * vector.xyz), position.w, coneOffset, normal);\n  vec4 conePosition = model * vec4(position.xyz, 1.0) + vec4(XYZ, 0.0);\n  gl_Position = projection * view * conePosition;\n  f_id        = id;\n  f_position  = position.xyz;\n}\n"]);var pickFragSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nuniform vec3  clipBounds[2];\nuniform float pickId;\n\nvarying vec3 f_position;\nvarying vec4 f_id;\n\nvoid main() {\n  if (outOfRange(clipBounds[0], clipBounds[1], f_position)) discard;\n\n  gl_FragColor = vec4(pickId, f_id.xyz);\n}"]);exports.meshShader={vertex:triVertSrc,fragment:triFragSrc,attributes:[{name:'position',type:'vec4'},{name:'color',type:'vec4'},{name:'uv',type:'vec2'},{name:'vector',type:'vec3'}]};exports.pickShader={vertex:pickVertSrc,fragment:pickFragSrc,attributes:[{name:'position',type:'vec4'},{name:'id',type:'vec4'},{name:'vector',type:'vec3'}]};/***/},/***/1950:/***/function(module){module.exports={0:'NONE',1:'ONE',2:'LINE_LOOP',3:'LINE_STRIP',4:'TRIANGLES',5:'TRIANGLE_STRIP',6:'TRIANGLE_FAN',256:'DEPTH_BUFFER_BIT',512:'NEVER',513:'LESS',514:'EQUAL',515:'LEQUAL',516:'GREATER',517:'NOTEQUAL',518:'GEQUAL',519:'ALWAYS',768:'SRC_COLOR',769:'ONE_MINUS_SRC_COLOR',770:'SRC_ALPHA',771:'ONE_MINUS_SRC_ALPHA',772:'DST_ALPHA',773:'ONE_MINUS_DST_ALPHA',774:'DST_COLOR',775:'ONE_MINUS_DST_COLOR',776:'SRC_ALPHA_SATURATE',1024:'STENCIL_BUFFER_BIT',1028:'FRONT',1029:'BACK',1032:'FRONT_AND_BACK',1280:'INVALID_ENUM',1281:'INVALID_VALUE',1282:'INVALID_OPERATION',1285:'OUT_OF_MEMORY',1286:'INVALID_FRAMEBUFFER_OPERATION',2304:'CW',2305:'CCW',2849:'LINE_WIDTH',2884:'CULL_FACE',2885:'CULL_FACE_MODE',2886:'FRONT_FACE',2928:'DEPTH_RANGE',2929:'DEPTH_TEST',2930:'DEPTH_WRITEMASK',2931:'DEPTH_CLEAR_VALUE',2932:'DEPTH_FUNC',2960:'STENCIL_TEST',2961:'STENCIL_CLEAR_VALUE',2962:'STENCIL_FUNC',2963:'STENCIL_VALUE_MASK',2964:'STENCIL_FAIL',2965:'STENCIL_PASS_DEPTH_FAIL',2966:'STENCIL_PASS_DEPTH_PASS',2967:'STENCIL_REF',2968:'STENCIL_WRITEMASK',2978:'VIEWPORT',3024:'DITHER',3042:'BLEND',3088:'SCISSOR_BOX',3089:'SCISSOR_TEST',3106:'COLOR_CLEAR_VALUE',3107:'COLOR_WRITEMASK',3317:'UNPACK_ALIGNMENT',3333:'PACK_ALIGNMENT',3379:'MAX_TEXTURE_SIZE',3386:'MAX_VIEWPORT_DIMS',3408:'SUBPIXEL_BITS',3410:'RED_BITS',3411:'GREEN_BITS',3412:'BLUE_BITS',3413:'ALPHA_BITS',3414:'DEPTH_BITS',3415:'STENCIL_BITS',3553:'TEXTURE_2D',4352:'DONT_CARE',4353:'FASTEST',4354:'NICEST',5120:'BYTE',5121:'UNSIGNED_BYTE',5122:'SHORT',5123:'UNSIGNED_SHORT',5124:'INT',5125:'UNSIGNED_INT',5126:'FLOAT',5386:'INVERT',5890:'TEXTURE',6401:'STENCIL_INDEX',6402:'DEPTH_COMPONENT',6406:'ALPHA',6407:'RGB',6408:'RGBA',6409:'LUMINANCE',6410:'LUMINANCE_ALPHA',7680:'KEEP',7681:'REPLACE',7682:'INCR',7683:'DECR',7936:'VENDOR',7937:'RENDERER',7938:'VERSION',9728:'NEAREST',9729:'LINEAR',9984:'NEAREST_MIPMAP_NEAREST',9985:'LINEAR_MIPMAP_NEAREST',9986:'NEAREST_MIPMAP_LINEAR',9987:'LINEAR_MIPMAP_LINEAR',10240:'TEXTURE_MAG_FILTER',10241:'TEXTURE_MIN_FILTER',10242:'TEXTURE_WRAP_S',10243:'TEXTURE_WRAP_T',10497:'REPEAT',10752:'POLYGON_OFFSET_UNITS',16384:'COLOR_BUFFER_BIT',32769:'CONSTANT_COLOR',32770:'ONE_MINUS_CONSTANT_COLOR',32771:'CONSTANT_ALPHA',32772:'ONE_MINUS_CONSTANT_ALPHA',32773:'BLEND_COLOR',32774:'FUNC_ADD',32777:'BLEND_EQUATION_RGB',32778:'FUNC_SUBTRACT',32779:'FUNC_REVERSE_SUBTRACT',32819:'UNSIGNED_SHORT_4_4_4_4',32820:'UNSIGNED_SHORT_5_5_5_1',32823:'POLYGON_OFFSET_FILL',32824:'POLYGON_OFFSET_FACTOR',32854:'RGBA4',32855:'RGB5_A1',32873:'TEXTURE_BINDING_2D',32926:'SAMPLE_ALPHA_TO_COVERAGE',32928:'SAMPLE_COVERAGE',32936:'SAMPLE_BUFFERS',32937:'SAMPLES',32938:'SAMPLE_COVERAGE_VALUE',32939:'SAMPLE_COVERAGE_INVERT',32968:'BLEND_DST_RGB',32969:'BLEND_SRC_RGB',32970:'BLEND_DST_ALPHA',32971:'BLEND_SRC_ALPHA',33071:'CLAMP_TO_EDGE',33170:'GENERATE_MIPMAP_HINT',33189:'DEPTH_COMPONENT16',33306:'DEPTH_STENCIL_ATTACHMENT',33635:'UNSIGNED_SHORT_5_6_5',33648:'MIRRORED_REPEAT',33901:'ALIASED_POINT_SIZE_RANGE',33902:'ALIASED_LINE_WIDTH_RANGE',33984:'TEXTURE0',33985:'TEXTURE1',33986:'TEXTURE2',33987:'TEXTURE3',33988:'TEXTURE4',33989:'TEXTURE5',33990:'TEXTURE6',33991:'TEXTURE7',33992:'TEXTURE8',33993:'TEXTURE9',33994:'TEXTURE10',33995:'TEXTURE11',33996:'TEXTURE12',33997:'TEXTURE13',33998:'TEXTURE14',33999:'TEXTURE15',34000:'TEXTURE16',34001:'TEXTURE17',34002:'TEXTURE18',34003:'TEXTURE19',34004:'TEXTURE20',34005:'TEXTURE21',34006:'TEXTURE22',34007:'TEXTURE23',34008:'TEXTURE24',34009:'TEXTURE25',34010:'TEXTURE26',34011:'TEXTURE27',34012:'TEXTURE28',34013:'TEXTURE29',34014:'TEXTURE30',34015:'TEXTURE31',34016:'ACTIVE_TEXTURE',34024:'MAX_RENDERBUFFER_SIZE',34041:'DEPTH_STENCIL',34055:'INCR_WRAP',34056:'DECR_WRAP',34067:'TEXTURE_CUBE_MAP',34068:'TEXTURE_BINDING_CUBE_MAP',34069:'TEXTURE_CUBE_MAP_POSITIVE_X',34070:'TEXTURE_CUBE_MAP_NEGATIVE_X',34071:'TEXTURE_CUBE_MAP_POSITIVE_Y',34072:'TEXTURE_CUBE_MAP_NEGATIVE_Y',34073:'TEXTURE_CUBE_MAP_POSITIVE_Z',34074:'TEXTURE_CUBE_MAP_NEGATIVE_Z',34076:'MAX_CUBE_MAP_TEXTURE_SIZE',34338:'VERTEX_ATTRIB_ARRAY_ENABLED',34339:'VERTEX_ATTRIB_ARRAY_SIZE',34340:'VERTEX_ATTRIB_ARRAY_STRIDE',34341:'VERTEX_ATTRIB_ARRAY_TYPE',34342:'CURRENT_VERTEX_ATTRIB',34373:'VERTEX_ATTRIB_ARRAY_POINTER',34466:'NUM_COMPRESSED_TEXTURE_FORMATS',34467:'COMPRESSED_TEXTURE_FORMATS',34660:'BUFFER_SIZE',34661:'BUFFER_USAGE',34816:'STENCIL_BACK_FUNC',34817:'STENCIL_BACK_FAIL',34818:'STENCIL_BACK_PASS_DEPTH_FAIL',34819:'STENCIL_BACK_PASS_DEPTH_PASS',34877:'BLEND_EQUATION_ALPHA',34921:'MAX_VERTEX_ATTRIBS',34922:'VERTEX_ATTRIB_ARRAY_NORMALIZED',34930:'MAX_TEXTURE_IMAGE_UNITS',34962:'ARRAY_BUFFER',34963:'ELEMENT_ARRAY_BUFFER',34964:'ARRAY_BUFFER_BINDING',34965:'ELEMENT_ARRAY_BUFFER_BINDING',34975:'VERTEX_ATTRIB_ARRAY_BUFFER_BINDING',35040:'STREAM_DRAW',35044:'STATIC_DRAW',35048:'DYNAMIC_DRAW',35632:'FRAGMENT_SHADER',35633:'VERTEX_SHADER',35660:'MAX_VERTEX_TEXTURE_IMAGE_UNITS',35661:'MAX_COMBINED_TEXTURE_IMAGE_UNITS',35663:'SHADER_TYPE',35664:'FLOAT_VEC2',35665:'FLOAT_VEC3',35666:'FLOAT_VEC4',35667:'INT_VEC2',35668:'INT_VEC3',35669:'INT_VEC4',35670:'BOOL',35671:'BOOL_VEC2',35672:'BOOL_VEC3',35673:'BOOL_VEC4',35674:'FLOAT_MAT2',35675:'FLOAT_MAT3',35676:'FLOAT_MAT4',35678:'SAMPLER_2D',35680:'SAMPLER_CUBE',35712:'DELETE_STATUS',35713:'COMPILE_STATUS',35714:'LINK_STATUS',35715:'VALIDATE_STATUS',35716:'INFO_LOG_LENGTH',35717:'ATTACHED_SHADERS',35718:'ACTIVE_UNIFORMS',35719:'ACTIVE_UNIFORM_MAX_LENGTH',35720:'SHADER_SOURCE_LENGTH',35721:'ACTIVE_ATTRIBUTES',35722:'ACTIVE_ATTRIBUTE_MAX_LENGTH',35724:'SHADING_LANGUAGE_VERSION',35725:'CURRENT_PROGRAM',36003:'STENCIL_BACK_REF',36004:'STENCIL_BACK_VALUE_MASK',36005:'STENCIL_BACK_WRITEMASK',36006:'FRAMEBUFFER_BINDING',36007:'RENDERBUFFER_BINDING',36048:'FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE',36049:'FRAMEBUFFER_ATTACHMENT_OBJECT_NAME',36050:'FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL',36051:'FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE',36053:'FRAMEBUFFER_COMPLETE',36054:'FRAMEBUFFER_INCOMPLETE_ATTACHMENT',36055:'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT',36057:'FRAMEBUFFER_INCOMPLETE_DIMENSIONS',36061:'FRAMEBUFFER_UNSUPPORTED',36064:'COLOR_ATTACHMENT0',36096:'DEPTH_ATTACHMENT',36128:'STENCIL_ATTACHMENT',36160:'FRAMEBUFFER',36161:'RENDERBUFFER',36162:'RENDERBUFFER_WIDTH',36163:'RENDERBUFFER_HEIGHT',36164:'RENDERBUFFER_INTERNAL_FORMAT',36168:'STENCIL_INDEX8',36176:'RENDERBUFFER_RED_SIZE',36177:'RENDERBUFFER_GREEN_SIZE',36178:'RENDERBUFFER_BLUE_SIZE',36179:'RENDERBUFFER_ALPHA_SIZE',36180:'RENDERBUFFER_DEPTH_SIZE',36181:'RENDERBUFFER_STENCIL_SIZE',36194:'RGB565',36336:'LOW_FLOAT',36337:'MEDIUM_FLOAT',36338:'HIGH_FLOAT',36339:'LOW_INT',36340:'MEDIUM_INT',36341:'HIGH_INT',36346:'SHADER_COMPILER',36347:'MAX_VERTEX_UNIFORM_VECTORS',36348:'MAX_VARYING_VECTORS',36349:'MAX_FRAGMENT_UNIFORM_VECTORS',37440:'UNPACK_FLIP_Y_WEBGL',37441:'UNPACK_PREMULTIPLY_ALPHA_WEBGL',37442:'CONTEXT_LOST_WEBGL',37443:'UNPACK_COLORSPACE_CONVERSION_WEBGL',37444:'BROWSER_DEFAULT_WEBGL'};/***/},/***/6603:/***/function(module,__unused_webpack_exports,__nested_webpack_require_309276__){var gl10=__nested_webpack_require_309276__(1950);module.exports=function lookupConstant(number){return gl10[number];};/***/},/***/3110:/***/function(module,__unused_webpack_exports,__nested_webpack_require_309464__){"use strict";module.exports=createErrorBars;var createBuffer=__nested_webpack_require_309464__(5827);var createVAO=__nested_webpack_require_309464__(2944);var createShader=__nested_webpack_require_309464__(7667);var IDENTITY=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];function ErrorBars(gl,buffer,vao,shader){this.gl=gl;this.shader=shader;this.buffer=buffer;this.vao=vao;this.pixelRatio=1;this.bounds=[[Infinity,Infinity,Infinity],[-Infinity,-Infinity,-Infinity]];this.clipBounds=[[-Infinity,-Infinity,-Infinity],[Infinity,Infinity,Infinity]];this.lineWidth=[1,1,1];this.capSize=[10,10,10];this.lineCount=[0,0,0];this.lineOffset=[0,0,0];this.opacity=1;this.hasAlpha=false;}var proto=ErrorBars.prototype;proto.isOpaque=function(){return!this.hasAlpha;};proto.isTransparent=function(){return this.hasAlpha;};proto.drawTransparent=proto.draw=function(cameraParams){var gl=this.gl;var uniforms=this.shader.uniforms;this.shader.bind();var view=uniforms.view=cameraParams.view||IDENTITY;var projection=uniforms.projection=cameraParams.projection||IDENTITY;uniforms.model=cameraParams.model||IDENTITY;uniforms.clipBounds=this.clipBounds;uniforms.opacity=this.opacity;var cx=view[12];var cy=view[13];var cz=view[14];var cw=view[15];var isOrtho=cameraParams._ortho||false;var orthoFix=isOrtho?2:1;// double up padding for orthographic ticks & labels
var pixelScaleF=orthoFix*this.pixelRatio*(projection[3]*cx+projection[7]*cy+projection[11]*cz+projection[15]*cw)/gl.drawingBufferHeight;this.vao.bind();for(var i=0;i<3;++i){gl.lineWidth(this.lineWidth[i]*this.pixelRatio);uniforms.capSize=this.capSize[i]*pixelScaleF;if(this.lineCount[i]){gl.drawArrays(gl.LINES,this.lineOffset[i],this.lineCount[i]);}}this.vao.unbind();};function updateBounds(bounds,point){for(var i=0;i<3;++i){bounds[0][i]=Math.min(bounds[0][i],point[i]);bounds[1][i]=Math.max(bounds[1][i],point[i]);}}var FACE_TABLE=function(){var table=new Array(3);for(var d=0;d<3;++d){var row=[];for(var j=1;j<=2;++j){for(var s=-1;s<=1;s+=2){var u=(j+d)%3;var y=[0,0,0];y[u]=s;row.push(y);}}table[d]=row;}return table;}();function emitFace(verts,x,c,d){var offsets=FACE_TABLE[d];for(var i=0;i<offsets.length;++i){var o=offsets[i];verts.push(x[0],x[1],x[2],c[0],c[1],c[2],c[3],o[0],o[1],o[2]);}return offsets.length;}proto.update=function(options){options=options||{};if('lineWidth'in options){this.lineWidth=options.lineWidth;if(!Array.isArray(this.lineWidth)){this.lineWidth=[this.lineWidth,this.lineWidth,this.lineWidth];}}if('capSize'in options){this.capSize=options.capSize;if(!Array.isArray(this.capSize)){this.capSize=[this.capSize,this.capSize,this.capSize];}}this.hasAlpha=false;// default to no transparent draw
if('opacity'in options){this.opacity=+options.opacity;if(this.opacity<1){this.hasAlpha=true;}}var color=options.color||[[0,0,0],[0,0,0],[0,0,0]];var position=options.position;var error=options.error;if(!Array.isArray(color[0])){color=[color,color,color];}if(position&&error){var verts=[];var n=position.length;var vertexCount=0;this.bounds=[[Infinity,Infinity,Infinity],[-Infinity,-Infinity,-Infinity]];this.lineCount=[0,0,0];//Build geometry for lines
for(var j=0;j<3;++j){this.lineOffset[j]=vertexCount;i_loop:for(var i=0;i<n;++i){var p=position[i];for(var k=0;k<3;++k){if(isNaN(p[k])||!isFinite(p[k])){continue i_loop;}}var e=error[i];var c=color[j];if(Array.isArray(c[0])){c=color[i];}if(c.length===3){c=[c[0],c[1],c[2],1];}else if(c.length===4){c=[c[0],c[1],c[2],c[3]];if(!this.hasAlpha&&c[3]<1)this.hasAlpha=true;}if(isNaN(e[0][j])||isNaN(e[1][j])){continue;}if(e[0][j]<0){var x=p.slice();x[j]+=e[0][j];verts.push(p[0],p[1],p[2],c[0],c[1],c[2],c[3],0,0,0,x[0],x[1],x[2],c[0],c[1],c[2],c[3],0,0,0);updateBounds(this.bounds,x);vertexCount+=2+emitFace(verts,x,c,j);}if(e[1][j]>0){var x=p.slice();x[j]+=e[1][j];verts.push(p[0],p[1],p[2],c[0],c[1],c[2],c[3],0,0,0,x[0],x[1],x[2],c[0],c[1],c[2],c[3],0,0,0);updateBounds(this.bounds,x);vertexCount+=2+emitFace(verts,x,c,j);}}this.lineCount[j]=vertexCount-this.lineOffset[j];}this.buffer.update(verts);}};proto.dispose=function(){this.shader.dispose();this.buffer.dispose();this.vao.dispose();};function createErrorBars(options){var gl=options.gl;var buffer=createBuffer(gl);var vao=createVAO(gl,[{buffer:buffer,type:gl.FLOAT,size:3,offset:0,stride:40},{buffer:buffer,type:gl.FLOAT,size:4,offset:12,stride:40},{buffer:buffer,type:gl.FLOAT,size:3,offset:28,stride:40}]);var shader=createShader(gl);shader.attributes.position.location=0;shader.attributes.color.location=1;shader.attributes.offset.location=2;var result=new ErrorBars(gl,buffer,vao,shader);result.update(options);return result;}/***/},/***/7667:/***/function(module,__unused_webpack_exports,__nested_webpack_require_314103__){"use strict";var glslify=__nested_webpack_require_314103__(6832);var createShader=__nested_webpack_require_314103__(5158);var vertSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nattribute vec3 position, offset;\nattribute vec4 color;\nuniform mat4 model, view, projection;\nuniform float capSize;\nvarying vec4 fragColor;\nvarying vec3 fragPosition;\n\nvoid main() {\n  vec4 worldPosition  = model * vec4(position, 1.0);\n  worldPosition       = (worldPosition / worldPosition.w) + vec4(capSize * offset, 0.0);\n  gl_Position         = projection * view * worldPosition;\n  fragColor           = color;\n  fragPosition        = position;\n}"]);var fragSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nuniform vec3 clipBounds[2];\nuniform float opacity;\nvarying vec3 fragPosition;\nvarying vec4 fragColor;\n\nvoid main() {\n  if (\n    outOfRange(clipBounds[0], clipBounds[1], fragPosition) ||\n    fragColor.a * opacity == 0.\n  ) discard;\n\n  gl_FragColor = opacity * fragColor;\n}"]);module.exports=function(gl){return createShader(gl,vertSrc,fragSrc,null,[{name:'position',type:'vec3'},{name:'color',type:'vec4'},{name:'offset',type:'vec3'}]);};/***/},/***/4234:/***/function(module,__unused_webpack_exports,__nested_webpack_require_315826__){"use strict";var createTexture=__nested_webpack_require_315826__(8931);module.exports=createFBO;var colorAttachmentArrays=null;var FRAMEBUFFER_UNSUPPORTED;var FRAMEBUFFER_INCOMPLETE_ATTACHMENT;var FRAMEBUFFER_INCOMPLETE_DIMENSIONS;var FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;function saveFBOState(gl){var fbo=gl.getParameter(gl.FRAMEBUFFER_BINDING);var rbo=gl.getParameter(gl.RENDERBUFFER_BINDING);var tex=gl.getParameter(gl.TEXTURE_BINDING_2D);return[fbo,rbo,tex];}function restoreFBOState(gl,data){gl.bindFramebuffer(gl.FRAMEBUFFER,data[0]);gl.bindRenderbuffer(gl.RENDERBUFFER,data[1]);gl.bindTexture(gl.TEXTURE_2D,data[2]);}function lazyInitColorAttachments(gl,ext){var maxColorAttachments=gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL);colorAttachmentArrays=new Array(maxColorAttachments+1);for(var i=0;i<=maxColorAttachments;++i){var x=new Array(maxColorAttachments);for(var j=0;j<i;++j){x[j]=gl.COLOR_ATTACHMENT0+j;}for(var j=i;j<maxColorAttachments;++j){x[j]=gl.NONE;}colorAttachmentArrays[i]=x;}}//Throw an appropriate error
function throwFBOError(status){switch(status){case FRAMEBUFFER_UNSUPPORTED:throw new Error('gl-fbo: Framebuffer unsupported');case FRAMEBUFFER_INCOMPLETE_ATTACHMENT:throw new Error('gl-fbo: Framebuffer incomplete attachment');case FRAMEBUFFER_INCOMPLETE_DIMENSIONS:throw new Error('gl-fbo: Framebuffer incomplete dimensions');case FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:throw new Error('gl-fbo: Framebuffer incomplete missing attachment');default:throw new Error('gl-fbo: Framebuffer failed for unspecified reason');}}//Initialize a texture object
function initTexture(gl,width,height,type,format,attachment){if(!type){return null;}var result=createTexture(gl,width,height,format,type);result.magFilter=gl.NEAREST;result.minFilter=gl.NEAREST;result.mipSamples=1;result.bind();gl.framebufferTexture2D(gl.FRAMEBUFFER,attachment,gl.TEXTURE_2D,result.handle,0);return result;}//Initialize a render buffer object
function initRenderBuffer(gl,width,height,component,attachment){var result=gl.createRenderbuffer();gl.bindRenderbuffer(gl.RENDERBUFFER,result);gl.renderbufferStorage(gl.RENDERBUFFER,component,width,height);gl.framebufferRenderbuffer(gl.FRAMEBUFFER,attachment,gl.RENDERBUFFER,result);return result;}//Rebuild the frame buffer
function rebuildFBO(fbo){//Save FBO state
var state=saveFBOState(fbo.gl);var gl=fbo.gl;var handle=fbo.handle=gl.createFramebuffer();var width=fbo._shape[0];var height=fbo._shape[1];var numColors=fbo.color.length;var ext=fbo._ext;var useStencil=fbo._useStencil;var useDepth=fbo._useDepth;var colorType=fbo._colorType;//Bind the fbo
gl.bindFramebuffer(gl.FRAMEBUFFER,handle);//Allocate color buffers
for(var i=0;i<numColors;++i){fbo.color[i]=initTexture(gl,width,height,colorType,gl.RGBA,gl.COLOR_ATTACHMENT0+i);}if(numColors===0){fbo._color_rb=initRenderBuffer(gl,width,height,gl.RGBA4,gl.COLOR_ATTACHMENT0);if(ext){ext.drawBuffersWEBGL(colorAttachmentArrays[0]);}}else if(numColors>1){ext.drawBuffersWEBGL(colorAttachmentArrays[numColors]);}//Allocate depth/stencil buffers
var WEBGL_depth_texture=gl.getExtension('WEBGL_depth_texture');if(WEBGL_depth_texture){if(useStencil){fbo.depth=initTexture(gl,width,height,WEBGL_depth_texture.UNSIGNED_INT_24_8_WEBGL,gl.DEPTH_STENCIL,gl.DEPTH_STENCIL_ATTACHMENT);}else if(useDepth){fbo.depth=initTexture(gl,width,height,gl.UNSIGNED_SHORT,gl.DEPTH_COMPONENT,gl.DEPTH_ATTACHMENT);}}else{if(useDepth&&useStencil){fbo._depth_rb=initRenderBuffer(gl,width,height,gl.DEPTH_STENCIL,gl.DEPTH_STENCIL_ATTACHMENT);}else if(useDepth){fbo._depth_rb=initRenderBuffer(gl,width,height,gl.DEPTH_COMPONENT16,gl.DEPTH_ATTACHMENT);}else if(useStencil){fbo._depth_rb=initRenderBuffer(gl,width,height,gl.STENCIL_INDEX,gl.STENCIL_ATTACHMENT);}}//Check frame buffer state
var status=gl.checkFramebufferStatus(gl.FRAMEBUFFER);if(status!==gl.FRAMEBUFFER_COMPLETE){//Release all partially allocated resources
fbo._destroyed=true;//Release all resources
gl.bindFramebuffer(gl.FRAMEBUFFER,null);gl.deleteFramebuffer(fbo.handle);fbo.handle=null;if(fbo.depth){fbo.depth.dispose();fbo.depth=null;}if(fbo._depth_rb){gl.deleteRenderbuffer(fbo._depth_rb);fbo._depth_rb=null;}for(var i=0;i<fbo.color.length;++i){fbo.color[i].dispose();fbo.color[i]=null;}if(fbo._color_rb){gl.deleteRenderbuffer(fbo._color_rb);fbo._color_rb=null;}restoreFBOState(gl,state);//Throw the frame buffer error
throwFBOError(status);}//Everything ok, let's get on with life
restoreFBOState(gl,state);}function Framebuffer(gl,width,height,colorType,numColors,useDepth,useStencil,ext){//Handle and set properties
this.gl=gl;this._shape=[width|0,height|0];this._destroyed=false;this._ext=ext;//Allocate buffers
this.color=new Array(numColors);for(var i=0;i<numColors;++i){this.color[i]=null;}this._color_rb=null;this.depth=null;this._depth_rb=null;//Save depth and stencil flags
this._colorType=colorType;this._useDepth=useDepth;this._useStencil=useStencil;//Shape vector for resizing
var parent=this;var shapeVector=[width|0,height|0];Object.defineProperties(shapeVector,{0:{get:function(){return parent._shape[0];},set:function(w){return parent.width=w;}},1:{get:function(){return parent._shape[1];},set:function(h){return parent.height=h;}}});this._shapeVector=shapeVector;//Initialize all attachments
rebuildFBO(this);}var proto=Framebuffer.prototype;function reshapeFBO(fbo,w,h){//If fbo is invalid, just skip this
if(fbo._destroyed){throw new Error('gl-fbo: Can\'t resize destroyed FBO');}//Don't resize if no change in shape
if(fbo._shape[0]===w&&fbo._shape[1]===h){return;}var gl=fbo.gl;//Check parameter ranges
var maxFBOSize=gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);if(w<0||w>maxFBOSize||h<0||h>maxFBOSize){throw new Error('gl-fbo: Can\'t resize FBO, invalid dimensions');}//Update shape
fbo._shape[0]=w;fbo._shape[1]=h;//Save framebuffer state
var state=saveFBOState(gl);//Resize framebuffer attachments
for(var i=0;i<fbo.color.length;++i){fbo.color[i].shape=fbo._shape;}if(fbo._color_rb){gl.bindRenderbuffer(gl.RENDERBUFFER,fbo._color_rb);gl.renderbufferStorage(gl.RENDERBUFFER,gl.RGBA4,fbo._shape[0],fbo._shape[1]);}if(fbo.depth){fbo.depth.shape=fbo._shape;}if(fbo._depth_rb){gl.bindRenderbuffer(gl.RENDERBUFFER,fbo._depth_rb);if(fbo._useDepth&&fbo._useStencil){gl.renderbufferStorage(gl.RENDERBUFFER,gl.DEPTH_STENCIL,fbo._shape[0],fbo._shape[1]);}else if(fbo._useDepth){gl.renderbufferStorage(gl.RENDERBUFFER,gl.DEPTH_COMPONENT16,fbo._shape[0],fbo._shape[1]);}else if(fbo._useStencil){gl.renderbufferStorage(gl.RENDERBUFFER,gl.STENCIL_INDEX,fbo._shape[0],fbo._shape[1]);}}//Check FBO status after resize, if something broke then die in a fire
gl.bindFramebuffer(gl.FRAMEBUFFER,fbo.handle);var status=gl.checkFramebufferStatus(gl.FRAMEBUFFER);if(status!==gl.FRAMEBUFFER_COMPLETE){fbo.dispose();restoreFBOState(gl,state);throwFBOError(status);}//Restore framebuffer state
restoreFBOState(gl,state);}Object.defineProperties(proto,{'shape':{get:function(){if(this._destroyed){return[0,0];}return this._shapeVector;},set:function(x){if(!Array.isArray(x)){x=[x|0,x|0];}if(x.length!==2){throw new Error('gl-fbo: Shape vector must be length 2');}var w=x[0]|0;var h=x[1]|0;reshapeFBO(this,w,h);return[w,h];},enumerable:false},'width':{get:function(){if(this._destroyed){return 0;}return this._shape[0];},set:function(w){w=w|0;reshapeFBO(this,w,this._shape[1]);return w;},enumerable:false},'height':{get:function(){if(this._destroyed){return 0;}return this._shape[1];},set:function(h){h=h|0;reshapeFBO(this,this._shape[0],h);return h;},enumerable:false}});proto.bind=function(){if(this._destroyed){return;}var gl=this.gl;gl.bindFramebuffer(gl.FRAMEBUFFER,this.handle);gl.viewport(0,0,this._shape[0],this._shape[1]);};proto.dispose=function(){if(this._destroyed){return;}this._destroyed=true;var gl=this.gl;gl.deleteFramebuffer(this.handle);this.handle=null;if(this.depth){this.depth.dispose();this.depth=null;}if(this._depth_rb){gl.deleteRenderbuffer(this._depth_rb);this._depth_rb=null;}for(var i=0;i<this.color.length;++i){this.color[i].dispose();this.color[i]=null;}if(this._color_rb){gl.deleteRenderbuffer(this._color_rb);this._color_rb=null;}};function createFBO(gl,width,height,options){//Update frame buffer error code values
if(!FRAMEBUFFER_UNSUPPORTED){FRAMEBUFFER_UNSUPPORTED=gl.FRAMEBUFFER_UNSUPPORTED;FRAMEBUFFER_INCOMPLETE_ATTACHMENT=gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT;FRAMEBUFFER_INCOMPLETE_DIMENSIONS=gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS;FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT=gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;}//Lazily initialize color attachment arrays
var WEBGL_draw_buffers=gl.getExtension('WEBGL_draw_buffers');if(!colorAttachmentArrays&&WEBGL_draw_buffers){lazyInitColorAttachments(gl,WEBGL_draw_buffers);}//Special case: Can accept an array as argument
if(Array.isArray(width)){options=height;height=width[1]|0;width=width[0]|0;}if(typeof width!=='number'){throw new Error('gl-fbo: Missing shape parameter');}//Validate width/height properties
var maxFBOSize=gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);if(width<0||width>maxFBOSize||height<0||height>maxFBOSize){throw new Error('gl-fbo: Parameters are too large for FBO');}//Handle each option type
options=options||{};//Figure out number of color buffers to use
var numColors=1;if('color'in options){numColors=Math.max(options.color|0,0);if(numColors<0){throw new Error('gl-fbo: Must specify a nonnegative number of colors');}if(numColors>1){//Check if multiple render targets supported
if(!WEBGL_draw_buffers){throw new Error('gl-fbo: Multiple draw buffer extension not supported');}else if(numColors>gl.getParameter(WEBGL_draw_buffers.MAX_COLOR_ATTACHMENTS_WEBGL)){throw new Error('gl-fbo: Context does not support '+numColors+' draw buffers');}}}//Determine whether to use floating point textures
var colorType=gl.UNSIGNED_BYTE;var OES_texture_float=gl.getExtension('OES_texture_float');if(options.float&&numColors>0){if(!OES_texture_float){throw new Error('gl-fbo: Context does not support floating point textures');}colorType=gl.FLOAT;}else if(options.preferFloat&&numColors>0){if(OES_texture_float){colorType=gl.FLOAT;}}//Check if we should use depth buffer
var useDepth=true;if('depth'in options){useDepth=!!options.depth;}//Check if we should use a stencil buffer
var useStencil=false;if('stencil'in options){useStencil=!!options.stencil;}return new Framebuffer(gl,width,height,colorType,numColors,useDepth,useStencil,WEBGL_draw_buffers);}/***/},/***/3530:/***/function(module,__unused_webpack_exports,__nested_webpack_require_326286__){var sprintf=__nested_webpack_require_326286__(8974).sprintf;var glConstants=__nested_webpack_require_326286__(6603);var shaderName=__nested_webpack_require_326286__(9365);var addLineNumbers=__nested_webpack_require_326286__(8008);module.exports=formatCompilerError;function formatCompilerError(errLog,src,type){"use strict";var name=shaderName(src)||'of unknown name (see npm glsl-shader-name)';var typeName='unknown type';if(type!==undefined){typeName=type===glConstants.FRAGMENT_SHADER?'fragment':'vertex';}var longForm=sprintf('Error compiling %s shader %s:\n',typeName,name);var shortForm=sprintf("%s%s",longForm,errLog);var errorStrings=errLog.split('\n');var errors={};for(var i=0;i<errorStrings.length;i++){var errorString=errorStrings[i];if(errorString===''||errorString==="\0")continue;var lineNo=parseInt(errorString.split(':')[2]);if(isNaN(lineNo)){throw new Error(sprintf('Could not parse error: %s',errorString));}errors[lineNo]=errorString;}var lines=addLineNumbers(src).split('\n');for(var i=0;i<lines.length;i++){if(!errors[i+3]&&!errors[i+2]&&!errors[i+1])continue;var line=lines[i];longForm+=line+'\n';if(errors[i+1]){var e=errors[i+1];e=e.substr(e.split(':',3).join(':').length+1).trim();longForm+=sprintf('^^^ %s\n\n',e);}}return{long:longForm.trim(),short:shortForm.trim()};}/***/},/***/6386:/***/function(module,__unused_webpack_exports,__nested_webpack_require_327610__){"use strict";module.exports=createHeatmap2D;var bsearch=__nested_webpack_require_327610__(5070);var iota=__nested_webpack_require_327610__(9560);var pool=__nested_webpack_require_327610__(5306);var createShader=__nested_webpack_require_327610__(5158);var createBuffer=__nested_webpack_require_327610__(5827);var shaders=__nested_webpack_require_327610__(1292);function GLHeatmap2D(plot,shader,pickShader,positionBuffer,weightBuffer,colorBuffer,idBuffer){this.plot=plot;this.shader=shader;this.pickShader=pickShader;this.positionBuffer=positionBuffer;this.weightBuffer=weightBuffer;this.colorBuffer=colorBuffer;this.idBuffer=idBuffer;this.xData=[];this.yData=[];this.shape=[0,0];this.bounds=[Infinity,Infinity,-Infinity,-Infinity];this.pickOffset=0;}var proto=GLHeatmap2D.prototype;var WEIGHTS=[0,0,1,0,0,1,1,0,1,1,0,1];proto.draw=function(){var MATRIX=[1,0,0,0,1,0,0,0,1];return function(){var plot=this.plot;var shader=this.shader;var bounds=this.bounds;var numVertices=this.numVertices;if(numVertices<=0){return;}var gl=plot.gl;var dataBox=plot.dataBox;var boundX=bounds[2]-bounds[0];var boundY=bounds[3]-bounds[1];var dataX=dataBox[2]-dataBox[0];var dataY=dataBox[3]-dataBox[1];MATRIX[0]=2.0*boundX/dataX;MATRIX[4]=2.0*boundY/dataY;MATRIX[6]=2.0*(bounds[0]-dataBox[0])/dataX-1.0;MATRIX[7]=2.0*(bounds[1]-dataBox[1])/dataY-1.0;shader.bind();var uniforms=shader.uniforms;uniforms.viewTransform=MATRIX;uniforms.shape=this.shape;var attributes=shader.attributes;this.positionBuffer.bind();attributes.position.pointer();this.weightBuffer.bind();attributes.weight.pointer(gl.UNSIGNED_BYTE,false);this.colorBuffer.bind();attributes.color.pointer(gl.UNSIGNED_BYTE,true);gl.drawArrays(gl.TRIANGLES,0,numVertices);};}();proto.drawPick=function(){var MATRIX=[1,0,0,0,1,0,0,0,1];var PICK_VECTOR=[0,0,0,0];return function(pickOffset){var plot=this.plot;var shader=this.pickShader;var bounds=this.bounds;var numVertices=this.numVertices;if(numVertices<=0){return;}var gl=plot.gl;var dataBox=plot.dataBox;var boundX=bounds[2]-bounds[0];var boundY=bounds[3]-bounds[1];var dataX=dataBox[2]-dataBox[0];var dataY=dataBox[3]-dataBox[1];MATRIX[0]=2.0*boundX/dataX;MATRIX[4]=2.0*boundY/dataY;MATRIX[6]=2.0*(bounds[0]-dataBox[0])/dataX-1.0;MATRIX[7]=2.0*(bounds[1]-dataBox[1])/dataY-1.0;for(var i=0;i<4;++i){PICK_VECTOR[i]=pickOffset>>i*8&0xff;}this.pickOffset=pickOffset;shader.bind();var uniforms=shader.uniforms;uniforms.viewTransform=MATRIX;uniforms.pickOffset=PICK_VECTOR;uniforms.shape=this.shape;var attributes=shader.attributes;this.positionBuffer.bind();attributes.position.pointer();this.weightBuffer.bind();attributes.weight.pointer(gl.UNSIGNED_BYTE,false);this.idBuffer.bind();attributes.pickId.pointer(gl.UNSIGNED_BYTE,false);gl.drawArrays(gl.TRIANGLES,0,numVertices);return pickOffset+this.shape[0]*this.shape[1];};}();proto.pick=function(x,y,value){var pickOffset=this.pickOffset;var pointCount=this.shape[0]*this.shape[1];if(value<pickOffset||value>=pickOffset+pointCount){return null;}var pointId=value-pickOffset;var xData=this.xData;var yData=this.yData;return{object:this,pointId:pointId,dataCoord:[xData[pointId%this.shape[0]],yData[pointId/this.shape[0]|0]]};};proto.update=function(options){options=options||{};var shape=options.shape||[0,0];var x=options.x||iota(shape[0]);var y=options.y||iota(shape[1]);var z=options.z||new Float32Array(shape[0]*shape[1]);var isSmooth=options.zsmooth!==false;this.xData=x;this.yData=y;var colorLevels=options.colorLevels||[0];var colorValues=options.colorValues||[0,0,0,1];var colorCount=colorLevels.length;var bounds=this.bounds;var lox,loy,hix,hiy;if(isSmooth){lox=bounds[0]=x[0];loy=bounds[1]=y[0];hix=bounds[2]=x[x.length-1];hiy=bounds[3]=y[y.length-1];}else{// To get squares to centre on data values
lox=bounds[0]=x[0]+(x[1]-x[0])/2;// starting x value
loy=bounds[1]=y[0]+(y[1]-y[0])/2;// starting y value
// Bounds needs to add half a square on each end
hix=bounds[2]=x[x.length-1]+(x[x.length-1]-x[x.length-2])/2;hiy=bounds[3]=y[y.length-1]+(y[y.length-1]-y[y.length-2])/2;// N.B. Resolution = 1 / range
}var xs=1.0/(hix-lox);var ys=1.0/(hiy-loy);var numX=shape[0];var numY=shape[1];this.shape=[numX,numY];var numVerts=(isSmooth?(numX-1)*(numY-1):numX*numY)*(WEIGHTS.length>>>1);this.numVertices=numVerts;var colors=pool.mallocUint8(numVerts*4);var positions=pool.mallocFloat32(numVerts*2);var weights=pool.mallocUint8(numVerts*2);var ids=pool.mallocUint32(numVerts);var ptr=0;var ni=isSmooth?numX-1:numX;var nj=isSmooth?numY-1:numY;for(var j=0;j<nj;++j){var yc0,yc1;if(isSmooth){yc0=ys*(y[j]-loy);yc1=ys*(y[j+1]-loy);}else{yc0=j<numY-1?ys*(y[j]-(y[j+1]-y[j])/2-loy):ys*(y[j]-(y[j]-y[j-1])/2-loy);yc1=j<numY-1?ys*(y[j]+(y[j+1]-y[j])/2-loy):ys*(y[j]+(y[j]-y[j-1])/2-loy);}for(var i=0;i<ni;++i){var xc0,xc1;if(isSmooth){xc0=xs*(x[i]-lox);xc1=xs*(x[i+1]-lox);}else{xc0=i<numX-1?xs*(x[i]-(x[i+1]-x[i])/2-lox):xs*(x[i]-(x[i]-x[i-1])/2-lox);xc1=i<numX-1?xs*(x[i]+(x[i+1]-x[i])/2-lox):xs*(x[i]+(x[i]-x[i-1])/2-lox);}for(var dd=0;dd<WEIGHTS.length;dd+=2){var dx=WEIGHTS[dd];var dy=WEIGHTS[dd+1];var offset=isSmooth?(j+dy)*numX+(i+dx):j*numX+i;var zc=z[offset];var colorIdx=bsearch.le(colorLevels,zc);var r,g,b,a;if(colorIdx<0){r=colorValues[0];g=colorValues[1];b=colorValues[2];a=colorValues[3];}else if(colorIdx===colorCount-1){r=colorValues[4*colorCount-4];g=colorValues[4*colorCount-3];b=colorValues[4*colorCount-2];a=colorValues[4*colorCount-1];}else{var t=(zc-colorLevels[colorIdx])/(colorLevels[colorIdx+1]-colorLevels[colorIdx]);var ti=1.0-t;var i0=4*colorIdx;var i1=4*(colorIdx+1);r=ti*colorValues[i0]+t*colorValues[i1];g=ti*colorValues[i0+1]+t*colorValues[i1+1];b=ti*colorValues[i0+2]+t*colorValues[i1+2];a=ti*colorValues[i0+3]+t*colorValues[i1+3];}colors[4*ptr]=255*r;colors[4*ptr+1]=255*g;colors[4*ptr+2]=255*b;colors[4*ptr+3]=255*a;positions[2*ptr]=xc0*.5+xc1*.5;positions[2*ptr+1]=yc0*.5+yc1*.5;weights[2*ptr]=dx;weights[2*ptr+1]=dy;ids[ptr]=j*numX+i;ptr+=1;}}}this.positionBuffer.update(positions);this.weightBuffer.update(weights);this.colorBuffer.update(colors);this.idBuffer.update(ids);pool.free(positions);pool.free(colors);pool.free(weights);pool.free(ids);};proto.dispose=function(){this.shader.dispose();this.pickShader.dispose();this.positionBuffer.dispose();this.weightBuffer.dispose();this.colorBuffer.dispose();this.idBuffer.dispose();this.plot.removeObject(this);};function createHeatmap2D(plot,options){var gl=plot.gl;var shader=createShader(gl,shaders.vertex,shaders.fragment);var pickShader=createShader(gl,shaders.pickVertex,shaders.pickFragment);var positionBuffer=createBuffer(gl);var weightBuffer=createBuffer(gl);var colorBuffer=createBuffer(gl);var idBuffer=createBuffer(gl);var heatmap=new GLHeatmap2D(plot,shader,pickShader,positionBuffer,weightBuffer,colorBuffer,idBuffer);heatmap.update(options);plot.addObject(heatmap);return heatmap;}/***/},/***/1292:/***/function(module,__unused_webpack_exports,__nested_webpack_require_334426__){"use strict";var glslify=__nested_webpack_require_334426__(6832);module.exports={fragment:glslify(["precision lowp float;\n#define GLSLIFY 1\nvarying vec4 fragColor;\nvoid main() {\n  gl_FragColor = vec4(fragColor.rgb * fragColor.a, fragColor.a);\n}\n"]),vertex:glslify(["precision mediump float;\n#define GLSLIFY 1\n\nattribute vec2 position;\nattribute vec4 color;\nattribute vec2 weight;\n\nuniform vec2 shape;\nuniform mat3 viewTransform;\n\nvarying vec4 fragColor;\n\nvoid main() {\n  vec3 vPosition = viewTransform * vec3( position + (weight-.5)/(shape-1.) , 1.0);\n  fragColor = color;\n  gl_Position = vec4(vPosition.xy, 0, vPosition.z);\n}\n"]),pickFragment:glslify(["precision mediump float;\n#define GLSLIFY 1\n\nvarying vec4 fragId;\nvarying vec2 vWeight;\n\nuniform vec2 shape;\nuniform vec4 pickOffset;\n\nvoid main() {\n  vec2 d = step(.5, vWeight);\n  vec4 id = fragId + pickOffset;\n  id.x += d.x + d.y*shape.x;\n\n  id.y += floor(id.x / 256.0);\n  id.x -= floor(id.x / 256.0) * 256.0;\n\n  id.z += floor(id.y / 256.0);\n  id.y -= floor(id.y / 256.0) * 256.0;\n\n  id.w += floor(id.z / 256.0);\n  id.z -= floor(id.z / 256.0) * 256.0;\n\n  gl_FragColor = id/255.;\n}\n"]),pickVertex:glslify(["precision mediump float;\n#define GLSLIFY 1\n\nattribute vec2 position;\nattribute vec4 pickId;\nattribute vec2 weight;\n\nuniform vec2 shape;\nuniform mat3 viewTransform;\n\nvarying vec4 fragId;\nvarying vec2 vWeight;\n\nvoid main() {\n  vWeight = weight;\n\n  fragId = pickId;\n\n  vec3 vPosition = viewTransform * vec3( position + (weight-.5)/(shape-1.) , 1.0);\n  gl_Position = vec4(vPosition.xy, 0, vPosition.z);\n}\n"])};/***/},/***/248:/***/function(__unused_webpack_module,exports,__nested_webpack_require_336131__){var glslify=__nested_webpack_require_336131__(6832);var createShader=__nested_webpack_require_336131__(5158);var vertSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nattribute vec3 position, nextPosition;\nattribute float arcLength, lineWidth;\nattribute vec4 color;\n\nuniform vec2 screenShape;\nuniform float pixelRatio;\nuniform mat4 model, view, projection;\n\nvarying vec4 fragColor;\nvarying vec3 worldPosition;\nvarying float pixelArcLength;\n\nvec4 project(vec3 p) {\n  return projection * view * model * vec4(p, 1.0);\n}\n\nvoid main() {\n  vec4 startPoint = project(position);\n  vec4 endPoint   = project(nextPosition);\n\n  vec2 A = startPoint.xy / startPoint.w;\n  vec2 B =   endPoint.xy /   endPoint.w;\n\n  float clipAngle = atan(\n    (B.y - A.y) * screenShape.y,\n    (B.x - A.x) * screenShape.x\n  );\n\n  vec2 offset = 0.5 * pixelRatio * lineWidth * vec2(\n    sin(clipAngle),\n    -cos(clipAngle)\n  ) / screenShape;\n\n  gl_Position = vec4(startPoint.xy + startPoint.w * offset, startPoint.zw);\n\n  worldPosition = position;\n  pixelArcLength = arcLength;\n  fragColor = color;\n}\n"]);var forwardFrag=glslify(["precision highp float;\n#define GLSLIFY 1\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nuniform vec3      clipBounds[2];\nuniform sampler2D dashTexture;\nuniform float     dashScale;\nuniform float     opacity;\n\nvarying vec3    worldPosition;\nvarying float   pixelArcLength;\nvarying vec4    fragColor;\n\nvoid main() {\n  if (\n    outOfRange(clipBounds[0], clipBounds[1], worldPosition) ||\n    fragColor.a * opacity == 0.\n  ) discard;\n\n  float dashWeight = texture2D(dashTexture, vec2(dashScale * pixelArcLength, 0)).r;\n  if(dashWeight < 0.5) {\n    discard;\n  }\n  gl_FragColor = fragColor * opacity;\n}\n"]);var pickFrag=glslify(["precision highp float;\n#define GLSLIFY 1\n\n#define FLOAT_MAX  1.70141184e38\n#define FLOAT_MIN  1.17549435e-38\n\n// https://github.com/mikolalysenko/glsl-read-float/blob/master/index.glsl\nvec4 packFloat(float v) {\n  float av = abs(v);\n\n  //Handle special cases\n  if(av < FLOAT_MIN) {\n    return vec4(0.0, 0.0, 0.0, 0.0);\n  } else if(v > FLOAT_MAX) {\n    return vec4(127.0, 128.0, 0.0, 0.0) / 255.0;\n  } else if(v < -FLOAT_MAX) {\n    return vec4(255.0, 128.0, 0.0, 0.0) / 255.0;\n  }\n\n  vec4 c = vec4(0,0,0,0);\n\n  //Compute exponent and mantissa\n  float e = floor(log2(av));\n  float m = av * pow(2.0, -e) - 1.0;\n\n  //Unpack mantissa\n  c[1] = floor(128.0 * m);\n  m -= c[1] / 128.0;\n  c[2] = floor(32768.0 * m);\n  m -= c[2] / 32768.0;\n  c[3] = floor(8388608.0 * m);\n\n  //Unpack exponent\n  float ebias = e + 127.0;\n  c[0] = floor(ebias / 2.0);\n  ebias -= c[0] * 2.0;\n  c[1] += floor(ebias) * 128.0;\n\n  //Unpack sign bit\n  c[0] += 128.0 * step(0.0, -v);\n\n  //Scale back to range\n  return c / 255.0;\n}\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nuniform float pickId;\nuniform vec3 clipBounds[2];\n\nvarying vec3 worldPosition;\nvarying float pixelArcLength;\nvarying vec4 fragColor;\n\nvoid main() {\n  if (outOfRange(clipBounds[0], clipBounds[1], worldPosition)) discard;\n\n  gl_FragColor = vec4(pickId/255.0, packFloat(pixelArcLength).xyz);\n}"]);var ATTRIBUTES=[{name:'position',type:'vec3'},{name:'nextPosition',type:'vec3'},{name:'arcLength',type:'float'},{name:'lineWidth',type:'float'},{name:'color',type:'vec4'}];exports.createShader=function(gl){return createShader(gl,vertSrc,forwardFrag,null,ATTRIBUTES);};exports.createPickShader=function(gl){return createShader(gl,vertSrc,pickFrag,null,ATTRIBUTES);};/***/},/***/6086:/***/function(module,__unused_webpack_exports,__nested_webpack_require_340632__){"use strict";module.exports=createLinePlot;var createBuffer=__nested_webpack_require_340632__(5827);var createVAO=__nested_webpack_require_340632__(2944);var createTexture=__nested_webpack_require_340632__(8931);var UINT8_VIEW=new Uint8Array(4);var FLOAT_VIEW=new Float32Array(UINT8_VIEW.buffer);// https://github.com/mikolalysenko/glsl-read-float/blob/master/index.js
function unpackFloat(x,y,z,w){UINT8_VIEW[0]=w;UINT8_VIEW[1]=z;UINT8_VIEW[2]=y;UINT8_VIEW[3]=x;return FLOAT_VIEW[0];}var bsearch=__nested_webpack_require_340632__(5070);var ndarray=__nested_webpack_require_340632__(5050);var shaders=__nested_webpack_require_340632__(248);var createShader=shaders.createShader;var createPickShader=shaders.createPickShader;var identity=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];function distance(a,b){var s=0.0;for(var i=0;i<3;++i){var d=a[i]-b[i];s+=d*d;}return Math.sqrt(s);}function filterClipBounds(bounds){var result=[[-1e6,-1e6,-1e6],[1e6,1e6,1e6]];for(var i=0;i<3;++i){result[0][i]=Math.max(bounds[0][i],result[0][i]);result[1][i]=Math.min(bounds[1][i],result[1][i]);}return result;}function PickResult(tau,position,index,dataCoordinate){this.arcLength=tau;this.position=position;this.index=index;this.dataCoordinate=dataCoordinate;}function LinePlot(gl,shader,pickShader,buffer,vao,texture){this.gl=gl;this.shader=shader;this.pickShader=pickShader;this.buffer=buffer;this.vao=vao;this.clipBounds=[[-Infinity,-Infinity,-Infinity],[Infinity,Infinity,Infinity]];this.points=[];this.arcLength=[];this.vertexCount=0;this.bounds=[[0,0,0],[0,0,0]];this.pickId=0;this.lineWidth=1;this.texture=texture;this.dashScale=1;this.opacity=1;this.hasAlpha=false;this.dirty=true;this.pixelRatio=1;}var proto=LinePlot.prototype;proto.isTransparent=function(){return this.hasAlpha;};proto.isOpaque=function(){return!this.hasAlpha;};proto.pickSlots=1;proto.setPickBase=function(id){this.pickId=id;};proto.drawTransparent=proto.draw=function(camera){if(!this.vertexCount)return;var gl=this.gl;var shader=this.shader;var vao=this.vao;shader.bind();shader.uniforms={model:camera.model||identity,view:camera.view||identity,projection:camera.projection||identity,clipBounds:filterClipBounds(this.clipBounds),dashTexture:this.texture.bind(),dashScale:this.dashScale/this.arcLength[this.arcLength.length-1],opacity:this.opacity,screenShape:[gl.drawingBufferWidth,gl.drawingBufferHeight],pixelRatio:this.pixelRatio};vao.bind();vao.draw(gl.TRIANGLE_STRIP,this.vertexCount);vao.unbind();};proto.drawPick=function(camera){if(!this.vertexCount)return;var gl=this.gl;var shader=this.pickShader;var vao=this.vao;shader.bind();shader.uniforms={model:camera.model||identity,view:camera.view||identity,projection:camera.projection||identity,pickId:this.pickId,clipBounds:filterClipBounds(this.clipBounds),screenShape:[gl.drawingBufferWidth,gl.drawingBufferHeight],pixelRatio:this.pixelRatio};vao.bind();vao.draw(gl.TRIANGLE_STRIP,this.vertexCount);vao.unbind();};proto.update=function(options){var i,j;this.dirty=true;var connectGaps=!!options.connectGaps;if('dashScale'in options){this.dashScale=options.dashScale;}this.hasAlpha=false;// default to no transparent draw
if('opacity'in options){this.opacity=+options.opacity;if(this.opacity<1){this.hasAlpha=true;}}// Recalculate buffer data
var buffer=[];var arcLengthArray=[];var pointArray=[];var arcLength=0.0;var vertexCount=0;var bounds=[[Infinity,Infinity,Infinity],[-Infinity,-Infinity,-Infinity]];var positions=options.position||options.positions;if(positions){// Default color
var colors=options.color||options.colors||[0,0,0,1];var lineWidth=options.lineWidth||1;var hadGap=false;fill_loop:for(i=1;i<positions.length;++i){var a=positions[i-1];var b=positions[i];arcLengthArray.push(arcLength);pointArray.push(a.slice());for(j=0;j<3;++j){if(isNaN(a[j])||isNaN(b[j])||!isFinite(a[j])||!isFinite(b[j])){if(!connectGaps&&buffer.length>0){for(var k=0;k<24;++k){buffer.push(buffer[buffer.length-12]);}vertexCount+=2;hadGap=true;}continue fill_loop;}bounds[0][j]=Math.min(bounds[0][j],a[j],b[j]);bounds[1][j]=Math.max(bounds[1][j],a[j],b[j]);}var acolor,bcolor;if(Array.isArray(colors[0])){acolor=colors.length>i-1?colors[i-1]:// using index value
colors.length>0?colors[colors.length-1]:// using last item
[0,0,0,1];// using black
bcolor=colors.length>i?colors[i]:// using index value
colors.length>0?colors[colors.length-1]:// using last item
[0,0,0,1];// using black
}else{acolor=bcolor=colors;}if(acolor.length===3){acolor=[acolor[0],acolor[1],acolor[2],1];}if(bcolor.length===3){bcolor=[bcolor[0],bcolor[1],bcolor[2],1];}if(!this.hasAlpha&&acolor[3]<1)this.hasAlpha=true;var w0;if(Array.isArray(lineWidth)){w0=lineWidth.length>i-1?lineWidth[i-1]:// using index value
lineWidth.length>0?lineWidth[lineWidth.length-1]:// using last item
[0,0,0,1];// using black
}else{w0=lineWidth;}var t0=arcLength;arcLength+=distance(a,b);if(hadGap){for(j=0;j<2;++j){buffer.push(a[0],a[1],a[2],b[0],b[1],b[2],t0,w0,acolor[0],acolor[1],acolor[2],acolor[3]);}vertexCount+=2;hadGap=false;}buffer.push(a[0],a[1],a[2],b[0],b[1],b[2],t0,w0,acolor[0],acolor[1],acolor[2],acolor[3],a[0],a[1],a[2],b[0],b[1],b[2],t0,-w0,acolor[0],acolor[1],acolor[2],acolor[3],b[0],b[1],b[2],a[0],a[1],a[2],arcLength,-w0,bcolor[0],bcolor[1],bcolor[2],bcolor[3],b[0],b[1],b[2],a[0],a[1],a[2],arcLength,w0,bcolor[0],bcolor[1],bcolor[2],bcolor[3]);vertexCount+=4;}}this.buffer.update(buffer);arcLengthArray.push(arcLength);pointArray.push(positions[positions.length-1].slice());this.bounds=bounds;this.vertexCount=vertexCount;this.points=pointArray;this.arcLength=arcLengthArray;if('dashes'in options){var dashArray=options.dashes;// Calculate prefix sum
var prefixSum=dashArray.slice();prefixSum.unshift(0);for(i=1;i<prefixSum.length;++i){prefixSum[i]=prefixSum[i-1]+prefixSum[i];}var dashTexture=ndarray(new Array(256*4),[256,1,4]);for(i=0;i<256;++i){for(j=0;j<4;++j){dashTexture.set(i,0,j,0);}if(bsearch.le(prefixSum,prefixSum[prefixSum.length-1]*i/255.0)&1){dashTexture.set(i,0,0,0);}else{dashTexture.set(i,0,0,255);}}this.texture.setPixels(dashTexture);}};proto.dispose=function(){this.shader.dispose();this.vao.dispose();this.buffer.dispose();};proto.pick=function(selection){if(!selection){return null;}if(selection.id!==this.pickId){return null;}var tau=unpackFloat(selection.value[0],selection.value[1],selection.value[2],0);var index=bsearch.le(this.arcLength,tau);if(index<0){return null;}if(index===this.arcLength.length-1){return new PickResult(this.arcLength[this.arcLength.length-1],this.points[this.points.length-1].slice(),index);}var a=this.points[index];var b=this.points[Math.min(index+1,this.points.length-1)];var t=(tau-this.arcLength[index])/(this.arcLength[index+1]-this.arcLength[index]);var ti=1.0-t;var x=[0,0,0];for(var i=0;i<3;++i){x[i]=ti*a[i]+t*b[i];}var dataIndex=Math.min(t<0.5?index:index+1,this.points.length-1);return new PickResult(tau,x,dataIndex,this.points[dataIndex]);};function createLinePlot(options){var gl=options.gl||options.scene&&options.scene.gl;var shader=createShader(gl);shader.attributes.position.location=0;shader.attributes.nextPosition.location=1;shader.attributes.arcLength.location=2;shader.attributes.lineWidth.location=3;shader.attributes.color.location=4;var pickShader=createPickShader(gl);pickShader.attributes.position.location=0;pickShader.attributes.nextPosition.location=1;pickShader.attributes.arcLength.location=2;pickShader.attributes.lineWidth.location=3;pickShader.attributes.color.location=4;var buffer=createBuffer(gl);var vao=createVAO(gl,[{'buffer':buffer,'size':3,'offset':0,'stride':48},{'buffer':buffer,'size':3,'offset':12,'stride':48},{'buffer':buffer,'size':1,'offset':24,'stride':48},{'buffer':buffer,'size':1,'offset':28,'stride':48},{'buffer':buffer,'size':4,'offset':32,'stride':48}]);// Create texture for dash pattern
var defaultTexture=ndarray(new Array(256*4),[256,1,4]);for(var i=0;i<256*4;++i){defaultTexture.data[i]=255;}var texture=createTexture(gl,defaultTexture);texture.wrap=gl.REPEAT;var linePlot=new LinePlot(gl,shader,pickShader,buffer,vao,texture);linePlot.update(options);return linePlot;}/***/},/***/7332:/***/function(module){module.exports=clone;/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */function clone(a){var out=new Float32Array(16);out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];out[4]=a[4];out[5]=a[5];out[6]=a[6];out[7]=a[7];out[8]=a[8];out[9]=a[9];out[10]=a[10];out[11]=a[11];out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15];return out;};/***/},/***/9823:/***/function(module){module.exports=create;/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */function create(){var out=new Float32Array(16);out[0]=1;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=1;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=1;out[11]=0;out[12]=0;out[13]=0;out[14]=0;out[15]=1;return out;};/***/},/***/7787:/***/function(module){module.exports=determinant;/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */function determinant(a){var a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11],a30=a[12],a31=a[13],a32=a[14],a33=a[15],b00=a00*a11-a01*a10,b01=a00*a12-a02*a10,b02=a00*a13-a03*a10,b03=a01*a12-a02*a11,b04=a01*a13-a03*a11,b05=a02*a13-a03*a12,b06=a20*a31-a21*a30,b07=a20*a32-a22*a30,b08=a20*a33-a23*a30,b09=a21*a32-a22*a31,b10=a21*a33-a23*a31,b11=a22*a33-a23*a32;// Calculate the determinant
return b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;};/***/},/***/5950:/***/function(module){module.exports=fromQuat;/**
 * Creates a matrix from a quaternion rotation.
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @returns {mat4} out
 */function fromQuat(out,q){var x=q[0],y=q[1],z=q[2],w=q[3],x2=x+x,y2=y+y,z2=z+z,xx=x*x2,yx=y*x2,yy=y*y2,zx=z*x2,zy=z*y2,zz=z*z2,wx=w*x2,wy=w*y2,wz=w*z2;out[0]=1-yy-zz;out[1]=yx+wz;out[2]=zx-wy;out[3]=0;out[4]=yx-wz;out[5]=1-xx-zz;out[6]=zy+wx;out[7]=0;out[8]=zx+wy;out[9]=zy-wx;out[10]=1-xx-yy;out[11]=0;out[12]=0;out[13]=0;out[14]=0;out[15]=1;return out;};/***/},/***/7280:/***/function(module){module.exports=fromRotationTranslation;/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */function fromRotationTranslation(out,q,v){// Quaternion math
var x=q[0],y=q[1],z=q[2],w=q[3],x2=x+x,y2=y+y,z2=z+z,xx=x*x2,xy=x*y2,xz=x*z2,yy=y*y2,yz=y*z2,zz=z*z2,wx=w*x2,wy=w*y2,wz=w*z2;out[0]=1-(yy+zz);out[1]=xy+wz;out[2]=xz-wy;out[3]=0;out[4]=xy-wz;out[5]=1-(xx+zz);out[6]=yz+wx;out[7]=0;out[8]=xz+wy;out[9]=yz-wx;out[10]=1-(xx+yy);out[11]=0;out[12]=v[0];out[13]=v[1];out[14]=v[2];out[15]=1;return out;};/***/},/***/9947:/***/function(module){module.exports=identity;/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */function identity(out){out[0]=1;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=1;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=1;out[11]=0;out[12]=0;out[13]=0;out[14]=0;out[15]=1;return out;};/***/},/***/7437:/***/function(module){module.exports=invert;/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */function invert(out,a){var a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11],a30=a[12],a31=a[13],a32=a[14],a33=a[15],b00=a00*a11-a01*a10,b01=a00*a12-a02*a10,b02=a00*a13-a03*a10,b03=a01*a12-a02*a11,b04=a01*a13-a03*a11,b05=a02*a13-a03*a12,b06=a20*a31-a21*a30,b07=a20*a32-a22*a30,b08=a20*a33-a23*a30,b09=a21*a32-a22*a31,b10=a21*a33-a23*a31,b11=a22*a33-a23*a32,// Calculate the determinant
det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;if(!det){return null;}det=1.0/det;out[0]=(a11*b11-a12*b10+a13*b09)*det;out[1]=(a02*b10-a01*b11-a03*b09)*det;out[2]=(a31*b05-a32*b04+a33*b03)*det;out[3]=(a22*b04-a21*b05-a23*b03)*det;out[4]=(a12*b08-a10*b11-a13*b07)*det;out[5]=(a00*b11-a02*b08+a03*b07)*det;out[6]=(a32*b02-a30*b05-a33*b01)*det;out[7]=(a20*b05-a22*b02+a23*b01)*det;out[8]=(a10*b10-a11*b08+a13*b06)*det;out[9]=(a01*b08-a00*b10-a03*b06)*det;out[10]=(a30*b04-a31*b02+a33*b00)*det;out[11]=(a21*b02-a20*b04-a23*b00)*det;out[12]=(a11*b07-a10*b09-a12*b06)*det;out[13]=(a00*b09-a01*b07+a02*b06)*det;out[14]=(a31*b01-a30*b03-a32*b00)*det;out[15]=(a20*b03-a21*b01+a22*b00)*det;return out;};/***/},/***/3012:/***/function(module,__unused_webpack_exports,__nested_webpack_require_353444__){var identity=__nested_webpack_require_353444__(9947);module.exports=lookAt;/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */function lookAt(out,eye,center,up){var x0,x1,x2,y0,y1,y2,z0,z1,z2,len,eyex=eye[0],eyey=eye[1],eyez=eye[2],upx=up[0],upy=up[1],upz=up[2],centerx=center[0],centery=center[1],centerz=center[2];if(Math.abs(eyex-centerx)<0.000001&&Math.abs(eyey-centery)<0.000001&&Math.abs(eyez-centerz)<0.000001){return identity(out);}z0=eyex-centerx;z1=eyey-centery;z2=eyez-centerz;len=1/Math.sqrt(z0*z0+z1*z1+z2*z2);z0*=len;z1*=len;z2*=len;x0=upy*z2-upz*z1;x1=upz*z0-upx*z2;x2=upx*z1-upy*z0;len=Math.sqrt(x0*x0+x1*x1+x2*x2);if(!len){x0=0;x1=0;x2=0;}else{len=1/len;x0*=len;x1*=len;x2*=len;}y0=z1*x2-z2*x1;y1=z2*x0-z0*x2;y2=z0*x1-z1*x0;len=Math.sqrt(y0*y0+y1*y1+y2*y2);if(!len){y0=0;y1=0;y2=0;}else{len=1/len;y0*=len;y1*=len;y2*=len;}out[0]=x0;out[1]=y0;out[2]=z0;out[3]=0;out[4]=x1;out[5]=y1;out[6]=z1;out[7]=0;out[8]=x2;out[9]=y2;out[10]=z2;out[11]=0;out[12]=-(x0*eyex+x1*eyey+x2*eyez);out[13]=-(y0*eyex+y1*eyey+y2*eyez);out[14]=-(z0*eyex+z1*eyey+z2*eyez);out[15]=1;return out;};/***/},/***/104:/***/function(module){module.exports=multiply;/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */function multiply(out,a,b){var a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11],a30=a[12],a31=a[13],a32=a[14],a33=a[15];// Cache only the current line of the second matrix
var b0=b[0],b1=b[1],b2=b[2],b3=b[3];out[0]=b0*a00+b1*a10+b2*a20+b3*a30;out[1]=b0*a01+b1*a11+b2*a21+b3*a31;out[2]=b0*a02+b1*a12+b2*a22+b3*a32;out[3]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[4];b1=b[5];b2=b[6];b3=b[7];out[4]=b0*a00+b1*a10+b2*a20+b3*a30;out[5]=b0*a01+b1*a11+b2*a21+b3*a31;out[6]=b0*a02+b1*a12+b2*a22+b3*a32;out[7]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[8];b1=b[9];b2=b[10];b3=b[11];out[8]=b0*a00+b1*a10+b2*a20+b3*a30;out[9]=b0*a01+b1*a11+b2*a21+b3*a31;out[10]=b0*a02+b1*a12+b2*a22+b3*a32;out[11]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[12];b1=b[13];b2=b[14];b3=b[15];out[12]=b0*a00+b1*a10+b2*a20+b3*a30;out[13]=b0*a01+b1*a11+b2*a21+b3*a31;out[14]=b0*a02+b1*a12+b2*a22+b3*a32;out[15]=b0*a03+b1*a13+b2*a23+b3*a33;return out;};/***/},/***/5268:/***/function(module){module.exports=ortho;/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */function ortho(out,left,right,bottom,top,near,far){var lr=1/(left-right),bt=1/(bottom-top),nf=1/(near-far);out[0]=-2*lr;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=-2*bt;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=2*nf;out[11]=0;out[12]=(left+right)*lr;out[13]=(top+bottom)*bt;out[14]=(far+near)*nf;out[15]=1;return out;};/***/},/***/1120:/***/function(module){module.exports=perspective;/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */function perspective(out,fovy,aspect,near,far){var f=1.0/Math.tan(fovy/2),nf=1/(near-far);out[0]=f/aspect;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=f;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=(far+near)*nf;out[11]=-1;out[12]=0;out[13]=0;out[14]=2*far*near*nf;out[15]=0;return out;};/***/},/***/4422:/***/function(module){module.exports=rotate;/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */function rotate(out,a,rad,axis){var x=axis[0],y=axis[1],z=axis[2],len=Math.sqrt(x*x+y*y+z*z),s,c,t,a00,a01,a02,a03,a10,a11,a12,a13,a20,a21,a22,a23,b00,b01,b02,b10,b11,b12,b20,b21,b22;if(Math.abs(len)<0.000001){return null;}len=1/len;x*=len;y*=len;z*=len;s=Math.sin(rad);c=Math.cos(rad);t=1-c;a00=a[0];a01=a[1];a02=a[2];a03=a[3];a10=a[4];a11=a[5];a12=a[6];a13=a[7];a20=a[8];a21=a[9];a22=a[10];a23=a[11];// Construct the elements of the rotation matrix
b00=x*x*t+c;b01=y*x*t+z*s;b02=z*x*t-y*s;b10=x*y*t-z*s;b11=y*y*t+c;b12=z*y*t+x*s;b20=x*z*t+y*s;b21=y*z*t-x*s;b22=z*z*t+c;// Perform rotation-specific matrix multiplication
out[0]=a00*b00+a10*b01+a20*b02;out[1]=a01*b00+a11*b01+a21*b02;out[2]=a02*b00+a12*b01+a22*b02;out[3]=a03*b00+a13*b01+a23*b02;out[4]=a00*b10+a10*b11+a20*b12;out[5]=a01*b10+a11*b11+a21*b12;out[6]=a02*b10+a12*b11+a22*b12;out[7]=a03*b10+a13*b11+a23*b12;out[8]=a00*b20+a10*b21+a20*b22;out[9]=a01*b20+a11*b21+a21*b22;out[10]=a02*b20+a12*b21+a22*b22;out[11]=a03*b20+a13*b21+a23*b22;if(a!==out){// If the source and destination differ, copy the unchanged last row
out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15];}return out;};/***/},/***/6109:/***/function(module){module.exports=rotateX;/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */function rotateX(out,a,rad){var s=Math.sin(rad),c=Math.cos(rad),a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11];if(a!==out){// If the source and destination differ, copy the unchanged rows
out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15];}// Perform axis-specific matrix multiplication
out[4]=a10*c+a20*s;out[5]=a11*c+a21*s;out[6]=a12*c+a22*s;out[7]=a13*c+a23*s;out[8]=a20*c-a10*s;out[9]=a21*c-a11*s;out[10]=a22*c-a12*s;out[11]=a23*c-a13*s;return out;};/***/},/***/7115:/***/function(module){module.exports=rotateY;/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */function rotateY(out,a,rad){var s=Math.sin(rad),c=Math.cos(rad),a00=a[0],a01=a[1],a02=a[2],a03=a[3],a20=a[8],a21=a[9],a22=a[10],a23=a[11];if(a!==out){// If the source and destination differ, copy the unchanged rows
out[4]=a[4];out[5]=a[5];out[6]=a[6];out[7]=a[7];out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15];}// Perform axis-specific matrix multiplication
out[0]=a00*c-a20*s;out[1]=a01*c-a21*s;out[2]=a02*c-a22*s;out[3]=a03*c-a23*s;out[8]=a00*s+a20*c;out[9]=a01*s+a21*c;out[10]=a02*s+a22*c;out[11]=a03*s+a23*c;return out;};/***/},/***/5240:/***/function(module){module.exports=rotateZ;/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */function rotateZ(out,a,rad){var s=Math.sin(rad),c=Math.cos(rad),a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7];if(a!==out){// If the source and destination differ, copy the unchanged last row
out[8]=a[8];out[9]=a[9];out[10]=a[10];out[11]=a[11];out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15];}// Perform axis-specific matrix multiplication
out[0]=a00*c+a10*s;out[1]=a01*c+a11*s;out[2]=a02*c+a12*s;out[3]=a03*c+a13*s;out[4]=a10*c-a00*s;out[5]=a11*c-a01*s;out[6]=a12*c-a02*s;out[7]=a13*c-a03*s;return out;};/***/},/***/3668:/***/function(module){module.exports=scale;/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/function scale(out,a,v){var x=v[0],y=v[1],z=v[2];out[0]=a[0]*x;out[1]=a[1]*x;out[2]=a[2]*x;out[3]=a[3]*x;out[4]=a[4]*y;out[5]=a[5]*y;out[6]=a[6]*y;out[7]=a[7]*y;out[8]=a[8]*z;out[9]=a[9]*z;out[10]=a[10]*z;out[11]=a[11]*z;out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15];return out;};/***/},/***/998:/***/function(module){module.exports=translate;/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */function translate(out,a,v){var x=v[0],y=v[1],z=v[2],a00,a01,a02,a03,a10,a11,a12,a13,a20,a21,a22,a23;if(a===out){out[12]=a[0]*x+a[4]*y+a[8]*z+a[12];out[13]=a[1]*x+a[5]*y+a[9]*z+a[13];out[14]=a[2]*x+a[6]*y+a[10]*z+a[14];out[15]=a[3]*x+a[7]*y+a[11]*z+a[15];}else{a00=a[0];a01=a[1];a02=a[2];a03=a[3];a10=a[4];a11=a[5];a12=a[6];a13=a[7];a20=a[8];a21=a[9];a22=a[10];a23=a[11];out[0]=a00;out[1]=a01;out[2]=a02;out[3]=a03;out[4]=a10;out[5]=a11;out[6]=a12;out[7]=a13;out[8]=a20;out[9]=a21;out[10]=a22;out[11]=a23;out[12]=a00*x+a10*y+a20*z+a[12];out[13]=a01*x+a11*y+a21*z+a[13];out[14]=a02*x+a12*y+a22*z+a[14];out[15]=a03*x+a13*y+a23*z+a[15];}return out;};/***/},/***/2142:/***/function(module){module.exports=transpose;/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */function transpose(out,a){// If we are transposing ourselves we can skip a few steps but have to cache some values
if(out===a){var a01=a[1],a02=a[2],a03=a[3],a12=a[6],a13=a[7],a23=a[11];out[1]=a[4];out[2]=a[8];out[3]=a[12];out[4]=a01;out[6]=a[9];out[7]=a[13];out[8]=a02;out[9]=a12;out[11]=a[14];out[12]=a03;out[13]=a13;out[14]=a23;}else{out[0]=a[0];out[1]=a[4];out[2]=a[8];out[3]=a[12];out[4]=a[1];out[5]=a[5];out[6]=a[9];out[7]=a[13];out[8]=a[2];out[9]=a[6];out[10]=a[10];out[11]=a[14];out[12]=a[3];out[13]=a[7];out[14]=a[11];out[15]=a[15];}return out;};/***/},/***/4340:/***/function(module,__unused_webpack_exports,__nested_webpack_require_363826__){"use strict";var barycentric=__nested_webpack_require_363826__(957);var closestPointToTriangle=__nested_webpack_require_363826__(7309);module.exports=closestPointToPickLocation;function xformMatrix(m,v){var out=[0,0,0,0];for(var i=0;i<4;++i){for(var j=0;j<4;++j){out[j]+=m[4*i+j]*v[i];}}return out;}function projectVertex(v,model,view,projection,resolution){var p=xformMatrix(projection,xformMatrix(view,xformMatrix(model,[v[0],v[1],v[2],1])));for(var i=0;i<3;++i){p[i]/=p[3];}return[0.5*resolution[0]*(1.0+p[0]),0.5*resolution[1]*(1.0-p[1])];}function barycentricCoord(simplex,point){if(simplex.length===2){var d0=0.0;var d1=0.0;for(var i=0;i<2;++i){d0+=Math.pow(point[i]-simplex[0][i],2);d1+=Math.pow(point[i]-simplex[1][i],2);}d0=Math.sqrt(d0);d1=Math.sqrt(d1);if(d0+d1<1e-6){return[1,0];}return[d1/(d0+d1),d0/(d1+d0)];}else if(simplex.length===3){var closestPoint=[0,0];closestPointToTriangle(simplex[0],simplex[1],simplex[2],point,closestPoint);return barycentric(simplex,closestPoint);}return[];}function interpolate(simplex,weights){var result=[0,0,0];for(var i=0;i<simplex.length;++i){var p=simplex[i];var w=weights[i];for(var j=0;j<3;++j){result[j]+=w*p[j];}}return result;}function closestPointToPickLocation(simplex,pixelCoord,model,view,projection,resolution){if(simplex.length===1){return[0,simplex[0].slice()];}var simplex2D=new Array(simplex.length);for(var i=0;i<simplex.length;++i){simplex2D[i]=projectVertex(simplex[i],model,view,projection,resolution);}var closestIndex=0;var closestDist=Infinity;for(var i=0;i<simplex2D.length;++i){var d2=0.0;for(var j=0;j<2;++j){d2+=Math.pow(simplex2D[i][j]-pixelCoord[j],2);}if(d2<closestDist){closestDist=d2;closestIndex=i;}}var weights=barycentricCoord(simplex2D,pixelCoord);var s=0.0;for(var i=0;i<3;++i){if(weights[i]<-0.001||weights[i]>1.0001){return null;}s+=weights[i];}if(Math.abs(s-1.0)>0.001){return null;}return[closestIndex,interpolate(simplex,weights),weights];}/***/},/***/2056:/***/function(__unused_webpack_module,exports,__nested_webpack_require_365813__){var glslify=__nested_webpack_require_365813__(6832);var triVertSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nattribute vec3 position, normal;\nattribute vec4 color;\nattribute vec2 uv;\n\nuniform mat4 model\n           , view\n           , projection\n           , inverseModel;\nuniform vec3 eyePosition\n           , lightPosition;\n\nvarying vec3 f_normal\n           , f_lightDirection\n           , f_eyeDirection\n           , f_data;\nvarying vec4 f_color;\nvarying vec2 f_uv;\n\nvec4 project(vec3 p) {\n  return projection * view * model * vec4(p, 1.0);\n}\n\nvoid main() {\n  gl_Position      = project(position);\n\n  //Lighting geometry parameters\n  vec4 cameraCoordinate = view * vec4(position , 1.0);\n  cameraCoordinate.xyz /= cameraCoordinate.w;\n  f_lightDirection = lightPosition - cameraCoordinate.xyz;\n  f_eyeDirection   = eyePosition - cameraCoordinate.xyz;\n  f_normal  = normalize((vec4(normal, 0.0) * inverseModel).xyz);\n\n  f_color          = color;\n  f_data           = position;\n  f_uv             = uv;\n}\n"]);var triFragSrc=glslify(["#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n#define GLSLIFY 1\n\nfloat beckmannDistribution(float x, float roughness) {\n  float NdotH = max(x, 0.0001);\n  float cos2Alpha = NdotH * NdotH;\n  float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;\n  float roughness2 = roughness * roughness;\n  float denom = 3.141592653589793 * roughness2 * cos2Alpha * cos2Alpha;\n  return exp(tan2Alpha / roughness2) / denom;\n}\n\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.0);\n  float VdotH = max(dot(viewDirection, H), 0.000001);\n  float LdotH = max(dot(lightDirection, H), 0.000001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = min(1.0, min(G1, G2));\n  \n  //Distribution term\n  float D = beckmannDistribution(NdotH, roughness);\n\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  G * F * D / max(3.14159265 * VdotN, 0.000001);\n}\n\n//#pragma glslify: beckmann = require(glsl-specular-beckmann) // used in gl-surface3d\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nuniform vec3 clipBounds[2];\nuniform float roughness\n            , fresnel\n            , kambient\n            , kdiffuse\n            , kspecular;\nuniform sampler2D texture;\n\nvarying vec3 f_normal\n           , f_lightDirection\n           , f_eyeDirection\n           , f_data;\nvarying vec4 f_color;\nvarying vec2 f_uv;\n\nvoid main() {\n  if (f_color.a == 0.0 ||\n    outOfRange(clipBounds[0], clipBounds[1], f_data)\n  ) discard;\n\n  vec3 N = normalize(f_normal);\n  vec3 L = normalize(f_lightDirection);\n  vec3 V = normalize(f_eyeDirection);\n\n  if(gl_FrontFacing) {\n    N = -N;\n  }\n\n  float specular = min(1.0, max(0.0, cookTorranceSpecular(L, V, N, roughness, fresnel)));\n  //float specular = max(0.0, beckmann(L, V, N, roughness)); // used in gl-surface3d\n\n  float diffuse  = min(kambient + kdiffuse * max(dot(N, L), 0.0), 1.0);\n\n  vec4 surfaceColor = vec4(f_color.rgb, 1.0) * texture2D(texture, f_uv);\n  vec4 litColor = surfaceColor.a * vec4(diffuse * surfaceColor.rgb + kspecular * vec3(1,1,1) * specular,  1.0);\n\n  gl_FragColor = litColor * f_color.a;\n}\n"]);var edgeVertSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec4 color;\nattribute vec2 uv;\n\nuniform mat4 model, view, projection;\n\nvarying vec4 f_color;\nvarying vec3 f_data;\nvarying vec2 f_uv;\n\nvoid main() {\n  gl_Position = projection * view * model * vec4(position, 1.0);\n  f_color = color;\n  f_data  = position;\n  f_uv    = uv;\n}"]);var edgeFragSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nuniform vec3 clipBounds[2];\nuniform sampler2D texture;\nuniform float opacity;\n\nvarying vec4 f_color;\nvarying vec3 f_data;\nvarying vec2 f_uv;\n\nvoid main() {\n  if (outOfRange(clipBounds[0], clipBounds[1], f_data)) discard;\n\n  gl_FragColor = f_color * texture2D(texture, f_uv) * opacity;\n}"]);var pointVertSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nattribute vec3 position;\nattribute vec4 color;\nattribute vec2 uv;\nattribute float pointSize;\n\nuniform mat4 model, view, projection;\nuniform vec3 clipBounds[2];\n\nvarying vec4 f_color;\nvarying vec2 f_uv;\n\nvoid main() {\n  if (outOfRange(clipBounds[0], clipBounds[1], position)) {\n\n    gl_Position = vec4(0.0, 0.0 ,0.0 ,0.0);\n  } else {\n    gl_Position = projection * view * model * vec4(position, 1.0);\n  }\n  gl_PointSize = pointSize;\n  f_color = color;\n  f_uv = uv;\n}"]);var pointFragSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\nuniform float opacity;\n\nvarying vec4 f_color;\nvarying vec2 f_uv;\n\nvoid main() {\n  vec2 pointR = gl_PointCoord.xy - vec2(0.5, 0.5);\n  if(dot(pointR, pointR) > 0.25) {\n    discard;\n  }\n  gl_FragColor = f_color * texture2D(texture, f_uv) * opacity;\n}"]);var pickVertSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec4 id;\n\nuniform mat4 model, view, projection;\n\nvarying vec3 f_position;\nvarying vec4 f_id;\n\nvoid main() {\n  gl_Position = projection * view * model * vec4(position, 1.0);\n  f_id        = id;\n  f_position  = position;\n}"]);var pickFragSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nuniform vec3  clipBounds[2];\nuniform float pickId;\n\nvarying vec3 f_position;\nvarying vec4 f_id;\n\nvoid main() {\n  if (outOfRange(clipBounds[0], clipBounds[1], f_position)) discard;\n\n  gl_FragColor = vec4(pickId, f_id.xyz);\n}"]);var pickPointVertSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nattribute vec3  position;\nattribute float pointSize;\nattribute vec4  id;\n\nuniform mat4 model, view, projection;\nuniform vec3 clipBounds[2];\n\nvarying vec3 f_position;\nvarying vec4 f_id;\n\nvoid main() {\n  if (outOfRange(clipBounds[0], clipBounds[1], position)) {\n\n    gl_Position = vec4(0.0, 0.0, 0.0, 0.0);\n  } else {\n    gl_Position  = projection * view * model * vec4(position, 1.0);\n    gl_PointSize = pointSize;\n  }\n  f_id         = id;\n  f_position   = position;\n}"]);var contourVertSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nattribute vec3 position;\n\nuniform mat4 model, view, projection;\n\nvoid main() {\n  gl_Position = projection * view * model * vec4(position, 1.0);\n}"]);var contourFragSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 contourColor;\n\nvoid main() {\n  gl_FragColor = vec4(contourColor, 1.0);\n}\n"]);exports.meshShader={vertex:triVertSrc,fragment:triFragSrc,attributes:[{name:'position',type:'vec3'},{name:'normal',type:'vec3'},{name:'color',type:'vec4'},{name:'uv',type:'vec2'}]};exports.wireShader={vertex:edgeVertSrc,fragment:edgeFragSrc,attributes:[{name:'position',type:'vec3'},{name:'color',type:'vec4'},{name:'uv',type:'vec2'}]};exports.pointShader={vertex:pointVertSrc,fragment:pointFragSrc,attributes:[{name:'position',type:'vec3'},{name:'color',type:'vec4'},{name:'uv',type:'vec2'},{name:'pointSize',type:'float'}]};exports.pickShader={vertex:pickVertSrc,fragment:pickFragSrc,attributes:[{name:'position',type:'vec3'},{name:'id',type:'vec4'}]};exports.pointPickShader={vertex:pickPointVertSrc,fragment:pickFragSrc,attributes:[{name:'position',type:'vec3'},{name:'pointSize',type:'float'},{name:'id',type:'vec4'}]};exports.contourShader={vertex:contourVertSrc,fragment:contourFragSrc,attributes:[{name:'position',type:'vec3'}]};/***/},/***/8116:/***/function(module,__unused_webpack_exports,__nested_webpack_require_376202__){"use strict";var DEFAULT_VERTEX_NORMALS_EPSILON=1e-6;// may be too large if triangles are very small
var DEFAULT_FACE_NORMALS_EPSILON=1e-6;var createShader=__nested_webpack_require_376202__(5158);var createBuffer=__nested_webpack_require_376202__(5827);var createVAO=__nested_webpack_require_376202__(2944);var createTexture=__nested_webpack_require_376202__(8931);var normals=__nested_webpack_require_376202__(115);var multiply=__nested_webpack_require_376202__(104);var invert=__nested_webpack_require_376202__(7437);var ndarray=__nested_webpack_require_376202__(5050);var colormap=__nested_webpack_require_376202__(9156);var getContour=__nested_webpack_require_376202__(7212);var pool=__nested_webpack_require_376202__(5306);var shaders=__nested_webpack_require_376202__(2056);var closestPoint=__nested_webpack_require_376202__(4340);var meshShader=shaders.meshShader;var wireShader=shaders.wireShader;var pointShader=shaders.pointShader;var pickShader=shaders.pickShader;var pointPickShader=shaders.pointPickShader;var contourShader=shaders.contourShader;var IDENTITY=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];function SimplicialMesh(gl,texture,triShader,lineShader,pointShader,pickShader,pointPickShader,contourShader,trianglePositions,triangleIds,triangleColors,triangleUVs,triangleNormals,triangleVAO,edgePositions,edgeIds,edgeColors,edgeUVs,edgeVAO,pointPositions,pointIds,pointColors,pointUVs,pointSizes,pointVAO,contourPositions,contourVAO){this.gl=gl;this.pixelRatio=1;this.cells=[];this.positions=[];this.intensity=[];this.texture=texture;this.dirty=true;this.triShader=triShader;this.lineShader=lineShader;this.pointShader=pointShader;this.pickShader=pickShader;this.pointPickShader=pointPickShader;this.contourShader=contourShader;this.trianglePositions=trianglePositions;this.triangleColors=triangleColors;this.triangleNormals=triangleNormals;this.triangleUVs=triangleUVs;this.triangleIds=triangleIds;this.triangleVAO=triangleVAO;this.triangleCount=0;this.lineWidth=1;this.edgePositions=edgePositions;this.edgeColors=edgeColors;this.edgeUVs=edgeUVs;this.edgeIds=edgeIds;this.edgeVAO=edgeVAO;this.edgeCount=0;this.pointPositions=pointPositions;this.pointColors=pointColors;this.pointUVs=pointUVs;this.pointSizes=pointSizes;this.pointIds=pointIds;this.pointVAO=pointVAO;this.pointCount=0;this.contourLineWidth=1;this.contourPositions=contourPositions;this.contourVAO=contourVAO;this.contourCount=0;this.contourColor=[0,0,0];this.contourEnable=true;this.pickVertex=true;this.pickId=1;this.bounds=[[Infinity,Infinity,Infinity],[-Infinity,-Infinity,-Infinity]];this.clipBounds=[[-Infinity,-Infinity,-Infinity],[Infinity,Infinity,Infinity]];this.lightPosition=[1e5,1e5,0];this.ambientLight=0.8;this.diffuseLight=0.8;this.specularLight=2.0;this.roughness=0.5;this.fresnel=1.5;this.opacity=1.0;this.hasAlpha=false;this.opacityscale=false;this._model=IDENTITY;this._view=IDENTITY;this._projection=IDENTITY;this._resolution=[1,1];}var proto=SimplicialMesh.prototype;proto.isOpaque=function(){return!this.hasAlpha;};proto.isTransparent=function(){return this.hasAlpha;};proto.pickSlots=1;proto.setPickBase=function(id){this.pickId=id;};function getOpacityFromScale(ratio,opacityscale){if(!opacityscale)return 1;if(!opacityscale.length)return 1;for(var i=0;i<opacityscale.length;++i){if(opacityscale.length<2)return 1;if(opacityscale[i][0]===ratio)return opacityscale[i][1];if(opacityscale[i][0]>ratio&&i>0){var d=(opacityscale[i][0]-ratio)/(opacityscale[i][0]-opacityscale[i-1][0]);return opacityscale[i][1]*(1-d)+d*opacityscale[i-1][1];}}return 1;}function genColormap(param,opacityscale){var colors=colormap({colormap:param,nshades:256,format:'rgba'});var result=new Uint8Array(256*4);for(var i=0;i<256;++i){var c=colors[i];for(var j=0;j<3;++j){result[4*i+j]=c[j];}if(!opacityscale){result[4*i+3]=255*c[3];}else{result[4*i+3]=255*getOpacityFromScale(i/255.0,opacityscale);}}return ndarray(result,[256,256,4],[4,0,1]);}function takeZComponent(array){var n=array.length;var result=new Array(n);for(var i=0;i<n;++i){result[i]=array[i][2];}return result;}proto.highlight=function(selection){if(!selection||!this.contourEnable){this.contourCount=0;return;}var level=getContour(this.cells,this.intensity,selection.intensity);var cells=level.cells;var vertexIds=level.vertexIds;var vertexWeights=level.vertexWeights;var numCells=cells.length;var result=pool.mallocFloat32(2*3*numCells);var ptr=0;for(var i=0;i<numCells;++i){var c=cells[i];for(var j=0;j<2;++j){var v=c[0];if(c.length===2){v=c[j];}var a=vertexIds[v][0];var b=vertexIds[v][1];var w=vertexWeights[v];var wi=1.0-w;var pa=this.positions[a];var pb=this.positions[b];for(var k=0;k<3;++k){result[ptr++]=w*pa[k]+wi*pb[k];}}}this.contourCount=ptr/3|0;this.contourPositions.update(result.subarray(0,ptr));pool.free(result);};proto.update=function(params){params=params||{};var gl=this.gl;this.dirty=true;if('contourEnable'in params){this.contourEnable=params.contourEnable;}if('contourColor'in params){this.contourColor=params.contourColor;}if('lineWidth'in params){this.lineWidth=params.lineWidth;}if('lightPosition'in params){this.lightPosition=params.lightPosition;}this.hasAlpha=false;// default to no transparent draw
if('opacity'in params){this.opacity=params.opacity;if(this.opacity<1){this.hasAlpha=true;}}if('opacityscale'in params){this.opacityscale=params.opacityscale;this.hasAlpha=true;}if('ambient'in params){this.ambientLight=params.ambient;}if('diffuse'in params){this.diffuseLight=params.diffuse;}if('specular'in params){this.specularLight=params.specular;}if('roughness'in params){this.roughness=params.roughness;}if('fresnel'in params){this.fresnel=params.fresnel;}if(params.texture){this.texture.dispose();this.texture=createTexture(gl,params.texture);}else if(params.colormap){this.texture.shape=[256,256];this.texture.minFilter=gl.LINEAR_MIPMAP_LINEAR;this.texture.magFilter=gl.LINEAR;this.texture.setPixels(genColormap(params.colormap,this.opacityscale));this.texture.generateMipmap();}var cells=params.cells;var positions=params.positions;if(!positions||!cells){return;}var tPos=[];var tCol=[];var tNor=[];var tUVs=[];var tIds=[];var ePos=[];var eCol=[];var eUVs=[];var eIds=[];var pPos=[];var pCol=[];var pUVs=[];var pSiz=[];var pIds=[];//Save geometry data for picking calculations
this.cells=cells;this.positions=positions;//Compute normals
var vertexNormals=params.vertexNormals;var cellNormals=params.cellNormals;var vertexNormalsEpsilon=params.vertexNormalsEpsilon===void 0?DEFAULT_VERTEX_NORMALS_EPSILON:params.vertexNormalsEpsilon;var faceNormalsEpsilon=params.faceNormalsEpsilon===void 0?DEFAULT_FACE_NORMALS_EPSILON:params.faceNormalsEpsilon;if(params.useFacetNormals&&!cellNormals){cellNormals=normals.faceNormals(cells,positions,faceNormalsEpsilon);}if(!cellNormals&&!vertexNormals){vertexNormals=normals.vertexNormals(cells,positions,vertexNormalsEpsilon);}//Compute colors
var vertexColors=params.vertexColors;var cellColors=params.cellColors;var meshColor=params.meshColor||[1,1,1,1];//UVs
var vertexUVs=params.vertexUVs;var vertexIntensity=params.vertexIntensity;var cellUVs=params.cellUVs;var cellIntensity=params.cellIntensity;var intensityLo=Infinity;var intensityHi=-Infinity;if(!vertexUVs&&!cellUVs){if(vertexIntensity){if(params.vertexIntensityBounds){intensityLo=+params.vertexIntensityBounds[0];intensityHi=+params.vertexIntensityBounds[1];}else{for(var i=0;i<vertexIntensity.length;++i){var f=vertexIntensity[i];intensityLo=Math.min(intensityLo,f);intensityHi=Math.max(intensityHi,f);}}}else if(cellIntensity){if(params.cellIntensityBounds){intensityLo=+params.cellIntensityBounds[0];intensityHi=+params.cellIntensityBounds[1];}else{for(var i=0;i<cellIntensity.length;++i){var f=cellIntensity[i];intensityLo=Math.min(intensityLo,f);intensityHi=Math.max(intensityHi,f);}}}else{for(var i=0;i<positions.length;++i){var f=positions[i][2];intensityLo=Math.min(intensityLo,f);intensityHi=Math.max(intensityHi,f);}}}if(vertexIntensity){this.intensity=vertexIntensity;}else if(cellIntensity){this.intensity=cellIntensity;}else{this.intensity=takeZComponent(positions);}this.pickVertex=!(cellIntensity||cellColors);//Point size
var pointSizes=params.pointSizes;var meshPointSize=params.pointSize||1.0;//Update bounds
this.bounds=[[Infinity,Infinity,Infinity],[-Infinity,-Infinity,-Infinity]];for(var i=0;i<positions.length;++i){var p=positions[i];for(var j=0;j<3;++j){if(isNaN(p[j])||!isFinite(p[j])){continue;}this.bounds[0][j]=Math.min(this.bounds[0][j],p[j]);this.bounds[1][j]=Math.max(this.bounds[1][j],p[j]);}}//Pack cells into buffers
var triangleCount=0;var edgeCount=0;var pointCount=0;fill_loop:for(var i=0;i<cells.length;++i){var cell=cells[i];switch(cell.length){case 1:var v=cell[0];var p=positions[v];//Check NaNs
for(var j=0;j<3;++j){if(isNaN(p[j])||!isFinite(p[j])){continue fill_loop;}}pPos.push(p[0],p[1],p[2]);var c;if(vertexColors){c=vertexColors[v];}else if(cellColors){c=cellColors[i];}else{c=meshColor;}if(this.opacityscale&&vertexIntensity){tCol.push(c[0],c[1],c[2],this.opacity*getOpacityFromScale((vertexIntensity[v]-intensityLo)/(intensityHi-intensityLo),this.opacityscale));}else if(c.length===3){pCol.push(c[0],c[1],c[2],this.opacity);}else{pCol.push(c[0],c[1],c[2],c[3]*this.opacity);if(c[3]<1)this.hasAlpha=true;}var uv;if(vertexUVs){uv=vertexUVs[v];}else if(vertexIntensity){uv=[(vertexIntensity[v]-intensityLo)/(intensityHi-intensityLo),0];}else if(cellUVs){uv=cellUVs[i];}else if(cellIntensity){uv=[(cellIntensity[i]-intensityLo)/(intensityHi-intensityLo),0];}else{uv=[(p[2]-intensityLo)/(intensityHi-intensityLo),0];}pUVs.push(uv[0],uv[1]);if(pointSizes){pSiz.push(pointSizes[v]);}else{pSiz.push(meshPointSize);}pIds.push(i);pointCount+=1;break;case 2://Check NaNs
for(var j=0;j<2;++j){var v=cell[j];var p=positions[v];for(var k=0;k<3;++k){if(isNaN(p[k])||!isFinite(p[k])){continue fill_loop;}}}for(var j=0;j<2;++j){var v=cell[j];var p=positions[v];ePos.push(p[0],p[1],p[2]);var c;if(vertexColors){c=vertexColors[v];}else if(cellColors){c=cellColors[i];}else{c=meshColor;}if(this.opacityscale&&vertexIntensity){tCol.push(c[0],c[1],c[2],this.opacity*getOpacityFromScale((vertexIntensity[v]-intensityLo)/(intensityHi-intensityLo),this.opacityscale));}else if(c.length===3){eCol.push(c[0],c[1],c[2],this.opacity);}else{eCol.push(c[0],c[1],c[2],c[3]*this.opacity);if(c[3]<1)this.hasAlpha=true;}var uv;if(vertexUVs){uv=vertexUVs[v];}else if(vertexIntensity){uv=[(vertexIntensity[v]-intensityLo)/(intensityHi-intensityLo),0];}else if(cellUVs){uv=cellUVs[i];}else if(cellIntensity){uv=[(cellIntensity[i]-intensityLo)/(intensityHi-intensityLo),0];}else{uv=[(p[2]-intensityLo)/(intensityHi-intensityLo),0];}eUVs.push(uv[0],uv[1]);eIds.push(i);}edgeCount+=1;break;case 3://Check NaNs
for(var j=0;j<3;++j){var v=cell[j];var p=positions[v];for(var k=0;k<3;++k){if(isNaN(p[k])||!isFinite(p[k])){continue fill_loop;}}}for(var j=0;j<3;++j){var v=cell[2-j];var p=positions[v];tPos.push(p[0],p[1],p[2]);var c;if(vertexColors){c=vertexColors[v];}else if(cellColors){c=cellColors[i];}else{c=meshColor;}if(!c){tCol.push(0.5,0.5,0.5,1);}else if(this.opacityscale&&vertexIntensity){tCol.push(c[0],c[1],c[2],this.opacity*getOpacityFromScale((vertexIntensity[v]-intensityLo)/(intensityHi-intensityLo),this.opacityscale));}else if(c.length===3){tCol.push(c[0],c[1],c[2],this.opacity);}else{tCol.push(c[0],c[1],c[2],c[3]*this.opacity);if(c[3]<1)this.hasAlpha=true;}var uv;if(vertexUVs){uv=vertexUVs[v];}else if(vertexIntensity){uv=[(vertexIntensity[v]-intensityLo)/(intensityHi-intensityLo),0];}else if(cellUVs){uv=cellUVs[i];}else if(cellIntensity){uv=[(cellIntensity[i]-intensityLo)/(intensityHi-intensityLo),0];}else{uv=[(p[2]-intensityLo)/(intensityHi-intensityLo),0];}tUVs.push(uv[0],uv[1]);var q;if(vertexNormals){q=vertexNormals[v];}else{q=cellNormals[i];}tNor.push(q[0],q[1],q[2]);tIds.push(i);}triangleCount+=1;break;default:break;}}this.pointCount=pointCount;this.edgeCount=edgeCount;this.triangleCount=triangleCount;this.pointPositions.update(pPos);this.pointColors.update(pCol);this.pointUVs.update(pUVs);this.pointSizes.update(pSiz);this.pointIds.update(new Uint32Array(pIds));this.edgePositions.update(ePos);this.edgeColors.update(eCol);this.edgeUVs.update(eUVs);this.edgeIds.update(new Uint32Array(eIds));this.trianglePositions.update(tPos);this.triangleColors.update(tCol);this.triangleUVs.update(tUVs);this.triangleNormals.update(tNor);this.triangleIds.update(new Uint32Array(tIds));};proto.drawTransparent=proto.draw=function(params){params=params||{};var gl=this.gl;var model=params.model||IDENTITY;var view=params.view||IDENTITY;var projection=params.projection||IDENTITY;var clipBounds=[[-1e6,-1e6,-1e6],[1e6,1e6,1e6]];for(var i=0;i<3;++i){clipBounds[0][i]=Math.max(clipBounds[0][i],this.clipBounds[0][i]);clipBounds[1][i]=Math.min(clipBounds[1][i],this.clipBounds[1][i]);}var uniforms={model:model,view:view,projection:projection,inverseModel:IDENTITY.slice(),clipBounds:clipBounds,kambient:this.ambientLight,kdiffuse:this.diffuseLight,kspecular:this.specularLight,roughness:this.roughness,fresnel:this.fresnel,eyePosition:[0,0,0],lightPosition:[0,0,0],contourColor:this.contourColor,texture:0};uniforms.inverseModel=invert(uniforms.inverseModel,uniforms.model);gl.disable(gl.CULL_FACE);this.texture.bind(0);var invCameraMatrix=new Array(16);multiply(invCameraMatrix,uniforms.view,uniforms.model);multiply(invCameraMatrix,uniforms.projection,invCameraMatrix);invert(invCameraMatrix,invCameraMatrix);for(var i=0;i<3;++i){uniforms.eyePosition[i]=invCameraMatrix[12+i]/invCameraMatrix[15];}var w=invCameraMatrix[15];for(var i=0;i<3;++i){w+=this.lightPosition[i]*invCameraMatrix[4*i+3];}for(var i=0;i<3;++i){var s=invCameraMatrix[12+i];for(var j=0;j<3;++j){s+=invCameraMatrix[4*j+i]*this.lightPosition[j];}uniforms.lightPosition[i]=s/w;}if(this.triangleCount>0){var shader=this.triShader;shader.bind();shader.uniforms=uniforms;this.triangleVAO.bind();gl.drawArrays(gl.TRIANGLES,0,this.triangleCount*3);this.triangleVAO.unbind();}if(this.edgeCount>0&&this.lineWidth>0){var shader=this.lineShader;shader.bind();shader.uniforms=uniforms;this.edgeVAO.bind();gl.lineWidth(this.lineWidth*this.pixelRatio);gl.drawArrays(gl.LINES,0,this.edgeCount*2);this.edgeVAO.unbind();}if(this.pointCount>0){var shader=this.pointShader;shader.bind();shader.uniforms=uniforms;this.pointVAO.bind();gl.drawArrays(gl.POINTS,0,this.pointCount);this.pointVAO.unbind();}if(this.contourEnable&&this.contourCount>0&&this.contourLineWidth>0){var shader=this.contourShader;shader.bind();shader.uniforms=uniforms;this.contourVAO.bind();gl.drawArrays(gl.LINES,0,this.contourCount);this.contourVAO.unbind();}};proto.drawPick=function(params){params=params||{};var gl=this.gl;var model=params.model||IDENTITY;var view=params.view||IDENTITY;var projection=params.projection||IDENTITY;var clipBounds=[[-1e6,-1e6,-1e6],[1e6,1e6,1e6]];for(var i=0;i<3;++i){clipBounds[0][i]=Math.max(clipBounds[0][i],this.clipBounds[0][i]);clipBounds[1][i]=Math.min(clipBounds[1][i],this.clipBounds[1][i]);}//Save camera parameters
this._model=[].slice.call(model);this._view=[].slice.call(view);this._projection=[].slice.call(projection);this._resolution=[gl.drawingBufferWidth,gl.drawingBufferHeight];var uniforms={model:model,view:view,projection:projection,clipBounds:clipBounds,pickId:this.pickId/255.0};var shader=this.pickShader;shader.bind();shader.uniforms=uniforms;if(this.triangleCount>0){this.triangleVAO.bind();gl.drawArrays(gl.TRIANGLES,0,this.triangleCount*3);this.triangleVAO.unbind();}if(this.edgeCount>0){this.edgeVAO.bind();gl.lineWidth(this.lineWidth*this.pixelRatio);gl.drawArrays(gl.LINES,0,this.edgeCount*2);this.edgeVAO.unbind();}if(this.pointCount>0){var shader=this.pointPickShader;shader.bind();shader.uniforms=uniforms;this.pointVAO.bind();gl.drawArrays(gl.POINTS,0,this.pointCount);this.pointVAO.unbind();}};proto.pick=function(pickData){if(!pickData){return null;}if(pickData.id!==this.pickId){return null;}var cellId=pickData.value[0]+256*pickData.value[1]+65536*pickData.value[2];var cell=this.cells[cellId];var positions=this.positions;var simplex=new Array(cell.length);for(var i=0;i<cell.length;++i){simplex[i]=positions[cell[i]];}var x=pickData.coord[0];var y=pickData.coord[1];if(!this.pickVertex){var A=this.positions[cell[0]];var B=this.positions[cell[1]];var C=this.positions[cell[2]];var dataCoordinate=[(A[0]+B[0]+C[0])/3,(A[1]+B[1]+C[1])/3,(A[2]+B[2]+C[2])/3];return{_cellCenter:true,position:[x,y],index:cellId,cell:cell,cellId:cellId,intensity:this.intensity[cellId],dataCoordinate:dataCoordinate};}var data=closestPoint(simplex,[x*this.pixelRatio,this._resolution[1]-y*this.pixelRatio],this._model,this._view,this._projection,this._resolution);if(!data){return null;}var weights=data[2];var interpIntensity=0.0;for(var i=0;i<cell.length;++i){interpIntensity+=weights[i]*this.intensity[cell[i]];}return{position:data[1],index:cell[data[0]],cell:cell,cellId:cellId,intensity:interpIntensity,dataCoordinate:this.positions[cell[data[0]]]};};proto.dispose=function(){this.texture.dispose();this.triShader.dispose();this.lineShader.dispose();this.pointShader.dispose();this.pickShader.dispose();this.pointPickShader.dispose();this.triangleVAO.dispose();this.trianglePositions.dispose();this.triangleColors.dispose();this.triangleUVs.dispose();this.triangleNormals.dispose();this.triangleIds.dispose();this.edgeVAO.dispose();this.edgePositions.dispose();this.edgeColors.dispose();this.edgeUVs.dispose();this.edgeIds.dispose();this.pointVAO.dispose();this.pointPositions.dispose();this.pointColors.dispose();this.pointUVs.dispose();this.pointSizes.dispose();this.pointIds.dispose();this.contourVAO.dispose();this.contourPositions.dispose();this.contourShader.dispose();};function createMeshShader(gl){var shader=createShader(gl,meshShader.vertex,meshShader.fragment);shader.attributes.position.location=0;shader.attributes.color.location=2;shader.attributes.uv.location=3;shader.attributes.normal.location=4;return shader;}function createWireShader(gl){var shader=createShader(gl,wireShader.vertex,wireShader.fragment);shader.attributes.position.location=0;shader.attributes.color.location=2;shader.attributes.uv.location=3;return shader;}function createPointShader(gl){var shader=createShader(gl,pointShader.vertex,pointShader.fragment);shader.attributes.position.location=0;shader.attributes.color.location=2;shader.attributes.uv.location=3;shader.attributes.pointSize.location=4;return shader;}function createPickShader(gl){var shader=createShader(gl,pickShader.vertex,pickShader.fragment);shader.attributes.position.location=0;shader.attributes.id.location=1;return shader;}function createPointPickShader(gl){var shader=createShader(gl,pointPickShader.vertex,pointPickShader.fragment);shader.attributes.position.location=0;shader.attributes.id.location=1;shader.attributes.pointSize.location=4;return shader;}function createContourShader(gl){var shader=createShader(gl,contourShader.vertex,contourShader.fragment);shader.attributes.position.location=0;return shader;}function createSimplicialMesh(gl,params){if(arguments.length===1){params=gl;gl=params.gl;}//enable derivatives for face normals
var ext=gl.getExtension('OES_standard_derivatives')||gl.getExtension('MOZ_OES_standard_derivatives')||gl.getExtension('WEBKIT_OES_standard_derivatives');if(!ext)throw new Error('derivatives not supported');var triShader=createMeshShader(gl);var lineShader=createWireShader(gl);var pointShader=createPointShader(gl);var pickShader=createPickShader(gl);var pointPickShader=createPointPickShader(gl);var contourShader=createContourShader(gl);var meshTexture=createTexture(gl,ndarray(new Uint8Array([255,255,255,255]),[1,1,4]));meshTexture.generateMipmap();meshTexture.minFilter=gl.LINEAR_MIPMAP_LINEAR;meshTexture.magFilter=gl.LINEAR;var trianglePositions=createBuffer(gl);var triangleColors=createBuffer(gl);var triangleUVs=createBuffer(gl);var triangleNormals=createBuffer(gl);var triangleIds=createBuffer(gl);var triangleVAO=createVAO(gl,[{buffer:trianglePositions,type:gl.FLOAT,size:3},{buffer:triangleIds,type:gl.UNSIGNED_BYTE,size:4,normalized:true},{buffer:triangleColors,type:gl.FLOAT,size:4},{buffer:triangleUVs,type:gl.FLOAT,size:2},{buffer:triangleNormals,type:gl.FLOAT,size:3}]);var edgePositions=createBuffer(gl);var edgeColors=createBuffer(gl);var edgeUVs=createBuffer(gl);var edgeIds=createBuffer(gl);var edgeVAO=createVAO(gl,[{buffer:edgePositions,type:gl.FLOAT,size:3},{buffer:edgeIds,type:gl.UNSIGNED_BYTE,size:4,normalized:true},{buffer:edgeColors,type:gl.FLOAT,size:4},{buffer:edgeUVs,type:gl.FLOAT,size:2}]);var pointPositions=createBuffer(gl);var pointColors=createBuffer(gl);var pointUVs=createBuffer(gl);var pointSizes=createBuffer(gl);var pointIds=createBuffer(gl);var pointVAO=createVAO(gl,[{buffer:pointPositions,type:gl.FLOAT,size:3},{buffer:pointIds,type:gl.UNSIGNED_BYTE,size:4,normalized:true},{buffer:pointColors,type:gl.FLOAT,size:4},{buffer:pointUVs,type:gl.FLOAT,size:2},{buffer:pointSizes,type:gl.FLOAT,size:1}]);var contourPositions=createBuffer(gl);var contourVAO=createVAO(gl,[{buffer:contourPositions,type:gl.FLOAT,size:3}]);var mesh=new SimplicialMesh(gl,meshTexture,triShader,lineShader,pointShader,pickShader,pointPickShader,contourShader,trianglePositions,triangleIds,triangleColors,triangleUVs,triangleNormals,triangleVAO,edgePositions,edgeIds,edgeColors,edgeUVs,edgeVAO,pointPositions,pointIds,pointColors,pointUVs,pointSizes,pointVAO,contourPositions,contourVAO);mesh.update(params);return mesh;}module.exports=createSimplicialMesh;/***/},/***/4554:/***/function(module,__unused_webpack_exports,__nested_webpack_require_397571__){"use strict";module.exports=createBoxes;var createBuffer=__nested_webpack_require_397571__(5827);var createShader=__nested_webpack_require_397571__(5158);var shaders=__nested_webpack_require_397571__(2709);function Boxes(plot,vbo,shader){this.plot=plot;this.vbo=vbo;this.shader=shader;}var proto=Boxes.prototype;proto.bind=function(){var shader=this.shader;this.vbo.bind();this.shader.bind();shader.attributes.coord.pointer();shader.uniforms.screenBox=this.plot.screenBox;};proto.drawBox=function(){var lo=[0,0];var hi=[0,0];return function(loX,loY,hiX,hiY,color){var plot=this.plot;var shader=this.shader;var gl=plot.gl;lo[0]=loX;lo[1]=loY;hi[0]=hiX;hi[1]=hiY;shader.uniforms.lo=lo;shader.uniforms.hi=hi;shader.uniforms.color=color;gl.drawArrays(gl.TRIANGLE_STRIP,0,4);};}();proto.dispose=function(){this.vbo.dispose();this.shader.dispose();};function createBoxes(plot){var gl=plot.gl;var vbo=createBuffer(gl,[0,0,0,1,1,0,1,1]);var shader=createShader(gl,shaders.boxVert,shaders.lineFrag);return new Boxes(plot,vbo,shader);}/***/},/***/3016:/***/function(module,__unused_webpack_exports,__nested_webpack_require_398638__){"use strict";module.exports=createGrid;var createBuffer=__nested_webpack_require_398638__(5827);var createShader=__nested_webpack_require_398638__(5158);var bsearch=__nested_webpack_require_398638__(5070);var shaders=__nested_webpack_require_398638__(2709);function Grid(plot,vbo,shader,tickShader){this.plot=plot;this.vbo=vbo;this.shader=shader;this.tickShader=tickShader;this.ticks=[[],[]];}function compareTickNum(a,b){return a-b;}var proto=Grid.prototype;proto.draw=function(){var DATA_SHIFT=[0,0];var DATA_SCALE=[0,0];var DATA_AXIS=[0,0];return function(){var plot=this.plot;var vbo=this.vbo;var shader=this.shader;var ticks=this.ticks;var gl=plot.gl;var bounds=plot._tickBounds;var dataBox=plot.dataBox;var viewPixels=plot.viewBox;var lineWidth=plot.gridLineWidth;var gridColor=plot.gridLineColor;var gridEnable=plot.gridLineEnable;var pixelRatio=plot.pixelRatio;for(var i=0;i<2;++i){var lo=bounds[i];var hi=bounds[i+2];var boundScale=hi-lo;var dataCenter=0.5*(dataBox[i+2]+dataBox[i]);var dataWidth=dataBox[i+2]-dataBox[i];DATA_SCALE[i]=2.0*boundScale/dataWidth;DATA_SHIFT[i]=2.0*(lo-dataCenter)/dataWidth;}shader.bind();vbo.bind();shader.attributes.dataCoord.pointer();shader.uniforms.dataShift=DATA_SHIFT;shader.uniforms.dataScale=DATA_SCALE;var offset=0;for(var i=0;i<2;++i){DATA_AXIS[0]=DATA_AXIS[1]=0;DATA_AXIS[i]=1;shader.uniforms.dataAxis=DATA_AXIS;shader.uniforms.lineWidth=lineWidth[i]/(viewPixels[i+2]-viewPixels[i])*pixelRatio;shader.uniforms.color=gridColor[i];var size=ticks[i].length*6;if(gridEnable[i]&&size){gl.drawArrays(gl.TRIANGLES,offset,size);}offset+=size;}};}();proto.drawTickMarks=function(){var DATA_SHIFT=[0,0];var DATA_SCALE=[0,0];var X_AXIS=[1,0];var Y_AXIS=[0,1];var SCR_OFFSET=[0,0];var TICK_SCALE=[0,0];return function(){var plot=this.plot;var vbo=this.vbo;var shader=this.tickShader;var ticks=this.ticks;var gl=plot.gl;var bounds=plot._tickBounds;var dataBox=plot.dataBox;var viewBox=plot.viewBox;var pixelRatio=plot.pixelRatio;var screenBox=plot.screenBox;var screenWidth=screenBox[2]-screenBox[0];var screenHeight=screenBox[3]-screenBox[1];var viewWidth=viewBox[2]-viewBox[0];var viewHeight=viewBox[3]-viewBox[1];for(var i=0;i<2;++i){var lo=bounds[i];var hi=bounds[i+2];var boundScale=hi-lo;var dataCenter=0.5*(dataBox[i+2]+dataBox[i]);var dataWidth=dataBox[i+2]-dataBox[i];DATA_SCALE[i]=2.0*boundScale/dataWidth;DATA_SHIFT[i]=2.0*(lo-dataCenter)/dataWidth;}DATA_SCALE[0]*=viewWidth/screenWidth;DATA_SHIFT[0]*=viewWidth/screenWidth;DATA_SCALE[1]*=viewHeight/screenHeight;DATA_SHIFT[1]*=viewHeight/screenHeight;shader.bind();vbo.bind();shader.attributes.dataCoord.pointer();var uniforms=shader.uniforms;uniforms.dataShift=DATA_SHIFT;uniforms.dataScale=DATA_SCALE;var tickMarkLength=plot.tickMarkLength;var tickMarkWidth=plot.tickMarkWidth;var tickMarkColor=plot.tickMarkColor;var xTicksOffset=0;var yTicksOffset=ticks[0].length*6;var xStart=Math.min(bsearch.ge(ticks[0],(dataBox[0]-bounds[0])/(bounds[2]-bounds[0]),compareTickNum),ticks[0].length);var xEnd=Math.min(bsearch.gt(ticks[0],(dataBox[2]-bounds[0])/(bounds[2]-bounds[0]),compareTickNum),ticks[0].length);var xOffset=xTicksOffset+6*xStart;var xCount=6*Math.max(0,xEnd-xStart);var yStart=Math.min(bsearch.ge(ticks[1],(dataBox[1]-bounds[1])/(bounds[3]-bounds[1]),compareTickNum),ticks[1].length);var yEnd=Math.min(bsearch.gt(ticks[1],(dataBox[3]-bounds[1])/(bounds[3]-bounds[1]),compareTickNum),ticks[1].length);var yOffset=yTicksOffset+6*yStart;var yCount=6*Math.max(0,yEnd-yStart);SCR_OFFSET[0]=2.0*(viewBox[0]-tickMarkLength[1])/screenWidth-1.0;SCR_OFFSET[1]=(viewBox[3]+viewBox[1])/screenHeight-1.0;TICK_SCALE[0]=tickMarkLength[1]*pixelRatio/screenWidth;TICK_SCALE[1]=tickMarkWidth[1]*pixelRatio/screenHeight;if(yCount){uniforms.color=tickMarkColor[1];uniforms.tickScale=TICK_SCALE;uniforms.dataAxis=Y_AXIS;uniforms.screenOffset=SCR_OFFSET;gl.drawArrays(gl.TRIANGLES,yOffset,yCount);}SCR_OFFSET[0]=(viewBox[2]+viewBox[0])/screenWidth-1.0;SCR_OFFSET[1]=2.0*(viewBox[1]-tickMarkLength[0])/screenHeight-1.0;TICK_SCALE[0]=tickMarkWidth[0]*pixelRatio/screenWidth;TICK_SCALE[1]=tickMarkLength[0]*pixelRatio/screenHeight;if(xCount){uniforms.color=tickMarkColor[0];uniforms.tickScale=TICK_SCALE;uniforms.dataAxis=X_AXIS;uniforms.screenOffset=SCR_OFFSET;gl.drawArrays(gl.TRIANGLES,xOffset,xCount);}SCR_OFFSET[0]=2.0*(viewBox[2]+tickMarkLength[3])/screenWidth-1.0;SCR_OFFSET[1]=(viewBox[3]+viewBox[1])/screenHeight-1.0;TICK_SCALE[0]=tickMarkLength[3]*pixelRatio/screenWidth;TICK_SCALE[1]=tickMarkWidth[3]*pixelRatio/screenHeight;if(yCount){uniforms.color=tickMarkColor[3];uniforms.tickScale=TICK_SCALE;uniforms.dataAxis=Y_AXIS;uniforms.screenOffset=SCR_OFFSET;gl.drawArrays(gl.TRIANGLES,yOffset,yCount);}SCR_OFFSET[0]=(viewBox[2]+viewBox[0])/screenWidth-1.0;SCR_OFFSET[1]=2.0*(viewBox[3]+tickMarkLength[2])/screenHeight-1.0;TICK_SCALE[0]=tickMarkWidth[2]*pixelRatio/screenWidth;TICK_SCALE[1]=tickMarkLength[2]*pixelRatio/screenHeight;if(xCount){uniforms.color=tickMarkColor[2];uniforms.tickScale=TICK_SCALE;uniforms.dataAxis=X_AXIS;uniforms.screenOffset=SCR_OFFSET;gl.drawArrays(gl.TRIANGLES,xOffset,xCount);}};}();proto.update=function(){var OFFSET_X=[1,1,-1,-1,1,-1];var OFFSET_Y=[1,-1,1,1,-1,-1];return function(options){var ticks=options.ticks;var bounds=options.bounds;var data=new Float32Array(6*3*(ticks[0].length+ticks[1].length));var zeroLineEnable=this.plot.zeroLineEnable;var ptr=0;var gridTicks=[[],[]];for(var dim=0;dim<2;++dim){var localTicks=gridTicks[dim];var axisTicks=ticks[dim];var lo=bounds[dim];var hi=bounds[dim+2];for(var i=0;i<axisTicks.length;++i){var x=(axisTicks[i].x-lo)/(hi-lo);localTicks.push(x);for(var j=0;j<6;++j){data[ptr++]=x;data[ptr++]=OFFSET_X[j];data[ptr++]=OFFSET_Y[j];}}}this.ticks=gridTicks;this.vbo.update(data);};}();proto.dispose=function(){this.vbo.dispose();this.shader.dispose();this.tickShader.dispose();};function createGrid(plot){var gl=plot.gl;var vbo=createBuffer(gl);var shader=createShader(gl,shaders.gridVert,shaders.gridFrag);var tickShader=createShader(gl,shaders.tickVert,shaders.gridFrag);var grid=new Grid(plot,vbo,shader,tickShader);return grid;}/***/},/***/1154:/***/function(module,__unused_webpack_exports,__nested_webpack_require_404765__){"use strict";module.exports=createLines;var createBuffer=__nested_webpack_require_404765__(5827);var createShader=__nested_webpack_require_404765__(5158);var shaders=__nested_webpack_require_404765__(2709);function Lines(plot,vbo,shader){this.plot=plot;this.vbo=vbo;this.shader=shader;}var proto=Lines.prototype;proto.bind=function(){var shader=this.shader;this.vbo.bind();this.shader.bind();shader.attributes.coord.pointer();shader.uniforms.screenBox=this.plot.screenBox;};proto.drawLine=function(){var start=[0,0];var end=[0,0];return function(startX,startY,endX,endY,width,color){var plot=this.plot;var shader=this.shader;var gl=plot.gl;start[0]=startX;start[1]=startY;end[0]=endX;end[1]=endY;shader.uniforms.start=start;shader.uniforms.end=end;shader.uniforms.width=width*plot.pixelRatio;shader.uniforms.color=color;gl.drawArrays(gl.TRIANGLE_STRIP,0,4);};}();proto.dispose=function(){this.vbo.dispose();this.shader.dispose();};function createLines(plot){var gl=plot.gl;var vbo=createBuffer(gl,[-1,-1,-1,1,1,-1,1,1]);var shader=createShader(gl,shaders.lineVert,shaders.lineFrag);var lines=new Lines(plot,vbo,shader);return lines;}/***/},/***/2709:/***/function(module,__unused_webpack_exports,__nested_webpack_require_405940__){"use strict";var glslify=__nested_webpack_require_405940__(6832);var FRAGMENT=glslify(["precision lowp float;\n#define GLSLIFY 1\nuniform vec4 color;\nvoid main() {\n  gl_FragColor = vec4(color.xyz * color.w, color.w);\n}\n"]);module.exports={lineVert:glslify(["precision mediump float;\n#define GLSLIFY 1\n\nattribute vec2 coord;\n\nuniform vec4 screenBox;\nuniform vec2 start, end;\nuniform float width;\n\nvec2 perp(vec2 v) {\n  return vec2(v.y, -v.x);\n}\n\nvec2 screen(vec2 v) {\n  return 2.0 * (v - screenBox.xy) / (screenBox.zw - screenBox.xy) - 1.0;\n}\n\nvoid main() {\n  vec2 delta = normalize(perp(start - end));\n  vec2 offset = mix(start, end, 0.5 * (coord.y+1.0));\n  gl_Position = vec4(screen(offset + 0.5 * width * delta * coord.x), 0, 1);\n}\n"]),lineFrag:FRAGMENT,textVert:glslify(["#define GLSLIFY 1\nattribute vec3 textCoordinate;\n\nuniform vec2 dataScale, dataShift, dataAxis, screenOffset, textScale;\nuniform float angle;\n\nvoid main() {\n  float dataOffset  = textCoordinate.z;\n  vec2 glyphOffset  = textCoordinate.xy;\n  mat2 glyphMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n  vec2 screenCoordinate = dataAxis * (dataScale * dataOffset + dataShift) +\n    glyphMatrix * glyphOffset * textScale + screenOffset;\n  gl_Position = vec4(screenCoordinate, 0, 1);\n}\n"]),textFrag:FRAGMENT,gridVert:glslify(["precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 dataCoord;\n\nuniform vec2 dataAxis, dataShift, dataScale;\nuniform float lineWidth;\n\nvoid main() {\n  vec2 pos = dataAxis * (dataScale * dataCoord.x + dataShift);\n  pos += 10.0 * dataCoord.y * vec2(dataAxis.y, -dataAxis.x) + dataCoord.z * lineWidth;\n  gl_Position = vec4(pos, 0, 1);\n}\n"]),gridFrag:FRAGMENT,boxVert:glslify(["precision mediump float;\n#define GLSLIFY 1\n\nattribute vec2 coord;\n\nuniform vec4 screenBox;\nuniform vec2 lo, hi;\n\nvec2 screen(vec2 v) {\n  return 2.0 * (v - screenBox.xy) / (screenBox.zw - screenBox.xy) - 1.0;\n}\n\nvoid main() {\n  gl_Position = vec4(screen(mix(lo, hi, coord)), 0, 1);\n}\n"]),tickVert:glslify(["precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 dataCoord;\n\nuniform vec2 dataAxis, dataShift, dataScale, screenOffset, tickScale;\n\nvoid main() {\n  vec2 pos = dataAxis * (dataScale * dataCoord.x + dataShift);\n  gl_Position = vec4(pos + tickScale*dataCoord.yz + screenOffset, 0, 1);\n}\n"])};/***/},/***/5613:/***/function(module,__unused_webpack_exports,__nested_webpack_require_408386__){"use strict";module.exports=createTextElements;var createBuffer=__nested_webpack_require_408386__(5827);var createShader=__nested_webpack_require_408386__(5158);var getText=__nested_webpack_require_408386__(6946);var bsearch=__nested_webpack_require_408386__(5070);var shaders=__nested_webpack_require_408386__(2709);function TextElements(plot,vbo,shader){this.plot=plot;this.vbo=vbo;this.shader=shader;this.tickOffset=[[],[]];this.tickX=[[],[]];this.labelOffset=[0,0];this.labelCount=[0,0];}var proto=TextElements.prototype;proto.drawTicks=function(){var DATA_AXIS=[0,0];var SCREEN_OFFSET=[0,0];var ZERO_2=[0,0];return function(axis){var plot=this.plot;var shader=this.shader;var tickX=this.tickX[axis];var tickOffset=this.tickOffset[axis];var gl=plot.gl;var viewBox=plot.viewBox;var dataBox=plot.dataBox;var screenBox=plot.screenBox;var pixelRatio=plot.pixelRatio;var tickEnable=plot.tickEnable;var tickPad=plot.tickPad;var textColor=plot.tickColor;var textAngle=plot.tickAngle;// todo check if this should be used (now unused)
// var tickLength  = plot.tickMarkLength
var labelEnable=plot.labelEnable;var labelPad=plot.labelPad;var labelColor=plot.labelColor;var labelAngle=plot.labelAngle;var labelOffset=this.labelOffset[axis];var labelCount=this.labelCount[axis];var start=bsearch.lt(tickX,dataBox[axis]);var end=bsearch.le(tickX,dataBox[axis+2]);DATA_AXIS[0]=DATA_AXIS[1]=0;DATA_AXIS[axis]=1;SCREEN_OFFSET[axis]=(viewBox[2+axis]+viewBox[axis])/(screenBox[2+axis]-screenBox[axis])-1.0;var screenScale=2.0/screenBox[2+(axis^1)]-screenBox[axis^1];SCREEN_OFFSET[axis^1]=screenScale*viewBox[axis^1]-1.0;if(tickEnable[axis]){SCREEN_OFFSET[axis^1]-=screenScale*pixelRatio*tickPad[axis];if(start<end&&tickOffset[end]>tickOffset[start]){shader.uniforms.dataAxis=DATA_AXIS;shader.uniforms.screenOffset=SCREEN_OFFSET;shader.uniforms.color=textColor[axis];shader.uniforms.angle=textAngle[axis];gl.drawArrays(gl.TRIANGLES,tickOffset[start],tickOffset[end]-tickOffset[start]);}}if(labelEnable[axis]&&labelCount){SCREEN_OFFSET[axis^1]-=screenScale*pixelRatio*labelPad[axis];shader.uniforms.dataAxis=ZERO_2;shader.uniforms.screenOffset=SCREEN_OFFSET;shader.uniforms.color=labelColor[axis];shader.uniforms.angle=labelAngle[axis];gl.drawArrays(gl.TRIANGLES,labelOffset,labelCount);}SCREEN_OFFSET[axis^1]=screenScale*viewBox[2+(axis^1)]-1.0;if(tickEnable[axis+2]){SCREEN_OFFSET[axis^1]+=screenScale*pixelRatio*tickPad[axis+2];if(start<end&&tickOffset[end]>tickOffset[start]){shader.uniforms.dataAxis=DATA_AXIS;shader.uniforms.screenOffset=SCREEN_OFFSET;shader.uniforms.color=textColor[axis+2];shader.uniforms.angle=textAngle[axis+2];gl.drawArrays(gl.TRIANGLES,tickOffset[start],tickOffset[end]-tickOffset[start]);}}if(labelEnable[axis+2]&&labelCount){SCREEN_OFFSET[axis^1]+=screenScale*pixelRatio*labelPad[axis+2];shader.uniforms.dataAxis=ZERO_2;shader.uniforms.screenOffset=SCREEN_OFFSET;shader.uniforms.color=labelColor[axis+2];shader.uniforms.angle=labelAngle[axis+2];gl.drawArrays(gl.TRIANGLES,labelOffset,labelCount);}};}();proto.drawTitle=function(){var DATA_AXIS=[0,0];var SCREEN_OFFSET=[0,0];return function(){var plot=this.plot;var shader=this.shader;var gl=plot.gl;var screenBox=plot.screenBox;var titleCenter=plot.titleCenter;var titleAngle=plot.titleAngle;var titleColor=plot.titleColor;var pixelRatio=plot.pixelRatio;if(!this.titleCount){return;}for(var i=0;i<2;++i){SCREEN_OFFSET[i]=2.0*(titleCenter[i]*pixelRatio-screenBox[i])/(screenBox[2+i]-screenBox[i])-1;}shader.bind();shader.uniforms.dataAxis=DATA_AXIS;shader.uniforms.screenOffset=SCREEN_OFFSET;shader.uniforms.angle=titleAngle;shader.uniforms.color=titleColor;gl.drawArrays(gl.TRIANGLES,this.titleOffset,this.titleCount);};}();proto.bind=function(){var DATA_SHIFT=[0,0];var DATA_SCALE=[0,0];var TEXT_SCALE=[0,0];return function(){var plot=this.plot;var shader=this.shader;var bounds=plot._tickBounds;var dataBox=plot.dataBox;var screenBox=plot.screenBox;var viewBox=plot.viewBox;shader.bind();//Set up coordinate scaling uniforms
for(var i=0;i<2;++i){var lo=bounds[i];var hi=bounds[i+2];var boundScale=hi-lo;var dataCenter=0.5*(dataBox[i+2]+dataBox[i]);var dataWidth=dataBox[i+2]-dataBox[i];var viewLo=viewBox[i];var viewHi=viewBox[i+2];var viewScale=viewHi-viewLo;var screenLo=screenBox[i];var screenHi=screenBox[i+2];var screenScale=screenHi-screenLo;DATA_SCALE[i]=2.0*boundScale/dataWidth*viewScale/screenScale;DATA_SHIFT[i]=2.0*(lo-dataCenter)/dataWidth*viewScale/screenScale;}TEXT_SCALE[1]=2.0*plot.pixelRatio/(screenBox[3]-screenBox[1]);TEXT_SCALE[0]=TEXT_SCALE[1]*(screenBox[3]-screenBox[1])/(screenBox[2]-screenBox[0]);shader.uniforms.dataScale=DATA_SCALE;shader.uniforms.dataShift=DATA_SHIFT;shader.uniforms.textScale=TEXT_SCALE;//Set attributes
this.vbo.bind();shader.attributes.textCoordinate.pointer();};}();proto.update=function(options){var vertices=[];var axesTicks=options.ticks;var bounds=options.bounds;var i,j,k,data,scale,dimension;for(dimension=0;dimension<2;++dimension){var offsets=[Math.floor(vertices.length/3)],tickX=[-Infinity];//Copy vertices over to buffer
var ticks=axesTicks[dimension];for(i=0;i<ticks.length;++i){var tick=ticks[i];var x=tick.x;var text=tick.text;var font=tick.font||'sans-serif';scale=tick.fontSize||12;var coordScale=1.0/(bounds[dimension+2]-bounds[dimension]);var coordShift=bounds[dimension];var rows=text.split('\n');for(var r=0;r<rows.length;r++){data=getText(font,rows[r]).data;for(j=0;j<data.length;j+=2){vertices.push(data[j]*scale,-data[j+1]*scale-r*scale*1.2,(x-coordShift)*coordScale);}}offsets.push(Math.floor(vertices.length/3));tickX.push(x);}this.tickOffset[dimension]=offsets;this.tickX[dimension]=tickX;}//Add labels
for(dimension=0;dimension<2;++dimension){this.labelOffset[dimension]=Math.floor(vertices.length/3);data=getText(options.labelFont[dimension],options.labels[dimension],{textAlign:'center'}).data;scale=options.labelSize[dimension];for(i=0;i<data.length;i+=2){vertices.push(data[i]*scale,-data[i+1]*scale,0);}this.labelCount[dimension]=Math.floor(vertices.length/3)-this.labelOffset[dimension];}//Add title
this.titleOffset=Math.floor(vertices.length/3);data=getText(options.titleFont,options.title).data;scale=options.titleSize;for(i=0;i<data.length;i+=2){vertices.push(data[i]*scale,-data[i+1]*scale,0);}this.titleCount=Math.floor(vertices.length/3)-this.titleOffset;//Upload new vertices
this.vbo.update(vertices);};proto.dispose=function(){this.vbo.dispose();this.shader.dispose();};function createTextElements(plot){var gl=plot.gl;var vbo=createBuffer(gl);var shader=createShader(gl,shaders.textVert,shaders.textFrag);var text=new TextElements(plot,vbo,shader);return text;}/***/},/***/2117:/***/function(module,__unused_webpack_exports,__nested_webpack_require_415020__){"use strict";module.exports=createGLPlot2D;var createPick=__nested_webpack_require_415020__(2611);var createGrid=__nested_webpack_require_415020__(3016);var createText=__nested_webpack_require_415020__(5613);var createLine=__nested_webpack_require_415020__(1154);var createBox=__nested_webpack_require_415020__(4554);function GLPlot2D(gl,pickBuffer){this.gl=gl;this.pickBuffer=pickBuffer;this.screenBox=[0,0,gl.drawingBufferWidth,gl.drawingBufferHeight];this.viewBox=[0,0,0,0];this.dataBox=[-10,-10,10,10];this.gridLineEnable=[true,true];this.gridLineWidth=[1,1];this.gridLineColor=[[0,0,0,1],[0,0,0,1]];this.pixelRatio=1;this.tickMarkLength=[0,0,0,0];this.tickMarkWidth=[0,0,0,0];this.tickMarkColor=[[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1]];this.tickPad=[15,15,15,15];this.tickAngle=[0,0,0,0];this.tickEnable=[true,true,true,true];this.tickColor=[[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1]];this.labelPad=[15,15,15,15];this.labelAngle=[0,Math.PI/2,0,3.0*Math.PI/2];this.labelEnable=[true,true,true,true];this.labelColor=[[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1]];this.titleCenter=[0,0];this.titleEnable=true;this.titleAngle=0;this.titleColor=[0,0,0,1];this.borderColor=[0,0,0,0];this.backgroundColor=[0,0,0,0];this.zeroLineEnable=[true,true];this.zeroLineWidth=[4,4];this.zeroLineColor=[[0,0,0,1],[0,0,0,1]];this.borderLineEnable=[true,true,true,true];this.borderLineWidth=[2,2,2,2];this.borderLineColor=[[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1]];//Drawing parameters
this.grid=null;this.text=null;this.line=null;this.box=null;this.objects=[];this.overlays=[];this._tickBounds=[Infinity,Infinity,-Infinity,-Infinity];this.static=false;this.dirty=false;this.pickDirty=false;this.pickDelay=120;this.pickRadius=10;this._pickTimeout=null;this._drawPick=this.drawPick.bind(this);this._depthCounter=0;}var proto=GLPlot2D.prototype;proto.setDirty=function(){this.dirty=this.pickDirty=true;};proto.setOverlayDirty=function(){this.dirty=true;};proto.nextDepthValue=function(){return this._depthCounter++/65536.0;};function lerp(a,b,t){var s=0.5*(t+1.0);return Math.floor((1.0-s)*a+s*b)|0;}proto.draw=function(){var TICK_MARK_BOX=[0,0,0,0];return function(){var gl=this.gl;var screenBox=this.screenBox;var viewPixels=this.viewBox;var dataBox=this.dataBox;var pixelRatio=this.pixelRatio;var grid=this.grid;var line=this.line;var text=this.text;var objects=this.objects;this._depthCounter=0;if(this.pickDirty){if(this._pickTimeout){clearTimeout(this._pickTimeout);}this.pickDirty=false;this._pickTimeout=setTimeout(this._drawPick,this.pickDelay);}if(!this.dirty){return;}this.dirty=false;gl.bindFramebuffer(gl.FRAMEBUFFER,null);//Turn on scissor
gl.enable(gl.SCISSOR_TEST);//Turn off depth buffer
gl.disable(gl.DEPTH_TEST);gl.depthFunc(gl.LESS);gl.depthMask(false);//Configure premultiplied alpha blending
gl.enable(gl.BLEND);gl.blendEquation(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFunc(gl.ONE,gl.ONE_MINUS_SRC_ALPHA);//Draw border
if(this.borderColor){gl.scissor(screenBox[0],screenBox[1],screenBox[2]-screenBox[0],screenBox[3]-screenBox[1]);var borderColor=this.borderColor;gl.clearColor(borderColor[0]*borderColor[3],borderColor[1]*borderColor[3],borderColor[2]*borderColor[3],borderColor[3]);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);}//Draw center pane
gl.scissor(viewPixels[0],viewPixels[1],viewPixels[2]-viewPixels[0],viewPixels[3]-viewPixels[1]);gl.viewport(viewPixels[0],viewPixels[1],viewPixels[2]-viewPixels[0],viewPixels[3]-viewPixels[1]);var backgroundColor=this.backgroundColor;gl.clearColor(backgroundColor[0]*backgroundColor[3],backgroundColor[1]*backgroundColor[3],backgroundColor[2]*backgroundColor[3],backgroundColor[3]);gl.clear(gl.COLOR_BUFFER_BIT);//Draw grid
grid.draw();//Draw zero lines separately
var zeroLineEnable=this.zeroLineEnable;var zeroLineColor=this.zeroLineColor;var zeroLineWidth=this.zeroLineWidth;if(zeroLineEnable[0]||zeroLineEnable[1]){line.bind();for(var i=0;i<2;++i){if(!zeroLineEnable[i]||!(dataBox[i]<=0&&dataBox[i+2]>=0)){continue;}var zeroIntercept=screenBox[i]-dataBox[i]*(screenBox[i+2]-screenBox[i])/(dataBox[i+2]-dataBox[i]);if(i===0){line.drawLine(zeroIntercept,screenBox[1],zeroIntercept,screenBox[3],zeroLineWidth[i],zeroLineColor[i]);}else{line.drawLine(screenBox[0],zeroIntercept,screenBox[2],zeroIntercept,zeroLineWidth[i],zeroLineColor[i]);}}}//Draw traces
for(var i=0;i<objects.length;++i){objects[i].draw();}//Return viewport to default
gl.viewport(screenBox[0],screenBox[1],screenBox[2]-screenBox[0],screenBox[3]-screenBox[1]);gl.scissor(screenBox[0],screenBox[1],screenBox[2]-screenBox[0],screenBox[3]-screenBox[1]);//Draw tick marks
this.grid.drawTickMarks();//Draw line elements
line.bind();//Draw border lines
var borderLineEnable=this.borderLineEnable;var borderLineWidth=this.borderLineWidth;var borderLineColor=this.borderLineColor;if(borderLineEnable[1]){line.drawLine(viewPixels[0],viewPixels[1]-0.5*borderLineWidth[1]*pixelRatio,viewPixels[0],viewPixels[3]+0.5*borderLineWidth[3]*pixelRatio,borderLineWidth[1],borderLineColor[1]);}if(borderLineEnable[0]){line.drawLine(viewPixels[0]-0.5*borderLineWidth[0]*pixelRatio,viewPixels[1],viewPixels[2]+0.5*borderLineWidth[2]*pixelRatio,viewPixels[1],borderLineWidth[0],borderLineColor[0]);}if(borderLineEnable[3]){line.drawLine(viewPixels[2],viewPixels[1]-0.5*borderLineWidth[1]*pixelRatio,viewPixels[2],viewPixels[3]+0.5*borderLineWidth[3]*pixelRatio,borderLineWidth[3],borderLineColor[3]);}if(borderLineEnable[2]){line.drawLine(viewPixels[0]-0.5*borderLineWidth[0]*pixelRatio,viewPixels[3],viewPixels[2]+0.5*borderLineWidth[2]*pixelRatio,viewPixels[3],borderLineWidth[2],borderLineColor[2]);}//Draw text elements
text.bind();for(var i=0;i<2;++i){text.drawTicks(i);}if(this.titleEnable){text.drawTitle();}//Draw other overlay elements (select boxes, etc.)
var overlays=this.overlays;for(var i=0;i<overlays.length;++i){overlays[i].draw();}//Turn off scissor test
gl.disable(gl.SCISSOR_TEST);gl.disable(gl.BLEND);gl.depthMask(true);};}();proto.drawPick=function(){return function(){if(this.static)return;var pickBuffer=this.pickBuffer;var gl=this.gl;this._pickTimeout=null;pickBuffer.begin();var pickOffset=1;var objects=this.objects;for(var i=0;i<objects.length;++i){pickOffset=objects[i].drawPick(pickOffset);}pickBuffer.end();};}();proto.pick=function(){return function(x,y){if(this.static)return;var pixelRatio=this.pixelRatio;var pickPixelRatio=this.pickPixelRatio;var viewBox=this.viewBox;var scrX=Math.round((x-viewBox[0]/pixelRatio)*pickPixelRatio)|0;var scrY=Math.round((y-viewBox[1]/pixelRatio)*pickPixelRatio)|0;var pickResult=this.pickBuffer.query(scrX,scrY,this.pickRadius);if(!pickResult){return null;}var pickValue=pickResult.id+(pickResult.value[0]<<8)+(pickResult.value[1]<<16)+(pickResult.value[2]<<24);var objects=this.objects;for(var i=0;i<objects.length;++i){var result=objects[i].pick(scrX,scrY,pickValue);if(result){return result;}}return null;};}();function deepClone(array){var result=array.slice();for(var i=0;i<result.length;++i){result[i]=result[i].slice();}return result;}function compareTicks(a,b){return a.x-b.x;}proto.setScreenBox=function(nbox){var screenBox=this.screenBox;var pixelRatio=this.pixelRatio;screenBox[0]=Math.round(nbox[0]*pixelRatio)|0;screenBox[1]=Math.round(nbox[1]*pixelRatio)|0;screenBox[2]=Math.round(nbox[2]*pixelRatio)|0;screenBox[3]=Math.round(nbox[3]*pixelRatio)|0;this.setDirty();};proto.setDataBox=function(nbox){var dataBox=this.dataBox;var different=dataBox[0]!==nbox[0]||dataBox[1]!==nbox[1]||dataBox[2]!==nbox[2]||dataBox[3]!==nbox[3];if(different){dataBox[0]=nbox[0];dataBox[1]=nbox[1];dataBox[2]=nbox[2];dataBox[3]=nbox[3];this.setDirty();}};proto.setViewBox=function(nbox){var pixelRatio=this.pixelRatio;var viewBox=this.viewBox;viewBox[0]=Math.round(nbox[0]*pixelRatio)|0;viewBox[1]=Math.round(nbox[1]*pixelRatio)|0;viewBox[2]=Math.round(nbox[2]*pixelRatio)|0;viewBox[3]=Math.round(nbox[3]*pixelRatio)|0;var pickPixelRatio=this.pickPixelRatio;this.pickBuffer.shape=[Math.round((nbox[2]-nbox[0])*pickPixelRatio)|0,Math.round((nbox[3]-nbox[1])*pickPixelRatio)|0];this.setDirty();};proto.update=function(options){options=options||{};var gl=this.gl;this.pixelRatio=options.pixelRatio||1;var pixelRatio=this.pixelRatio;this.pickPixelRatio=Math.max(pixelRatio,1);this.setScreenBox(options.screenBox||[0,0,gl.drawingBufferWidth/pixelRatio,gl.drawingBufferHeight/pixelRatio]);var screenBox=this.screenBox;this.setViewBox(options.viewBox||[0.125*(this.screenBox[2]-this.screenBox[0])/pixelRatio,0.125*(this.screenBox[3]-this.screenBox[1])/pixelRatio,0.875*(this.screenBox[2]-this.screenBox[0])/pixelRatio,0.875*(this.screenBox[3]-this.screenBox[1])/pixelRatio]);var viewBox=this.viewBox;var aspectRatio=(viewBox[2]-viewBox[0])/(viewBox[3]-viewBox[1]);this.setDataBox(options.dataBox||[-10,-10/aspectRatio,10,10/aspectRatio]);this.borderColor=options.borderColor!==false?(options.borderColor||[0,0,0,0]).slice():false;this.backgroundColor=(options.backgroundColor||[0,0,0,0]).slice();this.gridLineEnable=(options.gridLineEnable||[true,true]).slice();this.gridLineWidth=(options.gridLineWidth||[1,1]).slice();this.gridLineColor=deepClone(options.gridLineColor||[[0.5,0.5,0.5,1],[0.5,0.5,0.5,1]]);this.zeroLineEnable=(options.zeroLineEnable||[true,true]).slice();this.zeroLineWidth=(options.zeroLineWidth||[4,4]).slice();this.zeroLineColor=deepClone(options.zeroLineColor||[[0,0,0,1],[0,0,0,1]]);this.tickMarkLength=(options.tickMarkLength||[0,0,0,0]).slice();this.tickMarkWidth=(options.tickMarkWidth||[0,0,0,0]).slice();this.tickMarkColor=deepClone(options.tickMarkColor||[[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1]]);this.titleCenter=(options.titleCenter||[0.5*(viewBox[0]+viewBox[2])/pixelRatio,(viewBox[3]+120)/pixelRatio]).slice();this.titleEnable=!('titleEnable'in options)||!!options.titleEnable;this.titleAngle=options.titleAngle||0;this.titleColor=(options.titleColor||[0,0,0,1]).slice();this.labelPad=(options.labelPad||[15,15,15,15]).slice();this.labelAngle=(options.labelAngle||[0,Math.PI/2,0,3.0*Math.PI/2]).slice();this.labelEnable=(options.labelEnable||[true,true,true,true]).slice();this.labelColor=deepClone(options.labelColor||[[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1]]);this.tickPad=(options.tickPad||[15,15,15,15]).slice();this.tickAngle=(options.tickAngle||[0,0,0,0]).slice();this.tickEnable=(options.tickEnable||[true,true,true,true]).slice();this.tickColor=deepClone(options.tickColor||[[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1]]);this.borderLineEnable=(options.borderLineEnable||[true,true,true,true]).slice();this.borderLineWidth=(options.borderLineWidth||[2,2,2,2]).slice();this.borderLineColor=deepClone(options.borderLineColor||[[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1]]);var ticks=options.ticks||[[],[]];//Compute bounds on ticks
var bounds=this._tickBounds;bounds[0]=bounds[1]=Infinity;bounds[2]=bounds[3]=-Infinity;for(var i=0;i<2;++i){var axisTicks=ticks[i].slice(0);if(axisTicks.length===0){continue;}axisTicks.sort(compareTicks);bounds[i]=Math.min(bounds[i],axisTicks[0].x);bounds[i+2]=Math.max(bounds[i+2],axisTicks[axisTicks.length-1].x);}//Update grid
this.grid.update({bounds:bounds,ticks:ticks});//Update text
this.text.update({bounds:bounds,ticks:ticks,labels:options.labels||['x','y'],labelSize:options.labelSize||[12,12],labelFont:options.labelFont||['sans-serif','sans-serif'],title:options.title||'',titleSize:options.titleSize||18,titleFont:options.titleFont||'sans-serif'});this.static=!!options.static;this.setDirty();};proto.dispose=function(){this.box.dispose();this.grid.dispose();this.text.dispose();this.line.dispose();for(var i=this.objects.length-1;i>=0;--i){this.objects[i].dispose();}this.objects.length=0;for(var i=this.overlays.length-1;i>=0;--i){this.overlays[i].dispose();}this.overlays.length=0;this.gl=null;};proto.addObject=function(object){if(this.objects.indexOf(object)<0){this.objects.push(object);this.setDirty();}};proto.removeObject=function(object){var objects=this.objects;for(var i=0;i<objects.length;++i){if(objects[i]===object){objects.splice(i,1);this.setDirty();break;}}};proto.addOverlay=function(object){if(this.overlays.indexOf(object)<0){this.overlays.push(object);this.setOverlayDirty();}};proto.removeOverlay=function(object){var objects=this.overlays;for(var i=0;i<objects.length;++i){if(objects[i]===object){objects.splice(i,1);this.setOverlayDirty();break;}}};function createGLPlot2D(options){var gl=options.gl;var pickBuffer=createPick(gl,[gl.drawingBufferWidth,gl.drawingBufferHeight]);var plot=new GLPlot2D(gl,pickBuffer);plot.grid=createGrid(plot);plot.text=createText(plot);plot.line=createLine(plot);plot.box=createBox(plot);plot.update(options);return plot;}/***/},/***/4296:/***/function(module,__unused_webpack_exports,__nested_webpack_require_427633__){"use strict";module.exports=createCamera;var now=__nested_webpack_require_427633__(8161);var createView=__nested_webpack_require_427633__(1152);var mouseChange=__nested_webpack_require_427633__(6145);var mouseWheel=__nested_webpack_require_427633__(6475);var mouseOffset=__nested_webpack_require_427633__(2565);var hasPassive=__nested_webpack_require_427633__(5233);function createCamera(element,options){element=element||document.body;options=options||{};var limits=[0.01,Infinity];if('distanceLimits'in options){limits[0]=options.distanceLimits[0];limits[1]=options.distanceLimits[1];}if('zoomMin'in options){limits[0]=options.zoomMin;}if('zoomMax'in options){limits[1]=options.zoomMax;}var view=createView({center:options.center||[0,0,0],up:options.up||[0,1,0],eye:options.eye||[0,0,10],mode:options.mode||'orbit',distanceLimits:limits});var pmatrix=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];var distance=0.0;var width=element.clientWidth;var height=element.clientHeight;var camera={keyBindingMode:'rotate',enableWheel:true,view:view,element:element,delay:options.delay||16,rotateSpeed:options.rotateSpeed||1,zoomSpeed:options.zoomSpeed||1,translateSpeed:options.translateSpeed||1,flipX:!!options.flipX,flipY:!!options.flipY,modes:view.modes,_ortho:options._ortho||options.projection&&options.projection.type==='orthographic'||false,tick:function(){var t=now();var delay=this.delay;var ctime=t-2*delay;view.idle(t-delay);view.recalcMatrix(ctime);view.flush(t-(100+delay*2));var allEqual=true;var matrix=view.computedMatrix;for(var i=0;i<16;++i){allEqual=allEqual&&pmatrix[i]===matrix[i];pmatrix[i]=matrix[i];}var sizeChanged=element.clientWidth===width&&element.clientHeight===height;width=element.clientWidth;height=element.clientHeight;if(allEqual){return!sizeChanged;}distance=Math.exp(view.computedRadius[0]);return true;},lookAt:function(eye,center,up){view.lookAt(view.lastT(),eye,center,up);},rotate:function(pitch,yaw,roll){view.rotate(view.lastT(),pitch,yaw,roll);},pan:function(dx,dy,dz){view.pan(view.lastT(),dx,dy,dz);},translate:function(dx,dy,dz){view.translate(view.lastT(),dx,dy,dz);}};Object.defineProperties(camera,{matrix:{get:function(){return view.computedMatrix;},set:function(mat){view.setMatrix(view.lastT(),mat);return view.computedMatrix;},enumerable:true},mode:{get:function(){return view.getMode();},set:function(mode){var curUp=view.computedUp.slice();var curEye=view.computedEye.slice();var curCenter=view.computedCenter.slice();view.setMode(mode);if(mode==='turntable'){// Hacky time warping stuff to generate smooth animation
var t0=now();view._active.lookAt(t0,curEye,curCenter,curUp);view._active.lookAt(t0+500,curEye,curCenter,[0,0,1]);view._active.flush(t0);}return view.getMode();},enumerable:true},center:{get:function(){return view.computedCenter;},set:function(ncenter){view.lookAt(view.lastT(),null,ncenter);return view.computedCenter;},enumerable:true},eye:{get:function(){return view.computedEye;},set:function(neye){view.lookAt(view.lastT(),neye);return view.computedEye;},enumerable:true},up:{get:function(){return view.computedUp;},set:function(nup){view.lookAt(view.lastT(),null,null,nup);return view.computedUp;},enumerable:true},distance:{get:function(){return distance;},set:function(d){view.setDistance(view.lastT(),d);return d;},enumerable:true},distanceLimits:{get:function(){return view.getDistanceLimits(limits);},set:function(v){view.setDistanceLimits(v);return v;},enumerable:true}});element.addEventListener('contextmenu',function(ev){ev.preventDefault();return false;});camera._lastX=-1;camera._lastY=-1;camera._lastMods={shift:false,control:false,alt:false,meta:false};camera.enableMouseListeners=function(){camera.mouseListener=mouseChange(element,handleInteraction);//enable simple touch interactions
element.addEventListener('touchstart',function(ev){var xy=mouseOffset(ev.changedTouches[0],element);handleInteraction(0,xy[0],xy[1],camera._lastMods);handleInteraction(1,xy[0],xy[1],camera._lastMods);},hasPassive?{passive:true}:false);element.addEventListener('touchmove',function(ev){var xy=mouseOffset(ev.changedTouches[0],element);handleInteraction(1,xy[0],xy[1],camera._lastMods);ev.preventDefault();},hasPassive?{passive:false}:false);element.addEventListener('touchend',function(ev){handleInteraction(0,camera._lastX,camera._lastY,camera._lastMods);},hasPassive?{passive:true}:false);function handleInteraction(buttons,x,y,mods){var keyBindingMode=camera.keyBindingMode;if(keyBindingMode===false)return;var rotate=keyBindingMode==='rotate';var pan=keyBindingMode==='pan';var zoom=keyBindingMode==='zoom';var ctrl=!!mods.control;var alt=!!mods.alt;var shift=!!mods.shift;var left=!!(buttons&1);var right=!!(buttons&2);var middle=!!(buttons&4);var scale=1.0/element.clientHeight;var dx=scale*(x-camera._lastX);var dy=scale*(y-camera._lastY);var flipX=camera.flipX?1:-1;var flipY=camera.flipY?1:-1;var drot=Math.PI*camera.rotateSpeed;var t=now();if(camera._lastX!==-1&&camera._lastY!==-1){if(rotate&&left&&!ctrl&&!alt&&!shift||left&&!ctrl&&!alt&&shift){// Rotate
view.rotate(t,flipX*drot*dx,-flipY*drot*dy,0);}if(pan&&left&&!ctrl&&!alt&&!shift||right||left&&ctrl&&!alt&&!shift){// Pan
view.pan(t,-camera.translateSpeed*dx*distance,camera.translateSpeed*dy*distance,0);}if(zoom&&left&&!ctrl&&!alt&&!shift||middle||left&&!ctrl&&alt&&!shift){// Zoom
var kzoom=-camera.zoomSpeed*dy/window.innerHeight*(t-view.lastT())*100;view.pan(t,0,0,distance*(Math.exp(kzoom)-1));}}camera._lastX=x;camera._lastY=y;camera._lastMods=mods;return true;}camera.wheelListener=mouseWheel(element,function(dx,dy){// TODO remove now that we can disable scroll via scrollZoom?
if(camera.keyBindingMode===false)return;if(!camera.enableWheel)return;var flipX=camera.flipX?1:-1;var flipY=camera.flipY?1:-1;var t=now();if(Math.abs(dx)>Math.abs(dy)){view.rotate(t,0,0,-dx*flipX*Math.PI*camera.rotateSpeed/window.innerWidth);}else{if(!camera._ortho){var kzoom=-camera.zoomSpeed*flipY*dy/window.innerHeight*(t-view.lastT())/20.0;view.pan(t,0,0,distance*(Math.exp(kzoom)-1));}}},true);};camera.enableMouseListeners();return camera;}/***/},/***/8245:/***/function(module,__unused_webpack_exports,__nested_webpack_require_433691__){var glslify=__nested_webpack_require_433691__(6832);var createShader=__nested_webpack_require_433691__(5158);var vertSrc=glslify(["precision mediump float;\n#define GLSLIFY 1\nattribute vec2 position;\nvarying vec2 uv;\nvoid main() {\n  uv = position;\n  gl_Position = vec4(position, 0, 1);\n}"]);var fragSrc=glslify(["precision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D accumBuffer;\nvarying vec2 uv;\n\nvoid main() {\n  vec4 accum = texture2D(accumBuffer, 0.5 * (uv + 1.0));\n  gl_FragColor = min(vec4(1,1,1,1), accum);\n}"]);module.exports=function(gl){return createShader(gl,vertSrc,fragSrc,null,[{name:'position',type:'vec2'}]);};/***/},/***/1059:/***/function(module,__unused_webpack_exports,__nested_webpack_require_434395__){"use strict";var createCamera=__nested_webpack_require_434395__(4296);var createAxes=__nested_webpack_require_434395__(7453);var axesRanges=__nested_webpack_require_434395__(2771);var createSpikes=__nested_webpack_require_434395__(6496);var createSelect=__nested_webpack_require_434395__(2611);var createFBO=__nested_webpack_require_434395__(4234);var drawTriangle=__nested_webpack_require_434395__(8126);var mouseChange=__nested_webpack_require_434395__(6145);var perspective=__nested_webpack_require_434395__(1120);var ortho=__nested_webpack_require_434395__(5268);var createShader=__nested_webpack_require_434395__(8245);var isMobile=__nested_webpack_require_434395__(2321)({tablet:true,featureDetect:true});module.exports={createScene:createScene,createCamera:createCamera};function MouseSelect(){this.mouse=[-1,-1];this.screen=null;this.distance=Infinity;this.index=null;this.dataCoordinate=null;this.dataPosition=null;this.object=null;this.data=null;}function getContext(canvas,options){var gl=null;try{gl=canvas.getContext('webgl',options);if(!gl){gl=canvas.getContext('experimental-webgl',options);}}catch(e){return null;}return gl;}function roundUpPow10(x){var y=Math.round(Math.log(Math.abs(x))/Math.log(10));if(y<0){var base=Math.round(Math.pow(10,-y));return Math.ceil(x*base)/base;}else if(y>0){var base=Math.round(Math.pow(10,y));return Math.ceil(x/base)*base;}return Math.ceil(x);}function defaultBool(x){if(typeof x==='boolean'){return x;}return true;}function createScene(options){options=options||{};options.camera=options.camera||{};var canvas=options.canvas;if(!canvas){canvas=document.createElement('canvas');if(options.container){var container=options.container;container.appendChild(canvas);}else{document.body.appendChild(canvas);}}var gl=options.gl;if(!gl){if(options.glOptions){isMobile=!!options.glOptions.preserveDrawingBuffer;}gl=getContext(canvas,options.glOptions||{premultipliedAlpha:true,antialias:true,preserveDrawingBuffer:isMobile});}if(!gl){throw new Error('webgl not supported');}//Initial bounds
var bounds=options.bounds||[[-10,-10,-10],[10,10,10]];//Create selection
var selection=new MouseSelect();//Accumulation buffer
var accumBuffer=createFBO(gl,gl.drawingBufferWidth,gl.drawingBufferHeight,{preferFloat:!isMobile});var accumShader=createShader(gl);var isOrtho=options.cameraObject&&options.cameraObject._ortho===true||options.camera.projection&&options.camera.projection.type==='orthographic'||false;//Create a camera
var cameraOptions={eye:options.camera.eye||[2,0,0],center:options.camera.center||[0,0,0],up:options.camera.up||[0,1,0],zoomMin:options.camera.zoomMax||0.1,zoomMax:options.camera.zoomMin||100,mode:options.camera.mode||'turntable',_ortho:isOrtho};//Create axes
var axesOptions=options.axes||{};var axes=createAxes(gl,axesOptions);axes.enable=!axesOptions.disable;//Create spikes
var spikeOptions=options.spikes||{};var spikes=createSpikes(gl,spikeOptions);//Object list is empty initially
var objects=[];var pickBufferIds=[];var pickBufferCount=[];var pickBuffers=[];//Dirty flag, skip redraw if scene static
var dirty=true;var pickDirty=true;var projection=new Array(16);var model=new Array(16);var cameraParams={view:null,projection:projection,model:model,_ortho:false};var pickDirty=true;var viewShape=[gl.drawingBufferWidth,gl.drawingBufferHeight];var camera=options.cameraObject||createCamera(canvas,cameraOptions);//Create scene object
var scene={gl:gl,contextLost:false,pixelRatio:options.pixelRatio||1,canvas:canvas,selection:selection,camera:camera,axes:axes,axesPixels:null,spikes:spikes,bounds:bounds,objects:objects,shape:viewShape,aspect:options.aspectRatio||[1,1,1],pickRadius:options.pickRadius||10,zNear:options.zNear||0.01,zFar:options.zFar||1000,fovy:options.fovy||Math.PI/4,clearColor:options.clearColor||[0,0,0,0],autoResize:defaultBool(options.autoResize),autoBounds:defaultBool(options.autoBounds),autoScale:!!options.autoScale,autoCenter:defaultBool(options.autoCenter),clipToBounds:defaultBool(options.clipToBounds),snapToData:!!options.snapToData,onselect:options.onselect||null,onrender:options.onrender||null,onclick:options.onclick||null,cameraParams:cameraParams,oncontextloss:null,mouseListener:null,_stopped:false,getAspectratio:function(){return{x:this.aspect[0],y:this.aspect[1],z:this.aspect[2]};},setAspectratio:function(aspectratio){this.aspect[0]=aspectratio.x;this.aspect[1]=aspectratio.y;this.aspect[2]=aspectratio.z;pickDirty=true;},setBounds:function(axisIndex,range){this.bounds[0][axisIndex]=range.min;this.bounds[1][axisIndex]=range.max;},setClearColor:function(clearColor){this.clearColor=clearColor;},clearRGBA:function(){this.gl.clearColor(this.clearColor[0],this.clearColor[1],this.clearColor[2],this.clearColor[3]);this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT);}};var pickShape=[gl.drawingBufferWidth/scene.pixelRatio|0,gl.drawingBufferHeight/scene.pixelRatio|0];function resizeListener(){if(scene._stopped){return;}if(!scene.autoResize){return;}var parent=canvas.parentNode;var width=1;var height=1;if(parent&&parent!==document.body){width=parent.clientWidth;height=parent.clientHeight;}else{width=window.innerWidth;height=window.innerHeight;}var nextWidth=Math.ceil(width*scene.pixelRatio)|0;var nextHeight=Math.ceil(height*scene.pixelRatio)|0;if(nextWidth!==canvas.width||nextHeight!==canvas.height){canvas.width=nextWidth;canvas.height=nextHeight;var style=canvas.style;style.position=style.position||'absolute';style.left='0px';style.top='0px';style.width=width+'px';style.height=height+'px';dirty=true;}}if(scene.autoResize){resizeListener();}window.addEventListener('resize',resizeListener);function reallocPickIds(){var numObjs=objects.length;var numPick=pickBuffers.length;for(var i=0;i<numPick;++i){pickBufferCount[i]=0;}obj_loop:for(var i=0;i<numObjs;++i){var obj=objects[i];var pickCount=obj.pickSlots;if(!pickCount){pickBufferIds[i]=-1;continue;}for(var j=0;j<numPick;++j){if(pickBufferCount[j]+pickCount<255){pickBufferIds[i]=j;obj.setPickBase(pickBufferCount[j]+1);pickBufferCount[j]+=pickCount;continue obj_loop;}}//Create new pick buffer
var nbuffer=createSelect(gl,viewShape);pickBufferIds[i]=numPick;pickBuffers.push(nbuffer);pickBufferCount.push(pickCount);obj.setPickBase(1);numPick+=1;}while(numPick>0&&pickBufferCount[numPick-1]===0){pickBufferCount.pop();pickBuffers.pop().dispose();}}scene.update=function(options){if(scene._stopped){return;}options=options||{};dirty=true;pickDirty=true;};scene.add=function(obj){if(scene._stopped){return;}obj.axes=axes;objects.push(obj);pickBufferIds.push(-1);dirty=true;pickDirty=true;reallocPickIds();};scene.remove=function(obj){if(scene._stopped){return;}var idx=objects.indexOf(obj);if(idx<0){return;}objects.splice(idx,1);pickBufferIds.pop();dirty=true;pickDirty=true;reallocPickIds();};scene.dispose=function(){if(scene._stopped){return;}scene._stopped=true;window.removeEventListener('resize',resizeListener);canvas.removeEventListener('webglcontextlost',checkContextLoss);scene.mouseListener.enabled=false;if(scene.contextLost){return;}//Destroy objects
axes.dispose();spikes.dispose();for(var i=0;i<objects.length;++i){objects[i].dispose();}//Clean up buffers
accumBuffer.dispose();for(var i=0;i<pickBuffers.length;++i){pickBuffers[i].dispose();}//Clean up shaders
accumShader.dispose();//Release all references
gl=null;axes=null;spikes=null;objects=[];};//Update mouse position
scene._mouseRotating=false;scene._prevButtons=0;scene.enableMouseListeners=function(){scene.mouseListener=mouseChange(canvas,function(buttons,x,y){if(scene._stopped){return;}var numPick=pickBuffers.length;var numObjs=objects.length;var prevObj=selection.object;selection.distance=Infinity;selection.mouse[0]=x;selection.mouse[1]=y;selection.object=null;selection.screen=null;selection.dataCoordinate=selection.dataPosition=null;var change=false;if(buttons&&scene._prevButtons){scene._mouseRotating=true;}else{if(scene._mouseRotating){pickDirty=true;}scene._mouseRotating=false;for(var i=0;i<numPick;++i){var result=pickBuffers[i].query(x,pickShape[1]-y-1,scene.pickRadius);if(result){if(result.distance>selection.distance){continue;}for(var j=0;j<numObjs;++j){var obj=objects[j];if(pickBufferIds[j]!==i){continue;}var objPick=obj.pick(result);if(objPick){selection.buttons=buttons;selection.screen=result.coord;selection.distance=result.distance;selection.object=obj;selection.index=objPick.distance;selection.dataPosition=objPick.position;selection.dataCoordinate=objPick.dataCoordinate;selection.data=objPick;change=true;}}}}}if(prevObj&&prevObj!==selection.object){if(prevObj.highlight){prevObj.highlight(null);}dirty=true;}if(selection.object){if(selection.object.highlight){selection.object.highlight(selection.data);}dirty=true;}change=change||selection.object!==prevObj;if(change&&scene.onselect){scene.onselect(selection);}if(buttons&1&&!(scene._prevButtons&1)&&scene.onclick){scene.onclick(selection);}scene._prevButtons=buttons;});};function checkContextLoss(){if(scene.contextLost){return true;}if(gl.isContextLost()){scene.contextLost=true;scene.mouseListener.enabled=false;scene.selection.object=null;if(scene.oncontextloss){scene.oncontextloss();}}}canvas.addEventListener('webglcontextlost',checkContextLoss);//Render the scene for mouse picking
function renderPick(){if(checkContextLoss()){return;}gl.colorMask(true,true,true,true);gl.depthMask(true);gl.disable(gl.BLEND);gl.enable(gl.DEPTH_TEST);gl.depthFunc(gl.LEQUAL);var numObjs=objects.length;var numPick=pickBuffers.length;for(var j=0;j<numPick;++j){var buf=pickBuffers[j];buf.shape=pickShape;buf.begin();for(var i=0;i<numObjs;++i){if(pickBufferIds[i]!==j){continue;}var obj=objects[i];if(obj.drawPick){obj.pixelRatio=1;obj.drawPick(cameraParams);}}buf.end();}}var nBounds=[[Infinity,Infinity,Infinity],[-Infinity,-Infinity,-Infinity]];var prevBounds=[nBounds[0].slice(),nBounds[1].slice()];function redraw(){if(checkContextLoss()){return;}resizeListener();//Tick camera
var cameraMoved=scene.camera.tick();cameraParams.view=scene.camera.matrix;dirty=dirty||cameraMoved;pickDirty=pickDirty||cameraMoved;//Set pixel ratio
axes.pixelRatio=scene.pixelRatio;spikes.pixelRatio=scene.pixelRatio;//Check if any objects changed, recalculate bounds
var numObjs=objects.length;var lo=nBounds[0];var hi=nBounds[1];lo[0]=lo[1]=lo[2]=Infinity;hi[0]=hi[1]=hi[2]=-Infinity;for(var i=0;i<numObjs;++i){var obj=objects[i];//Set the axes properties for each object
obj.pixelRatio=scene.pixelRatio;obj.axes=scene.axes;dirty=dirty||!!obj.dirty;pickDirty=pickDirty||!!obj.dirty;var obb=obj.bounds;if(obb){var olo=obb[0];var ohi=obb[1];for(var j=0;j<3;++j){lo[j]=Math.min(lo[j],olo[j]);hi[j]=Math.max(hi[j],ohi[j]);}}}//Recalculate bounds
var bounds=scene.bounds;if(scene.autoBounds){for(var j=0;j<3;++j){if(hi[j]<lo[j]){lo[j]=-1;hi[j]=1;}else{if(lo[j]===hi[j]){lo[j]-=1;hi[j]+=1;}var padding=0.05*(hi[j]-lo[j]);lo[j]=lo[j]-padding;hi[j]=hi[j]+padding;}bounds[0][j]=lo[j];bounds[1][j]=hi[j];}}var boundsChanged=false;for(var j=0;j<3;++j){boundsChanged=boundsChanged||prevBounds[0][j]!==bounds[0][j]||prevBounds[1][j]!==bounds[1][j];prevBounds[0][j]=bounds[0][j];prevBounds[1][j]=bounds[1][j];}//Recalculate bounds
pickDirty=pickDirty||boundsChanged;dirty=dirty||boundsChanged;if(!dirty){return;}if(boundsChanged){var tickSpacing=[0,0,0];for(var i=0;i<3;++i){tickSpacing[i]=roundUpPow10((bounds[1][i]-bounds[0][i])/10.0);}if(axes.autoTicks){axes.update({bounds:bounds,tickSpacing:tickSpacing});}else{axes.update({bounds:bounds});}}//Get scene
var width=gl.drawingBufferWidth;var height=gl.drawingBufferHeight;viewShape[0]=width;viewShape[1]=height;pickShape[0]=Math.max(width/scene.pixelRatio,1)|0;pickShape[1]=Math.max(height/scene.pixelRatio,1)|0;//Compute camera parameters
calcCameraParams(scene,isOrtho);//Apply axes/clip bounds
for(var i=0;i<numObjs;++i){var obj=objects[i];//Set axes bounds
obj.axesBounds=bounds;//Set clip bounds
if(scene.clipToBounds){obj.clipBounds=bounds;}}//Set spike parameters
if(selection.object){if(scene.snapToData){spikes.position=selection.dataCoordinate;}else{spikes.position=selection.dataPosition;}spikes.bounds=bounds;}//If state changed, then redraw pick buffers
if(pickDirty){pickDirty=false;renderPick();}//Recalculate pixel data
scene.axesPixels=axesRanges(scene.axes,cameraParams,width,height);//Call render callback
if(scene.onrender){scene.onrender();}//Read value
gl.bindFramebuffer(gl.FRAMEBUFFER,null);gl.viewport(0,0,width,height);//General strategy: 3 steps
//  1. render non-transparent objects
//  2. accumulate transparent objects into separate fbo
//  3. composite final scene
//Clear FBO
scene.clearRGBA();gl.depthMask(true);gl.colorMask(true,true,true,true);gl.enable(gl.DEPTH_TEST);gl.depthFunc(gl.LEQUAL);gl.disable(gl.BLEND);gl.disable(gl.CULL_FACE);//most visualization surfaces are 2 sided
//Render opaque pass
var hasTransparent=false;if(axes.enable){hasTransparent=hasTransparent||axes.isTransparent();axes.draw(cameraParams);}spikes.axes=axes;if(selection.object){spikes.draw(cameraParams);}gl.disable(gl.CULL_FACE);//most visualization surfaces are 2 sided
for(var i=0;i<numObjs;++i){var obj=objects[i];obj.axes=axes;obj.pixelRatio=scene.pixelRatio;if(obj.isOpaque&&obj.isOpaque()){obj.draw(cameraParams);}if(obj.isTransparent&&obj.isTransparent()){hasTransparent=true;}}if(hasTransparent){//Render transparent pass
accumBuffer.shape=viewShape;accumBuffer.bind();gl.clear(gl.DEPTH_BUFFER_BIT);gl.colorMask(false,false,false,false);gl.depthMask(true);gl.depthFunc(gl.LESS);//Render forward facing objects
if(axes.enable&&axes.isTransparent()){axes.drawTransparent(cameraParams);}for(var i=0;i<numObjs;++i){var obj=objects[i];if(obj.isOpaque&&obj.isOpaque()){obj.draw(cameraParams);}}//Render transparent pass
gl.enable(gl.BLEND);gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.ONE,gl.ONE_MINUS_SRC_ALPHA);gl.colorMask(true,true,true,true);gl.depthMask(false);gl.clearColor(0,0,0,0);gl.clear(gl.COLOR_BUFFER_BIT);if(axes.isTransparent()){axes.drawTransparent(cameraParams);}for(var i=0;i<numObjs;++i){var obj=objects[i];if(obj.isTransparent&&obj.isTransparent()){obj.drawTransparent(cameraParams);}}//Unbind framebuffer
gl.bindFramebuffer(gl.FRAMEBUFFER,null);//Draw composite pass
gl.blendFunc(gl.ONE,gl.ONE_MINUS_SRC_ALPHA);gl.disable(gl.DEPTH_TEST);accumShader.bind();accumBuffer.color[0].bind(0);accumShader.uniforms.accumBuffer=0;drawTriangle(gl);//Turn off blending
gl.disable(gl.BLEND);}//Clear dirty flags
dirty=false;for(var i=0;i<numObjs;++i){objects[i].dirty=false;}}//Draw the whole scene
function render(){if(scene._stopped||scene.contextLost){return;}// this order is important: ios safari sometimes has sync raf
redraw();requestAnimationFrame(render);}scene.enableMouseListeners();render();//Force redraw of whole scene
scene.redraw=function(){if(scene._stopped){return;}dirty=true;redraw();};return scene;}function calcCameraParams(scene,isOrtho){var bounds=scene.bounds;var cameraParams=scene.cameraParams;var projection=cameraParams.projection;var model=cameraParams.model;var width=scene.gl.drawingBufferWidth;var height=scene.gl.drawingBufferHeight;var zNear=scene.zNear;var zFar=scene.zFar;var fovy=scene.fovy;var r=width/height;if(isOrtho){ortho(projection,-r,r,-1,1,zNear,zFar);cameraParams._ortho=true;}else{perspective(projection,fovy,r,zNear,zFar);cameraParams._ortho=false;}//Compute model matrix
for(var i=0;i<16;++i){model[i]=0;}model[15]=1;var maxS=0;for(var i=0;i<3;++i){maxS=Math.max(maxS,bounds[1][i]-bounds[0][i]);}for(var i=0;i<3;++i){if(scene.autoScale){model[5*i]=scene.aspect[i]/(bounds[1][i]-bounds[0][i]);}else{model[5*i]=1/maxS;}if(scene.autoCenter){model[12+i]=-model[5*i]*0.5*(bounds[0][i]+bounds[1][i]);}}}/***/},/***/8023:/***/function(__unused_webpack_module,exports,__nested_webpack_require_449952__){var glslify=__nested_webpack_require_449952__(6832);exports.pointVertex=glslify(["precision mediump float;\n#define GLSLIFY 1\n\nattribute vec2 position;\n\nuniform mat3 matrix;\nuniform float pointSize;\nuniform float pointCloud;\n\nhighp float rand(vec2 co) {\n  highp float a = 12.9898;\n  highp float b = 78.233;\n  highp float c = 43758.5453;\n  highp float d = dot(co.xy, vec2(a, b));\n  highp float e = mod(d, 3.14);\n  return fract(sin(e) * c);\n}\n\nvoid main() {\n  vec3 hgPosition = matrix * vec3(position, 1);\n  gl_Position  = vec4(hgPosition.xy, 0, hgPosition.z);\n    // if we don't jitter the point size a bit, overall point cloud\n    // saturation 'jumps' on zooming, which is disturbing and confusing\n  gl_PointSize = pointSize * ((19.5 + rand(position)) / 20.0);\n  if(pointCloud != 0.0) { // pointCloud is truthy\n    // get the same square surface as circle would be\n    gl_PointSize *= 0.886;\n  }\n}"]);exports.pointFragment=glslify(["precision mediump float;\n#define GLSLIFY 1\n\nuniform vec4 color, borderColor;\nuniform float centerFraction;\nuniform float pointCloud;\n\nvoid main() {\n  float radius;\n  vec4 baseColor;\n  if(pointCloud != 0.0) { // pointCloud is truthy\n    if(centerFraction == 1.0) {\n      gl_FragColor = color;\n    } else {\n      gl_FragColor = mix(borderColor, color, centerFraction);\n    }\n  } else {\n    radius = length(2.0 * gl_PointCoord.xy - 1.0);\n    if(radius > 1.0) {\n      discard;\n    }\n    baseColor = mix(borderColor, color, step(radius, centerFraction));\n    gl_FragColor = vec4(baseColor.rgb * baseColor.a, baseColor.a);\n  }\n}\n"]);exports.pickVertex=glslify(["precision mediump float;\n#define GLSLIFY 1\n\nattribute vec2 position;\nattribute vec4 pickId;\n\nuniform mat3 matrix;\nuniform float pointSize;\nuniform vec4 pickOffset;\n\nvarying vec4 fragId;\n\nvoid main() {\n  vec3 hgPosition = matrix * vec3(position, 1);\n  gl_Position  = vec4(hgPosition.xy, 0, hgPosition.z);\n  gl_PointSize = pointSize;\n\n  vec4 id = pickId + pickOffset;\n  id.y += floor(id.x / 256.0);\n  id.x -= floor(id.x / 256.0) * 256.0;\n\n  id.z += floor(id.y / 256.0);\n  id.y -= floor(id.y / 256.0) * 256.0;\n\n  id.w += floor(id.z / 256.0);\n  id.z -= floor(id.z / 256.0) * 256.0;\n\n  fragId = id;\n}\n"]);exports.pickFragment=glslify(["precision mediump float;\n#define GLSLIFY 1\n\nvarying vec4 fragId;\n\nvoid main() {\n  float radius = length(2.0 * gl_PointCoord.xy - 1.0);\n  if(radius > 1.0) {\n    discard;\n  }\n  gl_FragColor = fragId / 255.0;\n}\n"]);/***/},/***/8271:/***/function(module,__unused_webpack_exports,__nested_webpack_require_452548__){"use strict";var createShader=__nested_webpack_require_452548__(5158);var createBuffer=__nested_webpack_require_452548__(5827);var pool=__nested_webpack_require_452548__(5306);var SHADERS=__nested_webpack_require_452548__(8023);module.exports=createPointcloud2D;function Pointcloud2D(plot,offsetBuffer,pickBuffer,shader,pickShader){this.plot=plot;this.offsetBuffer=offsetBuffer;this.pickBuffer=pickBuffer;this.shader=shader;this.pickShader=pickShader;this.sizeMin=0.5;this.sizeMinCap=2;this.sizeMax=20;this.areaRatio=1.0;this.pointCount=0;this.color=[1,0,0,1];this.borderColor=[0,0,0,1];this.blend=false;this.pickOffset=0;this.points=null;}var proto=Pointcloud2D.prototype;proto.dispose=function(){this.shader.dispose();this.pickShader.dispose();this.offsetBuffer.dispose();this.pickBuffer.dispose();this.plot.removeObject(this);};proto.update=function(options){var i;options=options||{};function dflt(opt,value){if(opt in options){return options[opt];}return value;}this.sizeMin=dflt('sizeMin',0.5);// this.sizeMinCap      = dflt('sizeMinCap', 2)
this.sizeMax=dflt('sizeMax',20);this.color=dflt('color',[1,0,0,1]).slice();this.areaRatio=dflt('areaRatio',1);this.borderColor=dflt('borderColor',[0,0,0,1]).slice();this.blend=dflt('blend',false);//Update point data
// Attempt straight-through processing (STP) to avoid allocation and copy
// TODO eventually abstract out STP logic, maybe into `pool` or a layer above
var pointCount=options.positions.length>>>1;var dataStraightThrough=options.positions instanceof Float32Array;var idStraightThrough=options.idToIndex instanceof Int32Array&&options.idToIndex.length>=pointCount;// permit larger to help reuse
var data=options.positions;var packed=dataStraightThrough?data:pool.mallocFloat32(data.length);var packedId=idStraightThrough?options.idToIndex:pool.mallocInt32(pointCount);if(!dataStraightThrough){packed.set(data);}if(!idStraightThrough){packed.set(data);for(i=0;i<pointCount;i++){packedId[i]=i;}}this.points=data;this.offsetBuffer.update(packed);this.pickBuffer.update(packedId);if(!dataStraightThrough){pool.free(packed);}if(!idStraightThrough){pool.free(packedId);}this.pointCount=pointCount;this.pickOffset=0;};function count(points,dataBox){var visiblePointCountEstimate=0;var length=points.length>>>1;var i;for(i=0;i<length;i++){var x=points[i*2];var y=points[i*2+1];if(x>=dataBox[0]&&x<=dataBox[2]&&y>=dataBox[1]&&y<=dataBox[3])visiblePointCountEstimate++;}return visiblePointCountEstimate;}proto.unifiedDraw=function(){var MATRIX=[1,0,0,0,1,0,0,0,1];var PICK_VEC4=[0,0,0,0];return function(pickOffset){var pick=pickOffset!==void 0;var shader=pick?this.pickShader:this.shader;var gl=this.plot.gl;var dataBox=this.plot.dataBox;if(this.pointCount===0){return pickOffset;}var dataX=dataBox[2]-dataBox[0];var dataY=dataBox[3]-dataBox[1];var visiblePointCountEstimate=count(this.points,dataBox);var basicPointSize=this.plot.pickPixelRatio*Math.max(Math.min(this.sizeMinCap,this.sizeMin),Math.min(this.sizeMax,this.sizeMax/Math.pow(visiblePointCountEstimate,0.33333)));MATRIX[0]=2.0/dataX;MATRIX[4]=2.0/dataY;MATRIX[6]=-2.0*dataBox[0]/dataX-1.0;MATRIX[7]=-2.0*dataBox[1]/dataY-1.0;this.offsetBuffer.bind();shader.bind();shader.attributes.position.pointer();shader.uniforms.matrix=MATRIX;shader.uniforms.color=this.color;shader.uniforms.borderColor=this.borderColor;shader.uniforms.pointCloud=basicPointSize<5;shader.uniforms.pointSize=basicPointSize;shader.uniforms.centerFraction=Math.min(1,Math.max(0,Math.sqrt(1-this.areaRatio)));if(pick){PICK_VEC4[0]=pickOffset&0xff;PICK_VEC4[1]=pickOffset>>8&0xff;PICK_VEC4[2]=pickOffset>>16&0xff;PICK_VEC4[3]=pickOffset>>24&0xff;this.pickBuffer.bind();shader.attributes.pickId.pointer(gl.UNSIGNED_BYTE);shader.uniforms.pickOffset=PICK_VEC4;this.pickOffset=pickOffset;}// Worth switching these off, but we can't make assumptions about other
// renderers, so let's restore it after each draw
var blend=gl.getParameter(gl.BLEND);var dither=gl.getParameter(gl.DITHER);if(blend&&!this.blend)gl.disable(gl.BLEND);if(dither)gl.disable(gl.DITHER);gl.drawArrays(gl.POINTS,0,this.pointCount);if(blend&&!this.blend)gl.enable(gl.BLEND);if(dither)gl.enable(gl.DITHER);return pickOffset+this.pointCount;};}();proto.draw=proto.unifiedDraw;proto.drawPick=proto.unifiedDraw;proto.pick=function(x,y,value){var pickOffset=this.pickOffset;var pointCount=this.pointCount;if(value<pickOffset||value>=pickOffset+pointCount){return null;}var pointId=value-pickOffset;var points=this.points;return{object:this,pointId:pointId,dataCoord:[points[2*pointId],points[2*pointId+1]]};};function createPointcloud2D(plot,options){var gl=plot.gl;var buffer=createBuffer(gl);var pickBuffer=createBuffer(gl);var shader=createShader(gl,SHADERS.pointVertex,SHADERS.pointFragment);var pickShader=createShader(gl,SHADERS.pickVertex,SHADERS.pickFragment);var result=new Pointcloud2D(plot,buffer,pickBuffer,shader,pickShader);result.update(options);//Register with plot
plot.addObject(result);return result;}/***/},/***/6093:/***/function(module){module.exports=slerp;/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */function slerp(out,a,b,t){// benchmarks:
//    http://jsperf.com/quaternion-slerp-implementations
var ax=a[0],ay=a[1],az=a[2],aw=a[3],bx=b[0],by=b[1],bz=b[2],bw=b[3];var omega,cosom,sinom,scale0,scale1;// calc cosine
cosom=ax*bx+ay*by+az*bz+aw*bw;// adjust signs (if necessary)
if(cosom<0.0){cosom=-cosom;bx=-bx;by=-by;bz=-bz;bw=-bw;}// calculate coefficients
if(1.0-cosom>0.000001){// standard case (slerp)
omega=Math.acos(cosom);sinom=Math.sin(omega);scale0=Math.sin((1.0-t)*omega)/sinom;scale1=Math.sin(t*omega)/sinom;}else{// "from" and "to" quaternions are very close
//  ... so we can do a linear interpolation
scale0=1.0-t;scale1=t;}// calculate final values
out[0]=scale0*ax+scale1*bx;out[1]=scale0*ay+scale1*by;out[2]=scale0*az+scale1*bz;out[3]=scale0*aw+scale1*bw;return out;}/***/},/***/8240:/***/function(module){"use strict";module.exports=function(a){return!a&&a!==0?'':a.toString();};/***/},/***/4123:/***/function(module,__unused_webpack_exports,__nested_webpack_require_458780__){"use strict";var vectorizeText=__nested_webpack_require_458780__(875);module.exports=getGlyph;var GLYPH_CACHE={};function getGlyph(symbol,font,pixelRatio){var fontCache=GLYPH_CACHE[font];if(!fontCache){fontCache=GLYPH_CACHE[font]={};}if(symbol in fontCache){return fontCache[symbol];}var config={textAlign:"center",textBaseline:"middle",lineHeight:1.0,font:font,lineSpacing:1.25,styletags:{breaklines:true,bolds:true,italics:true,subscripts:true,superscripts:true}};//Get line and triangle meshes for glyph
config.triangles=true;var triSymbol=vectorizeText(symbol,config);config.triangles=false;var lineSymbol=vectorizeText(symbol,config);var i,j;if(pixelRatio&&pixelRatio!==1){for(i=0;i<triSymbol.positions.length;++i){for(j=0;j<triSymbol.positions[i].length;++j){triSymbol.positions[i][j]/=pixelRatio;}}for(i=0;i<lineSymbol.positions.length;++i){for(j=0;j<lineSymbol.positions[i].length;++j){lineSymbol.positions[i][j]/=pixelRatio;}}}//Calculate bounding box
var bounds=[[Infinity,Infinity],[-Infinity,-Infinity]];var n=lineSymbol.positions.length;for(i=0;i<n;++i){var p=lineSymbol.positions[i];for(j=0;j<2;++j){bounds[0][j]=Math.min(bounds[0][j],p[j]);bounds[1][j]=Math.max(bounds[1][j],p[j]);}}//Save cached symbol
return fontCache[symbol]=[triSymbol,lineSymbol,bounds];}/***/},/***/9282:/***/function(__unused_webpack_module,exports,__nested_webpack_require_460125__){var createShaderWrapper=__nested_webpack_require_460125__(5158);var glslify=__nested_webpack_require_460125__(6832);var perspectiveVertSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nattribute vec3 position;\nattribute vec4 color;\nattribute vec2 glyph;\nattribute vec4 id;\n\nuniform vec4 highlightId;\nuniform float highlightScale;\nuniform mat4 model, view, projection;\nuniform vec3 clipBounds[2];\n\nvarying vec4 interpColor;\nvarying vec4 pickId;\nvarying vec3 dataCoordinate;\n\nvoid main() {\n  if (outOfRange(clipBounds[0], clipBounds[1], position)) {\n\n    gl_Position = vec4(0,0,0,0);\n  } else {\n    float scale = 1.0;\n    if(distance(highlightId, id) < 0.0001) {\n      scale = highlightScale;\n    }\n\n    vec4 worldPosition = model * vec4(position, 1);\n    vec4 viewPosition = view * worldPosition;\n    viewPosition = viewPosition / viewPosition.w;\n    vec4 clipPosition = projection * (viewPosition + scale * vec4(glyph.x, -glyph.y, 0, 0));\n\n    gl_Position = clipPosition;\n    interpColor = color;\n    pickId = id;\n    dataCoordinate = position;\n  }\n}"]);var orthographicVertSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nattribute vec3 position;\nattribute vec4 color;\nattribute vec2 glyph;\nattribute vec4 id;\n\nuniform mat4 model, view, projection;\nuniform vec2 screenSize;\nuniform vec3 clipBounds[2];\nuniform float highlightScale, pixelRatio;\nuniform vec4 highlightId;\n\nvarying vec4 interpColor;\nvarying vec4 pickId;\nvarying vec3 dataCoordinate;\n\nvoid main() {\n  if (outOfRange(clipBounds[0], clipBounds[1], position)) {\n\n    gl_Position = vec4(0,0,0,0);\n  } else {\n    float scale = pixelRatio;\n    if(distance(highlightId.bgr, id.bgr) < 0.001) {\n      scale *= highlightScale;\n    }\n\n    vec4 worldPosition = model * vec4(position, 1.0);\n    vec4 viewPosition = view * worldPosition;\n    vec4 clipPosition = projection * viewPosition;\n    clipPosition /= clipPosition.w;\n\n    gl_Position = clipPosition + vec4(screenSize * scale * vec2(glyph.x, -glyph.y), 0.0, 0.0);\n    interpColor = color;\n    pickId = id;\n    dataCoordinate = position;\n  }\n}"]);var projectionVertSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nattribute vec3 position;\nattribute vec4 color;\nattribute vec2 glyph;\nattribute vec4 id;\n\nuniform float highlightScale;\nuniform vec4 highlightId;\nuniform vec3 axes[2];\nuniform mat4 model, view, projection;\nuniform vec2 screenSize;\nuniform vec3 clipBounds[2];\nuniform float scale, pixelRatio;\n\nvarying vec4 interpColor;\nvarying vec4 pickId;\nvarying vec3 dataCoordinate;\n\nvoid main() {\n  if (outOfRange(clipBounds[0], clipBounds[1], position)) {\n\n    gl_Position = vec4(0,0,0,0);\n  } else {\n    float lscale = pixelRatio * scale;\n    if(distance(highlightId, id) < 0.0001) {\n      lscale *= highlightScale;\n    }\n\n    vec4 clipCenter   = projection * view * model * vec4(position, 1);\n    vec3 dataPosition = position + 0.5*lscale*(axes[0] * glyph.x + axes[1] * glyph.y) * clipCenter.w * screenSize.y;\n    vec4 clipPosition = projection * view * model * vec4(dataPosition, 1);\n\n    gl_Position = clipPosition;\n    interpColor = color;\n    pickId = id;\n    dataCoordinate = dataPosition;\n  }\n}\n"]);var drawFragSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nuniform vec3 fragClipBounds[2];\nuniform float opacity;\n\nvarying vec4 interpColor;\nvarying vec3 dataCoordinate;\n\nvoid main() {\n  if (\n    outOfRange(fragClipBounds[0], fragClipBounds[1], dataCoordinate) ||\n    interpColor.a * opacity == 0.\n  ) discard;\n  gl_FragColor = interpColor * opacity;\n}\n"]);var pickFragSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nuniform vec3 fragClipBounds[2];\nuniform float pickGroup;\n\nvarying vec4 pickId;\nvarying vec3 dataCoordinate;\n\nvoid main() {\n  if (outOfRange(fragClipBounds[0], fragClipBounds[1], dataCoordinate)) discard;\n\n  gl_FragColor = vec4(pickGroup, pickId.bgr);\n}"]);var ATTRIBUTES=[{name:'position',type:'vec3'},{name:'color',type:'vec4'},{name:'glyph',type:'vec2'},{name:'id',type:'vec4'}];var perspective={vertex:perspectiveVertSrc,fragment:drawFragSrc,attributes:ATTRIBUTES},ortho={vertex:orthographicVertSrc,fragment:drawFragSrc,attributes:ATTRIBUTES},project={vertex:projectionVertSrc,fragment:drawFragSrc,attributes:ATTRIBUTES},pickPerspective={vertex:perspectiveVertSrc,fragment:pickFragSrc,attributes:ATTRIBUTES},pickOrtho={vertex:orthographicVertSrc,fragment:pickFragSrc,attributes:ATTRIBUTES},pickProject={vertex:projectionVertSrc,fragment:pickFragSrc,attributes:ATTRIBUTES};function createShader(gl,src){var shader=createShaderWrapper(gl,src);var attr=shader.attributes;attr.position.location=0;attr.color.location=1;attr.glyph.location=2;attr.id.location=3;return shader;}exports.createPerspective=function(gl){return createShader(gl,perspective);};exports.createOrtho=function(gl){return createShader(gl,ortho);};exports.createProject=function(gl){return createShader(gl,project);};exports.createPickPerspective=function(gl){return createShader(gl,pickPerspective);};exports.createPickOrtho=function(gl){return createShader(gl,pickOrtho);};exports.createPickProject=function(gl){return createShader(gl,pickProject);};/***/},/***/2182:/***/function(module,__unused_webpack_exports,__nested_webpack_require_467893__){"use strict";var isAllBlank=__nested_webpack_require_467893__(3596);var createBuffer=__nested_webpack_require_467893__(5827);var createVAO=__nested_webpack_require_467893__(2944);var pool=__nested_webpack_require_467893__(5306);var mat4mult=__nested_webpack_require_467893__(104);var shaders=__nested_webpack_require_467893__(9282);var getGlyph=__nested_webpack_require_467893__(4123);var getSimpleString=__nested_webpack_require_467893__(8240);var IDENTITY=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];module.exports=createPointCloud;function transformMat4(x,m){var x0=x[0];var x1=x[1];var x2=x[2];var x3=x[3];x[0]=m[0]*x0+m[4]*x1+m[8]*x2+m[12]*x3;x[1]=m[1]*x0+m[5]*x1+m[9]*x2+m[13]*x3;x[2]=m[2]*x0+m[6]*x1+m[10]*x2+m[14]*x3;x[3]=m[3]*x0+m[7]*x1+m[11]*x2+m[15]*x3;return x;}function project(p,v,m,x){transformMat4(x,x,m);transformMat4(x,x,v);return transformMat4(x,x,p);}function ScatterPlotPickResult(index,position){this.index=index;this.dataCoordinate=this.position=position;}function fixOpacity(a){if(a===true)return 1;if(a>1)return 1;return a;}function PointCloud(gl,shader,orthoShader,projectShader,pointBuffer,colorBuffer,glyphBuffer,idBuffer,vao,pickPerspectiveShader,pickOrthoShader,pickProjectShader){this.gl=gl;this.pixelRatio=1;this.shader=shader;this.orthoShader=orthoShader;this.projectShader=projectShader;this.pointBuffer=pointBuffer;this.colorBuffer=colorBuffer;this.glyphBuffer=glyphBuffer;this.idBuffer=idBuffer;this.vao=vao;this.vertexCount=0;this.lineVertexCount=0;this.opacity=1;this.hasAlpha=false;this.lineWidth=0;this.projectScale=[2.0/3.0,2.0/3.0,2.0/3.0];this.projectOpacity=[1,1,1];this.projectHasAlpha=false;this.pickId=0;this.pickPerspectiveShader=pickPerspectiveShader;this.pickOrthoShader=pickOrthoShader;this.pickProjectShader=pickProjectShader;this.points=[];this._selectResult=new ScatterPlotPickResult(0,[0,0,0]);this.useOrtho=true;this.bounds=[[Infinity,Infinity,Infinity],[-Infinity,-Infinity,-Infinity]];//Axes projections
this.axesProject=[true,true,true];this.axesBounds=[[-Infinity,-Infinity,-Infinity],[Infinity,Infinity,Infinity]];this.highlightId=[1,1,1,1];this.highlightScale=2;this.clipBounds=[[-Infinity,-Infinity,-Infinity],[Infinity,Infinity,Infinity]];this.dirty=true;}var proto=PointCloud.prototype;proto.pickSlots=1;proto.setPickBase=function(pickBase){this.pickId=pickBase;};proto.isTransparent=function(){if(this.hasAlpha){return true;}for(var i=0;i<3;++i){if(this.axesProject[i]&&this.projectHasAlpha){return true;}}return false;};proto.isOpaque=function(){if(!this.hasAlpha){return true;}for(var i=0;i<3;++i){if(this.axesProject[i]&&!this.projectHasAlpha){return true;}}return false;};var VIEW_SHAPE=[0,0];var U_VEC=[0,0,0];var V_VEC=[0,0,0];var MU_VEC=[0,0,0,1];var MV_VEC=[0,0,0,1];var SCRATCH_MATRIX=IDENTITY.slice();var SCRATCH_VEC=[0,0,0];var CLIP_BOUNDS=[[0,0,0],[0,0,0]];function zeroVec(a){a[0]=a[1]=a[2]=0;return a;}function augment(hg,af){hg[0]=af[0];hg[1]=af[1];hg[2]=af[2];hg[3]=1;return hg;}function setComponent(out,v,i,x){out[0]=v[0];out[1]=v[1];out[2]=v[2];out[i]=x;return out;}function getClipBounds(bounds){var result=CLIP_BOUNDS;for(var i=0;i<2;++i){for(var j=0;j<3;++j){result[i][j]=Math.max(Math.min(bounds[i][j],1e8),-1e8);}}return result;}function drawProject(shader,points,camera,pixelRatio){var axesProject=points.axesProject;var gl=points.gl;var uniforms=shader.uniforms;var model=camera.model||IDENTITY;var view=camera.view||IDENTITY;var projection=camera.projection||IDENTITY;var bounds=points.axesBounds;var clipBounds=getClipBounds(points.clipBounds);var cubeAxis;if(points.axes&&points.axes.lastCubeProps){cubeAxis=points.axes.lastCubeProps.axis;}else{cubeAxis=[1,1,1];}VIEW_SHAPE[0]=2.0/gl.drawingBufferWidth;VIEW_SHAPE[1]=2.0/gl.drawingBufferHeight;shader.bind();uniforms.view=view;uniforms.projection=projection;uniforms.screenSize=VIEW_SHAPE;uniforms.highlightId=points.highlightId;uniforms.highlightScale=points.highlightScale;uniforms.clipBounds=clipBounds;uniforms.pickGroup=points.pickId/255.0;uniforms.pixelRatio=pixelRatio;for(var i=0;i<3;++i){if(!axesProject[i]){continue;}uniforms.scale=points.projectScale[i];uniforms.opacity=points.projectOpacity[i];//Project model matrix
var pmodel=SCRATCH_MATRIX;for(var j=0;j<16;++j){pmodel[j]=0;}for(var j=0;j<4;++j){pmodel[5*j]=1;}pmodel[5*i]=0;if(cubeAxis[i]<0){pmodel[12+i]=bounds[0][i];}else{pmodel[12+i]=bounds[1][i];}mat4mult(pmodel,model,pmodel);uniforms.model=pmodel;//Compute initial axes
var u=(i+1)%3;var v=(i+2)%3;var du=zeroVec(U_VEC);var dv=zeroVec(V_VEC);du[u]=1;dv[v]=1;//Align orientation relative to viewer
var mdu=project(projection,view,model,augment(MU_VEC,du));var mdv=project(projection,view,model,augment(MV_VEC,dv));if(Math.abs(mdu[1])>Math.abs(mdv[1])){var tmp=mdu;mdu=mdv;mdv=tmp;tmp=du;du=dv;dv=tmp;var t=u;u=v;v=t;}if(mdu[0]<0){du[u]=-1;}if(mdv[1]>0){dv[v]=-1;}var su=0.0;var sv=0.0;for(var j=0;j<4;++j){su+=Math.pow(model[4*u+j],2);sv+=Math.pow(model[4*v+j],2);}du[u]/=Math.sqrt(su);dv[v]/=Math.sqrt(sv);uniforms.axes[0]=du;uniforms.axes[1]=dv;//Update fragment clip bounds
uniforms.fragClipBounds[0]=setComponent(SCRATCH_VEC,clipBounds[0],i,-1e8);uniforms.fragClipBounds[1]=setComponent(SCRATCH_VEC,clipBounds[1],i,1e8);points.vao.bind();//Draw interior
points.vao.draw(gl.TRIANGLES,points.vertexCount);//Draw edges
if(points.lineWidth>0){gl.lineWidth(points.lineWidth*pixelRatio);points.vao.draw(gl.LINES,points.lineVertexCount,points.vertexCount);}points.vao.unbind();}}var NEG_INFINITY3=[-1e8,-1e8,-1e8];var POS_INFINITY3=[1e8,1e8,1e8];var CLIP_GROUP=[NEG_INFINITY3,POS_INFINITY3];function drawFull(shader,pshader,points,camera,pixelRatio,transparent,forceDraw){var gl=points.gl;if(transparent===points.projectHasAlpha||forceDraw){drawProject(pshader,points,camera,pixelRatio);}if(transparent===points.hasAlpha||forceDraw){shader.bind();var uniforms=shader.uniforms;uniforms.model=camera.model||IDENTITY;uniforms.view=camera.view||IDENTITY;uniforms.projection=camera.projection||IDENTITY;VIEW_SHAPE[0]=2.0/gl.drawingBufferWidth;VIEW_SHAPE[1]=2.0/gl.drawingBufferHeight;uniforms.screenSize=VIEW_SHAPE;uniforms.highlightId=points.highlightId;uniforms.highlightScale=points.highlightScale;uniforms.fragClipBounds=CLIP_GROUP;uniforms.clipBounds=points.axes.bounds;uniforms.opacity=points.opacity;uniforms.pickGroup=points.pickId/255.0;uniforms.pixelRatio=pixelRatio;points.vao.bind();//Draw interior
points.vao.draw(gl.TRIANGLES,points.vertexCount);//Draw edges
if(points.lineWidth>0){gl.lineWidth(points.lineWidth*pixelRatio);points.vao.draw(gl.LINES,points.lineVertexCount,points.vertexCount);}points.vao.unbind();}}proto.draw=function(camera){var shader=this.useOrtho?this.orthoShader:this.shader;drawFull(shader,this.projectShader,this,camera,this.pixelRatio,false,false);};proto.drawTransparent=function(camera){var shader=this.useOrtho?this.orthoShader:this.shader;drawFull(shader,this.projectShader,this,camera,this.pixelRatio,true,false);};proto.drawPick=function(camera){var shader=this.useOrtho?this.pickOrthoShader:this.pickPerspectiveShader;drawFull(shader,this.pickProjectShader,this,camera,1,true,true);};proto.pick=function(selected){if(!selected){return null;}if(selected.id!==this.pickId){return null;}var x=selected.value[2]+(selected.value[1]<<8)+(selected.value[0]<<16);if(x>=this.pointCount||x<0){return null;}//Unpack result
var coord=this.points[x];var result=this._selectResult;result.index=x;for(var i=0;i<3;++i){result.position[i]=result.dataCoordinate[i]=coord[i];}return result;};proto.highlight=function(selection){if(!selection){this.highlightId=[1,1,1,1];}else{var pointId=selection.index;var a0=pointId&0xff;var a1=pointId>>8&0xff;var a2=pointId>>16&0xff;this.highlightId=[a0/255.0,a1/255.0,a2/255.0,0];}};function get_glyphData(glyphs,index,font,pixelRatio){var str;// use the data if presented in an array
if(Array.isArray(glyphs)){if(index<glyphs.length){str=glyphs[index];}else{str=undefined;}}else{str=glyphs;}str=getSimpleString(str);// this would handle undefined cases
var visible=true;if(isAllBlank(str)){str='▼';// Note: this special character may have minimum number of surfaces
visible=false;}var glyph=getGlyph(str,font,pixelRatio);return{mesh:glyph[0],lines:glyph[1],bounds:glyph[2],visible:visible};}proto.update=function(options){options=options||{};if('perspective'in options){this.useOrtho=!options.perspective;}if('orthographic'in options){this.useOrtho=!!options.orthographic;}if('lineWidth'in options){this.lineWidth=options.lineWidth;}if('project'in options){if(Array.isArray(options.project)){this.axesProject=options.project;}else{var v=!!options.project;this.axesProject=[v,v,v];}}if('projectScale'in options){if(Array.isArray(options.projectScale)){this.projectScale=options.projectScale.slice();}else{var s=+options.projectScale;this.projectScale=[s,s,s];}}this.projectHasAlpha=false;// default to no transparent draw
if('projectOpacity'in options){if(Array.isArray(options.projectOpacity)){this.projectOpacity=options.projectOpacity.slice();}else{var s=+options.projectOpacity;this.projectOpacity=[s,s,s];}for(var i=0;i<3;++i){this.projectOpacity[i]=fixOpacity(this.projectOpacity[i]);if(this.projectOpacity[i]<1){this.projectHasAlpha=true;}}}this.hasAlpha=false;// default to no transparent draw
if('opacity'in options){this.opacity=fixOpacity(options.opacity);if(this.opacity<1){this.hasAlpha=true;}}//Set dirty flag
this.dirty=true;//Create new buffers
var points=options.position;//Text font
var font=options.font||'normal';var alignment=options.alignment||[0,0];var alignmentX;var alignmentY;if(alignment.length===2){alignmentX=alignment[0];alignmentY=alignment[1];}else{alignmentX=[];alignmentY=[];for(var i=0;i<alignment.length;++i){alignmentX[i]=alignment[i][0];alignmentY[i]=alignment[i][1];}}//Bounds
var lowerBound=[Infinity,Infinity,Infinity];var upperBound=[-Infinity,-Infinity,-Infinity];//Unpack options
var glyphs=options.glyph;var colors=options.color;var sizes=options.size;var angles=options.angle;var lineColors=options.lineColor;//Picking geometry
var pickCounter=-1;//First do pass to compute buffer sizes
var triVertexCount=0;var lineVertexCount=0;var numPoints=0;if(points.length){//Count number of points and buffer size
numPoints=points.length;count_loop:for(var i=0;i<numPoints;++i){var x=points[i];for(var j=0;j<3;++j){if(isNaN(x[j])||!isFinite(x[j])){continue count_loop;}}var glyphData=get_glyphData(glyphs,i,font,this.pixelRatio);var glyphMesh=glyphData.mesh;var glyphLines=glyphData.lines;var glyphBounds=glyphData.bounds;triVertexCount+=glyphMesh.cells.length*3;lineVertexCount+=glyphLines.edges.length*2;}}var vertexCount=triVertexCount+lineVertexCount;//Preallocate data
var positionArray=pool.mallocFloat(3*vertexCount);var colorArray=pool.mallocFloat(4*vertexCount);var glyphArray=pool.mallocFloat(2*vertexCount);var idArray=pool.mallocUint32(vertexCount);if(vertexCount>0){var triOffset=0;var lineOffset=triVertexCount;var color=[0,0,0,1];var lineColor=[0,0,0,1];var isColorArray=Array.isArray(colors)&&Array.isArray(colors[0]);var isLineColorArray=Array.isArray(lineColors)&&Array.isArray(lineColors[0]);fill_loop:for(var i=0;i<numPoints;++i){//Increment pickCounter
pickCounter+=1;var x=points[i];for(var j=0;j<3;++j){if(isNaN(x[j])||!isFinite(x[j])){continue fill_loop;}upperBound[j]=Math.max(upperBound[j],x[j]);lowerBound[j]=Math.min(lowerBound[j],x[j]);}var glyphData=get_glyphData(glyphs,i,font,this.pixelRatio);var glyphMesh=glyphData.mesh;var glyphLines=glyphData.lines;var glyphBounds=glyphData.bounds;var glyphVisible=glyphData.visible;//Get color
if(!glyphVisible)color=[1,1,1,0];else if(Array.isArray(colors)){var c;if(isColorArray){if(i<colors.length){c=colors[i];}else{c=[0,0,0,0];}}else{c=colors;}if(c.length===3){for(var j=0;j<3;++j){color[j]=c[j];}color[3]=1;}else if(c.length===4){for(var j=0;j<4;++j){color[j]=c[j];}if(!this.hasAlpha&&c[3]<1)this.hasAlpha=true;}}else{color[0]=color[1]=color[2]=0;color[3]=1;}//Get lineColor
if(!glyphVisible)lineColor=[1,1,1,0];else if(Array.isArray(lineColors)){var c;if(isLineColorArray){if(i<lineColors.length){c=lineColors[i];}else{c=[0,0,0,0];}}else{c=lineColors;}if(c.length===3){for(var j=0;j<3;++j){lineColor[j]=c[j];}lineColor[j]=1;}else if(c.length===4){for(var j=0;j<4;++j){lineColor[j]=c[j];}if(!this.hasAlpha&&c[3]<1)this.hasAlpha=true;}}else{lineColor[0]=lineColor[1]=lineColor[2]=0;lineColor[3]=1;}var size=0.5;if(!glyphVisible)size=0.0;else if(Array.isArray(sizes)){if(i<sizes.length){size=+sizes[i];}else{size=12;}}else if(sizes){size=+sizes;}else if(this.useOrtho){size=12;}var angle=0;if(Array.isArray(angles)){if(i<angles.length){angle=+angles[i];}else{angle=0;}}else if(angles){angle=+angles;}//Loop through markers and append to buffers
var cos=Math.cos(angle);var sin=Math.sin(angle);var x=points[i];for(var j=0;j<3;++j){upperBound[j]=Math.max(upperBound[j],x[j]);lowerBound[j]=Math.min(lowerBound[j],x[j]);}//Calculate text offset
var textOffsetX=alignmentX;var textOffsetY=alignmentY;var textOffsetX=0;if(Array.isArray(alignmentX)){if(i<alignmentX.length){textOffsetX=alignmentX[i];}else{textOffsetX=0;}}else if(alignmentX){textOffsetX=alignmentX;}var textOffsetY=0;if(Array.isArray(alignmentY)){if(i<alignmentY.length){textOffsetY=alignmentY[i];}else{textOffsetY=0;}}else if(alignmentY){textOffsetY=alignmentY;}textOffsetX*=textOffsetX>0?1-glyphBounds[0][0]:textOffsetX<0?1+glyphBounds[1][0]:1;textOffsetY*=textOffsetY>0?1-glyphBounds[0][1]:textOffsetY<0?1+glyphBounds[1][1]:1;var textOffset=[textOffsetX,textOffsetY];//Write out inner marker
var cells=glyphMesh.cells||[];var verts=glyphMesh.positions||[];for(var j=0;j<cells.length;++j){var cell=cells[j];for(var k=0;k<3;++k){for(var l=0;l<3;++l){positionArray[3*triOffset+l]=x[l];}for(var l=0;l<4;++l){colorArray[4*triOffset+l]=color[l];}idArray[triOffset]=pickCounter;var p=verts[cell[k]];glyphArray[2*triOffset]=size*(cos*p[0]-sin*p[1]+textOffset[0]);glyphArray[2*triOffset+1]=size*(sin*p[0]+cos*p[1]+textOffset[1]);triOffset+=1;}}var cells=glyphLines.edges;var verts=glyphLines.positions;for(var j=0;j<cells.length;++j){var cell=cells[j];for(var k=0;k<2;++k){for(var l=0;l<3;++l){positionArray[3*lineOffset+l]=x[l];}for(var l=0;l<4;++l){colorArray[4*lineOffset+l]=lineColor[l];}idArray[lineOffset]=pickCounter;var p=verts[cell[k]];glyphArray[2*lineOffset]=size*(cos*p[0]-sin*p[1]+textOffset[0]);glyphArray[2*lineOffset+1]=size*(sin*p[0]+cos*p[1]+textOffset[1]);lineOffset+=1;}}}}//Update bounds
this.bounds=[lowerBound,upperBound];//Save points
this.points=points;//Save number of points
this.pointCount=points.length;//Update vertex counts
this.vertexCount=triVertexCount;this.lineVertexCount=lineVertexCount;this.pointBuffer.update(positionArray);this.colorBuffer.update(colorArray);this.glyphBuffer.update(glyphArray);//this.idBuffer.update(new Uint32Array(idArray))
this.idBuffer.update(idArray);pool.free(positionArray);pool.free(colorArray);pool.free(glyphArray);pool.free(idArray);};proto.dispose=function(){//Shaders
this.shader.dispose();this.orthoShader.dispose();this.pickPerspectiveShader.dispose();this.pickOrthoShader.dispose();//Vertex array
this.vao.dispose();//Buffers
this.pointBuffer.dispose();this.colorBuffer.dispose();this.glyphBuffer.dispose();this.idBuffer.dispose();};function createPointCloud(options){var gl=options.gl;var shader=shaders.createPerspective(gl);var orthoShader=shaders.createOrtho(gl);var projectShader=shaders.createProject(gl);var pickPerspectiveShader=shaders.createPickPerspective(gl);var pickOrthoShader=shaders.createPickOrtho(gl);var pickProjectShader=shaders.createPickProject(gl);var pointBuffer=createBuffer(gl);var colorBuffer=createBuffer(gl);var glyphBuffer=createBuffer(gl);var idBuffer=createBuffer(gl);var vao=createVAO(gl,[{buffer:pointBuffer,size:3,type:gl.FLOAT},{buffer:colorBuffer,size:4,type:gl.FLOAT},{buffer:glyphBuffer,size:2,type:gl.FLOAT},{buffer:idBuffer,size:4,type:gl.UNSIGNED_BYTE,normalized:true}]);var pointCloud=new PointCloud(gl,shader,orthoShader,projectShader,pointBuffer,colorBuffer,glyphBuffer,idBuffer,vao,pickPerspectiveShader,pickOrthoShader,pickProjectShader);pointCloud.update(options);return pointCloud;}/***/},/***/1884:/***/function(__unused_webpack_module,exports,__nested_webpack_require_483950__){"use strict";var glslify=__nested_webpack_require_483950__(6832);exports.boxVertex=glslify(["precision mediump float;\n#define GLSLIFY 1\n\nattribute vec2 vertex;\n\nuniform vec2 cornerA, cornerB;\n\nvoid main() {\n  gl_Position = vec4(mix(cornerA, cornerB, vertex), 0, 1);\n}\n"]);exports.boxFragment=glslify(["precision mediump float;\n#define GLSLIFY 1\n\nuniform vec4 color;\n\nvoid main() {\n  gl_FragColor = color;\n}\n"]);/***/},/***/6623:/***/function(module,__unused_webpack_exports,__nested_webpack_require_484449__){"use strict";var createShader=__nested_webpack_require_484449__(5158);var createBuffer=__nested_webpack_require_484449__(5827);var SHADERS=__nested_webpack_require_484449__(1884);module.exports=createSelectBox;function SelectBox(plot,boxBuffer,boxShader){this.plot=plot;this.boxBuffer=boxBuffer;this.boxShader=boxShader;this.enabled=true;this.selectBox=[Infinity,Infinity,-Infinity,-Infinity];this.borderColor=[0,0,0,1];this.innerFill=false;this.innerColor=[0,0,0,0.25];this.outerFill=true;this.outerColor=[0,0,0,0.5];this.borderWidth=10;}var proto=SelectBox.prototype;proto.draw=function(){if(!this.enabled){return;}var plot=this.plot;var selectBox=this.selectBox;var lineWidth=this.borderWidth;var innerFill=this.innerFill;var innerColor=this.innerColor;var outerFill=this.outerFill;var outerColor=this.outerColor;var borderColor=this.borderColor;var boxes=plot.box;var screenBox=plot.screenBox;var dataBox=plot.dataBox;var viewBox=plot.viewBox;var pixelRatio=plot.pixelRatio;//Map select box into pixel coordinates
var loX=(selectBox[0]-dataBox[0])*(viewBox[2]-viewBox[0])/(dataBox[2]-dataBox[0])+viewBox[0];var loY=(selectBox[1]-dataBox[1])*(viewBox[3]-viewBox[1])/(dataBox[3]-dataBox[1])+viewBox[1];var hiX=(selectBox[2]-dataBox[0])*(viewBox[2]-viewBox[0])/(dataBox[2]-dataBox[0])+viewBox[0];var hiY=(selectBox[3]-dataBox[1])*(viewBox[3]-viewBox[1])/(dataBox[3]-dataBox[1])+viewBox[1];loX=Math.max(loX,viewBox[0]);loY=Math.max(loY,viewBox[1]);hiX=Math.min(hiX,viewBox[2]);hiY=Math.min(hiY,viewBox[3]);if(hiX<loX||hiY<loY){return;}boxes.bind();//Draw box
var screenWidth=screenBox[2]-screenBox[0];var screenHeight=screenBox[3]-screenBox[1];if(this.outerFill){boxes.drawBox(0,0,screenWidth,loY,outerColor);boxes.drawBox(0,loY,loX,hiY,outerColor);boxes.drawBox(0,hiY,screenWidth,screenHeight,outerColor);boxes.drawBox(hiX,loY,screenWidth,hiY,outerColor);}if(this.innerFill){boxes.drawBox(loX,loY,hiX,hiY,innerColor);}//Draw border
if(lineWidth>0){//Draw border
var w=lineWidth*pixelRatio;boxes.drawBox(loX-w,loY-w,hiX+w,loY+w,borderColor);boxes.drawBox(loX-w,hiY-w,hiX+w,hiY+w,borderColor);boxes.drawBox(loX-w,loY-w,loX+w,hiY+w,borderColor);boxes.drawBox(hiX-w,loY-w,hiX+w,hiY+w,borderColor);}};proto.update=function(options){options=options||{};this.innerFill=!!options.innerFill;this.outerFill=!!options.outerFill;this.innerColor=(options.innerColor||[0,0,0,0.5]).slice();this.outerColor=(options.outerColor||[0,0,0,0.5]).slice();this.borderColor=(options.borderColor||[0,0,0,1]).slice();this.borderWidth=options.borderWidth||0;this.selectBox=(options.selectBox||this.selectBox).slice();};proto.dispose=function(){this.boxBuffer.dispose();this.boxShader.dispose();this.plot.removeOverlay(this);};function createSelectBox(plot,options){var gl=plot.gl;var buffer=createBuffer(gl,[0,0,0,1,1,0,1,1]);var shader=createShader(gl,SHADERS.boxVertex,SHADERS.boxFragment);var selectBox=new SelectBox(plot,buffer,shader);selectBox.update(options);plot.addOverlay(selectBox);return selectBox;}/***/},/***/2611:/***/function(module,__unused_webpack_exports,__nested_webpack_require_487476__){"use strict";module.exports=createSelectBuffer;var createFBO=__nested_webpack_require_487476__(4234);var pool=__nested_webpack_require_487476__(5306);var ndarray=__nested_webpack_require_487476__(5050);var nextPow2=__nested_webpack_require_487476__(2288).nextPow2;var selectRange=function(arr,x,y){var closestD2=1e8;var closestX=-1;var closestY=-1;var ni=arr.shape[0];var nj=arr.shape[1];for(var i=0;i<ni;i++){for(var j=0;j<nj;j++){var r=arr.get(i,j,0);var g=arr.get(i,j,1);var b=arr.get(i,j,2);var a=arr.get(i,j,3);if(r<255||g<255||b<255||a<255){var dx=x-i;var dy=y-j;var d2=dx*dx+dy*dy;if(d2<closestD2){closestD2=d2;closestX=i;closestY=j;}}}}return[closestX,closestY,closestD2];};function SelectResult(x,y,id,value,distance){this.coord=[x,y];this.id=id;this.value=value;this.distance=distance;}function SelectBuffer(gl,fbo,buffer){this.gl=gl;this.fbo=fbo;this.buffer=buffer;this._readTimeout=null;var self=this;this._readCallback=function(){if(!self.gl){return;}fbo.bind();gl.readPixels(0,0,fbo.shape[0],fbo.shape[1],gl.RGBA,gl.UNSIGNED_BYTE,self.buffer);self._readTimeout=null;};}var proto=SelectBuffer.prototype;Object.defineProperty(proto,'shape',{get:function(){if(!this.gl){return[0,0];}return this.fbo.shape.slice();},set:function(v){if(!this.gl){return;}this.fbo.shape=v;var c=this.fbo.shape[0];var r=this.fbo.shape[1];if(r*c*4>this.buffer.length){pool.free(this.buffer);var buffer=this.buffer=pool.mallocUint8(nextPow2(r*c*4));for(var i=0;i<r*c*4;++i){buffer[i]=0xff;}}return v;}});proto.begin=function(){var gl=this.gl;var shape=this.shape;if(!gl){return;}this.fbo.bind();gl.clearColor(1,1,1,1);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);};proto.end=function(){var gl=this.gl;if(!gl){return;}gl.bindFramebuffer(gl.FRAMEBUFFER,null);if(!this._readTimeout){clearTimeout(this._readTimeout);}this._readTimeout=setTimeout(this._readCallback,1);};proto.query=function(x,y,radius){if(!this.gl){return null;}var shape=this.fbo.shape.slice();x=x|0;y=y|0;if(typeof radius!=='number'){radius=1.0;}var x0=Math.min(Math.max(x-radius,0),shape[0])|0;var x1=Math.min(Math.max(x+radius,0),shape[0])|0;var y0=Math.min(Math.max(y-radius,0),shape[1])|0;var y1=Math.min(Math.max(y+radius,0),shape[1])|0;if(x1<=x0||y1<=y0){return null;}var dims=[x1-x0,y1-y0];var region=ndarray(this.buffer,[dims[0],dims[1],4],[4,shape[0]*4,1],4*(x0+shape[0]*y0));var closest=selectRange(region.hi(dims[0],dims[1],1),radius,radius);var dx=closest[0];var dy=closest[1];if(dx<0||Math.pow(this.radius,2)<closest[2]){return null;}var c0=region.get(dx,dy,0);var c1=region.get(dx,dy,1);var c2=region.get(dx,dy,2);var c3=region.get(dx,dy,3);return new SelectResult(dx+x0|0,dy+y0|0,c0,[c1,c2,c3],Math.sqrt(closest[2]));};proto.dispose=function(){if(!this.gl){return;}this.fbo.dispose();pool.free(this.buffer);this.gl=null;if(this._readTimeout){clearTimeout(this._readTimeout);}};function createSelectBuffer(gl,shape){var width=shape[0];var height=shape[1];var options={};var fbo=createFBO(gl,width,height,options);var buffer=pool.mallocUint8(width*height*4);return new SelectBuffer(gl,fbo,buffer);}/***/},/***/5158:/***/function(module,__unused_webpack_exports,__nested_webpack_require_490573__){"use strict";var createUniformWrapper=__nested_webpack_require_490573__(9016);var createAttributeWrapper=__nested_webpack_require_490573__(4280);var makeReflect=__nested_webpack_require_490573__(3984);var shaderCache=__nested_webpack_require_490573__(1628);var runtime=__nested_webpack_require_490573__(2631);var GLError=__nested_webpack_require_490573__(9068);//Shader object
function Shader(gl){this.gl=gl;this.gl.lastAttribCount=0;// fixme where else should we store info, safe but not nice on the gl object
//Default initialize these to null
this._vref=this._fref=this._relink=this.vertShader=this.fragShader=this.program=this.attributes=this.uniforms=this.types=null;}var proto=Shader.prototype;proto.bind=function(){if(!this.program){this._relink();}// ensuring that we have the right number of enabled vertex attributes
var i;var newAttribCount=this.gl.getProgramParameter(this.program,this.gl.ACTIVE_ATTRIBUTES);// more robust approach
//var newAttribCount = Object.keys(this.attributes).length // avoids the probably immaterial introspection slowdown
var oldAttribCount=this.gl.lastAttribCount;if(newAttribCount>oldAttribCount){for(i=oldAttribCount;i<newAttribCount;i++){this.gl.enableVertexAttribArray(i);}}else if(oldAttribCount>newAttribCount){for(i=newAttribCount;i<oldAttribCount;i++){this.gl.disableVertexAttribArray(i);}}this.gl.lastAttribCount=newAttribCount;this.gl.useProgram(this.program);};proto.dispose=function(){// disabling vertex attributes so new shader starts with zero
// and it's also useful if all shaders are disposed but the
// gl context is reused for subsequent replotting
var oldAttribCount=this.gl.lastAttribCount;for(var i=0;i<oldAttribCount;i++){this.gl.disableVertexAttribArray(i);}this.gl.lastAttribCount=0;if(this._fref){this._fref.dispose();}if(this._vref){this._vref.dispose();}this.attributes=this.types=this.vertShader=this.fragShader=this.program=this._relink=this._fref=this._vref=null;};function compareAttributes(a,b){if(a.name<b.name){return-1;}return 1;}//Update export hook for glslify-live
proto.update=function(vertSource,fragSource,uniforms,attributes){//If only one object passed, assume glslify style output
if(!fragSource||arguments.length===1){var obj=vertSource;vertSource=obj.vertex;fragSource=obj.fragment;uniforms=obj.uniforms;attributes=obj.attributes;}var wrapper=this;var gl=wrapper.gl;//Compile vertex and fragment shaders
var pvref=wrapper._vref;wrapper._vref=shaderCache.shader(gl,gl.VERTEX_SHADER,vertSource);if(pvref){pvref.dispose();}wrapper.vertShader=wrapper._vref.shader;var pfref=this._fref;wrapper._fref=shaderCache.shader(gl,gl.FRAGMENT_SHADER,fragSource);if(pfref){pfref.dispose();}wrapper.fragShader=wrapper._fref.shader;//If uniforms/attributes is not specified, use RT reflection
if(!uniforms||!attributes){//Create initial test program
var testProgram=gl.createProgram();gl.attachShader(testProgram,wrapper.fragShader);gl.attachShader(testProgram,wrapper.vertShader);gl.linkProgram(testProgram);if(!gl.getProgramParameter(testProgram,gl.LINK_STATUS)){var errLog=gl.getProgramInfoLog(testProgram);throw new GLError(errLog,'Error linking program:'+errLog);}//Load data from runtime
uniforms=uniforms||runtime.uniforms(gl,testProgram);attributes=attributes||runtime.attributes(gl,testProgram);//Release test program
gl.deleteProgram(testProgram);}//Sort attributes lexicographically
// overrides undefined WebGL behavior for attribute locations
attributes=attributes.slice();attributes.sort(compareAttributes);//Convert attribute types, read out locations
var attributeUnpacked=[];var attributeNames=[];var attributeLocations=[];var i;for(i=0;i<attributes.length;++i){var attr=attributes[i];if(attr.type.indexOf('mat')>=0){var size=attr.type.charAt(attr.type.length-1)|0;var locVector=new Array(size);for(var j=0;j<size;++j){locVector[j]=attributeLocations.length;attributeNames.push(attr.name+'['+j+']');if(typeof attr.location==='number'){attributeLocations.push(attr.location+j);}else if(Array.isArray(attr.location)&&attr.location.length===size&&typeof attr.location[j]==='number'){attributeLocations.push(attr.location[j]|0);}else{attributeLocations.push(-1);}}attributeUnpacked.push({name:attr.name,type:attr.type,locations:locVector});}else{attributeUnpacked.push({name:attr.name,type:attr.type,locations:[attributeLocations.length]});attributeNames.push(attr.name);if(typeof attr.location==='number'){attributeLocations.push(attr.location|0);}else{attributeLocations.push(-1);}}}//For all unspecified attributes, assign them lexicographically min attribute
var curLocation=0;for(i=0;i<attributeLocations.length;++i){if(attributeLocations[i]<0){while(attributeLocations.indexOf(curLocation)>=0){curLocation+=1;}attributeLocations[i]=curLocation;}}//Rebuild program and recompute all uniform locations
var uniformLocations=new Array(uniforms.length);function relink(){wrapper.program=shaderCache.program(gl,wrapper._vref,wrapper._fref,attributeNames,attributeLocations);for(var i=0;i<uniforms.length;++i){uniformLocations[i]=gl.getUniformLocation(wrapper.program,uniforms[i].name);}}//Perform initial linking, reuse program used for reflection
relink();//Save relinking procedure, defer until runtime
wrapper._relink=relink;//Generate type info
wrapper.types={uniforms:makeReflect(uniforms),attributes:makeReflect(attributes)};//Generate attribute wrappers
wrapper.attributes=createAttributeWrapper(gl,wrapper,attributeUnpacked,attributeLocations);//Generate uniform wrappers
Object.defineProperty(wrapper,'uniforms',createUniformWrapper(gl,wrapper,uniforms,uniformLocations));};//Compiles and links a shader program with the given attribute and vertex list
function createShader(gl,vertSource,fragSource,uniforms,attributes){var shader=new Shader(gl);shader.update(vertSource,fragSource,uniforms,attributes);return shader;}module.exports=createShader;/***/},/***/9068:/***/function(module){function GLError(rawError,shortMessage,longMessage){this.shortMessage=shortMessage||'';this.longMessage=longMessage||'';this.rawError=rawError||'';this.message='gl-shader: '+(shortMessage||rawError||'')+(longMessage?'\n'+longMessage:'');this.stack=new Error().stack;}GLError.prototype=new Error();GLError.prototype.name='GLError';GLError.prototype.constructor=GLError;module.exports=GLError;/***/},/***/4280:/***/function(module,__unused_webpack_exports,__nested_webpack_require_496842__){"use strict";module.exports=createAttributeWrapper;var GLError=__nested_webpack_require_496842__(9068);function ShaderAttribute(gl,wrapper,index,locations,dimension,constFunc){this._gl=gl;this._wrapper=wrapper;this._index=index;this._locations=locations;this._dimension=dimension;this._constFunc=constFunc;}var proto=ShaderAttribute.prototype;proto.pointer=function setAttribPointer(type,normalized,stride,offset){var self=this;var gl=self._gl;var location=self._locations[self._index];gl.vertexAttribPointer(location,self._dimension,type||gl.FLOAT,!!normalized,stride||0,offset||0);gl.enableVertexAttribArray(location);};proto.set=function(x0,x1,x2,x3){return this._constFunc(this._locations[this._index],x0,x1,x2,x3);};Object.defineProperty(proto,'location',{get:function(){return this._locations[this._index];},set:function(v){if(v!==this._locations[this._index]){this._locations[this._index]=v|0;this._wrapper.program=null;}return v|0;}});var allFns=[function(gl,v,x0){if(x0.length===undefined){return gl.vertexAttrib1f(v,x0);}else{return gl.vertexAttrib1fv(v,x0);}},function(gl,v,x0,x1){if(x0.length===undefined){return gl.vertexAttrib2f(v,x0,x1);}else{return gl.vertexAttrib2fv(v,x0);}},function(gl,v,x0,x1,x2){if(x0.length===undefined){return gl.vertexAttrib3f(v,x0,x1,x2);}else{return gl.vertexAttrib3fv(v,x0);}},function(gl,v,x0,x1,x2,x3){if(x0.length===undefined){return gl.vertexAttrib4f(v,x0,x1,x2,x3);}else{return gl.vertexAttrib4fv(v,x0);}}];//Adds a vector attribute to obj
function addVectorAttribute(gl,wrapper,index,locations,dimension,obj,name){var constFunc=allFns[dimension];//Create attribute wrapper
var attr=new ShaderAttribute(gl,wrapper,index,locations,dimension,constFunc);//Create accessor
Object.defineProperty(obj,name,{set:function(x){gl.disableVertexAttribArray(locations[index]);constFunc(gl,locations[index],x);return x;},get:function(){return attr;},enumerable:true});}function addMatrixAttribute(gl,wrapper,index,locations,dimension,obj,name){var parts=new Array(dimension);var attrs=new Array(dimension);for(var i=0;i<dimension;++i){addVectorAttribute(gl,wrapper,index[i],locations,dimension,parts,i);attrs[i]=parts[i];}Object.defineProperty(parts,'location',{set:function(v){if(Array.isArray(v)){for(var i=0;i<dimension;++i){attrs[i].location=v[i];}}else{for(var i=0;i<dimension;++i){attrs[i].location=v+i;}}return v;},get:function(){var result=new Array(dimension);for(var i=0;i<dimension;++i){result[i]=locations[index[i]];}return result;},enumerable:true});parts.pointer=function(type,normalized,stride,offset){type=type||gl.FLOAT;normalized=!!normalized;stride=stride||dimension*dimension;offset=offset||0;for(var i=0;i<dimension;++i){var location=locations[index[i]];gl.vertexAttribPointer(location,dimension,type,normalized,stride,offset+i*dimension);gl.enableVertexAttribArray(location);}};var scratch=new Array(dimension);var vertexAttrib=gl['vertexAttrib'+dimension+'fv'];Object.defineProperty(obj,name,{set:function(x){for(var i=0;i<dimension;++i){var loc=locations[index[i]];gl.disableVertexAttribArray(loc);if(Array.isArray(x[0])){vertexAttrib.call(gl,loc,x[i]);}else{for(var j=0;j<dimension;++j){scratch[j]=x[dimension*i+j];}vertexAttrib.call(gl,loc,scratch);}}return x;},get:function(){return parts;},enumerable:true});}//Create shims for attributes
function createAttributeWrapper(gl,wrapper,attributes,locations){var obj={};for(var i=0,n=attributes.length;i<n;++i){var a=attributes[i];var name=a.name;var type=a.type;var locs=a.locations;switch(type){case'bool':case'int':case'float':addVectorAttribute(gl,wrapper,locs[0],locations,1,obj,name);break;default:if(type.indexOf('vec')>=0){var d=type.charCodeAt(type.length-1)-48;if(d<2||d>4){throw new GLError('','Invalid data type for attribute '+name+': '+type);}addVectorAttribute(gl,wrapper,locs[0],locations,d,obj,name);}else if(type.indexOf('mat')>=0){var d=type.charCodeAt(type.length-1)-48;if(d<2||d>4){throw new GLError('','Invalid data type for attribute '+name+': '+type);}addMatrixAttribute(gl,wrapper,locs,locations,d,obj,name);}else{throw new GLError('','Unknown data type for attribute '+name+': '+type);}break;}}return obj;}/***/},/***/9016:/***/function(module,__unused_webpack_exports,__nested_webpack_require_501052__){"use strict";var coallesceUniforms=__nested_webpack_require_501052__(3984);var GLError=__nested_webpack_require_501052__(9068);module.exports=createUniformWrapper;//Binds a function and returns a value
function identity(x){return function(){return x;};}function makeVector(length,fill){var result=new Array(length);for(var i=0;i<length;++i){result[i]=fill;}return result;}//Create shims for uniforms
function createUniformWrapper(gl,wrapper,uniforms,locations){function makeGetter(idx){return function(gl,wrapper,locations){return gl.getUniform(wrapper.program,locations[idx]);};}function makeSetter(type){return function updateProperty(obj){var indices=enumerateIndices('',type);for(var i=0;i<indices.length;++i){var item=indices[i];var path=item[0];var idx=item[1];if(locations[idx]){var objPath=obj;if(typeof path==='string'&&(path.indexOf('.')===0||path.indexOf('[')===0)){var key=path;if(path.indexOf('.')===0){key=path.slice(1);}if(key.indexOf(']')===key.length-1){var j=key.indexOf('[');var k1=key.slice(0,j);var k2=key.slice(j+1,key.length-1);objPath=k1?obj[k1][k2]:obj[k2];}else{objPath=obj[key];}}var t=uniforms[idx].type;var d;switch(t){case'bool':case'int':case'sampler2D':case'samplerCube':gl.uniform1i(locations[idx],objPath);break;case'float':gl.uniform1f(locations[idx],objPath);break;default:var vidx=t.indexOf('vec');if(0<=vidx&&vidx<=1&&t.length===4+vidx){d=t.charCodeAt(t.length-1)-48;if(d<2||d>4){throw new GLError('','Invalid data type');}switch(t.charAt(0)){case'b':case'i':gl['uniform'+d+'iv'](locations[idx],objPath);break;case'v':gl['uniform'+d+'fv'](locations[idx],objPath);break;default:throw new GLError('','Unrecognized data type for vector '+name+': '+t);}}else if(t.indexOf('mat')===0&&t.length===4){d=t.charCodeAt(t.length-1)-48;if(d<2||d>4){throw new GLError('','Invalid uniform dimension type for matrix '+name+': '+t);}gl['uniformMatrix'+d+'fv'](locations[idx],false,objPath);break;}else{throw new GLError('','Unknown uniform data type for '+name+': '+t);}}}}};}function enumerateIndices(prefix,type){if(typeof type!=='object'){return[[prefix,type]];}var indices=[];for(var id in type){var prop=type[id];var tprefix=prefix;if(parseInt(id)+''===id){tprefix+='['+id+']';}else{tprefix+='.'+id;}if(typeof prop==='object'){indices.push.apply(indices,enumerateIndices(tprefix,prop));}else{indices.push([tprefix,prop]);}}return indices;}function defaultValue(type){switch(type){case'bool':return false;case'int':case'sampler2D':case'samplerCube':return 0;case'float':return 0.0;default:var vidx=type.indexOf('vec');if(0<=vidx&&vidx<=1&&type.length===4+vidx){var d=type.charCodeAt(type.length-1)-48;if(d<2||d>4){throw new GLError('','Invalid data type');}if(type.charAt(0)==='b'){return makeVector(d,false);}return makeVector(d,0);}else if(type.indexOf('mat')===0&&type.length===4){var d=type.charCodeAt(type.length-1)-48;if(d<2||d>4){throw new GLError('','Invalid uniform dimension type for matrix '+name+': '+type);}return makeVector(d*d,0);}else{throw new GLError('','Unknown uniform data type for '+name+': '+type);}}}function storeProperty(obj,prop,type){if(typeof type==='object'){var child=processObject(type);Object.defineProperty(obj,prop,{get:identity(child),set:makeSetter(type),enumerable:true,configurable:false});}else{if(locations[type]){Object.defineProperty(obj,prop,{get:makeGetter(type),set:makeSetter(type),enumerable:true,configurable:false});}else{obj[prop]=defaultValue(uniforms[type].type);}}}function processObject(obj){var result;if(Array.isArray(obj)){result=new Array(obj.length);for(var i=0;i<obj.length;++i){storeProperty(result,i,obj[i]);}}else{result={};for(var id in obj){storeProperty(result,id,obj[id]);}}return result;}//Return data
var coallesced=coallesceUniforms(uniforms,true);return{get:identity(processObject(coallesced)),set:makeSetter(coallesced),enumerable:true,configurable:true};}/***/},/***/3984:/***/function(module){"use strict";module.exports=makeReflectTypes;//Construct type info for reflection.
//
// This iterates over the flattened list of uniform type values and smashes them into a JSON object.
//
// The leaves of the resulting object are either indices or type strings representing primitive glslify types
function makeReflectTypes(uniforms,useIndex){var obj={};for(var i=0;i<uniforms.length;++i){var n=uniforms[i].name;var parts=n.split(".");var o=obj;for(var j=0;j<parts.length;++j){var x=parts[j].split("[");if(x.length>1){if(!(x[0]in o)){o[x[0]]=[];}o=o[x[0]];for(var k=1;k<x.length;++k){var y=parseInt(x[k]);if(k<x.length-1||j<parts.length-1){if(!(y in o)){if(k<x.length-1){o[y]=[];}else{o[y]={};}}o=o[y];}else{if(useIndex){o[y]=i;}else{o[y]=uniforms[i].type;}}}}else if(j<parts.length-1){if(!(x[0]in o)){o[x[0]]={};}o=o[x[0]];}else{if(useIndex){o[x[0]]=i;}else{o[x[0]]=uniforms[i].type;}}}}return obj;}/***/},/***/2631:/***/function(__unused_webpack_module,exports){"use strict";exports.uniforms=runtimeUniforms;exports.attributes=runtimeAttributes;var GL_TO_GLSL_TYPES={'FLOAT':'float','FLOAT_VEC2':'vec2','FLOAT_VEC3':'vec3','FLOAT_VEC4':'vec4','INT':'int','INT_VEC2':'ivec2','INT_VEC3':'ivec3','INT_VEC4':'ivec4','BOOL':'bool','BOOL_VEC2':'bvec2','BOOL_VEC3':'bvec3','BOOL_VEC4':'bvec4','FLOAT_MAT2':'mat2','FLOAT_MAT3':'mat3','FLOAT_MAT4':'mat4','SAMPLER_2D':'sampler2D','SAMPLER_CUBE':'samplerCube'};var GL_TABLE=null;function getType(gl,type){if(!GL_TABLE){var typeNames=Object.keys(GL_TO_GLSL_TYPES);GL_TABLE={};for(var i=0;i<typeNames.length;++i){var tn=typeNames[i];GL_TABLE[gl[tn]]=GL_TO_GLSL_TYPES[tn];}}return GL_TABLE[type];}function runtimeUniforms(gl,program){var numUniforms=gl.getProgramParameter(program,gl.ACTIVE_UNIFORMS);var result=[];for(var i=0;i<numUniforms;++i){var info=gl.getActiveUniform(program,i);if(info){var type=getType(gl,info.type);if(info.size>1){for(var j=0;j<info.size;++j){result.push({name:info.name.replace('[0]','['+j+']'),type:type});}}else{result.push({name:info.name,type:type});}}}return result;}function runtimeAttributes(gl,program){var numAttributes=gl.getProgramParameter(program,gl.ACTIVE_ATTRIBUTES);var result=[];for(var i=0;i<numAttributes;++i){var info=gl.getActiveAttrib(program,i);if(info){result.push({name:info.name,type:getType(gl,info.type)});}}return result;}/***/},/***/1628:/***/function(__unused_webpack_module,exports,__nested_webpack_require_507323__){"use strict";exports.shader=getShaderReference;exports.program=createProgram;var GLError=__nested_webpack_require_507323__(9068);var formatCompilerError=__nested_webpack_require_507323__(3530);var weakMap=typeof WeakMap==='undefined'?__nested_webpack_require_507323__(4037):WeakMap;var CACHE=new weakMap();var SHADER_COUNTER=0;function ShaderReference(id,src,type,shader,programs,count,cache){this.id=id;this.src=src;this.type=type;this.shader=shader;this.count=count;this.programs=[];this.cache=cache;}ShaderReference.prototype.dispose=function(){if(--this.count===0){var cache=this.cache;var gl=cache.gl;//Remove program references
var programs=this.programs;for(var i=0,n=programs.length;i<n;++i){var p=cache.programs[programs[i]];if(p){delete cache.programs[i];gl.deleteProgram(p);}}//Remove shader reference
gl.deleteShader(this.shader);delete cache.shaders[this.type===gl.FRAGMENT_SHADER|0][this.src];}};function ContextCache(gl){this.gl=gl;this.shaders=[{},{}];this.programs={};}var proto=ContextCache.prototype;function compileShader(gl,type,src){var shader=gl.createShader(type);gl.shaderSource(shader,src);gl.compileShader(shader);if(!gl.getShaderParameter(shader,gl.COMPILE_STATUS)){var errLog=gl.getShaderInfoLog(shader);try{var fmt=formatCompilerError(errLog,src,type);}catch(e){console.warn('Failed to format compiler error: '+e);throw new GLError(errLog,'Error compiling shader:\n'+errLog);}throw new GLError(errLog,fmt.short,fmt.long);}return shader;}proto.getShaderReference=function(type,src){var gl=this.gl;var shaders=this.shaders[type===gl.FRAGMENT_SHADER|0];var shader=shaders[src];if(!shader||!gl.isShader(shader.shader)){var shaderObj=compileShader(gl,type,src);shader=shaders[src]=new ShaderReference(SHADER_COUNTER++,src,type,shaderObj,[],1,this);}else{shader.count+=1;}return shader;};function linkProgram(gl,vshader,fshader,attribs,locations){var program=gl.createProgram();gl.attachShader(program,vshader);gl.attachShader(program,fshader);for(var i=0;i<attribs.length;++i){gl.bindAttribLocation(program,locations[i],attribs[i]);}gl.linkProgram(program);if(!gl.getProgramParameter(program,gl.LINK_STATUS)){var errLog=gl.getProgramInfoLog(program);throw new GLError(errLog,'Error linking program: '+errLog);}return program;}proto.getProgram=function(vref,fref,attribs,locations){var token=[vref.id,fref.id,attribs.join(':'),locations.join(':')].join('@');var prog=this.programs[token];if(!prog||!this.gl.isProgram(prog)){this.programs[token]=prog=linkProgram(this.gl,vref.shader,fref.shader,attribs,locations);vref.programs.push(token);fref.programs.push(token);}return prog;};function getCache(gl){var ctxCache=CACHE.get(gl);if(!ctxCache){ctxCache=new ContextCache(gl);CACHE.set(gl,ctxCache);}return ctxCache;}function getShaderReference(gl,type,src){return getCache(gl).getShaderReference(type,src);}function createProgram(gl,vref,fref,attribs,locations){return getCache(gl).getProgram(vref,fref,attribs,locations);}/***/},/***/3050:/***/function(module){"use strict";module.exports=createSpikes2D;function GLSpikes2D(plot){this.plot=plot;this.enable=[true,true,false,false];this.width=[1,1,1,1];this.color=[[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1]];this.center=[Infinity,Infinity];}var proto=GLSpikes2D.prototype;proto.update=function(options){options=options||{};this.enable=(options.enable||[true,true,false,false]).slice();this.width=(options.width||[1,1,1,1]).slice();this.color=(options.color||[[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1]]).map(function(x){return x.slice();});this.center=(options.center||[Infinity,Infinity]).slice();this.plot.setOverlayDirty();};proto.draw=function(){var spikeEnable=this.enable;var spikeWidth=this.width;var spikeColor=this.color;var spikeCenter=this.center;var plot=this.plot;var line=plot.line;var dataBox=plot.dataBox;var viewPixels=plot.viewBox;line.bind();if(dataBox[0]<=spikeCenter[0]&&spikeCenter[0]<=dataBox[2]&&dataBox[1]<=spikeCenter[1]&&spikeCenter[1]<=dataBox[3]){var centerX=viewPixels[0]+(spikeCenter[0]-dataBox[0])/(dataBox[2]-dataBox[0])*(viewPixels[2]-viewPixels[0]);var centerY=viewPixels[1]+(spikeCenter[1]-dataBox[1])/(dataBox[3]-dataBox[1])*(viewPixels[3]-viewPixels[1]);if(spikeEnable[0]){line.drawLine(centerX,centerY,viewPixels[0],centerY,spikeWidth[0],spikeColor[0]);}if(spikeEnable[1]){line.drawLine(centerX,centerY,centerX,viewPixels[1],spikeWidth[1],spikeColor[1]);}if(spikeEnable[2]){line.drawLine(centerX,centerY,viewPixels[2],centerY,spikeWidth[2],spikeColor[2]);}if(spikeEnable[3]){line.drawLine(centerX,centerY,centerX,viewPixels[3],spikeWidth[3],spikeColor[3]);}}};proto.dispose=function(){this.plot.removeOverlay(this);};function createSpikes2D(plot,options){var spikes=new GLSpikes2D(plot);spikes.update(options);plot.addOverlay(spikes);return spikes;}/***/},/***/3540:/***/function(module,__unused_webpack_exports,__nested_webpack_require_512120__){"use strict";var glslify=__nested_webpack_require_512120__(6832);var createShader=__nested_webpack_require_512120__(5158);var vertSrc=glslify(["precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 position, color;\nattribute float weight;\n\nuniform mat4 model, view, projection;\nuniform vec3 coordinates[3];\nuniform vec4 colors[3];\nuniform vec2 screenShape;\nuniform float lineWidth;\n\nvarying vec4 fragColor;\n\nvoid main() {\n  vec3 vertexPosition = mix(coordinates[0],\n    mix(coordinates[2], coordinates[1], 0.5 * (position + 1.0)), abs(position));\n\n  vec4 clipPos = projection * view * model * vec4(vertexPosition, 1.0);\n  vec2 clipOffset = (projection * view * model * vec4(color, 0.0)).xy;\n  vec2 delta = weight * clipOffset * screenShape;\n  vec2 lineOffset = normalize(vec2(delta.y, -delta.x)) / screenShape;\n\n  gl_Position   = vec4(clipPos.xy + clipPos.w * 0.5 * lineWidth * lineOffset, clipPos.z, clipPos.w);\n  fragColor     = color.x * colors[0] + color.y * colors[1] + color.z * colors[2];\n}\n"]);var fragSrc=glslify(["precision mediump float;\n#define GLSLIFY 1\n\nvarying vec4 fragColor;\n\nvoid main() {\n  gl_FragColor = fragColor;\n}"]);module.exports=function(gl){return createShader(gl,vertSrc,fragSrc,null,[{name:'position',type:'vec3'},{name:'color',type:'vec3'},{name:'weight',type:'float'}]);};/***/},/***/6496:/***/function(module,__unused_webpack_exports,__nested_webpack_require_513517__){"use strict";var createBuffer=__nested_webpack_require_513517__(5827);var createVAO=__nested_webpack_require_513517__(2944);var createShader=__nested_webpack_require_513517__(3540);module.exports=createSpikes;var identity=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];function AxisSpikes(gl,buffer,vao,shader){this.gl=gl;this.buffer=buffer;this.vao=vao;this.shader=shader;this.pixelRatio=1;this.bounds=[[-1000,-1000,-1000],[1000,1000,1000]];this.position=[0,0,0];this.lineWidth=[2,2,2];this.colors=[[0,0,0,1],[0,0,0,1],[0,0,0,1]];this.enabled=[true,true,true];this.drawSides=[true,true,true];this.axes=null;}var proto=AxisSpikes.prototype;var OUTER_FACE=[0,0,0];var INNER_FACE=[0,0,0];var SHAPE=[0,0];proto.isTransparent=function(){return false;};proto.drawTransparent=function(camera){};proto.draw=function(camera){var gl=this.gl;var vao=this.vao;var shader=this.shader;vao.bind();shader.bind();var model=camera.model||identity;var view=camera.view||identity;var projection=camera.projection||identity;var axis;if(this.axes){axis=this.axes.lastCubeProps.axis;}var outerFace=OUTER_FACE;var innerFace=INNER_FACE;for(var i=0;i<3;++i){if(axis&&axis[i]<0){outerFace[i]=this.bounds[0][i];innerFace[i]=this.bounds[1][i];}else{outerFace[i]=this.bounds[1][i];innerFace[i]=this.bounds[0][i];}}SHAPE[0]=gl.drawingBufferWidth;SHAPE[1]=gl.drawingBufferHeight;shader.uniforms.model=model;shader.uniforms.view=view;shader.uniforms.projection=projection;shader.uniforms.coordinates=[this.position,outerFace,innerFace];shader.uniforms.colors=this.colors;shader.uniforms.screenShape=SHAPE;for(var i=0;i<3;++i){shader.uniforms.lineWidth=this.lineWidth[i]*this.pixelRatio;if(this.enabled[i]){vao.draw(gl.TRIANGLES,6,6*i);if(this.drawSides[i]){vao.draw(gl.TRIANGLES,12,18+12*i);}}}vao.unbind();};proto.update=function(options){if(!options){return;}if("bounds"in options){this.bounds=options.bounds;}if("position"in options){this.position=options.position;}if("lineWidth"in options){this.lineWidth=options.lineWidth;}if("colors"in options){this.colors=options.colors;}if("enabled"in options){this.enabled=options.enabled;}if("drawSides"in options){this.drawSides=options.drawSides;}};proto.dispose=function(){this.vao.dispose();this.buffer.dispose();this.shader.dispose();};function createSpikes(gl,options){//Create buffers
var data=[];function line(x,y,z,i,l,h){var row=[x,y,z,0,0,0,1];row[i+3]=1;row[i]=l;data.push.apply(data,row);row[6]=-1;data.push.apply(data,row);row[i]=h;data.push.apply(data,row);data.push.apply(data,row);row[6]=1;data.push.apply(data,row);row[i]=l;data.push.apply(data,row);}line(0,0,0,0,0,1);line(0,0,0,1,0,1);line(0,0,0,2,0,1);line(1,0,0,1,-1,1);line(1,0,0,2,-1,1);line(0,1,0,0,-1,1);line(0,1,0,2,-1,1);line(0,0,1,0,-1,1);line(0,0,1,1,-1,1);var buffer=createBuffer(gl,data);var vao=createVAO(gl,[{type:gl.FLOAT,buffer:buffer,size:3,offset:0,stride:28},{type:gl.FLOAT,buffer:buffer,size:3,offset:12,stride:28},{type:gl.FLOAT,buffer:buffer,size:1,offset:24,stride:28}]);//Create shader
var shader=createShader(gl);shader.attributes.position.location=0;shader.attributes.color.location=1;shader.attributes.weight.location=2;//Create spike object
var spikes=new AxisSpikes(gl,buffer,vao,shader);//Set parameters
spikes.update(options);//Return resulting object
return spikes;}/***/},/***/9578:/***/function(__unused_webpack_module,exports,__nested_webpack_require_516827__){var glslify=__nested_webpack_require_516827__(6832);var triVertSrc=glslify(["precision highp float;\n\nprecision highp float;\n#define GLSLIFY 1\n\nvec3 getOrthogonalVector(vec3 v) {\n  // Return up-vector for only-z vector.\n  // Return ax + by + cz = 0, a point that lies on the plane that has v as a normal and that isn't (0,0,0).\n  // From the above if-statement we have ||a|| > 0  U  ||b|| > 0.\n  // Assign z = 0, x = -b, y = a:\n  // a*-b + b*a + c*0 = -ba + ba + 0 = 0\n  if (v.x*v.x > v.z*v.z || v.y*v.y > v.z*v.z) {\n    return normalize(vec3(-v.y, v.x, 0.0));\n  } else {\n    return normalize(vec3(0.0, v.z, -v.y));\n  }\n}\n\n// Calculate the tube vertex and normal at the given index.\n//\n// The returned vertex is for a tube ring with its center at origin, radius of length(d), pointing in the direction of d.\n//\n// Each tube segment is made up of a ring of vertices.\n// These vertices are used to make up the triangles of the tube by connecting them together in the vertex array.\n// The indexes of tube segments run from 0 to 8.\n//\nvec3 getTubePosition(vec3 d, float index, out vec3 normal) {\n  float segmentCount = 8.0;\n\n  float angle = 2.0 * 3.14159 * (index / segmentCount);\n\n  vec3 u = getOrthogonalVector(d);\n  vec3 v = normalize(cross(u, d));\n\n  vec3 x = u * cos(angle) * length(d);\n  vec3 y = v * sin(angle) * length(d);\n  vec3 v3 = x + y;\n\n  normal = normalize(v3);\n\n  return v3;\n}\n\nattribute vec4 vector;\nattribute vec4 color, position;\nattribute vec2 uv;\n\nuniform float vectorScale, tubeScale;\nuniform mat4 model, view, projection, inverseModel;\nuniform vec3 eyePosition, lightPosition;\n\nvarying vec3 f_normal, f_lightDirection, f_eyeDirection, f_data, f_position;\nvarying vec4 f_color;\nvarying vec2 f_uv;\n\nvoid main() {\n  // Scale the vector magnitude to stay constant with\n  // model & view changes.\n  vec3 normal;\n  vec3 XYZ = getTubePosition(mat3(model) * (tubeScale * vector.w * normalize(vector.xyz)), position.w, normal);\n  vec4 tubePosition = model * vec4(position.xyz, 1.0) + vec4(XYZ, 0.0);\n\n  //Lighting geometry parameters\n  vec4 cameraCoordinate = view * tubePosition;\n  cameraCoordinate.xyz /= cameraCoordinate.w;\n  f_lightDirection = lightPosition - cameraCoordinate.xyz;\n  f_eyeDirection   = eyePosition - cameraCoordinate.xyz;\n  f_normal = normalize((vec4(normal, 0.0) * inverseModel).xyz);\n\n  // vec4 m_position  = model * vec4(tubePosition, 1.0);\n  vec4 t_position  = view * tubePosition;\n  gl_Position      = projection * t_position;\n\n  f_color          = color;\n  f_data           = tubePosition.xyz;\n  f_position       = position.xyz;\n  f_uv             = uv;\n}\n"]);var triFragSrc=glslify(["#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n#define GLSLIFY 1\n\nfloat beckmannDistribution(float x, float roughness) {\n  float NdotH = max(x, 0.0001);\n  float cos2Alpha = NdotH * NdotH;\n  float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;\n  float roughness2 = roughness * roughness;\n  float denom = 3.141592653589793 * roughness2 * cos2Alpha * cos2Alpha;\n  return exp(tan2Alpha / roughness2) / denom;\n}\n\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.0);\n  float VdotH = max(dot(viewDirection, H), 0.000001);\n  float LdotH = max(dot(lightDirection, H), 0.000001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = min(1.0, min(G1, G2));\n  \n  //Distribution term\n  float D = beckmannDistribution(NdotH, roughness);\n\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  G * F * D / max(3.14159265 * VdotN, 0.000001);\n}\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nuniform vec3 clipBounds[2];\nuniform float roughness, fresnel, kambient, kdiffuse, kspecular, opacity;\nuniform sampler2D texture;\n\nvarying vec3 f_normal, f_lightDirection, f_eyeDirection, f_data, f_position;\nvarying vec4 f_color;\nvarying vec2 f_uv;\n\nvoid main() {\n  if (outOfRange(clipBounds[0], clipBounds[1], f_position)) discard;\n  vec3 N = normalize(f_normal);\n  vec3 L = normalize(f_lightDirection);\n  vec3 V = normalize(f_eyeDirection);\n\n  if(gl_FrontFacing) {\n    N = -N;\n  }\n\n  float specular = min(1.0, max(0.0, cookTorranceSpecular(L, V, N, roughness, fresnel)));\n  float diffuse  = min(kambient + kdiffuse * max(dot(N, L), 0.0), 1.0);\n\n  vec4 surfaceColor = f_color * texture2D(texture, f_uv);\n  vec4 litColor = surfaceColor.a * vec4(diffuse * surfaceColor.rgb + kspecular * vec3(1,1,1) * specular,  1.0);\n\n  gl_FragColor = litColor * opacity;\n}\n"]);var pickVertSrc=glslify(["precision highp float;\n\nprecision highp float;\n#define GLSLIFY 1\n\nvec3 getOrthogonalVector(vec3 v) {\n  // Return up-vector for only-z vector.\n  // Return ax + by + cz = 0, a point that lies on the plane that has v as a normal and that isn't (0,0,0).\n  // From the above if-statement we have ||a|| > 0  U  ||b|| > 0.\n  // Assign z = 0, x = -b, y = a:\n  // a*-b + b*a + c*0 = -ba + ba + 0 = 0\n  if (v.x*v.x > v.z*v.z || v.y*v.y > v.z*v.z) {\n    return normalize(vec3(-v.y, v.x, 0.0));\n  } else {\n    return normalize(vec3(0.0, v.z, -v.y));\n  }\n}\n\n// Calculate the tube vertex and normal at the given index.\n//\n// The returned vertex is for a tube ring with its center at origin, radius of length(d), pointing in the direction of d.\n//\n// Each tube segment is made up of a ring of vertices.\n// These vertices are used to make up the triangles of the tube by connecting them together in the vertex array.\n// The indexes of tube segments run from 0 to 8.\n//\nvec3 getTubePosition(vec3 d, float index, out vec3 normal) {\n  float segmentCount = 8.0;\n\n  float angle = 2.0 * 3.14159 * (index / segmentCount);\n\n  vec3 u = getOrthogonalVector(d);\n  vec3 v = normalize(cross(u, d));\n\n  vec3 x = u * cos(angle) * length(d);\n  vec3 y = v * sin(angle) * length(d);\n  vec3 v3 = x + y;\n\n  normal = normalize(v3);\n\n  return v3;\n}\n\nattribute vec4 vector;\nattribute vec4 position;\nattribute vec4 id;\n\nuniform mat4 model, view, projection;\nuniform float tubeScale;\n\nvarying vec3 f_position;\nvarying vec4 f_id;\n\nvoid main() {\n  vec3 normal;\n  vec3 XYZ = getTubePosition(mat3(model) * (tubeScale * vector.w * normalize(vector.xyz)), position.w, normal);\n  vec4 tubePosition = model * vec4(position.xyz, 1.0) + vec4(XYZ, 0.0);\n\n  gl_Position = projection * view * tubePosition;\n  f_id        = id;\n  f_position  = position.xyz;\n}\n"]);var pickFragSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nuniform vec3  clipBounds[2];\nuniform float pickId;\n\nvarying vec3 f_position;\nvarying vec4 f_id;\n\nvoid main() {\n  if (outOfRange(clipBounds[0], clipBounds[1], f_position)) discard;\n\n  gl_FragColor = vec4(pickId, f_id.xyz);\n}"]);exports.meshShader={vertex:triVertSrc,fragment:triFragSrc,attributes:[{name:'position',type:'vec4'},{name:'color',type:'vec4'},{name:'uv',type:'vec2'},{name:'vector',type:'vec4'}]};exports.pickShader={vertex:pickVertSrc,fragment:pickFragSrc,attributes:[{name:'position',type:'vec4'},{name:'id',type:'vec4'},{name:'vector',type:'vec4'}]};/***/},/***/7307:/***/function(module,__unused_webpack_exports,__nested_webpack_require_525348__){"use strict";var vec3=__nested_webpack_require_525348__(2858);var vec4=__nested_webpack_require_525348__(4020);var GRID_TYPES=['xyz','xzy','yxz','yzx','zxy','zyx'];var streamToTube=function(stream,maxDivergence,minDistance,maxNorm){var points=stream.points;var velocities=stream.velocities;var divergences=stream.divergences;var verts=[];var faces=[];var vectors=[];var previousVerts=[];var currentVerts=[];var intensities=[];var previousIntensity=0;var currentIntensity=0;var currentVector=vec4.create();var previousVector=vec4.create();var facets=8;for(var i=0;i<points.length;i++){var p=points[i];var fwd=velocities[i];var r=divergences[i];if(maxDivergence===0){r=minDistance*0.05;}currentIntensity=vec3.length(fwd)/maxNorm;currentVector=vec4.create();vec3.copy(currentVector,fwd);currentVector[3]=r;for(var a=0;a<facets;a++){currentVerts[a]=[p[0],p[1],p[2],a];}if(previousVerts.length>0){for(var a=0;a<facets;a++){var a1=(a+1)%facets;verts.push(previousVerts[a],currentVerts[a],currentVerts[a1],currentVerts[a1],previousVerts[a1],previousVerts[a]);vectors.push(previousVector,currentVector,currentVector,currentVector,previousVector,previousVector);intensities.push(previousIntensity,currentIntensity,currentIntensity,currentIntensity,previousIntensity,previousIntensity);var len=verts.length;faces.push([len-6,len-5,len-4],[len-3,len-2,len-1]);}}var tmp1=previousVerts;previousVerts=currentVerts;currentVerts=tmp1;var tmp2=previousVector;previousVector=currentVector;currentVector=tmp2;var tmp3=previousIntensity;previousIntensity=currentIntensity;currentIntensity=tmp3;}return{positions:verts,cells:faces,vectors:vectors,vertexIntensity:intensities};};var createTubes=function(streams,colormap,maxDivergence,minDistance){var maxNorm=0;for(var i=0;i<streams.length;i++){var velocities=streams[i].velocities;for(var j=0;j<velocities.length;j++){maxNorm=Math.max(maxNorm,vec3.length(velocities[j]));}}var tubes=streams.map(function(s){return streamToTube(s,maxDivergence,minDistance,maxNorm);});var positions=[];var cells=[];var vectors=[];var vertexIntensity=[];for(var i=0;i<tubes.length;i++){var tube=tubes[i];var offset=positions.length;positions=positions.concat(tube.positions);vectors=vectors.concat(tube.vectors);vertexIntensity=vertexIntensity.concat(tube.vertexIntensity);for(var j=0;j<tube.cells.length;j++){var cell=tube.cells[j];var newCell=[];cells.push(newCell);for(var k=0;k<cell.length;k++){newCell.push(cell[k]+offset);}}}return{positions:positions,cells:cells,vectors:vectors,vertexIntensity:vertexIntensity,colormap:colormap};};var findLastSmallerIndex=function(points,v){var len=points.length;var i;for(i=0;i<len;i++){var p=points[i];if(p===v)return i;else if(p>v)return i-1;}return i;};var clamp=function(v,min,max){return v<min?min:v>max?max:v;};var sampleMeshgrid=function(point,vectorField,gridInfo){var vectors=vectorField.vectors;var meshgrid=vectorField.meshgrid;var x=point[0];var y=point[1];var z=point[2];var w=meshgrid[0].length;var h=meshgrid[1].length;var d=meshgrid[2].length;// Find the index of the nearest smaller value in the meshgrid for each coordinate of (x,y,z).
// The nearest smaller value index for x is the index x0 such that
// meshgrid[0][x0] < x and for all x1 > x0, meshgrid[0][x1] >= x.
var x0=findLastSmallerIndex(meshgrid[0],x);var y0=findLastSmallerIndex(meshgrid[1],y);var z0=findLastSmallerIndex(meshgrid[2],z);// Get the nearest larger meshgrid value indices.
// From the above "nearest smaller value", we know that
//   meshgrid[0][x0] < x
//   meshgrid[0][x0+1] >= x
var x1=x0+1;var y1=y0+1;var z1=z0+1;x0=clamp(x0,0,w-1);x1=clamp(x1,0,w-1);y0=clamp(y0,0,h-1);y1=clamp(y1,0,h-1);z0=clamp(z0,0,d-1);z1=clamp(z1,0,d-1);// Reject points outside the meshgrid, return a zero vector.
if(x0<0||y0<0||z0<0||x1>w-1||y1>h-1||z1>d-1){return vec3.create();}// Normalize point coordinates to 0..1 scaling factor between x0 and x1.
var mX0=meshgrid[0][x0];var mX1=meshgrid[0][x1];var mY0=meshgrid[1][y0];var mY1=meshgrid[1][y1];var mZ0=meshgrid[2][z0];var mZ1=meshgrid[2][z1];var xf=(x-mX0)/(mX1-mX0);var yf=(y-mY0)/(mY1-mY0);var zf=(z-mZ0)/(mZ1-mZ0);if(!isFinite(xf))xf=0.5;if(!isFinite(yf))yf=0.5;if(!isFinite(zf))zf=0.5;var x0off;var x1off;var y0off;var y1off;var z0off;var z1off;if(gridInfo.reversedX){x0=w-1-x0;x1=w-1-x1;}if(gridInfo.reversedY){y0=h-1-y0;y1=h-1-y1;}if(gridInfo.reversedZ){z0=d-1-z0;z1=d-1-z1;}switch(gridInfo.filled){case 5:// 'zyx'
z0off=z0;z1off=z1;y0off=y0*d;y1off=y1*d;x0off=x0*d*h;x1off=x1*d*h;break;case 4:// 'zxy'
z0off=z0;z1off=z1;x0off=x0*d;x1off=x1*d;y0off=y0*d*w;y1off=y1*d*w;break;case 3:// 'yzx'
y0off=y0;y1off=y1;z0off=z0*h;z1off=z1*h;x0off=x0*h*d;x1off=x1*h*d;break;case 2:// 'yxz'
y0off=y0;y1off=y1;x0off=x0*h;x1off=x1*h;z0off=z0*h*w;z1off=z1*h*w;break;case 1:// 'xzy'
x0off=x0;x1off=x1;z0off=z0*w;z1off=z1*w;y0off=y0*w*d;y1off=y1*w*d;break;default:// case 0: // 'xyz'
x0off=x0;x1off=x1;y0off=y0*w;y1off=y1*w;z0off=z0*w*h;z1off=z1*w*h;break;}// Sample data vectors around the (x,y,z) point.
var v000=vectors[x0off+y0off+z0off];var v001=vectors[x0off+y0off+z1off];var v010=vectors[x0off+y1off+z0off];var v011=vectors[x0off+y1off+z1off];var v100=vectors[x1off+y0off+z0off];var v101=vectors[x1off+y0off+z1off];var v110=vectors[x1off+y1off+z0off];var v111=vectors[x1off+y1off+z1off];var c00=vec3.create();var c01=vec3.create();var c10=vec3.create();var c11=vec3.create();vec3.lerp(c00,v000,v100,xf);vec3.lerp(c01,v001,v101,xf);vec3.lerp(c10,v010,v110,xf);vec3.lerp(c11,v011,v111,xf);var c0=vec3.create();var c1=vec3.create();vec3.lerp(c0,c00,c10,yf);vec3.lerp(c1,c01,c11,yf);var c=vec3.create();vec3.lerp(c,c0,c1,zf);return c;};var vabs=function(dst,v){var x=v[0];var y=v[1];var z=v[2];dst[0]=x<0?-x:x;dst[1]=y<0?-y:y;dst[2]=z<0?-z:z;return dst;};var findMinSeparation=function(xs){var minSeparation=Infinity;xs.sort(function(a,b){return a-b;});var len=xs.length;for(var i=1;i<len;i++){var d=Math.abs(xs[i]-xs[i-1]);if(d<minSeparation){minSeparation=d;}}return minSeparation;};// Finds the minimum per-component distance in positions.
//
var calculateMinPositionDistance=function(positions){var xs=[],ys=[],zs=[];var xi={},yi={},zi={};var len=positions.length;for(var i=0;i<len;i++){var p=positions[i];var x=p[0],y=p[1],z=p[2];// Split the positions array into arrays of unique component values.
//
// Why go through the trouble of using a uniqueness hash table vs
// sort and uniq:
//
// Suppose you've got a million positions in a 100x100x100 grid.
//
// Using a uniqueness hash table, you're doing 1M array reads,
// 3M hash table lookups from 100-element hashes, 300 hash table inserts, then
// sorting three 100-element arrays and iterating over them.
// Roughly, 1M + 3M * ln(100) + 300 * ln(100/2) + 3 * 100 * ln(100) + 3 * 100 =
//          1M + 13.8M + 0.0012M +  0.0014M + 0.0003M
//          =~ 15M
//
// Sort and uniq solution would do 1M array reads, 3M array inserts,
// sort three 1M-element arrays and iterate over them.
// Roughly, 1M + 3M + 3 * 1M * ln(1M) + 3 * 1M =
//          1M + 3M + 41.4M + 3M
//          =~ 48.4M
//
// Guessing that a hard-coded sort & uniq would be faster due to not having
// to run a hashing function on everything. More memory usage though
// (bunch of small hash tables vs. duplicating the input array.)
//
// In JS-land, who knows. Maybe xi[x] casts x to string and destroys perf,
// maybe numeric keys get special-cased, maybe the object lookups run at near O(1)-speeds.
// Maybe the sorting comparison function is expensive to call, maybe it gets inlined or special-cased.
//
// ... You're probably not going to call this with more than 10k positions anyhow, so this is very academic.
//
if(!xi[x]){xs.push(x);xi[x]=true;}if(!yi[y]){ys.push(y);yi[y]=true;}if(!zi[z]){zs.push(z);zi[z]=true;}}var xSep=findMinSeparation(xs);var ySep=findMinSeparation(ys);var zSep=findMinSeparation(zs);var minSeparation=Math.min(xSep,ySep,zSep);return isFinite(minSeparation)?minSeparation:1;};module.exports=function(vectorField,bounds){var positions=vectorField.startingPositions;var maxLength=vectorField.maxLength||1000;var tubeSize=vectorField.tubeSize||1;var absoluteTubeSize=vectorField.absoluteTubeSize;var gridFill=vectorField.gridFill||'+x+y+z';var gridInfo={};if(gridFill.indexOf('-x')!==-1){gridInfo.reversedX=true;}if(gridFill.indexOf('-y')!==-1){gridInfo.reversedY=true;}if(gridFill.indexOf('-z')!==-1){gridInfo.reversedZ=true;}gridInfo.filled=GRID_TYPES.indexOf(gridFill.replace(/-/g,'').replace(/\+/g,''));var getVelocity=vectorField.getVelocity||function(p){return sampleMeshgrid(p,vectorField,gridInfo);};var getDivergence=vectorField.getDivergence||function(p,v0){var dp=vec3.create();var e=0.0001;vec3.add(dp,p,[e,0,0]);var vx=getVelocity(dp);vec3.subtract(vx,vx,v0);vec3.scale(vx,vx,1/e);vec3.add(dp,p,[0,e,0]);var vy=getVelocity(dp);vec3.subtract(vy,vy,v0);vec3.scale(vy,vy,1/e);vec3.add(dp,p,[0,0,e]);var vz=getVelocity(dp);vec3.subtract(vz,vz,v0);vec3.scale(vz,vz,1/e);vec3.add(dp,vx,vy);vec3.add(dp,dp,vz);return dp;};var streams=[];var minX=bounds[0][0],minY=bounds[0][1],minZ=bounds[0][2];var maxX=bounds[1][0],maxY=bounds[1][1],maxZ=bounds[1][2];var inBounds=function(p){var x=p[0];var y=p[1];var z=p[2];return!(x<minX||x>maxX||y<minY||y>maxY||z<minZ||z>maxZ);};var boundsSize=vec3.distance(bounds[0],bounds[1]);var maxStepSize=10*boundsSize/maxLength;var maxStepSizeSq=maxStepSize*maxStepSize;var minDistance=1;var maxDivergence=0;// For component-wise divergence vec3.create();
// In case we need to do component-wise divergence visualization
// var tmp = vec3.create();
var len=positions.length;if(len>1){minDistance=calculateMinPositionDistance(positions);}for(var i=0;i<len;i++){var p=vec3.create();vec3.copy(p,positions[i]);var stream=[p];var velocities=[];var v=getVelocity(p);var op=p;velocities.push(v);var divergences=[];var dv=getDivergence(p,v);var dvLength=vec3.length(dv);if(isFinite(dvLength)&&dvLength>maxDivergence){maxDivergence=dvLength;}// In case we need to do component-wise divergence visualization
// vec3.max(maxDivergence, maxDivergence, vabs(tmp, dv));
divergences.push(dvLength);streams.push({points:stream,velocities:velocities,divergences:divergences});var j=0;while(j<maxLength*100&&stream.length<maxLength&&inBounds(p)){j++;var np=vec3.clone(v);var sqLen=vec3.squaredLength(np);if(sqLen===0){break;}else if(sqLen>maxStepSizeSq){vec3.scale(np,np,maxStepSize/Math.sqrt(sqLen));}vec3.add(np,np,p);v=getVelocity(np);if(vec3.squaredDistance(op,np)-maxStepSizeSq>-0.0001*maxStepSizeSq){stream.push(np);op=np;velocities.push(v);var dv=getDivergence(np,v);var dvLength=vec3.length(dv);if(isFinite(dvLength)&&dvLength>maxDivergence){maxDivergence=dvLength;}// In case we need to do component-wise divergence visualization
//vec3.max(maxDivergence, maxDivergence, vabs(tmp, dv));
divergences.push(dvLength);}p=np;}}var tubes=createTubes(streams,vectorField.colormap,maxDivergence,minDistance);if(absoluteTubeSize){tubes.tubeScale=absoluteTubeSize;}else{// Avoid division by zero.
if(maxDivergence===0){maxDivergence=1;}tubes.tubeScale=tubeSize*0.5*minDistance/maxDivergence;}return tubes;};var shaders=__nested_webpack_require_525348__(9578);var createMesh=__nested_webpack_require_525348__(1140).createMesh;module.exports.createTubeMesh=function(gl,params){return createMesh(gl,params,{shaders:shaders,traceType:'streamtube'});};/***/},/***/9054:/***/function(__unused_webpack_module,exports,__nested_webpack_require_536673__){var createShader=__nested_webpack_require_536673__(5158);var glslify=__nested_webpack_require_536673__(6832);var vertSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nattribute vec4 uv;\nattribute vec3 f;\nattribute vec3 normal;\n\nuniform vec3 objectOffset;\nuniform mat4 model, view, projection, inverseModel;\nuniform vec3 lightPosition, eyePosition;\nuniform sampler2D colormap;\n\nvarying float value, kill;\nvarying vec3 worldCoordinate;\nvarying vec2 planeCoordinate;\nvarying vec3 lightDirection, eyeDirection, surfaceNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  vec3 localCoordinate = vec3(uv.zw, f.x);\n  worldCoordinate = objectOffset + localCoordinate;\n  vec4 worldPosition = model * vec4(worldCoordinate, 1.0);\n  vec4 clipPosition = projection * view * worldPosition;\n  gl_Position = clipPosition;\n  kill = f.y;\n  value = f.z;\n  planeCoordinate = uv.xy;\n\n  vColor = texture2D(colormap, vec2(value, value));\n\n  //Lighting geometry parameters\n  vec4 cameraCoordinate = view * worldPosition;\n  cameraCoordinate.xyz /= cameraCoordinate.w;\n  lightDirection = lightPosition - cameraCoordinate.xyz;\n  eyeDirection   = eyePosition - cameraCoordinate.xyz;\n  surfaceNormal  = normalize((vec4(normal,0) * inverseModel).xyz);\n}\n"]);var fragSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nfloat beckmannDistribution(float x, float roughness) {\n  float NdotH = max(x, 0.0001);\n  float cos2Alpha = NdotH * NdotH;\n  float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;\n  float roughness2 = roughness * roughness;\n  float denom = 3.141592653589793 * roughness2 * cos2Alpha * cos2Alpha;\n  return exp(tan2Alpha / roughness2) / denom;\n}\n\nfloat beckmannSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness) {\n  return beckmannDistribution(dot(surfaceNormal, normalize(lightDirection + viewDirection)), roughness);\n}\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nuniform vec3 lowerBound, upperBound;\nuniform float contourTint;\nuniform vec4 contourColor;\nuniform sampler2D colormap;\nuniform vec3 clipBounds[2];\nuniform float roughness, fresnel, kambient, kdiffuse, kspecular, opacity;\nuniform float vertexColor;\n\nvarying float value, kill;\nvarying vec3 worldCoordinate;\nvarying vec3 lightDirection, eyeDirection, surfaceNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  if (\n    kill > 0.0 ||\n    vColor.a == 0.0 ||\n    outOfRange(clipBounds[0], clipBounds[1], worldCoordinate)\n  ) discard;\n\n  vec3 N = normalize(surfaceNormal);\n  vec3 V = normalize(eyeDirection);\n  vec3 L = normalize(lightDirection);\n\n  if(gl_FrontFacing) {\n    N = -N;\n  }\n\n  float specular = max(beckmannSpecular(L, V, N, roughness), 0.);\n  float diffuse  = min(kambient + kdiffuse * max(dot(N, L), 0.0), 1.0);\n\n  //decide how to interpolate color — in vertex or in fragment\n  vec4 surfaceColor =\n    step(vertexColor, .5) * texture2D(colormap, vec2(value, value)) +\n    step(.5, vertexColor) * vColor;\n\n  vec4 litColor = surfaceColor.a * vec4(diffuse * surfaceColor.rgb + kspecular * vec3(1,1,1) * specular,  1.0);\n\n  gl_FragColor = mix(litColor, contourColor, contourTint) * opacity;\n}\n"]);var contourVertSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nattribute vec4 uv;\nattribute float f;\n\nuniform vec3 objectOffset;\nuniform mat3 permutation;\nuniform mat4 model, view, projection;\nuniform float height, zOffset;\nuniform sampler2D colormap;\n\nvarying float value, kill;\nvarying vec3 worldCoordinate;\nvarying vec2 planeCoordinate;\nvarying vec3 lightDirection, eyeDirection, surfaceNormal;\nvarying vec4 vColor;\n\nvoid main() {\n  vec3 dataCoordinate = permutation * vec3(uv.xy, height);\n  worldCoordinate = objectOffset + dataCoordinate;\n  vec4 worldPosition = model * vec4(worldCoordinate, 1.0);\n\n  vec4 clipPosition = projection * view * worldPosition;\n  clipPosition.z += zOffset;\n\n  gl_Position = clipPosition;\n  value = f + objectOffset.z;\n  kill = -1.0;\n  planeCoordinate = uv.zw;\n\n  vColor = texture2D(colormap, vec2(value, value));\n\n  //Don't do lighting for contours\n  surfaceNormal   = vec3(1,0,0);\n  eyeDirection    = vec3(0,1,0);\n  lightDirection  = vec3(0,0,1);\n}\n"]);var pickSrc=glslify(["precision highp float;\n#define GLSLIFY 1\n\nbool outOfRange(float a, float b, float p) {\n  return ((p > max(a, b)) || \n          (p < min(a, b)));\n}\n\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y));\n}\n\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\n  return (outOfRange(a.x, b.x, p.x) ||\n          outOfRange(a.y, b.y, p.y) ||\n          outOfRange(a.z, b.z, p.z));\n}\n\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\n  return outOfRange(a.xyz, b.xyz, p.xyz);\n}\n\nuniform vec2 shape;\nuniform vec3 clipBounds[2];\nuniform float pickId;\n\nvarying float value, kill;\nvarying vec3 worldCoordinate;\nvarying vec2 planeCoordinate;\nvarying vec3 surfaceNormal;\n\nvec2 splitFloat(float v) {\n  float vh = 255.0 * v;\n  float upper = floor(vh);\n  float lower = fract(vh);\n  return vec2(upper / 255.0, floor(lower * 16.0) / 16.0);\n}\n\nvoid main() {\n  if ((kill > 0.0) ||\n      (outOfRange(clipBounds[0], clipBounds[1], worldCoordinate))) discard;\n\n  vec2 ux = splitFloat(planeCoordinate.x / shape.x);\n  vec2 uy = splitFloat(planeCoordinate.y / shape.y);\n  gl_FragColor = vec4(pickId, ux.x, uy.x, ux.y + (uy.y/16.0));\n}\n"]);exports.createShader=function(gl){var shader=createShader(gl,vertSrc,fragSrc,null,[{name:'uv',type:'vec4'},{name:'f',type:'vec3'},{name:'normal',type:'vec3'}]);shader.attributes.uv.location=0;shader.attributes.f.location=1;shader.attributes.normal.location=2;return shader;};exports.createPickShader=function(gl){var shader=createShader(gl,vertSrc,pickSrc,null,[{name:'uv',type:'vec4'},{name:'f',type:'vec3'},{name:'normal',type:'vec3'}]);shader.attributes.uv.location=0;shader.attributes.f.location=1;shader.attributes.normal.location=2;return shader;};exports.createContourShader=function(gl){var shader=createShader(gl,contourVertSrc,fragSrc,null,[{name:'uv',type:'vec4'},{name:'f',type:'float'}]);shader.attributes.uv.location=0;shader.attributes.f.location=1;return shader;};exports.createPickContourShader=function(gl){var shader=createShader(gl,contourVertSrc,pickSrc,null,[{name:'uv',type:'vec4'},{name:'f',type:'float'}]);shader.attributes.uv.location=0;shader.attributes.f.location=1;return shader;};/***/},/***/3754:/***/function(module,__unused_webpack_exports,__nested_webpack_require_543637__){"use strict";module.exports=createSurfacePlot;var bits=__nested_webpack_require_543637__(2288);var createBuffer=__nested_webpack_require_543637__(5827);var createVAO=__nested_webpack_require_543637__(2944);var createTexture=__nested_webpack_require_543637__(8931);var pool=__nested_webpack_require_543637__(5306);var colormap=__nested_webpack_require_543637__(9156);var ops=__nested_webpack_require_543637__(7498);var pack=__nested_webpack_require_543637__(7382);var ndarray=__nested_webpack_require_543637__(5050);var surfaceNets=__nested_webpack_require_543637__(4162);var multiply=__nested_webpack_require_543637__(104);var invert=__nested_webpack_require_543637__(7437);var bsearch=__nested_webpack_require_543637__(5070);var gradient=__nested_webpack_require_543637__(9144);var shaders=__nested_webpack_require_543637__(9054);var createShader=shaders.createShader;var createContourShader=shaders.createContourShader;var createPickShader=shaders.createPickShader;var createPickContourShader=shaders.createPickContourShader;var SURFACE_VERTEX_SIZE=4*(4+3+3);var IDENTITY=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];var QUAD=[[0,0],[0,1],[1,0],[1,1],[1,0],[0,1]];var PERMUTATIONS=[[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]];(function(){for(var i=0;i<3;++i){var p=PERMUTATIONS[i];var u=(i+1)%3;var v=(i+2)%3;p[u+0]=1;p[v+3]=1;p[i+6]=1;}})();function SurfacePickResult(position,index,uv,level,dataCoordinate){this.position=position;this.index=index;this.uv=uv;this.level=level;this.dataCoordinate=dataCoordinate;}var N_COLORS=256;function SurfacePlot(gl,shape,bounds,shader,pickShader,coordinates,vao,colorMap,contourShader,contourPickShader,contourBuffer,contourVAO,dynamicBuffer,dynamicVAO,objectOffset){this.gl=gl;this.shape=shape;this.bounds=bounds;this.objectOffset=objectOffset;this.intensityBounds=[];this._shader=shader;this._pickShader=pickShader;this._coordinateBuffer=coordinates;this._vao=vao;this._colorMap=colorMap;this._contourShader=contourShader;this._contourPickShader=contourPickShader;this._contourBuffer=contourBuffer;this._contourVAO=contourVAO;this._contourOffsets=[[],[],[]];this._contourCounts=[[],[],[]];this._vertexCount=0;this._pickResult=new SurfacePickResult([0,0,0],[0,0],[0,0],[0,0,0],[0,0,0]);this._dynamicBuffer=dynamicBuffer;this._dynamicVAO=dynamicVAO;this._dynamicOffsets=[0,0,0];this._dynamicCounts=[0,0,0];this.contourWidth=[1,1,1];this.contourLevels=[[1],[1],[1]];this.contourTint=[0,0,0];this.contourColor=[[0.5,0.5,0.5,1],[0.5,0.5,0.5,1],[0.5,0.5,0.5,1]];this.showContour=true;this.showSurface=true;this.enableHighlight=[true,true,true];this.highlightColor=[[0,0,0,1],[0,0,0,1],[0,0,0,1]];this.highlightTint=[1,1,1];this.highlightLevel=[-1,-1,-1];// Dynamic contour options
this.enableDynamic=[true,true,true];this.dynamicLevel=[NaN,NaN,NaN];this.dynamicColor=[[0,0,0,1],[0,0,0,1],[0,0,0,1]];this.dynamicTint=[1,1,1];this.dynamicWidth=[1,1,1];this.axesBounds=[[Infinity,Infinity,Infinity],[-Infinity,-Infinity,-Infinity]];this.surfaceProject=[false,false,false];this.contourProject=[[false,false,false],[false,false,false],[false,false,false]];this.colorBounds=[false,false];// Store xyz fields, need this for picking
this._field=[ndarray(pool.mallocFloat(1024),[0,0]),ndarray(pool.mallocFloat(1024),[0,0]),ndarray(pool.mallocFloat(1024),[0,0])];this.pickId=1;this.clipBounds=[[-Infinity,-Infinity,-Infinity],[Infinity,Infinity,Infinity]];this.snapToData=false;this.pixelRatio=1;this.opacity=1.0;this.lightPosition=[10,10000,0];this.ambientLight=0.8;this.diffuseLight=0.8;this.specularLight=2.0;this.roughness=0.5;this.fresnel=1.5;this.vertexColor=0;this.dirty=true;}var proto=SurfacePlot.prototype;proto.genColormap=function(name,opacityscale){var hasAlpha=false;var x=pack([colormap({colormap:name,nshades:N_COLORS,format:'rgba'}).map(function(c,i){var a=opacityscale?getOpacityFromScale(i/255.0,opacityscale):c[3];if(a<1)hasAlpha=true;return[c[0],c[1],c[2],255*a];})]);ops.divseq(x,255.0);this.hasAlphaScale=hasAlpha;return x;};proto.isTransparent=function(){return this.opacity<1||this.hasAlphaScale;};proto.isOpaque=function(){return!this.isTransparent();};proto.pickSlots=1;proto.setPickBase=function(id){this.pickId=id;};function getOpacityFromScale(ratio,opacityscale){// copied form gl-mesh3d
if(!opacityscale)return 1;if(!opacityscale.length)return 1;for(var i=0;i<opacityscale.length;++i){if(opacityscale.length<2)return 1;if(opacityscale[i][0]===ratio)return opacityscale[i][1];if(opacityscale[i][0]>ratio&&i>0){var d=(opacityscale[i][0]-ratio)/(opacityscale[i][0]-opacityscale[i-1][0]);return opacityscale[i][1]*(1-d)+d*opacityscale[i-1][1];}}return 1;}var ZERO_VEC=[0,0,0];var PROJECT_DATA={showSurface:false,showContour:false,projections:[IDENTITY.slice(),IDENTITY.slice(),IDENTITY.slice()],clipBounds:[[[0,0,0],[0,0,0]],[[0,0,0],[0,0,0]],[[0,0,0],[0,0,0]]]};function computeProjectionData(camera,obj){var i,j,k;// Compute cube properties
var cubeAxis=obj.axes&&obj.axes.lastCubeProps.axis||ZERO_VEC;var showSurface=obj.showSurface;var showContour=obj.showContour;for(i=0;i<3;++i){showSurface=showSurface||obj.surfaceProject[i];for(j=0;j<3;++j){showContour=showContour||obj.contourProject[i][j];}}for(i=0;i<3;++i){// Construct projection onto axis
var axisSquish=PROJECT_DATA.projections[i];for(j=0;j<16;++j){axisSquish[j]=0;}for(j=0;j<4;++j){axisSquish[5*j]=1;}axisSquish[5*i]=0;axisSquish[12+i]=obj.axesBounds[+(cubeAxis[i]>0)][i];multiply(axisSquish,camera.model,axisSquish);var nclipBounds=PROJECT_DATA.clipBounds[i];for(k=0;k<2;++k){for(j=0;j<3;++j){nclipBounds[k][j]=camera.clipBounds[k][j];}}nclipBounds[0][i]=-1e8;nclipBounds[1][i]=1e8;}PROJECT_DATA.showSurface=showSurface;PROJECT_DATA.showContour=showContour;return PROJECT_DATA;}var UNIFORMS={model:IDENTITY,view:IDENTITY,projection:IDENTITY,inverseModel:IDENTITY.slice(),lowerBound:[0,0,0],upperBound:[0,0,0],colorMap:0,clipBounds:[[0,0,0],[0,0,0]],height:0.0,contourTint:0,contourColor:[0,0,0,1],permutation:[1,0,0,0,1,0,0,0,1],zOffset:-1e-4,objectOffset:[0,0,0],kambient:1,kdiffuse:1,kspecular:1,lightPosition:[1000,1000,1000],eyePosition:[0,0,0],roughness:1,fresnel:1,opacity:1,vertexColor:0};var MATRIX_INVERSE=IDENTITY.slice();var DEFAULT_PERM=[1,0,0,0,1,0,0,0,1];function drawCore(params,transparent){params=params||{};var gl=this.gl;gl.disable(gl.CULL_FACE);this._colorMap.bind(0);var uniforms=UNIFORMS;uniforms.model=params.model||IDENTITY;uniforms.view=params.view||IDENTITY;uniforms.projection=params.projection||IDENTITY;uniforms.lowerBound=[this.bounds[0][0],this.bounds[0][1],this.colorBounds[0]||this.bounds[0][2]];uniforms.upperBound=[this.bounds[1][0],this.bounds[1][1],this.colorBounds[1]||this.bounds[1][2]];uniforms.objectOffset=this.objectOffset;uniforms.contourColor=this.contourColor[0];uniforms.inverseModel=invert(uniforms.inverseModel,uniforms.model);for(var i=0;i<2;++i){var clipClamped=uniforms.clipBounds[i];for(var j=0;j<3;++j){clipClamped[j]=Math.min(Math.max(this.clipBounds[i][j],-1e8),1e8);}}uniforms.kambient=this.ambientLight;uniforms.kdiffuse=this.diffuseLight;uniforms.kspecular=this.specularLight;uniforms.roughness=this.roughness;uniforms.fresnel=this.fresnel;uniforms.opacity=this.opacity;uniforms.height=0.0;uniforms.permutation=DEFAULT_PERM;uniforms.vertexColor=this.vertexColor;// Compute camera matrix inverse
var invCameraMatrix=MATRIX_INVERSE;multiply(invCameraMatrix,uniforms.view,uniforms.model);multiply(invCameraMatrix,uniforms.projection,invCameraMatrix);invert(invCameraMatrix,invCameraMatrix);for(i=0;i<3;++i){uniforms.eyePosition[i]=invCameraMatrix[12+i]/invCameraMatrix[15];}var w=invCameraMatrix[15];for(i=0;i<3;++i){w+=this.lightPosition[i]*invCameraMatrix[4*i+3];}for(i=0;i<3;++i){var s=invCameraMatrix[12+i];for(j=0;j<3;++j){s+=invCameraMatrix[4*j+i]*this.lightPosition[j];}uniforms.lightPosition[i]=s/w;}var projectData=computeProjectionData(uniforms,this);if(projectData.showSurface){// Set up uniforms
this._shader.bind();this._shader.uniforms=uniforms;// Draw it
this._vao.bind();if(this.showSurface&&this._vertexCount){this._vao.draw(gl.TRIANGLES,this._vertexCount);}// Draw projections of surface
for(i=0;i<3;++i){if(!this.surfaceProject[i]||!this.vertexCount){continue;}this._shader.uniforms.model=projectData.projections[i];this._shader.uniforms.clipBounds=projectData.clipBounds[i];this._vao.draw(gl.TRIANGLES,this._vertexCount);}this._vao.unbind();}if(projectData.showContour){var shader=this._contourShader;// Don't apply lighting to contours
uniforms.kambient=1.0;uniforms.kdiffuse=0.0;uniforms.kspecular=0.0;uniforms.opacity=1.0;shader.bind();shader.uniforms=uniforms;// Draw contour lines
var vao=this._contourVAO;vao.bind();// Draw contour levels
for(i=0;i<3;++i){shader.uniforms.permutation=PERMUTATIONS[i];gl.lineWidth(this.contourWidth[i]*this.pixelRatio);for(j=0;j<this.contourLevels[i].length;++j){if(j===this.highlightLevel[i]){shader.uniforms.contourColor=this.highlightColor[i];shader.uniforms.contourTint=this.highlightTint[i];}else if(j===0||j-1===this.highlightLevel[i]){shader.uniforms.contourColor=this.contourColor[i];shader.uniforms.contourTint=this.contourTint[i];}if(!this._contourCounts[i][j]){continue;}shader.uniforms.height=this.contourLevels[i][j];vao.draw(gl.LINES,this._contourCounts[i][j],this._contourOffsets[i][j]);}}// Draw projections of surface
for(i=0;i<3;++i){shader.uniforms.model=projectData.projections[i];shader.uniforms.clipBounds=projectData.clipBounds[i];for(j=0;j<3;++j){if(!this.contourProject[i][j]){continue;}shader.uniforms.permutation=PERMUTATIONS[j];gl.lineWidth(this.contourWidth[j]*this.pixelRatio);for(var k=0;k<this.contourLevels[j].length;++k){if(k===this.highlightLevel[j]){shader.uniforms.contourColor=this.highlightColor[j];shader.uniforms.contourTint=this.highlightTint[j];}else if(k===0||k-1===this.highlightLevel[j]){shader.uniforms.contourColor=this.contourColor[j];shader.uniforms.contourTint=this.contourTint[j];}if(!this._contourCounts[j][k]){continue;}shader.uniforms.height=this.contourLevels[j][k];vao.draw(gl.LINES,this._contourCounts[j][k],this._contourOffsets[j][k]);}}}vao.unbind();// Draw dynamic contours
vao=this._dynamicVAO;vao.bind();// Draw contour levels
for(i=0;i<3;++i){if(this._dynamicCounts[i]===0){continue;}shader.uniforms.model=uniforms.model;shader.uniforms.clipBounds=uniforms.clipBounds;shader.uniforms.permutation=PERMUTATIONS[i];gl.lineWidth(this.dynamicWidth[i]*this.pixelRatio);shader.uniforms.contourColor=this.dynamicColor[i];shader.uniforms.contourTint=this.dynamicTint[i];shader.uniforms.height=this.dynamicLevel[i];vao.draw(gl.LINES,this._dynamicCounts[i],this._dynamicOffsets[i]);for(j=0;j<3;++j){if(!this.contourProject[j][i]){continue;}shader.uniforms.model=projectData.projections[j];shader.uniforms.clipBounds=projectData.clipBounds[j];vao.draw(gl.LINES,this._dynamicCounts[i],this._dynamicOffsets[i]);}}vao.unbind();}}proto.draw=function(params){return drawCore.call(this,params,false);};proto.drawTransparent=function(params){return drawCore.call(this,params,true);};var PICK_UNIFORMS={model:IDENTITY,view:IDENTITY,projection:IDENTITY,inverseModel:IDENTITY,clipBounds:[[0,0,0],[0,0,0]],height:0.0,shape:[0,0],pickId:0,lowerBound:[0,0,0],upperBound:[0,0,0],zOffset:0.0,objectOffset:[0,0,0],permutation:[1,0,0,0,1,0,0,0,1],lightPosition:[0,0,0],eyePosition:[0,0,0]};proto.drawPick=function(params){params=params||{};var gl=this.gl;gl.disable(gl.CULL_FACE);var uniforms=PICK_UNIFORMS;uniforms.model=params.model||IDENTITY;uniforms.view=params.view||IDENTITY;uniforms.projection=params.projection||IDENTITY;uniforms.shape=this._field[2].shape;uniforms.pickId=this.pickId/255.0;uniforms.lowerBound=this.bounds[0];uniforms.upperBound=this.bounds[1];uniforms.objectOffset=this.objectOffset;uniforms.permutation=DEFAULT_PERM;for(var i=0;i<2;++i){var clipClamped=uniforms.clipBounds[i];for(var j=0;j<3;++j){clipClamped[j]=Math.min(Math.max(this.clipBounds[i][j],-1e8),1e8);}}var projectData=computeProjectionData(uniforms,this);if(projectData.showSurface){// Set up uniforms
this._pickShader.bind();this._pickShader.uniforms=uniforms;// Draw it
this._vao.bind();this._vao.draw(gl.TRIANGLES,this._vertexCount);// Draw projections of surface
for(i=0;i<3;++i){if(!this.surfaceProject[i]){continue;}this._pickShader.uniforms.model=projectData.projections[i];this._pickShader.uniforms.clipBounds=projectData.clipBounds[i];this._vao.draw(gl.TRIANGLES,this._vertexCount);}this._vao.unbind();}if(projectData.showContour){var shader=this._contourPickShader;shader.bind();shader.uniforms=uniforms;var vao=this._contourVAO;vao.bind();for(j=0;j<3;++j){gl.lineWidth(this.contourWidth[j]*this.pixelRatio);shader.uniforms.permutation=PERMUTATIONS[j];for(i=0;i<this.contourLevels[j].length;++i){if(this._contourCounts[j][i]){shader.uniforms.height=this.contourLevels[j][i];vao.draw(gl.LINES,this._contourCounts[j][i],this._contourOffsets[j][i]);}}}// Draw projections of surface
for(i=0;i<3;++i){shader.uniforms.model=projectData.projections[i];shader.uniforms.clipBounds=projectData.clipBounds[i];for(j=0;j<3;++j){if(!this.contourProject[i][j]){continue;}shader.uniforms.permutation=PERMUTATIONS[j];gl.lineWidth(this.contourWidth[j]*this.pixelRatio);for(var k=0;k<this.contourLevels[j].length;++k){if(this._contourCounts[j][k]){shader.uniforms.height=this.contourLevels[j][k];vao.draw(gl.LINES,this._contourCounts[j][k],this._contourOffsets[j][k]);}}}}vao.unbind();}};proto.pick=function(selection){if(!selection){return null;}if(selection.id!==this.pickId){return null;}var shape=this._field[2].shape;var result=this._pickResult;// Compute uv coordinate
var x=shape[0]*(selection.value[0]+(selection.value[2]>>4)/16.0)/255.0;var ix=Math.floor(x);var fx=x-ix;var y=shape[1]*(selection.value[1]+(selection.value[2]&15)/16.0)/255.0;var iy=Math.floor(y);var fy=y-iy;ix+=1;iy+=1;// Compute xyz coordinate
var pos=result.position;pos[0]=pos[1]=pos[2]=0;for(var dx=0;dx<2;++dx){var s=dx?fx:1.0-fx;for(var dy=0;dy<2;++dy){var t=dy?fy:1.0-fy;var r=ix+dx;var c=iy+dy;var w=s*t;for(var i=0;i<3;++i){pos[i]+=this._field[i].get(r,c)*w;}}}// Find closest level
var levelIndex=this._pickResult.level;for(var j=0;j<3;++j){levelIndex[j]=bsearch.le(this.contourLevels[j],pos[j]);if(levelIndex[j]<0){if(this.contourLevels[j].length>0){levelIndex[j]=0;}}else if(levelIndex[j]<this.contourLevels[j].length-1){var a=this.contourLevels[j][levelIndex[j]];var b=this.contourLevels[j][levelIndex[j]+1];if(Math.abs(a-pos[j])>Math.abs(b-pos[j])){levelIndex[j]+=1;}}}result.index[0]=fx<0.5?ix:ix+1;result.index[1]=fy<0.5?iy:iy+1;result.uv[0]=x/shape[0];result.uv[1]=y/shape[1];for(i=0;i<3;++i){result.dataCoordinate[i]=this._field[i].get(result.index[0],result.index[1]);}return result;};proto.padField=function(dstField,srcField){var srcShape=srcField.shape.slice();var dstShape=dstField.shape.slice();// Center
ops.assign(dstField.lo(1,1).hi(srcShape[0],srcShape[1]),srcField);// Edges
ops.assign(dstField.lo(1).hi(srcShape[0],1),srcField.hi(srcShape[0],1));ops.assign(dstField.lo(1,dstShape[1]-1).hi(srcShape[0],1),srcField.lo(0,srcShape[1]-1).hi(srcShape[0],1));ops.assign(dstField.lo(0,1).hi(1,srcShape[1]),srcField.hi(1));ops.assign(dstField.lo(dstShape[0]-1,1).hi(1,srcShape[1]),srcField.lo(srcShape[0]-1));// Corners
dstField.set(0,0,srcField.get(0,0));dstField.set(0,dstShape[1]-1,srcField.get(0,srcShape[1]-1));dstField.set(dstShape[0]-1,0,srcField.get(srcShape[0]-1,0));dstField.set(dstShape[0]-1,dstShape[1]-1,srcField.get(srcShape[0]-1,srcShape[1]-1));};function handleArray(param,ctor){if(Array.isArray(param)){return[ctor(param[0]),ctor(param[1]),ctor(param[2])];}return[ctor(param),ctor(param),ctor(param)];}function toColor(x){if(Array.isArray(x)){if(x.length===3){return[x[0],x[1],x[2],1];}return[x[0],x[1],x[2],x[3]];}return[0,0,0,1];}function handleColor(param){if(Array.isArray(param)){if(Array.isArray(param)){return[toColor(param[0]),toColor(param[1]),toColor(param[2])];}else{var c=toColor(param);return[c.slice(),c.slice(),c.slice()];}}}proto.update=function(params){params=params||{};this.objectOffset=params.objectOffset||this.objectOffset;this.dirty=true;if('contourWidth'in params){this.contourWidth=handleArray(params.contourWidth,Number);}if('showContour'in params){this.showContour=handleArray(params.showContour,Boolean);}if('showSurface'in params){this.showSurface=!!params.showSurface;}if('contourTint'in params){this.contourTint=handleArray(params.contourTint,Boolean);}if('contourColor'in params){this.contourColor=handleColor(params.contourColor);}if('contourProject'in params){this.contourProject=handleArray(params.contourProject,function(x){return handleArray(x,Boolean);});}if('surfaceProject'in params){this.surfaceProject=params.surfaceProject;}if('dynamicColor'in params){this.dynamicColor=handleColor(params.dynamicColor);}if('dynamicTint'in params){this.dynamicTint=handleArray(params.dynamicTint,Number);}if('dynamicWidth'in params){this.dynamicWidth=handleArray(params.dynamicWidth,Number);}if('opacity'in params){this.opacity=params.opacity;}if('opacityscale'in params){this.opacityscale=params.opacityscale;}if('colorBounds'in params){this.colorBounds=params.colorBounds;}if('vertexColor'in params){this.vertexColor=params.vertexColor?1:0;}if('colormap'in params){this._colorMap.setPixels(this.genColormap(params.colormap,this.opacityscale));}var field=params.field||params.coords&&params.coords[2]||null;var levelsChanged=false;if(!field){if(this._field[2].shape[0]||this._field[2].shape[2]){field=this._field[2].lo(1,1).hi(this._field[2].shape[0]-2,this._field[2].shape[1]-2);}else{field=this._field[2].hi(0,0);}}// Update field
if('field'in params||'coords'in params){var fsize=(field.shape[0]+2)*(field.shape[1]+2);// Resize if necessary
if(fsize>this._field[2].data.length){pool.freeFloat(this._field[2].data);this._field[2].data=pool.mallocFloat(bits.nextPow2(fsize));}// Pad field
this._field[2]=ndarray(this._field[2].data,[field.shape[0]+2,field.shape[1]+2]);this.padField(this._field[2],field);// Save shape of field
this.shape=field.shape.slice();var shape=this.shape;// Resize coordinate fields if necessary
for(var i=0;i<2;++i){if(this._field[2].size>this._field[i].data.length){pool.freeFloat(this._field[i].data);this._field[i].data=pool.mallocFloat(this._field[2].size);}this._field[i]=ndarray(this._field[i].data,[shape[0]+2,shape[1]+2]);}// Generate x/y coordinates
if(params.coords){var coords=params.coords;if(!Array.isArray(coords)||coords.length!==3){throw new Error('gl-surface: invalid coordinates for x/y');}for(i=0;i<2;++i){var coord=coords[i];for(j=0;j<2;++j){if(coord.shape[j]!==shape[j]){throw new Error('gl-surface: coords have incorrect shape');}}this.padField(this._field[i],coord);}}else if(params.ticks){var ticks=params.ticks;if(!Array.isArray(ticks)||ticks.length!==2){throw new Error('gl-surface: invalid ticks');}for(i=0;i<2;++i){var tick=ticks[i];if(Array.isArray(tick)||tick.length){tick=ndarray(tick);}if(tick.shape[0]!==shape[i]){throw new Error('gl-surface: invalid tick length');}// Make a copy view of the tick array
var tick2=ndarray(tick.data,shape);tick2.stride[i]=tick.stride[0];tick2.stride[i^1]=0;// Fill in field array
this.padField(this._field[i],tick2);}}else{for(i=0;i<2;++i){var offset=[0,0];offset[i]=1;this._field[i]=ndarray(this._field[i].data,[shape[0]+2,shape[1]+2],offset,0);}this._field[0].set(0,0,0);for(var j=0;j<shape[0];++j){this._field[0].set(j+1,0,j);}this._field[0].set(shape[0]+1,0,shape[0]-1);this._field[1].set(0,0,0);for(j=0;j<shape[1];++j){this._field[1].set(0,j+1,j);}this._field[1].set(0,shape[1]+1,shape[1]-1);}// Save shape
var fields=this._field;// Compute surface normals
var dfields=ndarray(pool.mallocFloat(fields[2].size*3*2),[3,shape[0]+2,shape[1]+2,2]);for(i=0;i<3;++i){gradient(dfields.pick(i),fields[i],'mirror');}var normals=ndarray(pool.mallocFloat(fields[2].size*3),[shape[0]+2,shape[1]+2,3]);for(i=0;i<shape[0]+2;++i){for(j=0;j<shape[1]+2;++j){var dxdu=dfields.get(0,i,j,0);var dxdv=dfields.get(0,i,j,1);var dydu=dfields.get(1,i,j,0);var dydv=dfields.get(1,i,j,1);var dzdu=dfields.get(2,i,j,0);var dzdv=dfields.get(2,i,j,1);var nx=dydu*dzdv-dydv*dzdu;var ny=dzdu*dxdv-dzdv*dxdu;var nz=dxdu*dydv-dxdv*dydu;var nl=Math.sqrt(nx*nx+ny*ny+nz*nz);if(nl<1e-8){nl=Math.max(Math.abs(nx),Math.abs(ny),Math.abs(nz));if(nl<1e-8){nz=1.0;ny=nx=0.0;nl=1.0;}else{nl=1.0/nl;}}else{nl=1.0/Math.sqrt(nl);}normals.set(i,j,0,nx*nl);normals.set(i,j,1,ny*nl);normals.set(i,j,2,nz*nl);}}pool.free(dfields.data);// Initialize surface
var lo=[Infinity,Infinity,Infinity];var hi=[-Infinity,-Infinity,-Infinity];var lo_intensity=Infinity;var hi_intensity=-Infinity;var count=(shape[0]-1)*(shape[1]-1)*6;var tverts=pool.mallocFloat(bits.nextPow2(10*count));var tptr=0;var vertexCount=0;for(i=0;i<shape[0]-1;++i){j_loop:for(j=0;j<shape[1]-1;++j){// Test for NaNs
for(var dx=0;dx<2;++dx){for(var dy=0;dy<2;++dy){for(var k=0;k<3;++k){var f=this._field[k].get(1+i+dx,1+j+dy);if(isNaN(f)||!isFinite(f)){continue j_loop;}}}}for(k=0;k<6;++k){var r=i+QUAD[k][0];var c=j+QUAD[k][1];var tx=this._field[0].get(r+1,c+1);var ty=this._field[1].get(r+1,c+1);f=this._field[2].get(r+1,c+1);nx=normals.get(r+1,c+1,0);ny=normals.get(r+1,c+1,1);nz=normals.get(r+1,c+1,2);if(params.intensity){vf=params.intensity.get(r,c);}var vf=params.intensity?params.intensity.get(r,c):f+this.objectOffset[2];tverts[tptr++]=r;tverts[tptr++]=c;tverts[tptr++]=tx;tverts[tptr++]=ty;tverts[tptr++]=f;tverts[tptr++]=0;tverts[tptr++]=vf;tverts[tptr++]=nx;tverts[tptr++]=ny;tverts[tptr++]=nz;lo[0]=Math.min(lo[0],tx+this.objectOffset[0]);lo[1]=Math.min(lo[1],ty+this.objectOffset[1]);lo[2]=Math.min(lo[2],f+this.objectOffset[2]);lo_intensity=Math.min(lo_intensity,vf);hi[0]=Math.max(hi[0],tx+this.objectOffset[0]);hi[1]=Math.max(hi[1],ty+this.objectOffset[1]);hi[2]=Math.max(hi[2],f+this.objectOffset[2]);hi_intensity=Math.max(hi_intensity,vf);vertexCount+=1;}}}if(params.intensityBounds){lo_intensity=+params.intensityBounds[0];hi_intensity=+params.intensityBounds[1];}// Scale all vertex intensities
for(i=6;i<tptr;i+=10){tverts[i]=(tverts[i]-lo_intensity)/(hi_intensity-lo_intensity);}this._vertexCount=vertexCount;this._coordinateBuffer.update(tverts.subarray(0,tptr));pool.freeFloat(tverts);pool.free(normals.data);// Update bounds
this.bounds=[lo,hi];// Save intensity
this.intensity=params.intensity||this._field[2];if(this.intensityBounds[0]!==lo_intensity||this.intensityBounds[1]!==hi_intensity){levelsChanged=true;}// Save intensity bound
this.intensityBounds=[lo_intensity,hi_intensity];}// Update level crossings
if('levels'in params){var levels=params.levels;if(!Array.isArray(levels[0])){levels=[[],[],levels];}else{levels=levels.slice();}for(i=0;i<3;++i){levels[i]=levels[i].slice();levels[i].sort(function(a,b){return a-b;});}for(i=0;i<3;++i){for(j=0;j<levels[i].length;++j){levels[i][j]-=this.objectOffset[i];}}change_test:for(i=0;i<3;++i){if(levels[i].length!==this.contourLevels[i].length){levelsChanged=true;break;}for(j=0;j<levels[i].length;++j){if(levels[i][j]!==this.contourLevels[i][j]){levelsChanged=true;break change_test;}}}this.contourLevels=levels;}if(levelsChanged){fields=this._field;shape=this.shape;// Update contour lines
var contourVerts=[];for(var dim=0;dim<3;++dim){var contourLevel=this.contourLevels[dim];var levelOffsets=[];var levelCounts=[];var parts=[0,0,0];for(i=0;i<contourLevel.length;++i){var graph=surfaceNets(this._field[dim],contourLevel[i]);levelOffsets.push(contourVerts.length/5|0);vertexCount=0;edge_loop:for(j=0;j<graph.cells.length;++j){var e=graph.cells[j];for(k=0;k<2;++k){var p=graph.positions[e[k]];var x=p[0];var ix=Math.floor(x)|0;var fx=x-ix;var y=p[1];var iy=Math.floor(y)|0;var fy=y-iy;var hole=false;axis_loop:for(var axis=0;axis<3;++axis){parts[axis]=0.0;var iu=(dim+axis+1)%3;for(dx=0;dx<2;++dx){var s=dx?fx:1.0-fx;r=Math.min(Math.max(ix+dx,0),shape[0])|0;for(dy=0;dy<2;++dy){var t=dy?fy:1.0-fy;c=Math.min(Math.max(iy+dy,0),shape[1])|0;if(axis<2){f=this._field[iu].get(r,c);}else{f=(this.intensity.get(r,c)-this.intensityBounds[0])/(this.intensityBounds[1]-this.intensityBounds[0]);}if(!isFinite(f)||isNaN(f)){hole=true;break axis_loop;}var w=s*t;parts[axis]+=w*f;}}}if(!hole){contourVerts.push(parts[0],parts[1],p[0],p[1],parts[2]);vertexCount+=1;}else{if(k>0){// If we already added first edge, pop off verts
for(var l=0;l<5;++l){contourVerts.pop();}vertexCount-=1;}continue edge_loop;}}}levelCounts.push(vertexCount);}// Store results
this._contourOffsets[dim]=levelOffsets;this._contourCounts[dim]=levelCounts;}var floatBuffer=pool.mallocFloat(contourVerts.length);for(i=0;i<contourVerts.length;++i){floatBuffer[i]=contourVerts[i];}this._contourBuffer.update(floatBuffer);pool.freeFloat(floatBuffer);}};proto.dispose=function(){this._shader.dispose();this._vao.dispose();this._coordinateBuffer.dispose();this._colorMap.dispose();this._contourBuffer.dispose();this._contourVAO.dispose();this._contourShader.dispose();this._contourPickShader.dispose();this._dynamicBuffer.dispose();this._dynamicVAO.dispose();for(var i=0;i<3;++i){pool.freeFloat(this._field[i].data);}};proto.highlight=function(selection){var i;if(!selection){this._dynamicCounts=[0,0,0];this.dyanamicLevel=[NaN,NaN,NaN];this.highlightLevel=[-1,-1,-1];return;}for(i=0;i<3;++i){if(this.enableHighlight[i]){this.highlightLevel[i]=selection.level[i];}else{this.highlightLevel[i]=-1;}}var levels;if(this.snapToData){levels=selection.dataCoordinate;}else{levels=selection.position;}for(i=0;i<3;++i){levels[i]-=this.objectOffset[i];}if((!this.enableDynamic[0]||levels[0]===this.dynamicLevel[0])&&(!this.enableDynamic[1]||levels[1]===this.dynamicLevel[1])&&(!this.enableDynamic[2]||levels[2]===this.dynamicLevel[2])){return;}var vertexCount=0;var shape=this.shape;var scratchBuffer=pool.mallocFloat(12*shape[0]*shape[1]);for(var d=0;d<3;++d){if(!this.enableDynamic[d]){this.dynamicLevel[d]=NaN;this._dynamicCounts[d]=0;continue;}this.dynamicLevel[d]=levels[d];var u=(d+1)%3;var v=(d+2)%3;var f=this._field[d];var g=this._field[u];var h=this._field[v];var graph=surfaceNets(f,levels[d]);var edges=graph.cells;var positions=graph.positions;this._dynamicOffsets[d]=vertexCount;for(i=0;i<edges.length;++i){var e=edges[i];for(var j=0;j<2;++j){var p=positions[e[j]];var x=+p[0];var ix=x|0;var jx=Math.min(ix+1,shape[0])|0;var fx=x-ix;var hx=1.0-fx;var y=+p[1];var iy=y|0;var jy=Math.min(iy+1,shape[1])|0;var fy=y-iy;var hy=1.0-fy;var w00=hx*hy;var w01=hx*fy;var w10=fx*hy;var w11=fx*fy;var cu=w00*g.get(ix,iy)+w01*g.get(ix,jy)+w10*g.get(jx,iy)+w11*g.get(jx,jy);var cv=w00*h.get(ix,iy)+w01*h.get(ix,jy)+w10*h.get(jx,iy)+w11*h.get(jx,jy);if(isNaN(cu)||isNaN(cv)){if(j){vertexCount-=1;}break;}scratchBuffer[2*vertexCount+0]=cu;scratchBuffer[2*vertexCount+1]=cv;vertexCount+=1;}}this._dynamicCounts[d]=vertexCount-this._dynamicOffsets[d];}this._dynamicBuffer.update(scratchBuffer.subarray(0,2*vertexCount));pool.freeFloat(scratchBuffer);};function createSurfacePlot(params){var gl=params.gl;var shader=createShader(gl);var pickShader=createPickShader(gl);var contourShader=createContourShader(gl);var contourPickShader=createPickContourShader(gl);var coordinateBuffer=createBuffer(gl);var vao=createVAO(gl,[{buffer:coordinateBuffer,size:4,stride:SURFACE_VERTEX_SIZE,offset:0},{buffer:coordinateBuffer,size:3,stride:SURFACE_VERTEX_SIZE,offset:16},{buffer:coordinateBuffer,size:3,stride:SURFACE_VERTEX_SIZE,offset:28}]);var contourBuffer=createBuffer(gl);var contourVAO=createVAO(gl,[{buffer:contourBuffer,size:4,stride:20,offset:0},{buffer:contourBuffer,size:1,stride:20,offset:16}]);var dynamicBuffer=createBuffer(gl);var dynamicVAO=createVAO(gl,[{buffer:dynamicBuffer,size:2,type:gl.FLOAT}]);var cmap=createTexture(gl,1,N_COLORS,gl.RGBA,gl.UNSIGNED_BYTE);cmap.minFilter=gl.LINEAR;cmap.magFilter=gl.LINEAR;var surface=new SurfacePlot(gl,[0,0],// shape
[[0,0,0],[0,0,0]],// bounds
shader,pickShader,coordinateBuffer,vao,cmap,contourShader,contourPickShader,contourBuffer,contourVAO,dynamicBuffer,dynamicVAO,[0,0,0]// objectOffset
);var nparams={levels:[[],[],[]]};for(var id in params){nparams[id]=params[id];}nparams.colormap=nparams.colormap||'jet';surface.update(nparams);return surface;}/***/},/***/8931:/***/function(module,__unused_webpack_exports,__nested_webpack_require_571544__){"use strict";var ndarray=__nested_webpack_require_571544__(5050);var ops=__nested_webpack_require_571544__(7498);var pool=__nested_webpack_require_571544__(5306);module.exports=createTexture2D;var linearTypes=null;var filterTypes=null;var wrapTypes=null;function lazyInitLinearTypes(gl){linearTypes=[gl.LINEAR,gl.NEAREST_MIPMAP_LINEAR,gl.LINEAR_MIPMAP_NEAREST,gl.LINEAR_MIPMAP_NEAREST];filterTypes=[gl.NEAREST,gl.LINEAR,gl.NEAREST_MIPMAP_NEAREST,gl.NEAREST_MIPMAP_LINEAR,gl.LINEAR_MIPMAP_NEAREST,gl.LINEAR_MIPMAP_LINEAR];wrapTypes=[gl.REPEAT,gl.CLAMP_TO_EDGE,gl.MIRRORED_REPEAT];}function acceptTextureDOM(obj){return'undefined'!=typeof HTMLCanvasElement&&obj instanceof HTMLCanvasElement||'undefined'!=typeof HTMLImageElement&&obj instanceof HTMLImageElement||'undefined'!=typeof HTMLVideoElement&&obj instanceof HTMLVideoElement||'undefined'!=typeof ImageData&&obj instanceof ImageData;}var convertFloatToUint8=function(out,inp){ops.muls(out,inp,255.0);};function reshapeTexture(tex,w,h){var gl=tex.gl;var maxSize=gl.getParameter(gl.MAX_TEXTURE_SIZE);if(w<0||w>maxSize||h<0||h>maxSize){throw new Error('gl-texture2d: Invalid texture size');}tex._shape=[w,h];tex.bind();gl.texImage2D(gl.TEXTURE_2D,0,tex.format,w,h,0,tex.format,tex.type,null);tex._mipLevels=[0];return tex;}function Texture2D(gl,handle,width,height,format,type){this.gl=gl;this.handle=handle;this.format=format;this.type=type;this._shape=[width,height];this._mipLevels=[0];this._magFilter=gl.NEAREST;this._minFilter=gl.NEAREST;this._wrapS=gl.CLAMP_TO_EDGE;this._wrapT=gl.CLAMP_TO_EDGE;this._anisoSamples=1;var parent=this;var wrapVector=[this._wrapS,this._wrapT];Object.defineProperties(wrapVector,[{get:function(){return parent._wrapS;},set:function(v){return parent.wrapS=v;}},{get:function(){return parent._wrapT;},set:function(v){return parent.wrapT=v;}}]);this._wrapVector=wrapVector;var shapeVector=[this._shape[0],this._shape[1]];Object.defineProperties(shapeVector,[{get:function(){return parent._shape[0];},set:function(v){return parent.width=v;}},{get:function(){return parent._shape[1];},set:function(v){return parent.height=v;}}]);this._shapeVector=shapeVector;}var proto=Texture2D.prototype;Object.defineProperties(proto,{minFilter:{get:function(){return this._minFilter;},set:function(v){this.bind();var gl=this.gl;if(this.type===gl.FLOAT&&linearTypes.indexOf(v)>=0){if(!gl.getExtension('OES_texture_float_linear')){v=gl.NEAREST;}}if(filterTypes.indexOf(v)<0){throw new Error('gl-texture2d: Unknown filter mode '+v);}gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,v);return this._minFilter=v;}},magFilter:{get:function(){return this._magFilter;},set:function(v){this.bind();var gl=this.gl;if(this.type===gl.FLOAT&&linearTypes.indexOf(v)>=0){if(!gl.getExtension('OES_texture_float_linear')){v=gl.NEAREST;}}if(filterTypes.indexOf(v)<0){throw new Error('gl-texture2d: Unknown filter mode '+v);}gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,v);return this._magFilter=v;}},mipSamples:{get:function(){return this._anisoSamples;},set:function(i){var psamples=this._anisoSamples;this._anisoSamples=Math.max(i,1)|0;if(psamples!==this._anisoSamples){var ext=this.gl.getExtension('EXT_texture_filter_anisotropic');if(ext){this.gl.texParameterf(this.gl.TEXTURE_2D,ext.TEXTURE_MAX_ANISOTROPY_EXT,this._anisoSamples);}}return this._anisoSamples;}},wrapS:{get:function(){return this._wrapS;},set:function(v){this.bind();if(wrapTypes.indexOf(v)<0){throw new Error('gl-texture2d: Unknown wrap mode '+v);}this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,v);return this._wrapS=v;}},wrapT:{get:function(){return this._wrapT;},set:function(v){this.bind();if(wrapTypes.indexOf(v)<0){throw new Error('gl-texture2d: Unknown wrap mode '+v);}this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,v);return this._wrapT=v;}},wrap:{get:function(){return this._wrapVector;},set:function(v){if(!Array.isArray(v)){v=[v,v];}if(v.length!==2){throw new Error('gl-texture2d: Must specify wrap mode for rows and columns');}for(var i=0;i<2;++i){if(wrapTypes.indexOf(v[i])<0){throw new Error('gl-texture2d: Unknown wrap mode '+v);}}this._wrapS=v[0];this._wrapT=v[1];var gl=this.gl;this.bind();gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,this._wrapS);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,this._wrapT);return v;}},shape:{get:function(){return this._shapeVector;},set:function(x){if(!Array.isArray(x)){x=[x|0,x|0];}else{if(x.length!==2){throw new Error('gl-texture2d: Invalid texture shape');}}reshapeTexture(this,x[0]|0,x[1]|0);return[x[0]|0,x[1]|0];}},width:{get:function(){return this._shape[0];},set:function(w){w=w|0;reshapeTexture(this,w,this._shape[1]);return w;}},height:{get:function(){return this._shape[1];},set:function(h){h=h|0;reshapeTexture(this,this._shape[0],h);return h;}}});proto.bind=function(unit){var gl=this.gl;if(unit!==undefined){gl.activeTexture(gl.TEXTURE0+(unit|0));}gl.bindTexture(gl.TEXTURE_2D,this.handle);if(unit!==undefined){return unit|0;}return gl.getParameter(gl.ACTIVE_TEXTURE)-gl.TEXTURE0;};proto.dispose=function(){this.gl.deleteTexture(this.handle);};proto.generateMipmap=function(){this.bind();this.gl.generateMipmap(this.gl.TEXTURE_2D);//Update mip levels
var l=Math.min(this._shape[0],this._shape[1]);for(var i=0;l>0;++i,l>>>=1){if(this._mipLevels.indexOf(i)<0){this._mipLevels.push(i);}}};proto.setPixels=function(data,x_off,y_off,mip_level){var gl=this.gl;this.bind();if(Array.isArray(x_off)){mip_level=y_off;y_off=x_off[1]|0;x_off=x_off[0]|0;}else{x_off=x_off||0;y_off=y_off||0;}mip_level=mip_level||0;var directData=acceptTextureDOM(data)?data:data.raw;if(directData){var needsMip=this._mipLevels.indexOf(mip_level)<0;if(needsMip){gl.texImage2D(gl.TEXTURE_2D,0,this.format,this.format,this.type,directData);this._mipLevels.push(mip_level);}else{gl.texSubImage2D(gl.TEXTURE_2D,mip_level,x_off,y_off,this.format,this.type,directData);}}else if(data.shape&&data.stride&&data.data){if(data.shape.length<2||x_off+data.shape[1]>this._shape[1]>>>mip_level||y_off+data.shape[0]>this._shape[0]>>>mip_level||x_off<0||y_off<0){throw new Error('gl-texture2d: Texture dimensions are out of bounds');}texSubImageArray(gl,x_off,y_off,mip_level,this.format,this.type,this._mipLevels,data);}else{throw new Error('gl-texture2d: Unsupported data type');}};function isPacked(shape,stride){if(shape.length===3){return stride[2]===1&&stride[1]===shape[0]*shape[2]&&stride[0]===shape[2];}return stride[0]===1&&stride[1]===shape[0];}function texSubImageArray(gl,x_off,y_off,mip_level,cformat,ctype,mipLevels,array){var dtype=array.dtype;var shape=array.shape.slice();if(shape.length<2||shape.length>3){throw new Error('gl-texture2d: Invalid ndarray, must be 2d or 3d');}var type=0,format=0;var packed=isPacked(shape,array.stride.slice());if(dtype==='float32'){type=gl.FLOAT;}else if(dtype==='float64'){type=gl.FLOAT;packed=false;dtype='float32';}else if(dtype==='uint8'){type=gl.UNSIGNED_BYTE;}else{type=gl.UNSIGNED_BYTE;packed=false;dtype='uint8';}var channels=1;if(shape.length===2){format=gl.LUMINANCE;shape=[shape[0],shape[1],1];array=ndarray(array.data,shape,[array.stride[0],array.stride[1],1],array.offset);}else if(shape.length===3){if(shape[2]===1){format=gl.ALPHA;}else if(shape[2]===2){format=gl.LUMINANCE_ALPHA;}else if(shape[2]===3){format=gl.RGB;}else if(shape[2]===4){format=gl.RGBA;}else{throw new Error('gl-texture2d: Invalid shape for pixel coords');}channels=shape[2];}else{throw new Error('gl-texture2d: Invalid shape for texture');}//For 1-channel textures allow conversion between formats
if((format===gl.LUMINANCE||format===gl.ALPHA)&&(cformat===gl.LUMINANCE||cformat===gl.ALPHA)){format=cformat;}if(format!==cformat){throw new Error('gl-texture2d: Incompatible texture format for setPixels');}var size=array.size;var needsMip=mipLevels.indexOf(mip_level)<0;if(needsMip){mipLevels.push(mip_level);}if(type===ctype&&packed){//Array data types are compatible, can directly copy into texture
if(array.offset===0&&array.data.length===size){if(needsMip){gl.texImage2D(gl.TEXTURE_2D,mip_level,cformat,shape[0],shape[1],0,cformat,ctype,array.data);}else{gl.texSubImage2D(gl.TEXTURE_2D,mip_level,x_off,y_off,shape[0],shape[1],cformat,ctype,array.data);}}else{if(needsMip){gl.texImage2D(gl.TEXTURE_2D,mip_level,cformat,shape[0],shape[1],0,cformat,ctype,array.data.subarray(array.offset,array.offset+size));}else{gl.texSubImage2D(gl.TEXTURE_2D,mip_level,x_off,y_off,shape[0],shape[1],cformat,ctype,array.data.subarray(array.offset,array.offset+size));}}}else{//Need to do type conversion to pack data into buffer
var pack_buffer;if(ctype===gl.FLOAT){pack_buffer=pool.mallocFloat32(size);}else{pack_buffer=pool.mallocUint8(size);}var pack_view=ndarray(pack_buffer,shape,[shape[2],shape[2]*shape[0],1]);if(type===gl.FLOAT&&ctype===gl.UNSIGNED_BYTE){convertFloatToUint8(pack_view,array);}else{ops.assign(pack_view,array);}if(needsMip){gl.texImage2D(gl.TEXTURE_2D,mip_level,cformat,shape[0],shape[1],0,cformat,ctype,pack_buffer.subarray(0,size));}else{gl.texSubImage2D(gl.TEXTURE_2D,mip_level,x_off,y_off,shape[0],shape[1],cformat,ctype,pack_buffer.subarray(0,size));}if(ctype===gl.FLOAT){pool.freeFloat32(pack_buffer);}else{pool.freeUint8(pack_buffer);}}}function initTexture(gl){var tex=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,tex);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);return tex;}function createTextureShape(gl,width,height,format,type){var maxTextureSize=gl.getParameter(gl.MAX_TEXTURE_SIZE);if(width<0||width>maxTextureSize||height<0||height>maxTextureSize){throw new Error('gl-texture2d: Invalid texture shape');}if(type===gl.FLOAT&&!gl.getExtension('OES_texture_float')){throw new Error('gl-texture2d: Floating point textures not supported on this platform');}var tex=initTexture(gl);gl.texImage2D(gl.TEXTURE_2D,0,format,width,height,0,format,type,null);return new Texture2D(gl,tex,width,height,format,type);}function createTextureDOM(gl,directData,width,height,format,type){var tex=initTexture(gl);gl.texImage2D(gl.TEXTURE_2D,0,format,format,type,directData);return new Texture2D(gl,tex,width,height,format,type);}//Creates a texture from an ndarray
function createTextureArray(gl,array){var dtype=array.dtype;var shape=array.shape.slice();var maxSize=gl.getParameter(gl.MAX_TEXTURE_SIZE);if(shape[0]<0||shape[0]>maxSize||shape[1]<0||shape[1]>maxSize){throw new Error('gl-texture2d: Invalid texture size');}var packed=isPacked(shape,array.stride.slice());var type=0;if(dtype==='float32'){type=gl.FLOAT;}else if(dtype==='float64'){type=gl.FLOAT;packed=false;dtype='float32';}else if(dtype==='uint8'){type=gl.UNSIGNED_BYTE;}else{type=gl.UNSIGNED_BYTE;packed=false;dtype='uint8';}var format=0;if(shape.length===2){format=gl.LUMINANCE;shape=[shape[0],shape[1],1];array=ndarray(array.data,shape,[array.stride[0],array.stride[1],1],array.offset);}else if(shape.length===3){if(shape[2]===1){format=gl.ALPHA;}else if(shape[2]===2){format=gl.LUMINANCE_ALPHA;}else if(shape[2]===3){format=gl.RGB;}else if(shape[2]===4){format=gl.RGBA;}else{throw new Error('gl-texture2d: Invalid shape for pixel coords');}}else{throw new Error('gl-texture2d: Invalid shape for texture');}if(type===gl.FLOAT&&!gl.getExtension('OES_texture_float')){type=gl.UNSIGNED_BYTE;packed=false;}var buffer,buf_store;var size=array.size;if(!packed){var stride=[shape[2],shape[2]*shape[0],1];buf_store=pool.malloc(size,dtype);var buf_array=ndarray(buf_store,shape,stride,0);if((dtype==='float32'||dtype==='float64')&&type===gl.UNSIGNED_BYTE){convertFloatToUint8(buf_array,array);}else{ops.assign(buf_array,array);}buffer=buf_store.subarray(0,size);}else if(array.offset===0&&array.data.length===size){buffer=array.data;}else{buffer=array.data.subarray(array.offset,array.offset+size);}var tex=initTexture(gl);gl.texImage2D(gl.TEXTURE_2D,0,format,shape[0],shape[1],0,format,type,buffer);if(!packed){pool.free(buf_store);}return new Texture2D(gl,tex,shape[0],shape[1],format,type);}function createTexture2D(gl){if(arguments.length<=1){throw new Error('gl-texture2d: Missing arguments for texture2d constructor');}if(!linearTypes){lazyInitLinearTypes(gl);}if(typeof arguments[1]==='number'){return createTextureShape(gl,arguments[1],arguments[2],arguments[3]||gl.RGBA,arguments[4]||gl.UNSIGNED_BYTE);}if(Array.isArray(arguments[1])){return createTextureShape(gl,arguments[1][0]|0,arguments[1][1]|0,arguments[2]||gl.RGBA,arguments[3]||gl.UNSIGNED_BYTE);}if(typeof arguments[1]==='object'){var obj=arguments[1];var directData=acceptTextureDOM(obj)?obj:obj.raw;if(directData){return createTextureDOM(gl,directData,obj.width|0,obj.height|0,arguments[2]||gl.RGBA,arguments[3]||gl.UNSIGNED_BYTE);}else if(obj.shape&&obj.data&&obj.stride){return createTextureArray(gl,obj);}}throw new Error('gl-texture2d: Invalid arguments for texture2d constructor');}/***/},/***/3056:/***/function(module){"use strict";function doBind(gl,elements,attributes){if(elements){elements.bind();}else{gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,null);}var nattribs=gl.getParameter(gl.MAX_VERTEX_ATTRIBS)|0;if(attributes){if(attributes.length>nattribs){throw new Error("gl-vao: Too many vertex attributes");}for(var i=0;i<attributes.length;++i){var attrib=attributes[i];if(attrib.buffer){var buffer=attrib.buffer;var size=attrib.size||4;var type=attrib.type||gl.FLOAT;var normalized=!!attrib.normalized;var stride=attrib.stride||0;var offset=attrib.offset||0;buffer.bind();gl.enableVertexAttribArray(i);gl.vertexAttribPointer(i,size,type,normalized,stride,offset);}else{if(typeof attrib==="number"){gl.vertexAttrib1f(i,attrib);}else if(attrib.length===1){gl.vertexAttrib1f(i,attrib[0]);}else if(attrib.length===2){gl.vertexAttrib2f(i,attrib[0],attrib[1]);}else if(attrib.length===3){gl.vertexAttrib3f(i,attrib[0],attrib[1],attrib[2]);}else if(attrib.length===4){gl.vertexAttrib4f(i,attrib[0],attrib[1],attrib[2],attrib[3]);}else{throw new Error("gl-vao: Invalid vertex attribute");}gl.disableVertexAttribArray(i);}}for(;i<nattribs;++i){gl.disableVertexAttribArray(i);}}else{gl.bindBuffer(gl.ARRAY_BUFFER,null);for(var i=0;i<nattribs;++i){gl.disableVertexAttribArray(i);}}}module.exports=doBind;/***/},/***/7220:/***/function(module,__unused_webpack_exports,__nested_webpack_require_585871__){"use strict";var bindAttribs=__nested_webpack_require_585871__(3056);function VAOEmulated(gl){this.gl=gl;this._elements=null;this._attributes=null;this._elementsType=gl.UNSIGNED_SHORT;}VAOEmulated.prototype.bind=function(){bindAttribs(this.gl,this._elements,this._attributes);};VAOEmulated.prototype.update=function(attributes,elements,elementsType){this._elements=elements;this._attributes=attributes;this._elementsType=elementsType||this.gl.UNSIGNED_SHORT;};VAOEmulated.prototype.dispose=function(){};VAOEmulated.prototype.unbind=function(){};VAOEmulated.prototype.draw=function(mode,count,offset){offset=offset||0;var gl=this.gl;if(this._elements){gl.drawElements(mode,count,this._elementsType,offset);}else{gl.drawArrays(mode,offset,count);}};function createVAOEmulated(gl){return new VAOEmulated(gl);}module.exports=createVAOEmulated;/***/},/***/3778:/***/function(module,__unused_webpack_exports,__nested_webpack_require_586780__){"use strict";var bindAttribs=__nested_webpack_require_586780__(3056);function VertexAttribute(location,dimension,a,b,c,d){this.location=location;this.dimension=dimension;this.a=a;this.b=b;this.c=c;this.d=d;}VertexAttribute.prototype.bind=function(gl){switch(this.dimension){case 1:gl.vertexAttrib1f(this.location,this.a);break;case 2:gl.vertexAttrib2f(this.location,this.a,this.b);break;case 3:gl.vertexAttrib3f(this.location,this.a,this.b,this.c);break;case 4:gl.vertexAttrib4f(this.location,this.a,this.b,this.c,this.d);break;}};function VAONative(gl,ext,handle){this.gl=gl;this._ext=ext;this.handle=handle;this._attribs=[];this._useElements=false;this._elementsType=gl.UNSIGNED_SHORT;}VAONative.prototype.bind=function(){this._ext.bindVertexArrayOES(this.handle);for(var i=0;i<this._attribs.length;++i){this._attribs[i].bind(this.gl);}};VAONative.prototype.unbind=function(){this._ext.bindVertexArrayOES(null);};VAONative.prototype.dispose=function(){this._ext.deleteVertexArrayOES(this.handle);};VAONative.prototype.update=function(attributes,elements,elementsType){this.bind();bindAttribs(this.gl,elements,attributes);this.unbind();this._attribs.length=0;if(attributes)for(var i=0;i<attributes.length;++i){var a=attributes[i];if(typeof a==="number"){this._attribs.push(new VertexAttribute(i,1,a));}else if(Array.isArray(a)){this._attribs.push(new VertexAttribute(i,a.length,a[0],a[1],a[2],a[3]));}}this._useElements=!!elements;this._elementsType=elementsType||this.gl.UNSIGNED_SHORT;};VAONative.prototype.draw=function(mode,count,offset){offset=offset||0;var gl=this.gl;if(this._useElements){gl.drawElements(mode,count,this._elementsType,offset);}else{gl.drawArrays(mode,offset,count);}};function createVAONative(gl,ext){return new VAONative(gl,ext,ext.createVertexArrayOES());}module.exports=createVAONative;/***/},/***/2944:/***/function(module,__unused_webpack_exports,__nested_webpack_require_588664__){"use strict";var createVAONative=__nested_webpack_require_588664__(3778);var createVAOEmulated=__nested_webpack_require_588664__(7220);function ExtensionShim(gl){this.bindVertexArrayOES=gl.bindVertexArray.bind(gl);this.createVertexArrayOES=gl.createVertexArray.bind(gl);this.deleteVertexArrayOES=gl.deleteVertexArray.bind(gl);}function createVAO(gl,attributes,elements,elementsType){var ext=gl.createVertexArray?new ExtensionShim(gl):gl.getExtension('OES_vertex_array_object');var vao;if(ext){vao=createVAONative(gl,ext);}else{vao=createVAOEmulated(gl);}vao.update(attributes,elements,elementsType);return vao;}module.exports=createVAO;/***/},/***/2598:/***/function(module){module.exports=add;/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */function add(out,a,b){out[0]=a[0]+b[0];out[1]=a[1]+b[1];out[2]=a[2]+b[2];return out;}/***/},/***/5879:/***/function(module,__unused_webpack_exports,__nested_webpack_require_589668__){module.exports=angle;var fromValues=__nested_webpack_require_589668__(5415);var normalize=__nested_webpack_require_589668__(899);var dot=__nested_webpack_require_589668__(9305);/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */function angle(a,b){var tempA=fromValues(a[0],a[1],a[2]);var tempB=fromValues(b[0],b[1],b[2]);normalize(tempA,tempA);normalize(tempB,tempB);var cosine=dot(tempA,tempB);if(cosine>1.0){return 0;}else{return Math.acos(cosine);}}/***/},/***/8827:/***/function(module){module.exports=ceil;/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */function ceil(out,a){out[0]=Math.ceil(a[0]);out[1]=Math.ceil(a[1]);out[2]=Math.ceil(a[2]);return out;}/***/},/***/7622:/***/function(module){module.exports=clone;/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */function clone(a){var out=new Float32Array(3);out[0]=a[0];out[1]=a[1];out[2]=a[2];return out;}/***/},/***/8782:/***/function(module){module.exports=copy;/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */function copy(out,a){out[0]=a[0];out[1]=a[1];out[2]=a[2];return out;}/***/},/***/8501:/***/function(module){module.exports=create;/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */function create(){var out=new Float32Array(3);out[0]=0;out[1]=0;out[2]=0;return out;}/***/},/***/903:/***/function(module){module.exports=cross;/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */function cross(out,a,b){var ax=a[0],ay=a[1],az=a[2],bx=b[0],by=b[1],bz=b[2];out[0]=ay*bz-az*by;out[1]=az*bx-ax*bz;out[2]=ax*by-ay*bx;return out;}/***/},/***/5981:/***/function(module,__unused_webpack_exports,__nested_webpack_require_591790__){module.exports=__nested_webpack_require_591790__(8288);/***/},/***/8288:/***/function(module){module.exports=distance;/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */function distance(a,b){var x=b[0]-a[0],y=b[1]-a[1],z=b[2]-a[2];return Math.sqrt(x*x+y*y+z*z);}/***/},/***/8629:/***/function(module,__unused_webpack_exports,__nested_webpack_require_592259__){module.exports=__nested_webpack_require_592259__(7979);/***/},/***/7979:/***/function(module){module.exports=divide;/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */function divide(out,a,b){out[0]=a[0]/b[0];out[1]=a[1]/b[1];out[2]=a[2]/b[2];return out;}/***/},/***/9305:/***/function(module){module.exports=dot;/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */function dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];}/***/},/***/154:/***/function(module){module.exports=0.000001;/***/},/***/4932:/***/function(module,__unused_webpack_exports,__nested_webpack_require_593054__){module.exports=equals;var EPSILON=__nested_webpack_require_593054__(154);/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */function equals(a,b){var a0=a[0];var a1=a[1];var a2=a[2];var b0=b[0];var b1=b[1];var b2=b[2];return Math.abs(a0-b0)<=EPSILON*Math.max(1.0,Math.abs(a0),Math.abs(b0))&&Math.abs(a1-b1)<=EPSILON*Math.max(1.0,Math.abs(a1),Math.abs(b1))&&Math.abs(a2-b2)<=EPSILON*Math.max(1.0,Math.abs(a2),Math.abs(b2));}/***/},/***/5777:/***/function(module){module.exports=exactEquals;/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */function exactEquals(a,b){return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2];}/***/},/***/3306:/***/function(module){module.exports=floor;/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */function floor(out,a){out[0]=Math.floor(a[0]);out[1]=Math.floor(a[1]);out[2]=Math.floor(a[2]);return out;}/***/},/***/7447:/***/function(module,__unused_webpack_exports,__nested_webpack_require_594470__){module.exports=forEach;var vec=__nested_webpack_require_594470__(8501)();/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */function forEach(a,stride,offset,count,fn,arg){var i,l;if(!stride){stride=3;}if(!offset){offset=0;}if(count){l=Math.min(count*stride+offset,a.length);}else{l=a.length;}for(i=offset;i<l;i+=stride){vec[0]=a[i];vec[1]=a[i+1];vec[2]=a[i+2];fn(vec,vec,arg);a[i]=vec[0];a[i+1]=vec[1];a[i+2]=vec[2];}return a;}/***/},/***/5415:/***/function(module){module.exports=fromValues;/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */function fromValues(x,y,z){var out=new Float32Array(3);out[0]=x;out[1]=y;out[2]=z;return out;}/***/},/***/2858:/***/function(module,__unused_webpack_exports,__nested_webpack_require_595834__){module.exports={EPSILON:__nested_webpack_require_595834__(154),create:__nested_webpack_require_595834__(8501),clone:__nested_webpack_require_595834__(7622),angle:__nested_webpack_require_595834__(5879),fromValues:__nested_webpack_require_595834__(5415),copy:__nested_webpack_require_595834__(8782),set:__nested_webpack_require_595834__(831),equals:__nested_webpack_require_595834__(4932),exactEquals:__nested_webpack_require_595834__(5777),add:__nested_webpack_require_595834__(2598),subtract:__nested_webpack_require_595834__(911),sub:__nested_webpack_require_595834__(8921),multiply:__nested_webpack_require_595834__(105),mul:__nested_webpack_require_595834__(5733),divide:__nested_webpack_require_595834__(7979),div:__nested_webpack_require_595834__(8629),min:__nested_webpack_require_595834__(3605),max:__nested_webpack_require_595834__(1716),floor:__nested_webpack_require_595834__(3306),ceil:__nested_webpack_require_595834__(8827),round:__nested_webpack_require_595834__(1624),scale:__nested_webpack_require_595834__(5685),scaleAndAdd:__nested_webpack_require_595834__(6722),distance:__nested_webpack_require_595834__(8288),dist:__nested_webpack_require_595834__(5981),squaredDistance:__nested_webpack_require_595834__(6403),sqrDist:__nested_webpack_require_595834__(5294),length:__nested_webpack_require_595834__(4693),len:__nested_webpack_require_595834__(1468),squaredLength:__nested_webpack_require_595834__(4337),sqrLen:__nested_webpack_require_595834__(3303),negate:__nested_webpack_require_595834__(435),inverse:__nested_webpack_require_595834__(2073),normalize:__nested_webpack_require_595834__(899),dot:__nested_webpack_require_595834__(9305),cross:__nested_webpack_require_595834__(903),lerp:__nested_webpack_require_595834__(1868),random:__nested_webpack_require_595834__(6660),transformMat4:__nested_webpack_require_595834__(3255),transformMat3:__nested_webpack_require_595834__(9908),transformQuat:__nested_webpack_require_595834__(6568),rotateX:__nested_webpack_require_595834__(392),rotateY:__nested_webpack_require_595834__(3222),rotateZ:__nested_webpack_require_595834__(3388),forEach:__nested_webpack_require_595834__(7447)};/***/},/***/2073:/***/function(module){module.exports=inverse;/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */function inverse(out,a){out[0]=1.0/a[0];out[1]=1.0/a[1];out[2]=1.0/a[2];return out;}/***/},/***/1468:/***/function(module,__unused_webpack_exports,__nested_webpack_require_597746__){module.exports=__nested_webpack_require_597746__(4693);/***/},/***/4693:/***/function(module){module.exports=length;/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */function length(a){var x=a[0],y=a[1],z=a[2];return Math.sqrt(x*x+y*y+z*z);}/***/},/***/1868:/***/function(module){module.exports=lerp;/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */function lerp(out,a,b,t){var ax=a[0],ay=a[1],az=a[2];out[0]=ax+t*(b[0]-ax);out[1]=ay+t*(b[1]-ay);out[2]=az+t*(b[2]-az);return out;}/***/},/***/1716:/***/function(module){module.exports=max;/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */function max(out,a,b){out[0]=Math.max(a[0],b[0]);out[1]=Math.max(a[1],b[1]);out[2]=Math.max(a[2],b[2]);return out;}/***/},/***/3605:/***/function(module){module.exports=min;/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */function min(out,a,b){out[0]=Math.min(a[0],b[0]);out[1]=Math.min(a[1],b[1]);out[2]=Math.min(a[2],b[2]);return out;}/***/},/***/5733:/***/function(module,__unused_webpack_exports,__nested_webpack_require_599313__){module.exports=__nested_webpack_require_599313__(105);/***/},/***/105:/***/function(module){module.exports=multiply;/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */function multiply(out,a,b){out[0]=a[0]*b[0];out[1]=a[1]*b[1];out[2]=a[2]*b[2];return out;}/***/},/***/435:/***/function(module){module.exports=negate;/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */function negate(out,a){out[0]=-a[0];out[1]=-a[1];out[2]=-a[2];return out;}/***/},/***/899:/***/function(module){module.exports=normalize;/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */function normalize(out,a){var x=a[0],y=a[1],z=a[2];var len=x*x+y*y+z*z;if(len>0){//TODO: evaluate use of glm_invsqrt here?
len=1/Math.sqrt(len);out[0]=a[0]*len;out[1]=a[1]*len;out[2]=a[2]*len;}return out;}/***/},/***/6660:/***/function(module){module.exports=random;/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */function random(out,scale){scale=scale||1.0;var r=Math.random()*2.0*Math.PI;var z=Math.random()*2.0-1.0;var zScale=Math.sqrt(1.0-z*z)*scale;out[0]=Math.cos(r)*zScale;out[1]=Math.sin(r)*zScale;out[2]=z*scale;return out;}/***/},/***/392:/***/function(module){module.exports=rotateX;/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */function rotateX(out,a,b,c){var by=b[1];var bz=b[2];// Translate point to the origin
var py=a[1]-by;var pz=a[2]-bz;var sc=Math.sin(c);var cc=Math.cos(c);// perform rotation and translate to correct position
out[0]=a[0];out[1]=by+py*cc-pz*sc;out[2]=bz+py*sc+pz*cc;return out;}/***/},/***/3222:/***/function(module){module.exports=rotateY;/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */function rotateY(out,a,b,c){var bx=b[0];var bz=b[2];// translate point to the origin
var px=a[0]-bx;var pz=a[2]-bz;var sc=Math.sin(c);var cc=Math.cos(c);// perform rotation and translate to correct position
out[0]=bx+pz*sc+px*cc;out[1]=a[1];out[2]=bz+pz*cc-px*sc;return out;}/***/},/***/3388:/***/function(module){module.exports=rotateZ;/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */function rotateZ(out,a,b,c){var bx=b[0];var by=b[1];//Translate point to the origin
var px=a[0]-bx;var py=a[1]-by;var sc=Math.sin(c);var cc=Math.cos(c);// perform rotation and translate to correct position
out[0]=bx+px*cc-py*sc;out[1]=by+px*sc+py*cc;out[2]=a[2];return out;}/***/},/***/1624:/***/function(module){module.exports=round;/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */function round(out,a){out[0]=Math.round(a[0]);out[1]=Math.round(a[1]);out[2]=Math.round(a[2]);return out;}/***/},/***/5685:/***/function(module){module.exports=scale;/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */function scale(out,a,b){out[0]=a[0]*b;out[1]=a[1]*b;out[2]=a[2]*b;return out;}/***/},/***/6722:/***/function(module){module.exports=scaleAndAdd;/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */function scaleAndAdd(out,a,b,scale){out[0]=a[0]+b[0]*scale;out[1]=a[1]+b[1]*scale;out[2]=a[2]+b[2]*scale;return out;}/***/},/***/831:/***/function(module){module.exports=set;/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */function set(out,x,y,z){out[0]=x;out[1]=y;out[2]=z;return out;}/***/},/***/5294:/***/function(module,__unused_webpack_exports,__nested_webpack_require_604160__){module.exports=__nested_webpack_require_604160__(6403);/***/},/***/3303:/***/function(module,__unused_webpack_exports,__nested_webpack_require_604285__){module.exports=__nested_webpack_require_604285__(4337);/***/},/***/6403:/***/function(module){module.exports=squaredDistance;/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */function squaredDistance(a,b){var x=b[0]-a[0],y=b[1]-a[1],z=b[2]-a[2];return x*x+y*y+z*z;}/***/},/***/4337:/***/function(module){module.exports=squaredLength;/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */function squaredLength(a){var x=a[0],y=a[1],z=a[2];return x*x+y*y+z*z;}/***/},/***/8921:/***/function(module,__unused_webpack_exports,__nested_webpack_require_605063__){module.exports=__nested_webpack_require_605063__(911);/***/},/***/911:/***/function(module){module.exports=subtract;/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */function subtract(out,a,b){out[0]=a[0]-b[0];out[1]=a[1]-b[1];out[2]=a[2]-b[2];return out;}/***/},/***/9908:/***/function(module){module.exports=transformMat3;/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */function transformMat3(out,a,m){var x=a[0],y=a[1],z=a[2];out[0]=x*m[0]+y*m[3]+z*m[6];out[1]=x*m[1]+y*m[4]+z*m[7];out[2]=x*m[2]+y*m[5]+z*m[8];return out;}/***/},/***/3255:/***/function(module){module.exports=transformMat4;/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */function transformMat4(out,a,m){var x=a[0],y=a[1],z=a[2],w=m[3]*x+m[7]*y+m[11]*z+m[15];w=w||1.0;out[0]=(m[0]*x+m[4]*y+m[8]*z+m[12])/w;out[1]=(m[1]*x+m[5]*y+m[9]*z+m[13])/w;out[2]=(m[2]*x+m[6]*y+m[10]*z+m[14])/w;return out;}/***/},/***/6568:/***/function(module){module.exports=transformQuat;/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */function transformQuat(out,a,q){// benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations
var x=a[0],y=a[1],z=a[2],qx=q[0],qy=q[1],qz=q[2],qw=q[3],// calculate quat * vec
ix=qw*x+qy*z-qz*y,iy=qw*y+qz*x-qx*z,iz=qw*z+qx*y-qy*x,iw=-qx*x-qy*y-qz*z;// calculate result * inverse quat
out[0]=ix*qw+iw*-qx+iy*-qz-iz*-qy;out[1]=iy*qw+iw*-qy+iz*-qx-ix*-qz;out[2]=iz*qw+iw*-qz+ix*-qy-iy*-qx;return out;}/***/},/***/3433:/***/function(module){module.exports=add;/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */function add(out,a,b){out[0]=a[0]+b[0];out[1]=a[1]+b[1];out[2]=a[2]+b[2];out[3]=a[3]+b[3];return out;}/***/},/***/1413:/***/function(module){module.exports=clone;/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */function clone(a){var out=new Float32Array(4);out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];return out;}/***/},/***/3470:/***/function(module){module.exports=copy;/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */function copy(out,a){out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];return out;}/***/},/***/5313:/***/function(module){module.exports=create;/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */function create(){var out=new Float32Array(4);out[0]=0;out[1]=0;out[2]=0;out[3]=0;return out;}/***/},/***/5446:/***/function(module){module.exports=distance;/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */function distance(a,b){var x=b[0]-a[0],y=b[1]-a[1],z=b[2]-a[2],w=b[3]-a[3];return Math.sqrt(x*x+y*y+z*z+w*w);}/***/},/***/205:/***/function(module){module.exports=divide;/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */function divide(out,a,b){out[0]=a[0]/b[0];out[1]=a[1]/b[1];out[2]=a[2]/b[2];out[3]=a[3]/b[3];return out;}/***/},/***/4242:/***/function(module){module.exports=dot;/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */function dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3];}/***/},/***/5680:/***/function(module){module.exports=fromValues;/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */function fromValues(x,y,z,w){var out=new Float32Array(4);out[0]=x;out[1]=y;out[2]=z;out[3]=w;return out;}/***/},/***/4020:/***/function(module,__unused_webpack_exports,__nested_webpack_require_609729__){module.exports={create:__nested_webpack_require_609729__(5313),clone:__nested_webpack_require_609729__(1413),fromValues:__nested_webpack_require_609729__(5680),copy:__nested_webpack_require_609729__(3470),set:__nested_webpack_require_609729__(6453),add:__nested_webpack_require_609729__(3433),subtract:__nested_webpack_require_609729__(2705),multiply:__nested_webpack_require_609729__(746),divide:__nested_webpack_require_609729__(205),min:__nested_webpack_require_609729__(2170),max:__nested_webpack_require_609729__(3030),scale:__nested_webpack_require_609729__(5510),scaleAndAdd:__nested_webpack_require_609729__(4224),distance:__nested_webpack_require_609729__(5446),squaredDistance:__nested_webpack_require_609729__(1542),length:__nested_webpack_require_609729__(8177),squaredLength:__nested_webpack_require_609729__(9037),negate:__nested_webpack_require_609729__(6459),inverse:__nested_webpack_require_609729__(8057),normalize:__nested_webpack_require_609729__(381),dot:__nested_webpack_require_609729__(4242),lerp:__nested_webpack_require_609729__(8746),random:__nested_webpack_require_609729__(3770),transformMat4:__nested_webpack_require_609729__(6342),transformQuat:__nested_webpack_require_609729__(5022)};/***/},/***/8057:/***/function(module){module.exports=inverse;/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */function inverse(out,a){out[0]=1.0/a[0];out[1]=1.0/a[1];out[2]=1.0/a[2];out[3]=1.0/a[3];return out;}/***/},/***/8177:/***/function(module){module.exports=length;/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */function length(a){var x=a[0],y=a[1],z=a[2],w=a[3];return Math.sqrt(x*x+y*y+z*z+w*w);}/***/},/***/8746:/***/function(module){module.exports=lerp;/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */function lerp(out,a,b,t){var ax=a[0],ay=a[1],az=a[2],aw=a[3];out[0]=ax+t*(b[0]-ax);out[1]=ay+t*(b[1]-ay);out[2]=az+t*(b[2]-az);out[3]=aw+t*(b[3]-aw);return out;}/***/},/***/3030:/***/function(module){module.exports=max;/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */function max(out,a,b){out[0]=Math.max(a[0],b[0]);out[1]=Math.max(a[1],b[1]);out[2]=Math.max(a[2],b[2]);out[3]=Math.max(a[3],b[3]);return out;}/***/},/***/2170:/***/function(module){module.exports=min;/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */function min(out,a,b){out[0]=Math.min(a[0],b[0]);out[1]=Math.min(a[1],b[1]);out[2]=Math.min(a[2],b[2]);out[3]=Math.min(a[3],b[3]);return out;}/***/},/***/746:/***/function(module){module.exports=multiply;/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */function multiply(out,a,b){out[0]=a[0]*b[0];out[1]=a[1]*b[1];out[2]=a[2]*b[2];out[3]=a[3]*b[3];return out;}/***/},/***/6459:/***/function(module){module.exports=negate;/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */function negate(out,a){out[0]=-a[0];out[1]=-a[1];out[2]=-a[2];out[3]=-a[3];return out;}/***/},/***/381:/***/function(module){module.exports=normalize;/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */function normalize(out,a){var x=a[0],y=a[1],z=a[2],w=a[3];var len=x*x+y*y+z*z+w*w;if(len>0){len=1/Math.sqrt(len);out[0]=x*len;out[1]=y*len;out[2]=z*len;out[3]=w*len;}return out;}/***/},/***/3770:/***/function(module,__unused_webpack_exports,__nested_webpack_require_613555__){var vecNormalize=__nested_webpack_require_613555__(381);var vecScale=__nested_webpack_require_613555__(5510);module.exports=random;/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */function random(out,scale){scale=scale||1.0;// TODO: This is a pretty awful way of doing this. Find something better.
out[0]=Math.random();out[1]=Math.random();out[2]=Math.random();out[3]=Math.random();vecNormalize(out,out);vecScale(out,out,scale);return out;}/***/},/***/5510:/***/function(module){module.exports=scale;/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */function scale(out,a,b){out[0]=a[0]*b;out[1]=a[1]*b;out[2]=a[2]*b;out[3]=a[3]*b;return out;}/***/},/***/4224:/***/function(module){module.exports=scaleAndAdd;/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */function scaleAndAdd(out,a,b,scale){out[0]=a[0]+b[0]*scale;out[1]=a[1]+b[1]*scale;out[2]=a[2]+b[2]*scale;out[3]=a[3]+b[3]*scale;return out;}/***/},/***/6453:/***/function(module){module.exports=set;/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */function set(out,x,y,z,w){out[0]=x;out[1]=y;out[2]=z;out[3]=w;return out;}/***/},/***/1542:/***/function(module){module.exports=squaredDistance;/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */function squaredDistance(a,b){var x=b[0]-a[0],y=b[1]-a[1],z=b[2]-a[2],w=b[3]-a[3];return x*x+y*y+z*z+w*w;}/***/},/***/9037:/***/function(module){module.exports=squaredLength;/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */function squaredLength(a){var x=a[0],y=a[1],z=a[2],w=a[3];return x*x+y*y+z*z+w*w;}/***/},/***/2705:/***/function(module){module.exports=subtract;/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */function subtract(out,a,b){out[0]=a[0]-b[0];out[1]=a[1]-b[1];out[2]=a[2]-b[2];out[3]=a[3]-b[3];return out;}/***/},/***/6342:/***/function(module){module.exports=transformMat4;/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */function transformMat4(out,a,m){var x=a[0],y=a[1],z=a[2],w=a[3];out[0]=m[0]*x+m[4]*y+m[8]*z+m[12]*w;out[1]=m[1]*x+m[5]*y+m[9]*z+m[13]*w;out[2]=m[2]*x+m[6]*y+m[10]*z+m[14]*w;out[3]=m[3]*x+m[7]*y+m[11]*z+m[15]*w;return out;}/***/},/***/5022:/***/function(module){module.exports=transformQuat;/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */function transformQuat(out,a,q){var x=a[0],y=a[1],z=a[2],qx=q[0],qy=q[1],qz=q[2],qw=q[3],// calculate quat * vec
ix=qw*x+qy*z-qz*y,iy=qw*y+qz*x-qx*z,iz=qw*z+qx*y-qy*x,iw=-qx*x-qy*y-qz*z;// calculate result * inverse quat
out[0]=ix*qw+iw*-qx+iy*-qz-iz*-qy;out[1]=iy*qw+iw*-qy+iz*-qx-ix*-qz;out[2]=iz*qw+iw*-qz+ix*-qy-iy*-qx;out[3]=a[3];return out;}/***/},/***/9365:/***/function(module,__unused_webpack_exports,__nested_webpack_require_617604__){var tokenize=__nested_webpack_require_617604__(8096);var atob=__nested_webpack_require_617604__(7896);module.exports=getName;function getName(src){var tokens=Array.isArray(src)?src:tokenize(src);for(var i=0;i<tokens.length;i++){var token=tokens[i];if(token.type!=='preprocessor')continue;var match=token.data.match(/\#define\s+SHADER_NAME(_B64)?\s+(.+)$/);if(!match)continue;if(!match[2])continue;var b64=match[1];var name=match[2];return(b64?atob(name):name).trim();}}/***/},/***/3193:/***/function(module,__unused_webpack_exports,__nested_webpack_require_618129__){module.exports=tokenize;var literals100=__nested_webpack_require_618129__(399),operators=__nested_webpack_require_618129__(9746),builtins100=__nested_webpack_require_618129__(9525),literals300es=__nested_webpack_require_618129__(9458),builtins300es=__nested_webpack_require_618129__(3585);var NORMAL=999// <-- never emitted
,TOKEN=9999// <-- never emitted
,BLOCK_COMMENT=0,LINE_COMMENT=1,PREPROCESSOR=2,OPERATOR=3,INTEGER=4,FLOAT=5,IDENT=6,BUILTIN=7,KEYWORD=8,WHITESPACE=9,EOF=10,HEX=11;var map=['block-comment','line-comment','preprocessor','operator','integer','float','ident','builtin','keyword','whitespace','eof','integer'];function tokenize(opt){var i=0,total=0,mode=NORMAL,c,last,content=[],tokens=[],token_idx=0,token_offs=0,line=1,col=0,start=0,isnum=false,isoperator=false,input='',len;opt=opt||{};var allBuiltins=builtins100;var allLiterals=literals100;if(opt.version==='300 es'){allBuiltins=builtins300es;allLiterals=literals300es;}// cache by name
var builtinsDict={},literalsDict={};for(var i=0;i<allBuiltins.length;i++){builtinsDict[allBuiltins[i]]=true;}for(var i=0;i<allLiterals.length;i++){literalsDict[allLiterals[i]]=true;}return function(data){tokens=[];if(data!==null)return write(data);return end();};function token(data){if(data.length){tokens.push({type:map[mode],data:data,position:start,line:line,column:col});}}function write(chunk){i=0;if(chunk.toString)chunk=chunk.toString();input+=chunk.replace(/\r\n/g,'\n');len=input.length;var last;while(c=input[i],i<len){last=i;switch(mode){case BLOCK_COMMENT:i=block_comment();break;case LINE_COMMENT:i=line_comment();break;case PREPROCESSOR:i=preprocessor();break;case OPERATOR:i=operator();break;case INTEGER:i=integer();break;case HEX:i=hex();break;case FLOAT:i=decimal();break;case TOKEN:i=readtoken();break;case WHITESPACE:i=whitespace();break;case NORMAL:i=normal();break;}if(last!==i){switch(input[last]){case'\n':col=0;++line;break;default:++col;break;}}}total+=i;input=input.slice(i);return tokens;}function end(chunk){if(content.length){token(content.join(''));}mode=EOF;token('(eof)');return tokens;}function normal(){content=content.length?[]:content;if(last==='/'&&c==='*'){start=total+i-1;mode=BLOCK_COMMENT;last=c;return i+1;}if(last==='/'&&c==='/'){start=total+i-1;mode=LINE_COMMENT;last=c;return i+1;}if(c==='#'){mode=PREPROCESSOR;start=total+i;return i;}if(/\s/.test(c)){mode=WHITESPACE;start=total+i;return i;}isnum=/\d/.test(c);isoperator=/[^\w_]/.test(c);start=total+i;mode=isnum?INTEGER:isoperator?OPERATOR:TOKEN;return i;}function whitespace(){if(/[^\s]/g.test(c)){token(content.join(''));mode=NORMAL;return i;}content.push(c);last=c;return i+1;}function preprocessor(){if((c==='\r'||c==='\n')&&last!=='\\'){token(content.join(''));mode=NORMAL;return i;}content.push(c);last=c;return i+1;}function line_comment(){return preprocessor();}function block_comment(){if(c==='/'&&last==='*'){content.push(c);token(content.join(''));mode=NORMAL;return i+1;}content.push(c);last=c;return i+1;}function operator(){if(last==='.'&&/\d/.test(c)){mode=FLOAT;return i;}if(last==='/'&&c==='*'){mode=BLOCK_COMMENT;return i;}if(last==='/'&&c==='/'){mode=LINE_COMMENT;return i;}if(c==='.'&&content.length){while(determine_operator(content));mode=FLOAT;return i;}if(c===';'||c===')'||c==='('){if(content.length)while(determine_operator(content));token(c);mode=NORMAL;return i+1;}var is_composite_operator=content.length===2&&c!=='=';if(/[\w_\d\s]/.test(c)||is_composite_operator){while(determine_operator(content));mode=NORMAL;return i;}content.push(c);last=c;return i+1;}function determine_operator(buf){var j=0,idx,res;do{idx=operators.indexOf(buf.slice(0,buf.length+j).join(''));res=operators[idx];if(idx===-1){if(j--+buf.length>0)continue;res=buf.slice(0,1).join('');}token(res);start+=res.length;content=content.slice(res.length);return content.length;}while(1);}function hex(){if(/[^a-fA-F0-9]/.test(c)){token(content.join(''));mode=NORMAL;return i;}content.push(c);last=c;return i+1;}function integer(){if(c==='.'){content.push(c);mode=FLOAT;last=c;return i+1;}if(/[eE]/.test(c)){content.push(c);mode=FLOAT;last=c;return i+1;}if(c==='x'&&content.length===1&&content[0]==='0'){mode=HEX;content.push(c);last=c;return i+1;}if(/[^\d]/.test(c)){token(content.join(''));mode=NORMAL;return i;}content.push(c);last=c;return i+1;}function decimal(){if(c==='f'){content.push(c);last=c;i+=1;}if(/[eE]/.test(c)){content.push(c);last=c;return i+1;}if((c==='-'||c==='+')&&/[eE]/.test(last)){content.push(c);last=c;return i+1;}if(/[^\d]/.test(c)){token(content.join(''));mode=NORMAL;return i;}content.push(c);last=c;return i+1;}function readtoken(){if(/[^\d\w_]/.test(c)){var contentstr=content.join('');if(literalsDict[contentstr]){mode=KEYWORD;}else if(builtinsDict[contentstr]){mode=BUILTIN;}else{mode=IDENT;}token(content.join(''));mode=NORMAL;return i;}content.push(c);last=c;return i+1;}}/***/},/***/3585:/***/function(module,__unused_webpack_exports,__nested_webpack_require_623003__){// 300es builtins/reserved words that were previously valid in v100
var v100=__nested_webpack_require_623003__(9525);// The texture2D|Cube functions have been removed
// And the gl_ features are updated
v100=v100.slice().filter(function(b){return!/^(gl\_|texture)/.test(b);});module.exports=v100.concat([// the updated gl_ constants
'gl_VertexID','gl_InstanceID','gl_Position','gl_PointSize','gl_FragCoord','gl_FrontFacing','gl_FragDepth','gl_PointCoord','gl_MaxVertexAttribs','gl_MaxVertexUniformVectors','gl_MaxVertexOutputVectors','gl_MaxFragmentInputVectors','gl_MaxVertexTextureImageUnits','gl_MaxCombinedTextureImageUnits','gl_MaxTextureImageUnits','gl_MaxFragmentUniformVectors','gl_MaxDrawBuffers','gl_MinProgramTexelOffset','gl_MaxProgramTexelOffset','gl_DepthRangeParameters','gl_DepthRange'// other builtins
,'trunc','round','roundEven','isnan','isinf','floatBitsToInt','floatBitsToUint','intBitsToFloat','uintBitsToFloat','packSnorm2x16','unpackSnorm2x16','packUnorm2x16','unpackUnorm2x16','packHalf2x16','unpackHalf2x16','outerProduct','transpose','determinant','inverse','texture','textureSize','textureProj','textureLod','textureOffset','texelFetch','texelFetchOffset','textureProjOffset','textureLodOffset','textureProjLod','textureProjLodOffset','textureGrad','textureGradOffset','textureProjGrad','textureProjGradOffset']);/***/},/***/9525:/***/function(module){module.exports=[// Keep this list sorted
'abs','acos','all','any','asin','atan','ceil','clamp','cos','cross','dFdx','dFdy','degrees','distance','dot','equal','exp','exp2','faceforward','floor','fract','gl_BackColor','gl_BackLightModelProduct','gl_BackLightProduct','gl_BackMaterial','gl_BackSecondaryColor','gl_ClipPlane','gl_ClipVertex','gl_Color','gl_DepthRange','gl_DepthRangeParameters','gl_EyePlaneQ','gl_EyePlaneR','gl_EyePlaneS','gl_EyePlaneT','gl_Fog','gl_FogCoord','gl_FogFragCoord','gl_FogParameters','gl_FragColor','gl_FragCoord','gl_FragData','gl_FragDepth','gl_FragDepthEXT','gl_FrontColor','gl_FrontFacing','gl_FrontLightModelProduct','gl_FrontLightProduct','gl_FrontMaterial','gl_FrontSecondaryColor','gl_LightModel','gl_LightModelParameters','gl_LightModelProducts','gl_LightProducts','gl_LightSource','gl_LightSourceParameters','gl_MaterialParameters','gl_MaxClipPlanes','gl_MaxCombinedTextureImageUnits','gl_MaxDrawBuffers','gl_MaxFragmentUniformComponents','gl_MaxLights','gl_MaxTextureCoords','gl_MaxTextureImageUnits','gl_MaxTextureUnits','gl_MaxVaryingFloats','gl_MaxVertexAttribs','gl_MaxVertexTextureImageUnits','gl_MaxVertexUniformComponents','gl_ModelViewMatrix','gl_ModelViewMatrixInverse','gl_ModelViewMatrixInverseTranspose','gl_ModelViewMatrixTranspose','gl_ModelViewProjectionMatrix','gl_ModelViewProjectionMatrixInverse','gl_ModelViewProjectionMatrixInverseTranspose','gl_ModelViewProjectionMatrixTranspose','gl_MultiTexCoord0','gl_MultiTexCoord1','gl_MultiTexCoord2','gl_MultiTexCoord3','gl_MultiTexCoord4','gl_MultiTexCoord5','gl_MultiTexCoord6','gl_MultiTexCoord7','gl_Normal','gl_NormalMatrix','gl_NormalScale','gl_ObjectPlaneQ','gl_ObjectPlaneR','gl_ObjectPlaneS','gl_ObjectPlaneT','gl_Point','gl_PointCoord','gl_PointParameters','gl_PointSize','gl_Position','gl_ProjectionMatrix','gl_ProjectionMatrixInverse','gl_ProjectionMatrixInverseTranspose','gl_ProjectionMatrixTranspose','gl_SecondaryColor','gl_TexCoord','gl_TextureEnvColor','gl_TextureMatrix','gl_TextureMatrixInverse','gl_TextureMatrixInverseTranspose','gl_TextureMatrixTranspose','gl_Vertex','greaterThan','greaterThanEqual','inversesqrt','length','lessThan','lessThanEqual','log','log2','matrixCompMult','max','min','mix','mod','normalize','not','notEqual','pow','radians','reflect','refract','sign','sin','smoothstep','sqrt','step','tan','texture2D','texture2DLod','texture2DProj','texture2DProjLod','textureCube','textureCubeLod','texture2DLodEXT','texture2DProjLodEXT','textureCubeLodEXT','texture2DGradEXT','texture2DProjGradEXT','textureCubeGradEXT'];/***/},/***/9458:/***/function(module,__unused_webpack_exports,__nested_webpack_require_627009__){var v100=__nested_webpack_require_627009__(399);module.exports=v100.slice().concat(['layout','centroid','smooth','case','mat2x2','mat2x3','mat2x4','mat3x2','mat3x3','mat3x4','mat4x2','mat4x3','mat4x4','uvec2','uvec3','uvec4','samplerCubeShadow','sampler2DArray','sampler2DArrayShadow','isampler2D','isampler3D','isamplerCube','isampler2DArray','usampler2D','usampler3D','usamplerCube','usampler2DArray','coherent','restrict','readonly','writeonly','resource','atomic_uint','noperspective','patch','sample','subroutine','common','partition','active','filter','image1D','image2D','image3D','imageCube','iimage1D','iimage2D','iimage3D','iimageCube','uimage1D','uimage2D','uimage3D','uimageCube','image1DArray','image2DArray','iimage1DArray','iimage2DArray','uimage1DArray','uimage2DArray','image1DShadow','image2DShadow','image1DArrayShadow','image2DArrayShadow','imageBuffer','iimageBuffer','uimageBuffer','sampler1DArray','sampler1DArrayShadow','isampler1D','isampler1DArray','usampler1D','usampler1DArray','isampler2DRect','usampler2DRect','samplerBuffer','isamplerBuffer','usamplerBuffer','sampler2DMS','isampler2DMS','usampler2DMS','sampler2DMSArray','isampler2DMSArray','usampler2DMSArray']);/***/},/***/399:/***/function(module){module.exports=[// current
'precision','highp','mediump','lowp','attribute','const','uniform','varying','break','continue','do','for','while','if','else','in','out','inout','float','int','uint','void','bool','true','false','discard','return','mat2','mat3','mat4','vec2','vec3','vec4','ivec2','ivec3','ivec4','bvec2','bvec3','bvec4','sampler1D','sampler2D','sampler3D','samplerCube','sampler1DShadow','sampler2DShadow','struct'// future
,'asm','class','union','enum','typedef','template','this','packed','goto','switch','default','inline','noinline','volatile','public','static','extern','external','interface','long','short','double','half','fixed','unsigned','input','output','hvec2','hvec3','hvec4','dvec2','dvec3','dvec4','fvec2','fvec3','fvec4','sampler2DRect','sampler3DRect','sampler2DRectShadow','sizeof','cast','namespace','using'];/***/},/***/9746:/***/function(module){module.exports=['<<=','>>=','++','--','<<','>>','<=','>=','==','!=','&&','||','+=','-=','*=','/=','%=','&=','^^','^=','|=','(',')','[',']','.','!','~','*','/','%','+','-','<','>','&','^','|','?',':','=',',',';','{','}'];/***/},/***/8096:/***/function(module,__unused_webpack_exports,__nested_webpack_require_629411__){var tokenize=__nested_webpack_require_629411__(3193);module.exports=tokenizeString;function tokenizeString(str,opt){var generator=tokenize(opt);var tokens=[];tokens=tokens.concat(generator(str));tokens=tokens.concat(generator(null));return tokens;}/***/},/***/6832:/***/function(module){module.exports=function(strings){if(typeof strings==='string')strings=[strings];var exprs=[].slice.call(arguments,1);var parts=[];for(var i=0;i<strings.length-1;i++){parts.push(strings[i],exprs[i]||'');}parts.push(strings[i]);return parts.join('');};/***/},/***/5233:/***/function(module,__unused_webpack_exports,__nested_webpack_require_630018__){"use strict";var isBrowser=__nested_webpack_require_630018__(4846);function detect(){var supported=false;try{var opts=Object.defineProperty({},'passive',{get:function(){supported=true;}});window.addEventListener('test',null,opts);window.removeEventListener('test',null,opts);}catch(e){supported=false;}return supported;}module.exports=isBrowser&&detect();/***/},/***/2183:/***/function(module,__unused_webpack_exports,__nested_webpack_require_630443__){"use strict";//High level idea:
// 1. Use Clarkson's incremental construction to find convex hull
// 2. Point location in triangulation by jump and walk
module.exports=incrementalConvexHull;var orient=__nested_webpack_require_630443__(417);var compareCell=__nested_webpack_require_630443__(8211)/* .compareCells */.H;function Simplex(vertices,adjacent,boundary){this.vertices=vertices;this.adjacent=adjacent;this.boundary=boundary;this.lastVisited=-1;}Simplex.prototype.flip=function(){var t=this.vertices[0];this.vertices[0]=this.vertices[1];this.vertices[1]=t;var u=this.adjacent[0];this.adjacent[0]=this.adjacent[1];this.adjacent[1]=u;};function GlueFacet(vertices,cell,index){this.vertices=vertices;this.cell=cell;this.index=index;}function compareGlue(a,b){return compareCell(a.vertices,b.vertices);}function wrapper(test){return function(){var tuple=this.tuple;return test.apply(this,tuple);};}function bakeOrient(d){var test=orient[d+1];if(!test){test=orient;}return wrapper(test);}var BAKED=[];function Triangulation(dimension,vertices,simplices){this.dimension=dimension;this.vertices=vertices;this.simplices=simplices;this.interior=simplices.filter(function(c){return!c.boundary;});this.tuple=new Array(dimension+1);for(var i=0;i<=dimension;++i){this.tuple[i]=this.vertices[i];}var o=BAKED[dimension];if(!o){o=BAKED[dimension]=bakeOrient(dimension);}this.orient=o;}var proto=Triangulation.prototype;//Degenerate situation where we are on boundary, but coplanar to face
proto.handleBoundaryDegeneracy=function(cell,point){var d=this.dimension;var n=this.vertices.length-1;var tuple=this.tuple;var verts=this.vertices;//Dumb solution: Just do dfs from boundary cell until we find any peak, or terminate
var toVisit=[cell];cell.lastVisited=-n;while(toVisit.length>0){cell=toVisit.pop();var cellAdj=cell.adjacent;for(var i=0;i<=d;++i){var neighbor=cellAdj[i];if(!neighbor.boundary||neighbor.lastVisited<=-n){continue;}var nv=neighbor.vertices;for(var j=0;j<=d;++j){var vv=nv[j];if(vv<0){tuple[j]=point;}else{tuple[j]=verts[vv];}}var o=this.orient();if(o>0){return neighbor;}neighbor.lastVisited=-n;if(o===0){toVisit.push(neighbor);}}}return null;};proto.walk=function(point,random){//Alias local properties
var n=this.vertices.length-1;var d=this.dimension;var verts=this.vertices;var tuple=this.tuple;//Compute initial jump cell
var initIndex=random?this.interior.length*Math.random()|0:this.interior.length-1;var cell=this.interior[initIndex];//Start walking
outerLoop:while(!cell.boundary){var cellVerts=cell.vertices;var cellAdj=cell.adjacent;for(var i=0;i<=d;++i){tuple[i]=verts[cellVerts[i]];}cell.lastVisited=n;//Find farthest adjacent cell
for(var i=0;i<=d;++i){var neighbor=cellAdj[i];if(neighbor.lastVisited>=n){continue;}var prev=tuple[i];tuple[i]=point;var o=this.orient();tuple[i]=prev;if(o<0){cell=neighbor;continue outerLoop;}else{if(!neighbor.boundary){neighbor.lastVisited=n;}else{neighbor.lastVisited=-n;}}}return;}return cell;};proto.addPeaks=function(point,cell){var n=this.vertices.length-1;var d=this.dimension;var verts=this.vertices;var tuple=this.tuple;var interior=this.interior;var simplices=this.simplices;//Walking finished at boundary, time to add peaks
var tovisit=[cell];//Stretch initial boundary cell into a peak
cell.lastVisited=n;cell.vertices[cell.vertices.indexOf(-1)]=n;cell.boundary=false;interior.push(cell);//Record a list of all new boundaries created by added peaks so we can glue them together when we are all done
var glueFacets=[];//Do a traversal of the boundary walking outward from starting peak
while(tovisit.length>0){//Pop off peak and walk over adjacent cells
var cell=tovisit.pop();var cellVerts=cell.vertices;var cellAdj=cell.adjacent;var indexOfN=cellVerts.indexOf(n);if(indexOfN<0){continue;}for(var i=0;i<=d;++i){if(i===indexOfN){continue;}//For each boundary neighbor of the cell
var neighbor=cellAdj[i];if(!neighbor.boundary||neighbor.lastVisited>=n){continue;}var nv=neighbor.vertices;//Test if neighbor is a peak
if(neighbor.lastVisited!==-n){//Compute orientation of p relative to each boundary peak
var indexOfNeg1=0;for(var j=0;j<=d;++j){if(nv[j]<0){indexOfNeg1=j;tuple[j]=point;}else{tuple[j]=verts[nv[j]];}}var o=this.orient();//Test if neighbor cell is also a peak
if(o>0){nv[indexOfNeg1]=n;neighbor.boundary=false;interior.push(neighbor);tovisit.push(neighbor);neighbor.lastVisited=n;continue;}else{neighbor.lastVisited=-n;}}var na=neighbor.adjacent;//Otherwise, replace neighbor with new face
var vverts=cellVerts.slice();var vadj=cellAdj.slice();var ncell=new Simplex(vverts,vadj,true);simplices.push(ncell);//Connect to neighbor
var opposite=na.indexOf(cell);if(opposite<0){continue;}na[opposite]=ncell;vadj[indexOfN]=neighbor;//Connect to cell
vverts[i]=-1;vadj[i]=cell;cellAdj[i]=ncell;//Flip facet
ncell.flip();//Add to glue list
for(var j=0;j<=d;++j){var uu=vverts[j];if(uu<0||uu===n){continue;}var nface=new Array(d-1);var nptr=0;for(var k=0;k<=d;++k){var vv=vverts[k];if(vv<0||k===j){continue;}nface[nptr++]=vv;}glueFacets.push(new GlueFacet(nface,ncell,j));}}}//Glue boundary facets together
glueFacets.sort(compareGlue);for(var i=0;i+1<glueFacets.length;i+=2){var a=glueFacets[i];var b=glueFacets[i+1];var ai=a.index;var bi=b.index;if(ai<0||bi<0){continue;}a.cell.adjacent[a.index]=b.cell;b.cell.adjacent[b.index]=a.cell;}};proto.insert=function(point,random){//Add point
var verts=this.vertices;verts.push(point);var cell=this.walk(point,random);if(!cell){return;}//Alias local properties
var d=this.dimension;var tuple=this.tuple;//Degenerate case: If point is coplanar to cell, then walk until we find a non-degenerate boundary
for(var i=0;i<=d;++i){var vv=cell.vertices[i];if(vv<0){tuple[i]=point;}else{tuple[i]=verts[vv];}}var o=this.orient(tuple);if(o<0){return;}else if(o===0){cell=this.handleBoundaryDegeneracy(cell,point);if(!cell){return;}}//Add peaks
this.addPeaks(point,cell);};//Extract all boundary cells
proto.boundary=function(){var d=this.dimension;var boundary=[];var cells=this.simplices;var nc=cells.length;for(var i=0;i<nc;++i){var c=cells[i];if(c.boundary){var bcell=new Array(d);var cv=c.vertices;var ptr=0;var parity=0;for(var j=0;j<=d;++j){if(cv[j]>=0){bcell[ptr++]=cv[j];}else{parity=j&1;}}if(parity===(d&1)){var t=bcell[0];bcell[0]=bcell[1];bcell[1]=t;}boundary.push(bcell);}}return boundary;};function incrementalConvexHull(points,randomSearch){var n=points.length;if(n===0){throw new Error("Must have at least d+1 points");}var d=points[0].length;if(n<=d){throw new Error("Must input at least d+1 points");}//FIXME: This could be degenerate, but need to select d+1 non-coplanar points to bootstrap process
var initialSimplex=points.slice(0,d+1);//Make sure initial simplex is positively oriented
var o=orient.apply(void 0,initialSimplex);if(o===0){throw new Error("Input not in general position");}var initialCoords=new Array(d+1);for(var i=0;i<=d;++i){initialCoords[i]=i;}if(o<0){initialCoords[0]=1;initialCoords[1]=0;}//Create initial topological index, glue pointers together (kind of messy)
var initialCell=new Simplex(initialCoords,new Array(d+1),false);var boundary=initialCell.adjacent;var list=new Array(d+2);for(var i=0;i<=d;++i){var verts=initialCoords.slice();for(var j=0;j<=d;++j){if(j===i){verts[j]=-1;}}var t=verts[0];verts[0]=verts[1];verts[1]=t;var cell=new Simplex(verts,new Array(d+1),true);boundary[i]=cell;list[i]=cell;}list[d+1]=initialCell;for(var i=0;i<=d;++i){var verts=boundary[i].vertices;var adj=boundary[i].adjacent;for(var j=0;j<=d;++j){var v=verts[j];if(v<0){adj[j]=initialCell;continue;}for(var k=0;k<=d;++k){if(boundary[k].vertices.indexOf(v)<0){adj[j]=boundary[k];}}}}//Initialize triangles
var triangles=new Triangulation(d,initialSimplex,list);//Insert remaining points
var useRandom=!!randomSearch;for(var i=d+1;i<n;++i){triangles.insert(points[i],useRandom);}//Extract boundary cells
return triangles.boundary();}/***/},/***/9014:/***/function(module,__unused_webpack_exports,__nested_webpack_require_638365__){"use strict";var bounds=__nested_webpack_require_638365__(5070);var NOT_FOUND=0;var SUCCESS=1;var EMPTY=2;module.exports=createWrapper;function IntervalTreeNode(mid,left,right,leftPoints,rightPoints){this.mid=mid;this.left=left;this.right=right;this.leftPoints=leftPoints;this.rightPoints=rightPoints;this.count=(left?left.count:0)+(right?right.count:0)+leftPoints.length;}var proto=IntervalTreeNode.prototype;function copy(a,b){a.mid=b.mid;a.left=b.left;a.right=b.right;a.leftPoints=b.leftPoints;a.rightPoints=b.rightPoints;a.count=b.count;}function rebuild(node,intervals){var ntree=createIntervalTree(intervals);node.mid=ntree.mid;node.left=ntree.left;node.right=ntree.right;node.leftPoints=ntree.leftPoints;node.rightPoints=ntree.rightPoints;node.count=ntree.count;}function rebuildWithInterval(node,interval){var intervals=node.intervals([]);intervals.push(interval);rebuild(node,intervals);}function rebuildWithoutInterval(node,interval){var intervals=node.intervals([]);var idx=intervals.indexOf(interval);if(idx<0){return NOT_FOUND;}intervals.splice(idx,1);rebuild(node,intervals);return SUCCESS;}proto.intervals=function(result){result.push.apply(result,this.leftPoints);if(this.left){this.left.intervals(result);}if(this.right){this.right.intervals(result);}return result;};proto.insert=function(interval){var weight=this.count-this.leftPoints.length;this.count+=1;if(interval[1]<this.mid){if(this.left){if(4*(this.left.count+1)>3*(weight+1)){rebuildWithInterval(this,interval);}else{this.left.insert(interval);}}else{this.left=createIntervalTree([interval]);}}else if(interval[0]>this.mid){if(this.right){if(4*(this.right.count+1)>3*(weight+1)){rebuildWithInterval(this,interval);}else{this.right.insert(interval);}}else{this.right=createIntervalTree([interval]);}}else{var l=bounds.ge(this.leftPoints,interval,compareBegin);var r=bounds.ge(this.rightPoints,interval,compareEnd);this.leftPoints.splice(l,0,interval);this.rightPoints.splice(r,0,interval);}};proto.remove=function(interval){var weight=this.count-this.leftPoints;if(interval[1]<this.mid){if(!this.left){return NOT_FOUND;}var rw=this.right?this.right.count:0;if(4*rw>3*(weight-1)){return rebuildWithoutInterval(this,interval);}var r=this.left.remove(interval);if(r===EMPTY){this.left=null;this.count-=1;return SUCCESS;}else if(r===SUCCESS){this.count-=1;}return r;}else if(interval[0]>this.mid){if(!this.right){return NOT_FOUND;}var lw=this.left?this.left.count:0;if(4*lw>3*(weight-1)){return rebuildWithoutInterval(this,interval);}var r=this.right.remove(interval);if(r===EMPTY){this.right=null;this.count-=1;return SUCCESS;}else if(r===SUCCESS){this.count-=1;}return r;}else{if(this.count===1){if(this.leftPoints[0]===interval){return EMPTY;}else{return NOT_FOUND;}}if(this.leftPoints.length===1&&this.leftPoints[0]===interval){if(this.left&&this.right){var p=this;var n=this.left;while(n.right){p=n;n=n.right;}if(p===this){n.right=this.right;}else{var l=this.left;var r=this.right;p.count-=n.count;p.right=n.left;n.left=l;n.right=r;}copy(this,n);this.count=(this.left?this.left.count:0)+(this.right?this.right.count:0)+this.leftPoints.length;}else if(this.left){copy(this,this.left);}else{copy(this,this.right);}return SUCCESS;}for(var l=bounds.ge(this.leftPoints,interval,compareBegin);l<this.leftPoints.length;++l){if(this.leftPoints[l][0]!==interval[0]){break;}if(this.leftPoints[l]===interval){this.count-=1;this.leftPoints.splice(l,1);for(var r=bounds.ge(this.rightPoints,interval,compareEnd);r<this.rightPoints.length;++r){if(this.rightPoints[r][1]!==interval[1]){break;}else if(this.rightPoints[r]===interval){this.rightPoints.splice(r,1);return SUCCESS;}}}}return NOT_FOUND;}};function reportLeftRange(arr,hi,cb){for(var i=0;i<arr.length&&arr[i][0]<=hi;++i){var r=cb(arr[i]);if(r){return r;}}}function reportRightRange(arr,lo,cb){for(var i=arr.length-1;i>=0&&arr[i][1]>=lo;--i){var r=cb(arr[i]);if(r){return r;}}}function reportRange(arr,cb){for(var i=0;i<arr.length;++i){var r=cb(arr[i]);if(r){return r;}}}proto.queryPoint=function(x,cb){if(x<this.mid){if(this.left){var r=this.left.queryPoint(x,cb);if(r){return r;}}return reportLeftRange(this.leftPoints,x,cb);}else if(x>this.mid){if(this.right){var r=this.right.queryPoint(x,cb);if(r){return r;}}return reportRightRange(this.rightPoints,x,cb);}else{return reportRange(this.leftPoints,cb);}};proto.queryInterval=function(lo,hi,cb){if(lo<this.mid&&this.left){var r=this.left.queryInterval(lo,hi,cb);if(r){return r;}}if(hi>this.mid&&this.right){var r=this.right.queryInterval(lo,hi,cb);if(r){return r;}}if(hi<this.mid){return reportLeftRange(this.leftPoints,hi,cb);}else if(lo>this.mid){return reportRightRange(this.rightPoints,lo,cb);}else{return reportRange(this.leftPoints,cb);}};function compareNumbers(a,b){return a-b;}function compareBegin(a,b){var d=a[0]-b[0];if(d){return d;}return a[1]-b[1];}function compareEnd(a,b){var d=a[1]-b[1];if(d){return d;}return a[0]-b[0];}function createIntervalTree(intervals){if(intervals.length===0){return null;}var pts=[];for(var i=0;i<intervals.length;++i){pts.push(intervals[i][0],intervals[i][1]);}pts.sort(compareNumbers);var mid=pts[pts.length>>1];var leftIntervals=[];var rightIntervals=[];var centerIntervals=[];for(var i=0;i<intervals.length;++i){var s=intervals[i];if(s[1]<mid){leftIntervals.push(s);}else if(mid<s[0]){rightIntervals.push(s);}else{centerIntervals.push(s);}}//Split center intervals
var leftPoints=centerIntervals;var rightPoints=centerIntervals.slice();leftPoints.sort(compareBegin);rightPoints.sort(compareEnd);return new IntervalTreeNode(mid,createIntervalTree(leftIntervals),createIntervalTree(rightIntervals),leftPoints,rightPoints);}//User friendly wrapper that makes it possible to support empty trees
function IntervalTree(root){this.root=root;}var tproto=IntervalTree.prototype;tproto.insert=function(interval){if(this.root){this.root.insert(interval);}else{this.root=new IntervalTreeNode(interval[0],null,null,[interval],[interval]);}};tproto.remove=function(interval){if(this.root){var r=this.root.remove(interval);if(r===EMPTY){this.root=null;}return r!==NOT_FOUND;}return false;};tproto.queryPoint=function(p,cb){if(this.root){return this.root.queryPoint(p,cb);}};tproto.queryInterval=function(lo,hi,cb){if(lo<=hi&&this.root){return this.root.queryInterval(lo,hi,cb);}};Object.defineProperty(tproto,"count",{get:function(){if(this.root){return this.root.count;}return 0;}});Object.defineProperty(tproto,"intervals",{get:function(){if(this.root){return this.root.intervals([]);}return[];}});function createWrapper(intervals){if(!intervals||intervals.length===0){return new IntervalTree(null);}return new IntervalTree(createIntervalTree(intervals));}/***/},/***/9560:/***/function(module){"use strict";function iota(n){var result=new Array(n);for(var i=0;i<n;++i){result[i]=i;}return result;}module.exports=iota;/***/},/***/4846:/***/function(module){module.exports=true;/***/},/***/4780:/***/function(module){/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ // The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports=function(obj){return obj!=null&&(isBuffer(obj)||isSlowBuffer(obj)||!!obj._isBuffer);};function isBuffer(obj){return!!obj.constructor&&typeof obj.constructor.isBuffer==='function'&&obj.constructor.isBuffer(obj);}// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj){return typeof obj.readFloatLE==='function'&&typeof obj.slice==='function'&&isBuffer(obj.slice(0,0));}/***/},/***/3596:/***/function(module){"use strict";/**
 * Is this string all whitespace?
 * This solution kind of makes my brain hurt, but it's significantly faster
 * than !str.trim() or any other solution I could find.
 *
 * whitespace codes from: http://en.wikipedia.org/wiki/Whitespace_character
 * and verified with:
 *
 *  for(var i = 0; i < 65536; i++) {
 *      var s = String.fromCharCode(i);
 *      if(+s===0 && !s.trim()) console.log(i, s);
 *  }
 *
 * which counts a couple of these as *not* whitespace, but finds nothing else
 * that *is* whitespace. Note that charCodeAt stops at 16 bits, but it appears
 * that there are no whitespace characters above this, and code points above
 * this do not map onto white space characters.
 */module.exports=function(str){var l=str.length,a;for(var i=0;i<l;i++){a=str.charCodeAt(i);if((a<9||a>13)&&a!==32&&a!==133&&a!==160&&a!==5760&&a!==6158&&(a<8192||a>8205)&&a!==8232&&a!==8233&&a!==8239&&a!==8287&&a!==8288&&a!==12288&&a!==65279){return false;}}return true;};/***/},/***/3578:/***/function(module){function lerp(v0,v1,t){return v0*(1-t)+v1*t;}module.exports=lerp;/***/},/***/7191:/***/function(module,__unused_webpack_exports,__nested_webpack_require_647150__){/*jshint unused:true*/ /*
Input:  matrix      ; a 4x4 matrix
Output: translation ; a 3 component vector
        scale       ; a 3 component vector
        skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
        perspective ; a 4 component vector
        quaternion  ; a 4 component vector
Returns false if the matrix cannot be decomposed, true if it can


References:
https://github.com/kamicane/matrix3d/blob/master/lib/Matrix3d.js
https://github.com/ChromiumWebApps/chromium/blob/master/ui/gfx/transform_util.cc
http://www.w3.org/TR/css3-transforms/#decomposing-a-3d-matrix
*/var normalize=__nested_webpack_require_647150__(4690);var create=__nested_webpack_require_647150__(9823);var clone=__nested_webpack_require_647150__(7332);var determinant=__nested_webpack_require_647150__(7787);var invert=__nested_webpack_require_647150__(7437);var transpose=__nested_webpack_require_647150__(2142);var vec3={length:__nested_webpack_require_647150__(4693),normalize:__nested_webpack_require_647150__(899),dot:__nested_webpack_require_647150__(9305),cross:__nested_webpack_require_647150__(903)};var tmp=create();var perspectiveMatrix=create();var tmpVec4=[0,0,0,0];var row=[[0,0,0],[0,0,0],[0,0,0]];var pdum3=[0,0,0];module.exports=function decomposeMat4(matrix,translation,scale,skew,perspective,quaternion){if(!translation)translation=[0,0,0];if(!scale)scale=[0,0,0];if(!skew)skew=[0,0,0];if(!perspective)perspective=[0,0,0,1];if(!quaternion)quaternion=[0,0,0,1];//normalize, if not possible then bail out early
if(!normalize(tmp,matrix))return false;// perspectiveMatrix is used to solve for perspective, but it also provides
// an easy way to test for singularity of the upper 3x3 component.
clone(perspectiveMatrix,tmp);perspectiveMatrix[3]=0;perspectiveMatrix[7]=0;perspectiveMatrix[11]=0;perspectiveMatrix[15]=1;// If the perspectiveMatrix is not invertible, we are also unable to
// decompose, so we'll bail early. Constant taken from SkMatrix44::invert.
if(Math.abs(determinant(perspectiveMatrix)<1e-8))return false;var a03=tmp[3],a13=tmp[7],a23=tmp[11],a30=tmp[12],a31=tmp[13],a32=tmp[14],a33=tmp[15];// First, isolate perspective.
if(a03!==0||a13!==0||a23!==0){tmpVec4[0]=a03;tmpVec4[1]=a13;tmpVec4[2]=a23;tmpVec4[3]=a33;// Solve the equation by inverting perspectiveMatrix and multiplying
// rightHandSide by the inverse.
// resuing the perspectiveMatrix here since it's no longer needed
var ret=invert(perspectiveMatrix,perspectiveMatrix);if(!ret)return false;transpose(perspectiveMatrix,perspectiveMatrix);//multiply by transposed inverse perspective matrix, into perspective vec4
vec4multMat4(perspective,tmpVec4,perspectiveMatrix);}else{//no perspective
perspective[0]=perspective[1]=perspective[2]=0;perspective[3]=1;}// Next take care of translation
translation[0]=a30;translation[1]=a31;translation[2]=a32;// Now get scale and shear. 'row' is a 3 element array of 3 component vectors
mat3from4(row,tmp);// Compute X scale factor and normalize first row.
scale[0]=vec3.length(row[0]);vec3.normalize(row[0],row[0]);// Compute XY shear factor and make 2nd row orthogonal to 1st.
skew[0]=vec3.dot(row[0],row[1]);combine(row[1],row[1],row[0],1.0,-skew[0]);// Now, compute Y scale and normalize 2nd row.
scale[1]=vec3.length(row[1]);vec3.normalize(row[1],row[1]);skew[0]/=scale[1];// Compute XZ and YZ shears, orthogonalize 3rd row
skew[1]=vec3.dot(row[0],row[2]);combine(row[2],row[2],row[0],1.0,-skew[1]);skew[2]=vec3.dot(row[1],row[2]);combine(row[2],row[2],row[1],1.0,-skew[2]);// Next, get Z scale and normalize 3rd row.
scale[2]=vec3.length(row[2]);vec3.normalize(row[2],row[2]);skew[1]/=scale[2];skew[2]/=scale[2];// At this point, the matrix (in rows) is orthonormal.
// Check for a coordinate system flip.  If the determinant
// is -1, then negate the matrix and the scaling factors.
vec3.cross(pdum3,row[1],row[2]);if(vec3.dot(row[0],pdum3)<0){for(var i=0;i<3;i++){scale[i]*=-1;row[i][0]*=-1;row[i][1]*=-1;row[i][2]*=-1;}}// Now, get the rotations out
quaternion[0]=0.5*Math.sqrt(Math.max(1+row[0][0]-row[1][1]-row[2][2],0));quaternion[1]=0.5*Math.sqrt(Math.max(1-row[0][0]+row[1][1]-row[2][2],0));quaternion[2]=0.5*Math.sqrt(Math.max(1-row[0][0]-row[1][1]+row[2][2],0));quaternion[3]=0.5*Math.sqrt(Math.max(1+row[0][0]+row[1][1]+row[2][2],0));if(row[2][1]>row[1][2])quaternion[0]=-quaternion[0];if(row[0][2]>row[2][0])quaternion[1]=-quaternion[1];if(row[1][0]>row[0][1])quaternion[2]=-quaternion[2];return true;};//will be replaced by gl-vec4 eventually
function vec4multMat4(out,a,m){var x=a[0],y=a[1],z=a[2],w=a[3];out[0]=m[0]*x+m[4]*y+m[8]*z+m[12]*w;out[1]=m[1]*x+m[5]*y+m[9]*z+m[13]*w;out[2]=m[2]*x+m[6]*y+m[10]*z+m[14]*w;out[3]=m[3]*x+m[7]*y+m[11]*z+m[15]*w;return out;}//gets upper-left of a 4x4 matrix into a 3x3 of vectors
function mat3from4(out,mat4x4){out[0][0]=mat4x4[0];out[0][1]=mat4x4[1];out[0][2]=mat4x4[2];out[1][0]=mat4x4[4];out[1][1]=mat4x4[5];out[1][2]=mat4x4[6];out[2][0]=mat4x4[8];out[2][1]=mat4x4[9];out[2][2]=mat4x4[10];}function combine(out,a,b,scale1,scale2){out[0]=a[0]*scale1+b[0]*scale2;out[1]=a[1]*scale1+b[1]*scale2;out[2]=a[2]*scale1+b[2]*scale2;}/***/},/***/4690:/***/function(module){module.exports=function normalize(out,mat){var m44=mat[15];// Cannot normalize.
if(m44===0)return false;var scale=1/m44;for(var i=0;i<16;i++)out[i]=mat[i]*scale;return true;};/***/},/***/7649:/***/function(module,__unused_webpack_exports,__nested_webpack_require_652429__){var lerp=__nested_webpack_require_652429__(1868);var recompose=__nested_webpack_require_652429__(1102);var decompose=__nested_webpack_require_652429__(7191);var determinant=__nested_webpack_require_652429__(7787);var slerp=__nested_webpack_require_652429__(1116);var state0=state();var state1=state();var tmp=state();module.exports=interpolate;function interpolate(out,start,end,alpha){if(determinant(start)===0||determinant(end)===0)return false;//decompose the start and end matrices into individual components
var r0=decompose(start,state0.translate,state0.scale,state0.skew,state0.perspective,state0.quaternion);var r1=decompose(end,state1.translate,state1.scale,state1.skew,state1.perspective,state1.quaternion);if(!r0||!r1)return false;//now lerp/slerp the start and end components into a temporary     lerp(tmptranslate, state0.translate, state1.translate, alpha)
lerp(tmp.translate,state0.translate,state1.translate,alpha);lerp(tmp.skew,state0.skew,state1.skew,alpha);lerp(tmp.scale,state0.scale,state1.scale,alpha);lerp(tmp.perspective,state0.perspective,state1.perspective,alpha);slerp(tmp.quaternion,state0.quaternion,state1.quaternion,alpha);//and recompose into our 'out' matrix
recompose(out,tmp.translate,tmp.scale,tmp.skew,tmp.perspective,tmp.quaternion);return true;}function state(){return{translate:vec3(),scale:vec3(1),skew:vec3(),perspective:vec4(),quaternion:vec4()};}function vec3(n){return[n||0,n||0,n||0];}function vec4(){return[0,0,0,1];}/***/},/***/1102:/***/function(module,__unused_webpack_exports,__nested_webpack_require_653907__){/*
Input:  translation ; a 3 component vector
        scale       ; a 3 component vector
        skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
        perspective ; a 4 component vector
        quaternion  ; a 4 component vector
Output: matrix      ; a 4x4 matrix

From: http://www.w3.org/TR/css3-transforms/#recomposing-to-a-3d-matrix
*/var mat4={identity:__nested_webpack_require_653907__(9947),translate:__nested_webpack_require_653907__(998),multiply:__nested_webpack_require_653907__(104),create:__nested_webpack_require_653907__(9823),scale:__nested_webpack_require_653907__(3668),fromRotationTranslation:__nested_webpack_require_653907__(7280)};var rotationMatrix=mat4.create();var temp=mat4.create();module.exports=function recomposeMat4(matrix,translation,scale,skew,perspective,quaternion){mat4.identity(matrix);//apply translation & rotation
mat4.fromRotationTranslation(matrix,quaternion,translation);//apply perspective
matrix[3]=perspective[0];matrix[7]=perspective[1];matrix[11]=perspective[2];matrix[15]=perspective[3];// apply skew
// temp is a identity 4x4 matrix initially
mat4.identity(temp);if(skew[2]!==0){temp[9]=skew[2];mat4.multiply(matrix,matrix,temp);}if(skew[1]!==0){temp[9]=0;temp[8]=skew[1];mat4.multiply(matrix,matrix,temp);}if(skew[0]!==0){temp[8]=0;temp[4]=skew[0];mat4.multiply(matrix,matrix,temp);}//apply scale
mat4.scale(matrix,matrix,scale);return matrix;};/***/},/***/9298:/***/function(module,__unused_webpack_exports,__nested_webpack_require_655328__){"use strict";var bsearch=__nested_webpack_require_655328__(5070);var m4interp=__nested_webpack_require_655328__(7649);var invert44=__nested_webpack_require_655328__(7437);var rotateX=__nested_webpack_require_655328__(6109);var rotateY=__nested_webpack_require_655328__(7115);var rotateZ=__nested_webpack_require_655328__(5240);var lookAt=__nested_webpack_require_655328__(3012);var translate=__nested_webpack_require_655328__(998);var scale=__nested_webpack_require_655328__(3668);var normalize=__nested_webpack_require_655328__(899);var DEFAULT_CENTER=[0,0,0];module.exports=createMatrixCameraController;function MatrixCameraController(initialMatrix){this._components=initialMatrix.slice();this._time=[0];this.prevMatrix=initialMatrix.slice();this.nextMatrix=initialMatrix.slice();this.computedMatrix=initialMatrix.slice();this.computedInverse=initialMatrix.slice();this.computedEye=[0,0,0];this.computedUp=[0,0,0];this.computedCenter=[0,0,0];this.computedRadius=[0];this._limits=[-Infinity,Infinity];}var proto=MatrixCameraController.prototype;proto.recalcMatrix=function(t){var time=this._time;var tidx=bsearch.le(time,t);var mat=this.computedMatrix;if(tidx<0){return;}var comps=this._components;if(tidx===time.length-1){var ptr=16*tidx;for(var i=0;i<16;++i){mat[i]=comps[ptr++];}}else{var dt=time[tidx+1]-time[tidx];var ptr=16*tidx;var prev=this.prevMatrix;var allEqual=true;for(var i=0;i<16;++i){prev[i]=comps[ptr++];}var next=this.nextMatrix;for(var i=0;i<16;++i){next[i]=comps[ptr++];allEqual=allEqual&&prev[i]===next[i];}if(dt<1e-6||allEqual){for(var i=0;i<16;++i){mat[i]=prev[i];}}else{m4interp(mat,prev,next,(t-time[tidx])/dt);}}var up=this.computedUp;up[0]=mat[1];up[1]=mat[5];up[2]=mat[9];normalize(up,up);var imat=this.computedInverse;invert44(imat,mat);var eye=this.computedEye;var w=imat[15];eye[0]=imat[12]/w;eye[1]=imat[13]/w;eye[2]=imat[14]/w;var center=this.computedCenter;var radius=Math.exp(this.computedRadius[0]);for(var i=0;i<3;++i){center[i]=eye[i]-mat[2+4*i]*radius;}};proto.idle=function(t){if(t<this.lastT()){return;}var mc=this._components;var ptr=mc.length-16;for(var i=0;i<16;++i){mc.push(mc[ptr++]);}this._time.push(t);};proto.flush=function(t){var idx=bsearch.gt(this._time,t)-2;if(idx<0){return;}this._time.splice(0,idx);this._components.splice(0,16*idx);};proto.lastT=function(){return this._time[this._time.length-1];};proto.lookAt=function(t,eye,center,up){this.recalcMatrix(t);eye=eye||this.computedEye;center=center||DEFAULT_CENTER;up=up||this.computedUp;this.setMatrix(t,lookAt(this.computedMatrix,eye,center,up));var d2=0.0;for(var i=0;i<3;++i){d2+=Math.pow(center[i]-eye[i],2);}d2=Math.log(Math.sqrt(d2));this.computedRadius[0]=d2;};proto.rotate=function(t,yaw,pitch,roll){this.recalcMatrix(t);var mat=this.computedInverse;if(yaw)rotateY(mat,mat,yaw);if(pitch)rotateX(mat,mat,pitch);if(roll)rotateZ(mat,mat,roll);this.setMatrix(t,invert44(this.computedMatrix,mat));};var tvec=[0,0,0];proto.pan=function(t,dx,dy,dz){tvec[0]=-(dx||0.0);tvec[1]=-(dy||0.0);tvec[2]=-(dz||0.0);this.recalcMatrix(t);var mat=this.computedInverse;translate(mat,mat,tvec);this.setMatrix(t,invert44(mat,mat));};proto.translate=function(t,dx,dy,dz){tvec[0]=dx||0.0;tvec[1]=dy||0.0;tvec[2]=dz||0.0;this.recalcMatrix(t);var mat=this.computedMatrix;translate(mat,mat,tvec);this.setMatrix(t,mat);};proto.setMatrix=function(t,mat){if(t<this.lastT()){return;}this._time.push(t);for(var i=0;i<16;++i){this._components.push(mat[i]);}};proto.setDistance=function(t,d){this.computedRadius[0]=d;};proto.setDistanceLimits=function(a,b){var lim=this._limits;lim[0]=a;lim[1]=b;};proto.getDistanceLimits=function(out){var lim=this._limits;if(out){out[0]=lim[0];out[1]=lim[1];return out;}return lim;};function createMatrixCameraController(options){options=options||{};var matrix=options.matrix||[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return new MatrixCameraController(matrix);}/***/},/***/3266:/***/function(module,__unused_webpack_exports,__nested_webpack_require_659142__){"use strict";module.exports=monotoneConvexHull2D;var orient=__nested_webpack_require_659142__(417)[3];function monotoneConvexHull2D(points){var n=points.length;if(n<3){var result=new Array(n);for(var i=0;i<n;++i){result[i]=i;}if(n===2&&points[0][0]===points[1][0]&&points[0][1]===points[1][1]){return[0];}return result;}//Sort point indices along x-axis
var sorted=new Array(n);for(var i=0;i<n;++i){sorted[i]=i;}sorted.sort(function(a,b){var d=points[a][0]-points[b][0];if(d){return d;}return points[a][1]-points[b][1];});//Construct upper and lower hulls
var lower=[sorted[0],sorted[1]];var upper=[sorted[0],sorted[1]];for(var i=2;i<n;++i){var idx=sorted[i];var p=points[idx];//Insert into lower list
var m=lower.length;while(m>1&&orient(points[lower[m-2]],points[lower[m-1]],p)<=0){m-=1;lower.pop();}lower.push(idx);//Insert into upper list
m=upper.length;while(m>1&&orient(points[upper[m-2]],points[upper[m-1]],p)>=0){m-=1;upper.pop();}upper.push(idx);}//Merge lists together
var result=new Array(upper.length+lower.length-2);var ptr=0;for(var i=0,nl=lower.length;i<nl;++i){result[ptr++]=lower[i];}for(var j=upper.length-2;j>0;--j){result[ptr++]=upper[j];}//Return result
return result;}/***/},/***/6145:/***/function(module,__unused_webpack_exports,__nested_webpack_require_660402__){"use strict";module.exports=mouseListen;var mouse=__nested_webpack_require_660402__(4110);function mouseListen(element,callback){if(!callback){callback=element;element=window;}var buttonState=0;var x=0;var y=0;var mods={shift:false,alt:false,control:false,meta:false};var attached=false;function updateMods(ev){var changed=false;if('altKey'in ev){changed=changed||ev.altKey!==mods.alt;mods.alt=!!ev.altKey;}if('shiftKey'in ev){changed=changed||ev.shiftKey!==mods.shift;mods.shift=!!ev.shiftKey;}if('ctrlKey'in ev){changed=changed||ev.ctrlKey!==mods.control;mods.control=!!ev.ctrlKey;}if('metaKey'in ev){changed=changed||ev.metaKey!==mods.meta;mods.meta=!!ev.metaKey;}return changed;}function handleEvent(nextButtons,ev){var nextX=mouse.x(ev);var nextY=mouse.y(ev);if('buttons'in ev){nextButtons=ev.buttons|0;}if(nextButtons!==buttonState||nextX!==x||nextY!==y||updateMods(ev)){buttonState=nextButtons|0;x=nextX||0;y=nextY||0;callback&&callback(buttonState,x,y,mods);}}function clearState(ev){handleEvent(0,ev);}function handleBlur(){if(buttonState||x||y||mods.shift||mods.alt||mods.meta||mods.control){x=y=0;buttonState=0;mods.shift=mods.alt=mods.control=mods.meta=false;callback&&callback(0,0,0,mods);}}function handleMods(ev){if(updateMods(ev)){callback&&callback(buttonState,x,y,mods);}}function handleMouseMove(ev){if(mouse.buttons(ev)===0){handleEvent(0,ev);}else{handleEvent(buttonState,ev);}}function handleMouseDown(ev){handleEvent(buttonState|mouse.buttons(ev),ev);}function handleMouseUp(ev){handleEvent(buttonState&~mouse.buttons(ev),ev);}function attachListeners(){if(attached){return;}attached=true;element.addEventListener('mousemove',handleMouseMove);element.addEventListener('mousedown',handleMouseDown);element.addEventListener('mouseup',handleMouseUp);element.addEventListener('mouseleave',clearState);element.addEventListener('mouseenter',clearState);element.addEventListener('mouseout',clearState);element.addEventListener('mouseover',clearState);element.addEventListener('blur',handleBlur);element.addEventListener('keyup',handleMods);element.addEventListener('keydown',handleMods);element.addEventListener('keypress',handleMods);if(element!==window){window.addEventListener('blur',handleBlur);window.addEventListener('keyup',handleMods);window.addEventListener('keydown',handleMods);window.addEventListener('keypress',handleMods);}}function detachListeners(){if(!attached){return;}attached=false;element.removeEventListener('mousemove',handleMouseMove);element.removeEventListener('mousedown',handleMouseDown);element.removeEventListener('mouseup',handleMouseUp);element.removeEventListener('mouseleave',clearState);element.removeEventListener('mouseenter',clearState);element.removeEventListener('mouseout',clearState);element.removeEventListener('mouseover',clearState);element.removeEventListener('blur',handleBlur);element.removeEventListener('keyup',handleMods);element.removeEventListener('keydown',handleMods);element.removeEventListener('keypress',handleMods);if(element!==window){window.removeEventListener('blur',handleBlur);window.removeEventListener('keyup',handleMods);window.removeEventListener('keydown',handleMods);window.removeEventListener('keypress',handleMods);}}// Attach listeners
attachListeners();var result={element:element};Object.defineProperties(result,{enabled:{get:function(){return attached;},set:function(f){if(f){attachListeners();}else{detachListeners();}},enumerable:true},buttons:{get:function(){return buttonState;},enumerable:true},x:{get:function(){return x;},enumerable:true},y:{get:function(){return y;},enumerable:true},mods:{get:function(){return mods;},enumerable:true}});return result;}/***/},/***/2565:/***/function(module){var rootPosition={left:0,top:0};module.exports=mouseEventOffset;function mouseEventOffset(ev,target,out){target=target||ev.currentTarget||ev.srcElement;if(!Array.isArray(out)){out=[0,0];}var cx=ev.clientX||0;var cy=ev.clientY||0;var rect=getBoundingClientOffset(target);out[0]=cx-rect.left;out[1]=cy-rect.top;return out;}function getBoundingClientOffset(element){if(element===window||element===document||element===document.body){return rootPosition;}else{return element.getBoundingClientRect();}}/***/},/***/4110:/***/function(__unused_webpack_module,exports){"use strict";function mouseButtons(ev){if(typeof ev==='object'){if('buttons'in ev){return ev.buttons;}else if('which'in ev){var b=ev.which;if(b===2){return 4;}else if(b===3){return 2;}else if(b>0){return 1<<b-1;}}else if('button'in ev){var b=ev.button;if(b===1){return 4;}else if(b===2){return 2;}else if(b>=0){return 1<<b;}}}return 0;}exports.buttons=mouseButtons;function mouseElement(ev){return ev.target||ev.srcElement||window;}exports.element=mouseElement;function mouseRelativeX(ev){if(typeof ev==='object'){if('offsetX'in ev){return ev.offsetX;}var target=mouseElement(ev);var bounds=target.getBoundingClientRect();return ev.clientX-bounds.left;}return 0;}exports.x=mouseRelativeX;function mouseRelativeY(ev){if(typeof ev==='object'){if('offsetY'in ev){return ev.offsetY;}var target=mouseElement(ev);var bounds=target.getBoundingClientRect();return ev.clientY-bounds.top;}return 0;}exports.y=mouseRelativeY;/***/},/***/6475:/***/function(module,__unused_webpack_exports,__nested_webpack_require_665638__){"use strict";var toPX=__nested_webpack_require_665638__(14);module.exports=mouseWheelListen;function mouseWheelListen(element,callback,noScroll){if(typeof element==='function'){noScroll=!!callback;callback=element;element=window;}var lineHeight=toPX('ex',element);var listener=function(ev){if(noScroll){ev.preventDefault();}var dx=ev.deltaX||0;var dy=ev.deltaY||0;var dz=ev.deltaZ||0;var mode=ev.deltaMode;var scale=1;switch(mode){case 1:scale=lineHeight;break;case 2:scale=window.innerHeight;break;}dx*=scale;dy*=scale;dz*=scale;if(dx||dy||dz){return callback(dx,dy,dz,ev);}};element.addEventListener('wheel',listener);return listener;}/***/},/***/9284:/***/function(module,__unused_webpack_exports,__nested_webpack_require_666345__){"use strict";var pool=__nested_webpack_require_666345__(5306);module.exports=createSurfaceExtractor;var allFns={"false,0,1":function surfaceProcedure(vertex,face,phase,mallocUint32,freeUint32){return function extractContour0_1(a0,x0,x1,x2){var s0=a0.shape[0]|0,s1=a0.shape[1]|0,d0=a0.data,o0=a0.offset|0,t0_0=a0.stride[0]|0,t0_1=a0.stride[1]|0,p0=o0,c0_0,d0_1=-t0_0|0,c0_1=0,d0_2=-t0_1|0,c0_2=0,d0_3=-t0_0-t0_1|0,c0_3=0,u0_0=t0_0|0,u0_1=t0_1-t0_0*s0|0,i0=0,i1=0,N=0,Q=2*s0|0,P=mallocUint32(Q),V=mallocUint32(Q),X=0,b0=0,e1=-1|0,y1=-1|0,b1=0,e2=-s0|0,y2=s0|0,b2=0,e3=-s0-1|0,y3=s0-1|0,b3=0,v0=0,T=0;for(i0=0;i0<s0;++i0){P[X++]=phase(d0[p0],x0,x1,x2);p0+=u0_0;}p0+=u0_1;if(s1>0){i1=1;P[X++]=phase(d0[p0],x0,x1,x2);p0+=u0_0;if(s0>0){i0=1;c0_0=d0[p0];b0=P[X]=phase(c0_0,x0,x1,x2);b1=P[X+e1];b2=P[X+e2];b3=P[X+e3];if(b0!==b1||b0!==b2||b0!==b3){c0_1=d0[p0+d0_1];c0_2=d0[p0+d0_2];c0_3=d0[p0+d0_3];vertex(i0,i1,c0_0,c0_1,c0_2,c0_3,b0,b1,b2,b3,x0,x1,x2);v0=V[X]=N++;}X+=1;p0+=u0_0;for(i0=2;i0<s0;++i0){c0_0=d0[p0];b0=P[X]=phase(c0_0,x0,x1,x2);b1=P[X+e1];b2=P[X+e2];b3=P[X+e3];if(b0!==b1||b0!==b2||b0!==b3){c0_1=d0[p0+d0_1];c0_2=d0[p0+d0_2];c0_3=d0[p0+d0_3];vertex(i0,i1,c0_0,c0_1,c0_2,c0_3,b0,b1,b2,b3,x0,x1,x2);v0=V[X]=N++;if(b3!==b1){face(V[X+e1],v0,c0_3,c0_1,b3,b1,x0,x1,x2);}}X+=1;p0+=u0_0;}}p0+=u0_1;X=0;T=e1;e1=y1;y1=T;T=e2;e2=y2;y2=T;T=e3;e3=y3;y3=T;for(i1=2;i1<s1;++i1){P[X++]=phase(d0[p0],x0,x1,x2);p0+=u0_0;if(s0>0){i0=1;c0_0=d0[p0];b0=P[X]=phase(c0_0,x0,x1,x2);b1=P[X+e1];b2=P[X+e2];b3=P[X+e3];if(b0!==b1||b0!==b2||b0!==b3){c0_1=d0[p0+d0_1];c0_2=d0[p0+d0_2];c0_3=d0[p0+d0_3];vertex(i0,i1,c0_0,c0_1,c0_2,c0_3,b0,b1,b2,b3,x0,x1,x2);v0=V[X]=N++;if(b3!==b2){face(V[X+e2],v0,c0_2,c0_3,b2,b3,x0,x1,x2);}}X+=1;p0+=u0_0;for(i0=2;i0<s0;++i0){c0_0=d0[p0];b0=P[X]=phase(c0_0,x0,x1,x2);b1=P[X+e1];b2=P[X+e2];b3=P[X+e3];if(b0!==b1||b0!==b2||b0!==b3){c0_1=d0[p0+d0_1];c0_2=d0[p0+d0_2];c0_3=d0[p0+d0_3];vertex(i0,i1,c0_0,c0_1,c0_2,c0_3,b0,b1,b2,b3,x0,x1,x2);v0=V[X]=N++;if(b3!==b2){face(V[X+e2],v0,c0_2,c0_3,b2,b3,x0,x1,x2);}if(b3!==b1){face(V[X+e1],v0,c0_3,c0_1,b3,b1,x0,x1,x2);}}X+=1;p0+=u0_0;}}if(i1&1){X=0;}T=e1;e1=y1;y1=T;T=e2;e2=y2;y2=T;T=e3;e3=y3;y3=T;p0+=u0_1;}}freeUint32(V);freeUint32(P);};},"false,1,0":function anonymous(vertex,face,phase,mallocUint32,freeUint32){return function extractContour1_0(a0,x0,x1,x2){var s0=a0.shape[0]|0,s1=a0.shape[1]|0,d0=a0.data,o0=a0.offset|0,t0_0=a0.stride[0]|0,t0_1=a0.stride[1]|0,p0=o0,c0_0,d0_1=-t0_0|0,c0_1=0,d0_2=-t0_1|0,c0_2=0,d0_3=-t0_0-t0_1|0,c0_3=0,u0_1=t0_1|0,u0_0=t0_0-t0_1*s1|0,i0=0,i1=0,N=0,Q=2*s1|0,P=mallocUint32(Q),V=mallocUint32(Q),X=0,b0=0,e2=-1|0,y2=-1|0,b2=0,e1=-s1|0,y1=s1|0,b1=0,e3=-s1-1|0,y3=s1-1|0,b3=0,v0=0,T=0;for(i1=0;i1<s1;++i1){P[X++]=phase(d0[p0],x0,x1,x2);p0+=u0_1;}p0+=u0_0;if(s0>0){i0=1;P[X++]=phase(d0[p0],x0,x1,x2);p0+=u0_1;if(s1>0){i1=1;c0_0=d0[p0];b0=P[X]=phase(c0_0,x0,x1,x2);b1=P[X+e1];b2=P[X+e2];b3=P[X+e3];if(b0!==b1||b0!==b2||b0!==b3){c0_1=d0[p0+d0_1];c0_2=d0[p0+d0_2];c0_3=d0[p0+d0_3];vertex(i0,i1,c0_0,c0_1,c0_2,c0_3,b0,b1,b2,b3,x0,x1,x2);v0=V[X]=N++;}X+=1;p0+=u0_1;for(i1=2;i1<s1;++i1){c0_0=d0[p0];b0=P[X]=phase(c0_0,x0,x1,x2);b1=P[X+e1];b2=P[X+e2];b3=P[X+e3];if(b0!==b1||b0!==b2||b0!==b3){c0_1=d0[p0+d0_1];c0_2=d0[p0+d0_2];c0_3=d0[p0+d0_3];vertex(i0,i1,c0_0,c0_1,c0_2,c0_3,b0,b1,b2,b3,x0,x1,x2);v0=V[X]=N++;if(b3!==b2){face(V[X+e2],v0,c0_2,c0_3,b2,b3,x0,x1,x2);}}X+=1;p0+=u0_1;}}p0+=u0_0;X=0;T=e1;e1=y1;y1=T;T=e2;e2=y2;y2=T;T=e3;e3=y3;y3=T;for(i0=2;i0<s0;++i0){P[X++]=phase(d0[p0],x0,x1,x2);p0+=u0_1;if(s1>0){i1=1;c0_0=d0[p0];b0=P[X]=phase(c0_0,x0,x1,x2);b1=P[X+e1];b2=P[X+e2];b3=P[X+e3];if(b0!==b1||b0!==b2||b0!==b3){c0_1=d0[p0+d0_1];c0_2=d0[p0+d0_2];c0_3=d0[p0+d0_3];vertex(i0,i1,c0_0,c0_1,c0_2,c0_3,b0,b1,b2,b3,x0,x1,x2);v0=V[X]=N++;if(b3!==b1){face(V[X+e1],v0,c0_3,c0_1,b3,b1,x0,x1,x2);}}X+=1;p0+=u0_1;for(i1=2;i1<s1;++i1){c0_0=d0[p0];b0=P[X]=phase(c0_0,x0,x1,x2);b1=P[X+e1];b2=P[X+e2];b3=P[X+e3];if(b0!==b1||b0!==b2||b0!==b3){c0_1=d0[p0+d0_1];c0_2=d0[p0+d0_2];c0_3=d0[p0+d0_3];vertex(i0,i1,c0_0,c0_1,c0_2,c0_3,b0,b1,b2,b3,x0,x1,x2);v0=V[X]=N++;if(b3!==b2){face(V[X+e2],v0,c0_2,c0_3,b2,b3,x0,x1,x2);}if(b3!==b1){face(V[X+e1],v0,c0_3,c0_1,b3,b1,x0,x1,x2);}}X+=1;p0+=u0_1;}}if(i0&1){X=0;}T=e1;e1=y1;y1=T;T=e2;e2=y2;y2=T;T=e3;e3=y3;y3=T;p0+=u0_0;}}freeUint32(V);freeUint32(P);};}};//Generates the surface procedure
function compileSurfaceProcedure(vertexFunc,faceFunc,phaseFunc,scalarArgs,order,typesig){var key=[typesig,order].join(',');var proc=allFns[key];return proc(vertexFunc,faceFunc,phaseFunc,pool.mallocUint32,pool.freeUint32);}function createSurfaceExtractor(args){function error(msg){throw new Error("ndarray-extract-contour: "+msg);}if(typeof args!=="object"){error("Must specify arguments");}var order=args.order;if(!Array.isArray(order)){error("Must specify order");}var arrays=args.arrayArguments||1;if(arrays<1){error("Must have at least one array argument");}var scalars=args.scalarArguments||0;if(scalars<0){error("Scalar arg count must be > 0");}if(typeof args.vertex!=="function"){error("Must specify vertex creation function");}if(typeof args.cell!=="function"){error("Must specify cell creation function");}if(typeof args.phase!=="function"){error("Must specify phase function");}var getters=args.getters||[];var typesig=new Array(arrays);for(var i=0;i<arrays;++i){if(getters.indexOf(i)>=0){typesig[i]=true;}else{typesig[i]=false;}}return compileSurfaceProcedure(args.vertex,args.cell,args.phase,scalars,order,typesig);}/***/},/***/9144:/***/function(module,__unused_webpack_exports,__nested_webpack_require_671836__){"use strict";var dup=__nested_webpack_require_671836__(3094);var CACHED_CWiseOp={zero:function(SS,a0,t0,p0){var s0=SS[0],t0p0=t0[0];p0|=0;var i0=0,d0s0=t0p0;for(i0=0;i0<s0;++i0){a0[p0]=0;p0+=d0s0;}},fdTemplate1:function(SS,a0,t0,p0,a1,t1,p1){var s0=SS[0],t0p0=t0[0],t1p0=t1[0],q0=-1*t0p0,q1=t0p0;p0|=0;p1|=0;var i0=0,d0s0=t0p0,d1s0=t1p0;for(i0=0;i0<s0;++i0){a1[p1]=0.5*(a0[p0+q0]-a0[p0+q1]);p0+=d0s0;p1+=d1s0;}},fdTemplate2:function(SS,a0,t0,p0,a1,t1,p1,a2,t2,p2){var s0=SS[0],s1=SS[1],t0p0=t0[0],t0p1=t0[1],t1p0=t1[0],t1p1=t1[1],t2p0=t2[0],t2p1=t2[1],q0=-1*t0p0,q1=t0p0,q2=-1*t0p1,q3=t0p1;p0|=0;p1|=0;p2|=0;var i0=0,i1=0,d0s0=t0p1,d0s1=t0p0-s1*t0p1,d1s0=t1p1,d1s1=t1p0-s1*t1p1,d2s0=t2p1,d2s1=t2p0-s1*t2p1;for(i1=0;i1<s0;++i1){for(i0=0;i0<s1;++i0){a1[p1]=0.5*(a0[p0+q0]-a0[p0+q1]);a2[p2]=0.5*(a0[p0+q2]-a0[p0+q3]);p0+=d0s0;p1+=d1s0;p2+=d2s0;}p0+=d0s1;p1+=d1s1;p2+=d2s1;}}};var CACHED_thunk={cdiff:function(compile){var CACHED={};return function cdiff_cwise_thunk(array0,array1,array2){var t0=array0.dtype,r0=array0.order,t1=array1.dtype,r1=array1.order,t2=array2.dtype,r2=array2.order,type=[t0,r0.join(),t1,r1.join(),t2,r2.join()].join(),proc=CACHED[type];if(!proc){CACHED[type]=proc=compile([t0,r0,t1,r1,t2,r2]);}return proc(array0.shape.slice(0),array0.data,array0.stride,array0.offset|0,array1.data,array1.stride,array1.offset|0,array2.data,array2.stride,array2.offset|0);};},zero:function(compile){var CACHED={};return function zero_cwise_thunk(array0){var t0=array0.dtype,r0=array0.order,type=[t0,r0.join()].join(),proc=CACHED[type];if(!proc){CACHED[type]=proc=compile([t0,r0]);}return proc(array0.shape.slice(0),array0.data,array0.stride,array0.offset|0);};},fdTemplate1:function(compile){var CACHED={};return function fdTemplate1_cwise_thunk(array0,array1){var t0=array0.dtype,r0=array0.order,t1=array1.dtype,r1=array1.order,type=[t0,r0.join(),t1,r1.join()].join(),proc=CACHED[type];if(!proc){CACHED[type]=proc=compile([t0,r0,t1,r1]);}return proc(array0.shape.slice(0),array0.data,array0.stride,array0.offset|0,array1.data,array1.stride,array1.offset|0);};},fdTemplate2:function(compile){var CACHED={};return function fdTemplate2_cwise_thunk(array0,array1,array4){var t0=array0.dtype,r0=array0.order,t1=array1.dtype,r1=array1.order,t4=array4.dtype,r4=array4.order,type=[t0,r0.join(),t1,r1.join(),t4,r4.join()].join(),proc=CACHED[type];if(!proc){CACHED[type]=proc=compile([t0,r0,t1,r1,t4,r4]);}return proc(array0.shape.slice(0),array0.data,array0.stride,array0.offset|0,array1.data,array1.stride,array1.offset|0,array4.data,array4.stride,array4.offset|0);};}};function createThunk(proc){var thunk=CACHED_thunk[proc.funcName];return thunk(compile.bind(undefined,proc));}function compile(proc){return CACHED_CWiseOp[proc.funcName];}function cwiseCompiler(user_args){return createThunk({funcName:user_args.funcName});}var TEMPLATE_CACHE={};var GRADIENT_CACHE={};var EmptyProc={body:"",args:[],thisVars:[],localVars:[]};var centralDiff=cwiseCompiler({funcName:'cdiff'});var zeroOut=cwiseCompiler({funcName:'zero'});function generateTemplate(d){if(d in TEMPLATE_CACHE){return TEMPLATE_CACHE[d];}return TEMPLATE_CACHE[d]=cwiseCompiler({funcName:'fdTemplate'+d});}function CACHED_link(diff,zero,grad1,grad2){return function(dst,src){var s=src.shape.slice();if( true&&s[0]>2&&s[1]>2){grad2(src.pick(-1,-1).lo(1,1).hi(s[0]-2,s[1]-2),dst.pick(-1,-1,0).lo(1,1).hi(s[0]-2,s[1]-2),dst.pick(-1,-1,1).lo(1,1).hi(s[0]-2,s[1]-2));}if( true&&s[1]>2){grad1(src.pick(0,-1).lo(1).hi(s[1]-2),dst.pick(0,-1,1).lo(1).hi(s[1]-2));zero(dst.pick(0,-1,0).lo(1).hi(s[1]-2));}if( true&&s[1]>2){grad1(src.pick(s[0]-1,-1).lo(1).hi(s[1]-2),dst.pick(s[0]-1,-1,1).lo(1).hi(s[1]-2));zero(dst.pick(s[0]-1,-1,0).lo(1).hi(s[1]-2));}if( true&&s[0]>2){grad1(src.pick(-1,0).lo(1).hi(s[0]-2),dst.pick(-1,0,0).lo(1).hi(s[0]-2));zero(dst.pick(-1,0,1).lo(1).hi(s[0]-2));}if( true&&s[0]>2){grad1(src.pick(-1,s[1]-1).lo(1).hi(s[0]-2),dst.pick(-1,s[1]-1,0).lo(1).hi(s[0]-2));zero(dst.pick(-1,s[1]-1,1).lo(1).hi(s[0]-2));}dst.set(0,0,0,0);dst.set(0,0,1,0);dst.set(s[0]-1,0,0,0);dst.set(s[0]-1,0,1,0);dst.set(0,s[1]-1,0,0);dst.set(0,s[1]-1,1,0);dst.set(s[0]-1,s[1]-1,0,0);dst.set(s[0]-1,s[1]-1,1,0);return dst;};}function generateGradient(boundaryConditions){var token=boundaryConditions.join();var proc=GRADIENT_CACHE[token];if(proc){return proc;}var d=boundaryConditions.length;var linkArgs=[centralDiff,zeroOut];for(var i=1;i<=d;++i){linkArgs.push(generateTemplate(i));}var link=CACHED_link;var proc=link.apply(void 0,linkArgs);GRADIENT_CACHE[token]=proc;return proc;}module.exports=function gradient(out,inp,bc){if(!Array.isArray(bc)){if(typeof bc==='string'){bc=dup(inp.dimension,bc);}else{bc=dup(inp.dimension,'clamp');}}if(inp.size===0){return out;}if(inp.dimension===0){out.set(0);return out;}var cached=generateGradient(bc);return cached(out,inp);};/***/},/***/3581:/***/function(module){"use strict";function interp1d(arr,x){var ix=Math.floor(x),fx=x-ix,s0=0<=ix&&ix<arr.shape[0],s1=0<=ix+1&&ix+1<arr.shape[0],w0=s0?+arr.get(ix):0.0,w1=s1?+arr.get(ix+1):0.0;return(1.0-fx)*w0+fx*w1;}function interp2d(arr,x,y){var ix=Math.floor(x),fx=x-ix,s0=0<=ix&&ix<arr.shape[0],s1=0<=ix+1&&ix+1<arr.shape[0],iy=Math.floor(y),fy=y-iy,t0=0<=iy&&iy<arr.shape[1],t1=0<=iy+1&&iy+1<arr.shape[1],w00=s0&&t0?arr.get(ix,iy):0.0,w01=s0&&t1?arr.get(ix,iy+1):0.0,w10=s1&&t0?arr.get(ix+1,iy):0.0,w11=s1&&t1?arr.get(ix+1,iy+1):0.0;return(1.0-fy)*((1.0-fx)*w00+fx*w10)+fy*((1.0-fx)*w01+fx*w11);}function interp3d(arr,x,y,z){var ix=Math.floor(x),fx=x-ix,s0=0<=ix&&ix<arr.shape[0],s1=0<=ix+1&&ix+1<arr.shape[0],iy=Math.floor(y),fy=y-iy,t0=0<=iy&&iy<arr.shape[1],t1=0<=iy+1&&iy+1<arr.shape[1],iz=Math.floor(z),fz=z-iz,u0=0<=iz&&iz<arr.shape[2],u1=0<=iz+1&&iz+1<arr.shape[2],w000=s0&&t0&&u0?arr.get(ix,iy,iz):0.0,w010=s0&&t1&&u0?arr.get(ix,iy+1,iz):0.0,w100=s1&&t0&&u0?arr.get(ix+1,iy,iz):0.0,w110=s1&&t1&&u0?arr.get(ix+1,iy+1,iz):0.0,w001=s0&&t0&&u1?arr.get(ix,iy,iz+1):0.0,w011=s0&&t1&&u1?arr.get(ix,iy+1,iz+1):0.0,w101=s1&&t0&&u1?arr.get(ix+1,iy,iz+1):0.0,w111=s1&&t1&&u1?arr.get(ix+1,iy+1,iz+1):0.0;return(1.0-fz)*((1.0-fy)*((1.0-fx)*w000+fx*w100)+fy*((1.0-fx)*w010+fx*w110))+fz*((1.0-fy)*((1.0-fx)*w001+fx*w101)+fy*((1.0-fx)*w011+fx*w111));}function interpNd(arr){var d=arr.shape.length|0,ix=new Array(d),fx=new Array(d),s0=new Array(d),s1=new Array(d),i,t;for(i=0;i<d;++i){t=+arguments[i+1];ix[i]=Math.floor(t);fx[i]=t-ix[i];s0[i]=0<=ix[i]&&ix[i]<arr.shape[i];s1[i]=0<=ix[i]+1&&ix[i]+1<arr.shape[i];}var r=0.0,j,w,idx;i_loop:for(i=0;i<1<<d;++i){w=1.0;idx=arr.offset;for(j=0;j<d;++j){if(i&1<<j){if(!s1[j]){continue i_loop;}w*=fx[j];idx+=arr.stride[j]*(ix[j]+1);}else{if(!s0[j]){continue i_loop;}w*=1.0-fx[j];idx+=arr.stride[j]*ix[j];}}r+=w*arr.data[idx];}return r;}function interpolate(arr,x,y,z){switch(arr.shape.length){case 0:return 0.0;case 1:return interp1d(arr,x);case 2:return interp2d(arr,x,y);case 3:return interp3d(arr,x,y,z);default:return interpNd.apply(undefined,arguments);}}module.exports=interpolate;module.exports.d1=interp1d;module.exports.d2=interp2d;module.exports.d3=interp3d;/***/},/***/7498:/***/function(__unused_webpack_module,exports){"use strict";var CACHED_CWiseOp={'float64,2,1,0':function(){return function divseq_cwise_loop_2s1s0m3f64(SS,a0,t0,p0,Y0){var s0=SS[0],s1=SS[1],s2=SS[2],t0p0=t0[0],t0p1=t0[1],t0p2=t0[2];p0|=0;var i0=0,i1=0,i2=0,d0s0=t0p2,d0s1=t0p1-s2*t0p2,d0s2=t0p0-s1*t0p1;for(i2=0;i2<s0;++i2){for(i1=0;i1<s1;++i1){for(i0=0;i0<s2;++i0){a0[p0]/=Y0;p0+=d0s0;}p0+=d0s1;}p0+=d0s2;}};},'uint8,2,0,1,float64,2,1,0':function(){return function muls_cwise_loop_2s0s1m1u8f64(SS,a0,t0,p0,a1,t1,p1,Y0){var s0=SS[0],s1=SS[1],s2=SS[2],t0p0=t0[0],t0p1=t0[1],t0p2=t0[2],t1p0=t1[0],t1p1=t1[1],t1p2=t1[2];p0|=0;p1|=0;var offset0=p0;var offset1=p1;for(var j1=SS[0]|0;j1>0;){if(j1<64){s0=j1;j1=0;}else{s0=64;j1-=64;}for(var j2=SS[1]|0;j2>0;){if(j2<64){s1=j2;j2=0;}else{s1=64;j2-=64;}p0=offset0+j1*t0p0+j2*t0p1;p1=offset1+j1*t1p0+j2*t1p1;var i0=0,i1=0,i2=0,d0s0=t0p2,d0s1=t0p0-s2*t0p2,d0s2=t0p1-s0*t0p0,d1s0=t1p2,d1s1=t1p0-s2*t1p2,d1s2=t1p1-s0*t1p0;for(i2=0;i2<s1;++i2){for(i1=0;i1<s0;++i1){for(i0=0;i0<s2;++i0){a0[p0]=a1[p1]*Y0;p0+=d0s0;p1+=d1s0;}p0+=d0s1;p1+=d1s1;}p0+=d0s2;p1+=d1s2;}}}};},'float32,1,0,float32,1,0':function(){return function assign_cwise_loop_1s0m2f32(SS,a0,t0,p0,a1,t1,p1){var s0=SS[0],s1=SS[1],t0p0=t0[0],t0p1=t0[1],t1p0=t1[0],t1p1=t1[1];p0|=0;p1|=0;var i0=0,i1=0,d0s0=t0p1,d0s1=t0p0-s1*t0p1,d1s0=t1p1,d1s1=t1p0-s1*t1p1;for(i1=0;i1<s0;++i1){for(i0=0;i0<s1;++i0){a0[p0]=a1[p1];p0+=d0s0;p1+=d1s0;}p0+=d0s1;p1+=d1s1;}};},'float32,1,0,float32,0,1':function(){return function assign_cwise_loop_1s0m0f32(SS,a0,t0,p0,a1,t1,p1){var s0=SS[0],s1=SS[1],t0p0=t0[0],t0p1=t0[1],t1p0=t1[0],t1p1=t1[1];p0|=0;p1|=0;var offset0=p0;var offset1=p1;for(var j0=SS[1]|0;j0>0;){if(j0<64){s1=j0;j0=0;}else{s1=64;j0-=64;}for(var j1=SS[0]|0;j1>0;){if(j1<64){s0=j1;j1=0;}else{s0=64;j1-=64;}p0=offset0+j0*t0p1+j1*t0p0;p1=offset1+j0*t1p1+j1*t1p0;var i0=0,i1=0,d0s0=t0p1,d0s1=t0p0-s1*t0p1,d1s0=t1p1,d1s1=t1p0-s1*t1p1;for(i1=0;i1<s0;++i1){for(i0=0;i0<s1;++i0){a0[p0]=a1[p1];p0+=d0s0;p1+=d1s0;}p0+=d0s1;p1+=d1s1;}}}};},'uint8,2,0,1,uint8,1,2,0':function(){return function assign_cwise_loop_2s0s1m0u8(SS,a0,t0,p0,a1,t1,p1){var s0=SS[0],s1=SS[1],s2=SS[2],t0p0=t0[0],t0p1=t0[1],t0p2=t0[2],t1p0=t1[0],t1p1=t1[1],t1p2=t1[2];p0|=0;p1|=0;var offset0=p0;var offset1=p1;for(var j0=SS[2]|0;j0>0;){if(j0<64){s2=j0;j0=0;}else{s2=64;j0-=64;}for(var j1=SS[0]|0;j1>0;){if(j1<64){s0=j1;j1=0;}else{s0=64;j1-=64;}for(var j2=SS[1]|0;j2>0;){if(j2<64){s1=j2;j2=0;}else{s1=64;j2-=64;}p0=offset0+j0*t0p2+j1*t0p0+j2*t0p1;p1=offset1+j0*t1p2+j1*t1p0+j2*t1p1;var i0=0,i1=0,i2=0,d0s0=t0p2,d0s1=t0p0-s2*t0p2,d0s2=t0p1-s0*t0p0,d1s0=t1p2,d1s1=t1p0-s2*t1p2,d1s2=t1p1-s0*t1p0;for(i2=0;i2<s1;++i2){for(i1=0;i1<s0;++i1){for(i0=0;i0<s2;++i0){a0[p0]=a1[p1];p0+=d0s0;p1+=d1s0;}p0+=d0s1;p1+=d1s1;}p0+=d0s2;p1+=d1s2;}}}}};},'uint8,2,0,1,array,2,0,1':function(){return function assign_cwise_loop_2s0s1m3u8a(SS,a0,t0,p0,a1,t1,p1){var s0=SS[0],s1=SS[1],s2=SS[2],t0p0=t0[0],t0p1=t0[1],t0p2=t0[2],t1p0=t1[0],t1p1=t1[1],t1p2=t1[2];p0|=0;p1|=0;var i0=0,i1=0,i2=0,d0s0=t0p2,d0s1=t0p0-s2*t0p2,d0s2=t0p1-s0*t0p0,d1s0=t1p2,d1s1=t1p0-s2*t1p2,d1s2=t1p1-s0*t1p0;for(i2=0;i2<s1;++i2){for(i1=0;i1<s0;++i1){for(i0=0;i0<s2;++i0){a0[p0]=a1[p1];p0+=d0s0;p1+=d1s0;}p0+=d0s1;p1+=d1s1;}p0+=d0s2;p1+=d1s2;}};}};//Generates a cwise operator
function generateCWiseOp(proc,typesig){var key=typesig.join(',');var f=CACHED_CWiseOp[key];return f();}var compile=generateCWiseOp;var CACHED_thunk={mul:function(compile){var CACHED={};return function mul_cwise_thunk(array0,array1,array2){var t0=array0.dtype,r0=array0.order,t1=array1.dtype,r1=array1.order,t2=array2.dtype,r2=array2.order,type=[t0,r0.join(),t1,r1.join(),t2,r2.join()].join(),proc=CACHED[type];if(!proc){CACHED[type]=proc=compile([t0,r0,t1,r1,t2,r2]);}return proc(array0.shape.slice(0),array0.data,array0.stride,array0.offset|0,array1.data,array1.stride,array1.offset|0,array2.data,array2.stride,array2.offset|0);};},muls:function(compile){var CACHED={};return function muls_cwise_thunk(array0,array1,scalar2){var t0=array0.dtype,r0=array0.order,t1=array1.dtype,r1=array1.order,type=[t0,r0.join(),t1,r1.join()].join(),proc=CACHED[type];if(!proc){CACHED[type]=proc=compile([t0,r0,t1,r1]);}return proc(array0.shape.slice(0),array0.data,array0.stride,array0.offset|0,array1.data,array1.stride,array1.offset|0,scalar2);};},mulseq:function(compile){var CACHED={};return function mulseq_cwise_thunk(array0,scalar1){var t0=array0.dtype,r0=array0.order,type=[t0,r0.join()].join(),proc=CACHED[type];if(!proc){CACHED[type]=proc=compile([t0,r0]);}return proc(array0.shape.slice(0),array0.data,array0.stride,array0.offset|0,scalar1);};},div:function(compile){var CACHED={};return function div_cwise_thunk(array0,array1,array2){var t0=array0.dtype,r0=array0.order,t1=array1.dtype,r1=array1.order,t2=array2.dtype,r2=array2.order,type=[t0,r0.join(),t1,r1.join(),t2,r2.join()].join(),proc=CACHED[type];if(!proc){CACHED[type]=proc=compile([t0,r0,t1,r1,t2,r2]);}return proc(array0.shape.slice(0),array0.data,array0.stride,array0.offset|0,array1.data,array1.stride,array1.offset|0,array2.data,array2.stride,array2.offset|0);};},divs:function(compile){var CACHED={};return function divs_cwise_thunk(array0,array1,scalar2){var t0=array0.dtype,r0=array0.order,t1=array1.dtype,r1=array1.order,type=[t0,r0.join(),t1,r1.join()].join(),proc=CACHED[type];if(!proc){CACHED[type]=proc=compile([t0,r0,t1,r1]);}return proc(array0.shape.slice(0),array0.data,array0.stride,array0.offset|0,array1.data,array1.stride,array1.offset|0,scalar2);};},divseq:function(compile){var CACHED={};return function divseq_cwise_thunk(array0,scalar1){var t0=array0.dtype,r0=array0.order,type=[t0,r0.join()].join(),proc=CACHED[type];if(!proc){CACHED[type]=proc=compile([t0,r0]);}return proc(array0.shape.slice(0),array0.data,array0.stride,array0.offset|0,scalar1);};},assign:function(compile){var CACHED={};return function assign_cwise_thunk(array0,array1){var t0=array0.dtype,r0=array0.order,t1=array1.dtype,r1=array1.order,type=[t0,r0.join(),t1,r1.join()].join(),proc=CACHED[type];if(!proc){CACHED[type]=proc=compile([t0,r0,t1,r1]);}return proc(array0.shape.slice(0),array0.data,array0.stride,array0.offset|0,array1.data,array1.stride,array1.offset|0);};}};function createThunk(proc){var thunk=CACHED_thunk[proc.funcName];return thunk(compile.bind(undefined,proc));}function makeOp(user_args){return createThunk({funcName:user_args.funcName});}var assign_ops={mul:"*",div:"/"};(function(){for(var id in assign_ops){exports[id]=makeOp({funcName:id});exports[id+"s"]=makeOp({funcName:id+"s"});exports[id+"seq"]=makeOp({funcName:id+"seq"});}})();exports.assign=makeOp({funcName:"assign"});/***/},/***/7382:/***/function(module,__unused_webpack_exports,__nested_webpack_require_685580__){"use strict";var ndarray=__nested_webpack_require_685580__(5050);var do_convert=__nested_webpack_require_685580__(9262);module.exports=function convert(arr,result){var shape=[],c=arr,sz=1;while(Array.isArray(c)){shape.push(c.length);sz*=c.length;c=c[0];}if(shape.length===0){return ndarray();}if(!result){result=ndarray(new Float64Array(sz),shape);}do_convert(result,arr);return result;};/***/},/***/9262:/***/function(module){"use strict";function CwiseOp(){return function(SS,a0,t0,p0,Y0){var s0=SS[0],s1=SS[1],s2=SS[2],t0p0=t0[0],t0p1=t0[1],t0p2=t0[2],index=[0,0,0];p0|=0;var i0=0,i1=0,i2=0,d0s0=t0p2,d0s1=t0p1-s2*t0p2,d0s2=t0p0-s1*t0p1;for(i2=0;i2<s0;++i2){for(i1=0;i1<s1;++i1){for(i0=0;i0<s2;++i0){{var _inline_1_v=Y0,_inline_1_i;for(_inline_1_i=0;_inline_1_i<index.length-1;++_inline_1_i){_inline_1_v=_inline_1_v[index[_inline_1_i]];}a0[p0]=_inline_1_v[index[index.length-1]];}p0+=d0s0;++index[2];}p0+=d0s1;index[2]-=s2;++index[1];}p0+=d0s2;index[1]-=s1;++index[0];}};}//Generates a cwise operator
function generateCWiseOp(){return CwiseOp();}var compile=generateCWiseOp;function thunk(compile){var CACHED={};return function convert_cwise_thunk(array0,scalar1){var t0=array0.dtype,r0=array0.order,type=[t0,r0.join()].join(),proc=CACHED[type];if(!proc){CACHED[type]=proc=compile([t0,r0]);}return proc(array0.shape.slice(0),array0.data,array0.stride,array0.offset|0,scalar1);};}function createThunk(proc){return thunk(compile.bind(undefined,proc));}function compileCwise(user_args){return createThunk({funcName:user_args.funcName});}module.exports=compileCwise({funcName:"convert"});/***/},/***/8139:/***/function(module,__unused_webpack_exports,__nested_webpack_require_687223__){"use strict";var pool=__nested_webpack_require_687223__(5306);function getMallocFree(dtype){switch(dtype){case"uint32":return[pool.mallocUint32,pool.freeUint32];default:return null;}}var CACHED_insertionSort={"uint32,1,0":function(malloc,free){return function ndarrayInsertionSort1d0uint32(left,right,data,offset,s0,s1,n0,n1,d1,e1,f1){var i,j,cptr,ptr=left*s0+offset,i1,scratch=malloc(n1),dptr,sptr,a,b;for(i=left+1;i<=right;++i){j=i;ptr+=s0;cptr=ptr;dptr=0;sptr=ptr;for(i1=0;i1<n1;++i1){scratch[dptr++]=data[sptr];sptr+=d1;}__g:while(j-->left){dptr=0;sptr=cptr-s0;__l:for(i1=0;i1<n1;++i1){a=data[sptr];b=scratch[dptr];if(a<b){break __g;}if(a>b){break __l;}sptr+=e1;dptr+=f1;}dptr=cptr;sptr=cptr-s0;for(i1=0;i1<n1;++i1){data[dptr]=data[sptr];dptr+=d1;sptr+=d1;}cptr-=s0;}dptr=cptr;sptr=0;for(i1=0;i1<n1;++i1){data[dptr]=scratch[sptr++];dptr+=d1;}}free(scratch);};}};function createInsertionSort(order,dtype){var allocator=getMallocFree(dtype);var key=[dtype,order].join(',');var result=CACHED_insertionSort[key];if(allocator){return result(allocator[0],allocator[1]);}else{return result();}}var CACHED_quickSort={"uint32,1,0":function(insertionSort,malloc,free){return function ndarrayQuickSort1d0uint32(left,right,data,offset,s0,s1,n0,n1,d1,e1,f1){var sixth=(right-left+1)/6|0,index1=left+sixth,index5=right-sixth,index3=left+right>>1,index2=index3-sixth,index4=index3+sixth,el1=index1,el2=index2,el3=index3,el4=index4,el5=index5,less=left+1,great=right-1,pivots_are_equal=true,tmp,tmp0,x,y,z,k,ptr0,ptr1,ptr2,comp_pivot1=0,comp_pivot2=0,comp=0,i1,b_ptr0,b_ptr1,b_ptr2,b_ptr3,b_ptr4,b_ptr5,b_ptr6,b_ptr7,ptr3,ptr4,ptr5,ptr6,ptr7,pivot_ptr,ptr_shift,elementSize=n1,pivot1=malloc(elementSize),pivot2=malloc(elementSize);b_ptr0=s0*el1;b_ptr1=s0*el2;ptr_shift=offset;__l1:for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;comp=data[ptr0]-data[ptr1];if(comp>0){tmp0=el1;el1=el2;el2=tmp0;break __l1;}if(comp<0){break __l1;}ptr_shift+=e1;}b_ptr0=s0*el4;b_ptr1=s0*el5;ptr_shift=offset;__l2:for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;comp=data[ptr0]-data[ptr1];if(comp>0){tmp0=el4;el4=el5;el5=tmp0;break __l2;}if(comp<0){break __l2;}ptr_shift+=e1;}b_ptr0=s0*el1;b_ptr1=s0*el3;ptr_shift=offset;__l3:for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;comp=data[ptr0]-data[ptr1];if(comp>0){tmp0=el1;el1=el3;el3=tmp0;break __l3;}if(comp<0){break __l3;}ptr_shift+=e1;}b_ptr0=s0*el2;b_ptr1=s0*el3;ptr_shift=offset;__l4:for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;comp=data[ptr0]-data[ptr1];if(comp>0){tmp0=el2;el2=el3;el3=tmp0;break __l4;}if(comp<0){break __l4;}ptr_shift+=e1;}b_ptr0=s0*el1;b_ptr1=s0*el4;ptr_shift=offset;__l5:for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;comp=data[ptr0]-data[ptr1];if(comp>0){tmp0=el1;el1=el4;el4=tmp0;break __l5;}if(comp<0){break __l5;}ptr_shift+=e1;}b_ptr0=s0*el3;b_ptr1=s0*el4;ptr_shift=offset;__l6:for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;comp=data[ptr0]-data[ptr1];if(comp>0){tmp0=el3;el3=el4;el4=tmp0;break __l6;}if(comp<0){break __l6;}ptr_shift+=e1;}b_ptr0=s0*el2;b_ptr1=s0*el5;ptr_shift=offset;__l7:for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;comp=data[ptr0]-data[ptr1];if(comp>0){tmp0=el2;el2=el5;el5=tmp0;break __l7;}if(comp<0){break __l7;}ptr_shift+=e1;}b_ptr0=s0*el2;b_ptr1=s0*el3;ptr_shift=offset;__l8:for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;comp=data[ptr0]-data[ptr1];if(comp>0){tmp0=el2;el2=el3;el3=tmp0;break __l8;}if(comp<0){break __l8;}ptr_shift+=e1;}b_ptr0=s0*el4;b_ptr1=s0*el5;ptr_shift=offset;__l9:for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;comp=data[ptr0]-data[ptr1];if(comp>0){tmp0=el4;el4=el5;el5=tmp0;break __l9;}if(comp<0){break __l9;}ptr_shift+=e1;}b_ptr0=s0*el1;b_ptr1=s0*el2;b_ptr2=s0*el3;b_ptr3=s0*el4;b_ptr4=s0*el5;b_ptr5=s0*index1;b_ptr6=s0*index3;b_ptr7=s0*index5;pivot_ptr=0;ptr_shift=offset;for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;ptr2=b_ptr2+ptr_shift;ptr3=b_ptr3+ptr_shift;ptr4=b_ptr4+ptr_shift;ptr5=b_ptr5+ptr_shift;ptr6=b_ptr6+ptr_shift;ptr7=b_ptr7+ptr_shift;pivot1[pivot_ptr]=data[ptr1];pivot2[pivot_ptr]=data[ptr3];pivots_are_equal=pivots_are_equal&&pivot1[pivot_ptr]===pivot2[pivot_ptr];x=data[ptr0];y=data[ptr2];z=data[ptr4];data[ptr5]=x;data[ptr6]=y;data[ptr7]=z;++pivot_ptr;ptr_shift+=d1;}b_ptr0=s0*index2;b_ptr1=s0*left;ptr_shift=offset;for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;data[ptr0]=data[ptr1];ptr_shift+=d1;}b_ptr0=s0*index4;b_ptr1=s0*right;ptr_shift=offset;for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;data[ptr0]=data[ptr1];ptr_shift+=d1;}if(pivots_are_equal){for(k=less;k<=great;++k){ptr0=offset+k*s0;pivot_ptr=0;__l10:for(i1=0;i1<n1;++i1){comp=data[ptr0]-pivot1[pivot_ptr];if(comp!==0){break __l10;}pivot_ptr+=f1;ptr0+=e1;}if(comp===0){continue;}if(comp<0){if(k!==less){b_ptr0=s0*k;b_ptr1=s0*less;ptr_shift=offset;for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;tmp=data[ptr0];data[ptr0]=data[ptr1];data[ptr1]=tmp;ptr_shift+=d1;}}++less;}else{while(true){ptr0=offset+great*s0;pivot_ptr=0;__l11:for(i1=0;i1<n1;++i1){comp=data[ptr0]-pivot1[pivot_ptr];if(comp!==0){break __l11;}pivot_ptr+=f1;ptr0+=e1;}if(comp>0){great--;}else if(comp<0){b_ptr0=s0*k;b_ptr1=s0*less;b_ptr2=s0*great;ptr_shift=offset;for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;ptr2=b_ptr2+ptr_shift;tmp=data[ptr0];data[ptr0]=data[ptr1];data[ptr1]=data[ptr2];data[ptr2]=tmp;ptr_shift+=d1;}++less;--great;break;}else{b_ptr0=s0*k;b_ptr1=s0*great;ptr_shift=offset;for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;tmp=data[ptr0];data[ptr0]=data[ptr1];data[ptr1]=tmp;ptr_shift+=d1;}--great;break;}}}}}else{for(k=less;k<=great;++k){ptr0=offset+k*s0;pivot_ptr=0;__l12:for(i1=0;i1<n1;++i1){comp_pivot1=data[ptr0]-pivot1[pivot_ptr];if(comp_pivot1!==0){break __l12;}pivot_ptr+=f1;ptr0+=e1;}if(comp_pivot1<0){if(k!==less){b_ptr0=s0*k;b_ptr1=s0*less;ptr_shift=offset;for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;tmp=data[ptr0];data[ptr0]=data[ptr1];data[ptr1]=tmp;ptr_shift+=d1;}}++less;}else{ptr0=offset+k*s0;pivot_ptr=0;__l13:for(i1=0;i1<n1;++i1){comp_pivot2=data[ptr0]-pivot2[pivot_ptr];if(comp_pivot2!==0){break __l13;}pivot_ptr+=f1;ptr0+=e1;}if(comp_pivot2>0){while(true){ptr0=offset+great*s0;pivot_ptr=0;__l14:for(i1=0;i1<n1;++i1){comp=data[ptr0]-pivot2[pivot_ptr];if(comp!==0){break __l14;}pivot_ptr+=f1;ptr0+=e1;}if(comp>0){if(--great<k){break;}continue;}else{ptr0=offset+great*s0;pivot_ptr=0;__l15:for(i1=0;i1<n1;++i1){comp=data[ptr0]-pivot1[pivot_ptr];if(comp!==0){break __l15;}pivot_ptr+=f1;ptr0+=e1;}if(comp<0){b_ptr0=s0*k;b_ptr1=s0*less;b_ptr2=s0*great;ptr_shift=offset;for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;ptr2=b_ptr2+ptr_shift;tmp=data[ptr0];data[ptr0]=data[ptr1];data[ptr1]=data[ptr2];data[ptr2]=tmp;ptr_shift+=d1;}++less;--great;}else{b_ptr0=s0*k;b_ptr1=s0*great;ptr_shift=offset;for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;tmp=data[ptr0];data[ptr0]=data[ptr1];data[ptr1]=tmp;ptr_shift+=d1;}--great;}break;}}}}}}b_ptr0=s0*left;b_ptr1=s0*(less-1);pivot_ptr=0;ptr_shift=offset;for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;data[ptr0]=data[ptr1];data[ptr1]=pivot1[pivot_ptr];++pivot_ptr;ptr_shift+=d1;}b_ptr0=s0*right;b_ptr1=s0*(great+1);pivot_ptr=0;ptr_shift=offset;for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;data[ptr0]=data[ptr1];data[ptr1]=pivot2[pivot_ptr];++pivot_ptr;ptr_shift+=d1;}if(less-2-left<=32){insertionSort(left,less-2,data,offset,s0,s1,n0,n1,d1,e1,f1);}else{ndarrayQuickSort1d0uint32(left,less-2,data,offset,s0,s1,n0,n1,d1,e1,f1);}if(right-(great+2)<=32){insertionSort(great+2,right,data,offset,s0,s1,n0,n1,d1,e1,f1);}else{ndarrayQuickSort1d0uint32(great+2,right,data,offset,s0,s1,n0,n1,d1,e1,f1);}if(pivots_are_equal){free(pivot1);free(pivot2);return;}if(less<index1&&great>index5){__l16:while(true){ptr0=offset+less*s0;pivot_ptr=0;ptr_shift=offset;for(i1=0;i1<n1;++i1){if(data[ptr0]!==pivot1[pivot_ptr]){break __l16;}++pivot_ptr;ptr0+=d1;}++less;}__l17:while(true){ptr0=offset+great*s0;pivot_ptr=0;ptr_shift=offset;for(i1=0;i1<n1;++i1){if(data[ptr0]!==pivot2[pivot_ptr]){break __l17;}++pivot_ptr;ptr0+=d1;}--great;}for(k=less;k<=great;++k){ptr0=offset+k*s0;pivot_ptr=0;__l18:for(i1=0;i1<n1;++i1){comp_pivot1=data[ptr0]-pivot1[pivot_ptr];if(comp_pivot1!==0){break __l18;}pivot_ptr+=f1;ptr0+=e1;}if(comp_pivot1===0){if(k!==less){b_ptr0=s0*k;b_ptr1=s0*less;ptr_shift=offset;for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;tmp=data[ptr0];data[ptr0]=data[ptr1];data[ptr1]=tmp;ptr_shift+=d1;}}++less;}else{ptr0=offset+k*s0;pivot_ptr=0;__l19:for(i1=0;i1<n1;++i1){comp_pivot2=data[ptr0]-pivot2[pivot_ptr];if(comp_pivot2!==0){break __l19;}pivot_ptr+=f1;ptr0+=e1;}if(comp_pivot2===0){while(true){ptr0=offset+great*s0;pivot_ptr=0;__l20:for(i1=0;i1<n1;++i1){comp=data[ptr0]-pivot2[pivot_ptr];if(comp!==0){break __l20;}pivot_ptr+=f1;ptr0+=e1;}if(comp===0){if(--great<k){break;}continue;}else{ptr0=offset+great*s0;pivot_ptr=0;__l21:for(i1=0;i1<n1;++i1){comp=data[ptr0]-pivot1[pivot_ptr];if(comp!==0){break __l21;}pivot_ptr+=f1;ptr0+=e1;}if(comp<0){b_ptr0=s0*k;b_ptr1=s0*less;b_ptr2=s0*great;ptr_shift=offset;for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;ptr2=b_ptr2+ptr_shift;tmp=data[ptr0];data[ptr0]=data[ptr1];data[ptr1]=data[ptr2];data[ptr2]=tmp;ptr_shift+=d1;}++less;--great;}else{b_ptr0=s0*k;b_ptr1=s0*great;ptr_shift=offset;for(i1=0;i1<n1;++i1){ptr0=b_ptr0+ptr_shift;ptr1=b_ptr1+ptr_shift;tmp=data[ptr0];data[ptr0]=data[ptr1];data[ptr1]=tmp;ptr_shift+=d1;}--great;}break;}}}}}}free(pivot1);free(pivot2);if(great-less<=32){insertionSort(less,great,data,offset,s0,s1,n0,n1,d1,e1,f1);}else{ndarrayQuickSort1d0uint32(less,great,data,offset,s0,s1,n0,n1,d1,e1,f1);}};}};function createQuickSort(order,dtype,insertionSort){var allocator=getMallocFree(dtype);var key=[dtype,order].join(',');var result=CACHED_quickSort[key];if(order.length>1&&allocator){return result(insertionSort,allocator[0],allocator[1]);}else{return result(insertionSort);}}var CACHED_sort={"uint32,1,0":function(insertionSort,quickSort){return function(array){var data=array.data,offset=array.offset|0,shape=array.shape,stride=array.stride,s0=stride[0]|0,n0=shape[0]|0,s1=stride[1]|0,n1=shape[1]|0,d1=s1,e1=s1,f1=1;if(n0<=32){insertionSort(0,n0-1,data,offset,s0,s1,n0,n1,d1,e1,f1);}else{quickSort(0,n0-1,data,offset,s0,s1,n0,n1,d1,e1,f1);}};}};function compileSort(order,dtype){var key=[dtype,order].join(',');var result=CACHED_sort[key];var insertionSort=createInsertionSort(order,dtype);var quickSort=createQuickSort(order,dtype,insertionSort);return result(insertionSort,quickSort);}module.exports=compileSort;/***/},/***/8729:/***/function(module,__unused_webpack_exports,__nested_webpack_require_698074__){"use strict";var compile=__nested_webpack_require_698074__(8139);var CACHE={};function sort(array){var order=array.order;var dtype=array.dtype;var typeSig=[order,dtype];var typeName=typeSig.join(":");var compiled=CACHE[typeName];if(!compiled){CACHE[typeName]=compiled=compile(order,dtype);}compiled(array);return array;}module.exports=sort;/***/},/***/5050:/***/function(module,__unused_webpack_exports,__nested_webpack_require_698484__){var isBuffer=__nested_webpack_require_698484__(4780);var hasTypedArrays=typeof Float64Array!=="undefined";function compare1st(a,b){return a[0]-b[0];}function order(){var stride=this.stride;var terms=new Array(stride.length);var i;for(i=0;i<terms.length;++i){terms[i]=[Math.abs(stride[i]),i];}terms.sort(compare1st);var result=new Array(terms.length);for(i=0;i<result.length;++i){result[i]=terms[i][1];}return result;}var allFns={// Special case for trivial arrays
T:function(dtype){function View(a){this.data=a;}var proto=View.prototype;proto.dtype=dtype;proto.index=function(){return-1;};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new View(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null;};return function construct(a){return new View(a);};},// Special case for 0d arrays
0:function(dtype,TrivialArray){function View(a,d){this.data=a;this.offset=d;}var proto=View.prototype;proto.dtype=dtype;proto.index=function(){return this.offset;};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function copy(){return new View(this.data,this.offset);};proto.pick=function pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function get(){return dtype==="generic"?this.data.get(this.offset):this.data[this.offset];};proto.set=function set(v){return dtype==="generic"?this.data.set(this.offset,v):this.data[this.offset]=v;};return function construct(a,b,c,d){return new View(a,d);};},1:function(dtype,CTOR_LIST,ORDER){function View(a,b0,c0,d){this.data=a;this.shape=[b0];this.stride=[c0];this.offset=d|0;}var proto=View.prototype;proto.dtype=dtype;proto.dimension=1;Object.defineProperty(proto,"size",{get:function size(){return this.shape[0];}});proto.order=[0];proto.set=function set(i0,v){return dtype==="generic"?this.data.set(this.offset+this.stride[0]*i0,v):this.data[this.offset+this.stride[0]*i0]=v;};proto.get=function get(i0){return dtype==="generic"?this.data.get(this.offset+this.stride[0]*i0):this.data[this.offset+this.stride[0]*i0];};proto.index=function index(i0){return this.offset+this.stride[0]*i0;};proto.hi=function hi(i0){return new View(this.data,typeof i0!=="number"||i0<0?this.shape[0]:i0|0,this.stride[0],this.offset);};proto.lo=function lo(i0){var b=this.offset,d=0,a0=this.shape[0],c0=this.stride[0];if(typeof i0==="number"&&i0>=0){d=i0|0;b+=c0*d;a0-=d;}return new View(this.data,a0,c0,b);};proto.step=function step(i0){var a0=this.shape[0],b0=this.stride[0],c=this.offset,d=0,ceil=Math.ceil;if(typeof i0==="number"){d=i0|0;if(d<0){c+=b0*(a0-1);a0=ceil(-a0/d);}else{a0=ceil(a0/d);}b0*=d;}return new View(this.data,a0,b0,c);};proto.transpose=function transpose(i0){i0=i0===undefined?0:i0|0;var a=this.shape,b=this.stride;return new View(this.data,a[i0],b[i0],this.offset);};proto.pick=function pick(i0){var a=[],b=[],c=this.offset;if(typeof i0==="number"&&i0>=0){c=c+this.stride[0]*i0|0;}else{a.push(this.shape[0]);b.push(this.stride[0]);}var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c);};return function construct(data,shape,stride,offset){return new View(data,shape[0],stride[0],offset);};},2:function(dtype,CTOR_LIST,ORDER){function View(a,b0,b1,c0,c1,d){this.data=a;this.shape=[b0,b1];this.stride=[c0,c1];this.offset=d|0;}var proto=View.prototype;proto.dtype=dtype;proto.dimension=2;Object.defineProperty(proto,"size",{get:function size(){return this.shape[0]*this.shape[1];}});Object.defineProperty(proto,"order",{get:function order(){return Math.abs(this.stride[0])>Math.abs(this.stride[1])?[1,0]:[0,1];}});proto.set=function set(i0,i1,v){return dtype==="generic"?this.data.set(this.offset+this.stride[0]*i0+this.stride[1]*i1,v):this.data[this.offset+this.stride[0]*i0+this.stride[1]*i1]=v;};proto.get=function get(i0,i1){return dtype==="generic"?this.data.get(this.offset+this.stride[0]*i0+this.stride[1]*i1):this.data[this.offset+this.stride[0]*i0+this.stride[1]*i1];};proto.index=function index(i0,i1){return this.offset+this.stride[0]*i0+this.stride[1]*i1;};proto.hi=function hi(i0,i1){return new View(this.data,typeof i0!=="number"||i0<0?this.shape[0]:i0|0,typeof i1!=="number"||i1<0?this.shape[1]:i1|0,this.stride[0],this.stride[1],this.offset);};proto.lo=function lo(i0,i1){var b=this.offset,d=0,a0=this.shape[0],a1=this.shape[1],c0=this.stride[0],c1=this.stride[1];if(typeof i0==="number"&&i0>=0){d=i0|0;b+=c0*d;a0-=d;}if(typeof i1==="number"&&i1>=0){d=i1|0;b+=c1*d;a1-=d;}return new View(this.data,a0,a1,c0,c1,b);};proto.step=function step(i0,i1){var a0=this.shape[0],a1=this.shape[1],b0=this.stride[0],b1=this.stride[1],c=this.offset,d=0,ceil=Math.ceil;if(typeof i0==="number"){d=i0|0;if(d<0){c+=b0*(a0-1);a0=ceil(-a0/d);}else{a0=ceil(a0/d);}b0*=d;}if(typeof i1==="number"){d=i1|0;if(d<0){c+=b1*(a1-1);a1=ceil(-a1/d);}else{a1=ceil(a1/d);}b1*=d;}return new View(this.data,a0,a1,b0,b1,c);};proto.transpose=function transpose(i0,i1){i0=i0===undefined?0:i0|0;i1=i1===undefined?1:i1|0;var a=this.shape,b=this.stride;return new View(this.data,a[i0],a[i1],b[i0],b[i1],this.offset);};proto.pick=function pick(i0,i1){var a=[],b=[],c=this.offset;if(typeof i0==="number"&&i0>=0){c=c+this.stride[0]*i0|0;}else{a.push(this.shape[0]);b.push(this.stride[0]);}if(typeof i1==="number"&&i1>=0){c=c+this.stride[1]*i1|0;}else{a.push(this.shape[1]);b.push(this.stride[1]);}var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c);};return function construct(data,shape,stride,offset){return new View(data,shape[0],shape[1],stride[0],stride[1],offset);};},3:function(dtype,CTOR_LIST,ORDER){function View(a,b0,b1,b2,c0,c1,c2,d){this.data=a;this.shape=[b0,b1,b2];this.stride=[c0,c1,c2];this.offset=d|0;}var proto=View.prototype;proto.dtype=dtype;proto.dimension=3;Object.defineProperty(proto,"size",{get:function size(){return this.shape[0]*this.shape[1]*this.shape[2];}});Object.defineProperty(proto,"order",{get:function order(){var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return[2,1,0];}else if(s0>s2){return[1,2,0];}else{return[1,0,2];}}else if(s0>s2){return[2,0,1];}else if(s2>s1){return[0,1,2];}else{return[0,2,1];}}});proto.set=function set(i0,i1,i2,v){return dtype==="generic"?this.data.set(this.offset+this.stride[0]*i0+this.stride[1]*i1+this.stride[2]*i2,v):this.data[this.offset+this.stride[0]*i0+this.stride[1]*i1+this.stride[2]*i2]=v;};proto.get=function get(i0,i1,i2){return dtype==="generic"?this.data.get(this.offset+this.stride[0]*i0+this.stride[1]*i1+this.stride[2]*i2):this.data[this.offset+this.stride[0]*i0+this.stride[1]*i1+this.stride[2]*i2];};proto.index=function index(i0,i1,i2){return this.offset+this.stride[0]*i0+this.stride[1]*i1+this.stride[2]*i2;};proto.hi=function hi(i0,i1,i2){return new View(this.data,typeof i0!=="number"||i0<0?this.shape[0]:i0|0,typeof i1!=="number"||i1<0?this.shape[1]:i1|0,typeof i2!=="number"||i2<0?this.shape[2]:i2|0,this.stride[0],this.stride[1],this.stride[2],this.offset);};proto.lo=function lo(i0,i1,i2){var b=this.offset,d=0,a0=this.shape[0],a1=this.shape[1],a2=this.shape[2],c0=this.stride[0],c1=this.stride[1],c2=this.stride[2];if(typeof i0==="number"&&i0>=0){d=i0|0;b+=c0*d;a0-=d;}if(typeof i1==="number"&&i1>=0){d=i1|0;b+=c1*d;a1-=d;}if(typeof i2==="number"&&i2>=0){d=i2|0;b+=c2*d;a2-=d;}return new View(this.data,a0,a1,a2,c0,c1,c2,b);};proto.step=function step(i0,i1,i2){var a0=this.shape[0],a1=this.shape[1],a2=this.shape[2],b0=this.stride[0],b1=this.stride[1],b2=this.stride[2],c=this.offset,d=0,ceil=Math.ceil;if(typeof i0==="number"){d=i0|0;if(d<0){c+=b0*(a0-1);a0=ceil(-a0/d);}else{a0=ceil(a0/d);}b0*=d;}if(typeof i1==="number"){d=i1|0;if(d<0){c+=b1*(a1-1);a1=ceil(-a1/d);}else{a1=ceil(a1/d);}b1*=d;}if(typeof i2==="number"){d=i2|0;if(d<0){c+=b2*(a2-1);a2=ceil(-a2/d);}else{a2=ceil(a2/d);}b2*=d;}return new View(this.data,a0,a1,a2,b0,b1,b2,c);};proto.transpose=function transpose(i0,i1,i2){i0=i0===undefined?0:i0|0;i1=i1===undefined?1:i1|0;i2=i2===undefined?2:i2|0;var a=this.shape,b=this.stride;return new View(this.data,a[i0],a[i1],a[i2],b[i0],b[i1],b[i2],this.offset);};proto.pick=function pick(i0,i1,i2){var a=[],b=[],c=this.offset;if(typeof i0==="number"&&i0>=0){c=c+this.stride[0]*i0|0;}else{a.push(this.shape[0]);b.push(this.stride[0]);}if(typeof i1==="number"&&i1>=0){c=c+this.stride[1]*i1|0;}else{a.push(this.shape[1]);b.push(this.stride[1]);}if(typeof i2==="number"&&i2>=0){c=c+this.stride[2]*i2|0;}else{a.push(this.shape[2]);b.push(this.stride[2]);}var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c);};return function construct(data,shape,stride,offset){return new View(data,shape[0],shape[1],shape[2],stride[0],stride[1],stride[2],offset);};},4:function(dtype,CTOR_LIST,ORDER){function View(a,b0,b1,b2,b3,c0,c1,c2,c3,d){this.data=a;this.shape=[b0,b1,b2,b3];this.stride=[c0,c1,c2,c3];this.offset=d|0;}var proto=View.prototype;proto.dtype=dtype;proto.dimension=4;Object.defineProperty(proto,"size",{get:function size(){return this.shape[0]*this.shape[1]*this.shape[2]*this.shape[3];}});Object.defineProperty(proto,"order",{get:ORDER});proto.set=function set(i0,i1,i2,i3,v){return dtype==="generic"?this.data.set(this.offset+this.stride[0]*i0+this.stride[1]*i1+this.stride[2]*i2+this.stride[3]*i3,v):this.data[this.offset+this.stride[0]*i0+this.stride[1]*i1+this.stride[2]*i2+this.stride[3]*i3]=v;};proto.get=function get(i0,i1,i2,i3){return dtype==="generic"?this.data.get(this.offset+this.stride[0]*i0+this.stride[1]*i1+this.stride[2]*i2+this.stride[3]*i3):this.data[this.offset+this.stride[0]*i0+this.stride[1]*i1+this.stride[2]*i2+this.stride[3]*i3];};proto.index=function index(i0,i1,i2,i3){return this.offset+this.stride[0]*i0+this.stride[1]*i1+this.stride[2]*i2+this.stride[3]*i3;};proto.hi=function hi(i0,i1,i2,i3){return new View(this.data,typeof i0!=="number"||i0<0?this.shape[0]:i0|0,typeof i1!=="number"||i1<0?this.shape[1]:i1|0,typeof i2!=="number"||i2<0?this.shape[2]:i2|0,typeof i3!=="number"||i3<0?this.shape[3]:i3|0,this.stride[0],this.stride[1],this.stride[2],this.stride[3],this.offset);};proto.lo=function lo(i0,i1,i2,i3){var b=this.offset,d=0,a0=this.shape[0],a1=this.shape[1],a2=this.shape[2],a3=this.shape[3],c0=this.stride[0],c1=this.stride[1],c2=this.stride[2],c3=this.stride[3];if(typeof i0==="number"&&i0>=0){d=i0|0;b+=c0*d;a0-=d;}if(typeof i1==="number"&&i1>=0){d=i1|0;b+=c1*d;a1-=d;}if(typeof i2==="number"&&i2>=0){d=i2|0;b+=c2*d;a2-=d;}if(typeof i3==="number"&&i3>=0){d=i3|0;b+=c3*d;a3-=d;}return new View(this.data,a0,a1,a2,a3,c0,c1,c2,c3,b);};proto.step=function step(i0,i1,i2,i3){var a0=this.shape[0],a1=this.shape[1],a2=this.shape[2],a3=this.shape[3],b0=this.stride[0],b1=this.stride[1],b2=this.stride[2],b3=this.stride[3],c=this.offset,d=0,ceil=Math.ceil;if(typeof i0==="number"){d=i0|0;if(d<0){c+=b0*(a0-1);a0=ceil(-a0/d);}else{a0=ceil(a0/d);}b0*=d;}if(typeof i1==="number"){d=i1|0;if(d<0){c+=b1*(a1-1);a1=ceil(-a1/d);}else{a1=ceil(a1/d);}b1*=d;}if(typeof i2==="number"){d=i2|0;if(d<0){c+=b2*(a2-1);a2=ceil(-a2/d);}else{a2=ceil(a2/d);}b2*=d;}if(typeof i3==="number"){d=i3|0;if(d<0){c+=b3*(a3-1);a3=ceil(-a3/d);}else{a3=ceil(a3/d);}b3*=d;}return new View(this.data,a0,a1,a2,a3,b0,b1,b2,b3,c);};proto.transpose=function transpose(i0,i1,i2,i3){i0=i0===undefined?0:i0|0;i1=i1===undefined?1:i1|0;i2=i2===undefined?2:i2|0;i3=i3===undefined?3:i3|0;var a=this.shape,b=this.stride;return new View(this.data,a[i0],a[i1],a[i2],a[i3],b[i0],b[i1],b[i2],b[i3],this.offset);};proto.pick=function pick(i0,i1,i2,i3){var a=[],b=[],c=this.offset;if(typeof i0==="number"&&i0>=0){c=c+this.stride[0]*i0|0;}else{a.push(this.shape[0]);b.push(this.stride[0]);}if(typeof i1==="number"&&i1>=0){c=c+this.stride[1]*i1|0;}else{a.push(this.shape[1]);b.push(this.stride[1]);}if(typeof i2==="number"&&i2>=0){c=c+this.stride[2]*i2|0;}else{a.push(this.shape[2]);b.push(this.stride[2]);}if(typeof i3==="number"&&i3>=0){c=c+this.stride[3]*i3|0;}else{a.push(this.shape[3]);b.push(this.stride[3]);}var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c);};return function construct(data,shape,stride,offset){return new View(data,shape[0],shape[1],shape[2],shape[3],stride[0],stride[1],stride[2],stride[3],offset);};},5:function anonymous(dtype,CTOR_LIST,ORDER){function View(a,b0,b1,b2,b3,b4,c0,c1,c2,c3,c4,d){this.data=a;this.shape=[b0,b1,b2,b3,b4];this.stride=[c0,c1,c2,c3,c4];this.offset=d|0;}var proto=View.prototype;proto.dtype=dtype;proto.dimension=5;Object.defineProperty(proto,"size",{get:function size(){return this.shape[0]*this.shape[1]*this.shape[2]*this.shape[3]*this.shape[4];}});Object.defineProperty(proto,"order",{get:ORDER});proto.set=function set(i0,i1,i2,i3,i4,v){return dtype==="generic"?this.data.set(this.offset+this.stride[0]*i0+this.stride[1]*i1+this.stride[2]*i2+this.stride[3]*i3+this.stride[4]*i4,v):this.data[this.offset+this.stride[0]*i0+this.stride[1]*i1+this.stride[2]*i2+this.stride[3]*i3+this.stride[4]*i4]=v;};proto.get=function get(i0,i1,i2,i3,i4){return dtype==="generic"?this.data.get(this.offset+this.stride[0]*i0+this.stride[1]*i1+this.stride[2]*i2+this.stride[3]*i3+this.stride[4]*i4):this.data[this.offset+this.stride[0]*i0+this.stride[1]*i1+this.stride[2]*i2+this.stride[3]*i3+this.stride[4]*i4];};proto.index=function index(i0,i1,i2,i3,i4){return this.offset+this.stride[0]*i0+this.stride[1]*i1+this.stride[2]*i2+this.stride[3]*i3+this.stride[4]*i4;};proto.hi=function hi(i0,i1,i2,i3,i4){return new View(this.data,typeof i0!=="number"||i0<0?this.shape[0]:i0|0,typeof i1!=="number"||i1<0?this.shape[1]:i1|0,typeof i2!=="number"||i2<0?this.shape[2]:i2|0,typeof i3!=="number"||i3<0?this.shape[3]:i3|0,typeof i4!=="number"||i4<0?this.shape[4]:i4|0,this.stride[0],this.stride[1],this.stride[2],this.stride[3],this.stride[4],this.offset);};proto.lo=function lo(i0,i1,i2,i3,i4){var b=this.offset,d=0,a0=this.shape[0],a1=this.shape[1],a2=this.shape[2],a3=this.shape[3],a4=this.shape[4],c0=this.stride[0],c1=this.stride[1],c2=this.stride[2],c3=this.stride[3],c4=this.stride[4];if(typeof i0==="number"&&i0>=0){d=i0|0;b+=c0*d;a0-=d;}if(typeof i1==="number"&&i1>=0){d=i1|0;b+=c1*d;a1-=d;}if(typeof i2==="number"&&i2>=0){d=i2|0;b+=c2*d;a2-=d;}if(typeof i3==="number"&&i3>=0){d=i3|0;b+=c3*d;a3-=d;}if(typeof i4==="number"&&i4>=0){d=i4|0;b+=c4*d;a4-=d;}return new View(this.data,a0,a1,a2,a3,a4,c0,c1,c2,c3,c4,b);};proto.step=function step(i0,i1,i2,i3,i4){var a0=this.shape[0],a1=this.shape[1],a2=this.shape[2],a3=this.shape[3],a4=this.shape[4],b0=this.stride[0],b1=this.stride[1],b2=this.stride[2],b3=this.stride[3],b4=this.stride[4],c=this.offset,d=0,ceil=Math.ceil;if(typeof i0==="number"){d=i0|0;if(d<0){c+=b0*(a0-1);a0=ceil(-a0/d);}else{a0=ceil(a0/d);}b0*=d;}if(typeof i1==="number"){d=i1|0;if(d<0){c+=b1*(a1-1);a1=ceil(-a1/d);}else{a1=ceil(a1/d);}b1*=d;}if(typeof i2==="number"){d=i2|0;if(d<0){c+=b2*(a2-1);a2=ceil(-a2/d);}else{a2=ceil(a2/d);}b2*=d;}if(typeof i3==="number"){d=i3|0;if(d<0){c+=b3*(a3-1);a3=ceil(-a3/d);}else{a3=ceil(a3/d);}b3*=d;}if(typeof i4==="number"){d=i4|0;if(d<0){c+=b4*(a4-1);a4=ceil(-a4/d);}else{a4=ceil(a4/d);}b4*=d;}return new View(this.data,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4,c);};proto.transpose=function transpose(i0,i1,i2,i3,i4){i0=i0===undefined?0:i0|0;i1=i1===undefined?1:i1|0;i2=i2===undefined?2:i2|0;i3=i3===undefined?3:i3|0;i4=i4===undefined?4:i4|0;var a=this.shape,b=this.stride;return new View(this.data,a[i0],a[i1],a[i2],a[i3],a[i4],b[i0],b[i1],b[i2],b[i3],b[i4],this.offset);};proto.pick=function pick(i0,i1,i2,i3,i4){var a=[],b=[],c=this.offset;if(typeof i0==="number"&&i0>=0){c=c+this.stride[0]*i0|0;}else{a.push(this.shape[0]);b.push(this.stride[0]);}if(typeof i1==="number"&&i1>=0){c=c+this.stride[1]*i1|0;}else{a.push(this.shape[1]);b.push(this.stride[1]);}if(typeof i2==="number"&&i2>=0){c=c+this.stride[2]*i2|0;}else{a.push(this.shape[2]);b.push(this.stride[2]);}if(typeof i3==="number"&&i3>=0){c=c+this.stride[3]*i3|0;}else{a.push(this.shape[3]);b.push(this.stride[3]);}if(typeof i4==="number"&&i4>=0){c=c+this.stride[4]*i4|0;}else{a.push(this.shape[4]);b.push(this.stride[4]);}var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c);};return function construct(data,shape,stride,offset){return new View(data,shape[0],shape[1],shape[2],shape[3],shape[4],stride[0],stride[1],stride[2],stride[3],stride[4],offset);};}};function compileConstructor(inType,inDimension){var dKey=inDimension===-1?'T':String(inDimension);var procedure=allFns[dKey];if(inDimension===-1){return procedure(inType);}else if(inDimension===0){return procedure(inType,CACHED_CONSTRUCTORS[inType][0]);}return procedure(inType,CACHED_CONSTRUCTORS[inType],order);}function arrayDType(data){if(isBuffer(data)){return"buffer";}if(hasTypedArrays){switch(Object.prototype.toString.call(data)){case"[object Float64Array]":return"float64";case"[object Float32Array]":return"float32";case"[object Int8Array]":return"int8";case"[object Int16Array]":return"int16";case"[object Int32Array]":return"int32";case"[object Uint8ClampedArray]":return"uint8_clamped";case"[object Uint8Array]":return"uint8";case"[object Uint16Array]":return"uint16";case"[object Uint32Array]":return"uint32";case"[object BigInt64Array]":return"bigint64";case"[object BigUint64Array]":return"biguint64";}}if(Array.isArray(data)){return"array";}return"generic";}var CACHED_CONSTRUCTORS={"generic":[],"buffer":[],"array":[],// typed arrays
"float32":[],"float64":[],"int8":[],"int16":[],"int32":[],"uint8_clamped":[],"uint8":[],"uint16":[],"uint32":[],"bigint64":[],"biguint64":[]};(function(){for(var id in CACHED_CONSTRUCTORS){CACHED_CONSTRUCTORS[id].push(compileConstructor(id,-1));}});function wrappedNDArrayCtor(data,shape,stride,offset){if(data===undefined){var ctor=CACHED_CONSTRUCTORS.array[0];return ctor([]);}else if(typeof data==="number"){data=[data];}if(shape===undefined){shape=[data.length];}var d=shape.length;if(stride===undefined){stride=new Array(d);for(var i=d-1,sz=1;i>=0;--i){stride[i]=sz;sz*=shape[i];}}if(offset===undefined){offset=0;for(var i=0;i<d;++i){if(stride[i]<0){offset-=(shape[i]-1)*stride[i];}}}var inType=arrayDType(data);var ctor_list=CACHED_CONSTRUCTORS[inType];while(ctor_list.length<=d+1){ctor_list.push(compileConstructor(inType,ctor_list.length-1));}var ctor=ctor_list[d+1];return ctor(data,shape,stride,offset);}module.exports=wrappedNDArrayCtor;/***/},/***/8551:/***/function(module,__unused_webpack_exports,__nested_webpack_require_716834__){"use strict";var doubleBits=__nested_webpack_require_716834__(8362);var SMALLEST_DENORM=Math.pow(2,-1074);var UINT_MAX=-1>>>0;module.exports=nextafter;function nextafter(x,y){if(isNaN(x)||isNaN(y)){return NaN;}if(x===y){return x;}if(x===0){if(y<0){return-SMALLEST_DENORM;}else{return SMALLEST_DENORM;}}var hi=doubleBits.hi(x);var lo=doubleBits.lo(x);if(y>x===x>0){if(lo===UINT_MAX){hi+=1;lo=0;}else{lo+=1;}}else{if(lo===0){lo=UINT_MAX;hi-=1;}else{lo-=1;}}return doubleBits.pack(lo,hi);}/***/},/***/115:/***/function(__unused_webpack_module,exports){var DEFAULT_NORMALS_EPSILON=1e-6;var DEFAULT_FACE_EPSILON=1e-6;//Estimate the vertex normals of a mesh
exports.vertexNormals=function(faces,positions,specifiedEpsilon){var N=positions.length;var normals=new Array(N);var epsilon=specifiedEpsilon===void 0?DEFAULT_NORMALS_EPSILON:specifiedEpsilon;//Initialize normal array
for(var i=0;i<N;++i){normals[i]=[0.0,0.0,0.0];}//Walk over all the faces and add per-vertex contribution to normal weights
for(var i=0;i<faces.length;++i){var f=faces[i];var p=0;var c=f[f.length-1];var n=f[0];for(var j=0;j<f.length;++j){//Shift indices back
p=c;c=n;n=f[(j+1)%f.length];var v0=positions[p];var v1=positions[c];var v2=positions[n];//Compute infineteismal arcs
var d01=new Array(3);var m01=0.0;var d21=new Array(3);var m21=0.0;for(var k=0;k<3;++k){d01[k]=v0[k]-v1[k];m01+=d01[k]*d01[k];d21[k]=v2[k]-v1[k];m21+=d21[k]*d21[k];}//Accumulate values in normal
if(m01*m21>epsilon){var norm=normals[c];var w=1.0/Math.sqrt(m01*m21);for(var k=0;k<3;++k){var u=(k+1)%3;var v=(k+2)%3;norm[k]+=w*(d21[u]*d01[v]-d21[v]*d01[u]);}}}}//Scale all normals to unit length
for(var i=0;i<N;++i){var norm=normals[i];var m=0.0;for(var k=0;k<3;++k){m+=norm[k]*norm[k];}if(m>epsilon){var w=1.0/Math.sqrt(m);for(var k=0;k<3;++k){norm[k]*=w;}}else{for(var k=0;k<3;++k){norm[k]=0.0;}}}//Return the resulting set of patches
return normals;};//Compute face normals of a mesh
exports.faceNormals=function(faces,positions,specifiedEpsilon){var N=faces.length;var normals=new Array(N);var epsilon=specifiedEpsilon===void 0?DEFAULT_FACE_EPSILON:specifiedEpsilon;for(var i=0;i<N;++i){var f=faces[i];var pos=new Array(3);for(var j=0;j<3;++j){pos[j]=positions[f[j]];}var d01=new Array(3);var d21=new Array(3);for(var j=0;j<3;++j){d01[j]=pos[1][j]-pos[0][j];d21[j]=pos[2][j]-pos[0][j];}var n=new Array(3);var l=0.0;for(var j=0;j<3;++j){var u=(j+1)%3;var v=(j+2)%3;n[j]=d01[u]*d21[v]-d01[v]*d21[u];l+=n[j]*n[j];}if(l>epsilon){l=1.0/Math.sqrt(l);}else{l=0.0;}for(var j=0;j<3;++j){n[j]*=l;}normals[i]=n;}return normals;};/***/},/***/567:/***/function(module){"use strict";module.exports=quatFromFrame;function quatFromFrame(out,rx,ry,rz,ux,uy,uz,fx,fy,fz){var tr=rx+uy+fz;if(l>0){var l=Math.sqrt(tr+1.0);out[0]=0.5*(uz-fy)/l;out[1]=0.5*(fx-rz)/l;out[2]=0.5*(ry-uy)/l;out[3]=0.5*l;}else{var tf=Math.max(rx,uy,fz);var l=Math.sqrt(2*tf-tr+1.0);if(rx>=tf){//x y z  order
out[0]=0.5*l;out[1]=0.5*(ux+ry)/l;out[2]=0.5*(fx+rz)/l;out[3]=0.5*(uz-fy)/l;}else if(uy>=tf){//y z x  order
out[0]=0.5*(ry+ux)/l;out[1]=0.5*l;out[2]=0.5*(fy+uz)/l;out[3]=0.5*(fx-rz)/l;}else{//z x y  order
out[0]=0.5*(rz+fx)/l;out[1]=0.5*(uz+fy)/l;out[2]=0.5*l;out[3]=0.5*(ry-ux)/l;}}return out;}/***/},/***/7774:/***/function(module,__unused_webpack_exports,__nested_webpack_require_720109__){"use strict";module.exports=createOrbitController;var filterVector=__nested_webpack_require_720109__(8444);var lookAt=__nested_webpack_require_720109__(3012);var mat4FromQuat=__nested_webpack_require_720109__(5950);var invert44=__nested_webpack_require_720109__(7437);var quatFromFrame=__nested_webpack_require_720109__(567);function len3(x,y,z){return Math.sqrt(Math.pow(x,2)+Math.pow(y,2)+Math.pow(z,2));}function len4(w,x,y,z){return Math.sqrt(Math.pow(w,2)+Math.pow(x,2)+Math.pow(y,2)+Math.pow(z,2));}function normalize4(out,a){var ax=a[0];var ay=a[1];var az=a[2];var aw=a[3];var al=len4(ax,ay,az,aw);if(al>1e-6){out[0]=ax/al;out[1]=ay/al;out[2]=az/al;out[3]=aw/al;}else{out[0]=out[1]=out[2]=0.0;out[3]=1.0;}}function OrbitCameraController(initQuat,initCenter,initRadius){this.radius=filterVector([initRadius]);this.center=filterVector(initCenter);this.rotation=filterVector(initQuat);this.computedRadius=this.radius.curve(0);this.computedCenter=this.center.curve(0);this.computedRotation=this.rotation.curve(0);this.computedUp=[0.1,0,0];this.computedEye=[0.1,0,0];this.computedMatrix=[0.1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];this.recalcMatrix(0);}var proto=OrbitCameraController.prototype;proto.lastT=function(){return Math.max(this.radius.lastT(),this.center.lastT(),this.rotation.lastT());};proto.recalcMatrix=function(t){this.radius.curve(t);this.center.curve(t);this.rotation.curve(t);var quat=this.computedRotation;normalize4(quat,quat);var mat=this.computedMatrix;mat4FromQuat(mat,quat);var center=this.computedCenter;var eye=this.computedEye;var up=this.computedUp;var radius=Math.exp(this.computedRadius[0]);eye[0]=center[0]+radius*mat[2];eye[1]=center[1]+radius*mat[6];eye[2]=center[2]+radius*mat[10];up[0]=mat[1];up[1]=mat[5];up[2]=mat[9];for(var i=0;i<3;++i){var rr=0.0;for(var j=0;j<3;++j){rr+=mat[i+4*j]*eye[j];}mat[12+i]=-rr;}};proto.getMatrix=function(t,result){this.recalcMatrix(t);var m=this.computedMatrix;if(result){for(var i=0;i<16;++i){result[i]=m[i];}return result;}return m;};proto.idle=function(t){this.center.idle(t);this.radius.idle(t);this.rotation.idle(t);};proto.flush=function(t){this.center.flush(t);this.radius.flush(t);this.rotation.flush(t);};proto.pan=function(t,dx,dy,dz){dx=dx||0.0;dy=dy||0.0;dz=dz||0.0;this.recalcMatrix(t);var mat=this.computedMatrix;var ux=mat[1];var uy=mat[5];var uz=mat[9];var ul=len3(ux,uy,uz);ux/=ul;uy/=ul;uz/=ul;var rx=mat[0];var ry=mat[4];var rz=mat[8];var ru=rx*ux+ry*uy+rz*uz;rx-=ux*ru;ry-=uy*ru;rz-=uz*ru;var rl=len3(rx,ry,rz);rx/=rl;ry/=rl;rz/=rl;var fx=mat[2];var fy=mat[6];var fz=mat[10];var fu=fx*ux+fy*uy+fz*uz;var fr=fx*rx+fy*ry+fz*rz;fx-=fu*ux+fr*rx;fy-=fu*uy+fr*ry;fz-=fu*uz+fr*rz;var fl=len3(fx,fy,fz);fx/=fl;fy/=fl;fz/=fl;var vx=rx*dx+ux*dy;var vy=ry*dx+uy*dy;var vz=rz*dx+uz*dy;this.center.move(t,vx,vy,vz);//Update z-component of radius
var radius=Math.exp(this.computedRadius[0]);radius=Math.max(1e-4,radius+dz);this.radius.set(t,Math.log(radius));};proto.rotate=function(t,dx,dy,dz){this.recalcMatrix(t);dx=dx||0.0;dy=dy||0.0;var mat=this.computedMatrix;var rx=mat[0];var ry=mat[4];var rz=mat[8];var ux=mat[1];var uy=mat[5];var uz=mat[9];var fx=mat[2];var fy=mat[6];var fz=mat[10];var qx=dx*rx+dy*ux;var qy=dx*ry+dy*uy;var qz=dx*rz+dy*uz;var bx=-(fy*qz-fz*qy);var by=-(fz*qx-fx*qz);var bz=-(fx*qy-fy*qx);var bw=Math.sqrt(Math.max(0.0,1.0-Math.pow(bx,2)-Math.pow(by,2)-Math.pow(bz,2)));var bl=len4(bx,by,bz,bw);if(bl>1e-6){bx/=bl;by/=bl;bz/=bl;bw/=bl;}else{bx=by=bz=0.0;bw=1.0;}var rotation=this.computedRotation;var ax=rotation[0];var ay=rotation[1];var az=rotation[2];var aw=rotation[3];var cx=ax*bw+aw*bx+ay*bz-az*by;var cy=ay*bw+aw*by+az*bx-ax*bz;var cz=az*bw+aw*bz+ax*by-ay*bx;var cw=aw*bw-ax*bx-ay*by-az*bz;//Apply roll
if(dz){bx=fx;by=fy;bz=fz;var s=Math.sin(dz)/len3(bx,by,bz);bx*=s;by*=s;bz*=s;bw=Math.cos(dx);cx=cx*bw+cw*bx+cy*bz-cz*by;cy=cy*bw+cw*by+cz*bx-cx*bz;cz=cz*bw+cw*bz+cx*by-cy*bx;cw=cw*bw-cx*bx-cy*by-cz*bz;}var cl=len4(cx,cy,cz,cw);if(cl>1e-6){cx/=cl;cy/=cl;cz/=cl;cw/=cl;}else{cx=cy=cz=0.0;cw=1.0;}this.rotation.set(t,cx,cy,cz,cw);};proto.lookAt=function(t,eye,center,up){this.recalcMatrix(t);center=center||this.computedCenter;eye=eye||this.computedEye;up=up||this.computedUp;var mat=this.computedMatrix;lookAt(mat,eye,center,up);var rotation=this.computedRotation;quatFromFrame(rotation,mat[0],mat[1],mat[2],mat[4],mat[5],mat[6],mat[8],mat[9],mat[10]);normalize4(rotation,rotation);this.rotation.set(t,rotation[0],rotation[1],rotation[2],rotation[3]);var fl=0.0;for(var i=0;i<3;++i){fl+=Math.pow(center[i]-eye[i],2);}this.radius.set(t,0.5*Math.log(Math.max(fl,1e-6)));this.center.set(t,center[0],center[1],center[2]);};proto.translate=function(t,dx,dy,dz){this.center.move(t,dx||0.0,dy||0.0,dz||0.0);};proto.setMatrix=function(t,matrix){var rotation=this.computedRotation;quatFromFrame(rotation,matrix[0],matrix[1],matrix[2],matrix[4],matrix[5],matrix[6],matrix[8],matrix[9],matrix[10]);normalize4(rotation,rotation);this.rotation.set(t,rotation[0],rotation[1],rotation[2],rotation[3]);var mat=this.computedMatrix;invert44(mat,matrix);var w=mat[15];if(Math.abs(w)>1e-6){var cx=mat[12]/w;var cy=mat[13]/w;var cz=mat[14]/w;this.recalcMatrix(t);var r=Math.exp(this.computedRadius[0]);this.center.set(t,cx-mat[2]*r,cy-mat[6]*r,cz-mat[10]*r);this.radius.idle(t);}else{this.center.idle(t);this.radius.idle(t);}};proto.setDistance=function(t,d){if(d>0){this.radius.set(t,Math.log(d));}};proto.setDistanceLimits=function(lo,hi){if(lo>0){lo=Math.log(lo);}else{lo=-Infinity;}if(hi>0){hi=Math.log(hi);}else{hi=Infinity;}hi=Math.max(hi,lo);this.radius.bounds[0][0]=lo;this.radius.bounds[1][0]=hi;};proto.getDistanceLimits=function(out){var bounds=this.radius.bounds;if(out){out[0]=Math.exp(bounds[0][0]);out[1]=Math.exp(bounds[1][0]);return out;}return[Math.exp(bounds[0][0]),Math.exp(bounds[1][0])];};proto.toJSON=function(){this.recalcMatrix(this.lastT());return{center:this.computedCenter.slice(),rotation:this.computedRotation.slice(),distance:Math.log(this.computedRadius[0]),zoomMin:this.radius.bounds[0][0],zoomMax:this.radius.bounds[1][0]};};proto.fromJSON=function(options){var t=this.lastT();var c=options.center;if(c){this.center.set(t,c[0],c[1],c[2]);}var r=options.rotation;if(r){this.rotation.set(t,r[0],r[1],r[2],r[3]);}var d=options.distance;if(d&&d>0){this.radius.set(t,Math.log(d));}this.setDistanceLimits(options.zoomMin,options.zoomMax);};function createOrbitController(options){options=options||{};var center=options.center||[0,0,0];var rotation=options.rotation||[0,0,0,1];var radius=options.radius||1.0;center=[].slice.call(center,0,3);rotation=[].slice.call(rotation,0,4);normalize4(rotation,rotation);var result=new OrbitCameraController(rotation,center,Math.log(radius));result.setDistanceLimits(options.zoomMin,options.zoomMax);if('eye'in options||'up'in options){result.lookAt(0,options.eye,options.center,options.up);}return result;}/***/},/***/4930:/***/function(module,__unused_webpack_exports,__nested_webpack_require_726977__){"use strict";/*!
 * pad-left <https://github.com/jonschlinkert/pad-left>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT license.
 */var repeat=__nested_webpack_require_726977__(6184);module.exports=function padLeft(str,num,ch){ch=typeof ch!=='undefined'?ch+'':' ';return repeat(ch,num)+str;};/***/},/***/4405:/***/function(module){module.exports=function parseUnit(str,out){if(!out)out=[0,''];str=String(str);var num=parseFloat(str,10);out[0]=num;out[1]=str.match(/[\d.\-\+]*\s*(.*)/)[1]||'';return out;};/***/},/***/4166:/***/function(module,__unused_webpack_exports,__nested_webpack_require_727578__){"use strict";module.exports=planarDual;var compareAngle=__nested_webpack_require_727578__(9398);function planarDual(cells,positions){var numVertices=positions.length|0;var numEdges=cells.length;var adj=[new Array(numVertices),new Array(numVertices)];for(var i=0;i<numVertices;++i){adj[0][i]=[];adj[1][i]=[];}for(var i=0;i<numEdges;++i){var c=cells[i];adj[0][c[0]].push(c);adj[1][c[1]].push(c);}var cycles=[];//Add isolated vertices as trivial case
for(var i=0;i<numVertices;++i){if(adj[0][i].length+adj[1][i].length===0){cycles.push([i]);}}//Remove a half edge
function cut(c,i){var a=adj[i][c[i]];a.splice(a.indexOf(c),1);}//Find next vertex and cut edge
function next(a,b,noCut){var nextCell,nextVertex,nextDir;for(var i=0;i<2;++i){if(adj[i][b].length>0){nextCell=adj[i][b][0];nextDir=i;break;}}nextVertex=nextCell[nextDir^1];for(var dir=0;dir<2;++dir){var nbhd=adj[dir][b];for(var k=0;k<nbhd.length;++k){var e=nbhd[k];var p=e[dir^1];var cmp=compareAngle(positions[a],positions[b],positions[nextVertex],positions[p]);if(cmp>0){nextCell=e;nextVertex=p;nextDir=dir;}}}if(noCut){return nextVertex;}if(nextCell){cut(nextCell,nextDir);}return nextVertex;}function extractCycle(v,dir){var e0=adj[dir][v][0];var cycle=[v];cut(e0,dir);var u=e0[dir^1];var d0=dir;while(true){while(u!==v){cycle.push(u);u=next(cycle[cycle.length-2],u,false);}if(adj[0][v].length+adj[1][v].length===0){break;}var a=cycle[cycle.length-1];var b=v;var c=cycle[1];var d=next(a,b,true);if(compareAngle(positions[a],positions[b],positions[c],positions[d])<0){break;}cycle.push(v);u=next(a,b);}return cycle;}function shouldGlue(pcycle,ncycle){return ncycle[1]===ncycle[ncycle.length-1];}for(var i=0;i<numVertices;++i){for(var j=0;j<2;++j){var pcycle=[];while(adj[j][i].length>0){var ni=adj[0][i].length;var ncycle=extractCycle(i,j);if(shouldGlue(pcycle,ncycle)){//Glue together trivial cycles
pcycle.push.apply(pcycle,ncycle);}else{if(pcycle.length>0){cycles.push(pcycle);}pcycle=ncycle;}}if(pcycle.length>0){cycles.push(pcycle);}}}//Combine paths and loops together
return cycles;}/***/},/***/3959:/***/function(module,__unused_webpack_exports,__nested_webpack_require_729697__){"use strict";module.exports=trimLeaves;var e2a=__nested_webpack_require_729697__(8348);function trimLeaves(edges,positions){var adj=e2a(edges,positions.length);var live=new Array(positions.length);var nbhd=new Array(positions.length);var dead=[];for(var i=0;i<positions.length;++i){var count=adj[i].length;nbhd[i]=count;live[i]=true;if(count<=1){dead.push(i);}}while(dead.length>0){var v=dead.pop();live[v]=false;var n=adj[v];for(var i=0;i<n.length;++i){var u=n[i];if(--nbhd[u]===0){dead.push(u);}}}var newIndex=new Array(positions.length);var npositions=[];for(var i=0;i<positions.length;++i){if(live[i]){var v=npositions.length;newIndex[i]=v;npositions.push(positions[i]);}else{newIndex[i]=-1;}}var nedges=[];for(var i=0;i<edges.length;++i){var e=edges[i];if(live[e[0]]&&live[e[1]]){nedges.push([newIndex[e[0]],newIndex[e[1]]]);}}return[nedges,npositions];}/***/},/***/8040:/***/function(module,__unused_webpack_exports,__nested_webpack_require_730626__){"use strict";module.exports=planarGraphToPolyline;var e2a=__nested_webpack_require_730626__(8348);var planarDual=__nested_webpack_require_730626__(4166);var preprocessPolygon=__nested_webpack_require_730626__(211);var twoProduct=__nested_webpack_require_730626__(9660);var robustSum=__nested_webpack_require_730626__(9662);var uniq=__nested_webpack_require_730626__(1215);var trimLeaves=__nested_webpack_require_730626__(3959);function makeArray(length,fill){var result=new Array(length);for(var i=0;i<length;++i){result[i]=fill;}return result;}function makeArrayOfArrays(length){var result=new Array(length);for(var i=0;i<length;++i){result[i]=[];}return result;}function planarGraphToPolyline(edges,positions){//Trim leaves
var result=trimLeaves(edges,positions);edges=result[0];positions=result[1];var numVertices=positions.length;var numEdges=edges.length;//Calculate adjacency list, check manifold
var adj=e2a(edges,positions.length);for(var i=0;i<numVertices;++i){if(adj[i].length%2===1){throw new Error('planar-graph-to-polyline: graph must be manifold');}}//Get faces
var faces=planarDual(edges,positions);//Check orientation of a polygon using exact arithmetic
function ccw(c){var n=c.length;var area=[0];for(var j=0;j<n;++j){var a=positions[c[j]];var b=positions[c[(j+1)%n]];var t00=twoProduct(-a[0],a[1]);var t01=twoProduct(-a[0],b[1]);var t10=twoProduct(b[0],a[1]);var t11=twoProduct(b[0],b[1]);area=robustSum(area,robustSum(robustSum(t00,t01),robustSum(t10,t11)));}return area[area.length-1]>0;}//Extract all clockwise faces
faces=faces.filter(ccw);//Detect which loops are contained in one another to handle parent-of relation
var numFaces=faces.length;var parent=new Array(numFaces);var containment=new Array(numFaces);for(var i=0;i<numFaces;++i){parent[i]=i;var row=new Array(numFaces);var loopVertices=faces[i].map(function(v){return positions[v];});var pmc=preprocessPolygon([loopVertices]);var count=0;outer:for(var j=0;j<numFaces;++j){row[j]=0;if(i===j){continue;}var c=faces[j];var n=c.length;for(var k=0;k<n;++k){var d=pmc(positions[c[k]]);if(d!==0){if(d<0){row[j]=1;count+=1;}continue outer;}}row[j]=1;count+=1;}containment[i]=[count,i,row];}containment.sort(function(a,b){return b[0]-a[0];});for(var i=0;i<numFaces;++i){var row=containment[i];var idx=row[1];var children=row[2];for(var j=0;j<numFaces;++j){if(children[j]){parent[j]=idx;}}}//Initialize face adjacency list
var fadj=makeArrayOfArrays(numFaces);for(var i=0;i<numFaces;++i){fadj[i].push(parent[i]);fadj[parent[i]].push(i);}//Build adjacency matrix for edges
var edgeAdjacency={};var internalVertices=makeArray(numVertices,false);for(var i=0;i<numFaces;++i){var c=faces[i];var n=c.length;for(var j=0;j<n;++j){var a=c[j];var b=c[(j+1)%n];var key=Math.min(a,b)+":"+Math.max(a,b);if(key in edgeAdjacency){var neighbor=edgeAdjacency[key];fadj[neighbor].push(i);fadj[i].push(neighbor);internalVertices[a]=internalVertices[b]=true;}else{edgeAdjacency[key]=i;}}}function sharedBoundary(c){var n=c.length;for(var i=0;i<n;++i){if(!internalVertices[c[i]]){return false;}}return true;}var toVisit=[];var parity=makeArray(numFaces,-1);for(var i=0;i<numFaces;++i){if(parent[i]===i&&!sharedBoundary(faces[i])){toVisit.push(i);parity[i]=0;}else{parity[i]=-1;}}//Using face adjacency, classify faces as in/out
var result=[];while(toVisit.length>0){var top=toVisit.pop();var nbhd=fadj[top];uniq(nbhd,function(a,b){return a-b;});var nnbhr=nbhd.length;var p=parity[top];var polyline;if(p===0){var c=faces[top];polyline=[c];}for(var i=0;i<nnbhr;++i){var f=nbhd[i];if(parity[f]>=0){continue;}parity[f]=p^1;toVisit.push(f);if(p===0){var c=faces[f];if(!sharedBoundary(c)){c.reverse();polyline.push(c);}}}if(p===0){result.push(polyline);}}return result;}/***/},/***/211:/***/function(module,__unused_webpack_exports,__nested_webpack_require_734327__){module.exports=preprocessPolygon;var orient=__nested_webpack_require_734327__(417)[3];var makeSlabs=__nested_webpack_require_734327__(4385);var makeIntervalTree=__nested_webpack_require_734327__(9014);var bsearch=__nested_webpack_require_734327__(5070);function visitInterval(){return true;}function intervalSearch(table){return function(x,y){var tree=table[x];if(tree){return!!tree.queryPoint(y,visitInterval);}return false;};}function buildVerticalIndex(segments){var table={};for(var i=0;i<segments.length;++i){var s=segments[i];var x=s[0][0];var y0=s[0][1];var y1=s[1][1];var p=[Math.min(y0,y1),Math.max(y0,y1)];if(x in table){table[x].push(p);}else{table[x]=[p];}}var intervalTable={};var keys=Object.keys(table);for(var i=0;i<keys.length;++i){var segs=table[keys[i]];intervalTable[keys[i]]=makeIntervalTree(segs);}return intervalSearch(intervalTable);}function buildSlabSearch(slabs,coordinates){return function(p){var bucket=bsearch.le(coordinates,p[0]);if(bucket<0){return 1;}var root=slabs[bucket];if(!root){if(bucket>0&&coordinates[bucket]===p[0]){root=slabs[bucket-1];}else{return 1;}}var lastOrientation=1;while(root){var s=root.key;var o=orient(p,s[0],s[1]);if(s[0][0]<s[1][0]){if(o<0){root=root.left;}else if(o>0){lastOrientation=-1;root=root.right;}else{return 0;}}else{if(o>0){root=root.left;}else if(o<0){lastOrientation=1;root=root.right;}else{return 0;}}}return lastOrientation;};}function classifyEmpty(p){return 1;}function createClassifyVertical(testVertical){return function classify(p){if(testVertical(p[0],p[1])){return 0;}return 1;};}function createClassifyPointDegen(testVertical,testNormal){return function classify(p){if(testVertical(p[0],p[1])){return 0;}return testNormal(p);};}function preprocessPolygon(loops){//Compute number of loops
var numLoops=loops.length;//Unpack segments
var segments=[];var vsegments=[];var ptr=0;for(var i=0;i<numLoops;++i){var loop=loops[i];var numVertices=loop.length;for(var s=numVertices-1,t=0;t<numVertices;s=t++){var a=loop[s];var b=loop[t];if(a[0]===b[0]){vsegments.push([a,b]);}else{segments.push([a,b]);}}}//Degenerate case: All loops are empty
if(segments.length===0){if(vsegments.length===0){return classifyEmpty;}else{return createClassifyVertical(buildVerticalIndex(vsegments));}}//Build slab decomposition
var slabs=makeSlabs(segments);var testSlab=buildSlabSearch(slabs.slabs,slabs.coordinates);if(vsegments.length===0){return testSlab;}else{return createClassifyPointDegen(buildVerticalIndex(vsegments),testSlab);}}/***/},/***/7309:/***/function(module){"use strict";//Optimized version for triangle closest point
// Based on Eberly's WildMagick codes
// http://www.geometrictools.com/LibMathematics/Distance/Distance.html
var diff=new Float64Array(4);var edge0=new Float64Array(4);var edge1=new Float64Array(4);function closestPoint2d(V0,V1,V2,point,result){//Reallocate buffers if necessary
if(diff.length<point.length){diff=new Float64Array(point.length);edge0=new Float64Array(point.length);edge1=new Float64Array(point.length);}//Compute edges
for(var i=0;i<point.length;++i){diff[i]=V0[i]-point[i];edge0[i]=V1[i]-V0[i];edge1[i]=V2[i]-V0[i];}//Compute coefficients for quadratic func
var a00=0.0,a01=0.0,a11=0.0,b0=0.0,b1=0.0,c=0.0;for(var i=0;i<point.length;++i){var e0=edge0[i],e1=edge1[i],d=diff[i];a00+=e0*e0;a01+=e0*e1;a11+=e1*e1;b0+=d*e0;b1+=d*e1;c+=d*d;}//Compute determinant/coeffs
var det=Math.abs(a00*a11-a01*a01);var s=a01*b1-a11*b0;var t=a01*b0-a00*b1;var sqrDistance;//Hardcoded Voronoi diagram classification
if(s+t<=det){if(s<0){if(t<0){// region 4
if(b0<0){t=0;if(-b0>=a00){s=1.0;sqrDistance=a00+2.0*b0+c;}else{s=-b0/a00;sqrDistance=b0*s+c;}}else{s=0;if(b1>=0){t=0;sqrDistance=c;}else if(-b1>=a11){t=1;sqrDistance=a11+2.0*b1+c;}else{t=-b1/a11;sqrDistance=b1*t+c;}}}else{// region 3
s=0;if(b1>=0){t=0;sqrDistance=c;}else if(-b1>=a11){t=1;sqrDistance=a11+2.0*b1+c;}else{t=-b1/a11;sqrDistance=b1*t+c;}}}else if(t<0){// region 5
t=0;if(b0>=0){s=0;sqrDistance=c;}else if(-b0>=a00){s=1;sqrDistance=a00+2.0*b0+c;}else{s=-b0/a00;sqrDistance=b0*s+c;}}else{// region 0
// minimum at interior point
var invDet=1.0/det;s*=invDet;t*=invDet;sqrDistance=s*(a00*s+a01*t+2.0*b0)+t*(a01*s+a11*t+2.0*b1)+c;}}else{var tmp0,tmp1,numer,denom;if(s<0){// region 2
tmp0=a01+b0;tmp1=a11+b1;if(tmp1>tmp0){numer=tmp1-tmp0;denom=a00-2.0*a01+a11;if(numer>=denom){s=1;t=0;sqrDistance=a00+2.0*b0+c;}else{s=numer/denom;t=1-s;sqrDistance=s*(a00*s+a01*t+2.0*b0)+t*(a01*s+a11*t+2.0*b1)+c;}}else{s=0;if(tmp1<=0){t=1;sqrDistance=a11+2.0*b1+c;}else if(b1>=0){t=0;sqrDistance=c;}else{t=-b1/a11;sqrDistance=b1*t+c;}}}else if(t<0){// region 6
tmp0=a01+b1;tmp1=a00+b0;if(tmp1>tmp0){numer=tmp1-tmp0;denom=a00-2.0*a01+a11;if(numer>=denom){t=1;s=0;sqrDistance=a11+2.0*b1+c;}else{t=numer/denom;s=1-t;sqrDistance=s*(a00*s+a01*t+2.0*b0)+t*(a01*s+a11*t+2.0*b1)+c;}}else{t=0;if(tmp1<=0){s=1;sqrDistance=a00+2.0*b0+c;}else if(b0>=0){s=0;sqrDistance=c;}else{s=-b0/a00;sqrDistance=b0*s+c;}}}else{// region 1
numer=a11+b1-a01-b0;if(numer<=0){s=0;t=1;sqrDistance=a11+2.0*b1+c;}else{denom=a00-2.0*a01+a11;if(numer>=denom){s=1;t=0;sqrDistance=a00+2.0*b0+c;}else{s=numer/denom;t=1-s;sqrDistance=s*(a00*s+a01*t+2.0*b0)+t*(a01*s+a11*t+2.0*b1)+c;}}}}var u=1.0-s-t;for(var i=0;i<point.length;++i){result[i]=u*V0[i]+s*V1[i]+t*V2[i];}if(sqrDistance<0){return 0;}return sqrDistance;}module.exports=closestPoint2d;/***/},/***/1116:/***/function(module,__unused_webpack_exports,__nested_webpack_require_739699__){module.exports=__nested_webpack_require_739699__(6093);/***/},/***/7584:/***/function(module,__unused_webpack_exports,__nested_webpack_require_739824__){"use strict";var bnadd=__nested_webpack_require_739824__(1539);module.exports=add;function add(a,b){var n=a.length;var r=new Array(n);for(var i=0;i<n;++i){r[i]=bnadd(a[i],b[i]);}return r;}/***/},/***/2826:/***/function(module,__unused_webpack_exports,__nested_webpack_require_740082__){"use strict";module.exports=float2rat;var rat=__nested_webpack_require_740082__(5125);function float2rat(v){var result=new Array(v.length);for(var i=0;i<v.length;++i){result[i]=rat(v[i]);}return result;}/***/},/***/4469:/***/function(module,__unused_webpack_exports,__nested_webpack_require_740355__){"use strict";var rat=__nested_webpack_require_740355__(5125);var mul=__nested_webpack_require_740355__(3962);module.exports=muls;function muls(a,x){var s=rat(x);var n=a.length;var r=new Array(n);for(var i=0;i<n;++i){r[i]=mul(a[i],s);}return r;}/***/},/***/6695:/***/function(module,__unused_webpack_exports,__nested_webpack_require_740655__){"use strict";var bnsub=__nested_webpack_require_740655__(4354);module.exports=sub;function sub(a,b){var n=a.length;var r=new Array(n);for(var i=0;i<n;++i){r[i]=bnsub(a[i],b[i]);}return r;}/***/},/***/7037:/***/function(module,__unused_webpack_exports,__nested_webpack_require_740913__){"use strict";var compareCell=__nested_webpack_require_740913__(9209);var compareOrientedCell=__nested_webpack_require_740913__(1284);var orientation=__nested_webpack_require_740913__(9887);module.exports=reduceCellComplex;function reduceCellComplex(cells){cells.sort(compareOrientedCell);var n=cells.length;var ptr=0;for(var i=0;i<n;++i){var c=cells[i];var o=orientation(c);if(o===0){continue;}if(ptr>0){var f=cells[ptr-1];if(compareCell(c,f)===0&&orientation(f)!==o){ptr-=1;continue;}}cells[ptr++]=c;}cells.length=ptr;return cells;}/***/},/***/6184:/***/function(module){"use strict";/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */ /**
 * Results cache
 */var res='';var cache;/**
 * Expose `repeat`
 */module.exports=repeat;/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */function repeat(str,num){if(typeof str!=='string'){throw new TypeError('expected a string');}// cover common, quick use cases
if(num===1)return str;if(num===2)return str+str;var max=str.length*num;if(cache!==str||typeof cache==='undefined'){cache=str;res='';}else if(res.length>=max){return res.substr(0,max);}while(max>res.length&&num>1){if(num&1){res+=str;}num>>=1;str+=str;}res+=str;res=res.substr(0,max);return res;}/***/},/***/8161:/***/function(module,__unused_webpack_exports,__nested_webpack_require_742566__){module.exports=__nested_webpack_require_742566__.g.performance&&__nested_webpack_require_742566__.g.performance.now?function now(){return performance.now();}:Date.now||function now(){return+new Date();};/***/},/***/402:/***/function(module){"use strict";module.exports=compressExpansion;function compressExpansion(e){var m=e.length;var Q=e[e.length-1];var bottom=m;for(var i=m-2;i>=0;--i){var a=Q;var b=e[i];Q=a+b;var bv=Q-a;var q=b-bv;if(q){e[--bottom]=Q;Q=q;}}var top=0;for(var i=bottom;i<m;++i){var a=e[i];var b=Q;Q=a+b;var bv=Q-a;var q=b-bv;if(q){e[top++]=q;}}e[top++]=Q;e.length=top;return e;}/***/},/***/8167:/***/function(module,__unused_webpack_exports,__nested_webpack_require_743220__){"use strict";var twoProduct=__nested_webpack_require_743220__(9660);var robustSum=__nested_webpack_require_743220__(9662);var robustScale=__nested_webpack_require_743220__(8289);var compress=__nested_webpack_require_743220__(402);var NUM_EXPANDED=6;function determinant_2(sum,scale,prod,compress){return function robustDeterminant2(m){return compress(sum(prod(m[0][0],m[1][1]),prod(-m[0][1],m[1][0])));};}function determinant_3(sum,scale,prod,compress){return function robustDeterminant3(m){return compress(sum(scale(sum(prod(m[1][1],m[2][2]),prod(-m[1][2],m[2][1])),m[0][0]),sum(scale(sum(prod(m[1][0],m[2][2]),prod(-m[1][2],m[2][0])),-m[0][1]),scale(sum(prod(m[1][0],m[2][1]),prod(-m[1][1],m[2][0])),m[0][2]))));};}function determinant_4(sum,scale,prod,compress){return function robustDeterminant4(m){return compress(sum(sum(scale(sum(scale(sum(prod(m[2][2],m[3][3]),prod(-m[2][3],m[3][2])),m[1][1]),sum(scale(sum(prod(m[2][1],m[3][3]),prod(-m[2][3],m[3][1])),-m[1][2]),scale(sum(prod(m[2][1],m[3][2]),prod(-m[2][2],m[3][1])),m[1][3]))),m[0][0]),scale(sum(scale(sum(prod(m[2][2],m[3][3]),prod(-m[2][3],m[3][2])),m[1][0]),sum(scale(sum(prod(m[2][0],m[3][3]),prod(-m[2][3],m[3][0])),-m[1][2]),scale(sum(prod(m[2][0],m[3][2]),prod(-m[2][2],m[3][0])),m[1][3]))),-m[0][1])),sum(scale(sum(scale(sum(prod(m[2][1],m[3][3]),prod(-m[2][3],m[3][1])),m[1][0]),sum(scale(sum(prod(m[2][0],m[3][3]),prod(-m[2][3],m[3][0])),-m[1][1]),scale(sum(prod(m[2][0],m[3][1]),prod(-m[2][1],m[3][0])),m[1][3]))),m[0][2]),scale(sum(scale(sum(prod(m[2][1],m[3][2]),prod(-m[2][2],m[3][1])),m[1][0]),sum(scale(sum(prod(m[2][0],m[3][2]),prod(-m[2][2],m[3][0])),-m[1][1]),scale(sum(prod(m[2][0],m[3][1]),prod(-m[2][1],m[3][0])),m[1][2]))),-m[0][3]))));};}function determinant_5(sum,scale,prod,compress){return function robustDeterminant5(m){return compress(sum(sum(scale(sum(sum(scale(sum(scale(sum(prod(m[3][3],m[4][4]),prod(-m[3][4],m[4][3])),m[2][2]),sum(scale(sum(prod(m[3][2],m[4][4]),prod(-m[3][4],m[4][2])),-m[2][3]),scale(sum(prod(m[3][2],m[4][3]),prod(-m[3][3],m[4][2])),m[2][4]))),m[1][1]),scale(sum(scale(sum(prod(m[3][3],m[4][4]),prod(-m[3][4],m[4][3])),m[2][1]),sum(scale(sum(prod(m[3][1],m[4][4]),prod(-m[3][4],m[4][1])),-m[2][3]),scale(sum(prod(m[3][1],m[4][3]),prod(-m[3][3],m[4][1])),m[2][4]))),-m[1][2])),sum(scale(sum(scale(sum(prod(m[3][2],m[4][4]),prod(-m[3][4],m[4][2])),m[2][1]),sum(scale(sum(prod(m[3][1],m[4][4]),prod(-m[3][4],m[4][1])),-m[2][2]),scale(sum(prod(m[3][1],m[4][2]),prod(-m[3][2],m[4][1])),m[2][4]))),m[1][3]),scale(sum(scale(sum(prod(m[3][2],m[4][3]),prod(-m[3][3],m[4][2])),m[2][1]),sum(scale(sum(prod(m[3][1],m[4][3]),prod(-m[3][3],m[4][1])),-m[2][2]),scale(sum(prod(m[3][1],m[4][2]),prod(-m[3][2],m[4][1])),m[2][3]))),-m[1][4]))),m[0][0]),scale(sum(sum(scale(sum(scale(sum(prod(m[3][3],m[4][4]),prod(-m[3][4],m[4][3])),m[2][2]),sum(scale(sum(prod(m[3][2],m[4][4]),prod(-m[3][4],m[4][2])),-m[2][3]),scale(sum(prod(m[3][2],m[4][3]),prod(-m[3][3],m[4][2])),m[2][4]))),m[1][0]),scale(sum(scale(sum(prod(m[3][3],m[4][4]),prod(-m[3][4],m[4][3])),m[2][0]),sum(scale(sum(prod(m[3][0],m[4][4]),prod(-m[3][4],m[4][0])),-m[2][3]),scale(sum(prod(m[3][0],m[4][3]),prod(-m[3][3],m[4][0])),m[2][4]))),-m[1][2])),sum(scale(sum(scale(sum(prod(m[3][2],m[4][4]),prod(-m[3][4],m[4][2])),m[2][0]),sum(scale(sum(prod(m[3][0],m[4][4]),prod(-m[3][4],m[4][0])),-m[2][2]),scale(sum(prod(m[3][0],m[4][2]),prod(-m[3][2],m[4][0])),m[2][4]))),m[1][3]),scale(sum(scale(sum(prod(m[3][2],m[4][3]),prod(-m[3][3],m[4][2])),m[2][0]),sum(scale(sum(prod(m[3][0],m[4][3]),prod(-m[3][3],m[4][0])),-m[2][2]),scale(sum(prod(m[3][0],m[4][2]),prod(-m[3][2],m[4][0])),m[2][3]))),-m[1][4]))),-m[0][1])),sum(scale(sum(sum(scale(sum(scale(sum(prod(m[3][3],m[4][4]),prod(-m[3][4],m[4][3])),m[2][1]),sum(scale(sum(prod(m[3][1],m[4][4]),prod(-m[3][4],m[4][1])),-m[2][3]),scale(sum(prod(m[3][1],m[4][3]),prod(-m[3][3],m[4][1])),m[2][4]))),m[1][0]),scale(sum(scale(sum(prod(m[3][3],m[4][4]),prod(-m[3][4],m[4][3])),m[2][0]),sum(scale(sum(prod(m[3][0],m[4][4]),prod(-m[3][4],m[4][0])),-m[2][3]),scale(sum(prod(m[3][0],m[4][3]),prod(-m[3][3],m[4][0])),m[2][4]))),-m[1][1])),sum(scale(sum(scale(sum(prod(m[3][1],m[4][4]),prod(-m[3][4],m[4][1])),m[2][0]),sum(scale(sum(prod(m[3][0],m[4][4]),prod(-m[3][4],m[4][0])),-m[2][1]),scale(sum(prod(m[3][0],m[4][1]),prod(-m[3][1],m[4][0])),m[2][4]))),m[1][3]),scale(sum(scale(sum(prod(m[3][1],m[4][3]),prod(-m[3][3],m[4][1])),m[2][0]),sum(scale(sum(prod(m[3][0],m[4][3]),prod(-m[3][3],m[4][0])),-m[2][1]),scale(sum(prod(m[3][0],m[4][1]),prod(-m[3][1],m[4][0])),m[2][3]))),-m[1][4]))),m[0][2]),sum(scale(sum(sum(scale(sum(scale(sum(prod(m[3][2],m[4][4]),prod(-m[3][4],m[4][2])),m[2][1]),sum(scale(sum(prod(m[3][1],m[4][4]),prod(-m[3][4],m[4][1])),-m[2][2]),scale(sum(prod(m[3][1],m[4][2]),prod(-m[3][2],m[4][1])),m[2][4]))),m[1][0]),scale(sum(scale(sum(prod(m[3][2],m[4][4]),prod(-m[3][4],m[4][2])),m[2][0]),sum(scale(sum(prod(m[3][0],m[4][4]),prod(-m[3][4],m[4][0])),-m[2][2]),scale(sum(prod(m[3][0],m[4][2]),prod(-m[3][2],m[4][0])),m[2][4]))),-m[1][1])),sum(scale(sum(scale(sum(prod(m[3][1],m[4][4]),prod(-m[3][4],m[4][1])),m[2][0]),sum(scale(sum(prod(m[3][0],m[4][4]),prod(-m[3][4],m[4][0])),-m[2][1]),scale(sum(prod(m[3][0],m[4][1]),prod(-m[3][1],m[4][0])),m[2][4]))),m[1][2]),scale(sum(scale(sum(prod(m[3][1],m[4][2]),prod(-m[3][2],m[4][1])),m[2][0]),sum(scale(sum(prod(m[3][0],m[4][2]),prod(-m[3][2],m[4][0])),-m[2][1]),scale(sum(prod(m[3][0],m[4][1]),prod(-m[3][1],m[4][0])),m[2][2]))),-m[1][4]))),-m[0][3]),scale(sum(sum(scale(sum(scale(sum(prod(m[3][2],m[4][3]),prod(-m[3][3],m[4][2])),m[2][1]),sum(scale(sum(prod(m[3][1],m[4][3]),prod(-m[3][3],m[4][1])),-m[2][2]),scale(sum(prod(m[3][1],m[4][2]),prod(-m[3][2],m[4][1])),m[2][3]))),m[1][0]),scale(sum(scale(sum(prod(m[3][2],m[4][3]),prod(-m[3][3],m[4][2])),m[2][0]),sum(scale(sum(prod(m[3][0],m[4][3]),prod(-m[3][3],m[4][0])),-m[2][2]),scale(sum(prod(m[3][0],m[4][2]),prod(-m[3][2],m[4][0])),m[2][3]))),-m[1][1])),sum(scale(sum(scale(sum(prod(m[3][1],m[4][3]),prod(-m[3][3],m[4][1])),m[2][0]),sum(scale(sum(prod(m[3][0],m[4][3]),prod(-m[3][3],m[4][0])),-m[2][1]),scale(sum(prod(m[3][0],m[4][1]),prod(-m[3][1],m[4][0])),m[2][3]))),m[1][2]),scale(sum(scale(sum(prod(m[3][1],m[4][2]),prod(-m[3][2],m[4][1])),m[2][0]),sum(scale(sum(prod(m[3][0],m[4][2]),prod(-m[3][2],m[4][0])),-m[2][1]),scale(sum(prod(m[3][0],m[4][1]),prod(-m[3][1],m[4][0])),m[2][2]))),-m[1][3]))),m[0][4])))));};}function compileDeterminant(n){var fn=n===2?determinant_2:n===3?determinant_3:n===4?determinant_4:n===5?determinant_5:undefined;return fn(robustSum,robustScale,twoProduct,compress);}var CACHE=[function robustDeterminant0(){return[0];},function robustDeterminant1(m){return[m[0][0]];}];function proc(det0,det1,det2,det3,det4,det5,CACHE,gen){return function robustDeterminant(m){switch(m.length){case 0:return det0(m);case 1:return det1(m);case 2:return det2(m);case 3:return det3(m);case 4:return det4(m);case 5:return det5(m);}var det=CACHE[m.length];if(!det)det=CACHE[m.length]=gen(m.length);return det(m);};}function generateDispatch(){while(CACHE.length<NUM_EXPANDED){CACHE.push(compileDeterminant(CACHE.length));}module.exports=proc.apply(undefined,CACHE.concat([CACHE,compileDeterminant]));for(var i=0;i<CACHE.length;++i){module.exports[i]=CACHE[i];}}generateDispatch();/***/},/***/9130:/***/function(module,__unused_webpack_exports,__nested_webpack_require_750555__){"use strict";var twoProduct=__nested_webpack_require_750555__(9660);var robustSum=__nested_webpack_require_750555__(9662);module.exports=robustDotProduct;function robustDotProduct(a,b){var r=twoProduct(a[0],b[0]);for(var i=1;i<a.length;++i){r=robustSum(r,twoProduct(a[i],b[i]));}return r;}/***/},/***/2227:/***/function(module,__unused_webpack_exports,__nested_webpack_require_750900__){"use strict";var twoProduct=__nested_webpack_require_750900__(9660);var robustSum=__nested_webpack_require_750900__(9662);var robustDiff=__nested_webpack_require_750900__(4078);var robustScale=__nested_webpack_require_750900__(8289);var NUM_EXPAND=6;function orientation(n){var fn=n===3?inSphere3:n===4?inSphere4:n===5?inSphere5:inSphere6;return fn(robustSum,robustDiff,twoProduct,robustScale);}function inSphere0(){return 0;}function inSphere1(){return 0;}function inSphere2(){return 0;}function inSphere3(sum,diff,prod,scale){function exactInSphere3(m0,m1,m2){var w0=prod(m0[0],m0[0]);var w0m1=scale(w0,m1[0]);var w0m2=scale(w0,m2[0]);var w1=prod(m1[0],m1[0]);var w1m0=scale(w1,m0[0]);var w1m2=scale(w1,m2[0]);var w2=prod(m2[0],m2[0]);var w2m0=scale(w2,m0[0]);var w2m1=scale(w2,m1[0]);var p=sum(diff(w2m1,w1m2),diff(w1m0,w0m1));var n=diff(w2m0,w0m2);var d=diff(p,n);return d[d.length-1];}return exactInSphere3;}function inSphere4(sum,diff,prod,scale){function exactInSphere4(m0,m1,m2,m3){var w0=sum(prod(m0[0],m0[0]),prod(m0[1],m0[1]));var w0m1=scale(w0,m1[0]);var w0m2=scale(w0,m2[0]);var w0m3=scale(w0,m3[0]);var w1=sum(prod(m1[0],m1[0]),prod(m1[1],m1[1]));var w1m0=scale(w1,m0[0]);var w1m2=scale(w1,m2[0]);var w1m3=scale(w1,m3[0]);var w2=sum(prod(m2[0],m2[0]),prod(m2[1],m2[1]));var w2m0=scale(w2,m0[0]);var w2m1=scale(w2,m1[0]);var w2m3=scale(w2,m3[0]);var w3=sum(prod(m3[0],m3[0]),prod(m3[1],m3[1]));var w3m0=scale(w3,m0[0]);var w3m1=scale(w3,m1[0]);var w3m2=scale(w3,m2[0]);var p=sum(sum(scale(diff(w3m2,w2m3),m1[1]),sum(scale(diff(w3m1,w1m3),-m2[1]),scale(diff(w2m1,w1m2),m3[1]))),sum(scale(diff(w3m1,w1m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m1[1]),scale(diff(w1m0,w0m1),m3[1]))));var n=sum(sum(scale(diff(w3m2,w2m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m2[1]),scale(diff(w2m0,w0m2),m3[1]))),sum(scale(diff(w2m1,w1m2),m0[1]),sum(scale(diff(w2m0,w0m2),-m1[1]),scale(diff(w1m0,w0m1),m2[1]))));var d=diff(p,n);return d[d.length-1];}return exactInSphere4;}function inSphere5(sum,diff,prod,scale){function exactInSphere5(m0,m1,m2,m3,m4){var w0=sum(prod(m0[0],m0[0]),sum(prod(m0[1],m0[1]),prod(m0[2],m0[2])));var w0m1=scale(w0,m1[0]);var w0m2=scale(w0,m2[0]);var w0m3=scale(w0,m3[0]);var w0m4=scale(w0,m4[0]);var w1=sum(prod(m1[0],m1[0]),sum(prod(m1[1],m1[1]),prod(m1[2],m1[2])));var w1m0=scale(w1,m0[0]);var w1m2=scale(w1,m2[0]);var w1m3=scale(w1,m3[0]);var w1m4=scale(w1,m4[0]);var w2=sum(prod(m2[0],m2[0]),sum(prod(m2[1],m2[1]),prod(m2[2],m2[2])));var w2m0=scale(w2,m0[0]);var w2m1=scale(w2,m1[0]);var w2m3=scale(w2,m3[0]);var w2m4=scale(w2,m4[0]);var w3=sum(prod(m3[0],m3[0]),sum(prod(m3[1],m3[1]),prod(m3[2],m3[2])));var w3m0=scale(w3,m0[0]);var w3m1=scale(w3,m1[0]);var w3m2=scale(w3,m2[0]);var w3m4=scale(w3,m4[0]);var w4=sum(prod(m4[0],m4[0]),sum(prod(m4[1],m4[1]),prod(m4[2],m4[2])));var w4m0=scale(w4,m0[0]);var w4m1=scale(w4,m1[0]);var w4m2=scale(w4,m2[0]);var w4m3=scale(w4,m3[0]);var p=sum(sum(sum(scale(sum(scale(diff(w4m3,w3m4),m2[1]),sum(scale(diff(w4m2,w2m4),-m3[1]),scale(diff(w3m2,w2m3),m4[1]))),m1[2]),sum(scale(sum(scale(diff(w4m3,w3m4),m1[1]),sum(scale(diff(w4m1,w1m4),-m3[1]),scale(diff(w3m1,w1m3),m4[1]))),-m2[2]),scale(sum(scale(diff(w4m2,w2m4),m1[1]),sum(scale(diff(w4m1,w1m4),-m2[1]),scale(diff(w2m1,w1m2),m4[1]))),m3[2]))),sum(scale(sum(scale(diff(w3m2,w2m3),m1[1]),sum(scale(diff(w3m1,w1m3),-m2[1]),scale(diff(w2m1,w1m2),m3[1]))),-m4[2]),sum(scale(sum(scale(diff(w4m3,w3m4),m1[1]),sum(scale(diff(w4m1,w1m4),-m3[1]),scale(diff(w3m1,w1m3),m4[1]))),m0[2]),scale(sum(scale(diff(w4m3,w3m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m3[1]),scale(diff(w3m0,w0m3),m4[1]))),-m1[2])))),sum(sum(scale(sum(scale(diff(w4m1,w1m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m1[1]),scale(diff(w1m0,w0m1),m4[1]))),m3[2]),sum(scale(sum(scale(diff(w3m1,w1m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m1[1]),scale(diff(w1m0,w0m1),m3[1]))),-m4[2]),scale(sum(scale(diff(w3m2,w2m3),m1[1]),sum(scale(diff(w3m1,w1m3),-m2[1]),scale(diff(w2m1,w1m2),m3[1]))),m0[2]))),sum(scale(sum(scale(diff(w3m2,w2m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m2[1]),scale(diff(w2m0,w0m2),m3[1]))),-m1[2]),sum(scale(sum(scale(diff(w3m1,w1m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m1[1]),scale(diff(w1m0,w0m1),m3[1]))),m2[2]),scale(sum(scale(diff(w2m1,w1m2),m0[1]),sum(scale(diff(w2m0,w0m2),-m1[1]),scale(diff(w1m0,w0m1),m2[1]))),-m3[2])))));var n=sum(sum(sum(scale(sum(scale(diff(w4m3,w3m4),m2[1]),sum(scale(diff(w4m2,w2m4),-m3[1]),scale(diff(w3m2,w2m3),m4[1]))),m0[2]),scale(sum(scale(diff(w4m3,w3m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m3[1]),scale(diff(w3m0,w0m3),m4[1]))),-m2[2])),sum(scale(sum(scale(diff(w4m2,w2m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m2[1]),scale(diff(w2m0,w0m2),m4[1]))),m3[2]),scale(sum(scale(diff(w3m2,w2m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m2[1]),scale(diff(w2m0,w0m2),m3[1]))),-m4[2]))),sum(sum(scale(sum(scale(diff(w4m2,w2m4),m1[1]),sum(scale(diff(w4m1,w1m4),-m2[1]),scale(diff(w2m1,w1m2),m4[1]))),m0[2]),scale(sum(scale(diff(w4m2,w2m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m2[1]),scale(diff(w2m0,w0m2),m4[1]))),-m1[2])),sum(scale(sum(scale(diff(w4m1,w1m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m1[1]),scale(diff(w1m0,w0m1),m4[1]))),m2[2]),scale(sum(scale(diff(w2m1,w1m2),m0[1]),sum(scale(diff(w2m0,w0m2),-m1[1]),scale(diff(w1m0,w0m1),m2[1]))),-m4[2]))));var d=diff(p,n);return d[d.length-1];}return exactInSphere5;}function inSphere6(sum,diff,prod,scale){function exactInSphere6(m0,m1,m2,m3,m4,m5){var w0=sum(sum(prod(m0[0],m0[0]),prod(m0[1],m0[1])),sum(prod(m0[2],m0[2]),prod(m0[3],m0[3])));var w0m1=scale(w0,m1[0]);var w0m2=scale(w0,m2[0]);var w0m3=scale(w0,m3[0]);var w0m4=scale(w0,m4[0]);var w0m5=scale(w0,m5[0]);var w1=sum(sum(prod(m1[0],m1[0]),prod(m1[1],m1[1])),sum(prod(m1[2],m1[2]),prod(m1[3],m1[3])));var w1m0=scale(w1,m0[0]);var w1m2=scale(w1,m2[0]);var w1m3=scale(w1,m3[0]);var w1m4=scale(w1,m4[0]);var w1m5=scale(w1,m5[0]);var w2=sum(sum(prod(m2[0],m2[0]),prod(m2[1],m2[1])),sum(prod(m2[2],m2[2]),prod(m2[3],m2[3])));var w2m0=scale(w2,m0[0]);var w2m1=scale(w2,m1[0]);var w2m3=scale(w2,m3[0]);var w2m4=scale(w2,m4[0]);var w2m5=scale(w2,m5[0]);var w3=sum(sum(prod(m3[0],m3[0]),prod(m3[1],m3[1])),sum(prod(m3[2],m3[2]),prod(m3[3],m3[3])));var w3m0=scale(w3,m0[0]);var w3m1=scale(w3,m1[0]);var w3m2=scale(w3,m2[0]);var w3m4=scale(w3,m4[0]);var w3m5=scale(w3,m5[0]);var w4=sum(sum(prod(m4[0],m4[0]),prod(m4[1],m4[1])),sum(prod(m4[2],m4[2]),prod(m4[3],m4[3])));var w4m0=scale(w4,m0[0]);var w4m1=scale(w4,m1[0]);var w4m2=scale(w4,m2[0]);var w4m3=scale(w4,m3[0]);var w4m5=scale(w4,m5[0]);var w5=sum(sum(prod(m5[0],m5[0]),prod(m5[1],m5[1])),sum(prod(m5[2],m5[2]),prod(m5[3],m5[3])));var w5m0=scale(w5,m0[0]);var w5m1=scale(w5,m1[0]);var w5m2=scale(w5,m2[0]);var w5m3=scale(w5,m3[0]);var w5m4=scale(w5,m4[0]);var p=sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4,w4m5),m3[1]),sum(scale(diff(w5m3,w3m5),-m4[1]),scale(diff(w4m3,w3m4),m5[1]))),m2[2]),scale(sum(scale(diff(w5m4,w4m5),m2[1]),sum(scale(diff(w5m2,w2m5),-m4[1]),scale(diff(w4m2,w2m4),m5[1]))),-m3[2])),sum(scale(sum(scale(diff(w5m3,w3m5),m2[1]),sum(scale(diff(w5m2,w2m5),-m3[1]),scale(diff(w3m2,w2m3),m5[1]))),m4[2]),scale(sum(scale(diff(w4m3,w3m4),m2[1]),sum(scale(diff(w4m2,w2m4),-m3[1]),scale(diff(w3m2,w2m3),m4[1]))),-m5[2]))),m1[3]),sum(scale(sum(sum(scale(sum(scale(diff(w5m4,w4m5),m3[1]),sum(scale(diff(w5m3,w3m5),-m4[1]),scale(diff(w4m3,w3m4),m5[1]))),m1[2]),scale(sum(scale(diff(w5m4,w4m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m4[1]),scale(diff(w4m1,w1m4),m5[1]))),-m3[2])),sum(scale(sum(scale(diff(w5m3,w3m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m3[1]),scale(diff(w3m1,w1m3),m5[1]))),m4[2]),scale(sum(scale(diff(w4m3,w3m4),m1[1]),sum(scale(diff(w4m1,w1m4),-m3[1]),scale(diff(w3m1,w1m3),m4[1]))),-m5[2]))),-m2[3]),scale(sum(sum(scale(sum(scale(diff(w5m4,w4m5),m2[1]),sum(scale(diff(w5m2,w2m5),-m4[1]),scale(diff(w4m2,w2m4),m5[1]))),m1[2]),scale(sum(scale(diff(w5m4,w4m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m4[1]),scale(diff(w4m1,w1m4),m5[1]))),-m2[2])),sum(scale(sum(scale(diff(w5m2,w2m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m2[1]),scale(diff(w2m1,w1m2),m5[1]))),m4[2]),scale(sum(scale(diff(w4m2,w2m4),m1[1]),sum(scale(diff(w4m1,w1m4),-m2[1]),scale(diff(w2m1,w1m2),m4[1]))),-m5[2]))),m3[3]))),sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3,w3m5),m2[1]),sum(scale(diff(w5m2,w2m5),-m3[1]),scale(diff(w3m2,w2m3),m5[1]))),m1[2]),scale(sum(scale(diff(w5m3,w3m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m3[1]),scale(diff(w3m1,w1m3),m5[1]))),-m2[2])),sum(scale(sum(scale(diff(w5m2,w2m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m2[1]),scale(diff(w2m1,w1m2),m5[1]))),m3[2]),scale(sum(scale(diff(w3m2,w2m3),m1[1]),sum(scale(diff(w3m1,w1m3),-m2[1]),scale(diff(w2m1,w1m2),m3[1]))),-m5[2]))),-m4[3]),scale(sum(sum(scale(sum(scale(diff(w4m3,w3m4),m2[1]),sum(scale(diff(w4m2,w2m4),-m3[1]),scale(diff(w3m2,w2m3),m4[1]))),m1[2]),scale(sum(scale(diff(w4m3,w3m4),m1[1]),sum(scale(diff(w4m1,w1m4),-m3[1]),scale(diff(w3m1,w1m3),m4[1]))),-m2[2])),sum(scale(sum(scale(diff(w4m2,w2m4),m1[1]),sum(scale(diff(w4m1,w1m4),-m2[1]),scale(diff(w2m1,w1m2),m4[1]))),m3[2]),scale(sum(scale(diff(w3m2,w2m3),m1[1]),sum(scale(diff(w3m1,w1m3),-m2[1]),scale(diff(w2m1,w1m2),m3[1]))),-m4[2]))),m5[3])),sum(scale(sum(sum(scale(sum(scale(diff(w5m4,w4m5),m3[1]),sum(scale(diff(w5m3,w3m5),-m4[1]),scale(diff(w4m3,w3m4),m5[1]))),m1[2]),scale(sum(scale(diff(w5m4,w4m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m4[1]),scale(diff(w4m1,w1m4),m5[1]))),-m3[2])),sum(scale(sum(scale(diff(w5m3,w3m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m3[1]),scale(diff(w3m1,w1m3),m5[1]))),m4[2]),scale(sum(scale(diff(w4m3,w3m4),m1[1]),sum(scale(diff(w4m1,w1m4),-m3[1]),scale(diff(w3m1,w1m3),m4[1]))),-m5[2]))),m0[3]),scale(sum(sum(scale(sum(scale(diff(w5m4,w4m5),m3[1]),sum(scale(diff(w5m3,w3m5),-m4[1]),scale(diff(w4m3,w3m4),m5[1]))),m0[2]),scale(sum(scale(diff(w5m4,w4m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m4[1]),scale(diff(w4m0,w0m4),m5[1]))),-m3[2])),sum(scale(sum(scale(diff(w5m3,w3m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m3[1]),scale(diff(w3m0,w0m3),m5[1]))),m4[2]),scale(sum(scale(diff(w4m3,w3m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m3[1]),scale(diff(w3m0,w0m3),m4[1]))),-m5[2]))),-m1[3])))),sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4,w4m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m4[1]),scale(diff(w4m1,w1m4),m5[1]))),m0[2]),scale(sum(scale(diff(w5m4,w4m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m4[1]),scale(diff(w4m0,w0m4),m5[1]))),-m1[2])),sum(scale(sum(scale(diff(w5m1,w1m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m1[1]),scale(diff(w1m0,w0m1),m5[1]))),m4[2]),scale(sum(scale(diff(w4m1,w1m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m1[1]),scale(diff(w1m0,w0m1),m4[1]))),-m5[2]))),m3[3]),scale(sum(sum(scale(sum(scale(diff(w5m3,w3m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m3[1]),scale(diff(w3m1,w1m3),m5[1]))),m0[2]),scale(sum(scale(diff(w5m3,w3m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m3[1]),scale(diff(w3m0,w0m3),m5[1]))),-m1[2])),sum(scale(sum(scale(diff(w5m1,w1m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m1[1]),scale(diff(w1m0,w0m1),m5[1]))),m3[2]),scale(sum(scale(diff(w3m1,w1m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m1[1]),scale(diff(w1m0,w0m1),m3[1]))),-m5[2]))),-m4[3])),sum(scale(sum(sum(scale(sum(scale(diff(w4m3,w3m4),m1[1]),sum(scale(diff(w4m1,w1m4),-m3[1]),scale(diff(w3m1,w1m3),m4[1]))),m0[2]),scale(sum(scale(diff(w4m3,w3m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m3[1]),scale(diff(w3m0,w0m3),m4[1]))),-m1[2])),sum(scale(sum(scale(diff(w4m1,w1m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m1[1]),scale(diff(w1m0,w0m1),m4[1]))),m3[2]),scale(sum(scale(diff(w3m1,w1m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m1[1]),scale(diff(w1m0,w0m1),m3[1]))),-m4[2]))),m5[3]),scale(sum(sum(scale(sum(scale(diff(w5m3,w3m5),m2[1]),sum(scale(diff(w5m2,w2m5),-m3[1]),scale(diff(w3m2,w2m3),m5[1]))),m1[2]),scale(sum(scale(diff(w5m3,w3m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m3[1]),scale(diff(w3m1,w1m3),m5[1]))),-m2[2])),sum(scale(sum(scale(diff(w5m2,w2m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m2[1]),scale(diff(w2m1,w1m2),m5[1]))),m3[2]),scale(sum(scale(diff(w3m2,w2m3),m1[1]),sum(scale(diff(w3m1,w1m3),-m2[1]),scale(diff(w2m1,w1m2),m3[1]))),-m5[2]))),m0[3]))),sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3,w3m5),m2[1]),sum(scale(diff(w5m2,w2m5),-m3[1]),scale(diff(w3m2,w2m3),m5[1]))),m0[2]),scale(sum(scale(diff(w5m3,w3m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m3[1]),scale(diff(w3m0,w0m3),m5[1]))),-m2[2])),sum(scale(sum(scale(diff(w5m2,w2m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m2[1]),scale(diff(w2m0,w0m2),m5[1]))),m3[2]),scale(sum(scale(diff(w3m2,w2m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m2[1]),scale(diff(w2m0,w0m2),m3[1]))),-m5[2]))),-m1[3]),scale(sum(sum(scale(sum(scale(diff(w5m3,w3m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m3[1]),scale(diff(w3m1,w1m3),m5[1]))),m0[2]),scale(sum(scale(diff(w5m3,w3m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m3[1]),scale(diff(w3m0,w0m3),m5[1]))),-m1[2])),sum(scale(sum(scale(diff(w5m1,w1m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m1[1]),scale(diff(w1m0,w0m1),m5[1]))),m3[2]),scale(sum(scale(diff(w3m1,w1m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m1[1]),scale(diff(w1m0,w0m1),m3[1]))),-m5[2]))),m2[3])),sum(scale(sum(sum(scale(sum(scale(diff(w5m2,w2m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m2[1]),scale(diff(w2m1,w1m2),m5[1]))),m0[2]),scale(sum(scale(diff(w5m2,w2m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m2[1]),scale(diff(w2m0,w0m2),m5[1]))),-m1[2])),sum(scale(sum(scale(diff(w5m1,w1m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m1[1]),scale(diff(w1m0,w0m1),m5[1]))),m2[2]),scale(sum(scale(diff(w2m1,w1m2),m0[1]),sum(scale(diff(w2m0,w0m2),-m1[1]),scale(diff(w1m0,w0m1),m2[1]))),-m5[2]))),-m3[3]),scale(sum(sum(scale(sum(scale(diff(w3m2,w2m3),m1[1]),sum(scale(diff(w3m1,w1m3),-m2[1]),scale(diff(w2m1,w1m2),m3[1]))),m0[2]),scale(sum(scale(diff(w3m2,w2m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m2[1]),scale(diff(w2m0,w0m2),m3[1]))),-m1[2])),sum(scale(sum(scale(diff(w3m1,w1m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m1[1]),scale(diff(w1m0,w0m1),m3[1]))),m2[2]),scale(sum(scale(diff(w2m1,w1m2),m0[1]),sum(scale(diff(w2m0,w0m2),-m1[1]),scale(diff(w1m0,w0m1),m2[1]))),-m3[2]))),m5[3])))));var n=sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4,w4m5),m3[1]),sum(scale(diff(w5m3,w3m5),-m4[1]),scale(diff(w4m3,w3m4),m5[1]))),m2[2]),scale(sum(scale(diff(w5m4,w4m5),m2[1]),sum(scale(diff(w5m2,w2m5),-m4[1]),scale(diff(w4m2,w2m4),m5[1]))),-m3[2])),sum(scale(sum(scale(diff(w5m3,w3m5),m2[1]),sum(scale(diff(w5m2,w2m5),-m3[1]),scale(diff(w3m2,w2m3),m5[1]))),m4[2]),scale(sum(scale(diff(w4m3,w3m4),m2[1]),sum(scale(diff(w4m2,w2m4),-m3[1]),scale(diff(w3m2,w2m3),m4[1]))),-m5[2]))),m0[3]),sum(scale(sum(sum(scale(sum(scale(diff(w5m4,w4m5),m3[1]),sum(scale(diff(w5m3,w3m5),-m4[1]),scale(diff(w4m3,w3m4),m5[1]))),m0[2]),scale(sum(scale(diff(w5m4,w4m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m4[1]),scale(diff(w4m0,w0m4),m5[1]))),-m3[2])),sum(scale(sum(scale(diff(w5m3,w3m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m3[1]),scale(diff(w3m0,w0m3),m5[1]))),m4[2]),scale(sum(scale(diff(w4m3,w3m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m3[1]),scale(diff(w3m0,w0m3),m4[1]))),-m5[2]))),-m2[3]),scale(sum(sum(scale(sum(scale(diff(w5m4,w4m5),m2[1]),sum(scale(diff(w5m2,w2m5),-m4[1]),scale(diff(w4m2,w2m4),m5[1]))),m0[2]),scale(sum(scale(diff(w5m4,w4m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m4[1]),scale(diff(w4m0,w0m4),m5[1]))),-m2[2])),sum(scale(sum(scale(diff(w5m2,w2m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m2[1]),scale(diff(w2m0,w0m2),m5[1]))),m4[2]),scale(sum(scale(diff(w4m2,w2m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m2[1]),scale(diff(w2m0,w0m2),m4[1]))),-m5[2]))),m3[3]))),sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3,w3m5),m2[1]),sum(scale(diff(w5m2,w2m5),-m3[1]),scale(diff(w3m2,w2m3),m5[1]))),m0[2]),scale(sum(scale(diff(w5m3,w3m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m3[1]),scale(diff(w3m0,w0m3),m5[1]))),-m2[2])),sum(scale(sum(scale(diff(w5m2,w2m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m2[1]),scale(diff(w2m0,w0m2),m5[1]))),m3[2]),scale(sum(scale(diff(w3m2,w2m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m2[1]),scale(diff(w2m0,w0m2),m3[1]))),-m5[2]))),-m4[3]),scale(sum(sum(scale(sum(scale(diff(w4m3,w3m4),m2[1]),sum(scale(diff(w4m2,w2m4),-m3[1]),scale(diff(w3m2,w2m3),m4[1]))),m0[2]),scale(sum(scale(diff(w4m3,w3m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m3[1]),scale(diff(w3m0,w0m3),m4[1]))),-m2[2])),sum(scale(sum(scale(diff(w4m2,w2m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m2[1]),scale(diff(w2m0,w0m2),m4[1]))),m3[2]),scale(sum(scale(diff(w3m2,w2m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m2[1]),scale(diff(w2m0,w0m2),m3[1]))),-m4[2]))),m5[3])),sum(scale(sum(sum(scale(sum(scale(diff(w5m4,w4m5),m2[1]),sum(scale(diff(w5m2,w2m5),-m4[1]),scale(diff(w4m2,w2m4),m5[1]))),m1[2]),scale(sum(scale(diff(w5m4,w4m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m4[1]),scale(diff(w4m1,w1m4),m5[1]))),-m2[2])),sum(scale(sum(scale(diff(w5m2,w2m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m2[1]),scale(diff(w2m1,w1m2),m5[1]))),m4[2]),scale(sum(scale(diff(w4m2,w2m4),m1[1]),sum(scale(diff(w4m1,w1m4),-m2[1]),scale(diff(w2m1,w1m2),m4[1]))),-m5[2]))),m0[3]),scale(sum(sum(scale(sum(scale(diff(w5m4,w4m5),m2[1]),sum(scale(diff(w5m2,w2m5),-m4[1]),scale(diff(w4m2,w2m4),m5[1]))),m0[2]),scale(sum(scale(diff(w5m4,w4m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m4[1]),scale(diff(w4m0,w0m4),m5[1]))),-m2[2])),sum(scale(sum(scale(diff(w5m2,w2m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m2[1]),scale(diff(w2m0,w0m2),m5[1]))),m4[2]),scale(sum(scale(diff(w4m2,w2m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m2[1]),scale(diff(w2m0,w0m2),m4[1]))),-m5[2]))),-m1[3])))),sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4,w4m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m4[1]),scale(diff(w4m1,w1m4),m5[1]))),m0[2]),scale(sum(scale(diff(w5m4,w4m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m4[1]),scale(diff(w4m0,w0m4),m5[1]))),-m1[2])),sum(scale(sum(scale(diff(w5m1,w1m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m1[1]),scale(diff(w1m0,w0m1),m5[1]))),m4[2]),scale(sum(scale(diff(w4m1,w1m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m1[1]),scale(diff(w1m0,w0m1),m4[1]))),-m5[2]))),m2[3]),scale(sum(sum(scale(sum(scale(diff(w5m2,w2m5),m1[1]),sum(scale(diff(w5m1,w1m5),-m2[1]),scale(diff(w2m1,w1m2),m5[1]))),m0[2]),scale(sum(scale(diff(w5m2,w2m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m2[1]),scale(diff(w2m0,w0m2),m5[1]))),-m1[2])),sum(scale(sum(scale(diff(w5m1,w1m5),m0[1]),sum(scale(diff(w5m0,w0m5),-m1[1]),scale(diff(w1m0,w0m1),m5[1]))),m2[2]),scale(sum(scale(diff(w2m1,w1m2),m0[1]),sum(scale(diff(w2m0,w0m2),-m1[1]),scale(diff(w1m0,w0m1),m2[1]))),-m5[2]))),-m4[3])),sum(scale(sum(sum(scale(sum(scale(diff(w4m2,w2m4),m1[1]),sum(scale(diff(w4m1,w1m4),-m2[1]),scale(diff(w2m1,w1m2),m4[1]))),m0[2]),scale(sum(scale(diff(w4m2,w2m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m2[1]),scale(diff(w2m0,w0m2),m4[1]))),-m1[2])),sum(scale(sum(scale(diff(w4m1,w1m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m1[1]),scale(diff(w1m0,w0m1),m4[1]))),m2[2]),scale(sum(scale(diff(w2m1,w1m2),m0[1]),sum(scale(diff(w2m0,w0m2),-m1[1]),scale(diff(w1m0,w0m1),m2[1]))),-m4[2]))),m5[3]),scale(sum(sum(scale(sum(scale(diff(w4m3,w3m4),m2[1]),sum(scale(diff(w4m2,w2m4),-m3[1]),scale(diff(w3m2,w2m3),m4[1]))),m1[2]),scale(sum(scale(diff(w4m3,w3m4),m1[1]),sum(scale(diff(w4m1,w1m4),-m3[1]),scale(diff(w3m1,w1m3),m4[1]))),-m2[2])),sum(scale(sum(scale(diff(w4m2,w2m4),m1[1]),sum(scale(diff(w4m1,w1m4),-m2[1]),scale(diff(w2m1,w1m2),m4[1]))),m3[2]),scale(sum(scale(diff(w3m2,w2m3),m1[1]),sum(scale(diff(w3m1,w1m3),-m2[1]),scale(diff(w2m1,w1m2),m3[1]))),-m4[2]))),m0[3]))),sum(sum(scale(sum(sum(scale(sum(scale(diff(w4m3,w3m4),m2[1]),sum(scale(diff(w4m2,w2m4),-m3[1]),scale(diff(w3m2,w2m3),m4[1]))),m0[2]),scale(sum(scale(diff(w4m3,w3m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m3[1]),scale(diff(w3m0,w0m3),m4[1]))),-m2[2])),sum(scale(sum(scale(diff(w4m2,w2m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m2[1]),scale(diff(w2m0,w0m2),m4[1]))),m3[2]),scale(sum(scale(diff(w3m2,w2m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m2[1]),scale(diff(w2m0,w0m2),m3[1]))),-m4[2]))),-m1[3]),scale(sum(sum(scale(sum(scale(diff(w4m3,w3m4),m1[1]),sum(scale(diff(w4m1,w1m4),-m3[1]),scale(diff(w3m1,w1m3),m4[1]))),m0[2]),scale(sum(scale(diff(w4m3,w3m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m3[1]),scale(diff(w3m0,w0m3),m4[1]))),-m1[2])),sum(scale(sum(scale(diff(w4m1,w1m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m1[1]),scale(diff(w1m0,w0m1),m4[1]))),m3[2]),scale(sum(scale(diff(w3m1,w1m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m1[1]),scale(diff(w1m0,w0m1),m3[1]))),-m4[2]))),m2[3])),sum(scale(sum(sum(scale(sum(scale(diff(w4m2,w2m4),m1[1]),sum(scale(diff(w4m1,w1m4),-m2[1]),scale(diff(w2m1,w1m2),m4[1]))),m0[2]),scale(sum(scale(diff(w4m2,w2m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m2[1]),scale(diff(w2m0,w0m2),m4[1]))),-m1[2])),sum(scale(sum(scale(diff(w4m1,w1m4),m0[1]),sum(scale(diff(w4m0,w0m4),-m1[1]),scale(diff(w1m0,w0m1),m4[1]))),m2[2]),scale(sum(scale(diff(w2m1,w1m2),m0[1]),sum(scale(diff(w2m0,w0m2),-m1[1]),scale(diff(w1m0,w0m1),m2[1]))),-m4[2]))),-m3[3]),scale(sum(sum(scale(sum(scale(diff(w3m2,w2m3),m1[1]),sum(scale(diff(w3m1,w1m3),-m2[1]),scale(diff(w2m1,w1m2),m3[1]))),m0[2]),scale(sum(scale(diff(w3m2,w2m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m2[1]),scale(diff(w2m0,w0m2),m3[1]))),-m1[2])),sum(scale(sum(scale(diff(w3m1,w1m3),m0[1]),sum(scale(diff(w3m0,w0m3),-m1[1]),scale(diff(w1m0,w0m1),m3[1]))),m2[2]),scale(sum(scale(diff(w2m1,w1m2),m0[1]),sum(scale(diff(w2m0,w0m2),-m1[1]),scale(diff(w1m0,w0m1),m2[1]))),-m3[2]))),m4[3])))));var d=diff(p,n);return d[d.length-1];}return exactInSphere6;}var CACHED=[inSphere0,inSphere1,inSphere2];function slowInSphere(args){var proc=CACHED[args.length];if(!proc){proc=CACHED[args.length]=orientation(args.length);}return proc.apply(undefined,args);}function proc(slow,o0,o1,o2,o3,o4,o5,o6){function testInSphere(a0,a1,a2,a3,a4,a5){switch(arguments.length){case 0:case 1:return 0;case 2:return o2(a0,a1);case 3:return o3(a0,a1,a2);case 4:return o4(a0,a1,a2,a3);case 5:return o5(a0,a1,a2,a3,a4);case 6:return o6(a0,a1,a2,a3,a4,a5);}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i];}return slow(s);}return testInSphere;}function generateInSphereTest(){while(CACHED.length<=NUM_EXPAND){CACHED.push(orientation(CACHED.length));}module.exports=proc.apply(undefined,[slowInSphere].concat(CACHED));for(var i=0;i<=NUM_EXPAND;++i){module.exports[i]=CACHED[i];}}generateInSphereTest();/***/},/***/6606:/***/function(module,__unused_webpack_exports,__nested_webpack_require_772915__){"use strict";var determinant=__nested_webpack_require_772915__(8167);var NUM_EXPAND=6;function generateSolver(n){var fn=n===2?solve2d:n===3?solve3d:n===4?solve4d:n===5?solve5d:solve6d;if(n<6){return fn(determinant[n]);}return fn(determinant);}function robustLinearSolve0d(){return[[0]];}function robustLinearSolve1d(A,b){return[[b[0]],[A[0][0]]];}function solve2d(det){return function robustLinearSolve2d(A,b){return[det([[+b[0],+A[0][1]],[+b[1],+A[1][1]]]),det([[+A[0][0],+b[0]],[+A[1][0],+b[1]]]),det(A)];};}function solve3d(det){return function robustLinearSolve3d(A,b){return[det([[+b[0],+A[0][1],+A[0][2]],[+b[1],+A[1][1],+A[1][2]],[+b[2],+A[2][1],+A[2][2]]]),det([[+A[0][0],+b[0],+A[0][2]],[+A[1][0],+b[1],+A[1][2]],[+A[2][0],+b[2],+A[2][2]]]),det([[+A[0][0],+A[0][1],+b[0]],[+A[1][0],+A[1][1],+b[1]],[+A[2][0],+A[2][1],+b[2]]]),det(A)];};}function solve4d(det){return function robustLinearSolve4d(A,b){return[det([[+b[0],+A[0][1],+A[0][2],+A[0][3]],[+b[1],+A[1][1],+A[1][2],+A[1][3]],[+b[2],+A[2][1],+A[2][2],+A[2][3]],[+b[3],+A[3][1],+A[3][2],+A[3][3]]]),det([[+A[0][0],+b[0],+A[0][2],+A[0][3]],[+A[1][0],+b[1],+A[1][2],+A[1][3]],[+A[2][0],+b[2],+A[2][2],+A[2][3]],[+A[3][0],+b[3],+A[3][2],+A[3][3]]]),det([[+A[0][0],+A[0][1],+b[0],+A[0][3]],[+A[1][0],+A[1][1],+b[1],+A[1][3]],[+A[2][0],+A[2][1],+b[2],+A[2][3]],[+A[3][0],+A[3][1],+b[3],+A[3][3]]]),det([[+A[0][0],+A[0][1],+A[0][2],+b[0]],[+A[1][0],+A[1][1],+A[1][2],+b[1]],[+A[2][0],+A[2][1],+A[2][2],+b[2]],[+A[3][0],+A[3][1],+A[3][2],+b[3]]]),det(A)];};}function solve5d(det){return function robustLinearSolve5d(A,b){return[det([[+b[0],+A[0][1],+A[0][2],+A[0][3],+A[0][4]],[+b[1],+A[1][1],+A[1][2],+A[1][3],+A[1][4]],[+b[2],+A[2][1],+A[2][2],+A[2][3],+A[2][4]],[+b[3],+A[3][1],+A[3][2],+A[3][3],+A[3][4]],[+b[4],+A[4][1],+A[4][2],+A[4][3],+A[4][4]]]),det([[+A[0][0],+b[0],+A[0][2],+A[0][3],+A[0][4]],[+A[1][0],+b[1],+A[1][2],+A[1][3],+A[1][4]],[+A[2][0],+b[2],+A[2][2],+A[2][3],+A[2][4]],[+A[3][0],+b[3],+A[3][2],+A[3][3],+A[3][4]],[+A[4][0],+b[4],+A[4][2],+A[4][3],+A[4][4]]]),det([[+A[0][0],+A[0][1],+b[0],+A[0][3],+A[0][4]],[+A[1][0],+A[1][1],+b[1],+A[1][3],+A[1][4]],[+A[2][0],+A[2][1],+b[2],+A[2][3],+A[2][4]],[+A[3][0],+A[3][1],+b[3],+A[3][3],+A[3][4]],[+A[4][0],+A[4][1],+b[4],+A[4][3],+A[4][4]]]),det([[+A[0][0],+A[0][1],+A[0][2],+b[0],+A[0][4]],[+A[1][0],+A[1][1],+A[1][2],+b[1],+A[1][4]],[+A[2][0],+A[2][1],+A[2][2],+b[2],+A[2][4]],[+A[3][0],+A[3][1],+A[3][2],+b[3],+A[3][4]],[+A[4][0],+A[4][1],+A[4][2],+b[4],+A[4][4]]]),det([[+A[0][0],+A[0][1],+A[0][2],+A[0][3],+b[0]],[+A[1][0],+A[1][1],+A[1][2],+A[1][3],+b[1]],[+A[2][0],+A[2][1],+A[2][2],+A[2][3],+b[2]],[+A[3][0],+A[3][1],+A[3][2],+A[3][3],+b[3]],[+A[4][0],+A[4][1],+A[4][2],+A[4][3],+b[4]]]),det(A)];};}function solve6d(det){return function robustLinearSolve6d(A,b){return[det([[+b[0],+A[0][1],+A[0][2],+A[0][3],+A[0][4],+A[0][5]],[+b[1],+A[1][1],+A[1][2],+A[1][3],+A[1][4],+A[1][5]],[+b[2],+A[2][1],+A[2][2],+A[2][3],+A[2][4],+A[2][5]],[+b[3],+A[3][1],+A[3][2],+A[3][3],+A[3][4],+A[3][5]],[+b[4],+A[4][1],+A[4][2],+A[4][3],+A[4][4],+A[4][5]],[+b[5],+A[5][1],+A[5][2],+A[5][3],+A[5][4],+A[5][5]]]),det([[+A[0][0],+b[0],+A[0][2],+A[0][3],+A[0][4],+A[0][5]],[+A[1][0],+b[1],+A[1][2],+A[1][3],+A[1][4],+A[1][5]],[+A[2][0],+b[2],+A[2][2],+A[2][3],+A[2][4],+A[2][5]],[+A[3][0],+b[3],+A[3][2],+A[3][3],+A[3][4],+A[3][5]],[+A[4][0],+b[4],+A[4][2],+A[4][3],+A[4][4],+A[4][5]],[+A[5][0],+b[5],+A[5][2],+A[5][3],+A[5][4],+A[5][5]]]),det([[+A[0][0],+A[0][1],+b[0],+A[0][3],+A[0][4],+A[0][5]],[+A[1][0],+A[1][1],+b[1],+A[1][3],+A[1][4],+A[1][5]],[+A[2][0],+A[2][1],+b[2],+A[2][3],+A[2][4],+A[2][5]],[+A[3][0],+A[3][1],+b[3],+A[3][3],+A[3][4],+A[3][5]],[+A[4][0],+A[4][1],+b[4],+A[4][3],+A[4][4],+A[4][5]],[+A[5][0],+A[5][1],+b[5],+A[5][3],+A[5][4],+A[5][5]]]),det([[+A[0][0],+A[0][1],+A[0][2],+b[0],+A[0][4],+A[0][5]],[+A[1][0],+A[1][1],+A[1][2],+b[1],+A[1][4],+A[1][5]],[+A[2][0],+A[2][1],+A[2][2],+b[2],+A[2][4],+A[2][5]],[+A[3][0],+A[3][1],+A[3][2],+b[3],+A[3][4],+A[3][5]],[+A[4][0],+A[4][1],+A[4][2],+b[4],+A[4][4],+A[4][5]],[+A[5][0],+A[5][1],+A[5][2],+b[5],+A[5][4],+A[5][5]]]),det([[+A[0][0],+A[0][1],+A[0][2],+A[0][3],+b[0],+A[0][5]],[+A[1][0],+A[1][1],+A[1][2],+A[1][3],+b[1],+A[1][5]],[+A[2][0],+A[2][1],+A[2][2],+A[2][3],+b[2],+A[2][5]],[+A[3][0],+A[3][1],+A[3][2],+A[3][3],+b[3],+A[3][5]],[+A[4][0],+A[4][1],+A[4][2],+A[4][3],+b[4],+A[4][5]],[+A[5][0],+A[5][1],+A[5][2],+A[5][3],+b[5],+A[5][5]]]),det([[+A[0][0],+A[0][1],+A[0][2],+A[0][3],+A[0][4],+b[0]],[+A[1][0],+A[1][1],+A[1][2],+A[1][3],+A[1][4],+b[1]],[+A[2][0],+A[2][1],+A[2][2],+A[2][3],+A[2][4],+b[2]],[+A[3][0],+A[3][1],+A[3][2],+A[3][3],+A[3][4],+b[3]],[+A[4][0],+A[4][1],+A[4][2],+A[4][3],+A[4][4],+b[4]],[+A[5][0],+A[5][1],+A[5][2],+A[5][3],+A[5][4],+b[5]]]),det(A)];};}var CACHE=[robustLinearSolve0d,robustLinearSolve1d];function proc(s0,s1,s2,s3,s4,s5,CACHE,g){return function dispatchLinearSolve(A,b){switch(A.length){case 0:return s0(A,b);case 1:return s1(A,b);case 2:return s2(A,b);case 3:return s3(A,b);case 4:return s4(A,b);case 5:return s5(A,b);}var s=CACHE[A.length];if(!s)s=CACHE[A.length]=g(A.length);return s(A,b);};}function generateDispatch(){while(CACHE.length<NUM_EXPAND){CACHE.push(generateSolver(CACHE.length));}module.exports=proc.apply(undefined,CACHE.concat([CACHE,generateSolver]));for(var i=0;i<NUM_EXPAND;++i){module.exports[i]=CACHE[i];}}generateDispatch();/***/},/***/417:/***/function(module,__unused_webpack_exports,__nested_webpack_require_778358__){"use strict";var twoProduct=__nested_webpack_require_778358__(9660);var robustSum=__nested_webpack_require_778358__(9662);var robustScale=__nested_webpack_require_778358__(8289);var robustSubtract=__nested_webpack_require_778358__(4078);var NUM_EXPAND=5;var EPSILON=1.1102230246251565e-16;var ERRBOUND3=(3.0+16.0*EPSILON)*EPSILON;var ERRBOUND4=(7.0+56.0*EPSILON)*EPSILON;function orientation_3(sum,prod,scale,sub){return function orientation3Exact(m0,m1,m2){var p=sum(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0])));var n=sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0]));var d=sub(p,n);return d[d.length-1];};}function orientation_4(sum,prod,scale,sub){return function orientation4Exact(m0,m1,m2,m3){var p=sum(sum(scale(sum(prod(m2[1],m3[0]),prod(-m3[1],m2[0])),m1[2]),sum(scale(sum(prod(m1[1],m3[0]),prod(-m3[1],m1[0])),-m2[2]),scale(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),m3[2]))),sum(scale(sum(prod(m1[1],m3[0]),prod(-m3[1],m1[0])),m0[2]),sum(scale(sum(prod(m0[1],m3[0]),prod(-m3[1],m0[0])),-m1[2]),scale(sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0])),m3[2]))));var n=sum(sum(scale(sum(prod(m2[1],m3[0]),prod(-m3[1],m2[0])),m0[2]),sum(scale(sum(prod(m0[1],m3[0]),prod(-m3[1],m0[0])),-m2[2]),scale(sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0])),m3[2]))),sum(scale(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),m0[2]),sum(scale(sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0])),-m1[2]),scale(sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0])),m2[2]))));var d=sub(p,n);return d[d.length-1];};}function orientation_5(sum,prod,scale,sub){return function orientation5Exact(m0,m1,m2,m3,m4){var p=sum(sum(sum(scale(sum(scale(sum(prod(m3[1],m4[0]),prod(-m4[1],m3[0])),m2[2]),sum(scale(sum(prod(m2[1],m4[0]),prod(-m4[1],m2[0])),-m3[2]),scale(sum(prod(m2[1],m3[0]),prod(-m3[1],m2[0])),m4[2]))),m1[3]),sum(scale(sum(scale(sum(prod(m3[1],m4[0]),prod(-m4[1],m3[0])),m1[2]),sum(scale(sum(prod(m1[1],m4[0]),prod(-m4[1],m1[0])),-m3[2]),scale(sum(prod(m1[1],m3[0]),prod(-m3[1],m1[0])),m4[2]))),-m2[3]),scale(sum(scale(sum(prod(m2[1],m4[0]),prod(-m4[1],m2[0])),m1[2]),sum(scale(sum(prod(m1[1],m4[0]),prod(-m4[1],m1[0])),-m2[2]),scale(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),m4[2]))),m3[3]))),sum(scale(sum(scale(sum(prod(m2[1],m3[0]),prod(-m3[1],m2[0])),m1[2]),sum(scale(sum(prod(m1[1],m3[0]),prod(-m3[1],m1[0])),-m2[2]),scale(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),m3[2]))),-m4[3]),sum(scale(sum(scale(sum(prod(m3[1],m4[0]),prod(-m4[1],m3[0])),m1[2]),sum(scale(sum(prod(m1[1],m4[0]),prod(-m4[1],m1[0])),-m3[2]),scale(sum(prod(m1[1],m3[0]),prod(-m3[1],m1[0])),m4[2]))),m0[3]),scale(sum(scale(sum(prod(m3[1],m4[0]),prod(-m4[1],m3[0])),m0[2]),sum(scale(sum(prod(m0[1],m4[0]),prod(-m4[1],m0[0])),-m3[2]),scale(sum(prod(m0[1],m3[0]),prod(-m3[1],m0[0])),m4[2]))),-m1[3])))),sum(sum(scale(sum(scale(sum(prod(m1[1],m4[0]),prod(-m4[1],m1[0])),m0[2]),sum(scale(sum(prod(m0[1],m4[0]),prod(-m4[1],m0[0])),-m1[2]),scale(sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0])),m4[2]))),m3[3]),sum(scale(sum(scale(sum(prod(m1[1],m3[0]),prod(-m3[1],m1[0])),m0[2]),sum(scale(sum(prod(m0[1],m3[0]),prod(-m3[1],m0[0])),-m1[2]),scale(sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0])),m3[2]))),-m4[3]),scale(sum(scale(sum(prod(m2[1],m3[0]),prod(-m3[1],m2[0])),m1[2]),sum(scale(sum(prod(m1[1],m3[0]),prod(-m3[1],m1[0])),-m2[2]),scale(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),m3[2]))),m0[3]))),sum(scale(sum(scale(sum(prod(m2[1],m3[0]),prod(-m3[1],m2[0])),m0[2]),sum(scale(sum(prod(m0[1],m3[0]),prod(-m3[1],m0[0])),-m2[2]),scale(sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0])),m3[2]))),-m1[3]),sum(scale(sum(scale(sum(prod(m1[1],m3[0]),prod(-m3[1],m1[0])),m0[2]),sum(scale(sum(prod(m0[1],m3[0]),prod(-m3[1],m0[0])),-m1[2]),scale(sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0])),m3[2]))),m2[3]),scale(sum(scale(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),m0[2]),sum(scale(sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0])),-m1[2]),scale(sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0])),m2[2]))),-m3[3])))));var n=sum(sum(sum(scale(sum(scale(sum(prod(m3[1],m4[0]),prod(-m4[1],m3[0])),m2[2]),sum(scale(sum(prod(m2[1],m4[0]),prod(-m4[1],m2[0])),-m3[2]),scale(sum(prod(m2[1],m3[0]),prod(-m3[1],m2[0])),m4[2]))),m0[3]),scale(sum(scale(sum(prod(m3[1],m4[0]),prod(-m4[1],m3[0])),m0[2]),sum(scale(sum(prod(m0[1],m4[0]),prod(-m4[1],m0[0])),-m3[2]),scale(sum(prod(m0[1],m3[0]),prod(-m3[1],m0[0])),m4[2]))),-m2[3])),sum(scale(sum(scale(sum(prod(m2[1],m4[0]),prod(-m4[1],m2[0])),m0[2]),sum(scale(sum(prod(m0[1],m4[0]),prod(-m4[1],m0[0])),-m2[2]),scale(sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0])),m4[2]))),m3[3]),scale(sum(scale(sum(prod(m2[1],m3[0]),prod(-m3[1],m2[0])),m0[2]),sum(scale(sum(prod(m0[1],m3[0]),prod(-m3[1],m0[0])),-m2[2]),scale(sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0])),m3[2]))),-m4[3]))),sum(sum(scale(sum(scale(sum(prod(m2[1],m4[0]),prod(-m4[1],m2[0])),m1[2]),sum(scale(sum(prod(m1[1],m4[0]),prod(-m4[1],m1[0])),-m2[2]),scale(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),m4[2]))),m0[3]),scale(sum(scale(sum(prod(m2[1],m4[0]),prod(-m4[1],m2[0])),m0[2]),sum(scale(sum(prod(m0[1],m4[0]),prod(-m4[1],m0[0])),-m2[2]),scale(sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0])),m4[2]))),-m1[3])),sum(scale(sum(scale(sum(prod(m1[1],m4[0]),prod(-m4[1],m1[0])),m0[2]),sum(scale(sum(prod(m0[1],m4[0]),prod(-m4[1],m0[0])),-m1[2]),scale(sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0])),m4[2]))),m2[3]),scale(sum(scale(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),m0[2]),sum(scale(sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0])),-m1[2]),scale(sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0])),m2[2]))),-m4[3]))));var d=sub(p,n);return d[d.length-1];};}function orientation(n){var fn=n===3?orientation_3:n===4?orientation_4:orientation_5;return fn(robustSum,twoProduct,robustScale,robustSubtract);}var orientation3Exact=orientation(3);var orientation4Exact=orientation(4);var CACHED=[function orientation0(){return 0;},function orientation1(){return 0;},function orientation2(a,b){return b[0]-a[0];},function orientation3(a,b,c){var l=(a[1]-c[1])*(b[0]-c[0]);var r=(a[0]-c[0])*(b[1]-c[1]);var det=l-r;var s;if(l>0){if(r<=0){return det;}else{s=l+r;}}else if(l<0){if(r>=0){return det;}else{s=-(l+r);}}else{return det;}var tol=ERRBOUND3*s;if(det>=tol||det<=-tol){return det;}return orientation3Exact(a,b,c);},function orientation4(a,b,c,d){var adx=a[0]-d[0];var bdx=b[0]-d[0];var cdx=c[0]-d[0];var ady=a[1]-d[1];var bdy=b[1]-d[1];var cdy=c[1]-d[1];var adz=a[2]-d[2];var bdz=b[2]-d[2];var cdz=c[2]-d[2];var bdxcdy=bdx*cdy;var cdxbdy=cdx*bdy;var cdxady=cdx*ady;var adxcdy=adx*cdy;var adxbdy=adx*bdy;var bdxady=bdx*ady;var det=adz*(bdxcdy-cdxbdy)+bdz*(cdxady-adxcdy)+cdz*(adxbdy-bdxady);var permanent=(Math.abs(bdxcdy)+Math.abs(cdxbdy))*Math.abs(adz)+(Math.abs(cdxady)+Math.abs(adxcdy))*Math.abs(bdz)+(Math.abs(adxbdy)+Math.abs(bdxady))*Math.abs(cdz);var tol=ERRBOUND4*permanent;if(det>tol||-det>tol){return det;}return orientation4Exact(a,b,c,d);}];function slowOrient(args){var proc=CACHED[args.length];if(!proc){proc=CACHED[args.length]=orientation(args.length);}return proc.apply(undefined,args);}function proc(slow,o0,o1,o2,o3,o4,o5){return function getOrientation(a0,a1,a2,a3,a4){switch(arguments.length){case 0:case 1:return 0;case 2:return o2(a0,a1);case 3:return o3(a0,a1,a2);case 4:return o4(a0,a1,a2,a3);case 5:return o5(a0,a1,a2,a3,a4);}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i];}return slow(s);};}function generateOrientationProc(){while(CACHED.length<=NUM_EXPAND){CACHED.push(orientation(CACHED.length));}module.exports=proc.apply(undefined,[slowOrient].concat(CACHED));for(var i=0;i<=NUM_EXPAND;++i){module.exports[i]=CACHED[i];}}generateOrientationProc();/***/},/***/2019:/***/function(module,__unused_webpack_exports,__nested_webpack_require_785963__){"use strict";var robustSum=__nested_webpack_require_785963__(9662);var robustScale=__nested_webpack_require_785963__(8289);module.exports=robustProduct;function robustProduct(a,b){if(a.length===1){return robustScale(b,a[0]);}if(b.length===1){return robustScale(a,b[0]);}if(a.length===0||b.length===0){return[0];}var r=[0];if(a.length<b.length){for(var i=0;i<a.length;++i){r=robustSum(r,robustScale(b,a[i]));}}else{for(var i=0;i<b.length;++i){r=robustSum(r,robustScale(a,b[i]));}}return r;}/***/},/***/8289:/***/function(module,__unused_webpack_exports,__nested_webpack_require_786508__){"use strict";var twoProduct=__nested_webpack_require_786508__(9660);var twoSum=__nested_webpack_require_786508__(87);module.exports=scaleLinearExpansion;function scaleLinearExpansion(e,scale){var n=e.length;if(n===1){var ts=twoProduct(e[0],scale);if(ts[0]){return ts;}return[ts[1]];}var g=new Array(2*n);var q=[0.1,0.1];var t=[0.1,0.1];var count=0;twoProduct(e[0],scale,q);if(q[0]){g[count++]=q[0];}for(var i=1;i<n;++i){twoProduct(e[i],scale,t);var pq=q[1];twoSum(pq,t[0],q);if(q[0]){g[count++]=q[0];}var a=t[1];var b=q[1];var x=a+b;var bv=x-a;var y=b-bv;q[1]=x;if(y){g[count++]=y;}}if(q[1]){g[count++]=q[1];}if(count===0){g[count++]=0.0;}g.length=count;return g;}/***/},/***/4434:/***/function(module,__unused_webpack_exports,__nested_webpack_require_787228__){"use strict";module.exports=segmentsIntersect;var orient=__nested_webpack_require_787228__(417)[3];function checkCollinear(a0,a1,b0,b1){for(var d=0;d<2;++d){var x0=a0[d];var y0=a1[d];var l0=Math.min(x0,y0);var h0=Math.max(x0,y0);var x1=b0[d];var y1=b1[d];var l1=Math.min(x1,y1);var h1=Math.max(x1,y1);if(h1<l0||h0<l1){return false;}}return true;}function segmentsIntersect(a0,a1,b0,b1){var x0=orient(a0,b0,b1);var y0=orient(a1,b0,b1);if(x0>0&&y0>0||x0<0&&y0<0){return false;}var x1=orient(b0,a0,a1);var y1=orient(b1,a0,a1);if(x1>0&&y1>0||x1<0&&y1<0){return false;}//Check for degenerate collinear case
if(x0===0&&y0===0&&x1===0&&y1===0){return checkCollinear(a0,a1,b0,b1);}return true;}/***/},/***/4078:/***/function(module){"use strict";module.exports=robustSubtract;//Easy case: Add two scalars
function scalarScalar(a,b){var x=a+b;var bv=x-a;var av=x-bv;var br=b-bv;var ar=a-av;var y=ar+br;if(y){return[y,x];}return[x];}function robustSubtract(e,f){var ne=e.length|0;var nf=f.length|0;if(ne===1&&nf===1){return scalarScalar(e[0],-f[0]);}var n=ne+nf;var g=new Array(n);var count=0;var eptr=0;var fptr=0;var abs=Math.abs;var ei=e[eptr];var ea=abs(ei);var fi=-f[fptr];var fa=abs(fi);var a,b;if(ea<fa){b=ei;eptr+=1;if(eptr<ne){ei=e[eptr];ea=abs(ei);}}else{b=fi;fptr+=1;if(fptr<nf){fi=-f[fptr];fa=abs(fi);}}if(eptr<ne&&ea<fa||fptr>=nf){a=ei;eptr+=1;if(eptr<ne){ei=e[eptr];ea=abs(ei);}}else{a=fi;fptr+=1;if(fptr<nf){fi=-f[fptr];fa=abs(fi);}}var x=a+b;var bv=x-a;var y=b-bv;var q0=y;var q1=x;var _x,_bv,_av,_br,_ar;while(eptr<ne&&fptr<nf){if(ea<fa){a=ei;eptr+=1;if(eptr<ne){ei=e[eptr];ea=abs(ei);}}else{a=fi;fptr+=1;if(fptr<nf){fi=-f[fptr];fa=abs(fi);}}b=q0;x=a+b;bv=x-a;y=b-bv;if(y){g[count++]=y;}_x=q1+x;_bv=_x-q1;_av=_x-_bv;_br=x-_bv;_ar=q1-_av;q0=_ar+_br;q1=_x;}while(eptr<ne){a=ei;b=q0;x=a+b;bv=x-a;y=b-bv;if(y){g[count++]=y;}_x=q1+x;_bv=_x-q1;_av=_x-_bv;_br=x-_bv;_ar=q1-_av;q0=_ar+_br;q1=_x;eptr+=1;if(eptr<ne){ei=e[eptr];}}while(fptr<nf){a=fi;b=q0;x=a+b;bv=x-a;y=b-bv;if(y){g[count++]=y;}_x=q1+x;_bv=_x-q1;_av=_x-_bv;_br=x-_bv;_ar=q1-_av;q0=_ar+_br;q1=_x;fptr+=1;if(fptr<nf){fi=-f[fptr];}}if(q0){g[count++]=q0;}if(q1){g[count++]=q1;}if(!count){g[count++]=0.0;}g.length=count;return g;}/***/},/***/9662:/***/function(module){"use strict";module.exports=linearExpansionSum;//Easy case: Add two scalars
function scalarScalar(a,b){var x=a+b;var bv=x-a;var av=x-bv;var br=b-bv;var ar=a-av;var y=ar+br;if(y){return[y,x];}return[x];}function linearExpansionSum(e,f){var ne=e.length|0;var nf=f.length|0;if(ne===1&&nf===1){return scalarScalar(e[0],f[0]);}var n=ne+nf;var g=new Array(n);var count=0;var eptr=0;var fptr=0;var abs=Math.abs;var ei=e[eptr];var ea=abs(ei);var fi=f[fptr];var fa=abs(fi);var a,b;if(ea<fa){b=ei;eptr+=1;if(eptr<ne){ei=e[eptr];ea=abs(ei);}}else{b=fi;fptr+=1;if(fptr<nf){fi=f[fptr];fa=abs(fi);}}if(eptr<ne&&ea<fa||fptr>=nf){a=ei;eptr+=1;if(eptr<ne){ei=e[eptr];ea=abs(ei);}}else{a=fi;fptr+=1;if(fptr<nf){fi=f[fptr];fa=abs(fi);}}var x=a+b;var bv=x-a;var y=b-bv;var q0=y;var q1=x;var _x,_bv,_av,_br,_ar;while(eptr<ne&&fptr<nf){if(ea<fa){a=ei;eptr+=1;if(eptr<ne){ei=e[eptr];ea=abs(ei);}}else{a=fi;fptr+=1;if(fptr<nf){fi=f[fptr];fa=abs(fi);}}b=q0;x=a+b;bv=x-a;y=b-bv;if(y){g[count++]=y;}_x=q1+x;_bv=_x-q1;_av=_x-_bv;_br=x-_bv;_ar=q1-_av;q0=_ar+_br;q1=_x;}while(eptr<ne){a=ei;b=q0;x=a+b;bv=x-a;y=b-bv;if(y){g[count++]=y;}_x=q1+x;_bv=_x-q1;_av=_x-_bv;_br=x-_bv;_ar=q1-_av;q0=_ar+_br;q1=_x;eptr+=1;if(eptr<ne){ei=e[eptr];}}while(fptr<nf){a=fi;b=q0;x=a+b;bv=x-a;y=b-bv;if(y){g[count++]=y;}_x=q1+x;_bv=_x-q1;_av=_x-_bv;_br=x-_bv;_ar=q1-_av;q0=_ar+_br;q1=_x;fptr+=1;if(fptr<nf){fi=f[fptr];}}if(q0){g[count++]=q0;}if(q1){g[count++]=q1;}if(!count){g[count++]=0.0;}g.length=count;return g;}/***/},/***/8691:/***/function(module,__unused_webpack_exports,__nested_webpack_require_790992__){"use strict";module.exports=boundary;var bnd=__nested_webpack_require_790992__(2692);var reduce=__nested_webpack_require_790992__(7037);function boundary(cells){return reduce(bnd(cells));}/***/},/***/7212:/***/function(module,__unused_webpack_exports,__nested_webpack_require_791236__){"use strict";module.exports=extractContour;var ndarray=__nested_webpack_require_791236__(5050);var pool=__nested_webpack_require_791236__(5306);var ndsort=__nested_webpack_require_791236__(8729);var contourAlgorithm=__nested_webpack_require_791236__(1168);function getDimension(cells){var numCells=cells.length;var d=0;for(var i=0;i<numCells;++i){d=Math.max(d,cells[i].length)|0;}return d-1;}function getSigns(values,level){var numVerts=values.length;var vertexSigns=pool.mallocUint8(numVerts);for(var i=0;i<numVerts;++i){vertexSigns[i]=values[i]<level|0;}return vertexSigns;}function getEdges(cells,d){var numCells=cells.length;var maxEdges=d*(d+1)/2*numCells|0;var edges=pool.mallocUint32(maxEdges*2);var ePtr=0;for(var i=0;i<numCells;++i){var c=cells[i];var d=c.length;for(var j=0;j<d;++j){for(var k=0;k<j;++k){var a=c[k];var b=c[j];edges[ePtr++]=Math.min(a,b)|0;edges[ePtr++]=Math.max(a,b)|0;}}}var nedges=ePtr/2|0;ndsort(ndarray(edges,[nedges,2]));var ptr=2;for(var i=2;i<ePtr;i+=2){if(edges[i-2]===edges[i]&&edges[i-1]===edges[i+1]){continue;}edges[ptr++]=edges[i];edges[ptr++]=edges[i+1];}return ndarray(edges,[ptr/2|0,2]);}function getCrossingWeights(edges,values,signs,level){var edata=edges.data;var numEdges=edges.shape[0];var weights=pool.mallocDouble(numEdges);var ptr=0;for(var i=0;i<numEdges;++i){var a=edata[2*i];var b=edata[2*i+1];if(signs[a]===signs[b]){continue;}var va=values[a];var vb=values[b];edata[2*ptr]=a;edata[2*ptr+1]=b;weights[ptr++]=(vb-level)/(vb-va);}edges.shape[0]=ptr;return ndarray(weights,[ptr]);}function getCascade(edges,numVerts){var result=pool.mallocInt32(numVerts*2);var numEdges=edges.shape[0];var edata=edges.data;result[0]=0;var lastV=0;for(var i=0;i<numEdges;++i){var a=edata[2*i];if(a!==lastV){result[2*lastV+1]=i;while(++lastV<a){result[2*lastV]=i;result[2*lastV+1]=i;}result[2*lastV]=i;}}result[2*lastV+1]=numEdges;while(++lastV<numVerts){result[2*lastV]=result[2*lastV+1]=numEdges;}return result;}function unpackEdges(edges){var ne=edges.shape[0]|0;var edata=edges.data;var result=new Array(ne);for(var i=0;i<ne;++i){result[i]=[edata[2*i],edata[2*i+1]];}return result;}function extractContour(cells,values,level,d){level=level||0.0;//If user didn't specify `d`, use brute force scan
if(typeof d==='undefined'){d=getDimension(cells);}//Count number of cells
var numCells=cells.length;if(numCells===0||d<1){return{cells:[],vertexIds:[],vertexWeights:[]};}//Read in vertex signs
var vertexSigns=getSigns(values,+level);//First get 1-skeleton, find all crossings
var edges=getEdges(cells,d);var weights=getCrossingWeights(edges,values,vertexSigns,+level);//Build vertex cascade to speed up binary search
var vcascade=getCascade(edges,values.length|0);//Then construct cells
var faces=contourAlgorithm(d)(cells,edges.data,vcascade,vertexSigns);//Unpack data into pretty format
var uedges=unpackEdges(edges);var uweights=[].slice.call(weights.data,0,weights.shape[0]);//Release data
pool.free(vertexSigns);pool.free(edges.data);pool.free(weights.data);pool.free(vcascade);return{cells:faces,vertexIds:uedges,vertexWeights:uweights};}/***/},/***/1168:/***/function(module){"use strict";module.exports=getPolygonizer;var allFns=[function cellPolygonizer_0(){function B(C,E,i,j){var a=Math.min(i,j)|0,b=Math.max(i,j)|0,l=C[2*a],h=C[2*a+1];while(l<h){var m=l+h>>1,v=E[2*m+1];if(v===b){return m;}if(b<v){h=m;}else{l=m+1;}}return l;}function getContour0d(F,E,C,S){var n=F.length,R=[];for(var i=0;i<n;++i){var c=F[i],l=c.length;}return R;}return getContour0d;},function cellPolygonizer_1(){function B(C,E,i,j){var a=Math.min(i,j)|0,b=Math.max(i,j)|0,l=C[2*a],h=C[2*a+1];while(l<h){var m=l+h>>1,v=E[2*m+1];if(v===b){return m;}if(b<v){h=m;}else{l=m+1;}}return l;}function getContour1d(F,E,C,S){var n=F.length,R=[];for(var i=0;i<n;++i){var c=F[i],l=c.length;if(l===2){var M=(S[c[0]]<<0)+(S[c[1]]<<1);if(M===0||M===3){continue;}switch(M){case 0:break;case 1:R.push([B(C,E,c[0],c[1])]);break;case 2:R.push([B(C,E,c[1],c[0])]);break;case 3:break;}}}return R;}return getContour1d;},function cellPolygonizer_2(){function B(C,E,i,j){var a=Math.min(i,j)|0,b=Math.max(i,j)|0,l=C[2*a],h=C[2*a+1];while(l<h){var m=l+h>>1,v=E[2*m+1];if(v===b){return m;}if(b<v){h=m;}else{l=m+1;}}return l;}function getContour2d(F,E,C,S){var n=F.length,R=[];for(var i=0;i<n;++i){var c=F[i],l=c.length;if(l===3){var M=(S[c[0]]<<0)+(S[c[1]]<<1)+(S[c[2]]<<2);if(M===0||M===7){continue;}switch(M){case 0:break;case 1:R.push([B(C,E,c[0],c[2]),B(C,E,c[0],c[1])]);break;case 2:R.push([B(C,E,c[1],c[0]),B(C,E,c[1],c[2])]);break;case 3:R.push([B(C,E,c[0],c[2]),B(C,E,c[1],c[2])]);break;case 4:R.push([B(C,E,c[2],c[1]),B(C,E,c[2],c[0])]);break;case 5:R.push([B(C,E,c[2],c[1]),B(C,E,c[0],c[1])]);break;case 6:R.push([B(C,E,c[1],c[0]),B(C,E,c[2],c[0])]);break;case 7:break;}}else if(l===2){var M=(S[c[0]]<<0)+(S[c[1]]<<1);if(M===0||M===3){continue;}switch(M){case 0:break;case 1:R.push([B(C,E,c[0],c[1])]);break;case 2:R.push([B(C,E,c[1],c[0])]);break;case 3:break;}}}return R;}return getContour2d;},function cellPolygonizer_3(){function B(C,E,i,j){var a=Math.min(i,j)|0,b=Math.max(i,j)|0,l=C[2*a],h=C[2*a+1];while(l<h){var m=l+h>>1,v=E[2*m+1];if(v===b){return m;}if(b<v){h=m;}else{l=m+1;}}return l;}function getContour3d(F,E,C,S){var n=F.length,R=[];for(var i=0;i<n;++i){var c=F[i],l=c.length;if(l===4){var M=(S[c[0]]<<0)+(S[c[1]]<<1)+(S[c[2]]<<2)+(S[c[3]]<<3);if(M===0||M===15){continue;}switch(M){case 0:break;case 1:R.push([B(C,E,c[0],c[1]),B(C,E,c[0],c[2]),B(C,E,c[0],c[3])]);break;case 2:R.push([B(C,E,c[1],c[2]),B(C,E,c[1],c[0]),B(C,E,c[1],c[3])]);break;case 3:R.push([B(C,E,c[1],c[2]),B(C,E,c[0],c[2]),B(C,E,c[0],c[3])],[B(C,E,c[1],c[3]),B(C,E,c[1],c[2]),B(C,E,c[0],c[3])]);break;case 4:R.push([B(C,E,c[2],c[0]),B(C,E,c[2],c[1]),B(C,E,c[2],c[3])]);break;case 5:R.push([B(C,E,c[0],c[1]),B(C,E,c[2],c[1]),B(C,E,c[0],c[3])],[B(C,E,c[2],c[1]),B(C,E,c[2],c[3]),B(C,E,c[0],c[3])]);break;case 6:R.push([B(C,E,c[2],c[0]),B(C,E,c[1],c[0]),B(C,E,c[1],c[3])],[B(C,E,c[2],c[3]),B(C,E,c[2],c[0]),B(C,E,c[1],c[3])]);break;case 7:R.push([B(C,E,c[0],c[3]),B(C,E,c[1],c[3]),B(C,E,c[2],c[3])]);break;case 8:R.push([B(C,E,c[3],c[1]),B(C,E,c[3],c[0]),B(C,E,c[3],c[2])]);break;case 9:R.push([B(C,E,c[3],c[1]),B(C,E,c[0],c[1]),B(C,E,c[0],c[2])],[B(C,E,c[3],c[2]),B(C,E,c[3],c[1]),B(C,E,c[0],c[2])]);break;case 10:R.push([B(C,E,c[1],c[0]),B(C,E,c[3],c[0]),B(C,E,c[1],c[2])],[B(C,E,c[3],c[0]),B(C,E,c[3],c[2]),B(C,E,c[1],c[2])]);break;case 11:R.push([B(C,E,c[1],c[2]),B(C,E,c[0],c[2]),B(C,E,c[3],c[2])]);break;case 12:R.push([B(C,E,c[3],c[0]),B(C,E,c[2],c[0]),B(C,E,c[2],c[1])],[B(C,E,c[3],c[1]),B(C,E,c[3],c[0]),B(C,E,c[2],c[1])]);break;case 13:R.push([B(C,E,c[0],c[1]),B(C,E,c[2],c[1]),B(C,E,c[3],c[1])]);break;case 14:R.push([B(C,E,c[2],c[0]),B(C,E,c[1],c[0]),B(C,E,c[3],c[0])]);break;case 15:break;}}else if(l===3){var M=(S[c[0]]<<0)+(S[c[1]]<<1)+(S[c[2]]<<2);if(M===0||M===7){continue;}switch(M){case 0:break;case 1:R.push([B(C,E,c[0],c[2]),B(C,E,c[0],c[1])]);break;case 2:R.push([B(C,E,c[1],c[0]),B(C,E,c[1],c[2])]);break;case 3:R.push([B(C,E,c[0],c[2]),B(C,E,c[1],c[2])]);break;case 4:R.push([B(C,E,c[2],c[1]),B(C,E,c[2],c[0])]);break;case 5:R.push([B(C,E,c[2],c[1]),B(C,E,c[0],c[1])]);break;case 6:R.push([B(C,E,c[1],c[0]),B(C,E,c[2],c[0])]);break;case 7:break;}}else if(l===2){var M=(S[c[0]]<<0)+(S[c[1]]<<1);if(M===0||M===3){continue;}switch(M){case 0:break;case 1:R.push([B(C,E,c[0],c[1])]);break;case 2:R.push([B(C,E,c[1],c[0])]);break;case 3:break;}}}return R;}return getContour3d;}];function getPolygonizer(d){return allFns[d]();}/***/},/***/8211:/***/function(__unused_webpack_module,exports,__nested_webpack_require_798785__){"use strict";var __webpack_unused_export__;"use restrict";var bits=__nested_webpack_require_798785__(2288),UnionFind=__nested_webpack_require_798785__(1731);//Returns the dimension of a cell complex
function dimension(cells){var d=0,max=Math.max;for(var i=0,il=cells.length;i<il;++i){d=max(d,cells[i].length);}return d-1;}__webpack_unused_export__=dimension;//Counts the number of vertices in faces
function countVertices(cells){var vc=-1,max=Math.max;for(var i=0,il=cells.length;i<il;++i){var c=cells[i];for(var j=0,jl=c.length;j<jl;++j){vc=max(vc,c[j]);}}return vc+1;}__webpack_unused_export__=countVertices;//Returns a deep copy of cells
function cloneCells(cells){var ncells=new Array(cells.length);for(var i=0,il=cells.length;i<il;++i){ncells[i]=cells[i].slice(0);}return ncells;}__webpack_unused_export__=cloneCells;//Ranks a pair of cells up to permutation
function compareCells(a,b){var n=a.length,t=a.length-b.length,min=Math.min;if(t){return t;}switch(n){case 0:return 0;case 1:return a[0]-b[0];case 2:var d=a[0]+a[1]-b[0]-b[1];if(d){return d;}return min(a[0],a[1])-min(b[0],b[1]);case 3:var l1=a[0]+a[1],m1=b[0]+b[1];d=l1+a[2]-(m1+b[2]);if(d){return d;}var l0=min(a[0],a[1]),m0=min(b[0],b[1]),d=min(l0,a[2])-min(m0,b[2]);if(d){return d;}return min(l0+a[2],l1)-min(m0+b[2],m1);//TODO: Maybe optimize n=4 as well?
default:var as=a.slice(0);as.sort();var bs=b.slice(0);bs.sort();for(var i=0;i<n;++i){t=as[i]-bs[i];if(t){return t;}}return 0;}}exports.H=compareCells;function compareZipped(a,b){return compareCells(a[0],b[0]);}//Puts a cell complex into normal order for the purposes of findCell queries
function normalize(cells,attr){if(attr){var len=cells.length;var zipped=new Array(len);for(var i=0;i<len;++i){zipped[i]=[cells[i],attr[i]];}zipped.sort(compareZipped);for(var i=0;i<len;++i){cells[i]=zipped[i][0];attr[i]=zipped[i][1];}return cells;}else{cells.sort(compareCells);return cells;}}__webpack_unused_export__=normalize;//Removes all duplicate cells in the complex
function unique(cells){if(cells.length===0){return[];}var ptr=1,len=cells.length;for(var i=1;i<len;++i){var a=cells[i];if(compareCells(a,cells[i-1])){if(i===ptr){ptr++;continue;}cells[ptr++]=a;}}cells.length=ptr;return cells;}__webpack_unused_export__=unique;//Finds a cell in a normalized cell complex
function findCell(cells,c){var lo=0,hi=cells.length-1,r=-1;while(lo<=hi){var mid=lo+hi>>1,s=compareCells(cells[mid],c);if(s<=0){if(s===0){r=mid;}lo=mid+1;}else if(s>0){hi=mid-1;}}return r;}__webpack_unused_export__=findCell;//Builds an index for an n-cell.  This is more general than dual, but less efficient
function incidence(from_cells,to_cells){var index=new Array(from_cells.length);for(var i=0,il=index.length;i<il;++i){index[i]=[];}var b=[];for(var i=0,n=to_cells.length;i<n;++i){var c=to_cells[i];var cl=c.length;for(var k=1,kn=1<<cl;k<kn;++k){b.length=bits.popCount(k);var l=0;for(var j=0;j<cl;++j){if(k&1<<j){b[l++]=c[j];}}var idx=findCell(from_cells,b);if(idx<0){continue;}while(true){index[idx++].push(i);if(idx>=from_cells.length||compareCells(from_cells[idx],b)!==0){break;}}}}return index;}__webpack_unused_export__=incidence;//Computes the dual of the mesh.  This is basically an optimized version of buildIndex for the situation where from_cells is just the list of vertices
function dual(cells,vertex_count){if(!vertex_count){return incidence(unique(skeleton(cells,0)),cells,0);}var res=new Array(vertex_count);for(var i=0;i<vertex_count;++i){res[i]=[];}for(var i=0,len=cells.length;i<len;++i){var c=cells[i];for(var j=0,cl=c.length;j<cl;++j){res[c[j]].push(i);}}return res;}__webpack_unused_export__=dual;//Enumerates all cells in the complex
function explode(cells){var result=[];for(var i=0,il=cells.length;i<il;++i){var c=cells[i],cl=c.length|0;for(var j=1,jl=1<<cl;j<jl;++j){var b=[];for(var k=0;k<cl;++k){if(j>>>k&1){b.push(c[k]);}}result.push(b);}}return normalize(result);}__webpack_unused_export__=explode;//Enumerates all of the n-cells of a cell complex
function skeleton(cells,n){if(n<0){return[];}var result=[],k0=(1<<n+1)-1;for(var i=0;i<cells.length;++i){var c=cells[i];for(var k=k0;k<1<<c.length;k=bits.nextCombination(k)){var b=new Array(n+1),l=0;for(var j=0;j<c.length;++j){if(k&1<<j){b[l++]=c[j];}}result.push(b);}}return normalize(result);}__webpack_unused_export__=skeleton;//Computes the boundary of all cells, does not remove duplicates
function boundary(cells){var res=[];for(var i=0,il=cells.length;i<il;++i){var c=cells[i];for(var j=0,cl=c.length;j<cl;++j){var b=new Array(c.length-1);for(var k=0,l=0;k<cl;++k){if(k!==j){b[l++]=c[k];}}res.push(b);}}return normalize(res);}__webpack_unused_export__=boundary;//Computes connected components for a dense cell complex
function connectedComponents_dense(cells,vertex_count){var labels=new UnionFind(vertex_count);for(var i=0;i<cells.length;++i){var c=cells[i];for(var j=0;j<c.length;++j){for(var k=j+1;k<c.length;++k){labels.link(c[j],c[k]);}}}var components=[],component_labels=labels.ranks;for(var i=0;i<component_labels.length;++i){component_labels[i]=-1;}for(var i=0;i<cells.length;++i){var l=labels.find(cells[i][0]);if(component_labels[l]<0){component_labels[l]=components.length;components.push([cells[i].slice(0)]);}else{components[component_labels[l]].push(cells[i].slice(0));}}return components;}//Computes connected components for a sparse graph
function connectedComponents_sparse(cells){var vertices=unique(normalize(skeleton(cells,0))),labels=new UnionFind(vertices.length);for(var i=0;i<cells.length;++i){var c=cells[i];for(var j=0;j<c.length;++j){var vj=findCell(vertices,[c[j]]);for(var k=j+1;k<c.length;++k){labels.link(vj,findCell(vertices,[c[k]]));}}}var components=[],component_labels=labels.ranks;for(var i=0;i<component_labels.length;++i){component_labels[i]=-1;}for(var i=0;i<cells.length;++i){var l=labels.find(findCell(vertices,[cells[i][0]]));if(component_labels[l]<0){component_labels[l]=components.length;components.push([cells[i].slice(0)]);}else{components[component_labels[l]].push(cells[i].slice(0));}}return components;}//Computes connected components for a cell complex
function connectedComponents(cells,vertex_count){if(vertex_count){return connectedComponents_dense(cells,vertex_count);}return connectedComponents_sparse(cells);}__webpack_unused_export__=connectedComponents;/***/},/***/9392:/***/function(__unused_webpack_module,exports){"use strict";/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */"use restrict";//Number of bits in an integer
var INT_BITS=32;//Constants
exports.INT_BITS=INT_BITS;exports.INT_MAX=0x7fffffff;exports.INT_MIN=-1<<INT_BITS-1;//Returns -1, 0, +1 depending on sign of x
exports.sign=function(v){return(v>0)-(v<0);};//Computes absolute value of integer
exports.abs=function(v){var mask=v>>INT_BITS-1;return(v^mask)-mask;};//Computes minimum of integers x and y
exports.min=function(x,y){return y^(x^y)&-(x<y);};//Computes maximum of integers x and y
exports.max=function(x,y){return x^(x^y)&-(x<y);};//Checks if a number is a power of two
exports.isPow2=function(v){return!(v&v-1)&&!!v;};//Computes log base 2 of v
exports.log2=function(v){var r,shift;r=(v>0xFFFF)<<4;v>>>=r;shift=(v>0xFF)<<3;v>>>=shift;r|=shift;shift=(v>0xF)<<2;v>>>=shift;r|=shift;shift=(v>0x3)<<1;v>>>=shift;r|=shift;return r|v>>1;};//Computes log base 10 of v
exports.log10=function(v){return v>=1000000000?9:v>=100000000?8:v>=10000000?7:v>=1000000?6:v>=100000?5:v>=10000?4:v>=1000?3:v>=100?2:v>=10?1:0;};//Counts number of bits
exports.popCount=function(v){v=v-(v>>>1&0x55555555);v=(v&0x33333333)+(v>>>2&0x33333333);return(v+(v>>>4)&0xF0F0F0F)*0x1010101>>>24;};//Counts number of trailing zeros
function countTrailingZeros(v){var c=32;v&=-v;if(v)c--;if(v&0x0000FFFF)c-=16;if(v&0x00FF00FF)c-=8;if(v&0x0F0F0F0F)c-=4;if(v&0x33333333)c-=2;if(v&0x55555555)c-=1;return c;}exports.countTrailingZeros=countTrailingZeros;//Rounds to next power of 2
exports.nextPow2=function(v){v+=v===0;--v;v|=v>>>1;v|=v>>>2;v|=v>>>4;v|=v>>>8;v|=v>>>16;return v+1;};//Rounds down to previous power of 2
exports.prevPow2=function(v){v|=v>>>1;v|=v>>>2;v|=v>>>4;v|=v>>>8;v|=v>>>16;return v-(v>>>1);};//Computes parity of word
exports.parity=function(v){v^=v>>>16;v^=v>>>8;v^=v>>>4;v&=0xf;return 0x6996>>>v&1;};var REVERSE_TABLE=new Array(256);(function(tab){for(var i=0;i<256;++i){var v=i,r=i,s=7;for(v>>>=1;v;v>>>=1){r<<=1;r|=v&1;--s;}tab[i]=r<<s&0xff;}})(REVERSE_TABLE);//Reverse bits in a 32 bit word
exports.reverse=function(v){return REVERSE_TABLE[v&0xff]<<24|REVERSE_TABLE[v>>>8&0xff]<<16|REVERSE_TABLE[v>>>16&0xff]<<8|REVERSE_TABLE[v>>>24&0xff];};//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2=function(x,y){x&=0xFFFF;x=(x|x<<8)&0x00FF00FF;x=(x|x<<4)&0x0F0F0F0F;x=(x|x<<2)&0x33333333;x=(x|x<<1)&0x55555555;y&=0xFFFF;y=(y|y<<8)&0x00FF00FF;y=(y|y<<4)&0x0F0F0F0F;y=(y|y<<2)&0x33333333;y=(y|y<<1)&0x55555555;return x|y<<1;};//Extracts the nth interleaved component
exports.deinterleave2=function(v,n){v=v>>>n&0x55555555;v=(v|v>>>1)&0x33333333;v=(v|v>>>2)&0x0F0F0F0F;v=(v|v>>>4)&0x00FF00FF;v=(v|v>>>16)&0x000FFFF;return v<<16>>16;};//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3=function(x,y,z){x&=0x3FF;x=(x|x<<16)&4278190335;x=(x|x<<8)&251719695;x=(x|x<<4)&3272356035;x=(x|x<<2)&1227133513;y&=0x3FF;y=(y|y<<16)&4278190335;y=(y|y<<8)&251719695;y=(y|y<<4)&3272356035;y=(y|y<<2)&1227133513;x|=y<<1;z&=0x3FF;z=(z|z<<16)&4278190335;z=(z|z<<8)&251719695;z=(z|z<<4)&3272356035;z=(z|z<<2)&1227133513;return x|z<<2;};//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3=function(v,n){v=v>>>n&1227133513;v=(v|v>>>2)&3272356035;v=(v|v>>>4)&251719695;v=(v|v>>>8)&4278190335;v=(v|v>>>16)&0x3FF;return v<<22>>22;};//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination=function(v){var t=v|v-1;return t+1|(~t&-~t)-1>>>countTrailingZeros(v)+1;};/***/},/***/6656:/***/function(__unused_webpack_module,exports,__nested_webpack_require_808931__){"use strict";"use restrict";var bits=__nested_webpack_require_808931__(9392),UnionFind=__nested_webpack_require_808931__(9521);//Returns the dimension of a cell complex
function dimension(cells){var d=0,max=Math.max;for(var i=0,il=cells.length;i<il;++i){d=max(d,cells[i].length);}return d-1;}exports.dimension=dimension;//Counts the number of vertices in faces
function countVertices(cells){var vc=-1,max=Math.max;for(var i=0,il=cells.length;i<il;++i){var c=cells[i];for(var j=0,jl=c.length;j<jl;++j){vc=max(vc,c[j]);}}return vc+1;}exports.countVertices=countVertices;//Returns a deep copy of cells
function cloneCells(cells){var ncells=new Array(cells.length);for(var i=0,il=cells.length;i<il;++i){ncells[i]=cells[i].slice(0);}return ncells;}exports.cloneCells=cloneCells;//Ranks a pair of cells up to permutation
function compareCells(a,b){var n=a.length,t=a.length-b.length,min=Math.min;if(t){return t;}switch(n){case 0:return 0;case 1:return a[0]-b[0];case 2:var d=a[0]+a[1]-b[0]-b[1];if(d){return d;}return min(a[0],a[1])-min(b[0],b[1]);case 3:var l1=a[0]+a[1],m1=b[0]+b[1];d=l1+a[2]-(m1+b[2]);if(d){return d;}var l0=min(a[0],a[1]),m0=min(b[0],b[1]),d=min(l0,a[2])-min(m0,b[2]);if(d){return d;}return min(l0+a[2],l1)-min(m0+b[2],m1);//TODO: Maybe optimize n=4 as well?
default:var as=a.slice(0);as.sort();var bs=b.slice(0);bs.sort();for(var i=0;i<n;++i){t=as[i]-bs[i];if(t){return t;}}return 0;}}exports.compareCells=compareCells;function compareZipped(a,b){return compareCells(a[0],b[0]);}//Puts a cell complex into normal order for the purposes of findCell queries
function normalize(cells,attr){if(attr){var len=cells.length;var zipped=new Array(len);for(var i=0;i<len;++i){zipped[i]=[cells[i],attr[i]];}zipped.sort(compareZipped);for(var i=0;i<len;++i){cells[i]=zipped[i][0];attr[i]=zipped[i][1];}return cells;}else{cells.sort(compareCells);return cells;}}exports.normalize=normalize;//Removes all duplicate cells in the complex
function unique(cells){if(cells.length===0){return[];}var ptr=1,len=cells.length;for(var i=1;i<len;++i){var a=cells[i];if(compareCells(a,cells[i-1])){if(i===ptr){ptr++;continue;}cells[ptr++]=a;}}cells.length=ptr;return cells;}exports.unique=unique;//Finds a cell in a normalized cell complex
function findCell(cells,c){var lo=0,hi=cells.length-1,r=-1;while(lo<=hi){var mid=lo+hi>>1,s=compareCells(cells[mid],c);if(s<=0){if(s===0){r=mid;}lo=mid+1;}else if(s>0){hi=mid-1;}}return r;}exports.findCell=findCell;//Builds an index for an n-cell.  This is more general than dual, but less efficient
function incidence(from_cells,to_cells){var index=new Array(from_cells.length);for(var i=0,il=index.length;i<il;++i){index[i]=[];}var b=[];for(var i=0,n=to_cells.length;i<n;++i){var c=to_cells[i];var cl=c.length;for(var k=1,kn=1<<cl;k<kn;++k){b.length=bits.popCount(k);var l=0;for(var j=0;j<cl;++j){if(k&1<<j){b[l++]=c[j];}}var idx=findCell(from_cells,b);if(idx<0){continue;}while(true){index[idx++].push(i);if(idx>=from_cells.length||compareCells(from_cells[idx],b)!==0){break;}}}}return index;}exports.incidence=incidence;//Computes the dual of the mesh.  This is basically an optimized version of buildIndex for the situation where from_cells is just the list of vertices
function dual(cells,vertex_count){if(!vertex_count){return incidence(unique(skeleton(cells,0)),cells,0);}var res=new Array(vertex_count);for(var i=0;i<vertex_count;++i){res[i]=[];}for(var i=0,len=cells.length;i<len;++i){var c=cells[i];for(var j=0,cl=c.length;j<cl;++j){res[c[j]].push(i);}}return res;}exports.dual=dual;//Enumerates all cells in the complex
function explode(cells){var result=[];for(var i=0,il=cells.length;i<il;++i){var c=cells[i],cl=c.length|0;for(var j=1,jl=1<<cl;j<jl;++j){var b=[];for(var k=0;k<cl;++k){if(j>>>k&1){b.push(c[k]);}}result.push(b);}}return normalize(result);}exports.explode=explode;//Enumerates all of the n-cells of a cell complex
function skeleton(cells,n){if(n<0){return[];}var result=[],k0=(1<<n+1)-1;for(var i=0;i<cells.length;++i){var c=cells[i];for(var k=k0;k<1<<c.length;k=bits.nextCombination(k)){var b=new Array(n+1),l=0;for(var j=0;j<c.length;++j){if(k&1<<j){b[l++]=c[j];}}result.push(b);}}return normalize(result);}exports.skeleton=skeleton;//Computes the boundary of all cells, does not remove duplicates
function boundary(cells){var res=[];for(var i=0,il=cells.length;i<il;++i){var c=cells[i];for(var j=0,cl=c.length;j<cl;++j){var b=new Array(c.length-1);for(var k=0,l=0;k<cl;++k){if(k!==j){b[l++]=c[k];}}res.push(b);}}return normalize(res);}exports.boundary=boundary;//Computes connected components for a dense cell complex
function connectedComponents_dense(cells,vertex_count){var labels=new UnionFind(vertex_count);for(var i=0;i<cells.length;++i){var c=cells[i];for(var j=0;j<c.length;++j){for(var k=j+1;k<c.length;++k){labels.link(c[j],c[k]);}}}var components=[],component_labels=labels.ranks;for(var i=0;i<component_labels.length;++i){component_labels[i]=-1;}for(var i=0;i<cells.length;++i){var l=labels.find(cells[i][0]);if(component_labels[l]<0){component_labels[l]=components.length;components.push([cells[i].slice(0)]);}else{components[component_labels[l]].push(cells[i].slice(0));}}return components;}//Computes connected components for a sparse graph
function connectedComponents_sparse(cells){var vertices=unique(normalize(skeleton(cells,0))),labels=new UnionFind(vertices.length);for(var i=0;i<cells.length;++i){var c=cells[i];for(var j=0;j<c.length;++j){var vj=findCell(vertices,[c[j]]);for(var k=j+1;k<c.length;++k){labels.link(vj,findCell(vertices,[c[k]]));}}}var components=[],component_labels=labels.ranks;for(var i=0;i<component_labels.length;++i){component_labels[i]=-1;}for(var i=0;i<cells.length;++i){var l=labels.find(findCell(vertices,[cells[i][0]]));if(component_labels[l]<0){component_labels[l]=components.length;components.push([cells[i].slice(0)]);}else{components[component_labels[l]].push(cells[i].slice(0));}}return components;}//Computes connected components for a cell complex
function connectedComponents(cells,vertex_count){if(vertex_count){return connectedComponents_dense(cells,vertex_count);}return connectedComponents_sparse(cells);}exports.connectedComponents=connectedComponents;/***/},/***/9521:/***/function(module){"use strict";"use restrict";module.exports=UnionFind;function UnionFind(count){this.roots=new Array(count);this.ranks=new Array(count);for(var i=0;i<count;++i){this.roots[i]=i;this.ranks[i]=0;}}UnionFind.prototype.length=function(){return this.roots.length;};UnionFind.prototype.makeSet=function(){var n=this.roots.length;this.roots.push(n);this.ranks.push(0);return n;};UnionFind.prototype.find=function(x){var roots=this.roots;while(roots[x]!==x){var y=roots[x];roots[x]=roots[y];x=y;}return x;};UnionFind.prototype.link=function(x,y){var xr=this.find(x),yr=this.find(y);if(xr===yr){return;}var ranks=this.ranks,roots=this.roots,xd=ranks[xr],yd=ranks[yr];if(xd<yd){roots[xr]=yr;}else if(yd<xd){roots[yr]=xr;}else{roots[yr]=xr;++ranks[xr];}};/***/},/***/8243:/***/function(module,__unused_webpack_exports,__nested_webpack_require_815945__){"use strict";module.exports=simplifyPolygon;var orient=__nested_webpack_require_815945__(417);var sc=__nested_webpack_require_815945__(6656);function errorWeight(base,a,b){var area=Math.abs(orient(base,a,b));var perim=Math.sqrt(Math.pow(a[0]-b[0],2)+Math.pow(a[1]-b[1],2));return area/perim;}function simplifyPolygon(cells,positions,minArea){var n=positions.length;var nc=cells.length;var inv=new Array(n);var outv=new Array(n);var weights=new Array(n);var dead=new Array(n);//Initialize tables
for(var i=0;i<n;++i){inv[i]=outv[i]=-1;weights[i]=Infinity;dead[i]=false;}//Compute neighbors
for(var i=0;i<nc;++i){var c=cells[i];if(c.length!==2){throw new Error("Input must be a graph");}var s=c[1];var t=c[0];if(outv[t]!==-1){outv[t]=-2;}else{outv[t]=s;}if(inv[s]!==-1){inv[s]=-2;}else{inv[s]=t;}}//Updates the weight for vertex i
function computeWeight(i){if(dead[i]){return Infinity;}//TODO: Check that the line segment doesn't cross once simplified
var s=inv[i];var t=outv[i];if(s<0||t<0){return Infinity;}else{return errorWeight(positions[i],positions[s],positions[t]);}}//Swaps two nodes on the heap (i,j) are the index of the nodes
function heapSwap(i,j){var a=heap[i];var b=heap[j];heap[i]=b;heap[j]=a;index[a]=j;index[b]=i;}//Returns the weight of node i on the heap
function heapWeight(i){return weights[heap[i]];}function heapParent(i){if(i&1){return i-1>>1;}return(i>>1)-1;}//Bubble element i down the heap
function heapDown(i){var w=heapWeight(i);while(true){var tw=w;var left=2*i+1;var right=2*(i+1);var next=i;if(left<heapCount){var lw=heapWeight(left);if(lw<tw){next=left;tw=lw;}}if(right<heapCount){var rw=heapWeight(right);if(rw<tw){next=right;}}if(next===i){return i;}heapSwap(i,next);i=next;}}//Bubbles element i up the heap
function heapUp(i){var w=heapWeight(i);while(i>0){var parent=heapParent(i);if(parent>=0){var pw=heapWeight(parent);if(w<pw){heapSwap(i,parent);i=parent;continue;}}return i;}}//Pop minimum element
function heapPop(){if(heapCount>0){var head=heap[0];heapSwap(0,heapCount-1);heapCount-=1;heapDown(0);return head;}return-1;}//Update heap item i
function heapUpdate(i,w){var a=heap[i];if(weights[a]===w){return i;}weights[a]=-Infinity;heapUp(i);heapPop();weights[a]=w;heapCount+=1;return heapUp(heapCount-1);}//Kills a vertex (assume vertex already removed from heap)
function kill(i){if(dead[i]){return;}//Kill vertex
dead[i]=true;//Fixup topology
var s=inv[i];var t=outv[i];if(inv[t]>=0){inv[t]=s;}if(outv[s]>=0){outv[s]=t;}//Update weights on s and t
if(index[s]>=0){heapUpdate(index[s],computeWeight(s));}if(index[t]>=0){heapUpdate(index[t],computeWeight(t));}}//Initialize weights and heap
var heap=[];var index=new Array(n);for(var i=0;i<n;++i){var w=weights[i]=computeWeight(i);if(w<Infinity){index[i]=heap.length;heap.push(i);}else{index[i]=-1;}}var heapCount=heap.length;for(var i=heapCount>>1;i>=0;--i){heapDown(i);}//Kill vertices
while(true){var hmin=heapPop();if(hmin<0||weights[hmin]>minArea){break;}kill(hmin);}//Build collapsed vertex table
var npositions=[];for(var i=0;i<n;++i){if(!dead[i]){index[i]=npositions.length;npositions.push(positions[i].slice());}}var nv=npositions.length;function tortoiseHare(seq,start){if(seq[start]<0){return start;}var t=start;var h=start;do{//Walk two steps with h
var nh=seq[h];if(!dead[h]||nh<0||nh===h){break;}h=nh;nh=seq[h];if(!dead[h]||nh<0||nh===h){break;}h=nh;//Walk one step with t
t=seq[t];}while(t!==h);//Compress cycles
for(var v=start;v!==h;v=seq[v]){seq[v]=h;}return h;}var ncells=[];cells.forEach(function(c){var tin=tortoiseHare(inv,c[0]);var tout=tortoiseHare(outv,c[1]);if(tin>=0&&tout>=0&&tin!==tout){var cin=index[tin];var cout=index[tout];if(cin!==cout){ncells.push([cin,cout]);}}});//Normalize result
sc.unique(sc.normalize(ncells));//Return final list of cells
return{positions:npositions,edges:ncells};}/***/},/***/6638:/***/function(module,__unused_webpack_exports,__nested_webpack_require_819815__){"use strict";module.exports=orderSegments;var orient=__nested_webpack_require_819815__(417);function horizontalOrder(a,b){var bl,br;if(b[0][0]<b[1][0]){bl=b[0];br=b[1];}else if(b[0][0]>b[1][0]){bl=b[1];br=b[0];}else{var alo=Math.min(a[0][1],a[1][1]);var ahi=Math.max(a[0][1],a[1][1]);var blo=Math.min(b[0][1],b[1][1]);var bhi=Math.max(b[0][1],b[1][1]);if(ahi<blo){return ahi-blo;}if(alo>bhi){return alo-bhi;}return ahi-bhi;}var al,ar;if(a[0][1]<a[1][1]){al=a[0];ar=a[1];}else{al=a[1];ar=a[0];}var d=orient(br,bl,al);if(d){return d;}d=orient(br,bl,ar);if(d){return d;}return ar-br;}function orderSegments(b,a){var al,ar;if(a[0][0]<a[1][0]){al=a[0];ar=a[1];}else if(a[0][0]>a[1][0]){al=a[1];ar=a[0];}else{return horizontalOrder(a,b);}var bl,br;if(b[0][0]<b[1][0]){bl=b[0];br=b[1];}else if(b[0][0]>b[1][0]){bl=b[1];br=b[0];}else{return-horizontalOrder(b,a);}var d1=orient(al,ar,br);var d2=orient(al,ar,bl);if(d1<0){if(d2<=0){return d1;}}else if(d1>0){if(d2>=0){return d1;}}else if(d2){return d2;}d1=orient(br,bl,ar);d2=orient(br,bl,al);if(d1<0){if(d2<=0){return d1;}}else if(d1>0){if(d2>=0){return d1;}}else if(d2){return d2;}return ar[0]-br[0];}/***/},/***/4385:/***/function(module,__unused_webpack_exports,__nested_webpack_require_821028__){"use strict";module.exports=createSlabDecomposition;var bounds=__nested_webpack_require_821028__(5070);var createRBTree=__nested_webpack_require_821028__(7080);var orient=__nested_webpack_require_821028__(417);var orderSegments=__nested_webpack_require_821028__(6638);function SlabDecomposition(slabs,coordinates,horizontal){this.slabs=slabs;this.coordinates=coordinates;this.horizontal=horizontal;}var proto=SlabDecomposition.prototype;function compareHorizontal(e,y){return e.y-y;}function searchBucket(root,p){var lastNode=null;while(root){var seg=root.key;var l,r;if(seg[0][0]<seg[1][0]){l=seg[0];r=seg[1];}else{l=seg[1];r=seg[0];}var o=orient(l,r,p);if(o<0){root=root.left;}else if(o>0){if(p[0]!==seg[1][0]){lastNode=root;root=root.right;}else{var val=searchBucket(root.right,p);if(val){return val;}root=root.left;}}else{if(p[0]!==seg[1][0]){return root;}else{var val=searchBucket(root.right,p);if(val){return val;}root=root.left;}}}return lastNode;}proto.castUp=function(p){var bucket=bounds.le(this.coordinates,p[0]);if(bucket<0){return-1;}var root=this.slabs[bucket];var hitNode=searchBucket(this.slabs[bucket],p);var lastHit=-1;if(hitNode){lastHit=hitNode.value;}//Edge case: need to handle horizontal segments (sucks)
if(this.coordinates[bucket]===p[0]){var lastSegment=null;if(hitNode){lastSegment=hitNode.key;}if(bucket>0){var otherHitNode=searchBucket(this.slabs[bucket-1],p);if(otherHitNode){if(lastSegment){if(orderSegments(otherHitNode.key,lastSegment)>0){lastSegment=otherHitNode.key;lastHit=otherHitNode.value;}}else{lastHit=otherHitNode.value;lastSegment=otherHitNode.key;}}}var horiz=this.horizontal[bucket];if(horiz.length>0){var hbucket=bounds.ge(horiz,p[1],compareHorizontal);if(hbucket<horiz.length){var e=horiz[hbucket];if(p[1]===e.y){if(e.closed){return e.index;}else{while(hbucket<horiz.length-1&&horiz[hbucket+1].y===p[1]){hbucket=hbucket+1;e=horiz[hbucket];if(e.closed){return e.index;}}if(e.y===p[1]&&!e.start){hbucket=hbucket+1;if(hbucket>=horiz.length){return lastHit;}e=horiz[hbucket];}}}//Check if e is above/below last segment
if(e.start){if(lastSegment){var o=orient(lastSegment[0],lastSegment[1],[p[0],e.y]);if(lastSegment[0][0]>lastSegment[1][0]){o=-o;}if(o>0){lastHit=e.index;}}else{lastHit=e.index;}}else if(e.y!==p[1]){lastHit=e.index;}}}}return lastHit;};function IntervalSegment(y,index,start,closed){this.y=y;this.index=index;this.start=start;this.closed=closed;}function Event(x,segment,create,index){this.x=x;this.segment=segment;this.create=create;this.index=index;}function createSlabDecomposition(segments){var numSegments=segments.length;var numEvents=2*numSegments;var events=new Array(numEvents);for(var i=0;i<numSegments;++i){var s=segments[i];var f=s[0][0]<s[1][0];events[2*i]=new Event(s[0][0],s,f,i);events[2*i+1]=new Event(s[1][0],s,!f,i);}events.sort(function(a,b){var d=a.x-b.x;if(d){return d;}d=a.create-b.create;if(d){return d;}return Math.min(a.segment[0][1],a.segment[1][1])-Math.min(b.segment[0][1],b.segment[1][1]);});var tree=createRBTree(orderSegments);var slabs=[];var lines=[];var horizontal=[];var lastX=-Infinity;for(var i=0;i<numEvents;){var x=events[i].x;var horiz=[];while(i<numEvents){var e=events[i];if(e.x!==x){break;}i+=1;if(e.segment[0][0]===e.x&&e.segment[1][0]===e.x){if(e.create){if(e.segment[0][1]<e.segment[1][1]){horiz.push(new IntervalSegment(e.segment[0][1],e.index,true,true));horiz.push(new IntervalSegment(e.segment[1][1],e.index,false,false));}else{horiz.push(new IntervalSegment(e.segment[1][1],e.index,true,false));horiz.push(new IntervalSegment(e.segment[0][1],e.index,false,true));}}}else{if(e.create){tree=tree.insert(e.segment,e.index);}else{tree=tree.remove(e.segment);}}}slabs.push(tree.root);lines.push(x);horizontal.push(horiz);}return new SlabDecomposition(slabs,lines,horizontal);}/***/},/***/4670:/***/function(module,__unused_webpack_exports,__nested_webpack_require_824840__){"use strict";var robustDot=__nested_webpack_require_824840__(9130);var robustSum=__nested_webpack_require_824840__(9662);module.exports=splitPolygon;module.exports.positive=positive;module.exports.negative=negative;function planeT(p,plane){var r=robustSum(robustDot(p,plane),[plane[plane.length-1]]);return r[r.length-1];}//Can't do this exactly and emit a floating point result
function lerpW(a,wa,b,wb){var d=wb-wa;var t=-wa/d;if(t<0.0){t=0.0;}else if(t>1.0){t=1.0;}var ti=1.0-t;var n=a.length;var r=new Array(n);for(var i=0;i<n;++i){r[i]=t*a[i]+ti*b[i];}return r;}function splitPolygon(points,plane){var pos=[];var neg=[];var a=planeT(points[points.length-1],plane);for(var s=points[points.length-1],t=points[0],i=0;i<points.length;++i,s=t){t=points[i];var b=planeT(t,plane);if(a<0&&b>0||a>0&&b<0){var p=lerpW(s,b,t,a);pos.push(p);neg.push(p.slice());}if(b<0){neg.push(t.slice());}else if(b>0){pos.push(t.slice());}else{pos.push(t.slice());neg.push(t.slice());}a=b;}return{positive:pos,negative:neg};}function positive(points,plane){var pos=[];var a=planeT(points[points.length-1],plane);for(var s=points[points.length-1],t=points[0],i=0;i<points.length;++i,s=t){t=points[i];var b=planeT(t,plane);if(a<0&&b>0||a>0&&b<0){pos.push(lerpW(s,b,t,a));}if(b>=0){pos.push(t.slice());}a=b;}return pos;}function negative(points,plane){var neg=[];var a=planeT(points[points.length-1],plane);for(var s=points[points.length-1],t=points[0],i=0;i<points.length;++i,s=t){t=points[i];var b=planeT(t,plane);if(a<0&&b>0||a>0&&b<0){neg.push(lerpW(s,b,t,a));}if(b<=0){neg.push(t.slice());}a=b;}return neg;}/***/},/***/8974:/***/function(module,exports,__nested_webpack_require_826467__){var __WEBPACK_AMD_DEFINE_RESULT__;/* global window, exports, define */!function(){'use strict';var re={not_string:/[^s]/,not_bool:/[^t]/,not_type:/[^T]/,not_primitive:/[^v]/,number:/[diefg]/,numeric_arg:/[bcdiefguxX]/,json:/[j]/,not_json:/[^j]/,text:/^[^\x25]+/,modulo:/^\x25{2}/,placeholder:/^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,key:/^([a-z_][a-z_\d]*)/i,key_access:/^\.([a-z_][a-z_\d]*)/i,index_access:/^\[(\d+)\]/,sign:/^[+-]/};function sprintf(key){// `arguments` is not an array, but should be fine for this call
return sprintf_format(sprintf_parse(key),arguments);}function vsprintf(fmt,argv){return sprintf.apply(null,[fmt].concat(argv||[]));}function sprintf_format(parse_tree,argv){var cursor=1,tree_length=parse_tree.length,arg,output='',i,k,ph,pad,pad_character,pad_length,is_positive,sign;for(i=0;i<tree_length;i++){if(typeof parse_tree[i]==='string'){output+=parse_tree[i];}else if(typeof parse_tree[i]==='object'){ph=parse_tree[i];// convenience purposes only
if(ph.keys){// keyword argument
arg=argv[cursor];for(k=0;k<ph.keys.length;k++){if(arg==undefined){throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"',ph.keys[k],ph.keys[k-1]));}arg=arg[ph.keys[k]];}}else if(ph.param_no){// positional argument (explicit)
arg=argv[ph.param_no];}else{// positional argument (implicit)
arg=argv[cursor++];}if(re.not_type.test(ph.type)&&re.not_primitive.test(ph.type)&&arg instanceof Function){arg=arg();}if(re.numeric_arg.test(ph.type)&&typeof arg!=='number'&&isNaN(arg)){throw new TypeError(sprintf('[sprintf] expecting number but found %T',arg));}if(re.number.test(ph.type)){is_positive=arg>=0;}switch(ph.type){case'b':arg=parseInt(arg,10).toString(2);break;case'c':arg=String.fromCharCode(parseInt(arg,10));break;case'd':case'i':arg=parseInt(arg,10);break;case'j':arg=JSON.stringify(arg,null,ph.width?parseInt(ph.width):0);break;case'e':arg=ph.precision?parseFloat(arg).toExponential(ph.precision):parseFloat(arg).toExponential();break;case'f':arg=ph.precision?parseFloat(arg).toFixed(ph.precision):parseFloat(arg);break;case'g':arg=ph.precision?String(Number(arg.toPrecision(ph.precision))):parseFloat(arg);break;case'o':arg=(parseInt(arg,10)>>>0).toString(8);break;case's':arg=String(arg);arg=ph.precision?arg.substring(0,ph.precision):arg;break;case't':arg=String(!!arg);arg=ph.precision?arg.substring(0,ph.precision):arg;break;case'T':arg=Object.prototype.toString.call(arg).slice(8,-1).toLowerCase();arg=ph.precision?arg.substring(0,ph.precision):arg;break;case'u':arg=parseInt(arg,10)>>>0;break;case'v':arg=arg.valueOf();arg=ph.precision?arg.substring(0,ph.precision):arg;break;case'x':arg=(parseInt(arg,10)>>>0).toString(16);break;case'X':arg=(parseInt(arg,10)>>>0).toString(16).toUpperCase();break;}if(re.json.test(ph.type)){output+=arg;}else{if(re.number.test(ph.type)&&(!is_positive||ph.sign)){sign=is_positive?'+':'-';arg=arg.toString().replace(re.sign,'');}else{sign='';}pad_character=ph.pad_char?ph.pad_char==='0'?'0':ph.pad_char.charAt(1):' ';pad_length=ph.width-(sign+arg).length;pad=ph.width?pad_length>0?pad_character.repeat(pad_length):'':'';output+=ph.align?sign+arg+pad:pad_character==='0'?sign+pad+arg:pad+sign+arg;}}}return output;}var sprintf_cache=Object.create(null);function sprintf_parse(fmt){if(sprintf_cache[fmt]){return sprintf_cache[fmt];}var _fmt=fmt,match,parse_tree=[],arg_names=0;while(_fmt){if((match=re.text.exec(_fmt))!==null){parse_tree.push(match[0]);}else if((match=re.modulo.exec(_fmt))!==null){parse_tree.push('%');}else if((match=re.placeholder.exec(_fmt))!==null){if(match[2]){arg_names|=1;var field_list=[],replacement_field=match[2],field_match=[];if((field_match=re.key.exec(replacement_field))!==null){field_list.push(field_match[1]);while((replacement_field=replacement_field.substring(field_match[0].length))!==''){if((field_match=re.key_access.exec(replacement_field))!==null){field_list.push(field_match[1]);}else if((field_match=re.index_access.exec(replacement_field))!==null){field_list.push(field_match[1]);}else{throw new SyntaxError('[sprintf] failed to parse named argument key');}}}else{throw new SyntaxError('[sprintf] failed to parse named argument key');}match[2]=field_list;}else{arg_names|=2;}if(arg_names===3){throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');}parse_tree.push({placeholder:match[0],param_no:match[1],keys:match[2],sign:match[3],pad_char:match[4],align:match[5],width:match[6],precision:match[7],type:match[8]});}else{throw new SyntaxError('[sprintf] unexpected placeholder');}_fmt=_fmt.substring(match[0].length);}return sprintf_cache[fmt]=parse_tree;}/**
     * export to either browser or node.js
     */ /* eslint-disable quote-props */if(true){exports.sprintf=sprintf;exports.vsprintf=vsprintf;}if(typeof window!=='undefined'){window['sprintf']=sprintf;window['vsprintf']=vsprintf;if(true){!(__WEBPACK_AMD_DEFINE_RESULT__=function(){return{'sprintf':sprintf,'vsprintf':vsprintf};}.call(exports,__nested_webpack_require_826467__,exports,module),__WEBPACK_AMD_DEFINE_RESULT__!==undefined&&(module.exports=__WEBPACK_AMD_DEFINE_RESULT__));}}/* eslint-enable quote-props */}();// eslint-disable-line
/***/},/***/4162:/***/function(module,__unused_webpack_exports,__nested_webpack_require_831759__){"use strict";module.exports=surfaceNets;var generateContourExtractor=__nested_webpack_require_831759__(9284);var zeroCrossings=__nested_webpack_require_831759__(9584);var allFns={"2d":function(genContour,order,dtype){var contour=genContour({order:order,scalarArguments:3,getters:dtype==="generic"?[0]:undefined,phase:function phaseFunc(p,a,b,c){return p>c|0;},vertex:function vertexFunc(d0,d1,v0,v1,v2,v3,p0,p1,p2,p3,a,b,c){var m=(p0<<0)+(p1<<1)+(p2<<2)+(p3<<3)|0;if(m===0||m===15){return;}switch(m){case 0:a.push([d0-0.5,d1-0.5]);break;case 1:a.push([d0-0.25-0.25*(v1+v0-2*c)/(v0-v1),d1-0.25-0.25*(v2+v0-2*c)/(v0-v2)]);break;case 2:a.push([d0-0.75-0.25*(-v1-v0+2*c)/(v1-v0),d1-0.25-0.25*(v3+v1-2*c)/(v1-v3)]);break;case 3:a.push([d0-0.5,d1-0.5-0.5*(v2+v0+v3+v1-4*c)/(v0-v2+v1-v3)]);break;case 4:a.push([d0-0.25-0.25*(v3+v2-2*c)/(v2-v3),d1-0.75-0.25*(-v2-v0+2*c)/(v2-v0)]);break;case 5:a.push([d0-0.5-0.5*(v1+v0+v3+v2-4*c)/(v0-v1+v2-v3),d1-0.5]);break;case 6:a.push([d0-0.5-0.25*(-v1-v0+v3+v2)/(v1-v0+v2-v3),d1-0.5-0.25*(-v2-v0+v3+v1)/(v2-v0+v1-v3)]);break;case 7:a.push([d0-0.75-0.25*(v3+v2-2*c)/(v2-v3),d1-0.75-0.25*(v3+v1-2*c)/(v1-v3)]);break;case 8:a.push([d0-0.75-0.25*(-v3-v2+2*c)/(v3-v2),d1-0.75-0.25*(-v3-v1+2*c)/(v3-v1)]);break;case 9:a.push([d0-0.5-0.25*(v1+v0+-v3-v2)/(v0-v1+v3-v2),d1-0.5-0.25*(v2+v0+-v3-v1)/(v0-v2+v3-v1)]);break;case 10:a.push([d0-0.5-0.5*(-v1-v0+-v3-v2+4*c)/(v1-v0+v3-v2),d1-0.5]);break;case 11:a.push([d0-0.25-0.25*(-v3-v2+2*c)/(v3-v2),d1-0.75-0.25*(v2+v0-2*c)/(v0-v2)]);break;case 12:a.push([d0-0.5,d1-0.5-0.5*(-v2-v0+-v3-v1+4*c)/(v2-v0+v3-v1)]);break;case 13:a.push([d0-0.75-0.25*(v1+v0-2*c)/(v0-v1),d1-0.25-0.25*(-v3-v1+2*c)/(v3-v1)]);break;case 14:a.push([d0-0.25-0.25*(-v1-v0+2*c)/(v1-v0),d1-0.25-0.25*(-v2-v0+2*c)/(v2-v0)]);break;case 15:a.push([d0-0.5,d1-0.5]);break;}},cell:function cellFunc(v0,v1,c0,c1,p0,p1,a,b,c){if(p0){b.push([v0,v1]);}else{b.push([v1,v0]);}}});return function(array,level){var verts=[],cells=[];contour(array,verts,cells,level);return{positions:verts,cells:cells};};}};function buildSurfaceNets(order,dtype){var inKey=order.length+'d';var fn=allFns[inKey];if(fn)return fn(generateContourExtractor,order,dtype);}//1D case: Need to handle specially
function mesh1D(array,level){var zc=zeroCrossings(array,level);var n=zc.length;var npos=new Array(n);var ncel=new Array(n);for(var i=0;i<n;++i){npos[i]=[zc[i]];ncel[i]=[i];}return{positions:npos,cells:ncel};}var CACHE={};function surfaceNets(array,level){if(array.dimension<=0){return{positions:[],cells:[]};}else if(array.dimension===1){return mesh1D(array,level);}var typesig=array.order.join()+"-"+array.dtype;var proc=CACHE[typesig];var level=+level||0.0;if(!proc){proc=CACHE[typesig]=buildSurfaceNets(array.order,array.dtype);}return proc(array,level);}/***/},/***/6946:/***/function(module,__unused_webpack_exports,__nested_webpack_require_834583__){"use strict";module.exports=textGet;var vectorizeText=__nested_webpack_require_834583__(875);var globals=window||process.global||{};var __TEXT_CACHE=globals.__TEXT_CACHE||{};globals.__TEXT_CACHE={};function unwrap(mesh){var cells=mesh.cells;var positions=mesh.positions;var data=new Float32Array(cells.length*6);var ptr=0;var shapeX=0;for(var i=0;i<cells.length;++i){var tri=cells[i];for(var j=0;j<3;++j){var point=positions[tri[j]];data[ptr++]=point[0];data[ptr++]=point[1]+1.4;shapeX=Math.max(point[0],shapeX);}}return{data:data,shape:shapeX};}function textGet(font,text,opts){var opts=opts||{};var fontcache=__TEXT_CACHE[font];if(!fontcache){fontcache=__TEXT_CACHE[font]={' ':{data:new Float32Array(0),shape:0.2}};}var mesh=fontcache[text];if(!mesh){if(text.length<=1||!/\d/.test(text)){mesh=fontcache[text]=unwrap(vectorizeText(text,{triangles:true,font:font,textAlign:opts.textAlign||'left',textBaseline:'alphabetic',styletags:{breaklines:true,bolds:true,italics:true,subscripts:true,superscripts:true}}));}else{var parts=text.split(/(\d|\s)/);var buffer=new Array(parts.length);var bufferSize=0;var shapeX=0;for(var i=0;i<parts.length;++i){buffer[i]=textGet(font,parts[i]);bufferSize+=buffer[i].data.length;shapeX+=buffer[i].shape;if(i>0){shapeX+=0.02;}}var data=new Float32Array(bufferSize);var ptr=0;var xOffset=-0.5*shapeX;for(var i=0;i<buffer.length;++i){var bdata=buffer[i].data;for(var j=0;j<bdata.length;j+=2){data[ptr++]=bdata[j]+xOffset;data[ptr++]=bdata[j+1];}xOffset+=buffer[i].shape+0.02;}mesh=fontcache[text]={data:data,shape:shapeX};}}return mesh;}/***/},/***/14:/***/function(module,__unused_webpack_exports,__nested_webpack_require_836219__){"use strict";var parseUnit=__nested_webpack_require_836219__(4405);module.exports=toPX;var PIXELS_PER_INCH=96;function getPropertyInPX(element,prop){var parts=parseUnit(getComputedStyle(element).getPropertyValue(prop));return parts[0]*toPX(parts[1],element);}//This brutal hack is needed
function getSizeBrutal(unit,element){var testDIV=document.createElement('div');testDIV.style['font-size']='128'+unit;element.appendChild(testDIV);var size=getPropertyInPX(testDIV,'font-size')/128;element.removeChild(testDIV);return size;}function toPX(str,element){element=element||document.body;str=(str||'px').trim().toLowerCase();if(element===window||element===document){element=document.body;}switch(str){case'%'://Ambiguous, not sure if we should use width or height
return element.clientHeight/100.0;case'ch':case'ex':return getSizeBrutal(str,element);case'em':return getPropertyInPX(element,'font-size');case'rem':return getPropertyInPX(document.body,'font-size');case'vw':return window.innerWidth/100;case'vh':return window.innerHeight/100;case'vmin':return Math.min(window.innerWidth,window.innerHeight)/100;case'vmax':return Math.max(window.innerWidth,window.innerHeight)/100;case'in':return PIXELS_PER_INCH;case'cm':return PIXELS_PER_INCH/2.54;case'mm':return PIXELS_PER_INCH/25.4;case'pt':return PIXELS_PER_INCH/72;case'pc':return PIXELS_PER_INCH/6;}return 1;}/***/},/***/3440:/***/function(module,__unused_webpack_exports,__nested_webpack_require_837649__){"use strict";module.exports=createTurntableController;var filterVector=__nested_webpack_require_837649__(8444);var invert44=__nested_webpack_require_837649__(7437);var rotateM=__nested_webpack_require_837649__(4422);var cross=__nested_webpack_require_837649__(903);var normalize3=__nested_webpack_require_837649__(899);var dot3=__nested_webpack_require_837649__(9305);function len3(x,y,z){return Math.sqrt(Math.pow(x,2)+Math.pow(y,2)+Math.pow(z,2));}function clamp1(x){return Math.min(1.0,Math.max(-1.0,x));}function findOrthoPair(v){var vx=Math.abs(v[0]);var vy=Math.abs(v[1]);var vz=Math.abs(v[2]);var u=[0,0,0];if(vx>Math.max(vy,vz)){u[2]=1;}else if(vy>Math.max(vx,vz)){u[0]=1;}else{u[1]=1;}var vv=0;var uv=0;for(var i=0;i<3;++i){vv+=v[i]*v[i];uv+=u[i]*v[i];}for(var i=0;i<3;++i){u[i]-=uv/vv*v[i];}normalize3(u,u);return u;}function TurntableController(zoomMin,zoomMax,center,up,right,radius,theta,phi){this.center=filterVector(center);this.up=filterVector(up);this.right=filterVector(right);this.radius=filterVector([radius]);this.angle=filterVector([theta,phi]);this.angle.bounds=[[-Infinity,-Math.PI/2],[Infinity,Math.PI/2]];this.setDistanceLimits(zoomMin,zoomMax);this.computedCenter=this.center.curve(0);this.computedUp=this.up.curve(0);this.computedRight=this.right.curve(0);this.computedRadius=this.radius.curve(0);this.computedAngle=this.angle.curve(0);this.computedToward=[0,0,0];this.computedEye=[0,0,0];this.computedMatrix=new Array(16);for(var i=0;i<16;++i){this.computedMatrix[i]=0.5;}this.recalcMatrix(0);}var proto=TurntableController.prototype;proto.setDistanceLimits=function(minDist,maxDist){if(minDist>0){minDist=Math.log(minDist);}else{minDist=-Infinity;}if(maxDist>0){maxDist=Math.log(maxDist);}else{maxDist=Infinity;}maxDist=Math.max(maxDist,minDist);this.radius.bounds[0][0]=minDist;this.radius.bounds[1][0]=maxDist;};proto.getDistanceLimits=function(out){var bounds=this.radius.bounds[0];if(out){out[0]=Math.exp(bounds[0][0]);out[1]=Math.exp(bounds[1][0]);return out;}return[Math.exp(bounds[0][0]),Math.exp(bounds[1][0])];};proto.recalcMatrix=function(t){//Recompute curves
this.center.curve(t);this.up.curve(t);this.right.curve(t);this.radius.curve(t);this.angle.curve(t);//Compute frame for camera matrix
var up=this.computedUp;var right=this.computedRight;var uu=0.0;var ur=0.0;for(var i=0;i<3;++i){ur+=up[i]*right[i];uu+=up[i]*up[i];}var ul=Math.sqrt(uu);var rr=0.0;for(var i=0;i<3;++i){right[i]-=up[i]*ur/uu;rr+=right[i]*right[i];up[i]/=ul;}var rl=Math.sqrt(rr);for(var i=0;i<3;++i){right[i]/=rl;}//Compute toward vector
var toward=this.computedToward;cross(toward,up,right);normalize3(toward,toward);//Compute angular parameters
var radius=Math.exp(this.computedRadius[0]);var theta=this.computedAngle[0];var phi=this.computedAngle[1];var ctheta=Math.cos(theta);var stheta=Math.sin(theta);var cphi=Math.cos(phi);var sphi=Math.sin(phi);var center=this.computedCenter;var wx=ctheta*cphi;var wy=stheta*cphi;var wz=sphi;var sx=-ctheta*sphi;var sy=-stheta*sphi;var sz=cphi;var eye=this.computedEye;var mat=this.computedMatrix;for(var i=0;i<3;++i){var x=wx*right[i]+wy*toward[i]+wz*up[i];mat[4*i+1]=sx*right[i]+sy*toward[i]+sz*up[i];mat[4*i+2]=x;mat[4*i+3]=0.0;}var ax=mat[1];var ay=mat[5];var az=mat[9];var bx=mat[2];var by=mat[6];var bz=mat[10];var cx=ay*bz-az*by;var cy=az*bx-ax*bz;var cz=ax*by-ay*bx;var cl=len3(cx,cy,cz);cx/=cl;cy/=cl;cz/=cl;mat[0]=cx;mat[4]=cy;mat[8]=cz;for(var i=0;i<3;++i){eye[i]=center[i]+mat[2+4*i]*radius;}for(var i=0;i<3;++i){var rr=0.0;for(var j=0;j<3;++j){rr+=mat[i+4*j]*eye[j];}mat[12+i]=-rr;}mat[15]=1.0;};proto.getMatrix=function(t,result){this.recalcMatrix(t);var mat=this.computedMatrix;if(result){for(var i=0;i<16;++i){result[i]=mat[i];}return result;}return mat;};var zAxis=[0,0,0];proto.rotate=function(t,dtheta,dphi,droll){this.angle.move(t,dtheta,dphi);if(droll){this.recalcMatrix(t);var mat=this.computedMatrix;zAxis[0]=mat[2];zAxis[1]=mat[6];zAxis[2]=mat[10];var up=this.computedUp;var right=this.computedRight;var toward=this.computedToward;for(var i=0;i<3;++i){mat[4*i]=up[i];mat[4*i+1]=right[i];mat[4*i+2]=toward[i];}rotateM(mat,mat,droll,zAxis);for(var i=0;i<3;++i){up[i]=mat[4*i];right[i]=mat[4*i+1];}this.up.set(t,up[0],up[1],up[2]);this.right.set(t,right[0],right[1],right[2]);}};proto.pan=function(t,dx,dy,dz){dx=dx||0.0;dy=dy||0.0;dz=dz||0.0;this.recalcMatrix(t);var mat=this.computedMatrix;var dist=Math.exp(this.computedRadius[0]);var ux=mat[1];var uy=mat[5];var uz=mat[9];var ul=len3(ux,uy,uz);ux/=ul;uy/=ul;uz/=ul;var rx=mat[0];var ry=mat[4];var rz=mat[8];var ru=rx*ux+ry*uy+rz*uz;rx-=ux*ru;ry-=uy*ru;rz-=uz*ru;var rl=len3(rx,ry,rz);rx/=rl;ry/=rl;rz/=rl;var vx=rx*dx+ux*dy;var vy=ry*dx+uy*dy;var vz=rz*dx+uz*dy;this.center.move(t,vx,vy,vz);//Update z-component of radius
var radius=Math.exp(this.computedRadius[0]);radius=Math.max(1e-4,radius+dz);this.radius.set(t,Math.log(radius));};proto.translate=function(t,dx,dy,dz){this.center.move(t,dx||0.0,dy||0.0,dz||0.0);};//Recenters the coordinate axes
proto.setMatrix=function(t,mat,axes,noSnap){//Get the axes for tare
var ushift=1;if(typeof axes==='number'){ushift=axes|0;}if(ushift<0||ushift>3){ushift=1;}var vshift=(ushift+2)%3;var fshift=(ushift+1)%3;//Recompute state for new t value
if(!mat){this.recalcMatrix(t);mat=this.computedMatrix;}//Get right and up vectors
var ux=mat[ushift];var uy=mat[ushift+4];var uz=mat[ushift+8];if(!noSnap){var ul=len3(ux,uy,uz);ux/=ul;uy/=ul;uz/=ul;}else{var ax=Math.abs(ux);var ay=Math.abs(uy);var az=Math.abs(uz);var am=Math.max(ax,ay,az);if(ax===am){ux=ux<0?-1:1;uy=uz=0;}else if(az===am){uz=uz<0?-1:1;ux=uy=0;}else{uy=uy<0?-1:1;ux=uz=0;}}var rx=mat[vshift];var ry=mat[vshift+4];var rz=mat[vshift+8];var ru=rx*ux+ry*uy+rz*uz;rx-=ux*ru;ry-=uy*ru;rz-=uz*ru;var rl=len3(rx,ry,rz);rx/=rl;ry/=rl;rz/=rl;var fx=uy*rz-uz*ry;var fy=uz*rx-ux*rz;var fz=ux*ry-uy*rx;var fl=len3(fx,fy,fz);fx/=fl;fy/=fl;fz/=fl;this.center.jump(t,ex,ey,ez);this.radius.idle(t);this.up.jump(t,ux,uy,uz);this.right.jump(t,rx,ry,rz);var phi,theta;if(ushift===2){var cx=mat[1];var cy=mat[5];var cz=mat[9];var cr=cx*rx+cy*ry+cz*rz;var cf=cx*fx+cy*fy+cz*fz;if(tu<0){phi=-Math.PI/2;}else{phi=Math.PI/2;}theta=Math.atan2(cf,cr);}else{var tx=mat[2];var ty=mat[6];var tz=mat[10];var tu=tx*ux+ty*uy+tz*uz;var tr=tx*rx+ty*ry+tz*rz;var tf=tx*fx+ty*fy+tz*fz;phi=Math.asin(clamp1(tu));theta=Math.atan2(tf,tr);}this.angle.jump(t,theta,phi);this.recalcMatrix(t);var dx=mat[2];var dy=mat[6];var dz=mat[10];var imat=this.computedMatrix;invert44(imat,mat);var w=imat[15];var ex=imat[12]/w;var ey=imat[13]/w;var ez=imat[14]/w;var gs=Math.exp(this.computedRadius[0]);this.center.jump(t,ex-dx*gs,ey-dy*gs,ez-dz*gs);};proto.lastT=function(){return Math.max(this.center.lastT(),this.up.lastT(),this.right.lastT(),this.radius.lastT(),this.angle.lastT());};proto.idle=function(t){this.center.idle(t);this.up.idle(t);this.right.idle(t);this.radius.idle(t);this.angle.idle(t);};proto.flush=function(t){this.center.flush(t);this.up.flush(t);this.right.flush(t);this.radius.flush(t);this.angle.flush(t);};proto.setDistance=function(t,d){if(d>0){this.radius.set(t,Math.log(d));}};proto.lookAt=function(t,eye,center,up){this.recalcMatrix(t);eye=eye||this.computedEye;center=center||this.computedCenter;up=up||this.computedUp;var ux=up[0];var uy=up[1];var uz=up[2];var ul=len3(ux,uy,uz);if(ul<1e-6){return;}ux/=ul;uy/=ul;uz/=ul;var tx=eye[0]-center[0];var ty=eye[1]-center[1];var tz=eye[2]-center[2];var tl=len3(tx,ty,tz);if(tl<1e-6){return;}tx/=tl;ty/=tl;tz/=tl;var right=this.computedRight;var rx=right[0];var ry=right[1];var rz=right[2];var ru=ux*rx+uy*ry+uz*rz;rx-=ru*ux;ry-=ru*uy;rz-=ru*uz;var rl=len3(rx,ry,rz);if(rl<0.01){rx=uy*tz-uz*ty;ry=uz*tx-ux*tz;rz=ux*ty-uy*tx;rl=len3(rx,ry,rz);if(rl<1e-6){return;}}rx/=rl;ry/=rl;rz/=rl;this.up.set(t,ux,uy,uz);this.right.set(t,rx,ry,rz);this.center.set(t,center[0],center[1],center[2]);this.radius.set(t,Math.log(tl));var fx=uy*rz-uz*ry;var fy=uz*rx-ux*rz;var fz=ux*ry-uy*rx;var fl=len3(fx,fy,fz);fx/=fl;fy/=fl;fz/=fl;var tu=ux*tx+uy*ty+uz*tz;var tr=rx*tx+ry*ty+rz*tz;var tf=fx*tx+fy*ty+fz*tz;var phi=Math.asin(clamp1(tu));var theta=Math.atan2(tf,tr);var angleState=this.angle._state;var lastTheta=angleState[angleState.length-1];var lastPhi=angleState[angleState.length-2];lastTheta=lastTheta%(2.0*Math.PI);var dp=Math.abs(lastTheta+2.0*Math.PI-theta);var d0=Math.abs(lastTheta-theta);var dn=Math.abs(lastTheta-2.0*Math.PI-theta);if(dp<d0){lastTheta+=2.0*Math.PI;}if(dn<d0){lastTheta-=2.0*Math.PI;}this.angle.jump(this.angle.lastT(),lastTheta,lastPhi);this.angle.set(t,theta,phi);};function createTurntableController(options){options=options||{};var center=options.center||[0,0,0];var up=options.up||[0,1,0];var right=options.right||findOrthoPair(up);var radius=options.radius||1.0;var theta=options.theta||0.0;var phi=options.phi||0.0;center=[].slice.call(center,0,3);up=[].slice.call(up,0,3);normalize3(up,up);right=[].slice.call(right,0,3);normalize3(right,right);if('eye'in options){var eye=options.eye;var toward=[eye[0]-center[0],eye[1]-center[1],eye[2]-center[2]];cross(right,toward,up);if(len3(right[0],right[1],right[2])<1e-6){right=findOrthoPair(up);}else{normalize3(right,right);}radius=len3(toward[0],toward[1],toward[2]);var ut=dot3(up,toward)/radius;var rt=dot3(right,toward)/radius;phi=Math.acos(ut);theta=Math.acos(rt);}//Use logarithmic coordinates for radius
radius=Math.log(radius);//Return the controller
return new TurntableController(options.zoomMin,options.zoomMax,center,up,right,radius,theta,phi);}/***/},/***/9660:/***/function(module){"use strict";module.exports=twoProduct;var SPLITTER=+(Math.pow(2,27)+1.0);function twoProduct(a,b,result){var x=a*b;var c=SPLITTER*a;var abig=c-a;var ahi=c-abig;var alo=a-ahi;var d=SPLITTER*b;var bbig=d-b;var bhi=d-bbig;var blo=b-bhi;var err1=x-ahi*bhi;var err2=err1-alo*bhi;var err3=err2-ahi*blo;var y=alo*blo-err3;if(result){result[0]=y;result[1]=x;return result;}return[y,x];}/***/},/***/87:/***/function(module){"use strict";module.exports=fastTwoSum;function fastTwoSum(a,b,result){var x=a+b;var bv=x-a;var av=x-bv;var br=b-bv;var ar=a-av;if(result){result[0]=ar+br;result[1]=x;return result;}return[ar+br,x];}/***/},/***/5306:/***/function(__unused_webpack_module,exports,__nested_webpack_require_847784__){"use strict";var bits=__nested_webpack_require_847784__(2288);var dup=__nested_webpack_require_847784__(3094);var Buffer=__nested_webpack_require_847784__(2146)/* .Buffer */.lW;//Legacy pool support
if(!__nested_webpack_require_847784__.g.__TYPEDARRAY_POOL){__nested_webpack_require_847784__.g.__TYPEDARRAY_POOL={UINT8:dup([32,0]),UINT16:dup([32,0]),UINT32:dup([32,0]),BIGUINT64:dup([32,0]),INT8:dup([32,0]),INT16:dup([32,0]),INT32:dup([32,0]),BIGINT64:dup([32,0]),FLOAT:dup([32,0]),DOUBLE:dup([32,0]),DATA:dup([32,0]),UINT8C:dup([32,0]),BUFFER:dup([32,0])};}var hasUint8C=typeof Uint8ClampedArray!=='undefined';var hasBigUint64=typeof BigUint64Array!=='undefined';var hasBigInt64=typeof BigInt64Array!=='undefined';var POOL=__nested_webpack_require_847784__.g.__TYPEDARRAY_POOL;//Upgrade pool
if(!POOL.UINT8C){POOL.UINT8C=dup([32,0]);}if(!POOL.BIGUINT64){POOL.BIGUINT64=dup([32,0]);}if(!POOL.BIGINT64){POOL.BIGINT64=dup([32,0]);}if(!POOL.BUFFER){POOL.BUFFER=dup([32,0]);}//New technique: Only allocate from ArrayBufferView and Buffer
var DATA=POOL.DATA,BUFFER=POOL.BUFFER;exports.free=function free(array){if(Buffer.isBuffer(array)){BUFFER[bits.log2(array.length)].push(array);}else{if(Object.prototype.toString.call(array)!=='[object ArrayBuffer]'){array=array.buffer;}if(!array){return;}var n=array.length||array.byteLength;var log_n=bits.log2(n)|0;DATA[log_n].push(array);}};function freeArrayBuffer(buffer){if(!buffer){return;}var n=buffer.length||buffer.byteLength;var log_n=bits.log2(n);DATA[log_n].push(buffer);}function freeTypedArray(array){freeArrayBuffer(array.buffer);}exports.freeUint8=exports.freeUint16=exports.freeUint32=exports.freeBigUint64=exports.freeInt8=exports.freeInt16=exports.freeInt32=exports.freeBigInt64=exports.freeFloat32=exports.freeFloat=exports.freeFloat64=exports.freeDouble=exports.freeUint8Clamped=exports.freeDataView=freeTypedArray;exports.freeArrayBuffer=freeArrayBuffer;exports.freeBuffer=function freeBuffer(array){BUFFER[bits.log2(array.length)].push(array);};exports.malloc=function malloc(n,dtype){if(dtype===undefined||dtype==='arraybuffer'){return mallocArrayBuffer(n);}else{switch(dtype){case'uint8':return mallocUint8(n);case'uint16':return mallocUint16(n);case'uint32':return mallocUint32(n);case'int8':return mallocInt8(n);case'int16':return mallocInt16(n);case'int32':return mallocInt32(n);case'float':case'float32':return mallocFloat(n);case'double':case'float64':return mallocDouble(n);case'uint8_clamped':return mallocUint8Clamped(n);case'bigint64':return mallocBigInt64(n);case'biguint64':return mallocBigUint64(n);case'buffer':return mallocBuffer(n);case'data':case'dataview':return mallocDataView(n);default:return null;}}return null;};function mallocArrayBuffer(n){var n=bits.nextPow2(n);var log_n=bits.log2(n);var d=DATA[log_n];if(d.length>0){return d.pop();}return new ArrayBuffer(n);}exports.mallocArrayBuffer=mallocArrayBuffer;function mallocUint8(n){return new Uint8Array(mallocArrayBuffer(n),0,n);}exports.mallocUint8=mallocUint8;function mallocUint16(n){return new Uint16Array(mallocArrayBuffer(2*n),0,n);}exports.mallocUint16=mallocUint16;function mallocUint32(n){return new Uint32Array(mallocArrayBuffer(4*n),0,n);}exports.mallocUint32=mallocUint32;function mallocInt8(n){return new Int8Array(mallocArrayBuffer(n),0,n);}exports.mallocInt8=mallocInt8;function mallocInt16(n){return new Int16Array(mallocArrayBuffer(2*n),0,n);}exports.mallocInt16=mallocInt16;function mallocInt32(n){return new Int32Array(mallocArrayBuffer(4*n),0,n);}exports.mallocInt32=mallocInt32;function mallocFloat(n){return new Float32Array(mallocArrayBuffer(4*n),0,n);}exports.mallocFloat32=exports.mallocFloat=mallocFloat;function mallocDouble(n){return new Float64Array(mallocArrayBuffer(8*n),0,n);}exports.mallocFloat64=exports.mallocDouble=mallocDouble;function mallocUint8Clamped(n){if(hasUint8C){return new Uint8ClampedArray(mallocArrayBuffer(n),0,n);}else{return mallocUint8(n);}}exports.mallocUint8Clamped=mallocUint8Clamped;function mallocBigUint64(n){if(hasBigUint64){return new BigUint64Array(mallocArrayBuffer(8*n),0,n);}else{return null;}}exports.mallocBigUint64=mallocBigUint64;function mallocBigInt64(n){if(hasBigInt64){return new BigInt64Array(mallocArrayBuffer(8*n),0,n);}else{return null;}}exports.mallocBigInt64=mallocBigInt64;function mallocDataView(n){return new DataView(mallocArrayBuffer(n),0,n);}exports.mallocDataView=mallocDataView;function mallocBuffer(n){n=bits.nextPow2(n);var log_n=bits.log2(n);var cache=BUFFER[log_n];if(cache.length>0){return cache.pop();}return new Buffer(n);}exports.mallocBuffer=mallocBuffer;exports.clearCache=function clearCache(){for(var i=0;i<32;++i){POOL.UINT8[i].length=0;POOL.UINT16[i].length=0;POOL.UINT32[i].length=0;POOL.INT8[i].length=0;POOL.INT16[i].length=0;POOL.INT32[i].length=0;POOL.FLOAT[i].length=0;POOL.DOUBLE[i].length=0;POOL.BIGUINT64[i].length=0;POOL.BIGINT64[i].length=0;POOL.UINT8C[i].length=0;DATA[i].length=0;BUFFER[i].length=0;}};/***/},/***/1731:/***/function(module){"use strict";"use restrict";module.exports=UnionFind;function UnionFind(count){this.roots=new Array(count);this.ranks=new Array(count);for(var i=0;i<count;++i){this.roots[i]=i;this.ranks[i]=0;}}var proto=UnionFind.prototype;Object.defineProperty(proto,"length",{"get":function(){return this.roots.length;}});proto.makeSet=function(){var n=this.roots.length;this.roots.push(n);this.ranks.push(0);return n;};proto.find=function(x){var x0=x;var roots=this.roots;while(roots[x]!==x){x=roots[x];}while(roots[x0]!==x){var y=roots[x0];roots[x0]=x;x0=y;}return x;};proto.link=function(x,y){var xr=this.find(x),yr=this.find(y);if(xr===yr){return;}var ranks=this.ranks,roots=this.roots,xd=ranks[xr],yd=ranks[yr];if(xd<yd){roots[xr]=yr;}else if(yd<xd){roots[yr]=xr;}else{roots[yr]=xr;++ranks[xr];}};/***/},/***/1215:/***/function(module){"use strict";function unique_pred(list,compare){var ptr=1,len=list.length,a=list[0],b=list[0];for(var i=1;i<len;++i){b=a;a=list[i];if(compare(a,b)){if(i===ptr){ptr++;continue;}list[ptr++]=a;}}list.length=ptr;return list;}function unique_eq(list){var ptr=1,len=list.length,a=list[0],b=list[0];for(var i=1;i<len;++i,b=a){b=a;a=list[i];if(a!==b){if(i===ptr){ptr++;continue;}list[ptr++]=a;}}list.length=ptr;return list;}function unique(list,compare,sorted){if(list.length===0){return list;}if(compare){if(!sorted){list.sort(compare);}return unique_pred(list,compare);}if(!sorted){list.sort();}return unique_eq(list);}module.exports=unique;/***/},/***/875:/***/function(module,__unused_webpack_exports,__nested_webpack_require_854234__){"use strict";module.exports=createText;var vectorizeText=__nested_webpack_require_854234__(712);var defaultCanvas=null;var defaultContext=null;if(typeof document!=='undefined'){defaultCanvas=document.createElement('canvas');defaultCanvas.width=8192;defaultCanvas.height=1024;defaultContext=defaultCanvas.getContext("2d");}function createText(str,options){if(typeof options!=="object"||options===null){options={};}return vectorizeText(str,options.canvas||defaultCanvas,options.context||defaultContext,options);}/***/},/***/712:/***/function(module,__unused_webpack_exports,__nested_webpack_require_854813__){module.exports=vectorizeText;module.exports.processPixels=processPixels;var surfaceNets=__nested_webpack_require_854813__(4162);var ndarray=__nested_webpack_require_854813__(5050);var simplify=__nested_webpack_require_854813__(8243);var cleanPSLG=__nested_webpack_require_854813__(197);var cdt2d=__nested_webpack_require_854813__(7761);var toPolygonCrappy=__nested_webpack_require_854813__(8040);var TAG_bold="b";var CHR_bold='b|';var TAG_italic="i";var CHR_italic='i|';var TAG_super="sup";var CHR_super0='+';var CHR_super='+1';var TAG_sub="sub";var CHR_sub0='-';var CHR_sub='-1';function parseTag(tag,TAG_CHR,str,map){var opnTag="<"+tag+">";var clsTag="</"+tag+">";var nOPN=opnTag.length;var nCLS=clsTag.length;var isRecursive=TAG_CHR[0]===CHR_super0||TAG_CHR[0]===CHR_sub0;var a=0;var b=-nCLS;while(a>-1){a=str.indexOf(opnTag,a);if(a===-1)break;b=str.indexOf(clsTag,a+nOPN);if(b===-1)break;if(b<=a)break;for(var i=a;i<b+nCLS;++i){if(i<a+nOPN||i>=b){map[i]=null;str=str.substr(0,i)+" "+str.substr(i+1);}else{if(map[i]!==null){var pos=map[i].indexOf(TAG_CHR[0]);if(pos===-1){map[i]+=TAG_CHR;}else{// i.e. to handle multiple sub/super-scripts
if(isRecursive){// i.e to increase the sub/sup number
map[i]=map[i].substr(0,pos+1)+(1+parseInt(map[i][pos+1]))+map[i].substr(pos+2);}}}}}var start=a+nOPN;var remainingStr=str.substr(start,b-start);var c=remainingStr.indexOf(opnTag);if(c!==-1)a=c;else a=b+nCLS;}return map;}function transformPositions(positions,options,size){var align=options.textAlign||"start";var baseline=options.textBaseline||"alphabetic";var lo=[1<<30,1<<30];var hi=[0,0];var n=positions.length;for(var i=0;i<n;++i){var p=positions[i];for(var j=0;j<2;++j){lo[j]=Math.min(lo[j],p[j])|0;hi[j]=Math.max(hi[j],p[j])|0;}}var xShift=0;switch(align){case"center":xShift=-0.5*(lo[0]+hi[0]);break;case"right":case"end":xShift=-hi[0];break;case"left":case"start":xShift=-lo[0];break;default:throw new Error("vectorize-text: Unrecognized textAlign: '"+align+"'");}var yShift=0;switch(baseline){case"hanging":case"top":yShift=-lo[1];break;case"middle":yShift=-0.5*(lo[1]+hi[1]);break;case"alphabetic":case"ideographic":yShift=-3*size;break;case"bottom":yShift=-hi[1];break;default:throw new Error("vectorize-text: Unrecoginized textBaseline: '"+baseline+"'");}var scale=1.0/size;if("lineHeight"in options){scale*=+options.lineHeight;}else if("width"in options){scale=options.width/(hi[0]-lo[0]);}else if("height"in options){scale=options.height/(hi[1]-lo[1]);}return positions.map(function(p){return[scale*(p[0]+xShift),scale*(p[1]+yShift)];});}function getPixels(canvas,context,rawString,fontSize,lineSpacing,styletags){rawString=rawString.replace(/\n/g,'');// don't accept \n in the input
if(styletags.breaklines===true){rawString=rawString.replace(/\<br\>/g,'\n');// replace <br> tags with \n in the string
}else{rawString=rawString.replace(/\<br\>/g,' ');// don't accept <br> tags in the input and replace with space in this case
}var activeStyle="";var map=[];for(j=0;j<rawString.length;++j){map[j]=activeStyle;}if(styletags.bolds===true)map=parseTag(TAG_bold,CHR_bold,rawString,map);if(styletags.italics===true)map=parseTag(TAG_italic,CHR_italic,rawString,map);if(styletags.superscripts===true)map=parseTag(TAG_super,CHR_super,rawString,map);if(styletags.subscripts===true)map=parseTag(TAG_sub,CHR_sub,rawString,map);var allStyles=[];var plainText="";for(j=0;j<rawString.length;++j){if(map[j]!==null){plainText+=rawString[j];allStyles.push(map[j]);}}var allTexts=plainText.split('\n');var numberOfLines=allTexts.length;var lineHeight=Math.round(lineSpacing*fontSize);var offsetX=fontSize;var offsetY=fontSize*2;var maxWidth=0;var minHeight=numberOfLines*lineHeight+offsetY;if(canvas.height<minHeight){canvas.height=minHeight;}context.fillStyle="#000";context.fillRect(0,0,canvas.width,canvas.height);context.fillStyle="#fff";var i,j,xPos,yPos,zPos;var nDone=0;var buffer="";function writeBuffer(){if(buffer!==""){var delta=context.measureText(buffer).width;context.fillText(buffer,offsetX+xPos,offsetY+yPos);xPos+=delta;}}function getTextFontSize(){return""+Math.round(zPos)+"px ";}function changeStyle(oldStyle,newStyle){var ctxFont=""+context.font;if(styletags.subscripts===true){var oldIndex_Sub=oldStyle.indexOf(CHR_sub0);var newIndex_Sub=newStyle.indexOf(CHR_sub0);var oldSub=oldIndex_Sub>-1?parseInt(oldStyle[1+oldIndex_Sub]):0;var newSub=newIndex_Sub>-1?parseInt(newStyle[1+newIndex_Sub]):0;if(oldSub!==newSub){ctxFont=ctxFont.replace(getTextFontSize(),"?px ");zPos*=Math.pow(0.75,newSub-oldSub);ctxFont=ctxFont.replace("?px ",getTextFontSize());}yPos+=0.25*lineHeight*(newSub-oldSub);}if(styletags.superscripts===true){var oldIndex_Super=oldStyle.indexOf(CHR_super0);var newIndex_Super=newStyle.indexOf(CHR_super0);var oldSuper=oldIndex_Super>-1?parseInt(oldStyle[1+oldIndex_Super]):0;var newSuper=newIndex_Super>-1?parseInt(newStyle[1+newIndex_Super]):0;if(oldSuper!==newSuper){ctxFont=ctxFont.replace(getTextFontSize(),"?px ");zPos*=Math.pow(0.75,newSuper-oldSuper);ctxFont=ctxFont.replace("?px ",getTextFontSize());}yPos-=0.25*lineHeight*(newSuper-oldSuper);}if(styletags.bolds===true){var wasBold=oldStyle.indexOf(CHR_bold)>-1;var is_Bold=newStyle.indexOf(CHR_bold)>-1;if(!wasBold&&is_Bold){if(wasItalic){ctxFont=ctxFont.replace("italic ","italic bold ");}else{ctxFont="bold "+ctxFont;}}if(wasBold&&!is_Bold){ctxFont=ctxFont.replace("bold ",'');}}if(styletags.italics===true){var wasItalic=oldStyle.indexOf(CHR_italic)>-1;var is_Italic=newStyle.indexOf(CHR_italic)>-1;if(!wasItalic&&is_Italic){ctxFont="italic "+ctxFont;}if(wasItalic&&!is_Italic){ctxFont=ctxFont.replace("italic ",'');}}context.font=ctxFont;}for(i=0;i<numberOfLines;++i){var txt=allTexts[i]+'\n';xPos=0;yPos=i*lineHeight;zPos=fontSize;buffer="";for(j=0;j<txt.length;++j){var style=j+nDone<allStyles.length?allStyles[j+nDone]:allStyles[allStyles.length-1];if(activeStyle===style){buffer+=txt[j];}else{writeBuffer();buffer=txt[j];if(style!==undefined){changeStyle(activeStyle,style);activeStyle=style;}}}writeBuffer();nDone+=txt.length;var width=Math.round(xPos+2*offsetX)|0;if(maxWidth<width)maxWidth=width;}//Cut pixels from image
var xCut=maxWidth;var yCut=offsetY+lineHeight*numberOfLines;var pixels=ndarray(context.getImageData(0,0,xCut,yCut).data,[yCut,xCut,4]);return pixels.pick(-1,-1,0).transpose(1,0);}function getContour(pixels,doSimplify){var contour=surfaceNets(pixels,128);if(doSimplify){return simplify(contour.cells,contour.positions,0.25);}return{edges:contour.cells,positions:contour.positions};}function processPixelsImpl(pixels,options,size,simplify){//Extract contour
var contour=getContour(pixels,simplify);//Apply warp to positions
var positions=transformPositions(contour.positions,options,size);var edges=contour.edges;var flip="ccw"===options.orientation;//Clean up the PSLG, resolve self intersections, etc.
cleanPSLG(positions,edges);//If triangulate flag passed, triangulate the result
if(options.polygons||options.polygon||options.polyline){var result=toPolygonCrappy(edges,positions);var nresult=new Array(result.length);for(var i=0;i<result.length;++i){var loops=result[i];var nloops=new Array(loops.length);for(var j=0;j<loops.length;++j){var loop=loops[j];var nloop=new Array(loop.length);for(var k=0;k<loop.length;++k){nloop[k]=positions[loop[k]].slice();}if(flip){nloop.reverse();}nloops[j]=nloop;}nresult[i]=nloops;}return nresult;}else if(options.triangles||options.triangulate||options.triangle){return{cells:cdt2d(positions,edges,{delaunay:false,exterior:false,interior:true}),positions:positions};}else{return{edges:edges,positions:positions};}}function processPixels(pixels,options,size){try{return processPixelsImpl(pixels,options,size,true);}catch(e){}try{return processPixelsImpl(pixels,options,size,false);}catch(e){}if(options.polygons||options.polyline||options.polygon){return[];}if(options.triangles||options.triangulate||options.triangle){return{cells:[],positions:[]};}return{edges:[],positions:[]};}function vectorizeText(str,canvas,context,options){var size=64;var lineSpacing=1.25;var styletags={breaklines:false,bolds:false,italics:false,subscripts:false,superscripts:false};if(options){if(options.size&&options.size>0)size=options.size;if(options.lineSpacing&&options.lineSpacing>0)lineSpacing=options.lineSpacing;if(options.styletags&&options.styletags.breaklines)styletags.breaklines=options.styletags.breaklines?true:false;if(options.styletags&&options.styletags.bolds)styletags.bolds=options.styletags.bolds?true:false;if(options.styletags&&options.styletags.italics)styletags.italics=options.styletags.italics?true:false;if(options.styletags&&options.styletags.subscripts)styletags.subscripts=options.styletags.subscripts?true:false;if(options.styletags&&options.styletags.superscripts)styletags.superscripts=options.styletags.superscripts?true:false;}context.font=[options.fontStyle,options.fontVariant,options.fontWeight,size+"px",options.font].filter(function(d){return d;}).join(" ");context.textAlign="start";context.textBaseline="alphabetic";context.direction="ltr";var pixels=getPixels(canvas,context,str,size,lineSpacing,styletags);return processPixels(pixels,options,size);}/***/},/***/5346:/***/function(module){// Copyright (C) 2011 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Install a leaky WeakMap emulation on platforms that
 * don't provide a built-in one.
 *
 * <p>Assumes that an ES5 platform where, if {@code WeakMap} is
 * already present, then it conforms to the anticipated ES6
 * specification. To run this file on an ES5 or almost ES5
 * implementation where the {@code WeakMap} specification does not
 * quite conform, run <code>repairES5.js</code> first.
 *
 * <p>Even though WeakMapModule is not global, the linter thinks it
 * is, which is why it is in the overrides list below.
 *
 * <p>NOTE: Before using this WeakMap emulation in a non-SES
 * environment, see the note below about hiddenRecord.
 *
 * @author Mark S. Miller
 * @requires crypto, ArrayBuffer, Uint8Array, navigator, console
 * @overrides WeakMap, ses, Proxy
 * @overrides WeakMapModule
 */ /**
 * This {@code WeakMap} emulation is observably equivalent to the
 * ES-Harmony WeakMap, but with leakier garbage collection properties.
 *
 * <p>As with true WeakMaps, in this emulation, a key does not
 * retain maps indexed by that key and (crucially) a map does not
 * retain the keys it indexes. A map by itself also does not retain
 * the values associated with that map.
 *
 * <p>However, the values associated with a key in some map are
 * retained so long as that key is retained and those associations are
 * not overridden. For example, when used to support membranes, all
 * values exported from a given membrane will live for the lifetime
 * they would have had in the absence of an interposed membrane. Even
 * when the membrane is revoked, all objects that would have been
 * reachable in the absence of revocation will still be reachable, as
 * far as the GC can tell, even though they will no longer be relevant
 * to ongoing computation.
 *
 * <p>The API implemented here is approximately the API as implemented
 * in FF6.0a1 and agreed to by MarkM, Andreas Gal, and Dave Herman,
 * rather than the offially approved proposal page. TODO(erights):
 * upgrade the ecmascript WeakMap proposal page to explain this API
 * change and present to EcmaScript committee for their approval.
 *
 * <p>The first difference between the emulation here and that in
 * FF6.0a1 is the presence of non enumerable {@code get___, has___,
 * set___, and delete___} methods on WeakMap instances to represent
 * what would be the hidden internal properties of a primitive
 * implementation. Whereas the FF6.0a1 WeakMap.prototype methods
 * require their {@code this} to be a genuine WeakMap instance (i.e.,
 * an object of {@code [[Class]]} "WeakMap}), since there is nothing
 * unforgeable about the pseudo-internal method names used here,
 * nothing prevents these emulated prototype methods from being
 * applied to non-WeakMaps with pseudo-internal methods of the same
 * names.
 *
 * <p>Another difference is that our emulated {@code
 * WeakMap.prototype} is not itself a WeakMap. A problem with the
 * current FF6.0a1 API is that WeakMap.prototype is itself a WeakMap
 * providing ambient mutability and an ambient communications
 * channel. Thus, if a WeakMap is already present and has this
 * problem, repairES5.js wraps it in a safe wrappper in order to
 * prevent access to this channel. (See
 * PATCH_MUTABLE_FROZEN_WEAKMAP_PROTO in repairES5.js).
 */ /**
 * If this is a full <a href=
 * "http://code.google.com/p/es-lab/wiki/SecureableES5"
 * >secureable ES5</a> platform and the ES-Harmony {@code WeakMap} is
 * absent, install an approximate emulation.
 *
 * <p>If WeakMap is present but cannot store some objects, use our approximate
 * emulation as a wrapper.
 *
 * <p>If this is almost a secureable ES5 platform, then WeakMap.js
 * should be run after repairES5.js.
 *
 * <p>See {@code WeakMap} for documentation of the garbage collection
 * properties of this WeakMap emulation.
 */(function WeakMapModule(){"use strict";if(typeof ses!=='undefined'&&ses.ok&&!ses.ok()){// already too broken, so give up
return;}/**
   * In some cases (current Firefox), we must make a choice betweeen a
   * WeakMap which is capable of using all varieties of host objects as
   * keys and one which is capable of safely using proxies as keys. See
   * comments below about HostWeakMap and DoubleWeakMap for details.
   *
   * This function (which is a global, not exposed to guests) marks a
   * WeakMap as permitted to do what is necessary to index all host
   * objects, at the cost of making it unsafe for proxies.
   *
   * Do not apply this function to anything which is not a genuine
   * fresh WeakMap.
   */function weakMapPermitHostObjects(map){// identity of function used as a secret -- good enough and cheap
if(map.permitHostObjects___){map.permitHostObjects___(weakMapPermitHostObjects);}}if(typeof ses!=='undefined'){ses.weakMapPermitHostObjects=weakMapPermitHostObjects;}// IE 11 has no Proxy but has a broken WeakMap such that we need to patch
// it using DoubleWeakMap; this flag tells DoubleWeakMap so.
var doubleWeakMapCheckSilentFailure=false;// Check if there is already a good-enough WeakMap implementation, and if so
// exit without replacing it.
if(typeof WeakMap==='function'){var HostWeakMap=WeakMap;// There is a WeakMap -- is it good enough?
if(typeof navigator!=='undefined'&&/Firefox/.test(navigator.userAgent)){// We're now *assuming not*, because as of this writing (2013-05-06)
// Firefox's WeakMaps have a miscellany of objects they won't accept, and
// we don't want to make an exhaustive list, and testing for just one
// will be a problem if that one is fixed alone (as they did for Event).
// If there is a platform that we *can* reliably test on, here's how to
// do it:
//  var problematic = ... ;
//  var testHostMap = new HostWeakMap();
//  try {
//    testHostMap.set(problematic, 1);  // Firefox 20 will throw here
//    if (testHostMap.get(problematic) === 1) {
//      return;
//    }
//  } catch (e) {}
}else{// IE 11 bug: WeakMaps silently fail to store frozen objects.
var testMap=new HostWeakMap();var testObject=Object.freeze({});testMap.set(testObject,1);if(testMap.get(testObject)!==1){doubleWeakMapCheckSilentFailure=true;// Fall through to installing our WeakMap.
}else{module.exports=WeakMap;return;}}}var hop=Object.prototype.hasOwnProperty;var gopn=Object.getOwnPropertyNames;var defProp=Object.defineProperty;var isExtensible=Object.isExtensible;/**
   * Security depends on HIDDEN_NAME being both <i>unguessable</i> and
   * <i>undiscoverable</i> by untrusted code.
   *
   * <p>Given the known weaknesses of Math.random() on existing
   * browsers, it does not generate unguessability we can be confident
   * of.
   *
   * <p>It is the monkey patching logic in this file that is intended
   * to ensure undiscoverability. The basic idea is that there are
   * three fundamental means of discovering properties of an object:
   * The for/in loop, Object.keys(), and Object.getOwnPropertyNames(),
   * as well as some proposed ES6 extensions that appear on our
   * whitelist. The first two only discover enumerable properties, and
   * we only use HIDDEN_NAME to name a non-enumerable property, so the
   * only remaining threat should be getOwnPropertyNames and some
   * proposed ES6 extensions that appear on our whitelist. We monkey
   * patch them to remove HIDDEN_NAME from the list of properties they
   * returns.
   *
   * <p>TODO(erights): On a platform with built-in Proxies, proxies
   * could be used to trap and thereby discover the HIDDEN_NAME, so we
   * need to monkey patch Proxy.create, Proxy.createFunction, etc, in
   * order to wrap the provided handler with the real handler which
   * filters out all traps using HIDDEN_NAME.
   *
   * <p>TODO(erights): Revisit Mike Stay's suggestion that we use an
   * encapsulated function at a not-necessarily-secret name, which
   * uses the Stiegler shared-state rights amplification pattern to
   * reveal the associated value only to the WeakMap in which this key
   * is associated with that value. Since only the key retains the
   * function, the function can also remember the key without causing
   * leakage of the key, so this doesn't violate our general gc
   * goals. In addition, because the name need not be a guarded
   * secret, we could efficiently handle cross-frame frozen keys.
   */var HIDDEN_NAME_PREFIX='weakmap:';var HIDDEN_NAME=HIDDEN_NAME_PREFIX+'ident:'+Math.random()+'___';if(typeof crypto!=='undefined'&&typeof crypto.getRandomValues==='function'&&typeof ArrayBuffer==='function'&&typeof Uint8Array==='function'){var ab=new ArrayBuffer(25);var u8s=new Uint8Array(ab);crypto.getRandomValues(u8s);HIDDEN_NAME=HIDDEN_NAME_PREFIX+'rand:'+Array.prototype.map.call(u8s,function(u8){return(u8%36).toString(36);}).join('')+'___';}function isNotHiddenName(name){return!(name.substr(0,HIDDEN_NAME_PREFIX.length)==HIDDEN_NAME_PREFIX&&name.substr(name.length-3)==='___');}/**
   * Monkey patch getOwnPropertyNames to avoid revealing the
   * HIDDEN_NAME.
   *
   * <p>The ES5.1 spec requires each name to appear only once, but as
   * of this writing, this requirement is controversial for ES6, so we
   * made this code robust against this case. If the resulting extra
   * search turns out to be expensive, we can probably relax this once
   * ES6 is adequately supported on all major browsers, iff no browser
   * versions we support at that time have relaxed this constraint
   * without providing built-in ES6 WeakMaps.
   */defProp(Object,'getOwnPropertyNames',{value:function fakeGetOwnPropertyNames(obj){return gopn(obj).filter(isNotHiddenName);}});/**
   * getPropertyNames is not in ES5 but it is proposed for ES6 and
   * does appear in our whitelist, so we need to clean it too.
   */if('getPropertyNames'in Object){var originalGetPropertyNames=Object.getPropertyNames;defProp(Object,'getPropertyNames',{value:function fakeGetPropertyNames(obj){return originalGetPropertyNames(obj).filter(isNotHiddenName);}});}/**
   * <p>To treat objects as identity-keys with reasonable efficiency
   * on ES5 by itself (i.e., without any object-keyed collections), we
   * need to add a hidden property to such key objects when we
   * can. This raises several issues:
   * <ul>
   * <li>Arranging to add this property to objects before we lose the
   *     chance, and
   * <li>Hiding the existence of this new property from most
   *     JavaScript code.
   * <li>Preventing <i>certification theft</i>, where one object is
   *     created falsely claiming to be the key of an association
   *     actually keyed by another object.
   * <li>Preventing <i>value theft</i>, where untrusted code with
   *     access to a key object but not a weak map nevertheless
   *     obtains access to the value associated with that key in that
   *     weak map.
   * </ul>
   * We do so by
   * <ul>
   * <li>Making the name of the hidden property unguessable, so "[]"
   *     indexing, which we cannot intercept, cannot be used to access
   *     a property without knowing the name.
   * <li>Making the hidden property non-enumerable, so we need not
   *     worry about for-in loops or {@code Object.keys},
   * <li>monkey patching those reflective methods that would
   *     prevent extensions, to add this hidden property first,
   * <li>monkey patching those methods that would reveal this
   *     hidden property.
   * </ul>
   * Unfortunately, because of same-origin iframes, we cannot reliably
   * add this hidden property before an object becomes
   * non-extensible. Instead, if we encounter a non-extensible object
   * without a hidden record that we can detect (whether or not it has
   * a hidden record stored under a name secret to us), then we just
   * use the key object itself to represent its identity in a brute
   * force leaky map stored in the weak map, losing all the advantages
   * of weakness for these.
   */function getHiddenRecord(key){if(key!==Object(key)){throw new TypeError('Not an object: '+key);}var hiddenRecord=key[HIDDEN_NAME];if(hiddenRecord&&hiddenRecord.key===key){return hiddenRecord;}if(!isExtensible(key)){// Weak map must brute force, as explained in doc-comment above.
return void 0;}// The hiddenRecord and the key point directly at each other, via
// the "key" and HIDDEN_NAME properties respectively. The key
// field is for quickly verifying that this hidden record is an
// own property, not a hidden record from up the prototype chain.
//
// NOTE: Because this WeakMap emulation is meant only for systems like
// SES where Object.prototype is frozen without any numeric
// properties, it is ok to use an object literal for the hiddenRecord.
// This has two advantages:
// * It is much faster in a performance critical place
// * It avoids relying on Object.create(null), which had been
//   problematic on Chrome 28.0.1480.0. See
//   https://code.google.com/p/google-caja/issues/detail?id=1687
hiddenRecord={key:key};// When using this WeakMap emulation on platforms where
// Object.prototype might not be frozen and Object.create(null) is
// reliable, use the following two commented out lines instead.
// hiddenRecord = Object.create(null);
// hiddenRecord.key = key;
// Please contact us if you need this to work on platforms where
// Object.prototype might not be frozen and
// Object.create(null) might not be reliable.
try{defProp(key,HIDDEN_NAME,{value:hiddenRecord,writable:false,enumerable:false,configurable:false});return hiddenRecord;}catch(error){// Under some circumstances, isExtensible seems to misreport whether
// the HIDDEN_NAME can be defined.
// The circumstances have not been isolated, but at least affect
// Node.js v0.10.26 on TravisCI / Linux, but not the same version of
// Node.js on OS X.
return void 0;}}/**
   * Monkey patch operations that would make their argument
   * non-extensible.
   *
   * <p>The monkey patched versions throw a TypeError if their
   * argument is not an object, so it should only be done to functions
   * that should throw a TypeError anyway if their argument is not an
   * object.
   */(function(){var oldFreeze=Object.freeze;defProp(Object,'freeze',{value:function identifyingFreeze(obj){getHiddenRecord(obj);return oldFreeze(obj);}});var oldSeal=Object.seal;defProp(Object,'seal',{value:function identifyingSeal(obj){getHiddenRecord(obj);return oldSeal(obj);}});var oldPreventExtensions=Object.preventExtensions;defProp(Object,'preventExtensions',{value:function identifyingPreventExtensions(obj){getHiddenRecord(obj);return oldPreventExtensions(obj);}});})();function constFunc(func){func.prototype=null;return Object.freeze(func);}var calledAsFunctionWarningDone=false;function calledAsFunctionWarning(){// Future ES6 WeakMap is currently (2013-09-10) expected to reject WeakMap()
// but we used to permit it and do it ourselves, so warn only.
if(!calledAsFunctionWarningDone&&typeof console!=='undefined'){calledAsFunctionWarningDone=true;console.warn('WeakMap should be invoked as new WeakMap(), not '+'WeakMap(). This will be an error in the future.');}}var nextId=0;var OurWeakMap=function(){if(!(this instanceof OurWeakMap)){// approximate test for new ...()
calledAsFunctionWarning();}// We are currently (12/25/2012) never encountering any prematurely
// non-extensible keys.
var keys=[];// brute force for prematurely non-extensible keys.
var values=[];// brute force for corresponding values.
var id=nextId++;function get___(key,opt_default){var index;var hiddenRecord=getHiddenRecord(key);if(hiddenRecord){return id in hiddenRecord?hiddenRecord[id]:opt_default;}else{index=keys.indexOf(key);return index>=0?values[index]:opt_default;}}function has___(key){var hiddenRecord=getHiddenRecord(key);if(hiddenRecord){return id in hiddenRecord;}else{return keys.indexOf(key)>=0;}}function set___(key,value){var index;var hiddenRecord=getHiddenRecord(key);if(hiddenRecord){hiddenRecord[id]=value;}else{index=keys.indexOf(key);if(index>=0){values[index]=value;}else{// Since some browsers preemptively terminate slow turns but
// then continue computing with presumably corrupted heap
// state, we here defensively get keys.length first and then
// use it to update both the values and keys arrays, keeping
// them in sync.
index=keys.length;values[index]=value;// If we crash here, values will be one longer than keys.
keys[index]=key;}}return this;}function delete___(key){var hiddenRecord=getHiddenRecord(key);var index,lastIndex;if(hiddenRecord){return id in hiddenRecord&&delete hiddenRecord[id];}else{index=keys.indexOf(key);if(index<0){return false;}// Since some browsers preemptively terminate slow turns but
// then continue computing with potentially corrupted heap
// state, we here defensively get keys.length first and then use
// it to update both the keys and the values array, keeping
// them in sync. We update the two with an order of assignments,
// such that any prefix of these assignments will preserve the
// key/value correspondence, either before or after the delete.
// Note that this needs to work correctly when index === lastIndex.
lastIndex=keys.length-1;keys[index]=void 0;// If we crash here, there's a void 0 in the keys array, but
// no operation will cause a "keys.indexOf(void 0)", since
// getHiddenRecord(void 0) will always throw an error first.
values[index]=values[lastIndex];// If we crash here, values[index] cannot be found here,
// because keys[index] is void 0.
keys[index]=keys[lastIndex];// If index === lastIndex and we crash here, then keys[index]
// is still void 0, since the aliasing killed the previous key.
keys.length=lastIndex;// If we crash here, keys will be one shorter than values.
values.length=lastIndex;return true;}}return Object.create(OurWeakMap.prototype,{get___:{value:constFunc(get___)},has___:{value:constFunc(has___)},set___:{value:constFunc(set___)},delete___:{value:constFunc(delete___)}});};OurWeakMap.prototype=Object.create(Object.prototype,{get:{/**
       * Return the value most recently associated with key, or
       * opt_default if none.
       */value:function get(key,opt_default){return this.get___(key,opt_default);},writable:true,configurable:true},has:{/**
       * Is there a value associated with key in this WeakMap?
       */value:function has(key){return this.has___(key);},writable:true,configurable:true},set:{/**
       * Associate value with key in this WeakMap, overwriting any
       * previous association if present.
       */value:function set(key,value){return this.set___(key,value);},writable:true,configurable:true},'delete':{/**
       * Remove any association for key in this WeakMap, returning
       * whether there was one.
       *
       * <p>Note that the boolean return here does not work like the
       * {@code delete} operator. The {@code delete} operator returns
       * whether the deletion succeeds at bringing about a state in
       * which the deleted property is absent. The {@code delete}
       * operator therefore returns true if the property was already
       * absent, whereas this {@code delete} method returns false if
       * the association was already absent.
       */value:function remove(key){return this.delete___(key);},writable:true,configurable:true}});if(typeof HostWeakMap==='function'){(function(){// If we got here, then the platform has a WeakMap but we are concerned
// that it may refuse to store some key types. Therefore, make a map
// implementation which makes use of both as possible.
// In this mode we are always using double maps, so we are not proxy-safe.
// This combination does not occur in any known browser, but we had best
// be safe.
if(doubleWeakMapCheckSilentFailure&&typeof Proxy!=='undefined'){Proxy=undefined;}function DoubleWeakMap(){if(!(this instanceof OurWeakMap)){// approximate test for new ...()
calledAsFunctionWarning();}// Preferable, truly weak map.
var hmap=new HostWeakMap();// Our hidden-property-based pseudo-weak-map. Lazily initialized in the
// 'set' implementation; thus we can avoid performing extra lookups if
// we know all entries actually stored are entered in 'hmap'.
var omap=undefined;// Hidden-property maps are not compatible with proxies because proxies
// can observe the hidden name and either accidentally expose it or fail
// to allow the hidden property to be set. Therefore, we do not allow
// arbitrary WeakMaps to switch to using hidden properties, but only
// those which need the ability, and unprivileged code is not allowed
// to set the flag.
//
// (Except in doubleWeakMapCheckSilentFailure mode in which case we
// disable proxies.)
var enableSwitching=false;function dget(key,opt_default){if(omap){return hmap.has(key)?hmap.get(key):omap.get___(key,opt_default);}else{return hmap.get(key,opt_default);}}function dhas(key){return hmap.has(key)||(omap?omap.has___(key):false);}var dset;if(doubleWeakMapCheckSilentFailure){dset=function(key,value){hmap.set(key,value);if(!hmap.has(key)){if(!omap){omap=new OurWeakMap();}omap.set(key,value);}return this;};}else{dset=function(key,value){if(enableSwitching){try{hmap.set(key,value);}catch(e){if(!omap){omap=new OurWeakMap();}omap.set___(key,value);}}else{hmap.set(key,value);}return this;};}function ddelete(key){var result=!!hmap['delete'](key);if(omap){return omap.delete___(key)||result;}return result;}return Object.create(OurWeakMap.prototype,{get___:{value:constFunc(dget)},has___:{value:constFunc(dhas)},set___:{value:constFunc(dset)},delete___:{value:constFunc(ddelete)},permitHostObjects___:{value:constFunc(function(token){if(token===weakMapPermitHostObjects){enableSwitching=true;}else{throw new Error('bogus call to permitHostObjects___');}})}});}DoubleWeakMap.prototype=OurWeakMap.prototype;module.exports=DoubleWeakMap;// define .constructor to hide OurWeakMap ctor
Object.defineProperty(WeakMap.prototype,'constructor',{value:WeakMap,enumerable:false,// as default .constructor is
configurable:true,writable:true});})();}else{// There is no host WeakMap, so we must use the emulation.
// Emulated WeakMaps are incompatible with native proxies (because proxies
// can observe the hidden name), so we must disable Proxy usage (in
// ArrayLike and Domado, currently).
if(typeof Proxy!=='undefined'){Proxy=undefined;}module.exports=OurWeakMap;}})();/***/},/***/9222:/***/function(module,__unused_webpack_exports,__nested_webpack_require_886677__){var hiddenStore=__nested_webpack_require_886677__(7178);module.exports=createStore;function createStore(){var key={};return function(obj){if((typeof obj!=='object'||obj===null)&&typeof obj!=='function'){throw new Error('Weakmap-shim: Key must be object');}var store=obj.valueOf(key);return store&&store.identity===key?store:hiddenStore(obj,key);};}/***/},/***/7178:/***/function(module){module.exports=hiddenStore;function hiddenStore(obj,key){var store={identity:key};var valueOf=obj.valueOf;Object.defineProperty(obj,"valueOf",{value:function(value){return value!==key?valueOf.apply(this,arguments):store;},writable:true});return store;}/***/},/***/4037:/***/function(module,__unused_webpack_exports,__nested_webpack_require_887386__){// Original - @Gozola.
// https://gist.github.com/Gozala/1269991
// This is a reimplemented version (with a few bug fixes).
var createStore=__nested_webpack_require_887386__(9222);module.exports=weakMap;function weakMap(){var privates=createStore();return{'get':function(key,fallback){var store=privates(key);return store.hasOwnProperty('value')?store.value:fallback;},'set':function(key,value){privates(key).value=value;return this;},'has':function(key){return'value'in privates(key);},'delete':function(key){return delete privates(key).value;}};}/***/},/***/6183:/***/function(module){"use strict";function CWiseOp(){return function(SS,a0,t0,p0,Y0,Y1){var s0=SS[0],t0p0=t0[0],index=[0],q0=t0p0;p0|=0;var i0=0,d0s0=t0p0;for(i0=0;i0<s0;++i0){{var da=a0[p0]-Y1;var db=a0[p0+q0]-Y1;if(da>=0!==db>=0){Y0.push(index[0]+0.5+0.5*(da+db)/(da-db));}}p0+=d0s0;++index[0];}};}//Generates a cwise operator
function generateCWiseOp(){return CWiseOp();}var compile=generateCWiseOp;function thunk(compile){var CACHED={};return function zeroCrossings_cwise_thunk(array0,scalar2,scalar3){var t0=array0.dtype,r0=array0.order,type=[t0,r0.join()].join(),proc=CACHED[type];if(!proc){CACHED[type]=proc=compile([t0,r0]);}return proc(array0.shape.slice(0),array0.data,array0.stride,array0.offset|0,scalar2,scalar3);};}function createThunk(proc){return thunk(compile.bind(undefined,proc));}function compileCwise(user_args){return createThunk({funcName:user_args.funcName});}module.exports=compileCwise({funcName:'zeroCrossings'});/***/},/***/9584:/***/function(module,__unused_webpack_exports,__nested_webpack_require_888962__){"use strict";module.exports=findZeroCrossings;var core=__nested_webpack_require_888962__(6183);function findZeroCrossings(array,level){var cross=[];level=+level||0.0;core(array.hi(array.shape[0]-1),cross,level);return cross;}/***/},/***/6601:/***/function(){/* (ignored) */ /***/}/******/};/************************************************************************/ /******/ // The module cache
/******/var __webpack_module_cache__={};/******/ /******/ // The require function
/******/function __nested_webpack_require_889453__(moduleId){/******/ // Check if module is in cache
/******/var cachedModule=__webpack_module_cache__[moduleId];/******/if(cachedModule!==undefined){/******/return cachedModule.exports;/******/}/******/ // Create a new module (and put it into the cache)
/******/var module=__webpack_module_cache__[moduleId]={/******/id:moduleId,/******/loaded:false,/******/exports:{}/******/};/******/ /******/ // Execute the module function
/******/__webpack_modules__[moduleId].call(module.exports,module,module.exports,__nested_webpack_require_889453__);/******/ /******/ // Flag the module as loaded
/******/module.loaded=true;/******/ /******/ // Return the exports of the module
/******/return module.exports;/******/}/******/ /************************************************************************/ /******/ /* webpack/runtime/global */ /******/!function(){/******/__nested_webpack_require_889453__.g=function(){/******/if(typeof globalThis==='object')return globalThis;/******/try{/******/return this||new Function('return this')();/******/}catch(e){/******/if(typeof window==='object')return window;/******/}/******/}();/******/}();/******/ /******/ /* webpack/runtime/node module decorator */ /******/!function(){/******/__nested_webpack_require_889453__.nmd=function(module){/******/module.paths=[];/******/if(!module.children)module.children=[];/******/return module;/******/};/******/}();/******/ /************************************************************************/ /******/ /******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module is referenced by other modules so it can't be inlined
/******/var __nested_webpack_exports__=__nested_webpack_require_889453__(7386);/******/ /******/return __nested_webpack_exports__;/******/}());});

/***/ }),

/***/ 5791:
/***/ (function(module) {

"use strict";


module.exports = isMobile;
module.exports.isMobile = isMobile;
module.exports["default"] = isMobile;
var mobileRE = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;
var notMobileRE = /CrOS/;
var tabletRE = /android|ipad|playbook|silk/i;
function isMobile(opts) {
  if (!opts) opts = {};
  var ua = opts.ua;
  if (!ua && typeof navigator !== 'undefined') ua = navigator.userAgent;
  if (ua && ua.headers && typeof ua.headers['user-agent'] === 'string') {
    ua = ua.headers['user-agent'];
  }
  if (typeof ua !== 'string') return false;
  var result = mobileRE.test(ua) && !notMobileRE.test(ua) || !!opts.tablet && tabletRE.test(ua);
  if (!result && opts.tablet && opts.featureDetect && navigator && navigator.maxTouchPoints > 1 && ua.indexOf('Macintosh') !== -1 && ua.indexOf('Safari') !== -1) {
    result = true;
  }
  return result;
}

/***/ }),

/***/ 9898:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {
  var d3 = {
    version: "3.8.0"
  };
  var d3_arraySlice = [].slice, d3_array = function(list) {
    return d3_arraySlice.call(list);
  };
  var d3_document = self.document;
  function d3_documentElement(node) {
    return node && (node.ownerDocument || node.document || node).documentElement;
  }
  function d3_window(node) {
    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
  }
  if (d3_document) {
    try {
      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
    } catch (e) {
      d3_array = function(list) {
        var i = list.length, array = new Array(i);
        while (i--) array[i] = list[i];
        return array;
      };
    }
  }
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  if (d3_document) {
    try {
      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
    } catch (error) {
      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
      d3_element_prototype.setAttribute = function(name, value) {
        d3_element_setAttribute.call(this, name, value + "");
      };
      d3_element_prototype.setAttributeNS = function(space, local, value) {
        d3_element_setAttributeNS.call(this, space, local, value + "");
      };
      d3_style_prototype.setProperty = function(name, value, priority) {
        d3_style_setProperty.call(this, name, value + "", priority);
      };
    }
  }
  d3.ascending = d3_ascending;
  function d3_ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  function d3_number(x) {
    return x === null ? NaN : +x;
  }
  function d3_numeric(x) {
    return !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
    } else {
      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.mean = function(array, f) {
    var s = 0, n = array.length, a, i = -1, j = n;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
    }
    if (j) return s / j;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.median = function(array, f) {
    var numbers = [], n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
    }
    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
  };
  d3.variance = function(array, f) {
    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) {
        if (d3_numeric(a = d3_number(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    } else {
      while (++i < n) {
        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }
    if (j > 1) return s / (j - 1);
  };
  d3.deviation = function() {
    var v = d3.variance.apply(this, arguments);
    return v ? Math.sqrt(v) : v;
  };
  function d3_bisector(compare) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  }
  var d3_bisect = d3_bisector(d3_ascending);
  d3.bisectLeft = d3_bisect.left;
  d3.bisect = d3.bisectRight = d3_bisect.right;
  d3.bisector = function(f) {
    return d3_bisector(f.length === 1 ? function(d, x) {
      return d3_ascending(f(d), x);
    } : f);
  };
  d3.shuffle = function(array, i0, i1) {
    if ((m = arguments.length) < 3) {
      i1 = array.length;
      if (m < 2) i0 = 0;
    }
    var m = i1 - i0, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
    }
    return array;
  };
  d3.permute = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.pairs = function(array) {
    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
    return pairs;
  };
  d3.transpose = function(matrix) {
    if (!(n = matrix.length)) return [];
    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
        row[j] = matrix[j][i];
      }
    }
    return transpose;
  };
  function d3_transposeLength(d) {
    return d.length;
  }
  d3.zip = function() {
    return d3.transpose(arguments);
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.merge = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while (++i < n) j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }
    return merged;
  };
  var abs = Math.abs;
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_class(ctor, properties) {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  }
  d3.map = function(object, f) {
    var map = new d3_Map();
    if (object instanceof d3_Map) {
      object.forEach(function(key, value) {
        map.set(key, value);
      });
    } else if (Array.isArray(object)) {
      var i = -1, n = object.length, o;
      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
    } else {
      for (var key in object) map.set(key, object[key]);
    }
    return map;
  };
  function d3_Map() {
    this._ = Object.create(null);
  }
  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
  d3_class(d3_Map, {
    has: d3_map_has,
    get: function(key) {
      return this._[d3_map_escape(key)];
    },
    set: function(key, value) {
      return this._[d3_map_escape(key)] = value;
    },
    remove: d3_map_remove,
    keys: d3_map_keys,
    values: function() {
      var values = [];
      for (var key in this._) values.push(this._[key]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var key in this._) entries.push({
        key: d3_map_unescape(key),
        value: this._[key]
      });
      return entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
    }
  });
  function d3_map_escape(key) {
    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
  }
  function d3_map_unescape(key) {
    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
  }
  function d3_map_has(key) {
    return d3_map_escape(key) in this._;
  }
  function d3_map_remove(key) {
    return (key = d3_map_escape(key)) in this._ && delete this._[key];
  }
  function d3_map_keys() {
    var keys = [];
    for (var key in this._) keys.push(d3_map_unescape(key));
    return keys;
  }
  function d3_map_size() {
    var size = 0;
    for (var key in this._) ++size;
    return size;
  }
  function d3_map_empty() {
    for (var key in this._) return false;
    return true;
  }
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
    return set;
  };
  function d3_Set() {
    this._ = Object.create(null);
  }
  d3_class(d3_Set, {
    has: d3_map_has,
    add: function(key) {
      this._[d3_map_escape(key += "")] = true;
      return key;
    },
    remove: d3_map_remove,
    values: d3_map_keys,
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key));
    }
  });
  d3.behavior = {};
  function d3_identity(d) {
    return d;
  }
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  function d3_vendorSymbol(object, name) {
    if (name in object) return name;
    name = name.charAt(0).toUpperCase() + name.slice(1);
    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
      var prefixName = d3_vendorPrefixes[i] + name;
      if (prefixName in object) return prefixName;
    }
  }
  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
  function d3_noop() {}
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i >= 0) {
      name = type.slice(i + 1);
      type = type.slice(0, i);
    }
    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
    if (arguments.length === 2) {
      if (listener == null) for (type in this) {
        if (this.hasOwnProperty(type)) this[type].on(name, null);
      }
      return this;
    }
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.event = null;
  function d3_eventPreventDefault() {
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  var d3_subclass = {}.__proto__ ? function(object, prototype) {
    object.__proto__ = prototype;
  } : function(object, prototype) {
    for (var property in prototype) object[property] = prototype[property];
  };
  function d3_selection(groups) {
    d3_subclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectMatches = function(n, s) {
    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
    d3_selectMatches = function(n, s) {
      return d3_selectMatcher.call(n, s);
    };
    return d3_selectMatches(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = Sizzle;
    d3_selectMatches = Sizzle.matchesSelector;
  }
  d3.selection = function() {
    return d3.select(d3_document.documentElement);
  };
  var d3_selectionPrototype = d3.selection.prototype = [];
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_selectAll(selector, this);
    };
  }
  var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: d3_nsXhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.getAttribute("class");
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classes(name) {
    return (name + "").trim().split(/^|\s+/);
  }
  function d3_selection_classed(name, value) {
    name = d3_selection_classes(name).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.getAttribute("class") || "";
      if (value) {
        re.lastIndex = 0;
        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
      } else {
        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) {
        var node = this.node();
        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
      }
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3_selection_creator(name);
    return this.select(function() {
      return this.appendChild(name.apply(this, arguments));
    });
  };
  function d3_selection_creator(name) {
    function create() {
      var document = this.ownerDocument, namespace = this.namespaceURI;
      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
    }
    function createNS() {
      return this.ownerDocument.createElementNS(name.space, name.local);
    }
    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
  }
  d3_selectionPrototype.insert = function(name, before) {
    name = d3_selection_creator(name);
    before = d3_selection_selector(before);
    return this.select(function() {
      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
    });
  };
  d3_selectionPrototype.remove = function() {
    return this.each(d3_selectionRemove);
  };
  function d3_selectionRemove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
        for (i = -1; ++i < n; ) {
          if (node = group[i]) {
            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
              exitNodes[i] = node;
            } else {
              nodeByKeyValue.set(keyValue, node);
            }
            keyValues[i] = keyValue;
          }
        }
        for (i = -1; ++i < m; ) {
          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          } else if (node !== true) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          }
          nodeByKeyValue.set(keyValue, true);
        }
        for (i = -1; ++i < n; ) {
          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3_ascending;
    return function(a, b) {
      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.size = function() {
    var n = 0;
    d3_selection_each(this, function() {
      ++n;
    });
    return n;
  };
  function d3_selection_enter(selection) {
    d3_subclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selection_enterPrototype.insert = function(name, before) {
    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
    return d3_selectionPrototype.insert.call(this, name, before);
  };
  function d3_selection_enterInsertBefore(enter) {
    var i0, j0;
    return function(d, i, j) {
      var group = enter[j].update, n = group.length, node;
      if (j != j0) j0 = j, i0 = 0;
      if (i >= i0) i0 = i + 1;
      while (!(node = group[i0]) && ++i0 < n) ;
      return node;
    };
  }
  d3.select = function(node) {
    var group;
    if (typeof node === "string") {
      group = [ d3_select(node, d3_document) ];
      group.parentNode = d3_document.documentElement;
    } else {
      group = [ node ];
      group.parentNode = d3_documentElement(node);
    }
    return d3_selection([ group ]);
  };
  d3.selectAll = function(nodes) {
    var group;
    if (typeof nodes === "string") {
      group = d3_array(d3_selectAll(nodes, d3_document));
      group.parentNode = d3_document.documentElement;
    } else {
      group = d3_array(nodes);
      group.parentNode = null;
    }
    return d3_selection([ group ]);
  };
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.slice(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    function removeAll() {
      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
      for (var name in this) {
        if (match = name.match(re)) {
          var l = this[name];
          this.removeEventListener(match[1], l, l.$);
          delete this[name];
        }
      }
    }
    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  if (d3_document) {
    d3_selection_onFilters.forEach(function(k) {
      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
    });
  }
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  var d3_event_dragSelect, d3_event_dragId = 0;
  function d3_event_dragSuppress(node) {
    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
    if (d3_event_dragSelect == null) {
      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
    }
    if (d3_event_dragSelect) {
      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
      style[d3_event_dragSelect] = "none";
    }
    return function(suppressClick) {
      w.on(name, null);
      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
      if (suppressClick) {
        var off = function() {
          w.on(click, null);
        };
        w.on(click, function() {
          d3_eventPreventDefault();
          off();
        }, true);
        setTimeout(off, 0);
      }
    };
  }
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    if (e.changedTouches) e = e.changedTouches[0];
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0) {
        var window = d3_window(container);
        if (window.scrollX || window.scrollY) {
          svg = d3.select("body").append("svg").style({
            position: "absolute",
            top: 0,
            left: 0,
            margin: 0,
            padding: 0,
            border: "none"
          }, "important");
          var ctm = svg[0][0].getScreenCTM();
          d3_mouse_bug44083 = !(ctm.f || ctm.e);
          svg.remove();
        }
      }
      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
      point.y = e.clientY;
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touch = function(container, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return d3_mousePoint(container, touch);
      }
    }
  };
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
    }
    function dragstart(id, position, subject, move, end) {
      return function() {
        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
        if (origin) {
          dragOffset = origin.apply(that, arguments);
          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
        } else {
          dragOffset = [ 0, 0 ];
        }
        dispatch({
          type: "dragstart"
        });
        function moved() {
          var position1 = position(parent, dragId), dx, dy;
          if (!position1) return;
          dx = position1[0] - position0[0];
          dy = position1[1] - position0[1];
          dragged |= dx | dy;
          position0 = position1;
          dispatch({
            type: "drag",
            x: position1[0] + dragOffset[0],
            y: position1[1] + dragOffset[1],
            dx: dx,
            dy: dy
          });
        }
        function ended() {
          if (!position(parent, dragId)) return;
          dragSubject.on(move + dragName, null).on(end + dragName, null);
          dragRestore(dragged);
          dispatch({
            type: "dragend"
          });
        }
      };
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  function d3_behavior_dragTouchId() {
    return d3.event.changedTouches[0].identifier;
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
  function d3_sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function d3_cross2d(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  }
  function d3_acos(x) {
    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
  }
  function d3_asin(x) {
    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
  }
  function d3_sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }
  function d3_cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }
  function d3_tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }
  function d3_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
  d3.interpolateZoom = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < ε2) {
      S = Math.log(w1 / w0) / ρ;
      i = function(t) {
        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / ρ;
      i = function(t) {
        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
      };
    }
    i.duration = S * 1e3;
    return i;
  };
  d3.behavior.zoom = function() {
    var view = {
      x: 0,
      y: 0,
      k: 1
    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
    if (!d3_behavior_zoomWheel) {
      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return d3.event.wheelDelta;
      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
        return -d3.event.detail;
      }, "MozMousePixelScroll");
    }
    function zoom(g) {
      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
    }
    zoom.event = function(g) {
      g.each(function() {
        var dispatch = event.of(this, arguments), view1 = view;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.zoom", function() {
            view = this.__chart__ || {
              x: 0,
              y: 0,
              k: 1
            };
            zoomstarted(dispatch);
          }).tween("zoom:zoom", function() {
            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
            return function(t) {
              var l = i(t), k = dx / l[2];
              this.__chart__ = view = {
                x: cx - l[0] * k,
                y: cy - l[1] * k,
                k: k
              };
              zoomed(dispatch);
            };
          }).each("interrupt.zoom", function() {
            zoomended(dispatch);
          }).each("end.zoom", function() {
            zoomended(dispatch);
          });
        } else {
          this.__chart__ = view;
          zoomstarted(dispatch);
          zoomed(dispatch);
          zoomended(dispatch);
        }
      });
    };
    zoom.translate = function(_) {
      if (!arguments.length) return [ view.x, view.y ];
      view = {
        x: +_[0],
        y: +_[1],
        k: view.k
      };
      rescale();
      return zoom;
    };
    zoom.scale = function(_) {
      if (!arguments.length) return view.k;
      view = {
        x: view.x,
        y: view.y,
        k: null
      };
      scaleTo(+_);
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(_) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.center = function(_) {
      if (!arguments.length) return center;
      center = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.size = function(_) {
      if (!arguments.length) return size;
      size = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.duration = function(_) {
      if (!arguments.length) return duration;
      duration = +_;
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    function location(p) {
      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
    }
    function point(l) {
      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
    }
    function scaleTo(s) {
      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      view.x += p[0] - l[0];
      view.y += p[1] - l[1];
    }
    function zoomTo(that, p, l, k) {
      that.__chart__ = {
        x: view.x,
        y: view.y,
        k: view.k
      };
      scaleTo(Math.pow(2, k));
      translateTo(center0 = p, l);
      that = d3.select(that);
      if (duration > 0) that = that.transition().duration(duration);
      that.call(zoom.event);
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - view.x) / view.k;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - view.y) / view.k;
      }).map(y0.invert));
    }
    function zoomstarted(dispatch) {
      if (!zooming++) dispatch({
        type: "zoomstart"
      });
    }
    function zoomed(dispatch) {
      rescale();
      dispatch({
        type: "zoom",
        scale: view.k,
        translate: [ view.x, view.y ]
      });
    }
    function zoomended(dispatch) {
      if (!--zooming) dispatch({
        type: "zoomend"
      }), center0 = null;
    }
    function mousedowned() {
      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
      d3_selection_interrupt.call(that);
      zoomstarted(dispatch);
      function moved() {
        dragged = 1;
        translateTo(d3.mouse(that), location0);
        zoomed(dispatch);
      }
      function ended() {
        subject.on(mousemove, null).on(mouseup, null);
        dragRestore(dragged);
        zoomended(dispatch);
      }
    }
    function touchstarted() {
      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
      started();
      zoomstarted(dispatch);
      subject.on(mousedown, null).on(touchstart, started);
      function relocate() {
        var touches = d3.touches(that);
        scale0 = view.k;
        touches.forEach(function(t) {
          if (t.identifier in locations0) locations0[t.identifier] = location(t);
        });
        return touches;
      }
      function started() {
        var target = d3.event.target;
        d3.select(target).on(touchmove, moved).on(touchend, ended);
        targets.push(target);
        var changed = d3.event.changedTouches;
        for (var i = 0, n = changed.length; i < n; ++i) {
          locations0[changed[i].identifier] = null;
        }
        var touches = relocate(), now = Date.now();
        if (touches.length === 1) {
          if (now - touchtime < 500) {
            var p = touches[0];
            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
            d3_eventPreventDefault();
          }
          touchtime = now;
        } else if (touches.length > 1) {
          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
          distance0 = dx * dx + dy * dy;
        }
      }
      function moved() {
        var touches = d3.touches(that), p0, l0, p1, l1;
        d3_selection_interrupt.call(that);
        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
          p1 = touches[i];
          if (l1 = locations0[p1.identifier]) {
            if (l0) break;
            p0 = p1, l0 = l1;
          }
        }
        if (l1) {
          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
          scaleTo(scale1 * scale0);
        }
        touchtime = null;
        translateTo(p0, l0);
        zoomed(dispatch);
      }
      function ended() {
        if (d3.event.touches.length) {
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            delete locations0[changed[i].identifier];
          }
          for (var identifier in locations0) {
            return void relocate();
          }
        }
        d3.selectAll(targets).on(zoomName, null);
        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
        dragRestore();
        zoomended(dispatch);
      }
    }
    function mousewheeled() {
      var dispatch = event.of(this, arguments);
      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
      mousewheelTimer = setTimeout(function() {
        mousewheelTimer = null;
        zoomended(dispatch);
      }, 50);
      d3_eventPreventDefault();
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
      translateTo(center0, translate0);
      zoomed(dispatch);
    }
    function dblclicked() {
      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
  d3.color = d3_color;
  function d3_color() {}
  d3_color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.hsl = d3_hsl;
  function d3_hsl(h, s, l) {
    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
  }
  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = d3_hcl;
  function d3_hcl(h, c, l) {
    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
  }
  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
  d3_hclPrototype.brighter = function(k) {
    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    if (isNaN(h)) h = 0;
    if (isNaN(c)) c = 0;
    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = d3_lab;
  function d3_lab(l, a, b) {
    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_lab.prototype = new d3_color();
  d3_labPrototype.brighter = function(k) {
    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  d3.rgb = d3_rgb;
  function d3_rgb(r, g, b) {
    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
  }
  function d3_rgbNumber(value) {
    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
  }
  function d3_rgbString(value) {
    return d3_rgbNumber(value) + "";
  }
  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return new d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_rgb(k * this.r, k * this.g, k * this.b);
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, color;
    m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (color = d3_rgb_names.get(format)) {
      return rgb(color.r, color.g, color.b);
    }
    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
      if (format.length === 4) {
        r = (color & 3840) >> 4;
        r = r >> 4 | r;
        g = color & 240;
        g = g >> 4 | g;
        b = color & 15;
        b = b << 4 | b;
      } else if (format.length === 7) {
        r = (color & 16711680) >> 16;
        g = (color & 65280) >> 8;
        b = color & 255;
      }
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      h = NaN;
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgbNumber(value));
  });
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  d3.xhr = d3_xhrType(d3_identity);
  function d3_xhrType(response) {
    return function(url, mimeType, callback) {
      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
      mimeType = null;
      return d3_xhr(url, mimeType, response, callback);
    };
  }
  function d3_xhr(url, mimeType, response, callback) {
    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
    if (self.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var status = request.status, result;
      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
        try {
          result = response.call(xhr, request);
        } catch (e) {
          dispatch.error.call(xhr, e);
          return;
        }
        dispatch.load.call(xhr, result);
      } else {
        dispatch.error.call(xhr, request);
      }
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.responseType = function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (responseType != null) request.responseType = responseType;
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      dispatch.beforesend.call(xhr, request);
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  }
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  function d3_xhrHasResponse(request) {
    var type = request.responseType;
    return type && type !== "text" ? request.response : request.responseText;
  }
  d3.dsv = function(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr;
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = function(d) {
          var obj = {};
          var len = row.length;
          for (var k = 0; k < len; ++k) {
            obj[row[k]] = d[k];
          }
          return obj;
        };
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }
        return text.slice(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  };
  d3.csv = d3.dsv(",", "text/csv");
  d3.tsv = d3.dsv("	", "text/tab-separated-values");
  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
    setTimeout(callback, 17);
  };
  d3.timer = function() {
    d3_timer.apply(this, arguments);
  };
  function d3_timer(callback, delay, then) {
    var n = arguments.length;
    if (n < 2) delay = 0;
    if (n < 3) then = Date.now();
    var time = then + delay, timer = {
      c: callback,
      t: time,
      n: null
    };
    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
    d3_timer_queueTail = timer;
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
    return timer;
  }
  function d3_timer_step() {
    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    d3_timer_mark();
    d3_timer_sweep();
  };
  function d3_timer_mark() {
    var now = Date.now(), timer = d3_timer_queueHead;
    while (timer) {
      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
      timer = timer.n;
    }
    return now;
  }
  function d3_timer_sweep() {
    var t0, t1 = d3_timer_queueHead, time = Infinity;
    while (t1) {
      if (t1.c) {
        if (t1.t < time) time = t1.t;
        t1 = (t0 = t1).n;
      } else {
        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
      }
    }
    d3_timer_queueTail = t0;
    return time;
  }
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  d3.geom = {};
  function d3_geom_pointX(d) {
    return d[0];
  }
  function d3_geom_pointY(d) {
    return d[1];
  }
  d3.geom.hull = function(vertices) {
    var x = d3_geom_pointX, y = d3_geom_pointY;
    if (arguments.length) return hull(vertices);
    function hull(data) {
      if (data.length < 3) return [];
      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
      for (i = 0; i < n; i++) {
        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
      }
      points.sort(d3_geom_hullOrder);
      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
      return polygon;
    }
    hull.x = function(_) {
      return arguments.length ? (x = _, hull) : x;
    };
    hull.y = function(_) {
      return arguments.length ? (y = _, hull) : y;
    };
    return hull;
  };
  function d3_geom_hullUpper(points) {
    var n = points.length, hull = [ 0, 1 ], hs = 2;
    for (var i = 2; i < n; i++) {
      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
      hull[hs++] = i;
    }
    return hull.slice(0, hs);
  }
  function d3_geom_hullOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }
  d3.geom.polygon = function(coordinates) {
    d3_subclass(coordinates, d3_geom_polygonPrototype);
    return coordinates;
  };
  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
  d3_geom_polygonPrototype.area = function() {
    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
    while (++i < n) {
      a = b;
      b = this[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area * .5;
  };
  d3_geom_polygonPrototype.centroid = function(k) {
    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
    if (!arguments.length) k = -1 / (6 * this.area());
    while (++i < n) {
      a = b;
      b = this[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [ x * k, y * k ];
  };
  d3_geom_polygonPrototype.clip = function(subject) {
    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = this[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      if (closed) subject.push(subject[0]);
      a = b;
    }
    return subject;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_geom_polygonClosed(coordinates) {
    var a = coordinates[0], b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
  function d3_geom_voronoiBeach() {
    d3_geom_voronoiRedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function d3_geom_voronoiCreateBeach(site) {
    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
    beach.site = site;
    return beach;
  }
  function d3_geom_voronoiDetachBeach(beach) {
    d3_geom_voronoiDetachCircle(beach);
    d3_geom_voronoiBeaches.remove(beach);
    d3_geom_voronoiBeachPool.push(beach);
    d3_geom_voronoiRedBlackNode(beach);
  }
  function d3_geom_voronoiRemoveBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
      x: x,
      y: y
    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
    d3_geom_voronoiDetachBeach(beach);
    var lArc = previous;
    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    d3_geom_voronoiDetachCircle(lArc);
    var rArc = next;
    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
      next = rArc.N;
      disappearing.push(rArc);
      d3_geom_voronoiDetachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    d3_geom_voronoiDetachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiAddBeach(site) {
    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
    while (node) {
      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
      if (dxl > ε) node = node.L; else {
        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
        if (dxr > ε) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -ε) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -ε) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    var newArc = d3_geom_voronoiCreateBeach(site);
    d3_geom_voronoiBeaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
      d3_geom_voronoiDetachCircle(lArc);
      rArc = d3_geom_voronoiCreateBeach(lArc.site);
      d3_geom_voronoiBeaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      return;
    }
    d3_geom_voronoiDetachCircle(lArc);
    d3_geom_voronoiDetachCircle(rArc);
    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
      x: (cy * hb - by * hc) / d + ax,
      y: (bx * hc - cx * hb) / d + ay
    };
    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  function d3_geom_voronoiCell(site) {
    this.site = site;
    this.edges = [];
  }
  d3_geom_voronoiCell.prototype.prepare = function() {
    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
    while (iHalfEdge--) {
      edge = halfEdges[iHalfEdge].edge;
      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
    }
    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
    return halfEdges.length;
  };
  function d3_geom_voronoiCloseCells(extent) {
    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell || !cell.prepare()) continue;
      halfEdges = cell.edges;
      nHalfEdges = halfEdges.length;
      iHalfEdge = 0;
      while (iHalfEdge < nHalfEdges) {
        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
            x: x0,
            y: abs(x2 - x0) < ε ? y2 : y1
          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
            x: abs(y2 - y1) < ε ? x2 : x1,
            y: y1
          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
            x: x1,
            y: abs(x2 - x1) < ε ? y2 : y0
          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
            x: abs(y2 - y0) < ε ? x2 : x0,
            y: y0
          } : null), cell.site, null));
          ++nHalfEdges;
        }
      }
    }
  }
  function d3_geom_voronoiHalfEdgeOrder(a, b) {
    return b.angle - a.angle;
  }
  function d3_geom_voronoiCircle() {
    d3_geom_voronoiRedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function d3_geom_voronoiAttachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -ε2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = cy + Math.sqrt(x * x + y * y);
    circle.cy = cy;
    arc.circle = circle;
    var before = null, node = d3_geom_voronoiCircles._;
    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L; else {
          before = node.P;
          break;
        }
      } else {
        if (node.R) node = node.R; else {
          before = node;
          break;
        }
      }
    }
    d3_geom_voronoiCircles.insert(before, circle);
    if (!before) d3_geom_voronoiFirstCircle = circle;
  }
  function d3_geom_voronoiDetachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
      d3_geom_voronoiCircles.remove(circle);
      d3_geom_voronoiCirclePool.push(circle);
      d3_geom_voronoiRedBlackNode(circle);
      arc.circle = null;
    }
  }
  function d3_geom_clipLine(x0, y0, x1, y1) {
    return function(line) {
      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      if (t0 > 0) line.a = {
        x: ax + t0 * dx,
        y: ay + t0 * dy
      };
      if (t1 < 1) line.b = {
        x: ax + t1 * dx,
        y: ay + t1 * dy
      };
      return line;
    };
  }
  function d3_geom_voronoiClipEdges(extent) {
    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
    while (i--) {
      e = edges[i];
      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
        e.a = e.b = null;
        edges.splice(i, 1);
      }
    }
  }
  function d3_geom_voronoiConnectEdge(edge, extent) {
    var vb = edge.b;
    if (vb) return true;
    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!va) va = {
          x: fx,
          y: y0
        }; else if (va.y >= y1) return;
        vb = {
          x: fx,
          y: y1
        };
      } else {
        if (!va) va = {
          x: fx,
          y: y1
        }; else if (va.y < y0) return;
        vb = {
          x: fx,
          y: y0
        };
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!va) va = {
            x: (y0 - fb) / fm,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: (y1 - fb) / fm,
            y: y1
          };
        } else {
          if (!va) va = {
            x: (y1 - fb) / fm,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: (y0 - fb) / fm,
            y: y0
          };
        }
      } else {
        if (ly < ry) {
          if (!va) va = {
            x: x0,
            y: fm * x0 + fb
          }; else if (va.x >= x1) return;
          vb = {
            x: x1,
            y: fm * x1 + fb
          };
        } else {
          if (!va) va = {
            x: x1,
            y: fm * x1 + fb
          }; else if (va.x < x0) return;
          vb = {
            x: x0,
            y: fm * x0 + fb
          };
        }
      }
    }
    edge.a = va;
    edge.b = vb;
    return true;
  }
  function d3_geom_voronoiEdge(lSite, rSite) {
    this.l = lSite;
    this.r = rSite;
    this.a = this.b = null;
  }
  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, rSite);
    d3_geom_voronoiEdges.push(edge);
    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
    return edge;
  }
  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, null);
    edge.a = va;
    edge.b = vb;
    d3_geom_voronoiEdges.push(edge);
    return edge;
  }
  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
    if (!edge.a && !edge.b) {
      edge.a = vertex;
      edge.l = lSite;
      edge.r = rSite;
    } else if (edge.l === rSite) {
      edge.b = vertex;
    } else {
      edge.a = vertex;
    }
  }
  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
    var va = edge.a, vb = edge.b;
    this.edge = edge;
    this.site = lSite;
    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
  }
  d3_geom_voronoiHalfEdge.prototype = {
    start: function() {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function() {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  };
  function d3_geom_voronoiRedBlackTree() {
    this._ = null;
  }
  function d3_geom_voronoiRedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  d3_geom_voronoiRedBlackTree.prototype = {
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = d3_geom_voronoiRedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
      if (parent) {
        if (parent.L === node) parent.L = next; else parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node) node.C = false;
    }
  };
  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }
  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }
  function d3_geom_voronoiRedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }
  function d3_geom_voronoi(sites, bbox) {
    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
    d3_geom_voronoiEdges = [];
    d3_geom_voronoiCells = new Array(sites.length);
    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
    while (true) {
      circle = d3_geom_voronoiFirstCircle;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== x0 || site.y !== y0) {
          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
          d3_geom_voronoiAddBeach(site);
          x0 = site.x, y0 = site.y;
        }
        site = sites.pop();
      } else if (circle) {
        d3_geom_voronoiRemoveBeach(circle.arc);
      } else {
        break;
      }
    }
    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
    var diagram = {
      cells: d3_geom_voronoiCells,
      edges: d3_geom_voronoiEdges
    };
    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
    return diagram;
  }
  function d3_geom_voronoiVertexOrder(a, b) {
    return b.y - a.y || b.x - a.x;
  }
  d3.geom.voronoi = function(points) {
    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
    if (points) return voronoi(points);
    function voronoi(data) {
      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
          var s = e.start();
          return [ s.x, s.y ];
        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
        polygon.point = data[i];
      });
      return polygons;
    }
    function sites(data) {
      return data.map(function(d, i) {
        return {
          x: Math.round(fx(d, i) / ε) * ε,
          y: Math.round(fy(d, i) / ε) * ε,
          i: i
        };
      });
    }
    voronoi.links = function(data) {
      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
        return edge.l && edge.r;
      }).map(function(edge) {
        return {
          source: data[edge.l.i],
          target: data[edge.r.i]
        };
      });
    };
    voronoi.triangles = function(data) {
      var triangles = [];
      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
        while (++j < m) {
          e0 = e1;
          s0 = s1;
          e1 = edges[j].edge;
          s1 = e1.l === site ? e1.r : e1.l;
          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
          }
        }
      });
      return triangles;
    };
    voronoi.x = function(_) {
      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
    };
    voronoi.clipExtent = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
      return voronoi;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
    };
    return voronoi;
  };
  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
  function d3_geom_voronoiTriangleArea(a, b, c) {
    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
  }
  d3.geom.delaunay = function(vertices) {
    return d3.geom.voronoi().triangles(vertices);
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
    if (compat = arguments.length) {
      x = d3_geom_quadtreeCompatX;
      y = d3_geom_quadtreeCompatY;
      if (compat === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      }
      return quadtree(points);
    }
    function quadtree(data) {
      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
      if (x1 != null) {
        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
      } else {
        x2_ = y2_ = -(x1_ = y1_ = Infinity);
        xs = [], ys = [];
        n = data.length;
        if (compat) for (i = 0; i < n; ++i) {
          d = data[i];
          if (d.x < x1_) x1_ = d.x;
          if (d.y < y1_) y1_ = d.y;
          if (d.x > x2_) x2_ = d.x;
          if (d.y > y2_) y2_ = d.y;
          xs.push(d.x);
          ys.push(d.y);
        } else for (i = 0; i < n; ++i) {
          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
          if (x_ < x1_) x1_ = x_;
          if (y_ < y1_) y1_ = y_;
          if (x_ > x2_) x2_ = x_;
          if (y_ > y2_) y2_ = y_;
          xs.push(x_);
          ys.push(y_);
        }
      }
      var dx = x2_ - x1_, dy = y2_ - y1_;
      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
      function insert(n, d, x, y, x1, y1, x2, y2) {
        if (isNaN(x) || isNaN(y)) return;
        if (n.leaf) {
          var nx = n.x, ny = n.y;
          if (nx != null) {
            if (abs(nx - x) + abs(ny - y) < .01) {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            } else {
              var nPoint = n.point;
              n.x = n.y = n.point = null;
              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          } else {
            n.x = x, n.y = y, n.point = d;
          }
        } else {
          insertChild(n, d, x, y, x1, y1, x2, y2);
        }
      }
      function insertChild(n, d, x, y, x1, y1, x2, y2) {
        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
        n.leaf = false;
        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
        if (right) x1 = xm; else x2 = xm;
        if (below) y1 = ym; else y2 = ym;
        insert(n, d, x, y, x1, y1, x2, y2);
      }
      var root = d3_geom_quadtreeNode();
      root.add = function(d) {
        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
      };
      root.visit = function(f) {
        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
      };
      root.find = function(point) {
        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
      };
      i = -1;
      if (x1 == null) {
        while (++i < n) {
          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
        }
        --i;
      } else data.forEach(root.add);
      xs = ys = data = d = null;
      return root;
    }
    quadtree.x = function(_) {
      return arguments.length ? (x = _, quadtree) : x;
    };
    quadtree.y = function(_) {
      return arguments.length ? (y = _, quadtree) : y;
    };
    quadtree.extent = function(_) {
      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
      y2 = +_[1][1];
      return quadtree;
    };
    quadtree.size = function(_) {
      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
      return quadtree;
    };
    return quadtree;
  };
  function d3_geom_quadtreeCompatX(d) {
    return d.x;
  }
  function d3_geom_quadtreeCompatY(d) {
    return d.y;
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
    var minDistance2 = Infinity, closestPoint;
    (function find(node, x1, y1, x2, y2) {
      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
      if (point = node.point) {
        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
        if (distance2 < minDistance2) {
          var distance = Math.sqrt(minDistance2 = distance2);
          x0 = x - distance, y0 = y - distance;
          x3 = x + distance, y3 = y + distance;
          closestPoint = point;
        }
      }
      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
        if (node = children[i & 3]) switch (i & 3) {
         case 0:
          find(node, x1, y1, xm, ym);
          break;

         case 1:
          find(node, xm, y1, x2, ym);
          break;

         case 2:
          find(node, x1, ym, xm, y2);
          break;

         case 3:
          find(node, xm, ym, x2, y2);
          break;
        }
      }
    })(root, x0, y0, x3, y3);
    return closestPoint;
  }
  d3.interpolateRgb = d3_interpolateRgb;
  function d3_interpolateRgb(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  }
  d3.interpolateObject = d3_interpolateObject;
  function d3_interpolateObject(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolate(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }
  d3.interpolateNumber = d3_interpolateNumber;
  function d3_interpolateNumber(a, b) {
    a = +a, b = +b;
    return function(t) {
      return a * (1 - t) + b * t;
    };
  }
  d3.interpolateString = d3_interpolateString;
  function d3_interpolateString(a, b) {
    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm; else s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({
          i: i,
          x: d3_interpolateNumber(am, bm)
        });
      }
      bi = d3_interpolate_numberB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; else s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
      return b(t) + "";
    }) : function() {
      return b;
    } : (b = q.length, function(t) {
      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    });
  }
  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
  d3.interpolate = d3_interpolate;
  function d3_interpolate(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  }
  d3.interpolators = [ function(a, b) {
    var t = typeof b;
    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
  } ];
  d3.interpolateArray = d3_interpolateArray;
  function d3_interpolateArray(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * halfπ);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.interpolateHcl = d3_interpolateHcl;
  function d3_interpolateHcl(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  }
  d3.interpolateHsl = d3_interpolateHsl;
  function d3_interpolateHsl(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
    };
  }
  d3.interpolateLab = d3_interpolateLab;
  function d3_interpolateLab(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  }
  d3.interpolateRound = d3_interpolateRound;
  function d3_interpolateRound(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      if (string != null) {
        g.setAttribute("transform", string);
        var t = g.transform.baseVal.consolidate();
      }
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolateTransform = d3_interpolateTransform;
  function d3_interpolateTransformPop(s) {
    return s.length ? s.pop() + "," : "";
  }
  function d3_interpolateTranslate(ta, tb, s, q) {
    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
      var i = s.push("translate(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ta[0], tb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    }
  }
  function d3_interpolateRotate(ra, rb, s, q) {
    if (ra !== rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
        x: d3_interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
    }
  }
  function d3_interpolateSkew(wa, wb, s, q) {
    if (wa !== wb) {
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
        x: d3_interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
    }
  }
  function d3_interpolateScale(ka, kb, s, q) {
    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
      var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ka[0], kb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] !== 1 || kb[1] !== 1) {
      s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
    }
  }
  function d3_interpolateTransform(a, b) {
    var s = [], q = [];
    a = d3.transform(a), b = d3.transform(b);
    d3_interpolateTranslate(a.translate, b.translate, s, q);
    d3_interpolateRotate(a.rotate, b.rotate, s, q);
    d3_interpolateSkew(a.skew, b.skew, s, q);
    d3_interpolateScale(a.scale, b.scale, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  function d3_uninterpolateNumber(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return (x - a) / b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) / b));
    };
  }
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (τ - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: groupSums[di]
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
          if (dw * dw / theta2 < dn) {
            if (dn < chargeDistance2) {
              var k = quad.charge / dn;
              node.px -= dx * k;
              node.py -= dy * k;
            }
            return true;
          }
          if (quad.point && dn && dn < chargeDistance2) {
            var k = quad.pointCharge / dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        timer = null;
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.chargeDistance = function(x) {
      if (!arguments.length) return Math.sqrt(chargeDistance2);
      chargeDistance2 = x * x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return Math.sqrt(theta2);
      theta2 = x * x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) {
          alpha = x;
        } else {
          timer.c = null, timer.t = NaN, timer = null;
          event.end({
            type: "end",
            alpha: alpha = 0
          });
        }
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        timer = d3_timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        if (!neighbors) {
          neighbors = new Array(n);
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        var candidates = neighbors[i], j = -1, l = candidates.length, x;
        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
        return Math.random() * size;
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function hierarchy(root) {
      var stack = [ root ], nodes = [], node;
      root.depth = 0;
      while ((node = stack.pop()) != null) {
        nodes.push(node);
        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
          var n, childs, child;
          while (--n >= 0) {
            stack.push(child = childs[n]);
            child.parent = node;
            child.depth = node.depth + 1;
          }
          if (value) node.value = 0;
          node.children = childs;
        } else {
          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
          delete node.children;
        }
      }
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var childs, parent;
        if (sort && (childs = node.children)) childs.sort(sort);
        if (value && (parent = node.parent)) parent.value += node.value;
      });
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      if (value) {
        d3_layout_hierarchyVisitBefore(root, function(node) {
          if (node.children) node.value = 0;
        });
        d3_layout_hierarchyVisitAfter(root, function(node) {
          var parent;
          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
          if (parent = node.parent) parent.value += node.value;
        });
      }
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyVisitBefore(node, callback) {
    var nodes = [ node ];
    while ((node = nodes.pop()) != null) {
      callback(node);
      if ((children = node.children) && (n = children.length)) {
        var n, children;
        while (--n >= 0) nodes.push(children[n]);
      }
    }
  }
  function d3_layout_hierarchyVisitAfter(node, callback) {
    var nodes = [ node ], nodes2 = [];
    while ((node = nodes.pop()) != null) {
      nodes2.push(node);
      if ((children = node.children) && (n = children.length)) {
        var i = -1, n, children;
        while (++i < n) nodes.push(children[i]);
      }
    }
    while ((node = nodes2.pop()) != null) {
      callback(node);
    }
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
    function pie(data) {
      var n = data.length, values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      index.forEach(function(i) {
        arcs[i] = {
          data: data[i],
          value: v = values[i],
          startAngle: a,
          endAngle: a += v * k + pa,
          padAngle: p
        };
      });
      return arcs;
    }
    pie.value = function(_) {
      if (!arguments.length) return value;
      value = _;
      return pie;
    };
    pie.sort = function(_) {
      if (!arguments.length) return sort;
      sort = _;
      return pie;
    };
    pie.startAngle = function(_) {
      if (!arguments.length) return startAngle;
      startAngle = _;
      return pie;
    };
    pie.endAngle = function(_) {
      if (!arguments.length) return endAngle;
      endAngle = _;
      return pie;
    };
    pie.padAngle = function(_) {
      if (!arguments.length) return padAngle;
      padAngle = _;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      if (!(n = data.length)) return data;
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var m = series[0].length, n, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
        return radius;
      };
      root.x = root.y = 0;
      d3_layout_hierarchyVisitAfter(root, function(d) {
        d.r = +r(d.value);
      });
      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
      if (padding) {
        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r -= dr;
        });
      }
      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
      return nodes;
    }
    pack.size = function(_) {
      if (!arguments.length) return size;
      size = _;
      return pack;
    };
    pack.radius = function(_) {
      if (!arguments.length) return radius;
      radius = _ == null || typeof _ === "function" ? _ : +_;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return .999 * dr * dr > dx * dx + dy * dy;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
      d3_layout_hierarchyVisitBefore(root1, secondWalk);
      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
        var left = root0, right = root0, bottom = root0;
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
      return nodes;
    }
    function wrapTree(root0) {
      var root1 = {
        A: null,
        children: [ root0 ]
      }, queue = [ root1 ], node1;
      while ((node1 = queue.pop()) != null) {
        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
          queue.push((children[i] = child = {
            _: children[i],
            parent: node1,
            children: (child = children[i].children) && child.slice() || [],
            A: null,
            a: null,
            z: 0,
            m: 0,
            c: 0,
            s: 0,
            t: null,
            i: i
          }).a = child);
        }
      }
      return root1.children[0];
    }
    function firstWalk(v) {
      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
      if (children.length) {
        d3_layout_treeShift(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= size[0];
      node.y = node.depth * size[1];
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null ? sizeNode : null;
      return tree;
    };
    tree.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) == null ? null : sizeNode;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(v) {
    var children = v.children;
    return children.length ? children[0] : v.t;
  }
  function d3_layout_treeRight(v) {
    var children = v.children, n;
    return (n = children.length) ? children[n - 1] : v.t;
  }
  function d3_layout_treeMove(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function d3_layout_treeShift(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function d3_layout_treeAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
        node.x = (node.x - root.x) * size[0];
        node.y = (root.y - node.y) * size[1];
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return cluster;
    };
    cluster.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = root.y = 0;
      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.random = {
    normal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    bates: function(m) {
      var random = d3.random.irwinHall(m);
      return function() {
        return random() / m;
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s;
      };
    }
  };
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
    return domain;
  }
  function d3_scale_niceStep(step) {
    return step ? {
      floor: function(x) {
        return Math.floor(x / step) * step;
      },
      ceil: function(x) {
        return Math.ceil(x / step) * step;
      }
    } : d3_scale_niceIdentity;
  }
  var d3_scale_niceIdentity = {
    floor: d3_identity,
    ceil: d3_identity
  };
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3_interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3_interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      d3_scale_linearNice(domain, m);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(domain, m) {
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    return domain;
  }
  function d3_scale_linearTickRange(domain, m) {
    if (m == null) m = 10;
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  var d3_scale_linearFormatSignificant = {
    s: 1,
    g: 1,
    p: 1,
    r: 1,
    e: 1
  };
  function d3_scale_linearPrecision(value) {
    return -Math.floor(Math.log(value) / Math.LN10 + .01);
  }
  function d3_scale_linearFormatPrecision(type, range) {
    var p = d3_scale_linearPrecision(range[2]);
    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
  };
  function d3_scale_log(linear, base, positive, domain) {
    function log(x) {
      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
    }
    function pow(x) {
      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
    }
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      positive = x[0] >= 0;
      linear.domain((domain = x.map(Number)).map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      linear.domain(domain.map(log));
      return scale;
    };
    scale.nice = function() {
      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
      linear.domain(niced);
      domain = niced.map(pow);
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
      if (isFinite(j - i)) {
        if (positive) {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        } else {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, positive, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logNiceNegative = {
    floor: function(x) {
      return -Math.ceil(-x);
    },
    ceil: function(x) {
      return -Math.floor(-x);
    }
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
  };
  function d3_scale_pow(linear, exponent, domain) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      linear.domain((domain = x.map(Number)).map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_linearNice(domain, m));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      linear.domain(domain.map(powp));
      return scale;
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
      0) : (stop - start) / (domain.length - 1 + padding);
      range = steps(start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundPoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
      0) : (stop - start) / (domain.length - 1 + padding) | 0;
      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
      rangeBand = 0;
      ranger = {
        t: "rangeRoundPoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      y = y < 0 ? NaN : y / kx + x0;
      return [ y, y + 1 / kx ];
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      if (x <= x) return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return [ domain[y - 1], domain[y] ];
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  function d3_zero() {
    return 0;
  }
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
    function arc() {
      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
        if (!cw) p1 *= -1;
        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
      }
      if (r1) {
        x0 = r1 * Math.cos(a0 + p1);
        y0 = r1 * Math.sin(a0 + p1);
        x1 = r1 * Math.cos(a1 - p1);
        y1 = r1 * Math.sin(a1 - p1);
        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
          var h1 = (a0 + a1) / 2;
          x0 = r1 * Math.cos(h1);
          y0 = r1 * Math.sin(h1);
          x1 = y1 = null;
        }
      } else {
        x0 = y0 = 0;
      }
      if (r0) {
        x2 = r0 * Math.cos(a1 - p0);
        y2 = r0 * Math.sin(a1 - p0);
        x3 = r0 * Math.cos(a0 + p0);
        y3 = r0 * Math.sin(a0 + p0);
        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
          var h0 = (a0 + a1) / 2;
          x2 = r0 * Math.cos(h0);
          y2 = r0 * Math.sin(h0);
          x3 = y3 = null;
        }
      } else {
        x2 = y2 = 0;
      }
      if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
        cr = r0 < r1 ^ cw ? 0 : 1;
        var rc1 = rc, rc0 = rc;
        if (da < π) {
          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
        }
        if (x1 != null) {
          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
          if (rc === rc1) {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
          } else {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
          }
        } else {
          path.push("M", x0, ",", y0);
        }
        if (x3 != null) {
          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
          if (rc === rc0) {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          } else {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          }
        } else {
          path.push("L", x2, ",", y2);
        }
      } else {
        path.push("M", x0, ",", y0);
        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
        path.push("L", x2, ",", y2);
        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
      }
      path.push("Z");
      return path.join("");
    }
    function circleSegment(r1, cw) {
      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.cornerRadius = function(v) {
      if (!arguments.length) return cornerRadius;
      cornerRadius = d3_functor(v);
      return arc;
    };
    arc.padRadius = function(v) {
      if (!arguments.length) return padRadius;
      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.padAngle = function(v) {
      if (!arguments.length) return padAngle;
      padAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcAuto = "auto";
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_arcPadAngle(d) {
    return d && d.padAngle;
  }
  function d3_svg_arcSweep(x0, y0, x1, y1) {
    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
  }
  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
  }
  function d3_true() {
    return true;
  }
  function d3_svg_line(projection) {
    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    step: d3_svg_lineStep,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.length > 1 ? points.join("L") : points + "Z";
  }
  function d3_svg_lineLinearClosed(points) {
    return points.join("L") + "Z";
  }
  function d3_svg_lineStep(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
    if (n > 1) path.push("H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    points.push(points[n - 1]);
    while (++i <= n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    points.pop();
    path.push("L", pi);
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (abs(d) < ε) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] - halfπ;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  function d3_source(d) {
    return d.source;
  }
  function d3_target(d) {
    return d.target;
  }
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / π);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3_selectionPrototype.transition = function(name) {
    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
      time: Date.now(),
      ease: d3_ease_cubicInOut,
      delay: 0,
      duration: 250
    };
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_selectionPrototype.interrupt = function(name) {
    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
  };
  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
  function d3_selection_interruptNS(ns) {
    return function() {
      var lock, activeId, active;
      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
        active.timer.c = null;
        active.timer.t = NaN;
        if (--lock.count) delete lock[activeId]; else delete this[ns];
        lock.active += .5;
        active.event && active.event.interrupt.call(this, this.__data__, active.index);
      }
    };
  }
  function d3_transition(groups, ns, id) {
    d3_subclass(groups, d3_transitionPrototype);
    groups.namespace = ns;
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3_transitionPrototype.size = d3_selectionPrototype.size;
  d3.transition = function(selection, name) {
    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node[ns][id];
          subnodes = selector.call(node, node.__data__, i, j);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.namespace, this.id);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node[ns][id].tween.remove(name);
    } : function(node) {
      node[ns][id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id, ns = groups.namespace;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node[ns][id].tween.set(name, value);
    }));
  }
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrTween(b) {
      return b == null ? attrNull : (b += "", function() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      });
    }
    function attrTweenNS(b) {
      return b == null ? attrNullNS : (b += "", function() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      });
    }
    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleString(b) {
      return b == null ? styleNull : (b += "", function() {
        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = d3_interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      });
    }
    return d3_transition_tween(this, "style." + name, value, styleString);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    function styleTween(d, i) {
      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    }
    return this.tween("style." + name, styleTween);
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    var ns = this.namespace;
    return this.each("end.transition", function() {
      var p;
      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node[ns][id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].delay;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].delay = +value.call(node, node.__data__, i, j);
    } : (value = +value, function(node) {
      node[ns][id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].duration;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
    } : (value = Math.max(1, value), function(node) {
      node[ns][id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      try {
        d3_transitionInheritId = id;
        d3_selection_each(this, function(node, i, j) {
          d3_transitionInherit = node[ns][id];
          type.call(node, node.__data__, i, j);
        });
      } finally {
        d3_transitionInherit = inherit;
        d3_transitionInheritId = inheritId;
      }
    } else {
      d3_selection_each(this, function(node) {
        var transition = node[ns][id];
        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = node[ns][id0];
          d3_transitionNode(node, i, ns, id1, {
            time: transition.time,
            ease: transition.ease,
            delay: transition.delay + transition.duration,
            duration: transition.duration
          });
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id1);
  };
  function d3_transitionNamespace(name) {
    return name == null ? "__transition__" : "__transition_" + name + "__";
  }
  function d3_transitionNode(node, i, ns, id, inherit) {
    var lock = node[ns] || (node[ns] = {
      active: 0,
      count: 0
    }), transition = lock[id], time, timer, duration, ease, tweens;
    function schedule(elapsed) {
      var delay = transition.delay;
      timer.t = delay + time;
      if (delay <= elapsed) return start(elapsed - delay);
      timer.c = start;
    }
    function start(elapsed) {
      var activeId = lock.active, active = lock[activeId];
      if (active) {
        active.timer.c = null;
        active.timer.t = NaN;
        --lock.count;
        delete lock[activeId];
        active.event && active.event.interrupt.call(node, node.__data__, active.index);
      }
      for (var cancelId in lock) {
        if (+cancelId < id) {
          var cancel = lock[cancelId];
          cancel.timer.c = null;
          cancel.timer.t = NaN;
          --lock.count;
          delete lock[cancelId];
        }
      }
      timer.c = tick;
      d3_timer(function() {
        if (timer.c && tick(elapsed || 1)) {
          timer.c = null;
          timer.t = NaN;
        }
        return 1;
      }, 0, time);
      lock.active = id;
      transition.event && transition.event.start.call(node, node.__data__, i);
      tweens = [];
      transition.tween.forEach(function(key, value) {
        if (value = value.call(node, node.__data__, i)) {
          tweens.push(value);
        }
      });
      ease = transition.ease;
      duration = transition.duration;
    }
    function tick(elapsed) {
      var t = elapsed / duration, e = ease(t), n = tweens.length;
      while (n > 0) {
        tweens[--n].call(node, e);
      }
      if (t >= 1) {
        transition.event && transition.event.end.call(node, node.__data__, i);
        if (--lock.count) delete lock[id]; else delete node[ns];
        return 1;
      }
    }
    if (!transition) {
      time = inherit.time;
      timer = d3_timer(schedule, 0, time);
      transition = lock[id] = {
        tween: new d3_Map(),
        time: time,
        timer: timer,
        delay: inherit.delay,
        duration: inherit.duration,
        ease: inherit.ease,
        index: i
      };
      inherit = null;
      ++lock.count;
    }
  }
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
        if (orient === "bottom" || orient === "top") {
          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
        } else {
          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
        }
        lineEnter.attr(y2, sign * innerTickSize);
        textEnter.attr(y1, sign * tickSpacing);
        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
        if (scale1.rangeBand) {
          var x = scale1, dx = x.rangeBand() / 2;
          scale0 = scale1 = function(d) {
            return x(d) + dx;
          };
        } else if (scale0.rangeBand) {
          scale0 = scale1;
        } else {
          tickExit.call(tickTransform, scale1, scale0);
        }
        tickEnter.call(tickTransform, scale0, scale1);
        tickUpdate.call(tickTransform, scale1, scale1);
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = d3_array(arguments);
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x) {
      var n = arguments.length;
      if (!n) return innerTickSize;
      innerTickSize = +x;
      outerTickSize = +arguments[n - 1];
      return axis;
    };
    axis.innerTickSize = function(x) {
      if (!arguments.length) return innerTickSize;
      innerTickSize = +x;
      return axis;
    };
    axis.outerTickSize = function(x) {
      if (!arguments.length) return outerTickSize;
      outerTickSize = +x;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function() {
      return arguments.length && axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x0, x1) {
    selection.attr("transform", function(d) {
      var v0 = x0(d);
      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y0, y1) {
    selection.attr("transform", function(d) {
      var v0 = y0(d);
      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
    });
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
    function brush(g) {
      g.each(function() {
        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        var background = g.selectAll(".background").data([ 0 ]);
        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var resize = g.selectAll(".resize").data(resizes, d3_identity);
        resize.exit().remove();
        resize.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        resize.style("display", brush.empty() ? "none" : null);
        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
        if (x) {
          range = d3_scaleRange(x);
          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
          redrawX(gUpdate);
        }
        if (y) {
          range = d3_scaleRange(y);
          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
          redrawY(gUpdate);
        }
        redraw(gUpdate);
      });
    }
    brush.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), extent1 = {
          x: xExtent,
          y: yExtent,
          i: xExtentDomain,
          j: yExtentDomain
        }, extent0 = this.__chart__ || extent1;
        this.__chart__ = extent1;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.brush", function() {
            xExtentDomain = extent0.i;
            yExtentDomain = extent0.j;
            xExtent = extent0.x;
            yExtent = extent0.y;
            event_({
              type: "brushstart"
            });
          }).tween("brush:brush", function() {
            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
            xExtentDomain = yExtentDomain = null;
            return function(t) {
              xExtent = extent1.x = xi(t);
              yExtent = extent1.y = yi(t);
              event_({
                type: "brush",
                mode: "resize"
              });
            };
          }).each("end.brush", function() {
            xExtentDomain = extent1.i;
            yExtentDomain = extent1.j;
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          });
        } else {
          event_({
            type: "brushstart"
          });
          event_({
            type: "brush",
            mode: "resize"
          });
          event_({
            type: "brushend"
          });
        }
      });
    };
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", xExtent[0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", yExtent[0]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (d3.event.changedTouches) {
        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
      } else {
        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
      }
      g.interrupt().selectAll("*").interrupt();
      if (dragging) {
        origin[0] = xExtent[0] - origin[0];
        origin[1] = yExtent[0] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
        origin[0] = xExtent[ex];
        origin[1] = yExtent[ey];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= xExtent[1];
            origin[1] -= yExtent[1];
            dragging = 2;
          }
          d3_eventPreventDefault();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += xExtent[1];
          origin[1] += yExtent[1];
          dragging = 0;
          d3_eventPreventDefault();
        }
      }
      function brushmove() {
        var point = d3.mouse(target), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
            origin[0] = xExtent[+(point[0] < center[0])];
            origin[1] = yExtent[+(point[1] < center[1])];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0] != min || extent[1] != max) {
          if (i) yExtentDomain = null; else xExtentDomain = null;
          extent[0] = min;
          extent[1] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        dragRestore();
        event_({
          type: "brushend"
        });
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.clamp = function(z) {
      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        if (x) {
          if (xExtentDomain) {
            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
          } else {
            x0 = xExtent[0], x1 = xExtent[1];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          if (yExtentDomain) {
            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
          } else {
            y0 = yExtent[0], y1 = yExtent[1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        xExtentDomain = [ x0, x1 ];
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        yExtentDomain = [ y0, y1 ];
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
      }
      return brush;
    };
    brush.clear = function() {
      if (!brush.empty()) {
        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
        xExtentDomain = yExtentDomain = null;
      }
      return brush;
    };
    brush.empty = function() {
      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  d3.text = d3_xhrType(function(request) {
    return request.responseText;
  });
  d3.json = function(url, callback) {
    return d3_xhr(url, "application/json", d3_json, callback);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3_xhr(url, "text/html", d3_html, callback);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = d3_xhrType(function(request) {
    return request.responseXML;
  });
  if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else {}
}.apply(self);

/***/ }),

/***/ 3435:
/***/ (function(module) {

module.exports = clamp

function clamp(value, min, max) {
  return min < max
    ? (value < min ? min : value > max ? max : value)
    : (value < max ? max : value > min ? min : value)
}


/***/ }),

/***/ 6857:
/***/ (function(module) {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),

/***/ 5075:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/** @module  color-normalize */



var rgba = __webpack_require__(6652)
var clamp = __webpack_require__(3435)
var dtype = __webpack_require__(660)

module.exports = function normalize (color, type) {
	if (type === 'float' || !type) type = 'array'
	if (type === 'uint') type = 'uint8'
	if (type === 'uint_clamped') type = 'uint8_clamped'
	var Ctor = dtype(type)
	var output = new Ctor(4)

	var normalize = type !== 'uint8' && type !== 'uint8_clamped'

	// attempt to parse non-array arguments
	if (!color.length || typeof color === 'string') {
		color = rgba(color)
		color[0] /= 255
		color[1] /= 255
		color[2] /= 255
	}

	// 0, 1 are possible contradictory values for Arrays:
	// [1,1,1] input gives [1,1,1] output instead of [1/255,1/255,1/255], which may be collision if input is meant to be uint.
	// converting [1,1,1] to [1/255,1/255,1/255] in case of float input gives larger mistake since [1,1,1] float is frequent edge value, whereas [0,1,1], [1,1,1] etc. uint inputs are relatively rare
	if (isInt(color)) {
		output[0] = color[0]
		output[1] = color[1]
		output[2] = color[2]
		output[3] = color[3] != null ? color[3] : 255

		if (normalize) {
			output[0] /= 255
			output[1] /= 255
			output[2] /= 255
			output[3] /= 255
		}

		return output
	}

	if (!normalize) {
		output[0] = clamp(Math.floor(color[0] * 255), 0, 255)
		output[1] = clamp(Math.floor(color[1] * 255), 0, 255)
		output[2] = clamp(Math.floor(color[2] * 255), 0, 255)
		output[3] = color[3] == null ? 255 : clamp(Math.floor(color[3] * 255), 0, 255)
	} else {
		output[0] = color[0]
		output[1] = color[1]
		output[2] = color[2]
		output[3] = color[3] != null ? color[3] : 1
	}

	return output
}

function isInt(color) {
	if (color instanceof Uint8Array || color instanceof Uint8ClampedArray) return true

	if (Array.isArray(color) &&
		(color[0] > 1 || color[0] === 0) &&
		(color[1] > 1 || color[1] === 0) &&
		(color[2] > 1 || color[2] === 0) &&
		(!color[3] || color[3] > 1)
	) return true

	return false
}


/***/ }),

/***/ 736:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/**
 * @module color-parse
 */



var names = __webpack_require__(6857)
var isObject = __webpack_require__(973)
var defined = __webpack_require__(6775)

module.exports = parse

/**
 * Base hues
 * http://dev.w3.org/csswg/css-color/#typedef-named-hue
 */
//FIXME: use external hue detector
var baseHues = {
	red: 0,
	orange: 60,
	yellow: 120,
	green: 180,
	blue: 240,
	purple: 300
}

/**
 * Parse color from the string passed
 *
 * @return {Object} A space indicator `space`, an array `values` and `alpha`
 */
function parse (cstr) {
	var m, parts = [], alpha = 1, space

	if (typeof cstr === 'string') {
		//keyword
		if (names[cstr]) {
			parts = names[cstr].slice()
			space = 'rgb'
		}

		//reserved words
		else if (cstr === 'transparent') {
			alpha = 0
			space = 'rgb'
			parts = [0,0,0]
		}

		//hex
		else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
			var base = cstr.slice(1)
			var size = base.length
			var isShort = size <= 4
			alpha = 1

			if (isShort) {
				parts = [
					parseInt(base[0] + base[0], 16),
					parseInt(base[1] + base[1], 16),
					parseInt(base[2] + base[2], 16)
				]
				if (size === 4) {
					alpha = parseInt(base[3] + base[3], 16) / 255
				}
			}
			else {
				parts = [
					parseInt(base[0] + base[1], 16),
					parseInt(base[2] + base[3], 16),
					parseInt(base[4] + base[5], 16)
				]
				if (size === 8) {
					alpha = parseInt(base[6] + base[7], 16) / 255
				}
			}

			if (!parts[0]) parts[0] = 0
			if (!parts[1]) parts[1] = 0
			if (!parts[2]) parts[2] = 0

			space = 'rgb'
		}

		//color space
		else if (m = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
			var name = m[1]
			var isRGB = name === 'rgb'
			var base = name.replace(/a$/, '')
			space = base
			var size = base === 'cmyk' ? 4 : base === 'gray' ? 1 : 3
			parts = m[2].trim()
				.split(/\s*,\s*/)
				.map(function (x, i) {
					//<percentage>
					if (/%$/.test(x)) {
						//alpha
						if (i === size)	return parseFloat(x) / 100
						//rgb
						if (base === 'rgb') return parseFloat(x) * 255 / 100
						return parseFloat(x)
					}
					//hue
					else if (base[i] === 'h') {
						//<deg>
						if (/deg$/.test(x)) {
							return parseFloat(x)
						}
						//<base-hue>
						else if (baseHues[x] !== undefined) {
							return baseHues[x]
						}
					}
					return parseFloat(x)
				})

			if (name === base) parts.push(1)
			alpha = (isRGB) ? 1 : (parts[size] === undefined) ? 1 : parts[size]
			parts = parts.slice(0, size)
		}

		//named channels case
		else if (cstr.length > 10 && /[0-9](?:\s|\/)/.test(cstr)) {
			parts = cstr.match(/([0-9]+)/g).map(function (value) {
				return parseFloat(value)
			})

			space = cstr.match(/([a-z])/ig).join('').toLowerCase()
		}
	}

	//numeric case
	else if (!isNaN(cstr)) {
		space = 'rgb'
		parts = [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff]
	}

	//object case - detects css cases of rgb and hsl
	else if (isObject(cstr)) {
		var r = defined(cstr.r, cstr.red, cstr.R, null)

		if (r !== null) {
			space = 'rgb'
			parts = [
				r,
				defined(cstr.g, cstr.green, cstr.G),
				defined(cstr.b, cstr.blue, cstr.B)
			]
		}
		else {
			space = 'hsl'
			parts = [
				defined(cstr.h, cstr.hue, cstr.H),
				defined(cstr.s, cstr.saturation, cstr.S),
				defined(cstr.l, cstr.lightness, cstr.L, cstr.b, cstr.brightness)
			]
		}

		alpha = defined(cstr.a, cstr.alpha, cstr.opacity, 1)

		if (cstr.opacity != null) alpha /= 100
	}

	//array
	else if (Array.isArray(cstr) || __webpack_require__.g.ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(cstr)) {
		parts = [cstr[0], cstr[1], cstr[2]]
		space = 'rgb'
		alpha = cstr.length === 4 ? cstr[3] : 1
	}

	return {
		space: space,
		values: parts,
		alpha: alpha
	}
}


/***/ }),

/***/ 6652:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/** @module  color-rgba */



var parse = __webpack_require__(736)
var hsl = __webpack_require__(9)
var clamp = __webpack_require__(3435)

module.exports = function rgba (color) {
	var values, i, l

	//attempt to parse non-array arguments
	var parsed = parse(color)

	if (!parsed.space) return []

	values = Array(3)
	values[0] = clamp(parsed.values[0], 0, 255)
	values[1] = clamp(parsed.values[1], 0, 255)
	values[2] = clamp(parsed.values[2], 0, 255)

	if (parsed.space[0] === 'h') {
		values = hsl.rgb(values)
	}

	values.push(clamp(parsed.alpha, 0, 1))

	return values
}


/***/ }),

/***/ 9:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/**
 * @module color-space/hsl
 */


var rgb = __webpack_require__(6866);

module.exports = {
	name: 'hsl',
	min: [0,0,0],
	max: [360,100,100],
	channel: ['hue', 'saturation', 'lightness'],
	alias: ['HSL'],

	rgb: function(hsl) {
		var h = hsl[0] / 360,
				s = hsl[1] / 100,
				l = hsl[2] / 100,
				t1, t2, t3, rgb, val;

		if (s === 0) {
			val = l * 255;
			return [val, val, val];
		}

		if (l < 0.5) {
			t2 = l * (1 + s);
		}
		else {
			t2 = l + s - l * s;
		}
		t1 = 2 * l - t2;

		rgb = [0, 0, 0];
		for (var i = 0; i < 3; i++) {
			t3 = h + 1 / 3 * - (i - 1);
			if (t3 < 0) {
				t3++;
			}
			else if (t3 > 1) {
				t3--;
			}

			if (6 * t3 < 1) {
				val = t1 + (t2 - t1) * 6 * t3;
			}
			else if (2 * t3 < 1) {
				val = t2;
			}
			else if (3 * t3 < 2) {
				val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
			}
			else {
				val = t1;
			}

			rgb[i] = val * 255;
		}

		return rgb;
	}
};


//extend rgb
rgb.hsl = function(rgb) {
	var r = rgb[0]/255,
			g = rgb[1]/255,
			b = rgb[2]/255,
			min = Math.min(r, g, b),
			max = Math.max(r, g, b),
			delta = max - min,
			h, s, l;

	if (max === min) {
		h = 0;
	}
	else if (r === max) {
		h = (g - b) / delta;
	}
	else if (g === max) {
		h = 2 + (b - r) / delta;
	}
	else if (b === max) {
		h = 4 + (r - g)/ delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	}
	else if (l <= 0.5) {
		s = delta / (max + min);
	}
	else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};


/***/ }),

/***/ 6866:
/***/ (function(module) {

"use strict";
/**
 * RGB space.
 *
 * @module  color-space/rgb
 */


module.exports = {
	name: 'rgb',
	min: [0,0,0],
	max: [255,255,255],
	channel: ['red', 'green', 'blue'],
	alias: ['RGB']
};


/***/ }),

/***/ 721:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  WU: function() { return /* reexport */ format; },
  FF: function() { return /* reexport */ locale; }
});

// UNUSED EXPORTS: FormatSpecifier, formatDefaultLocale, formatPrefix, formatSpecifier, precisionFixed, precisionPrefix, precisionRound

;// CONCATENATED MODULE: ./node_modules/d3-format/src/formatDecimal.js
/* harmony default export */ function formatDecimal(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

;// CONCATENATED MODULE: ./node_modules/d3-format/src/exponent.js


/* harmony default export */ function exponent(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}

;// CONCATENATED MODULE: ./node_modules/d3-format/src/formatGroup.js
/* harmony default export */ function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

;// CONCATENATED MODULE: ./node_modules/d3-format/src/formatNumerals.js
/* harmony default export */ function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

;// CONCATENATED MODULE: ./node_modules/d3-format/src/formatSpecifier.js
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

;// CONCATENATED MODULE: ./node_modules/d3-format/src/formatTrim.js
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

;// CONCATENATED MODULE: ./node_modules/d3-format/src/formatPrefixAuto.js


var prefixExponent;

/* harmony default export */ function formatPrefixAuto(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

;// CONCATENATED MODULE: ./node_modules/d3-format/src/formatRounded.js


/* harmony default export */ function formatRounded(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

;// CONCATENATED MODULE: ./node_modules/d3-format/src/formatTypes.js




/* harmony default export */ var formatTypes = ({
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": formatDecimal,
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
});

;// CONCATENATED MODULE: ./node_modules/d3-format/src/identity.js
/* harmony default export */ function identity(x) {
  return x;
}

;// CONCATENATED MODULE: ./node_modules/d3-format/src/locale.js









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ function locale(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "-" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

;// CONCATENATED MODULE: ./node_modules/d3-format/src/defaultLocale.js


var defaultLocale_locale;
var format;
var formatPrefix;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
  minus: "-"
});

function defaultLocale(definition) {
  defaultLocale_locale = locale(definition);
  format = defaultLocale_locale.format;
  formatPrefix = defaultLocale_locale.formatPrefix;
  return defaultLocale_locale;
}

;// CONCATENATED MODULE: ./node_modules/d3-format/src/index.js








/***/ }),

/***/ 4096:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  i$: function() { return /* reexport */ timeFormat; },
  Dq: function() { return /* reexport */ formatLocale; },
  g0: function() { return /* reexport */ utcFormat; }
});

// UNUSED EXPORTS: isoFormat, isoParse, timeFormatDefaultLocale, timeParse, utcParse

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcWeek.js
var utcWeek = __webpack_require__(8176);
// EXTERNAL MODULE: ./node_modules/d3-time/src/utcDay.js
var utcDay = __webpack_require__(8480);
// EXTERNAL MODULE: ./node_modules/d3-time/src/week.js
var src_week = __webpack_require__(9879);
// EXTERNAL MODULE: ./node_modules/d3-time/src/day.js
var src_day = __webpack_require__(2301);
// EXTERNAL MODULE: ./node_modules/d3-time/src/year.js
var year = __webpack_require__(4823);
// EXTERNAL MODULE: ./node_modules/d3-time/src/utcYear.js
var utcYear = __webpack_require__(9791);
;// CONCATENATED MODULE: ./node_modules/d3-time-format/src/locale.js


function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

      // If this is utcParse, never use the local timezone.
      if (Z && !("Z" in d)) d.Z = 0;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // If the month was not specified, inherit from the quarter.
      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcWeek/* utcMonday */.l6.ceil(week) : (0,utcWeek/* utcMonday */.l6)(week);
          week = utcDay/* default */.Z.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? src_week/* monday */.wA.ceil(week) : (0,src_week/* monday */.wA)(week);
          week = src_day/* default */.Z.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + src_day/* default */.Z.count((0,year/* default */.Z)(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(src_week/* sunday */.OM.count((0,year/* default */.Z)(d) - 1, d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? (0,src_week/* thursday */.bL)(d) : src_week/* thursday */.bL.ceil(d);
  return pad(src_week/* thursday */.bL.count((0,year/* default */.Z)(d), d) + ((0,year/* default */.Z)(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(src_week/* monday */.wA.count((0,year/* default */.Z)(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay/* default */.Z.count((0,utcYear/* default */.Z)(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(utcWeek/* utcSunday */.Ox.count((0,utcYear/* default */.Z)(d) - 1, d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? (0,utcWeek/* utcThursday */.hB)(d) : utcWeek/* utcThursday */.hB.ceil(d);
  return pad(utcWeek/* utcThursday */.hB.count((0,utcYear/* default */.Z)(d), d) + ((0,utcYear/* default */.Z)(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(utcWeek/* utcMonday */.l6.count((0,utcYear/* default */.Z)(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

;// CONCATENATED MODULE: ./node_modules/d3-time-format/src/defaultLocale.js


var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  timeFormat = locale.format;
  timeParse = locale.parse;
  utcFormat = locale.utcFormat;
  utcParse = locale.utcParse;
  return locale;
}

;// CONCATENATED MODULE: ./node_modules/d3-time-format/src/index.js






/***/ }),

/***/ 2301:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: function() { return /* binding */ days; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4263);



var day = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration_js__WEBPACK_IMPORTED_MODULE_1__/* .durationMinute */ .yB) / _duration_js__WEBPACK_IMPORTED_MODULE_1__/* .durationDay */ .UD;
}, function(date) {
  return date.getDate() - 1;
});

/* harmony default export */ __webpack_exports__.Z = (day);
var days = day.range;


/***/ }),

/***/ 4263:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UD: function() { return /* binding */ durationDay; },
/* harmony export */   Y2: function() { return /* binding */ durationHour; },
/* harmony export */   Ym: function() { return /* binding */ durationSecond; },
/* harmony export */   iM: function() { return /* binding */ durationWeek; },
/* harmony export */   yB: function() { return /* binding */ durationMinute; }
/* harmony export */ });
var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;


/***/ }),

/***/ 1041:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  timeDay: function() { return /* reexport */ day/* default */.Z; },
  timeDays: function() { return /* reexport */ day/* days */.a; },
  timeFriday: function() { return /* reexport */ week/* friday */.mC; },
  timeFridays: function() { return /* reexport */ week/* fridays */.b$; },
  timeHour: function() { return /* reexport */ src_hour; },
  timeHours: function() { return /* reexport */ hours; },
  timeInterval: function() { return /* reexport */ interval/* default */.Z; },
  timeMillisecond: function() { return /* reexport */ src_millisecond; },
  timeMilliseconds: function() { return /* reexport */ milliseconds; },
  timeMinute: function() { return /* reexport */ src_minute; },
  timeMinutes: function() { return /* reexport */ minutes; },
  timeMonday: function() { return /* reexport */ week/* monday */.wA; },
  timeMondays: function() { return /* reexport */ week/* mondays */.bJ; },
  timeMonth: function() { return /* reexport */ src_month; },
  timeMonths: function() { return /* reexport */ months; },
  timeSaturday: function() { return /* reexport */ week/* saturday */.EY; },
  timeSaturdays: function() { return /* reexport */ week/* saturdays */.Ff; },
  timeSecond: function() { return /* reexport */ src_second; },
  timeSeconds: function() { return /* reexport */ seconds; },
  timeSunday: function() { return /* reexport */ week/* sunday */.OM; },
  timeSundays: function() { return /* reexport */ week/* sundays */.vm; },
  timeThursday: function() { return /* reexport */ week/* thursday */.bL; },
  timeThursdays: function() { return /* reexport */ week/* thursdays */.$t; },
  timeTuesday: function() { return /* reexport */ week/* tuesday */.sy; },
  timeTuesdays: function() { return /* reexport */ week/* tuesdays */.aU; },
  timeWednesday: function() { return /* reexport */ week/* wednesday */.zg; },
  timeWednesdays: function() { return /* reexport */ week/* wednesdays */.Ld; },
  timeWeek: function() { return /* reexport */ week/* sunday */.OM; },
  timeWeeks: function() { return /* reexport */ week/* sundays */.vm; },
  timeYear: function() { return /* reexport */ year/* default */.Z; },
  timeYears: function() { return /* reexport */ year/* years */.g; },
  utcDay: function() { return /* reexport */ utcDay/* default */.Z; },
  utcDays: function() { return /* reexport */ utcDay/* utcDays */.y; },
  utcFriday: function() { return /* reexport */ utcWeek/* utcFriday */.QQ; },
  utcFridays: function() { return /* reexport */ utcWeek/* utcFridays */.fz; },
  utcHour: function() { return /* reexport */ src_utcHour; },
  utcHours: function() { return /* reexport */ utcHours; },
  utcMillisecond: function() { return /* reexport */ src_millisecond; },
  utcMilliseconds: function() { return /* reexport */ milliseconds; },
  utcMinute: function() { return /* reexport */ src_utcMinute; },
  utcMinutes: function() { return /* reexport */ utcMinutes; },
  utcMonday: function() { return /* reexport */ utcWeek/* utcMonday */.l6; },
  utcMondays: function() { return /* reexport */ utcWeek/* utcMondays */.$3; },
  utcMonth: function() { return /* reexport */ src_utcMonth; },
  utcMonths: function() { return /* reexport */ utcMonths; },
  utcSaturday: function() { return /* reexport */ utcWeek/* utcSaturday */.g4; },
  utcSaturdays: function() { return /* reexport */ utcWeek/* utcSaturdays */.Q_; },
  utcSecond: function() { return /* reexport */ src_second; },
  utcSeconds: function() { return /* reexport */ seconds; },
  utcSunday: function() { return /* reexport */ utcWeek/* utcSunday */.Ox; },
  utcSundays: function() { return /* reexport */ utcWeek/* utcSundays */.SU; },
  utcThursday: function() { return /* reexport */ utcWeek/* utcThursday */.hB; },
  utcThursdays: function() { return /* reexport */ utcWeek/* utcThursdays */.xj; },
  utcTuesday: function() { return /* reexport */ utcWeek/* utcTuesday */.J1; },
  utcTuesdays: function() { return /* reexport */ utcWeek/* utcTuesdays */.DK; },
  utcWednesday: function() { return /* reexport */ utcWeek/* utcWednesday */.b3; },
  utcWednesdays: function() { return /* reexport */ utcWeek/* utcWednesdays */.uy; },
  utcWeek: function() { return /* reexport */ utcWeek/* utcSunday */.Ox; },
  utcWeeks: function() { return /* reexport */ utcWeek/* utcSundays */.SU; },
  utcYear: function() { return /* reexport */ utcYear/* default */.Z; },
  utcYears: function() { return /* reexport */ utcYear/* utcYears */.D; }
});

// EXTERNAL MODULE: ./node_modules/d3-time/src/interval.js
var interval = __webpack_require__(52);
;// CONCATENATED MODULE: ./node_modules/d3-time/src/millisecond.js


var millisecond = (0,interval/* default */.Z)(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return (0,interval/* default */.Z)(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

/* harmony default export */ var src_millisecond = (millisecond);
var milliseconds = millisecond.range;

// EXTERNAL MODULE: ./node_modules/d3-time/src/duration.js
var duration = __webpack_require__(4263);
;// CONCATENATED MODULE: ./node_modules/d3-time/src/second.js



var second = (0,interval/* default */.Z)(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * duration/* durationSecond */.Ym);
}, function(start, end) {
  return (end - start) / duration/* durationSecond */.Ym;
}, function(date) {
  return date.getUTCSeconds();
});

/* harmony default export */ var src_second = (second);
var seconds = second.range;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/minute.js



var minute = (0,interval/* default */.Z)(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * duration/* durationSecond */.Ym);
}, function(date, step) {
  date.setTime(+date + step * duration/* durationMinute */.yB);
}, function(start, end) {
  return (end - start) / duration/* durationMinute */.yB;
}, function(date) {
  return date.getMinutes();
});

/* harmony default export */ var src_minute = (minute);
var minutes = minute.range;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/hour.js



var hour = (0,interval/* default */.Z)(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * duration/* durationSecond */.Ym - date.getMinutes() * duration/* durationMinute */.yB);
}, function(date, step) {
  date.setTime(+date + step * duration/* durationHour */.Y2);
}, function(start, end) {
  return (end - start) / duration/* durationHour */.Y2;
}, function(date) {
  return date.getHours();
});

/* harmony default export */ var src_hour = (hour);
var hours = hour.range;

// EXTERNAL MODULE: ./node_modules/d3-time/src/day.js
var day = __webpack_require__(2301);
// EXTERNAL MODULE: ./node_modules/d3-time/src/week.js
var week = __webpack_require__(9879);
;// CONCATENATED MODULE: ./node_modules/d3-time/src/month.js


var month = (0,interval/* default */.Z)(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

/* harmony default export */ var src_month = (month);
var months = month.range;

// EXTERNAL MODULE: ./node_modules/d3-time/src/year.js
var year = __webpack_require__(4823);
;// CONCATENATED MODULE: ./node_modules/d3-time/src/utcMinute.js



var utcMinute = (0,interval/* default */.Z)(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * duration/* durationMinute */.yB);
}, function(start, end) {
  return (end - start) / duration/* durationMinute */.yB;
}, function(date) {
  return date.getUTCMinutes();
});

/* harmony default export */ var src_utcMinute = (utcMinute);
var utcMinutes = utcMinute.range;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/utcHour.js



var utcHour = (0,interval/* default */.Z)(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * duration/* durationHour */.Y2);
}, function(start, end) {
  return (end - start) / duration/* durationHour */.Y2;
}, function(date) {
  return date.getUTCHours();
});

/* harmony default export */ var src_utcHour = (utcHour);
var utcHours = utcHour.range;

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcDay.js
var utcDay = __webpack_require__(8480);
// EXTERNAL MODULE: ./node_modules/d3-time/src/utcWeek.js
var utcWeek = __webpack_require__(8176);
;// CONCATENATED MODULE: ./node_modules/d3-time/src/utcMonth.js


var utcMonth = (0,interval/* default */.Z)(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

/* harmony default export */ var src_utcMonth = (utcMonth);
var utcMonths = utcMonth.range;

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcYear.js
var utcYear = __webpack_require__(9791);
;// CONCATENATED MODULE: ./node_modules/d3-time/src/index.js































/***/ }),

/***/ 52:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: function() { return /* binding */ newInterval; }
/* harmony export */ });
var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
  }

  interval.floor = function(date) {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}


/***/ }),

/***/ 8480:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   y: function() { return /* binding */ utcDays; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4263);



var utcDay = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__/* .durationDay */ .UD;
}, function(date) {
  return date.getUTCDate() - 1;
});

/* harmony default export */ __webpack_exports__.Z = (utcDay);
var utcDays = utcDay.range;


/***/ }),

/***/ 8176:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $3: function() { return /* binding */ utcMondays; },
/* harmony export */   DK: function() { return /* binding */ utcTuesdays; },
/* harmony export */   J1: function() { return /* binding */ utcTuesday; },
/* harmony export */   Ox: function() { return /* binding */ utcSunday; },
/* harmony export */   QQ: function() { return /* binding */ utcFriday; },
/* harmony export */   Q_: function() { return /* binding */ utcSaturdays; },
/* harmony export */   SU: function() { return /* binding */ utcSundays; },
/* harmony export */   b3: function() { return /* binding */ utcWednesday; },
/* harmony export */   fz: function() { return /* binding */ utcFridays; },
/* harmony export */   g4: function() { return /* binding */ utcSaturday; },
/* harmony export */   hB: function() { return /* binding */ utcThursday; },
/* harmony export */   l6: function() { return /* binding */ utcMonday; },
/* harmony export */   uy: function() { return /* binding */ utcWednesdays; },
/* harmony export */   xj: function() { return /* binding */ utcThursdays; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4263);



function utcWeekday(i) {
  return (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__/* .durationWeek */ .iM;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;


/***/ }),

/***/ 9791:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: function() { return /* binding */ utcYears; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);


var utcYear = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

/* harmony default export */ __webpack_exports__.Z = (utcYear);
var utcYears = utcYear.range;


/***/ }),

/***/ 9879:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $t: function() { return /* binding */ thursdays; },
/* harmony export */   EY: function() { return /* binding */ saturday; },
/* harmony export */   Ff: function() { return /* binding */ saturdays; },
/* harmony export */   Ld: function() { return /* binding */ wednesdays; },
/* harmony export */   OM: function() { return /* binding */ sunday; },
/* harmony export */   aU: function() { return /* binding */ tuesdays; },
/* harmony export */   b$: function() { return /* binding */ fridays; },
/* harmony export */   bJ: function() { return /* binding */ mondays; },
/* harmony export */   bL: function() { return /* binding */ thursday; },
/* harmony export */   mC: function() { return /* binding */ friday; },
/* harmony export */   sy: function() { return /* binding */ tuesday; },
/* harmony export */   vm: function() { return /* binding */ sundays; },
/* harmony export */   wA: function() { return /* binding */ monday; },
/* harmony export */   zg: function() { return /* binding */ wednesday; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4263);



function weekday(i) {
  return (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration_js__WEBPACK_IMPORTED_MODULE_1__/* .durationMinute */ .yB) / _duration_js__WEBPACK_IMPORTED_MODULE_1__/* .durationWeek */ .iM;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;


/***/ }),

/***/ 4823:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: function() { return /* binding */ years; }
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);


var year = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

/* harmony default export */ __webpack_exports__.Z = (year);
var years = year.range;


/***/ }),

/***/ 6775:
/***/ (function(module) {

module.exports = function () {
    for (var i = 0; i < arguments.length; i++) {
        if (arguments[i] !== undefined) return arguments[i];
    }
};


/***/ }),

/***/ 660:
/***/ (function(module) {

module.exports = function(dtype) {
  switch (dtype) {
    case 'int8':
      return Int8Array
    case 'int16':
      return Int16Array
    case 'int32':
      return Int32Array
    case 'uint8':
      return Uint8Array
    case 'uint16':
      return Uint16Array
    case 'uint32':
      return Uint32Array
    case 'float32':
      return Float32Array
    case 'float64':
      return Float64Array
    case 'array':
      return Array
    case 'uint8_clamped':
      return Uint8ClampedArray
  }
}


/***/ }),

/***/ 5398:
/***/ (function(module) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ 2770:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/**
 * inspired by is-number <https://github.com/jonschlinkert/is-number>
 * but significantly simplified and sped up by ignoring number and string constructors
 * ie these return false:
 *   new Number(1)
 *   new String('1')
 */



var allBlankCharCodes = __webpack_require__(8546);

module.exports = function(n) {
    var type = typeof n;
    if(type === 'string') {
        var original = n;
        n = +n;
        // whitespace strings cast to zero - filter them out
        if(n===0 && allBlankCharCodes(original)) return false;
    }
    else if(type !== 'number') return false;

    return n - n < 1;
};


/***/ }),

/***/ 6249:
/***/ (function(module) {

module.exports = getCanvasContext
function getCanvasContext (type, opts) {
  if (typeof type !== 'string') {
    throw new TypeError('must specify type string')
  }

  opts = opts || {}

  if (typeof document === 'undefined' && !opts.canvas) {
    return null // check for Node
  }

  var canvas = opts.canvas || document.createElement('canvas')
  if (typeof opts.width === 'number') {
    canvas.width = opts.width
  }
  if (typeof opts.height === 'number') {
    canvas.height = opts.height
  }

  var attribs = opts
  var gl
  try {
    var names = [ type ]
    // prefix GL contexts
    if (type.indexOf('webgl') === 0) {
      names.push('experimental-' + type)
    }

    for (var i = 0; i < names.length; i++) {
      gl = canvas.getContext(names[i], attribs)
      if (gl) return gl
    }
  } catch (e) {
    gl = null
  }
  return (gl || null) // ensure null on fail
}


/***/ }),

/***/ 5400:
/***/ (function(module) {

module.exports = adjoint;

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/***/ }),

/***/ 2331:
/***/ (function(module) {

module.exports = clone;

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
    var out = new Float32Array(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/***/ }),

/***/ 1042:
/***/ (function(module) {

module.exports = copy;

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/***/ }),

/***/ 1902:
/***/ (function(module) {

module.exports = create;

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
    var out = new Float32Array(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/***/ }),

/***/ 9887:
/***/ (function(module) {

module.exports = determinant;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/***/ }),

/***/ 7812:
/***/ (function(module) {

module.exports = fromQuat;

/**
 * Creates a matrix from a quaternion rotation.
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @returns {mat4} out
 */
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/***/ }),

/***/ 4045:
/***/ (function(module) {

module.exports = fromRotation

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotate(dest, dest, rad, axis)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  var s, c, t
  var x = axis[0]
  var y = axis[1]
  var z = axis[2]
  var len = Math.sqrt(x * x + y * y + z * z)

  if (Math.abs(len) < 0.000001) {
    return null
  }

  len = 1 / len
  x *= len
  y *= len
  z *= len

  s = Math.sin(rad)
  c = Math.cos(rad)
  t = 1 - c

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c
  out[1] = y * x * t + z * s
  out[2] = z * x * t - y * s
  out[3] = 0
  out[4] = x * y * t - z * s
  out[5] = y * y * t + c
  out[6] = z * y * t + x * s
  out[7] = 0
  out[8] = x * z * t + y * s
  out[9] = y * z * t - x * s
  out[10] = z * z * t + c
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}


/***/ }),

/***/ 5973:
/***/ (function(module) {

module.exports = fromRotationTranslation;

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

/***/ }),

/***/ 1472:
/***/ (function(module) {

module.exports = fromScaling

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.scale(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0]
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = v[1]
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = v[2]
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}


/***/ }),

/***/ 4669:
/***/ (function(module) {

module.exports = fromTranslation

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.translate(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = 1
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = 1
  out[11] = 0
  out[12] = v[0]
  out[13] = v[1]
  out[14] = v[2]
  out[15] = 1
  return out
}


/***/ }),

/***/ 5262:
/***/ (function(module) {

module.exports = fromXRotation

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateX(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = 1
    out[1] = 0
    out[2] = 0
    out[3] = 0
    out[4] = 0
    out[5] = c
    out[6] = s
    out[7] = 0
    out[8] = 0
    out[9] = -s
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}

/***/ }),

/***/ 331:
/***/ (function(module) {

module.exports = fromYRotation

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateY(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = 0
    out[2] = -s
    out[3] = 0
    out[4] = 0
    out[5] = 1
    out[6] = 0
    out[7] = 0
    out[8] = s
    out[9] = 0
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}

/***/ }),

/***/ 1049:
/***/ (function(module) {

module.exports = fromZRotation

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateZ(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = s
    out[2] = 0
    out[3] = 0
    out[4] = -s
    out[5] = c
    out[6] = 0
    out[7] = 0
    out[8] = 0
    out[9] = 0
    out[10] = 1
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}

/***/ }),

/***/ 5195:
/***/ (function(module) {

module.exports = frustum;

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/***/ }),

/***/ 1551:
/***/ (function(module) {

module.exports = identity;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/***/ }),

/***/ 9576:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = {
  create: __webpack_require__(1902)
  , clone: __webpack_require__(2331)
  , copy: __webpack_require__(1042)
  , identity: __webpack_require__(1551)
  , transpose: __webpack_require__(8654)
  , invert: __webpack_require__(5874)
  , adjoint: __webpack_require__(5400)
  , determinant: __webpack_require__(9887)
  , multiply: __webpack_require__(1362)
  , translate: __webpack_require__(1283)
  , scale: __webpack_require__(789)
  , rotate: __webpack_require__(5074)
  , rotateX: __webpack_require__(5545)
  , rotateY: __webpack_require__(4918)
  , rotateZ: __webpack_require__(5692)
  , fromRotation: __webpack_require__(4045)
  , fromRotationTranslation: __webpack_require__(5973)
  , fromScaling: __webpack_require__(1472)
  , fromTranslation: __webpack_require__(4669)
  , fromXRotation: __webpack_require__(5262)
  , fromYRotation: __webpack_require__(331)
  , fromZRotation: __webpack_require__(1049)
  , fromQuat: __webpack_require__(7812)
  , frustum: __webpack_require__(5195)
  , perspective: __webpack_require__(7864)
  , perspectiveFromFieldOfView: __webpack_require__(5279)
  , ortho: __webpack_require__(378)
  , lookAt: __webpack_require__(5551)
  , str: __webpack_require__(6726)
}


/***/ }),

/***/ 5874:
/***/ (function(module) {

module.exports = invert;

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/***/ }),

/***/ 5551:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var identity = __webpack_require__(1551);

module.exports = lookAt;

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < 0.000001 &&
        Math.abs(eyey - centery) < 0.000001 &&
        Math.abs(eyez - centerz) < 0.000001) {
        return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/***/ }),

/***/ 1362:
/***/ (function(module) {

module.exports = multiply;

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/***/ }),

/***/ 378:
/***/ (function(module) {

module.exports = ortho;

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/***/ }),

/***/ 7864:
/***/ (function(module) {

module.exports = perspective;

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/***/ }),

/***/ 5279:
/***/ (function(module) {

module.exports = perspectiveFromFieldOfView;

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}



/***/ }),

/***/ 5074:
/***/ (function(module) {

module.exports = rotate;

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < 0.000001) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/***/ }),

/***/ 5545:
/***/ (function(module) {

module.exports = rotateX;

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/***/ }),

/***/ 4918:
/***/ (function(module) {

module.exports = rotateY;

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/***/ }),

/***/ 5692:
/***/ (function(module) {

module.exports = rotateZ;

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/***/ }),

/***/ 789:
/***/ (function(module) {

module.exports = scale;

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/***/ }),

/***/ 6726:
/***/ (function(module) {

module.exports = str;

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/***/ }),

/***/ 1283:
/***/ (function(module) {

module.exports = translate;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/***/ }),

/***/ 8654:
/***/ (function(module) {

module.exports = transpose;

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/***/ }),

/***/ 7035:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isBrowser = __webpack_require__(4404)
var hasHover

if (typeof __webpack_require__.g.matchMedia === 'function') {
	hasHover = !__webpack_require__.g.matchMedia('(hover: none)').matches
}
else {
	hasHover = isBrowser
}

module.exports = hasHover


/***/ }),

/***/ 8520:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isBrowser = __webpack_require__(4404)

function detect() {
	var supported = false

	try {
		var opts = Object.defineProperty({}, 'passive', {
			get: function() {
				supported = true
			}
		})

		window.addEventListener('test', null, opts)
		window.removeEventListener('test', null, opts)
	} catch(e) {
		supported = false
	}

	return supported
}

module.exports = isBrowser && detect()


/***/ }),

/***/ 4404:
/***/ (function(module) {

module.exports = true;

/***/ }),

/***/ 973:
/***/ (function(module) {

"use strict";

var toString = Object.prototype.toString;

module.exports = function (x) {
	var prototype;
	return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
};


/***/ }),

/***/ 8546:
/***/ (function(module) {

"use strict";


/**
 * Is this string all whitespace?
 * This solution kind of makes my brain hurt, but it's significantly faster
 * than !str.trim() or any other solution I could find.
 *
 * whitespace codes from: http://en.wikipedia.org/wiki/Whitespace_character
 * and verified with:
 *
 *  for(var i = 0; i < 65536; i++) {
 *      var s = String.fromCharCode(i);
 *      if(+s===0 && !s.trim()) console.log(i, s);
 *  }
 *
 * which counts a couple of these as *not* whitespace, but finds nothing else
 * that *is* whitespace. Note that charCodeAt stops at 16 bits, but it appears
 * that there are no whitespace characters above this, and code points above
 * this do not map onto white space characters.
 */

module.exports = function(str){
    var l = str.length,
        a;
    for(var i = 0; i < l; i++) {
        a = str.charCodeAt(i);
        if((a < 9 || a > 13) && (a !== 32) && (a !== 133) && (a !== 160) &&
            (a !== 5760) && (a !== 6158) && (a < 8192 || a > 8205) &&
            (a !== 8232) && (a !== 8233) && (a !== 8239) && (a !== 8287) &&
            (a !== 8288) && (a !== 12288) && (a !== 65279)) {
                return false;
        }
    }
    return true;
}


/***/ }),

/***/ 8956:
/***/ (function(module) {

var rootPosition = { left: 0, top: 0 }

module.exports = mouseEventOffset
function mouseEventOffset (ev, target, out) {
  target = target || ev.currentTarget || ev.srcElement
  if (!Array.isArray(out)) {
    out = [ 0, 0 ]
  }
  var cx = ev.clientX || 0
  var cy = ev.clientY || 0
  var rect = getBoundingClientOffset(target)
  out[0] = cx - rect.left
  out[1] = cy - rect.top
  return out
}

function getBoundingClientOffset (element) {
  if (element === window ||
      element === document ||
      element === document.body) {
    return rootPosition
  } else {
    return element.getBoundingClientRect()
  }
}


/***/ }),

/***/ 7417:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! Native Promise Only
    v0.8.1 (c) Kyle Simpson
    MIT License: http://getify.mit-license.org
*/

(function UMD(name,context,definition){
	// special form of UMD for polyfilling across evironments
	context[name] = context[name] || definition();
	if ( true && module.exports) { module.exports = context[name]; }
	else if (true) { !(__WEBPACK_AMD_DEFINE_RESULT__ = (function $AMD$(){ return context[name]; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); }
})("Promise",typeof __webpack_require__.g != "undefined" ? __webpack_require__.g : this,function DEF(){
	/*jshint validthis:true */
	"use strict";

	var builtInProp, cycle, scheduling_queue,
		ToString = Object.prototype.toString,
		timer = (typeof setImmediate != "undefined") ?
			function timer(fn) { return setImmediate(fn); } :
			setTimeout
	;

	// dammit, IE8.
	try {
		Object.defineProperty({},"x",{});
		builtInProp = function builtInProp(obj,name,val,config) {
			return Object.defineProperty(obj,name,{
				value: val,
				writable: true,
				configurable: config !== false
			});
		};
	}
	catch (err) {
		builtInProp = function builtInProp(obj,name,val) {
			obj[name] = val;
			return obj;
		};
	}

	// Note: using a queue instead of array for efficiency
	scheduling_queue = (function Queue() {
		var first, last, item;

		function Item(fn,self) {
			this.fn = fn;
			this.self = self;
			this.next = void 0;
		}

		return {
			add: function add(fn,self) {
				item = new Item(fn,self);
				if (last) {
					last.next = item;
				}
				else {
					first = item;
				}
				last = item;
				item = void 0;
			},
			drain: function drain() {
				var f = first;
				first = last = cycle = void 0;

				while (f) {
					f.fn.call(f.self);
					f = f.next;
				}
			}
		};
	})();

	function schedule(fn,self) {
		scheduling_queue.add(fn,self);
		if (!cycle) {
			cycle = timer(scheduling_queue.drain);
		}
	}

	// promise duck typing
	function isThenable(o) {
		var _then, o_type = typeof o;

		if (o != null &&
			(
				o_type == "object" || o_type == "function"
			)
		) {
			_then = o.then;
		}
		return typeof _then == "function" ? _then : false;
	}

	function notify() {
		for (var i=0; i<this.chain.length; i++) {
			notifyIsolated(
				this,
				(this.state === 1) ? this.chain[i].success : this.chain[i].failure,
				this.chain[i]
			);
		}
		this.chain.length = 0;
	}

	// NOTE: This is a separate function to isolate
	// the `try..catch` so that other code can be
	// optimized better
	function notifyIsolated(self,cb,chain) {
		var ret, _then;
		try {
			if (cb === false) {
				chain.reject(self.msg);
			}
			else {
				if (cb === true) {
					ret = self.msg;
				}
				else {
					ret = cb.call(void 0,self.msg);
				}

				if (ret === chain.promise) {
					chain.reject(TypeError("Promise-chain cycle"));
				}
				else if (_then = isThenable(ret)) {
					_then.call(ret,chain.resolve,chain.reject);
				}
				else {
					chain.resolve(ret);
				}
			}
		}
		catch (err) {
			chain.reject(err);
		}
	}

	function resolve(msg) {
		var _then, self = this;

		// already triggered?
		if (self.triggered) { return; }

		self.triggered = true;

		// unwrap
		if (self.def) {
			self = self.def;
		}

		try {
			if (_then = isThenable(msg)) {
				schedule(function(){
					var def_wrapper = new MakeDefWrapper(self);
					try {
						_then.call(msg,
							function $resolve$(){ resolve.apply(def_wrapper,arguments); },
							function $reject$(){ reject.apply(def_wrapper,arguments); }
						);
					}
					catch (err) {
						reject.call(def_wrapper,err);
					}
				})
			}
			else {
				self.msg = msg;
				self.state = 1;
				if (self.chain.length > 0) {
					schedule(notify,self);
				}
			}
		}
		catch (err) {
			reject.call(new MakeDefWrapper(self),err);
		}
	}

	function reject(msg) {
		var self = this;

		// already triggered?
		if (self.triggered) { return; }

		self.triggered = true;

		// unwrap
		if (self.def) {
			self = self.def;
		}

		self.msg = msg;
		self.state = 2;
		if (self.chain.length > 0) {
			schedule(notify,self);
		}
	}

	function iteratePromises(Constructor,arr,resolver,rejecter) {
		for (var idx=0; idx<arr.length; idx++) {
			(function IIFE(idx){
				Constructor.resolve(arr[idx])
				.then(
					function $resolver$(msg){
						resolver(idx,msg);
					},
					rejecter
				);
			})(idx);
		}
	}

	function MakeDefWrapper(self) {
		this.def = self;
		this.triggered = false;
	}

	function MakeDef(self) {
		this.promise = self;
		this.state = 0;
		this.triggered = false;
		this.chain = [];
		this.msg = void 0;
	}

	function Promise(executor) {
		if (typeof executor != "function") {
			throw TypeError("Not a function");
		}

		if (this.__NPO__ !== 0) {
			throw TypeError("Not a promise");
		}

		// instance shadowing the inherited "brand"
		// to signal an already "initialized" promise
		this.__NPO__ = 1;

		var def = new MakeDef(this);

		this["then"] = function then(success,failure) {
			var o = {
				success: typeof success == "function" ? success : true,
				failure: typeof failure == "function" ? failure : false
			};
			// Note: `then(..)` itself can be borrowed to be used against
			// a different promise constructor for making the chained promise,
			// by substituting a different `this` binding.
			o.promise = new this.constructor(function extractChain(resolve,reject) {
				if (typeof resolve != "function" || typeof reject != "function") {
					throw TypeError("Not a function");
				}

				o.resolve = resolve;
				o.reject = reject;
			});
			def.chain.push(o);

			if (def.state !== 0) {
				schedule(notify,def);
			}

			return o.promise;
		};
		this["catch"] = function $catch$(failure) {
			return this.then(void 0,failure);
		};

		try {
			executor.call(
				void 0,
				function publicResolve(msg){
					resolve.call(def,msg);
				},
				function publicReject(msg) {
					reject.call(def,msg);
				}
			);
		}
		catch (err) {
			reject.call(def,err);
		}
	}

	var PromisePrototype = builtInProp({},"constructor",Promise,
		/*configurable=*/false
	);

	// Note: Android 4 cannot use `Object.defineProperty(..)` here
	Promise.prototype = PromisePrototype;

	// built-in "brand" to signal an "uninitialized" promise
	builtInProp(PromisePrototype,"__NPO__",0,
		/*configurable=*/false
	);

	builtInProp(Promise,"resolve",function Promise$resolve(msg) {
		var Constructor = this;

		// spec mandated checks
		// note: best "isPromise" check that's practical for now
		if (msg && typeof msg == "object" && msg.__NPO__ === 1) {
			return msg;
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			resolve(msg);
		});
	});

	builtInProp(Promise,"reject",function Promise$reject(msg) {
		return new this(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			reject(msg);
		});
	});

	builtInProp(Promise,"all",function Promise$all(arr) {
		var Constructor = this;

		// spec mandated checks
		if (ToString.call(arr) != "[object Array]") {
			return Constructor.reject(TypeError("Not an array"));
		}
		if (arr.length === 0) {
			return Constructor.resolve([]);
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			var len = arr.length, msgs = Array(len), count = 0;

			iteratePromises(Constructor,arr,function resolver(idx,msg) {
				msgs[idx] = msg;
				if (++count === len) {
					resolve(msgs);
				}
			},reject);
		});
	});

	builtInProp(Promise,"race",function Promise$race(arr) {
		var Constructor = this;

		// spec mandated checks
		if (ToString.call(arr) != "[object Array]") {
			return Constructor.reject(TypeError("Not an array"));
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			iteratePromises(Constructor,arr,function resolver(idx,msg){
				resolve(msg);
			},reject);
		});
	});

	return Promise;
});


/***/ }),

/***/ 6131:
/***/ (function(module) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ 5616:
/***/ (function(module) {


module.exports = parse

/**
 * expected argument lengths
 * @type {Object}
 */

var length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}

/**
 * segment pattern
 * @type {RegExp}
 */

var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig

/**
 * parse an svg path data string. Generates an Array
 * of commands where each command is an Array of the
 * form `[command, arg1, arg2, ...]`
 *
 * @param {String} path
 * @return {Array}
 */

function parse(path) {
	var data = []
	path.replace(segment, function(_, command, args){
		var type = command.toLowerCase()
		args = parseValues(args)

		// overloaded moveTo
		if (type == 'm' && args.length > 2) {
			data.push([command].concat(args.splice(0, 2)))
			type = 'l'
			command = command == 'm' ? 'l' : 'L'
		}

		while (true) {
			if (args.length == length[type]) {
				args.unshift(command)
				return data.push(args)
			}
			if (args.length < length[type]) throw new Error('malformed path data')
			data.push([command].concat(args.splice(0, length[type])))
		}
	})
	return data
}

var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig

function parseValues(args) {
	var numbers = args.match(number)
	return numbers ? numbers.map(Number) : []
}


/***/ }),

/***/ 8258:
/***/ (function(module) {

// ray-casting algorithm based on
// https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html

module.exports = function pointInPolygonNested (point, vs, start, end) {
    var x = point[0], y = point[1];
    var inside = false;
    if (start === undefined) start = 0;
    if (end === undefined) end = vs.length;
    var len = end - start;
    for (var i = 0, j = len - 1; i < len; j = i++) {
        var xi = vs[i+start][0], yi = vs[i+start][1];
        var xj = vs[j+start][0], yj = vs[j+start][1];
        var intersect = ((yi > y) !== (yj > y))
            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
};


/***/ }),

/***/ 2142:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
 * @copyright 2016 Sean Connelly (@voidqk), http://syntheti.cc
 * @license MIT
 * @preserve Project Home: https://github.com/voidqk/polybooljs
 */

var BuildLog = __webpack_require__(9444);
var Epsilon = __webpack_require__(9023);
var Intersecter = __webpack_require__(7263);
var SegmentChainer = __webpack_require__(1328);
var SegmentSelector = __webpack_require__(5968);
var GeoJSON = __webpack_require__(670);

var buildLog = false;
var epsilon = Epsilon();

var PolyBool;
PolyBool = {
	// getter/setter for buildLog
	buildLog: function(bl){
		if (bl === true)
			buildLog = BuildLog();
		else if (bl === false)
			buildLog = false;
		return buildLog === false ? false : buildLog.list;
	},
	// getter/setter for epsilon
	epsilon: function(v){
		return epsilon.epsilon(v);
	},

	// core API
	segments: function(poly){
		var i = Intersecter(true, epsilon, buildLog);
		poly.regions.forEach(i.addRegion);
		return {
			segments: i.calculate(poly.inverted),
			inverted: poly.inverted
		};
	},
	combine: function(segments1, segments2){
		var i3 = Intersecter(false, epsilon, buildLog);
		return {
			combined: i3.calculate(
				segments1.segments, segments1.inverted,
				segments2.segments, segments2.inverted
			),
			inverted1: segments1.inverted,
			inverted2: segments2.inverted
		};
	},
	selectUnion: function(combined){
		return {
			segments: SegmentSelector.union(combined.combined, buildLog),
			inverted: combined.inverted1 || combined.inverted2
		}
	},
	selectIntersect: function(combined){
		return {
			segments: SegmentSelector.intersect(combined.combined, buildLog),
			inverted: combined.inverted1 && combined.inverted2
		}
	},
	selectDifference: function(combined){
		return {
			segments: SegmentSelector.difference(combined.combined, buildLog),
			inverted: combined.inverted1 && !combined.inverted2
		}
	},
	selectDifferenceRev: function(combined){
		return {
			segments: SegmentSelector.differenceRev(combined.combined, buildLog),
			inverted: !combined.inverted1 && combined.inverted2
		}
	},
	selectXor: function(combined){
		return {
			segments: SegmentSelector.xor(combined.combined, buildLog),
			inverted: combined.inverted1 !== combined.inverted2
		}
	},
	polygon: function(segments){
		return {
			regions: SegmentChainer(segments.segments, epsilon, buildLog),
			inverted: segments.inverted
		};
	},

	// GeoJSON converters
	polygonFromGeoJSON: function(geojson){
		return GeoJSON.toPolygon(PolyBool, geojson);
	},
	polygonToGeoJSON: function(poly){
		return GeoJSON.fromPolygon(PolyBool, epsilon, poly);
	},

	// helper functions for common operations
	union: function(poly1, poly2){
		return operate(poly1, poly2, PolyBool.selectUnion);
	},
	intersect: function(poly1, poly2){
		return operate(poly1, poly2, PolyBool.selectIntersect);
	},
	difference: function(poly1, poly2){
		return operate(poly1, poly2, PolyBool.selectDifference);
	},
	differenceRev: function(poly1, poly2){
		return operate(poly1, poly2, PolyBool.selectDifferenceRev);
	},
	xor: function(poly1, poly2){
		return operate(poly1, poly2, PolyBool.selectXor);
	}
};

function operate(poly1, poly2, selector){
	var seg1 = PolyBool.segments(poly1);
	var seg2 = PolyBool.segments(poly2);
	var comb = PolyBool.combine(seg1, seg2);
	var seg3 = selector(comb);
	return PolyBool.polygon(seg3);
}

if (typeof window === 'object')
	window.PolyBool = PolyBool;

module.exports = PolyBool;


/***/ }),

/***/ 9444:
/***/ (function(module) {

// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc
// MIT License
// Project Home: https://github.com/voidqk/polybooljs

//
// used strictly for logging the processing of the algorithm... only useful if you intend on
// looking under the covers (for pretty UI's or debugging)
//

function BuildLog(){
	var my;
	var nextSegmentId = 0;
	var curVert = false;

	function push(type, data){
		my.list.push({
			type: type,
			data: data ? JSON.parse(JSON.stringify(data)) : void 0
		});
		return my;
	}

	my = {
		list: [],
		segmentId: function(){
			return nextSegmentId++;
		},
		checkIntersection: function(seg1, seg2){
			return push('check', { seg1: seg1, seg2: seg2 });
		},
		segmentChop: function(seg, end){
			push('div_seg', { seg: seg, pt: end });
			return push('chop', { seg: seg, pt: end });
		},
		statusRemove: function(seg){
			return push('pop_seg', { seg: seg });
		},
		segmentUpdate: function(seg){
			return push('seg_update', { seg: seg });
		},
		segmentNew: function(seg, primary){
			return push('new_seg', { seg: seg, primary: primary });
		},
		segmentRemove: function(seg){
			return push('rem_seg', { seg: seg });
		},
		tempStatus: function(seg, above, below){
			return push('temp_status', { seg: seg, above: above, below: below });
		},
		rewind: function(seg){
			return push('rewind', { seg: seg });
		},
		status: function(seg, above, below){
			return push('status', { seg: seg, above: above, below: below });
		},
		vert: function(x){
			if (x === curVert)
				return my;
			curVert = x;
			return push('vert', { x: x });
		},
		log: function(data){
			if (typeof data !== 'string')
				data = JSON.stringify(data, false, '  ');
			return push('log', { txt: data });
		},
		reset: function(){
			return push('reset');
		},
		selected: function(segs){
			return push('selected', { segs: segs });
		},
		chainStart: function(seg){
			return push('chain_start', { seg: seg });
		},
		chainRemoveHead: function(index, pt){
			return push('chain_rem_head', { index: index, pt: pt });
		},
		chainRemoveTail: function(index, pt){
			return push('chain_rem_tail', { index: index, pt: pt });
		},
		chainNew: function(pt1, pt2){
			return push('chain_new', { pt1: pt1, pt2: pt2 });
		},
		chainMatch: function(index){
			return push('chain_match', { index: index });
		},
		chainClose: function(index){
			return push('chain_close', { index: index });
		},
		chainAddHead: function(index, pt){
			return push('chain_add_head', { index: index, pt: pt });
		},
		chainAddTail: function(index, pt){
			return push('chain_add_tail', { index: index, pt: pt, });
		},
		chainConnect: function(index1, index2){
			return push('chain_con', { index1: index1, index2: index2 });
		},
		chainReverse: function(index){
			return push('chain_rev', { index: index });
		},
		chainJoin: function(index1, index2){
			return push('chain_join', { index1: index1, index2: index2 });
		},
		done: function(){
			return push('done');
		}
	};
	return my;
}

module.exports = BuildLog;


/***/ }),

/***/ 9023:
/***/ (function(module) {

// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc
// MIT License
// Project Home: https://github.com/voidqk/polybooljs

//
// provides the raw computation functions that takes epsilon into account
//
// zero is defined to be between (-epsilon, epsilon) exclusive
//

function Epsilon(eps){
	if (typeof eps !== 'number')
		eps = 0.0000000001; // sane default? sure why not
	var my = {
		epsilon: function(v){
			if (typeof v === 'number')
				eps = v;
			return eps;
		},
		pointAboveOrOnLine: function(pt, left, right){
			var Ax = left[0];
			var Ay = left[1];
			var Bx = right[0];
			var By = right[1];
			var Cx = pt[0];
			var Cy = pt[1];
			return (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax) >= -eps;
		},
		pointBetween: function(p, left, right){
			// p must be collinear with left->right
			// returns false if p == left, p == right, or left == right
			var d_py_ly = p[1] - left[1];
			var d_rx_lx = right[0] - left[0];
			var d_px_lx = p[0] - left[0];
			var d_ry_ly = right[1] - left[1];

			var dot = d_px_lx * d_rx_lx + d_py_ly * d_ry_ly;
			// if `dot` is 0, then `p` == `left` or `left` == `right` (reject)
			// if `dot` is less than 0, then `p` is to the left of `left` (reject)
			if (dot < eps)
				return false;

			var sqlen = d_rx_lx * d_rx_lx + d_ry_ly * d_ry_ly;
			// if `dot` > `sqlen`, then `p` is to the right of `right` (reject)
			// therefore, if `dot - sqlen` is greater than 0, then `p` is to the right of `right` (reject)
			if (dot - sqlen > -eps)
				return false;

			return true;
		},
		pointsSameX: function(p1, p2){
			return Math.abs(p1[0] - p2[0]) < eps;
		},
		pointsSameY: function(p1, p2){
			return Math.abs(p1[1] - p2[1]) < eps;
		},
		pointsSame: function(p1, p2){
			return my.pointsSameX(p1, p2) && my.pointsSameY(p1, p2);
		},
		pointsCompare: function(p1, p2){
			// returns -1 if p1 is smaller, 1 if p2 is smaller, 0 if equal
			if (my.pointsSameX(p1, p2))
				return my.pointsSameY(p1, p2) ? 0 : (p1[1] < p2[1] ? -1 : 1);
			return p1[0] < p2[0] ? -1 : 1;
		},
		pointsCollinear: function(pt1, pt2, pt3){
			// does pt1->pt2->pt3 make a straight line?
			// essentially this is just checking to see if the slope(pt1->pt2) === slope(pt2->pt3)
			// if slopes are equal, then they must be collinear, because they share pt2
			var dx1 = pt1[0] - pt2[0];
			var dy1 = pt1[1] - pt2[1];
			var dx2 = pt2[0] - pt3[0];
			var dy2 = pt2[1] - pt3[1];
			return Math.abs(dx1 * dy2 - dx2 * dy1) < eps;
		},
		linesIntersect: function(a0, a1, b0, b1){
			// returns false if the lines are coincident (e.g., parallel or on top of each other)
			//
			// returns an object if the lines intersect:
			//   {
			//     pt: [x, y],    where the intersection point is at
			//     alongA: where intersection point is along A,
			//     alongB: where intersection point is along B
			//   }
			//
			//  alongA and alongB will each be one of: -2, -1, 0, 1, 2
			//
			//  with the following meaning:
			//
			//    -2   intersection point is before segment's first point
			//    -1   intersection point is directly on segment's first point
			//     0   intersection point is between segment's first and second points (exclusive)
			//     1   intersection point is directly on segment's second point
			//     2   intersection point is after segment's second point
			var adx = a1[0] - a0[0];
			var ady = a1[1] - a0[1];
			var bdx = b1[0] - b0[0];
			var bdy = b1[1] - b0[1];

			var axb = adx * bdy - ady * bdx;
			if (Math.abs(axb) < eps)
				return false; // lines are coincident

			var dx = a0[0] - b0[0];
			var dy = a0[1] - b0[1];

			var A = (bdx * dy - bdy * dx) / axb;
			var B = (adx * dy - ady * dx) / axb;

			var ret = {
				alongA: 0,
				alongB: 0,
				pt: [
					a0[0] + A * adx,
					a0[1] + A * ady
				]
			};

			// categorize where intersection point is along A and B

			if (A <= -eps)
				ret.alongA = -2;
			else if (A < eps)
				ret.alongA = -1;
			else if (A - 1 <= -eps)
				ret.alongA = 0;
			else if (A - 1 < eps)
				ret.alongA = 1;
			else
				ret.alongA = 2;

			if (B <= -eps)
				ret.alongB = -2;
			else if (B < eps)
				ret.alongB = -1;
			else if (B - 1 <= -eps)
				ret.alongB = 0;
			else if (B - 1 < eps)
				ret.alongB = 1;
			else
				ret.alongB = 2;

			return ret;
		},
		pointInsideRegion: function(pt, region){
			var x = pt[0];
			var y = pt[1];
			var last_x = region[region.length - 1][0];
			var last_y = region[region.length - 1][1];
			var inside = false;
			for (var i = 0; i < region.length; i++){
				var curr_x = region[i][0];
				var curr_y = region[i][1];

				// if y is between curr_y and last_y, and
				// x is to the right of the boundary created by the line
				if ((curr_y - y > eps) != (last_y - y > eps) &&
					(last_x - curr_x) * (y - curr_y) / (last_y - curr_y) + curr_x - x > eps)
					inside = !inside

				last_x = curr_x;
				last_y = curr_y;
			}
			return inside;
		}
	};
	return my;
}

module.exports = Epsilon;


/***/ }),

/***/ 670:
/***/ (function(module) {

// (c) Copyright 2017, Sean Connelly (@voidqk), http://syntheti.cc
// MIT License
// Project Home: https://github.com/voidqk/polybooljs

//
// convert between PolyBool polygon format and GeoJSON formats (Polygon and MultiPolygon)
//

var GeoJSON = {
	// convert a GeoJSON object to a PolyBool polygon
	toPolygon: function(PolyBool, geojson){

		// converts list of LineString's to segments
		function GeoPoly(coords){
			// check for empty coords
			if (coords.length <= 0)
				return PolyBool.segments({ inverted: false, regions: [] });

			// convert LineString to segments
			function LineString(ls){
				// remove tail which should be the same as head
				var reg = ls.slice(0, ls.length - 1);
				return PolyBool.segments({ inverted: false, regions: [reg] });
			}

			// the first LineString is considered the outside
			var out = LineString(coords[0]);

			// the rest of the LineStrings are considered interior holes, so subtract them from the
			// current result
			for (var i = 1; i < coords.length; i++)
				out = PolyBool.selectDifference(PolyBool.combine(out, LineString(coords[i])));

			return out;
		}

		if (geojson.type === 'Polygon'){
			// single polygon, so just convert it and we're done
			return PolyBool.polygon(GeoPoly(geojson.coordinates));
		}
		else if (geojson.type === 'MultiPolygon'){
			// multiple polygons, so union all the polygons together
			var out = PolyBool.segments({ inverted: false, regions: [] });
			for (var i = 0; i < geojson.coordinates.length; i++)
				out = PolyBool.selectUnion(PolyBool.combine(out, GeoPoly(geojson.coordinates[i])));
			return PolyBool.polygon(out);
		}
		throw new Error('PolyBool: Cannot convert GeoJSON object to PolyBool polygon');
	},

	// convert a PolyBool polygon to a GeoJSON object
	fromPolygon: function(PolyBool, eps, poly){
		// make sure out polygon is clean
		poly = PolyBool.polygon(PolyBool.segments(poly));

		// test if r1 is inside r2
		function regionInsideRegion(r1, r2){
			// we're guaranteed no lines intersect (because the polygon is clean), but a vertex
			// could be on the edge -- so we just average pt[0] and pt[1] to produce a point on the
			// edge of the first line, which cannot be on an edge
			return eps.pointInsideRegion([
				(r1[0][0] + r1[1][0]) * 0.5,
				(r1[0][1] + r1[1][1]) * 0.5
			], r2);
		}

		// calculate inside heirarchy
		//
		//  _____________________   _______    roots -> A       -> F
		// |          A          | |   F   |            |          |
		// |  _______   _______  | |  ___  |            +-- B      +-- G
		// | |   B   | |   C   | | | |   | |            |   |
		// | |  ___  | |  ___  | | | |   | |            |   +-- D
		// | | | D | | | | E | | | | | G | |            |
		// | | |___| | | |___| | | | |   | |            +-- C
		// | |_______| |_______| | | |___| |                |
		// |_____________________| |_______|                +-- E

		function newNode(region){
			return {
				region: region,
				children: []
			};
		}

		var roots = newNode(null);

		function addChild(root, region){
			// first check if we're inside any children
			for (var i = 0; i < root.children.length; i++){
				var child = root.children[i];
				if (regionInsideRegion(region, child.region)){
					// we are, so insert inside them instead
					addChild(child, region);
					return;
				}
			}

			// not inside any children, so check to see if any children are inside us
			var node = newNode(region);
			for (var i = 0; i < root.children.length; i++){
				var child = root.children[i];
				if (regionInsideRegion(child.region, region)){
					// oops... move the child beneath us, and remove them from root
					node.children.push(child);
					root.children.splice(i, 1);
					i--;
				}
			}

			// now we can add ourselves
			root.children.push(node);
		}

		// add all regions to the root
		for (var i = 0; i < poly.regions.length; i++){
			var region = poly.regions[i];
			if (region.length < 3) // regions must have at least 3 points (sanity check)
				continue;
			addChild(roots, region);
		}

		// with our heirarchy, we can distinguish between exterior borders, and interior holes
		// the root nodes are exterior, children are interior, children's children are exterior,
		// children's children's children are interior, etc

		// while we're at it, exteriors are counter-clockwise, and interiors are clockwise

		function forceWinding(region, clockwise){
			// first, see if we're clockwise or counter-clockwise
			// https://en.wikipedia.org/wiki/Shoelace_formula
			var winding = 0;
			var last_x = region[region.length - 1][0];
			var last_y = region[region.length - 1][1];
			var copy = [];
			for (var i = 0; i < region.length; i++){
				var curr_x = region[i][0];
				var curr_y = region[i][1];
				copy.push([curr_x, curr_y]); // create a copy while we're at it
				winding += curr_y * last_x - curr_x * last_y;
				last_x = curr_x;
				last_y = curr_y;
			}
			// this assumes Cartesian coordinates (Y is positive going up)
			var isclockwise = winding < 0;
			if (isclockwise !== clockwise)
				copy.reverse();
			// while we're here, the last point must be the first point...
			copy.push([copy[0][0], copy[0][1]]);
			return copy;
		}

		var geopolys = [];

		function addExterior(node){
			var poly = [forceWinding(node.region, false)];
			geopolys.push(poly);
			// children of exteriors are interior
			for (var i = 0; i < node.children.length; i++)
				poly.push(getInterior(node.children[i]));
		}

		function getInterior(node){
			// children of interiors are exterior
			for (var i = 0; i < node.children.length; i++)
				addExterior(node.children[i]);
			// return the clockwise interior
			return forceWinding(node.region, true);
		}

		// root nodes are exterior
		for (var i = 0; i < roots.children.length; i++)
			addExterior(roots.children[i]);

		// lastly, construct the approrpriate GeoJSON object

		if (geopolys.length <= 0) // empty GeoJSON Polygon
			return { type: 'Polygon', coordinates: [] };
		if (geopolys.length == 1) // use a GeoJSON Polygon
			return { type: 'Polygon', coordinates: geopolys[0] };
		return { // otherwise, use a GeoJSON MultiPolygon
			type: 'MultiPolygon',
			coordinates: geopolys
		};
	}
};

module.exports = GeoJSON;


/***/ }),

/***/ 7263:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc
// MIT License
// Project Home: https://github.com/voidqk/polybooljs

//
// this is the core work-horse
//

var LinkedList = __webpack_require__(6859);

function Intersecter(selfIntersection, eps, buildLog){
	// selfIntersection is true/false depending on the phase of the overall algorithm

	//
	// segment creation
	//

	function segmentNew(start, end){
		return {
			id: buildLog ? buildLog.segmentId() : -1,
			start: start,
			end: end,
			myFill: {
				above: null, // is there fill above us?
				below: null  // is there fill below us?
			},
			otherFill: null
		};
	}

	function segmentCopy(start, end, seg){
		return {
			id: buildLog ? buildLog.segmentId() : -1,
			start: start,
			end: end,
			myFill: {
				above: seg.myFill.above,
				below: seg.myFill.below
			},
			otherFill: null
		};
	}

	//
	// event logic
	//

	var event_root = LinkedList.create();

	function eventCompare(p1_isStart, p1_1, p1_2, p2_isStart, p2_1, p2_2){
		// compare the selected points first
		var comp = eps.pointsCompare(p1_1, p2_1);
		if (comp !== 0)
			return comp;
		// the selected points are the same

		if (eps.pointsSame(p1_2, p2_2)) // if the non-selected points are the same too...
			return 0; // then the segments are equal

		if (p1_isStart !== p2_isStart) // if one is a start and the other isn't...
			return p1_isStart ? 1 : -1; // favor the one that isn't the start

		// otherwise, we'll have to calculate which one is below the other manually
		return eps.pointAboveOrOnLine(p1_2,
			p2_isStart ? p2_1 : p2_2, // order matters
			p2_isStart ? p2_2 : p2_1
		) ? 1 : -1;
	}

	function eventAdd(ev, other_pt){
		event_root.insertBefore(ev, function(here){
			// should ev be inserted before here?
			var comp = eventCompare(
				ev  .isStart, ev  .pt,      other_pt,
				here.isStart, here.pt, here.other.pt
			);
			return comp < 0;
		});
	}

	function eventAddSegmentStart(seg, primary){
		var ev_start = LinkedList.node({
			isStart: true,
			pt: seg.start,
			seg: seg,
			primary: primary,
			other: null,
			status: null
		});
		eventAdd(ev_start, seg.end);
		return ev_start;
	}

	function eventAddSegmentEnd(ev_start, seg, primary){
		var ev_end = LinkedList.node({
			isStart: false,
			pt: seg.end,
			seg: seg,
			primary: primary,
			other: ev_start,
			status: null
		});
		ev_start.other = ev_end;
		eventAdd(ev_end, ev_start.pt);
	}

	function eventAddSegment(seg, primary){
		var ev_start = eventAddSegmentStart(seg, primary);
		eventAddSegmentEnd(ev_start, seg, primary);
		return ev_start;
	}

	function eventUpdateEnd(ev, end){
		// slides an end backwards
		//   (start)------------(end)    to:
		//   (start)---(end)

		if (buildLog)
			buildLog.segmentChop(ev.seg, end);

		ev.other.remove();
		ev.seg.end = end;
		ev.other.pt = end;
		eventAdd(ev.other, ev.pt);
	}

	function eventDivide(ev, pt){
		var ns = segmentCopy(pt, ev.seg.end, ev.seg);
		eventUpdateEnd(ev, pt);
		return eventAddSegment(ns, ev.primary);
	}

	function calculate(primaryPolyInverted, secondaryPolyInverted){
		// if selfIntersection is true then there is no secondary polygon, so that isn't used

		//
		// status logic
		//

		var status_root = LinkedList.create();

		function statusCompare(ev1, ev2){
			var a1 = ev1.seg.start;
			var a2 = ev1.seg.end;
			var b1 = ev2.seg.start;
			var b2 = ev2.seg.end;

			if (eps.pointsCollinear(a1, b1, b2)){
				if (eps.pointsCollinear(a2, b1, b2))
					return 1;//eventCompare(true, a1, a2, true, b1, b2);
				return eps.pointAboveOrOnLine(a2, b1, b2) ? 1 : -1;
			}
			return eps.pointAboveOrOnLine(a1, b1, b2) ? 1 : -1;
		}

		function statusFindSurrounding(ev){
			return status_root.findTransition(function(here){
				var comp = statusCompare(ev, here.ev);
				return comp > 0;
			});
		}

		function checkIntersection(ev1, ev2){
			// returns the segment equal to ev1, or false if nothing equal

			var seg1 = ev1.seg;
			var seg2 = ev2.seg;
			var a1 = seg1.start;
			var a2 = seg1.end;
			var b1 = seg2.start;
			var b2 = seg2.end;

			if (buildLog)
				buildLog.checkIntersection(seg1, seg2);

			var i = eps.linesIntersect(a1, a2, b1, b2);

			if (i === false){
				// segments are parallel or coincident

				// if points aren't collinear, then the segments are parallel, so no intersections
				if (!eps.pointsCollinear(a1, a2, b1))
					return false;
				// otherwise, segments are on top of each other somehow (aka coincident)

				if (eps.pointsSame(a1, b2) || eps.pointsSame(a2, b1))
					return false; // segments touch at endpoints... no intersection

				var a1_equ_b1 = eps.pointsSame(a1, b1);
				var a2_equ_b2 = eps.pointsSame(a2, b2);

				if (a1_equ_b1 && a2_equ_b2)
					return ev2; // segments are exactly equal

				var a1_between = !a1_equ_b1 && eps.pointBetween(a1, b1, b2);
				var a2_between = !a2_equ_b2 && eps.pointBetween(a2, b1, b2);

				// handy for debugging:
				// buildLog.log({
				//	a1_equ_b1: a1_equ_b1,
				//	a2_equ_b2: a2_equ_b2,
				//	a1_between: a1_between,
				//	a2_between: a2_between
				// });

				if (a1_equ_b1){
					if (a2_between){
						//  (a1)---(a2)
						//  (b1)----------(b2)
						eventDivide(ev2, a2);
					}
					else{
						//  (a1)----------(a2)
						//  (b1)---(b2)
						eventDivide(ev1, b2);
					}
					return ev2;
				}
				else if (a1_between){
					if (!a2_equ_b2){
						// make a2 equal to b2
						if (a2_between){
							//         (a1)---(a2)
							//  (b1)-----------------(b2)
							eventDivide(ev2, a2);
						}
						else{
							//         (a1)----------(a2)
							//  (b1)----------(b2)
							eventDivide(ev1, b2);
						}
					}

					//         (a1)---(a2)
					//  (b1)----------(b2)
					eventDivide(ev2, a1);
				}
			}
			else{
				// otherwise, lines intersect at i.pt, which may or may not be between the endpoints

				// is A divided between its endpoints? (exclusive)
				if (i.alongA === 0){
					if (i.alongB === -1) // yes, at exactly b1
						eventDivide(ev1, b1);
					else if (i.alongB === 0) // yes, somewhere between B's endpoints
						eventDivide(ev1, i.pt);
					else if (i.alongB === 1) // yes, at exactly b2
						eventDivide(ev1, b2);
				}

				// is B divided between its endpoints? (exclusive)
				if (i.alongB === 0){
					if (i.alongA === -1) // yes, at exactly a1
						eventDivide(ev2, a1);
					else if (i.alongA === 0) // yes, somewhere between A's endpoints (exclusive)
						eventDivide(ev2, i.pt);
					else if (i.alongA === 1) // yes, at exactly a2
						eventDivide(ev2, a2);
				}
			}
			return false;
		}

		//
		// main event loop
		//
		var segments = [];
		while (!event_root.isEmpty()){
			var ev = event_root.getHead();

			if (buildLog)
				buildLog.vert(ev.pt[0]);

			if (ev.isStart){

				if (buildLog)
					buildLog.segmentNew(ev.seg, ev.primary);

				var surrounding = statusFindSurrounding(ev);
				var above = surrounding.before ? surrounding.before.ev : null;
				var below = surrounding.after ? surrounding.after.ev : null;

				if (buildLog){
					buildLog.tempStatus(
						ev.seg,
						above ? above.seg : false,
						below ? below.seg : false
					);
				}

				function checkBothIntersections(){
					if (above){
						var eve = checkIntersection(ev, above);
						if (eve)
							return eve;
					}
					if (below)
						return checkIntersection(ev, below);
					return false;
				}

				var eve = checkBothIntersections();
				if (eve){
					// ev and eve are equal
					// we'll keep eve and throw away ev

					// merge ev.seg's fill information into eve.seg

					if (selfIntersection){
						var toggle; // are we a toggling edge?
						if (ev.seg.myFill.below === null)
							toggle = true;
						else
							toggle = ev.seg.myFill.above !== ev.seg.myFill.below;

						// merge two segments that belong to the same polygon
						// think of this as sandwiching two segments together, where `eve.seg` is
						// the bottom -- this will cause the above fill flag to toggle
						if (toggle)
							eve.seg.myFill.above = !eve.seg.myFill.above;
					}
					else{
						// merge two segments that belong to different polygons
						// each segment has distinct knowledge, so no special logic is needed
						// note that this can only happen once per segment in this phase, because we
						// are guaranteed that all self-intersections are gone
						eve.seg.otherFill = ev.seg.myFill;
					}

					if (buildLog)
						buildLog.segmentUpdate(eve.seg);

					ev.other.remove();
					ev.remove();
				}

				if (event_root.getHead() !== ev){
					// something was inserted before us in the event queue, so loop back around and
					// process it before continuing
					if (buildLog)
						buildLog.rewind(ev.seg);
					continue;
				}

				//
				// calculate fill flags
				//
				if (selfIntersection){
					var toggle; // are we a toggling edge?
					if (ev.seg.myFill.below === null) // if we are a new segment...
						toggle = true; // then we toggle
					else // we are a segment that has previous knowledge from a division
						toggle = ev.seg.myFill.above !== ev.seg.myFill.below; // calculate toggle

					// next, calculate whether we are filled below us
					if (!below){ // if nothing is below us...
						// we are filled below us if the polygon is inverted
						ev.seg.myFill.below = primaryPolyInverted;
					}
					else{
						// otherwise, we know the answer -- it's the same if whatever is below
						// us is filled above it
						ev.seg.myFill.below = below.seg.myFill.above;
					}

					// since now we know if we're filled below us, we can calculate whether
					// we're filled above us by applying toggle to whatever is below us
					if (toggle)
						ev.seg.myFill.above = !ev.seg.myFill.below;
					else
						ev.seg.myFill.above = ev.seg.myFill.below;
				}
				else{
					// now we fill in any missing transition information, since we are all-knowing
					// at this point

					if (ev.seg.otherFill === null){
						// if we don't have other information, then we need to figure out if we're
						// inside the other polygon
						var inside;
						if (!below){
							// if nothing is below us, then we're inside if the other polygon is
							// inverted
							inside =
								ev.primary ? secondaryPolyInverted : primaryPolyInverted;
						}
						else{ // otherwise, something is below us
							// so copy the below segment's other polygon's above
							if (ev.primary === below.primary)
								inside = below.seg.otherFill.above;
							else
								inside = below.seg.myFill.above;
						}
						ev.seg.otherFill = {
							above: inside,
							below: inside
						};
					}
				}

				if (buildLog){
					buildLog.status(
						ev.seg,
						above ? above.seg : false,
						below ? below.seg : false
					);
				}

				// insert the status and remember it for later removal
				ev.other.status = surrounding.insert(LinkedList.node({ ev: ev }));
			}
			else{
				var st = ev.status;

				if (st === null){
					throw new Error('PolyBool: Zero-length segment detected; your epsilon is ' +
						'probably too small or too large');
				}

				// removing the status will create two new adjacent edges, so we'll need to check
				// for those
				if (status_root.exists(st.prev) && status_root.exists(st.next))
					checkIntersection(st.prev.ev, st.next.ev);

				if (buildLog)
					buildLog.statusRemove(st.ev.seg);

				// remove the status
				st.remove();

				// if we've reached this point, we've calculated everything there is to know, so
				// save the segment for reporting
				if (!ev.primary){
					// make sure `seg.myFill` actually points to the primary polygon though
					var s = ev.seg.myFill;
					ev.seg.myFill = ev.seg.otherFill;
					ev.seg.otherFill = s;
				}
				segments.push(ev.seg);
			}

			// remove the event and continue
			event_root.getHead().remove();
		}

		if (buildLog)
			buildLog.done();

		return segments;
	}

	// return the appropriate API depending on what we're doing
	if (!selfIntersection){
		// performing combination of polygons, so only deal with already-processed segments
		return {
			calculate: function(segments1, inverted1, segments2, inverted2){
				// segmentsX come from the self-intersection API, or this API
				// invertedX is whether we treat that list of segments as an inverted polygon or not
				// returns segments that can be used for further operations
				segments1.forEach(function(seg){
					eventAddSegment(segmentCopy(seg.start, seg.end, seg), true);
				});
				segments2.forEach(function(seg){
					eventAddSegment(segmentCopy(seg.start, seg.end, seg), false);
				});
				return calculate(inverted1, inverted2);
			}
		};
	}

	// otherwise, performing self-intersection, so deal with regions
	return {
		addRegion: function(region){
			// regions are a list of points:
			//  [ [0, 0], [100, 0], [50, 100] ]
			// you can add multiple regions before running calculate
			var pt1;
			var pt2 = region[region.length - 1];
			for (var i = 0; i < region.length; i++){
				pt1 = pt2;
				pt2 = region[i];

				var forward = eps.pointsCompare(pt1, pt2);
				if (forward === 0) // points are equal, so we have a zero-length segment
					continue; // just skip it

				eventAddSegment(
					segmentNew(
						forward < 0 ? pt1 : pt2,
						forward < 0 ? pt2 : pt1
					),
					true
				);
			}
		},
		calculate: function(inverted){
			// is the polygon inverted?
			// returns segments
			return calculate(inverted, false);
		}
	};
}

module.exports = Intersecter;


/***/ }),

/***/ 6859:
/***/ (function(module) {

// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc
// MIT License
// Project Home: https://github.com/voidqk/polybooljs

//
// simple linked list implementation that allows you to traverse down nodes and save positions
//

var LinkedList = {
	create: function(){
		var my = {
			root: { root: true, next: null },
			exists: function(node){
				if (node === null || node === my.root)
					return false;
				return true;
			},
			isEmpty: function(){
				return my.root.next === null;
			},
			getHead: function(){
				return my.root.next;
			},
			insertBefore: function(node, check){
				var last = my.root;
				var here = my.root.next;
				while (here !== null){
					if (check(here)){
						node.prev = here.prev;
						node.next = here;
						here.prev.next = node;
						here.prev = node;
						return;
					}
					last = here;
					here = here.next;
				}
				last.next = node;
				node.prev = last;
				node.next = null;
			},
			findTransition: function(check){
				var prev = my.root;
				var here = my.root.next;
				while (here !== null){
					if (check(here))
						break;
					prev = here;
					here = here.next;
				}
				return {
					before: prev === my.root ? null : prev,
					after: here,
					insert: function(node){
						node.prev = prev;
						node.next = here;
						prev.next = node;
						if (here !== null)
							here.prev = node;
						return node;
					}
				};
			}
		};
		return my;
	},
	node: function(data){
		data.prev = null;
		data.next = null;
		data.remove = function(){
			data.prev.next = data.next;
			if (data.next)
				data.next.prev = data.prev;
			data.prev = null;
			data.next = null;
		};
		return data;
	}
};

module.exports = LinkedList;


/***/ }),

/***/ 1328:
/***/ (function(module) {

// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc
// MIT License
// Project Home: https://github.com/voidqk/polybooljs

//
// converts a list of segments into a list of regions, while also removing unnecessary verticies
//

function SegmentChainer(segments, eps, buildLog){
	var chains = [];
	var regions = [];

	segments.forEach(function(seg){
		var pt1 = seg.start;
		var pt2 = seg.end;
		if (eps.pointsSame(pt1, pt2)){
			console.warn('PolyBool: Warning: Zero-length segment detected; your epsilon is ' +
				'probably too small or too large');
			return;
		}

		if (buildLog)
			buildLog.chainStart(seg);

		// search for two chains that this segment matches
		var first_match = {
			index: 0,
			matches_head: false,
			matches_pt1: false
		};
		var second_match = {
			index: 0,
			matches_head: false,
			matches_pt1: false
		};
		var next_match = first_match;
		function setMatch(index, matches_head, matches_pt1){
			// return true if we've matched twice
			next_match.index = index;
			next_match.matches_head = matches_head;
			next_match.matches_pt1 = matches_pt1;
			if (next_match === first_match){
				next_match = second_match;
				return false;
			}
			next_match = null;
			return true; // we've matched twice, we're done here
		}
		for (var i = 0; i < chains.length; i++){
			var chain = chains[i];
			var head  = chain[0];
			var head2 = chain[1];
			var tail  = chain[chain.length - 1];
			var tail2 = chain[chain.length - 2];
			if (eps.pointsSame(head, pt1)){
				if (setMatch(i, true, true))
					break;
			}
			else if (eps.pointsSame(head, pt2)){
				if (setMatch(i, true, false))
					break;
			}
			else if (eps.pointsSame(tail, pt1)){
				if (setMatch(i, false, true))
					break;
			}
			else if (eps.pointsSame(tail, pt2)){
				if (setMatch(i, false, false))
					break;
			}
		}

		if (next_match === first_match){
			// we didn't match anything, so create a new chain
			chains.push([ pt1, pt2 ]);
			if (buildLog)
				buildLog.chainNew(pt1, pt2);
			return;
		}

		if (next_match === second_match){
			// we matched a single chain

			if (buildLog)
				buildLog.chainMatch(first_match.index);

			// add the other point to the apporpriate end, and check to see if we've closed the
			// chain into a loop

			var index = first_match.index;
			var pt = first_match.matches_pt1 ? pt2 : pt1; // if we matched pt1, then we add pt2, etc
			var addToHead = first_match.matches_head; // if we matched at head, then add to the head

			var chain = chains[index];
			var grow  = addToHead ? chain[0] : chain[chain.length - 1];
			var grow2 = addToHead ? chain[1] : chain[chain.length - 2];
			var oppo  = addToHead ? chain[chain.length - 1] : chain[0];
			var oppo2 = addToHead ? chain[chain.length - 2] : chain[1];

			if (eps.pointsCollinear(grow2, grow, pt)){
				// grow isn't needed because it's directly between grow2 and pt:
				// grow2 ---grow---> pt
				if (addToHead){
					if (buildLog)
						buildLog.chainRemoveHead(first_match.index, pt);
					chain.shift();
				}
				else{
					if (buildLog)
						buildLog.chainRemoveTail(first_match.index, pt);
					chain.pop();
				}
				grow = grow2; // old grow is gone... new grow is what grow2 was
			}

			if (eps.pointsSame(oppo, pt)){
				// we're closing the loop, so remove chain from chains
				chains.splice(index, 1);

				if (eps.pointsCollinear(oppo2, oppo, grow)){
					// oppo isn't needed because it's directly between oppo2 and grow:
					// oppo2 ---oppo--->grow
					if (addToHead){
						if (buildLog)
							buildLog.chainRemoveTail(first_match.index, grow);
						chain.pop();
					}
					else{
						if (buildLog)
							buildLog.chainRemoveHead(first_match.index, grow);
						chain.shift();
					}
				}

				if (buildLog)
					buildLog.chainClose(first_match.index);

				// we have a closed chain!
				regions.push(chain);
				return;
			}

			// not closing a loop, so just add it to the apporpriate side
			if (addToHead){
				if (buildLog)
					buildLog.chainAddHead(first_match.index, pt);
				chain.unshift(pt);
			}
			else{
				if (buildLog)
					buildLog.chainAddTail(first_match.index, pt);
				chain.push(pt);
			}
			return;
		}

		// otherwise, we matched two chains, so we need to combine those chains together

		function reverseChain(index){
			if (buildLog)
				buildLog.chainReverse(index);
			chains[index].reverse(); // gee, that's easy
		}

		function appendChain(index1, index2){
			// index1 gets index2 appended to it, and index2 is removed
			var chain1 = chains[index1];
			var chain2 = chains[index2];
			var tail  = chain1[chain1.length - 1];
			var tail2 = chain1[chain1.length - 2];
			var head  = chain2[0];
			var head2 = chain2[1];

			if (eps.pointsCollinear(tail2, tail, head)){
				// tail isn't needed because it's directly between tail2 and head
				// tail2 ---tail---> head
				if (buildLog)
					buildLog.chainRemoveTail(index1, tail);
				chain1.pop();
				tail = tail2; // old tail is gone... new tail is what tail2 was
			}

			if (eps.pointsCollinear(tail, head, head2)){
				// head isn't needed because it's directly between tail and head2
				// tail ---head---> head2
				if (buildLog)
					buildLog.chainRemoveHead(index2, head);
				chain2.shift();
			}

			if (buildLog)
				buildLog.chainJoin(index1, index2);
			chains[index1] = chain1.concat(chain2);
			chains.splice(index2, 1);
		}

		var F = first_match.index;
		var S = second_match.index;

		if (buildLog)
			buildLog.chainConnect(F, S);

		var reverseF = chains[F].length < chains[S].length; // reverse the shorter chain, if needed
		if (first_match.matches_head){
			if (second_match.matches_head){
				if (reverseF){
					// <<<< F <<<< --- >>>> S >>>>
					reverseChain(F);
					// >>>> F >>>> --- >>>> S >>>>
					appendChain(F, S);
				}
				else{
					// <<<< F <<<< --- >>>> S >>>>
					reverseChain(S);
					// <<<< F <<<< --- <<<< S <<<<   logically same as:
					// >>>> S >>>> --- >>>> F >>>>
					appendChain(S, F);
				}
			}
			else{
				// <<<< F <<<< --- <<<< S <<<<   logically same as:
				// >>>> S >>>> --- >>>> F >>>>
				appendChain(S, F);
			}
		}
		else{
			if (second_match.matches_head){
				// >>>> F >>>> --- >>>> S >>>>
				appendChain(F, S);
			}
			else{
				if (reverseF){
					// >>>> F >>>> --- <<<< S <<<<
					reverseChain(F);
					// <<<< F <<<< --- <<<< S <<<<   logically same as:
					// >>>> S >>>> --- >>>> F >>>>
					appendChain(S, F);
				}
				else{
					// >>>> F >>>> --- <<<< S <<<<
					reverseChain(S);
					// >>>> F >>>> --- >>>> S >>>>
					appendChain(F, S);
				}
			}
		}
	});

	return regions;
}

module.exports = SegmentChainer;


/***/ }),

/***/ 5968:
/***/ (function(module) {

// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc
// MIT License
// Project Home: https://github.com/voidqk/polybooljs

//
// filter a list of segments based on boolean operations
//

function select(segments, selection, buildLog){
	var result = [];
	segments.forEach(function(seg){
		var index =
			(seg.myFill.above ? 8 : 0) +
			(seg.myFill.below ? 4 : 0) +
			((seg.otherFill && seg.otherFill.above) ? 2 : 0) +
			((seg.otherFill && seg.otherFill.below) ? 1 : 0);
		if (selection[index] !== 0){
			// copy the segment to the results, while also calculating the fill status
			result.push({
				id: buildLog ? buildLog.segmentId() : -1,
				start: seg.start,
				end: seg.end,
				myFill: {
					above: selection[index] === 1, // 1 if filled above
					below: selection[index] === 2  // 2 if filled below
				},
				otherFill: null
			});
		}
	});

	if (buildLog)
		buildLog.selected(result);

	return result;
}

var SegmentSelector = {
	union: function(segments, buildLog){ // primary | secondary
		// above1 below1 above2 below2    Keep?               Value
		//    0      0      0      0   =>   no                  0
		//    0      0      0      1   =>   yes filled below    2
		//    0      0      1      0   =>   yes filled above    1
		//    0      0      1      1   =>   no                  0
		//    0      1      0      0   =>   yes filled below    2
		//    0      1      0      1   =>   yes filled below    2
		//    0      1      1      0   =>   no                  0
		//    0      1      1      1   =>   no                  0
		//    1      0      0      0   =>   yes filled above    1
		//    1      0      0      1   =>   no                  0
		//    1      0      1      0   =>   yes filled above    1
		//    1      0      1      1   =>   no                  0
		//    1      1      0      0   =>   no                  0
		//    1      1      0      1   =>   no                  0
		//    1      1      1      0   =>   no                  0
		//    1      1      1      1   =>   no                  0
		return select(segments, [
			0, 2, 1, 0,
			2, 2, 0, 0,
			1, 0, 1, 0,
			0, 0, 0, 0
		], buildLog);
	},
	intersect: function(segments, buildLog){ // primary & secondary
		// above1 below1 above2 below2    Keep?               Value
		//    0      0      0      0   =>   no                  0
		//    0      0      0      1   =>   no                  0
		//    0      0      1      0   =>   no                  0
		//    0      0      1      1   =>   no                  0
		//    0      1      0      0   =>   no                  0
		//    0      1      0      1   =>   yes filled below    2
		//    0      1      1      0   =>   no                  0
		//    0      1      1      1   =>   yes filled below    2
		//    1      0      0      0   =>   no                  0
		//    1      0      0      1   =>   no                  0
		//    1      0      1      0   =>   yes filled above    1
		//    1      0      1      1   =>   yes filled above    1
		//    1      1      0      0   =>   no                  0
		//    1      1      0      1   =>   yes filled below    2
		//    1      1      1      0   =>   yes filled above    1
		//    1      1      1      1   =>   no                  0
		return select(segments, [
			0, 0, 0, 0,
			0, 2, 0, 2,
			0, 0, 1, 1,
			0, 2, 1, 0
		], buildLog);
	},
	difference: function(segments, buildLog){ // primary - secondary
		// above1 below1 above2 below2    Keep?               Value
		//    0      0      0      0   =>   no                  0
		//    0      0      0      1   =>   no                  0
		//    0      0      1      0   =>   no                  0
		//    0      0      1      1   =>   no                  0
		//    0      1      0      0   =>   yes filled below    2
		//    0      1      0      1   =>   no                  0
		//    0      1      1      0   =>   yes filled below    2
		//    0      1      1      1   =>   no                  0
		//    1      0      0      0   =>   yes filled above    1
		//    1      0      0      1   =>   yes filled above    1
		//    1      0      1      0   =>   no                  0
		//    1      0      1      1   =>   no                  0
		//    1      1      0      0   =>   no                  0
		//    1      1      0      1   =>   yes filled above    1
		//    1      1      1      0   =>   yes filled below    2
		//    1      1      1      1   =>   no                  0
		return select(segments, [
			0, 0, 0, 0,
			2, 0, 2, 0,
			1, 1, 0, 0,
			0, 1, 2, 0
		], buildLog);
	},
	differenceRev: function(segments, buildLog){ // secondary - primary
		// above1 below1 above2 below2    Keep?               Value
		//    0      0      0      0   =>   no                  0
		//    0      0      0      1   =>   yes filled below    2
		//    0      0      1      0   =>   yes filled above    1
		//    0      0      1      1   =>   no                  0
		//    0      1      0      0   =>   no                  0
		//    0      1      0      1   =>   no                  0
		//    0      1      1      0   =>   yes filled above    1
		//    0      1      1      1   =>   yes filled above    1
		//    1      0      0      0   =>   no                  0
		//    1      0      0      1   =>   yes filled below    2
		//    1      0      1      0   =>   no                  0
		//    1      0      1      1   =>   yes filled below    2
		//    1      1      0      0   =>   no                  0
		//    1      1      0      1   =>   no                  0
		//    1      1      1      0   =>   no                  0
		//    1      1      1      1   =>   no                  0
		return select(segments, [
			0, 2, 1, 0,
			0, 0, 1, 1,
			0, 2, 0, 2,
			0, 0, 0, 0
		], buildLog);
	},
	xor: function(segments, buildLog){ // primary ^ secondary
		// above1 below1 above2 below2    Keep?               Value
		//    0      0      0      0   =>   no                  0
		//    0      0      0      1   =>   yes filled below    2
		//    0      0      1      0   =>   yes filled above    1
		//    0      0      1      1   =>   no                  0
		//    0      1      0      0   =>   yes filled below    2
		//    0      1      0      1   =>   no                  0
		//    0      1      1      0   =>   no                  0
		//    0      1      1      1   =>   yes filled above    1
		//    1      0      0      0   =>   yes filled above    1
		//    1      0      0      1   =>   no                  0
		//    1      0      1      0   =>   no                  0
		//    1      0      1      1   =>   yes filled below    2
		//    1      1      0      0   =>   no                  0
		//    1      1      0      1   =>   yes filled above    1
		//    1      1      1      0   =>   yes filled below    2
		//    1      1      1      1   =>   no                  0
		return select(segments, [
			0, 2, 1, 0,
			2, 0, 0, 1,
			1, 0, 0, 2,
			0, 1, 2, 0
		], buildLog);
	}
};

module.exports = SegmentSelector;


/***/ }),

/***/ 386:
/***/ (function(module) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ 4267:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;// TinyColor v1.4.2
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function(Math) {

var trimLeft = /^\s+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    mathRound = Math.round,
    mathMin = Math.min,
    mathMax = Math.max,
    mathRandom = Math.random;

function tinycolor (color, opts) {

    color = (color) ? color : '';
    opts = opts || { };

    // If input is already a tinycolor, return itself
    if (color instanceof tinycolor) {
       return color;
    }
    // If we are called as a function, call using new instead
    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;

    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this._r < 1) { this._r = mathRound(this._r); }
    if (this._g < 1) { this._g = mathRound(this._g); }
    if (this._b < 1) { this._b = mathRound(this._b); }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() < 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {
        //http://www.w3.org/TR/AERT#color-contrast
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function() {
        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r/255;
        GsRGB = rgb.g/255;
        BsRGB = rgb.b/255;

        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
    },
    toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function(allow4Char) {
        return '#' + this.toHex8(allow4Char);
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function() {
        if (this._a === 0) {
            return "transparent";
        }

        if (this._a < 1) {
            return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";

        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }

        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === "name" && this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === "rgb") {
            formattedString = this.toRgbString();
        }
        if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
        }
        if (format === "hex3") {
            formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
            formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
            formattedString = this.toHex8String();
        }
        if (format === "name") {
            formattedString = this.toName();
        }
        if (format === "hsl") {
            formattedString = this.toHslString();
        }
        if (format === "hsv") {
            formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
    },
    clone: function() {
        return tinycolor(this.toString());
    },

    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color, opts) {
    if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === "a") {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }

    return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
        color = stringInputToObject(color);
    }

    if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
        }

        if (color.hasOwnProperty("a")) {
            a = color.a;
        }
    }

    a = boundAlpha(a);

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h: h, s: s, l: l };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
    var r, g, b;

    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    if(s === 0) {
        r = g = b = l; // achromatic
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
 function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);

    var i = Math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    // Return a 3 character hex if possible
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
    ];

    // Return a 4 character hex if possible
    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }

    return hex.join("");
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
function rgbaToArgbHex(r, g, b, a) {

    var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};

tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function greyscale(color) {
    return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}

function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}

function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}

function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}

function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;

    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}

function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }

    return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);

    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();

    var p = amount / 100;

    var rgba = {
        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
        a: ((rgb2.a - rgb1.a) * p) + rgb1.a
    };

    return tinycolor(rgba);
};


// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;

    out = false;

    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
            out = readability >= 4.5;
            break;
        case "AAlarge":
            out = readability >= 3;
            break;
        case "AAAsmall":
            out = readability >= 7;
            break;
    }
    return out;

};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size ;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors ;
    level = args.level;
    size = args.size;

    for (var i= 0; i < colorList.length ; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
        }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
        return bestColor;
    }
    else {
        args.includeFallbackColors=false;
        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
    }
};


// Big List of Colors
// ------------------
// <http://www.w3.org/TR/css3-color/#svg-color>
var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }

    return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
    if (isOnePointZero(n)) { n = "100%"; }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));

    // Automatically convert percentage into number
    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if ((Math.abs(n - max) < 0.000001)) {
        return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
    return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
    if (n <= 1) {
        n = (n * 100) + "%";
    }

    return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}

var matchers = (function() {

    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?";

    // <http://www.w3.org/TR/css3-values/#number-value>
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

    return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }

    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
        };
    }
    if ((match = matchers.hex4.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            a: convertHexToDecimal(match[4] + '' + match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? "name" : "hex"
        };
    }

    return false;
}

function validateWCAG2Parms(parms) {
    // return valid WCAG2 parms for isReadable.
    // If input parms are invalid, return {"level":"AA", "size":"small"}
    var level, size;
    parms = parms || {"level":"AA", "size":"small"};
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
        level = "AA";
    }
    if (size !== "small" && size !== "large") {
        size = "small";
    }
    return {"level":level, "size":size};
}

// Node: Export function
if ( true && module.exports) {
    module.exports = tinycolor;
}
// AMD/requirejs: Define the module
else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {return tinycolor;}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}
// Browser: Expose to window
else {}

})(Math);


/***/ }),

/***/ 372:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getContext = __webpack_require__(6249)

module.exports = function getWebGLContext (opt) {
  return getContext('webgl', opt)
}


/***/ }),

/***/ 3961:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/*
 * World Calendars
 * https://github.com/alexcjohnson/world-calendars
 *
 * Batch-converted from kbwood/calendars
 * Many thanks to Keith Wood and all of the contributors to the original project!
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

﻿/* http://keith-wood.name/calendars.html
   Traditional Chinese calendar for jQuery v2.0.2.
   Written by Nicolas Riesco (enquiries@nicolasriesco.net) December 2016.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

var main = __webpack_require__(3489);
var assign = __webpack_require__(6131);


var gregorianCalendar = main.instance();

/** Implementation of the traditional Chinese calendar.
    Source of calendar tables https://github.com/isee15/Lunar-Solar-Calendar-Converter .
    @class ChineseCalendar
    @param [language=''] {string} The language code (default English) for localisation. */
function ChineseCalendar(language) {
    this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
}

ChineseCalendar.prototype = new main.baseCalendar;

assign(ChineseCalendar.prototype, {
    /** The calendar name.
        @memberof ChineseCalendar */
    name: 'Chinese',
     /** Julian date of start of Gregorian epoch: 1 January 0001 CE.
        @memberof GregorianCalendar */
    jdEpoch: 1721425.5,
    /** <code>true</code> if has a year zero, <code>false</code> if not.
        @memberof ChineseCalendar */
    hasYearZero: false,
    /** The minimum month number.
        This calendar uses month indices to account for intercalary months. 
        @memberof ChineseCalendar */
    minMonth: 0,
    /** The first month in the year.
        This calendar uses month indices to account for intercalary months. 
        @memberof ChineseCalendar */
    firstMonth: 0,
    /** The minimum day number.
        @memberof ChineseCalendar */
    minDay: 1,

    /** Localisations for the plugin.
        Entries are objects indexed by the language code ('' being the default US/English).
        Each object has the following attributes.
        @memberof ChineseCalendar
        @property name {string} The calendar name.
        @property epochs {string[]} The epoch names.
        @property monthNames {string[]} The long names of the months of the year.
        @property monthNamesShort {string[]} The short names of the months of the year.
        @property dayNames {string[]} The long names of the days of the week.
        @property dayNamesShort {string[]} The short names of the days of the week.
        @property dayNamesMin {string[]} The minimal names of the days of the week.
        @property dateFormat {string} The date format for this calendar.
                See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
        @property firstDay {number} The number of the first day of the week, starting at 0.
        @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
    regionalOptions: { // Localisations
        '': {
            name: 'Chinese',
            epochs: ['BEC', 'EC'],
            monthNumbers: function(date, padded) {
                if (typeof date === 'string') {
                    var match = date.match(MONTH_NUMBER_REGEXP);
                    return (match) ? match[0] : '';
                }

                var year = this._validateYear(date);
                var monthIndex = date.month();

                var month = '' + this.toChineseMonth(year, monthIndex);

                if (padded && month.length < 2) {
                    month = "0" + month;
                }

                if (this.isIntercalaryMonth(year, monthIndex)) {
                    month += 'i';
                }

                return month;
            },
            monthNames: function(date) {
                if (typeof date === 'string') {
                    var match = date.match(MONTH_NAME_REGEXP);
                    return (match) ? match[0] : '';
                }

                var year = this._validateYear(date);
                var monthIndex = date.month();

                var month = this.toChineseMonth(year, monthIndex);

                var monthName = ['一月','二月','三月','四月','五月','六月',
                    '七月','八月','九月','十月','十一月','十二月'][month - 1];

                if (this.isIntercalaryMonth(year, monthIndex)) {
                    monthName = '闰' + monthName;
                }

                return monthName;
            },
            monthNamesShort: function(date) {
                if (typeof date === 'string') {
                    var match = date.match(MONTH_SHORT_NAME_REGEXP);
                    return (match) ? match[0] : '';
                }

                var year = this._validateYear(date);
                var monthIndex = date.month();

                var month = this.toChineseMonth(year, monthIndex);

                var monthName = ['一','二','三','四','五','六',
                    '七','八','九','十','十一','十二'][month - 1];

                if (this.isIntercalaryMonth(year, monthIndex)) {
                    monthName = '闰' + monthName;
                }

                return monthName;
            },
            parseMonth: function(year, monthString) {
                year = this._validateYear(year);
                var month = parseInt(monthString);
                var isIntercalary;

                if (!isNaN(month)) {
                    var i = monthString[monthString.length - 1];
                    isIntercalary = (i === 'i' || i === 'I');
                } else {
                    if (monthString[0] === '闰') {
                        isIntercalary = true;
                        monthString = monthString.substring(1);
                    }
                    if (monthString[monthString.length - 1] === '月') {
                        monthString = monthString.substring(0, monthString.length - 1);
                    }
                    month = 1 +
                        ['一','二','三','四','五','六',
                        '七','八','九','十','十一','十二'].indexOf(monthString);
                }

                var monthIndex = this.toMonthIndex(year, month, isIntercalary);
                return monthIndex;
            },
            dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
            digits: null,
            dateFormat: 'yyyy/mm/dd',
            firstDay: 1,
            isRTL: false
        }
    },

    /** Check that a candidate date is from the same calendar and is valid.
        @memberof BaseCalendar
        @private
        @param year {CDate|number} The date or the year to validate.
        @param error {string} Error message if invalid.
        @return {number} The year.
        @throws Error if year out of range. */
    _validateYear: function(year, error) {
        if (year.year) {
            year = year.year();
        }

        if (typeof year !== 'number' || year < 1888 || year > 2111) {
            throw error.replace(/\{0\}/, this.local.name);
        }

        return year;
    },

    /** Retrieve the month index (i.e. accounting for intercalary months).
        @memberof ChineseCalendar
        @param year {number} The year.
        @param month {number} The month (1 for first month).
        @param [isIntercalary=false] {boolean} If month is intercalary.
        @return {number} The month index (0 for first month).
        @throws Error if an invalid month/year or a different calendar used. */
    toMonthIndex: function(year, month, isIntercalary) {
        // compute intercalary month in the year (0 if none)
        var intercalaryMonth = this.intercalaryMonth(year);

        // validate month
        var invalidIntercalaryMonth = 
            (isIntercalary && month !== intercalaryMonth);
        if (invalidIntercalaryMonth || month < 1 || month > 12) {
            throw main.local.invalidMonth
                .replace(/\{0\}/, this.local.name);
        }

        // compute month index
        var monthIndex;

        if (!intercalaryMonth) {
            monthIndex = month - 1;
        } else if(!isIntercalary && month <= intercalaryMonth) {
            monthIndex = month - 1;
        } else {
            monthIndex = month;
        }

        return monthIndex;
    },

    /** Retrieve the month (i.e. accounting for intercalary months).
        @memberof ChineseCalendar
        @param year {CDate|number} The date or the year to examine.
        @param monthIndex {number} The month index (0 for first month).
        @return {number} The month (1 for first month).
        @throws Error if an invalid month/year or a different calendar used. */
    toChineseMonth: function(year, monthIndex) {
        if (year.year) {
            year = year.year();
            monthIndex = year.month();
        }

        // compute intercalary month in the year (0 if none)
        var intercalaryMonth = this.intercalaryMonth(year);

        // validate month
        var maxMonthIndex = (intercalaryMonth) ? 12 : 11;
        if (monthIndex < 0 || monthIndex > maxMonthIndex) {
            throw main.local.invalidMonth
                .replace(/\{0\}/, this.local.name);
        }

        // compute Chinese month
        var month;

        if (!intercalaryMonth) {
            month = monthIndex + 1;
        } else if(monthIndex < intercalaryMonth) {
            month = monthIndex + 1;
        } else {
            month = monthIndex;
        }

        return month;
    },

    /** Determine the intercalary month of a year (if any).
        @memberof ChineseCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {number} The intercalary month number, or 0 if none.
        @throws Error if an invalid year or a different calendar used. */
    intercalaryMonth: function(year) {
        year = this._validateYear(year);

        var monthDaysTable = LUNAR_MONTH_DAYS[year - LUNAR_MONTH_DAYS[0]];
        var intercalaryMonth = monthDaysTable >> 13;

        return intercalaryMonth;
    },

    /** Determine whether this date is an intercalary month.
        @memberof ChineseCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [monthIndex] {number} The month index to examine.
        @return {boolean} <code>true</code> if this is an intercalary month, <code>false</code> if not.
        @throws Error if an invalid year or a different calendar used. */
    isIntercalaryMonth: function(year, monthIndex) {
        if (year.year) {
            year = year.year();
            monthIndex = year.month();
        }

        var intercalaryMonth = this.intercalaryMonth(year);

        return !!intercalaryMonth && intercalaryMonth === monthIndex;
    },

    /** Determine whether this date is in a leap year.
        @memberof ChineseCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
        @throws Error if an invalid year or a different calendar used. */
    leapYear: function(year) {
        return (this.intercalaryMonth(year) !== 0);
    },

    /** Determine the week of the year for a date - ISO 8601.
        @memberof ChineseCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [monthIndex] {number} The month index to examine.
        @param [day] {number} The day to examine.
        @return {number} The week of the year.
        @throws Error if an invalid date or a different calendar used. */
    weekOfYear: function(year, monthIndex, day) {
        // compute Chinese new year
        var validatedYear =
            this._validateYear(year, main.local.invalidyear);
        var packedDate =
            CHINESE_NEW_YEAR[validatedYear - CHINESE_NEW_YEAR[0]];

        var y = (packedDate >> 9) & 0xFFF;
        var m = (packedDate >> 5) & 0x0F;
        var d = packedDate & 0x1F;
        
        // find first Thrusday of the year
        var firstThursday;
        firstThursday = gregorianCalendar.newDate(y, m, d);
        firstThursday.add(4 - (firstThursday.dayOfWeek() || 7), 'd');

        // compute days from first Thursday
        var offset =
            this.toJD(year, monthIndex, day) - firstThursday.toJD();
        return 1 + Math.floor(offset / 7);
    },

    /** Retrieve the number of months in a year.
        @memberof ChineseCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {number} The number of months.
        @throws Error if an invalid year or a different calendar used. */
    monthsInYear: function(year) {
        return (this.leapYear(year)) ? 13 : 12;
    },

    /** Retrieve the number of days in a month.
        @memberof ChineseCalendar
        @param year {CDate|number} The date to examine or the year of the month.
        @param [monthIndex] {number} The month index.
        @return {number} The number of days in this month.
        @throws Error if an invalid month/year or a different calendar used. */
    daysInMonth: function(year, monthIndex) {
        if (year.year) {
            monthIndex = year.month();
            year = year.year();
        }

        year = this._validateYear(year);

        var monthDaysTable = LUNAR_MONTH_DAYS[year - LUNAR_MONTH_DAYS[0]];

        var intercalaryMonth = monthDaysTable >> 13;
        var maxMonthIndex = (intercalaryMonth) ? 12 : 11;
        if (monthIndex > maxMonthIndex) {
            throw main.local.invalidMonth
                .replace(/\{0\}/, this.local.name);
        }

        var daysInMonth = (monthDaysTable & (1 << (12 - monthIndex))) ?
            30 : 29;

        return daysInMonth;
    },

    /** Determine whether this date is a week day.
        @memberof ChineseCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [monthIndex] {number} The month index to examine.
        @param [day] {number} The day to examine.
        @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
        @throws Error if an invalid date or a different calendar used. */
    weekDay: function(year, monthIndex, day) {
        return (this.dayOfWeek(year, monthIndex, day) || 7) < 6;
    },

    /** Retrieve the Julian date equivalent for this date,
        i.e. days since January 1, 4713 BCE Greenwich noon.
        @memberof ChineseCalendar
        @param year {CDate|number} The date to convert or the year to convert.
        @param [monthIndex] {number} The month index to convert.
        @param [day] {number} The day to convert.
        @return {number} The equivalent Julian date.
        @throws Error if an invalid date or a different calendar used. */
    toJD: function(year, monthIndex, day) {
        var date = this._validate(year, month, day, main.local.invalidDate);
        year = this._validateYear(date.year());
        monthIndex = date.month();
        day = date.day();

        var isIntercalary = this.isIntercalaryMonth(year, monthIndex);
        var month = this.toChineseMonth(year, monthIndex);

        var solar = toSolar(year, month, day, isIntercalary);

        return gregorianCalendar.toJD(solar.year, solar.month, solar.day);
    },

    /** Create a new date from a Julian date.
        @memberof ChineseCalendar
        @param jd {number} The Julian date to convert.
        @return {CDate} The equivalent date. */
    fromJD: function(jd) {
        var date = gregorianCalendar.fromJD(jd);
        var lunar = toLunar(date.year(), date.month(), date.day());
        var monthIndex = this.toMonthIndex(
            lunar.year, lunar.month, lunar.isIntercalary);
        return this.newDate(lunar.year, monthIndex, lunar.day);
    },

    /** Create a new date from a string.
        @memberof ChineseCalendar
        @param dateString {string} String representing a Chinese date
        @return {CDate} The new date.
        @throws Error if an invalid date. */
    fromString: function(dateString) {
        var match = dateString.match(DATE_REGEXP);

        var year = this._validateYear(+match[1]);

        var month = +match[2];
        var isIntercalary = !!match[3];
        var monthIndex = this.toMonthIndex(year, month, isIntercalary);

        var day = +match[4];

        return this.newDate(year, monthIndex, day);
    },

    /** Add period(s) to a date.
        Cater for no year zero.
        @memberof ChineseCalendar
        @param date {CDate} The starting date.
        @param offset {number} The number of periods to adjust by.
        @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
        @return {CDate} The updated date.
        @throws Error if a different calendar used. */
    add: function(date, offset, period) {
        var year = date.year();
        var monthIndex = date.month();
        var isIntercalary = this.isIntercalaryMonth(year, monthIndex);
        var month = this.toChineseMonth(year, monthIndex);

        var cdate = Object.getPrototypeOf(ChineseCalendar.prototype)
            .add.call(this, date, offset, period);

        if (period === 'y') {
            // Resync month
            var resultYear = cdate.year();
            var resultMonthIndex = cdate.month();

            // Using the fact the month index of an intercalary month
            // equals its month number:
            var resultCanBeIntercalaryMonth =
                this.isIntercalaryMonth(resultYear, month);

            var correctedMonthIndex =
                (isIntercalary && resultCanBeIntercalaryMonth) ?
                this.toMonthIndex(resultYear, month, true) :
                this.toMonthIndex(resultYear, month, false);

            if (correctedMonthIndex !== resultMonthIndex) {
                cdate.month(correctedMonthIndex);
            }
        }

        return cdate;
    },
});

// Used by ChineseCalendar.prototype.fromString
var DATE_REGEXP = /^\s*(-?\d\d\d\d|\d\d)[-/](\d?\d)([iI]?)[-/](\d?\d)/m;
var MONTH_NUMBER_REGEXP = /^\d?\d[iI]?/m;
var MONTH_NAME_REGEXP = /^闰?十?[一二三四五六七八九]?月/m;
var MONTH_SHORT_NAME_REGEXP = /^闰?十?[一二三四五六七八九]?/m;

// Chinese calendar implementation
main.calendars.chinese = ChineseCalendar;

// Chinese calendar tables from year 1888 to 2111
//
// Source:
// https://github.com/isee15/Lunar-Solar-Calendar-Converter.git

// Table of intercalary months and days per month from year 1888 to 2111
//
// bit (12 - i):        days in the i^th month
//                      (= 0 if i^th lunar month has 29 days)
//                      (= 1 if i^th lunar month has 30 days)
//                      (first month in lunar year is i = 0)
// bits (13,14,15,16):  intercalary month
//                      (= 0 if lunar year has no intercalary month)
var LUNAR_MONTH_DAYS = [1887, 0x1694, 0x16aa, 0x4ad5,
    0xab6, 0xc4b7, 0x4ae, 0xa56, 0xb52a, 0x1d2a, 0xd54, 0x75aa, 0x156a,
    0x1096d, 0x95c, 0x14ae, 0xaa4d, 0x1a4c, 0x1b2a, 0x8d55, 0xad4,
    0x135a, 0x495d, 0x95c, 0xd49b, 0x149a, 0x1a4a, 0xbaa5, 0x16a8,
    0x1ad4, 0x52da, 0x12b6, 0xe937, 0x92e, 0x1496, 0xb64b, 0xd4a,
    0xda8, 0x95b5, 0x56c, 0x12ae, 0x492f, 0x92e, 0xcc96, 0x1a94,
    0x1d4a, 0xada9, 0xb5a, 0x56c, 0x726e, 0x125c, 0xf92d, 0x192a,
    0x1a94, 0xdb4a, 0x16aa, 0xad4, 0x955b, 0x4ba, 0x125a, 0x592b,
    0x152a, 0xf695, 0xd94, 0x16aa, 0xaab5, 0x9b4, 0x14b6, 0x6a57,
    0xa56, 0x1152a, 0x1d2a, 0xd54, 0xd5aa, 0x156a, 0x96c, 0x94ae,
    0x14ae, 0xa4c, 0x7d26, 0x1b2a, 0xeb55, 0xad4, 0x12da, 0xa95d,
    0x95a, 0x149a, 0x9a4d, 0x1a4a, 0x11aa5, 0x16a8, 0x16d4, 0xd2da,
    0x12b6, 0x936, 0x9497, 0x1496, 0x1564b, 0xd4a, 0xda8, 0xd5b4,
    0x156c, 0x12ae, 0xa92f, 0x92e, 0xc96, 0x6d4a, 0x1d4a, 0x10d65,
    0xb58, 0x156c, 0xb26d, 0x125c, 0x192c, 0x9a95, 0x1a94, 0x1b4a,
    0x4b55, 0xad4, 0xf55b, 0x4ba, 0x125a, 0xb92b, 0x152a, 0x1694,
    0x96aa, 0x15aa, 0x12ab5, 0x974, 0x14b6, 0xca57, 0xa56, 0x1526,
    0x8e95, 0xd54, 0x15aa, 0x49b5, 0x96c, 0xd4ae, 0x149c, 0x1a4c,
    0xbd26, 0x1aa6, 0xb54, 0x6d6a, 0x12da, 0x1695d, 0x95a, 0x149a,
    0xda4b, 0x1a4a, 0x1aa4, 0xbb54, 0x16b4, 0xada, 0x495b, 0x936,
    0xf497, 0x1496, 0x154a, 0xb6a5, 0xda4, 0x15b4, 0x6ab6, 0x126e,
    0x1092f, 0x92e, 0xc96, 0xcd4a, 0x1d4a, 0xd64, 0x956c, 0x155c,
    0x125c, 0x792e, 0x192c, 0xfa95, 0x1a94, 0x1b4a, 0xab55, 0xad4,
    0x14da, 0x8a5d, 0xa5a, 0x1152b, 0x152a, 0x1694, 0xd6aa, 0x15aa,
    0xab4, 0x94ba, 0x14b6, 0xa56, 0x7527, 0xd26, 0xee53, 0xd54, 0x15aa,
    0xa9b5, 0x96c, 0x14ae, 0x8a4e, 0x1a4c, 0x11d26, 0x1aa4, 0x1b54,
    0xcd6a, 0xada, 0x95c, 0x949d, 0x149a, 0x1a2a, 0x5b25, 0x1aa4,
    0xfb52, 0x16b4, 0xaba, 0xa95b, 0x936, 0x1496, 0x9a4b, 0x154a,
    0x136a5, 0xda4, 0x15ac];

// Table of Chinese New Years from year 1888 to 2111
// 
// bits (0 to 4):   solar day
// bits (5 to 8):   solar month
// bits (9 to 20):  solar year
var CHINESE_NEW_YEAR = [1887, 0xec04c, 0xec23f, 0xec435, 0xec649,
    0xec83e, 0xeca51, 0xecc46, 0xece3a, 0xed04d, 0xed242, 0xed436,
    0xed64a, 0xed83f, 0xeda53, 0xedc48, 0xede3d, 0xee050, 0xee244,
    0xee439, 0xee64d, 0xee842, 0xeea36, 0xeec4a, 0xeee3e, 0xef052,
    0xef246, 0xef43a, 0xef64e, 0xef843, 0xefa37, 0xefc4b, 0xefe41,
    0xf0054, 0xf0248, 0xf043c, 0xf0650, 0xf0845, 0xf0a38, 0xf0c4d,
    0xf0e42, 0xf1037, 0xf124a, 0xf143e, 0xf1651, 0xf1846, 0xf1a3a,
    0xf1c4e, 0xf1e44, 0xf2038, 0xf224b, 0xf243f, 0xf2653, 0xf2848,
    0xf2a3b, 0xf2c4f, 0xf2e45, 0xf3039, 0xf324d, 0xf3442, 0xf3636,
    0xf384a, 0xf3a3d, 0xf3c51, 0xf3e46, 0xf403b, 0xf424e, 0xf4443,
    0xf4638, 0xf484c, 0xf4a3f, 0xf4c52, 0xf4e48, 0xf503c, 0xf524f,
    0xf5445, 0xf5639, 0xf584d, 0xf5a42, 0xf5c35, 0xf5e49, 0xf603e,
    0xf6251, 0xf6446, 0xf663b, 0xf684f, 0xf6a43, 0xf6c37, 0xf6e4b,
    0xf703f, 0xf7252, 0xf7447, 0xf763c, 0xf7850, 0xf7a45, 0xf7c39,
    0xf7e4d, 0xf8042, 0xf8254, 0xf8449, 0xf863d, 0xf8851, 0xf8a46,
    0xf8c3b, 0xf8e4f, 0xf9044, 0xf9237, 0xf944a, 0xf963f, 0xf9853,
    0xf9a47, 0xf9c3c, 0xf9e50, 0xfa045, 0xfa238, 0xfa44c, 0xfa641,
    0xfa836, 0xfaa49, 0xfac3d, 0xfae52, 0xfb047, 0xfb23a, 0xfb44e,
    0xfb643, 0xfb837, 0xfba4a, 0xfbc3f, 0xfbe53, 0xfc048, 0xfc23c,
    0xfc450, 0xfc645, 0xfc839, 0xfca4c, 0xfcc41, 0xfce36, 0xfd04a,
    0xfd23d, 0xfd451, 0xfd646, 0xfd83a, 0xfda4d, 0xfdc43, 0xfde37,
    0xfe04b, 0xfe23f, 0xfe453, 0xfe648, 0xfe83c, 0xfea4f, 0xfec44,
    0xfee38, 0xff04c, 0xff241, 0xff436, 0xff64a, 0xff83e, 0xffa51,
    0xffc46, 0xffe3a, 0x10004e, 0x100242, 0x100437, 0x10064b, 0x100841,
    0x100a53, 0x100c48, 0x100e3c, 0x10104f, 0x101244, 0x101438,
    0x10164c, 0x101842, 0x101a35, 0x101c49, 0x101e3d, 0x102051,
    0x102245, 0x10243a, 0x10264e, 0x102843, 0x102a37, 0x102c4b,
    0x102e3f, 0x103053, 0x103247, 0x10343b, 0x10364f, 0x103845,
    0x103a38, 0x103c4c, 0x103e42, 0x104036, 0x104249, 0x10443d,
    0x104651, 0x104846, 0x104a3a, 0x104c4e, 0x104e43, 0x105038,
    0x10524a, 0x10543e, 0x105652, 0x105847, 0x105a3b, 0x105c4f,
    0x105e45, 0x106039, 0x10624c, 0x106441, 0x106635, 0x106849,
    0x106a3d, 0x106c51, 0x106e47, 0x10703c, 0x10724f, 0x107444,
    0x107638, 0x10784c, 0x107a3f, 0x107c53, 0x107e48];

function toLunar(yearOrDate, monthOrResult, day, result) {
    var solarDate;
    var lunarDate;

    if(typeof yearOrDate === 'object') {
        solarDate = yearOrDate;
        lunarDate = monthOrResult || {};

    } else {
        var isValidYear = (typeof yearOrDate === 'number') &&
            (yearOrDate >= 1888) && (yearOrDate <= 2111);
        if(!isValidYear)
            throw new Error("Solar year outside range 1888-2111");

        var isValidMonth = (typeof monthOrResult === 'number') &&
            (monthOrResult >= 1) && (monthOrResult <= 12);
        if(!isValidMonth)
            throw new Error("Solar month outside range 1 - 12");

        var isValidDay = (typeof day === 'number') && (day >= 1) && (day <= 31);
        if(!isValidDay)
            throw new Error("Solar day outside range 1 - 31");

        solarDate = {
            year: yearOrDate,
            month: monthOrResult,
            day: day,
        };
        lunarDate = result || {};
    }

    // Compute Chinese new year and lunar year
    var chineseNewYearPackedDate =
        CHINESE_NEW_YEAR[solarDate.year - CHINESE_NEW_YEAR[0]];

    var packedDate = (solarDate.year << 9) | (solarDate.month << 5)
        | solarDate.day;

    lunarDate.year = (packedDate >= chineseNewYearPackedDate) ?
        solarDate.year :
        solarDate.year - 1;

    chineseNewYearPackedDate =
        CHINESE_NEW_YEAR[lunarDate.year - CHINESE_NEW_YEAR[0]];

    var y = (chineseNewYearPackedDate >> 9) & 0xFFF;
    var m = (chineseNewYearPackedDate >> 5) & 0x0F;
    var d = chineseNewYearPackedDate & 0x1F;

    // Compute days from new year
    var daysFromNewYear;

    var chineseNewYearJSDate = new Date(y, m -1, d);
    var jsDate = new Date(solarDate.year, solarDate.month - 1, solarDate.day);

    daysFromNewYear = Math.round(
        (jsDate - chineseNewYearJSDate) / (24 * 3600 * 1000));

    // Compute lunar month and day
    var monthDaysTable = LUNAR_MONTH_DAYS[lunarDate.year - LUNAR_MONTH_DAYS[0]];

    var i;
    for(i = 0; i < 13; i++) {
        var daysInMonth = (monthDaysTable & (1 << (12 - i))) ? 30 : 29;

        if (daysFromNewYear < daysInMonth) {
            break;
        }

        daysFromNewYear -= daysInMonth;
    }

    var intercalaryMonth = monthDaysTable >> 13;
    if (!intercalaryMonth || i < intercalaryMonth) {
        lunarDate.isIntercalary = false;
        lunarDate.month = 1 + i;
    } else if (i === intercalaryMonth) {
        lunarDate.isIntercalary = true;
        lunarDate.month = i;
    } else {
        lunarDate.isIntercalary = false;
        lunarDate.month = i;
    }

    lunarDate.day = 1 + daysFromNewYear;

    return lunarDate;
}

function toSolar(yearOrDate, monthOrResult, day, isIntercalaryOrResult, result) {
    var solarDate;
    var lunarDate;

    if(typeof yearOrDate === 'object') {
        lunarDate = yearOrDate;
        solarDate = monthOrResult || {};

    } else {
        var isValidYear = (typeof yearOrDate === 'number') &&
            (yearOrDate >= 1888) && (yearOrDate <= 2111);
        if(!isValidYear)
            throw new Error("Lunar year outside range 1888-2111");

        var isValidMonth = (typeof monthOrResult === 'number') &&
            (monthOrResult >= 1) && (monthOrResult <= 12);
        if(!isValidMonth)
            throw new Error("Lunar month outside range 1 - 12");

        var isValidDay = (typeof day === 'number') && (day >= 1) && (day <= 30);
        if(!isValidDay)
            throw new Error("Lunar day outside range 1 - 30");

        var isIntercalary;
        if(typeof isIntercalaryOrResult === 'object') {
            isIntercalary = false;
            solarDate = isIntercalaryOrResult;
        } else {
            isIntercalary = !!isIntercalaryOrResult;
            solarDate = result || {};
        }

        lunarDate = {
            year: yearOrDate,
            month: monthOrResult,
            day: day,
            isIntercalary: isIntercalary,
        };
    }

    // Compute days from new year
    var daysFromNewYear;

    daysFromNewYear = lunarDate.day - 1;

    var monthDaysTable = LUNAR_MONTH_DAYS[lunarDate.year - LUNAR_MONTH_DAYS[0]];
    var intercalaryMonth = monthDaysTable >> 13;

    var monthsFromNewYear;
    if (!intercalaryMonth) {
        monthsFromNewYear = lunarDate.month - 1;
    } else if (lunarDate.month > intercalaryMonth) {
        monthsFromNewYear = lunarDate.month;
    } else if (lunarDate.isIntercalary) {
        monthsFromNewYear = lunarDate.month;
    } else {
        monthsFromNewYear = lunarDate.month - 1;
    }

    for(var i = 0; i < monthsFromNewYear; i++) {
        var daysInMonth = (monthDaysTable & (1 << (12 - i))) ? 30 : 29;
        daysFromNewYear += daysInMonth;
    }

    // Compute Chinese new year
    var packedDate = CHINESE_NEW_YEAR[lunarDate.year - CHINESE_NEW_YEAR[0]];

    var y = (packedDate >> 9) & 0xFFF;
    var m = (packedDate >> 5) & 0x0F;
    var d = packedDate & 0x1F;

    // Compute solar date
    var jsDate = new Date(y, m - 1, d + daysFromNewYear);

    solarDate.year = jsDate.getFullYear();
    solarDate.month = 1 + jsDate.getMonth();
    solarDate.day = jsDate.getDate();

    return solarDate;
}



/***/ }),

/***/ 8751:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/*
 * World Calendars
 * https://github.com/alexcjohnson/world-calendars
 *
 * Batch-converted from kbwood/calendars
 * Many thanks to Keith Wood and all of the contributors to the original project!
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

﻿/* http://keith-wood.name/calendars.html
   Coptic calendar for jQuery v2.0.2.
   Written by Keith Wood (wood.keith{at}optusnet.com.au) February 2010.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

var main = __webpack_require__(3489);
var assign = __webpack_require__(6131);


/** Implementation of the Coptic calendar.
    See <a href="http://en.wikipedia.org/wiki/Coptic_calendar">http://en.wikipedia.org/wiki/Coptic_calendar</a>.
    See also Calendrical Calculations: The Millennium Edition
    (<a href="http://emr.cs.iit.edu/home/reingold/calendar-book/index.shtml">http://emr.cs.iit.edu/home/reingold/calendar-book/index.shtml</a>).
    @class CopticCalendar
    @param [language=''] {string} The language code (default English) for localisation. */
function CopticCalendar(language) {
    this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
}

CopticCalendar.prototype = new main.baseCalendar;

assign(CopticCalendar.prototype, {
    /** The calendar name.
        @memberof CopticCalendar */
    name: 'Coptic',
    /** Julian date of start of Coptic epoch: 29 August 284 CE (Gregorian).
        @memberof CopticCalendar */
    jdEpoch: 1825029.5,
    /** Days per month in a common year.
        @memberof CopticCalendar */
    daysPerMonth: [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 5],
    /** <code>true</code> if has a year zero, <code>false</code> if not.
        @memberof CopticCalendar */
    hasYearZero: false,
    /** The minimum month number.
        @memberof CopticCalendar */
    minMonth: 1,
    /** The first month in the year.
        @memberof CopticCalendar */
    firstMonth: 1,
    /** The minimum day number.
        @memberof CopticCalendar */
    minDay: 1,

    /** Localisations for the plugin.
        Entries are objects indexed by the language code ('' being the default US/English).
        Each object has the following attributes.
        @memberof CopticCalendar
        @property name {string} The calendar name.
        @property epochs {string[]} The epoch names.
        @property monthNames {string[]} The long names of the months of the year.
        @property monthNamesShort {string[]} The short names of the months of the year.
        @property dayNames {string[]} The long names of the days of the week.
        @property dayNamesShort {string[]} The short names of the days of the week.
        @property dayNamesMin {string[]} The minimal names of the days of the week.
        @property dateFormat {string} The date format for this calendar.
                See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
        @property firstDay {number} The number of the first day of the week, starting at 0.
        @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
    regionalOptions: { // Localisations
        '': {
            name: 'Coptic',
            epochs: ['BAM', 'AM'],
            monthNames: ['Thout', 'Paopi', 'Hathor', 'Koiak', 'Tobi', 'Meshir',
            'Paremhat', 'Paremoude', 'Pashons', 'Paoni', 'Epip', 'Mesori', 'Pi Kogi Enavot'],
            monthNamesShort: ['Tho', 'Pao', 'Hath', 'Koi', 'Tob', 'Mesh',
            'Pat', 'Pad', 'Pash', 'Pao', 'Epi', 'Meso', 'PiK'],
            dayNames: ['Tkyriaka', 'Pesnau', 'Pshoment', 'Peftoou', 'Ptiou', 'Psoou', 'Psabbaton'],
            dayNamesShort: ['Tky', 'Pes', 'Psh', 'Pef', 'Pti', 'Pso', 'Psa'],
            dayNamesMin: ['Tk', 'Pes', 'Psh', 'Pef', 'Pt', 'Pso', 'Psa'],
            digits: null,
            dateFormat: 'dd/mm/yyyy',
            firstDay: 0,
            isRTL: false
        }
    },

    /** Determine whether this date is in a leap year.
        @memberof CopticCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
        @throws Error if an invalid year or a different calendar used. */
    leapYear: function(year) {
        var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        var year = date.year() + (date.year() < 0 ? 1 : 0); // No year zero
        return year % 4 === 3 || year % 4 === -1;
    },

    /** Retrieve the number of months in a year.
        @memberof CopticCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {number} The number of months.
        @throws Error if an invalid year or a different calendar used. */
    monthsInYear: function(year) {
        this._validate(year, this.minMonth, this.minDay,
            main.local.invalidYear || main.regionalOptions[''].invalidYear);
        return 13;
    },

    /** Determine the week of the year for a date.
        @memberof CopticCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number) the month to examine.
        @param [day] {number} The day to examine.
        @return {number} The week of the year.
        @throws Error if an invalid date or a different calendar used. */
    weekOfYear: function(year, month, day) {
        // Find Sunday of this week starting on Sunday
        var checkDate = this.newDate(year, month, day);
        checkDate.add(-checkDate.dayOfWeek(), 'd');
        return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
    },

    /** Retrieve the number of days in a month.
        @memberof CopticCalendar
        @param year {CDate|number} The date to examine or the year of the month.
        @param [month] {number} The month.
        @return {number} The number of days in this month.
        @throws Error if an invalid month/year or a different calendar used. */
    daysInMonth: function(year, month) {
        var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
        return this.daysPerMonth[date.month() - 1] +
            (date.month() === 13 && this.leapYear(date.year()) ? 1 : 0);
    },

    /** Determine whether this date is a week day.
        @memberof CopticCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param month {number} The month to examine.
        @param day {number} The day to examine.
        @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
        @throws Error if an invalid date or a different calendar used. */
    weekDay: function(year, month, day) {
        return (this.dayOfWeek(year, month, day) || 7) < 6;
    },

    /** Retrieve the Julian date equivalent for this date,
        i.e. days since January 1, 4713 BCE Greenwich noon.
        @memberof CopticCalendar
        @param year {CDate|number} The date to convert or the year to convert.
        @param [month] {number) the month to convert.
        @param [day] {number} The day to convert.
        @return {number} The equivalent Julian date.
        @throws Error if an invalid date or a different calendar used. */
    toJD: function(year, month, day) {
        var date = this._validate(year, month, day, main.local.invalidDate);
        year = date.year();
        if (year < 0) { year++; } // No year zero
        return date.day() + (date.month() - 1) * 30 +
            (year - 1) * 365 + Math.floor(year / 4) + this.jdEpoch - 1;
    },

    /** Create a new date from a Julian date.
        @memberof CopticCalendar
        @param jd {number} The Julian date to convert.
        @return {CDate} The equivalent date. */
    fromJD: function(jd) {
        var c = Math.floor(jd) + 0.5 - this.jdEpoch;
        var year = Math.floor((c - Math.floor((c + 366) / 1461)) / 365) + 1;
        if (year <= 0) { year--; } // No year zero
        c = Math.floor(jd) + 0.5 - this.newDate(year, 1, 1).toJD();
        var month = Math.floor(c / 30) + 1;
        var day = c - (month - 1) * 30 + 1;
        return this.newDate(year, month, day);
    }
});

// Coptic calendar implementation
main.calendars.coptic = CopticCalendar;



/***/ }),

/***/ 6825:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/*
 * World Calendars
 * https://github.com/alexcjohnson/world-calendars
 *
 * Batch-converted from kbwood/calendars
 * Many thanks to Keith Wood and all of the contributors to the original project!
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

﻿/* http://keith-wood.name/calendars.html
   Discworld calendar for jQuery v2.0.2.
   Written by Keith Wood (wood.keith{at}optusnet.com.au) January 2016.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

var main = __webpack_require__(3489);
var assign = __webpack_require__(6131);


/** Implementation of the Discworld calendar - Unseen University version.
    See also <a href="http://wiki.lspace.org/mediawiki/Discworld_calendar">http://wiki.lspace.org/mediawiki/Discworld_calendar</a>
    and <a href="http://discworld.wikia.com/wiki/Discworld_calendar">http://discworld.wikia.com/wiki/Discworld_calendar</a>.
    @class DiscworldCalendar
    @param [language=''] {string} The language code (default English) for localisation. */
function DiscworldCalendar(language) {
    this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
}

DiscworldCalendar.prototype = new main.baseCalendar;

assign(DiscworldCalendar.prototype, {
    /** The calendar name.
        @memberof DiscworldCalendar */
    name: 'Discworld',
    /** Julian date of start of Discworld epoch: 1 January 0001 CE.
        @memberof DiscworldCalendar */
    jdEpoch: 1721425.5,
    /** Days per month in a common year.
        @memberof DiscworldCalendar */
    daysPerMonth: [16, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32],
    /** <code>true</code> if has a year zero, <code>false</code> if not.
        @memberof DiscworldCalendar */
    hasYearZero: false,
    /** The minimum month number.
        @memberof DiscworldCalendar */
    minMonth: 1,
    /** The first month in the year.
        @memberof DiscworldCalendar */
    firstMonth: 1,
    /** The minimum day number.
        @memberof DiscworldCalendar */
    minDay: 1,

    /** Localisations for the plugin.
        Entries are objects indexed by the language code ('' being the default US/English).
        Each object has the following attributes.
        @memberof DiscworldCalendar
        @property name {string} The calendar name.
        @property epochs {string[]} The epoch names.
        @property monthNames {string[]} The long names of the months of the year.
        @property monthNamesShort {string[]} The short names of the months of the year.
        @property dayNames {string[]} The long names of the days of the week.
        @property dayNamesShort {string[]} The short names of the days of the week.
        @property dayNamesMin {string[]} The minimal names of the days of the week.
        @property dateFormat {string} The date format for this calendar.
                See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
        @property firstDay {number} The number of the first day of the week, starting at 0.
        @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
    regionalOptions: { // Localisations
        '': {
            name: 'Discworld',
            epochs: ['BUC', 'UC'],
            monthNames: ['Ick', 'Offle', 'February', 'March', 'April', 'May', 'June',
            'Grune', 'August', 'Spune', 'Sektober', 'Ember', 'December'],
            monthNamesShort: ['Ick', 'Off', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Gru', 'Aug', 'Spu', 'Sek', 'Emb', 'Dec'],
            dayNames: ['Sunday', 'Octeday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            dayNamesShort: ['Sun', 'Oct', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            dayNamesMin: ['Su', 'Oc', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
            digits: null,
            dateFormat: 'yyyy/mm/dd',
            firstDay: 2,
            isRTL: false
        }
    },

    /** Determine whether this date is in a leap year.
        @memberof DiscworldCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
        @throws Error if an invalid year or a different calendar used. */
    leapYear: function(year) {
        this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        return false;
    },

    /** Retrieve the number of months in a year.
        @memberof DiscworldCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {number} The number of months.
        @throws Error if an invalid year or a different calendar used. */
    monthsInYear: function(year) {
        this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        return 13;
    },

    /** Retrieve the number of days in a year.
        @memberof DiscworldCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {number} The number of days.
        @throws Error if an invalid year or a different calendar used. */
    daysInYear: function(year) {
        this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        return 400;
    },

    /** Determine the week of the year for a date.
        @memberof DiscworldCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {number} The week of the year.
        @throws Error if an invalid date or a different calendar used. */
    weekOfYear: function(year, month, day) {
        // Find Sunday of this week starting on Sunday
        var checkDate = this.newDate(year, month, day);
        checkDate.add(-checkDate.dayOfWeek(), 'd');
        return Math.floor((checkDate.dayOfYear() - 1) / 8) + 1;
    },

    /** Retrieve the number of days in a month.
        @memberof DiscworldCalendar
        @param year {CDate|number} The date to examine or the year of the month.
        @param [month] {number} The month.
        @return {number} The number of days in this month.
        @throws Error if an invalid month/year or a different calendar used. */
    daysInMonth: function(year, month) {
        var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
        return this.daysPerMonth[date.month() - 1];
    },

    /** Retrieve the number of days in a week.
        @memberof DiscworldCalendar
        @return {number} The number of days. */
    daysInWeek: function() {
        return 8;
    },

    /** Retrieve the day of the week for a date.
        @memberof DiscworldCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {number} The day of the week: 0 to number of days - 1.
        @throws Error if an invalid date or a different calendar used. */
    dayOfWeek: function(year, month, day) {
        var date = this._validate(year, month, day, main.local.invalidDate);
        return (date.day() + 1) % 8;
    },

    /** Determine whether this date is a week day.
        @memberof DiscworldCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
        @throws Error if an invalid date or a different calendar used. */
    weekDay: function(year, month, day) {
        var dow = this.dayOfWeek(year, month, day);
        return (dow >= 2 && dow <= 6);
    },

    /** Retrieve additional information about a date.
        @memberof DiscworldCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {object} Additional information - contents depends on calendar.
        @throws Error if an invalid date or a different calendar used. */
    extraInfo: function(year, month, day) {
        var date = this._validate(year, month, day, main.local.invalidDate);
        return {century: centuries[Math.floor((date.year() - 1) / 100) + 1] || ''};
    },

    /** Retrieve the Julian date equivalent for this date,
        i.e. days since January 1, 4713 BCE Greenwich noon.
        @memberof DiscworldCalendar
        @param year {CDate|number} The date to convert or the year to convert.
        @param [month] {number} The month to convert.
        @param [day] {number} The day to convert.
        @return {number} The equivalent Julian date.
        @throws Error if an invalid date or a different calendar used. */
    toJD: function(year, month, day) {
        var date = this._validate(year, month, day, main.local.invalidDate);
        year = date.year() + (date.year() < 0 ? 1 : 0);
        month = date.month();
        day = date.day();
        return day + (month > 1 ? 16 : 0) + (month > 2 ? (month - 2) * 32 : 0) +
            (year - 1) * 400 + this.jdEpoch - 1;
    },

    /** Create a new date from a Julian date.
        @memberof DiscworldCalendar
        @param jd {number} The Julian date to convert.
        @return {CDate} The equivalent date. */
    fromJD: function(jd) {
        jd = Math.floor(jd + 0.5) - Math.floor(this.jdEpoch) - 1;
        var year = Math.floor(jd / 400) + 1;
        jd -= (year - 1) * 400;
        jd += (jd > 15 ? 16 : 0);
        var month = Math.floor(jd / 32) + 1;
        var day = jd - (month - 1) * 32 + 1;
        return this.newDate(year <= 0 ? year - 1 : year, month, day);
    }
});

// Names of the centuries
var centuries = {
    20: 'Fruitbat',
    21: 'Anchovy'
};

// Discworld calendar implementation
main.calendars.discworld = DiscworldCalendar;



/***/ }),

/***/ 7715:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/*
 * World Calendars
 * https://github.com/alexcjohnson/world-calendars
 *
 * Batch-converted from kbwood/calendars
 * Many thanks to Keith Wood and all of the contributors to the original project!
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

﻿/* http://keith-wood.name/calendars.html
   Ethiopian calendar for jQuery v2.0.2.
   Written by Keith Wood (wood.keith{at}optusnet.com.au) February 2010.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

var main = __webpack_require__(3489);
var assign = __webpack_require__(6131);


/** Implementation of the Ethiopian calendar.
    See <a href="http://en.wikipedia.org/wiki/Ethiopian_calendar">http://en.wikipedia.org/wiki/Ethiopian_calendar</a>.
    See also Calendrical Calculations: The Millennium Edition
    (<a href="http://emr.cs.iit.edu/home/reingold/calendar-book/index.shtml">http://emr.cs.iit.edu/home/reingold/calendar-book/index.shtml</a>).
    @class EthiopianCalendar
    @param [language=''] {string} The language code (default English) for localisation. */
function EthiopianCalendar(language) {
    this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
}

EthiopianCalendar.prototype = new main.baseCalendar;

assign(EthiopianCalendar.prototype, {
    /** The calendar name.
        @memberof EthiopianCalendar */
    name: 'Ethiopian',
    /** Julian date of start of Ethiopian epoch: 27 August 8 CE (Gregorian).
        @memberof EthiopianCalendar */
    jdEpoch: 1724220.5,
    /** Days per month in a common year.
        @memberof EthiopianCalendar */
    daysPerMonth: [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 5],
    /** <code>true</code> if has a year zero, <code>false</code> if not.
        @memberof EthiopianCalendar */
    hasYearZero: false,
    /** The minimum month number.
        @memberof EthiopianCalendar */
    minMonth: 1,
    /** The first month in the year.
        @memberof EthiopianCalendar */
    firstMonth: 1,
    /** The minimum day number.
        @memberof EthiopianCalendar */
    minDay: 1,

    /** Localisations for the plugin.
        Entries are objects indexed by the language code ('' being the default US/English).
        Each object has the following attributes.
        @memberof EthiopianCalendar
        @property name {string} The calendar name.
        @property epochs {string[]} The epoch names.
        @property monthNames {string[]} The long names of the months of the year.
        @property monthNamesShort {string[]} The short names of the months of the year.
        @property dayNames {string[]} The long names of the days of the week.
        @property dayNamesShort {string[]} The short names of the days of the week.
        @property dayNamesMin {string[]} The minimal names of the days of the week.
        @property dateFormat {string} The date format for this calendar.
                See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
        @property firstDay {number} The number of the first day of the week, starting at 0.
        @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
    regionalOptions: { // Localisations
        '': {
            name: 'Ethiopian',
            epochs: ['BEE', 'EE'],
            monthNames: ['Meskerem', 'Tikemet', 'Hidar', 'Tahesas', 'Tir', 'Yekatit',
            'Megabit', 'Miazia', 'Genbot', 'Sene', 'Hamle', 'Nehase', 'Pagume'],
            monthNamesShort: ['Mes', 'Tik', 'Hid', 'Tah', 'Tir', 'Yek',
            'Meg', 'Mia', 'Gen', 'Sen', 'Ham', 'Neh', 'Pag'],
            dayNames: ['Ehud', 'Segno', 'Maksegno', 'Irob', 'Hamus', 'Arb', 'Kidame'],
            dayNamesShort: ['Ehu', 'Seg', 'Mak', 'Iro', 'Ham', 'Arb', 'Kid'],
            dayNamesMin: ['Eh', 'Se', 'Ma', 'Ir', 'Ha', 'Ar', 'Ki'],
            digits: null,
            dateFormat: 'dd/mm/yyyy',
            firstDay: 0,
            isRTL: false
        }
    },

    /** Determine whether this date is in a leap year.
        @memberof EthiopianCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
        @throws Error if an invalid year or a different calendar used. */
    leapYear: function(year) {
        var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        var year = date.year() + (date.year() < 0 ? 1 : 0); // No year zero
        return year % 4 === 3 || year % 4 === -1;
    },

    /** Retrieve the number of months in a year.
        @memberof EthiopianCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {number} The number of months.
        @throws Error if an invalid year or a different calendar used. */
    monthsInYear: function(year) {
        this._validate(year, this.minMonth, this.minDay,
            main.local.invalidYear || main.regionalOptions[''].invalidYear);
        return 13;
    },

    /** Determine the week of the year for a date.
        @memberof EthiopianCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {number} The week of the year.
        @throws Error if an invalid date or a different calendar used. */
    weekOfYear: function(year, month, day) {
        // Find Sunday of this week starting on Sunday
        var checkDate = this.newDate(year, month, day);
        checkDate.add(-checkDate.dayOfWeek(), 'd');
        return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
    },

    /** Retrieve the number of days in a month.
        @memberof EthiopianCalendar
        @param year {CDate|number} The date to examine or the year of the month.
        @param [month] {number} The month.
        @return {number} The number of days in this month.
        @throws Error if an invalid month/year or a different calendar used. */
    daysInMonth: function(year, month) {
        var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
        return this.daysPerMonth[date.month() - 1] +
            (date.month() === 13 && this.leapYear(date.year()) ? 1 : 0);
    },

    /** Determine whether this date is a week day.
        @memberof EthiopianCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
        @throws Error if an invalid date or a different calendar used. */
    weekDay: function(year, month, day) {
        return (this.dayOfWeek(year, month, day) || 7) < 6;
    },

    /** Retrieve the Julian date equivalent for this date,
        i.e. days since January 1, 4713 BCE Greenwich noon.
        @memberof EthiopianCalendar
        @param year {CDate|number} The date to convert or the year to convert.
        @param [month] {number} The month to convert.
        @param [day] {number} The day to convert.
        @return {number} The equivalent Julian date.
        @throws Error if an invalid date or a different calendar used. */
    toJD: function(year, month, day) {
        var date = this._validate(year, month, day, main.local.invalidDate);
        year = date.year();
        if (year < 0) { year++; } // No year zero
        return date.day() + (date.month() - 1) * 30 +
            (year - 1) * 365 + Math.floor(year / 4) + this.jdEpoch - 1;
    },

    /** Create a new date from a Julian date.
        @memberof EthiopianCalendar
        @param jd {number} the Julian date to convert.
        @return {CDate} the equivalent date. */
    fromJD: function(jd) {
        var c = Math.floor(jd) + 0.5 - this.jdEpoch;
        var year = Math.floor((c - Math.floor((c + 366) / 1461)) / 365) + 1;
        if (year <= 0) { year--; } // No year zero
        c = Math.floor(jd) + 0.5 - this.newDate(year, 1, 1).toJD();
        var month = Math.floor(c / 30) + 1;
        var day = c - (month - 1) * 30 + 1;
        return this.newDate(year, month, day);
    }
});

// Ethiopian calendar implementation
main.calendars.ethiopian = EthiopianCalendar;



/***/ }),

/***/ 9384:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/*
 * World Calendars
 * https://github.com/alexcjohnson/world-calendars
 *
 * Batch-converted from kbwood/calendars
 * Many thanks to Keith Wood and all of the contributors to the original project!
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

﻿/* http://keith-wood.name/calendars.html
   Hebrew calendar for jQuery v2.0.2.
   Written by Keith Wood (wood.keith{at}optusnet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

var main = __webpack_require__(3489);
var assign = __webpack_require__(6131);


/** Implementation of the Hebrew civil calendar.
    Based on code from <a href="http://www.fourmilab.ch/documents/calendar/">http://www.fourmilab.ch/documents/calendar/</a>.
    See also <a href="http://en.wikipedia.org/wiki/Hebrew_calendar">http://en.wikipedia.org/wiki/Hebrew_calendar</a>.
    @class HebrewCalendar
    @param [language=''] {string} The language code (default English) for localisation. */
function HebrewCalendar(language) {
    this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
}

HebrewCalendar.prototype = new main.baseCalendar;

assign(HebrewCalendar.prototype, {
    /** The calendar name.
        @memberof HebrewCalendar */
    name: 'Hebrew',
    /** Julian date of start of Hebrew epoch: 7 October 3761 BCE.
        @memberof HebrewCalendar */
    jdEpoch: 347995.5,
    /** Days per month in a common year.
        @memberof HebrewCalendar */
    daysPerMonth: [30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 29],
    /** <code>true</code> if has a year zero, <code>false</code> if not.
        @memberof HebrewCalendar */
    hasYearZero: false,
    /** The minimum month number.
        @memberof HebrewCalendar */
    minMonth: 1,
    /** The first month in the year.
        @memberof HebrewCalendar */
    firstMonth: 7,
    /** The minimum day number.
        @memberof HebrewCalendar */
    minDay: 1,

    /** Localisations for the plugin.
        Entries are objects indexed by the language code ('' being the default US/English).
        Each object has the following attributes.
        @memberof HebrewCalendar
        @property name {string} The calendar name.
        @property epochs {string[]} The epoch names.
        @property monthNames {string[]} The long names of the months of the year.
        @property monthNamesShort {string[]} The short names of the months of the year.
        @property dayNames {string[]} The long names of the days of the week.
        @property dayNamesShort {string[]} The short names of the days of the week.
        @property dayNamesMin {string[]} The minimal names of the days of the week.
        @property dateFormat {string} The date format for this calendar.
                See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
        @property firstDay {number} The number of the first day of the week, starting at 0.
        @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
    regionalOptions: { // Localisations
        '': {
            name: 'Hebrew',
            epochs: ['BAM', 'AM'],
            monthNames: ['Nisan', 'Iyar', 'Sivan', 'Tammuz', 'Av', 'Elul',
            'Tishrei', 'Cheshvan', 'Kislev', 'Tevet', 'Shevat', 'Adar', 'Adar II'],
            monthNamesShort: ['Nis', 'Iya', 'Siv', 'Tam', 'Av', 'Elu', 'Tis', 'Che', 'Kis', 'Tev', 'She', 'Ada', 'Ad2'],
            dayNames: ['Yom Rishon', 'Yom Sheni', 'Yom Shlishi', 'Yom Revi\'i', 'Yom Chamishi', 'Yom Shishi', 'Yom Shabbat'],
            dayNamesShort: ['Ris', 'She', 'Shl', 'Rev', 'Cha', 'Shi', 'Sha'],
            dayNamesMin: ['Ri','She','Shl','Re','Ch','Shi','Sha'],
            digits: null,
            dateFormat: 'dd/mm/yyyy',
            firstDay: 0,
            isRTL: false
        }
    },

    /** Determine whether this date is in a leap year.
        @memberof HebrewCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
        @throws Error if an invalid year or a different calendar used. */
    leapYear: function(year) {
        var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        return this._leapYear(date.year());
    },

    /** Determine whether this date is in a leap year.
        @memberof HebrewCalendar
        @private
        @param year {number} The year to examine.
        @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
        @throws Error if an invalid year or a different calendar used. */
    _leapYear: function(year) {
        year = (year < 0 ? year + 1 : year);
        return mod(year * 7 + 1, 19) < 7;
    },

    /** Retrieve the number of months in a year.
        @memberof HebrewCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {number} The number of months.
        @throws Error if an invalid year or a different calendar used. */
    monthsInYear: function(year) {
        this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        return this._leapYear(year.year ? year.year() : year) ? 13 : 12;
    },

    /** Determine the week of the year for a date.
        @memberof HebrewCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {number} The week of the year.
        @throws Error if an invalid date or a different calendar used. */
    weekOfYear: function(year, month, day) {
        // Find Sunday of this week starting on Sunday
        var checkDate = this.newDate(year, month, day);
        checkDate.add(-checkDate.dayOfWeek(), 'd');
        return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
    },

    /** Retrieve the number of days in a year.
        @memberof HebrewCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {number} The number of days.
        @throws Error if an invalid year or a different calendar used. */
    daysInYear: function(year) {
        var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        year = date.year();
        return this.toJD((year === -1 ? +1 : year + 1), 7, 1) - this.toJD(year, 7, 1);
    },

    /** Retrieve the number of days in a month.
        @memberof HebrewCalendar
        @param year {CDate|number} The date to examine or the year of the month.
        @param [month] {number} The month.
        @return {number} The number of days in this month.
        @throws Error if an invalid month/year or a different calendar used. */
    daysInMonth: function(year, month) {
        if (year.year) {
            month = year.month();
            year = year.year();
        }
        this._validate(year, month, this.minDay, main.local.invalidMonth);
        return (month === 12 && this.leapYear(year) ? 30 : // Adar I
                (month === 8 && mod(this.daysInYear(year), 10) === 5 ? 30 : // Cheshvan in shlemah year
                (month === 9 && mod(this.daysInYear(year), 10) === 3 ? 29 : // Kislev in chaserah year
                this.daysPerMonth[month - 1])));
    },

    /** Determine whether this date is a week day.
        @memberof HebrewCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
        @throws Error if an invalid date or a different calendar used. */
    weekDay: function(year, month, day) {
        return this.dayOfWeek(year, month, day) !== 6;
    },

    /** Retrieve additional information about a date - year type.
        @memberof HebrewCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {object} Additional information - contents depends on calendar.
        @throws Error if an invalid date or a different calendar used. */
    extraInfo: function(year, month, day) {
        var date = this._validate(year, month, day, main.local.invalidDate);
        return {yearType: (this.leapYear(date) ? 'embolismic' : 'common') + ' ' +
            ['deficient', 'regular', 'complete'][this.daysInYear(date) % 10 - 3]};
    },

    /** Retrieve the Julian date equivalent for this date,
        i.e. days since January 1, 4713 BCE Greenwich noon.
        @memberof HebrewCalendar
        @param year {CDate)|number} The date to convert or the year to convert.
        @param [month] {number} The month to convert.
        @param [day] {number} The day to convert.
        @return {number} The equivalent Julian date.
        @throws Error if an invalid date or a different calendar used. */
    toJD: function(year, month, day) {
        var date = this._validate(year, month, day, main.local.invalidDate);
        year = date.year();
        month = date.month();
        day = date.day();
        var adjYear = (year <= 0 ? year + 1 : year);
        var jd = this.jdEpoch + this._delay1(adjYear) +
            this._delay2(adjYear) + day + 1;
        if (month < 7) {
            for (var m = 7; m <= this.monthsInYear(year); m++) {
                jd += this.daysInMonth(year, m);
            }
            for (var m = 1; m < month; m++) {
                jd += this.daysInMonth(year, m);
            }
        }
        else {
            for (var m = 7; m < month; m++) {
                jd += this.daysInMonth(year, m);
            }
        }
        return jd;
    },

    /** Test for delay of start of new year and to avoid
        Sunday, Wednesday, or Friday as start of the new year.
        @memberof HebrewCalendar
        @private
        @param year {number} The year to examine.
        @return {number} The days to offset by. */
    _delay1: function(year) {
        var months = Math.floor((235 * year - 234) / 19);
        var parts = 12084 + 13753 * months;
        var day = months * 29 + Math.floor(parts / 25920);
        if (mod(3 * (day + 1), 7) < 3) {
            day++;
        }
        return day;
    },

    /** Check for delay in start of new year due to length of adjacent years.
        @memberof HebrewCalendar
        @private
        @param year {number} The year to examine.
        @return {number} The days to offset by. */
    _delay2: function(year) {
        var last = this._delay1(year - 1);
        var present = this._delay1(year);
        var next = this._delay1(year + 1);
        return ((next - present) === 356 ? 2 : ((present - last) === 382 ? 1 : 0));
    },

    /** Create a new date from a Julian date.
        @memberof HebrewCalendar
        @param jd {number} The Julian date to convert.
        @return {CDate} The equivalent date. */
    fromJD: function(jd) {
        jd = Math.floor(jd) + 0.5;
        var year = Math.floor(((jd - this.jdEpoch) * 98496.0) / 35975351.0) - 1;
        while (jd >= this.toJD((year === -1 ? +1 : year + 1), 7, 1)) {
            year++;
        }
        var month = (jd < this.toJD(year, 1, 1)) ? 7 : 1;
        while (jd > this.toJD(year, month, this.daysInMonth(year, month))) {
            month++;
        }
        var day = jd - this.toJD(year, month, 1) + 1;
        return this.newDate(year, month, day);
    }
});

// Modulus function which works for non-integers.
function mod(a, b) {
    return a - (b * Math.floor(a / b));
}

// Hebrew calendar implementation
main.calendars.hebrew = HebrewCalendar;



/***/ }),

/***/ 3805:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/*
 * World Calendars
 * https://github.com/alexcjohnson/world-calendars
 *
 * Batch-converted from kbwood/calendars
 * Many thanks to Keith Wood and all of the contributors to the original project!
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

﻿/* http://keith-wood.name/calendars.html
   Islamic calendar for jQuery v2.0.2.
   Written by Keith Wood (wood.keith{at}optusnet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

var main = __webpack_require__(3489);
var assign = __webpack_require__(6131);


/** Implementation of the Islamic or '16 civil' calendar.
    Based on code from <a href="http://www.iranchamber.com/calendar/converter/iranian_calendar_converter.php">http://www.iranchamber.com/calendar/converter/iranian_calendar_converter.php</a>.
    See also <a href="http://en.wikipedia.org/wiki/Islamic_calendar">http://en.wikipedia.org/wiki/Islamic_calendar</a>.
    @class IslamicCalendar
    @param [language=''] {string} The language code (default English) for localisation. */
function IslamicCalendar(language) {
    this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
}

IslamicCalendar.prototype = new main.baseCalendar;

assign(IslamicCalendar.prototype, {
    /** The calendar name.
        @memberof IslamicCalendar */
    name: 'Islamic',
    /** Julian date of start of Islamic epoch: 16 July 622 CE.
        @memberof IslamicCalendar */
    jdEpoch: 1948439.5,
    /** Days per month in a common year.
        @memberof IslamicCalendar */
    daysPerMonth: [30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29],
    /** <code>true</code> if has a year zero, <code>false</code> if not.
        @memberof IslamicCalendar */
    hasYearZero: false,
    /** The minimum month number.
        @memberof IslamicCalendar */
    minMonth: 1,
    /** The first month in the year.
        @memberof IslamicCalendar */
    firstMonth: 1,
    /** The minimum day number.
        @memberof IslamicCalendar */
    minDay: 1,

    /** Localisations for the plugin.
        Entries are objects indexed by the language code ('' being the default US/English).
        Each object has the following attributes.
        @memberof IslamicCalendar
        @property name {string} The calendar name.
        @property epochs {string[]} The epoch names.
        @property monthNames {string[]} The long names of the months of the year.
        @property monthNamesShort {string[]} The short names of the months of the year.
        @property dayNames {string[]} The long names of the days of the week.
        @property dayNamesShort {string[]} The short names of the days of the week.
        @property dayNamesMin {string[]} The minimal names of the days of the week.
        @property dateFormat {string} The date format for this calendar.
                See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
        @property firstDay {number} The number of the first day of the week, starting at 0.
        @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
    regionalOptions: { // Localisations
        '': {
            name: 'Islamic',
            epochs: ['BH', 'AH'],
            monthNames: ['Muharram', 'Safar', 'Rabi\' al-awwal', 'Rabi\' al-thani', 'Jumada al-awwal', 'Jumada al-thani',
            'Rajab', 'Sha\'aban', 'Ramadan', 'Shawwal', 'Dhu al-Qi\'dah', 'Dhu al-Hijjah'],
            monthNamesShort: ['Muh', 'Saf', 'Rab1', 'Rab2', 'Jum1', 'Jum2', 'Raj', 'Sha\'', 'Ram', 'Shaw', 'DhuQ', 'DhuH'],
            dayNames: ['Yawm al-ahad', 'Yawm al-ithnayn', 'Yawm ath-thulaathaa\'',
            'Yawm al-arbi\'aa\'', 'Yawm al-khamīs', 'Yawm al-jum\'a', 'Yawm as-sabt'],
            dayNamesShort: ['Aha', 'Ith', 'Thu', 'Arb', 'Kha', 'Jum', 'Sab'],
            dayNamesMin: ['Ah','It','Th','Ar','Kh','Ju','Sa'],
            digits: null,
            dateFormat: 'yyyy/mm/dd',
            firstDay: 6,
            isRTL: false
        }
    },

    /** Determine whether this date is in a leap year.
        @memberof IslamicCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
        @throws Error if an invalid year or a different calendar used. */
    leapYear: function(year) {
        var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        return (date.year() * 11 + 14) % 30 < 11;
    },

    /** Determine the week of the year for a date.
        @memberof IslamicCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {number} The week of the year.
        @throws Error if an invalid date or a different calendar used. */
    weekOfYear: function(year, month, day) {
        // Find Sunday of this week starting on Sunday
        var checkDate = this.newDate(year, month, day);
        checkDate.add(-checkDate.dayOfWeek(), 'd');
        return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
    },

    /** Retrieve the number of days in a year.
        @memberof IslamicCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {number} The number of days.
        @throws Error if an invalid year or a different calendar used. */
    daysInYear: function(year) {
        return (this.leapYear(year) ? 355 : 354);
    },

    /** Retrieve the number of days in a month.
        @memberof IslamicCalendar
        @param year {CDate|number} The date to examine or the year of the month.
        @param [month] {number} The month.
        @return {number} The number of days in this month.
        @throws Error if an invalid month/year or a different calendar used. */
    daysInMonth: function(year, month) {
        var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
        return this.daysPerMonth[date.month() - 1] +
            (date.month() === 12 && this.leapYear(date.year()) ? 1 : 0);
    },

    /** Determine whether this date is a week day.
        @memberof IslamicCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
        @throws Error if an invalid date or a different calendar used. */
    weekDay: function(year, month, day) {
        return this.dayOfWeek(year, month, day) !== 5;
    },

    /** Retrieve the Julian date equivalent for this date,
        i.e. days since January 1, 4713 BCE Greenwich noon.
        @memberof IslamicCalendar
        @param year {CDate|number} The date to convert or the year to convert.
        @param [month] {number} The month to convert.
        @param [day] {number} The day to convert.
        @return {number} The equivalent Julian date.
        @throws Error if an invalid date or a different calendar used. */
    toJD: function(year, month, day) {
        var date = this._validate(year, month, day, main.local.invalidDate);
        year = date.year();
        month = date.month();
        day = date.day();
        year = (year <= 0 ? year + 1 : year);
        return day + Math.ceil(29.5 * (month - 1)) + (year - 1) * 354 +
            Math.floor((3 + (11 * year)) / 30) + this.jdEpoch - 1;
    },

    /** Create a new date from a Julian date.
        @memberof IslamicCalendar
        @param jd {number} The Julian date to convert.
        @return {CDate} The equivalent date. */
    fromJD: function(jd) {
        jd = Math.floor(jd) + 0.5;
        var year = Math.floor((30 * (jd - this.jdEpoch) + 10646) / 10631);
        year = (year <= 0 ? year - 1 : year);
        var month = Math.min(12, Math.ceil((jd - 29 - this.toJD(year, 1, 1)) / 29.5) + 1);
        var day = jd - this.toJD(year, month, 1) + 1;
        return this.newDate(year, month, day);
    }
});

// Islamic (16 civil) calendar implementation
main.calendars.islamic = IslamicCalendar;



/***/ }),

/***/ 8874:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/*
 * World Calendars
 * https://github.com/alexcjohnson/world-calendars
 *
 * Batch-converted from kbwood/calendars
 * Many thanks to Keith Wood and all of the contributors to the original project!
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

﻿/* http://keith-wood.name/calendars.html
   Julian calendar for jQuery v2.0.2.
   Written by Keith Wood (wood.keith{at}optusnet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

var main = __webpack_require__(3489);
var assign = __webpack_require__(6131);


/** Implementation of the Julian calendar.
    Based on code from <a href="http://www.fourmilab.ch/documents/calendar/">http://www.fourmilab.ch/documents/calendar/</a>.
    See also <a href="http://en.wikipedia.org/wiki/Julian_calendar">http://en.wikipedia.org/wiki/Julian_calendar</a>.
    @class JulianCalendar
    @augments BaseCalendar
    @param [language=''] {string} The language code (default English) for localisation. */
function JulianCalendar(language) {
    this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
}

JulianCalendar.prototype = new main.baseCalendar;

assign(JulianCalendar.prototype, {
    /** The calendar name.
        @memberof JulianCalendar */
    name: 'Julian',
    /** Julian date of start of Julian epoch: 1 January 0001 AD = 30 December 0001 BCE.
        @memberof JulianCalendar */
    jdEpoch: 1721423.5,
    /** Days per month in a common year.
        @memberof JulianCalendar */
    daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    /** <code>true</code> if has a year zero, <code>false</code> if not.
        @memberof JulianCalendar */
    hasYearZero: false,
    /** The minimum month number.
        @memberof JulianCalendar */
    minMonth: 1,
    /** The first month in the year.
        @memberof JulianCalendar */
    firstMonth: 1,
    /** The minimum day number.
        @memberof JulianCalendar */
    minDay: 1,

    /** Localisations for the plugin.
        Entries are objects indexed by the language code ('' being the default US/English).
        Each object has the following attributes.
        @memberof JulianCalendar
        @property name {string} The calendar name.
        @property epochs {string[]} The epoch names.
        @property monthNames {string[]} The long names of the months of the year.
        @property monthNamesShort {string[]} The short names of the months of the year.
        @property dayNames {string[]} The long names of the days of the week.
        @property dayNamesShort {string[]} The short names of the days of the week.
        @property dayNamesMin {string[]} The minimal names of the days of the week.
        @property dateFormat {string} The date format for this calendar.
                See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
        @property firstDay {number} The number of the first day of the week, starting at 0.
        @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
    regionalOptions: { // Localisations
        '': {
            name: 'Julian',
            epochs: ['BC', 'AD'],
            monthNames: ['January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'],
            monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
            digits: null,
            dateFormat: 'mm/dd/yyyy',
            firstDay: 0,
            isRTL: false
        }
    },

    /** Determine whether this date is in a leap year.
        @memberof JulianCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
        @throws Error if an invalid year or a different calendar used. */
    leapYear: function(year) {
        var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        var year = (date.year() < 0 ? date.year() + 1 : date.year()); // No year zero
        return (year % 4) === 0;
    },

    /** Determine the week of the year for a date - ISO 8601.
        @memberof JulianCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {number} The week of the year.
        @throws Error if an invalid date or a different calendar used. */
    weekOfYear: function(year, month, day) {
        // Find Thursday of this week starting on Monday
        var checkDate = this.newDate(year, month, day);
        checkDate.add(4 - (checkDate.dayOfWeek() || 7), 'd');
        return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
    },

    /** Retrieve the number of days in a month.
        @memberof JulianCalendar
        @param year {CDate|number} The date to examine or the year of the month.
        @param [month] {number} The month.
        @return {number} The number of days in this month.
        @throws Error if an invalid month/year or a different calendar used. */
    daysInMonth: function(year, month) {
        var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
        return this.daysPerMonth[date.month() - 1] +
            (date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
    },

    /** Determine whether this date is a week day.
        @memberof JulianCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {boolean} True if a week day, false if not.
        @throws Error if an invalid date or a different calendar used. */
    weekDay: function(year, month, day) {
        return (this.dayOfWeek(year, month, day) || 7) < 6;
    },

    /** Retrieve the Julian date equivalent for this date,
        i.e. days since January 1, 4713 BCE Greenwich noon.
        @memberof JulianCalendar
        @param year {CDate|number} The date to convert or the year to convert.
        @param [month] {number} The month to convert.
        @param [day] {number} The day to convert.
        @return {number} The equivalent Julian date.
        @throws Error if an invalid date or a different calendar used. */
    toJD: function(year, month, day) {
        var date = this._validate(year, month, day, main.local.invalidDate);
        year = date.year();
        month = date.month();
        day = date.day();
        if (year < 0) { year++; } // No year zero
        // Jean Meeus algorithm, "Astronomical Algorithms", 1991
        if (month <= 2) {
            year--;
            month += 12;
        }
        return Math.floor(365.25 * (year + 4716)) +
            Math.floor(30.6001 * (month + 1)) + day - 1524.5;
    },

    /** Create a new date from a Julian date.
        @memberof JulianCalendar
        @param jd {number} The Julian date to convert.
        @return {CDate} The equivalent date. */
    fromJD: function(jd) {
        // Jean Meeus algorithm, "Astronomical Algorithms", 1991
        var a = Math.floor(jd + 0.5);
        var b = a + 1524;
        var c = Math.floor((b - 122.1) / 365.25);
        var d = Math.floor(365.25 * c);
        var e = Math.floor((b - d) / 30.6001);
        var month = e - Math.floor(e < 14 ? 1 : 13);
        var year = c - Math.floor(month > 2 ? 4716 : 4715);
        var day = b - d - Math.floor(30.6001 * e);
        if (year <= 0) { year--; } // No year zero
        return this.newDate(year, month, day);
    }
});

// Julian calendar implementation
main.calendars.julian = JulianCalendar;



/***/ }),

/***/ 3290:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/*
 * World Calendars
 * https://github.com/alexcjohnson/world-calendars
 *
 * Batch-converted from kbwood/calendars
 * Many thanks to Keith Wood and all of the contributors to the original project!
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

﻿/* http://keith-wood.name/calendars.html
   Mayan calendar for jQuery v2.0.2.
   Written by Keith Wood (wood.keith{at}optusnet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

var main = __webpack_require__(3489);
var assign = __webpack_require__(6131);


/** Implementation of the Mayan Long Count calendar.
    See also <a href="http://en.wikipedia.org/wiki/Mayan_calendar">http://en.wikipedia.org/wiki/Mayan_calendar</a>.
    @class MayanCalendar
    @param [language=''] {string} The language code (default English) for localisation. */
function MayanCalendar(language) {
    this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
}

MayanCalendar.prototype = new main.baseCalendar;

assign(MayanCalendar.prototype, {
    /** The calendar name.
        @memberof MayanCalendar */
    name: 'Mayan',
    /** Julian date of start of Mayan epoch: 11 August 3114 BCE.
        @memberof MayanCalendar */
    jdEpoch: 584282.5,
    /** <code>true</code> if has a year zero, <code>false</code> if not.
        @memberof MayanCalendar */
    hasYearZero: true,
    /** The minimum month number.
        @memberof MayanCalendar */
    minMonth: 0,
    /** The first month in the year.
        @memberof MayanCalendar */
    firstMonth: 0,
    /** The minimum day number.
        @memberof MayanCalendar */
    minDay: 0,

    /** Localisations for the plugin.
        Entries are objects indexed by the language code ('' being the default US/English).
        Each object has the following attributes.
        @memberof MayanCalendar
        @property name {string} The calendar name.
        @property epochs {string[]} The epoch names.
        @property monthNames {string[]} The long names of the months of the year.
        @property monthNamesShort {string[]} The short names of the months of the year.
        @property dayNames {string[]} The long names of the days of the week.
        @property dayNamesShort {string[]} The short names of the days of the week.
        @property dayNamesMin {string[]} The minimal names of the days of the week.
        @property dateFormat {string} The date format for this calendar.
                See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
        @property firstDay {number} The number of the first day of the week, starting at 0.
        @property isRTL {number} <code>true</code> if this localisation reads right-to-left.
        @property haabMonths {string[]} The names of the Haab months.
        @property tzolkinMonths {string[]} The names of the Tzolkin months. */
    regionalOptions: { // Localisations
        '': {
            name: 'Mayan',
            epochs: ['', ''],
            monthNames: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '10', '11', '12', '13', '14', '15', '16', '17'],
            monthNamesShort: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '10', '11', '12', '13', '14', '15', '16', '17'],
            dayNames: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '10', '11', '12', '13', '14', '15', '16', '17', '18', '19'],
            dayNamesShort: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '10', '11', '12', '13', '14', '15', '16', '17', '18', '19'],
            dayNamesMin: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '10', '11', '12', '13', '14', '15', '16', '17', '18', '19'],
            digits: null,
            dateFormat: 'YYYY.m.d',
            firstDay: 0,
            isRTL: false,
            haabMonths: ['Pop', 'Uo', 'Zip', 'Zotz', 'Tzec', 'Xul', 'Yaxkin', 'Mol', 'Chen', 'Yax',
            'Zac', 'Ceh', 'Mac', 'Kankin', 'Muan', 'Pax', 'Kayab', 'Cumku', 'Uayeb'],
            tzolkinMonths: ['Imix', 'Ik', 'Akbal', 'Kan', 'Chicchan', 'Cimi', 'Manik', 'Lamat', 'Muluc', 'Oc',
            'Chuen', 'Eb', 'Ben', 'Ix', 'Men', 'Cib', 'Caban', 'Etznab', 'Cauac', 'Ahau']
        }
    },

    /** Determine whether this date is in a leap year.
        @memberof MayanCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
        @throws Error if an invalid year or a different calendar used. */
    leapYear: function(year) {
        this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        return false;
    },

    /** Format the year, if not a simple sequential number.
        @memberof MayanCalendar
        @param year {CDate|number} The date to format or the year to format.
        @return {string} The formatted year.
        @throws Error if an invalid year or a different calendar used. */
    formatYear: function(year) {
        var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        year = date.year();
        var baktun = Math.floor(year / 400);
        year = year % 400;
        year += (year < 0 ? 400 : 0);
        var katun = Math.floor(year / 20);
        return baktun + '.' + katun + '.' + (year % 20);
    },

    /** Convert from the formatted year back to a single number.
        @memberof MayanCalendar
        @param years {string} The year as n.n.n.
        @return {number} The sequential year.
        @throws Error if an invalid value is supplied. */
    forYear: function(years) {
        years = years.split('.');
        if (years.length < 3) {
            throw 'Invalid Mayan year';
        }
        var year = 0;
        for (var i = 0; i < years.length; i++) {
            var y = parseInt(years[i], 10);
            if (Math.abs(y) > 19 || (i > 0 && y < 0)) {
                throw 'Invalid Mayan year';
            }
            year = year * 20 + y;
        }
        return year;
    },

    /** Retrieve the number of months in a year.
        @memberof MayanCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {number} The number of months.
        @throws Error if an invalid year or a different calendar used. */
    monthsInYear: function(year) {
        this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        return 18;
    },

    /** Determine the week of the year for a date.
        @memberof MayanCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {number} The week of the year.
        @throws Error if an invalid date or a different calendar used. */
    weekOfYear: function(year, month, day) {
        this._validate(year, month, day, main.local.invalidDate);
        return 0;
    },

    /** Retrieve the number of days in a year.
        @memberof MayanCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {number} The number of days.
        @throws Error if an invalid year or a different calendar used. */
    daysInYear: function(year) {
        this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        return 360;
    },

    /** Retrieve the number of days in a month.
        @memberof MayanCalendar
        @param year {CDate|number} The date to examine or the year of the month.
        @param [month] {number} The month.
        @return {number} The number of days in this month.
        @throws Error if an invalid month/year or a different calendar used. */
    daysInMonth: function(year, month) {
        this._validate(year, month, this.minDay, main.local.invalidMonth);
        return 20;
    },

    /** Retrieve the number of days in a week.
        @memberof MayanCalendar
        @return {number} The number of days. */
    daysInWeek: function() {
        return 5; // Just for formatting
    },

    /** Retrieve the day of the week for a date.
        @memberof MayanCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {number} The day of the week: 0 to number of days - 1.
        @throws Error if an invalid date or a different calendar used. */
    dayOfWeek: function(year, month, day) {
        var date = this._validate(year, month, day, main.local.invalidDate);
        return date.day();
    },

    /** Determine whether this date is a week day.
        @memberof MayanCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
        @throws Error if an invalid date or a different calendar used. */
    weekDay: function(year, month, day) {
        this._validate(year, month, day, main.local.invalidDate);
        return true;
    },

    /** Retrieve additional information about a date - Haab and Tzolkin equivalents.
        @memberof MayanCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {object} Additional information - contents depends on calendar.
        @throws Error if an invalid date or a different calendar used. */
    extraInfo: function(year, month, day) {
        var date = this._validate(year, month, day, main.local.invalidDate);
        var jd = date.toJD();
        var haab = this._toHaab(jd);
        var tzolkin = this._toTzolkin(jd);
        return {haabMonthName: this.local.haabMonths[haab[0] - 1],
            haabMonth: haab[0], haabDay: haab[1],
            tzolkinDayName: this.local.tzolkinMonths[tzolkin[0] - 1],
            tzolkinDay: tzolkin[0], tzolkinTrecena: tzolkin[1]};
    },

    /** Retrieve Haab date from a Julian date.
        @memberof MayanCalendar
        @private
        @param jd  {number} The Julian date.
        @return {number[]} Corresponding Haab month and day. */
    _toHaab: function(jd) {
        jd -= this.jdEpoch;
        var day = mod(jd + 8 + ((18 - 1) * 20), 365);
        return [Math.floor(day / 20) + 1, mod(day, 20)];
    },

    /** Retrieve Tzolkin date from a Julian date.
        @memberof MayanCalendar
        @private
        @param jd {number} The Julian date.
        @return {number[]} Corresponding Tzolkin day and trecena. */
    _toTzolkin: function(jd) {
        jd -= this.jdEpoch;
        return [amod(jd + 20, 20), amod(jd + 4, 13)];
    },

    /** Retrieve the Julian date equivalent for this date,
        i.e. days since January 1, 4713 BCE Greenwich noon.
        @memberof MayanCalendar
        @param year {CDate|number} The date to convert or the year to convert.
        @param [month] {number} The month to convert.
        @param [day] {number} The day to convert.
        @return {number} The equivalent Julian date.
        @throws Error if an invalid date or a different calendar used. */
    toJD: function(year, month, day) {
        var date = this._validate(year, month, day, main.local.invalidDate);
        return date.day() + (date.month() * 20) + (date.year() * 360) + this.jdEpoch;
    },

    /** Create a new date from a Julian date.
        @memberof MayanCalendar
        @param jd {number} The Julian date to convert.
        @return {CDate} The equivalent date. */
    fromJD: function(jd) {
        jd = Math.floor(jd) + 0.5 - this.jdEpoch;
        var year = Math.floor(jd / 360);
        jd = jd % 360;
        jd += (jd < 0 ? 360 : 0);
        var month = Math.floor(jd / 20);
        var day = jd % 20;
        return this.newDate(year, month, day);
    }
});

// Modulus function which works for non-integers.
function mod(a, b) {
    return a - (b * Math.floor(a / b));
}

// Modulus function which returns numerator if modulus is zero.
function amod(a, b) {
    return mod(a - 1, b) + 1;
}

// Mayan calendar implementation
main.calendars.mayan = MayanCalendar;



/***/ }),

/***/ 9108:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/*
 * World Calendars
 * https://github.com/alexcjohnson/world-calendars
 *
 * Batch-converted from kbwood/calendars
 * Many thanks to Keith Wood and all of the contributors to the original project!
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/* http://keith-wood.name/calendars.html
   Nanakshahi calendar for jQuery v2.0.2.
   Written by Keith Wood (wood.keith{at}optusnet.com.au) January 2016.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

var main = __webpack_require__(3489);
var assign = __webpack_require__(6131);


/** Implementation of the Nanakshahi calendar.
    See also <a href="https://en.wikipedia.org/wiki/Nanakshahi_calendar">https://en.wikipedia.org/wiki/Nanakshahi_calendar</a>.
    @class NanakshahiCalendar
    @param [language=''] {string} The language code (default English) for localisation. */
function NanakshahiCalendar(language) {
    this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
}

NanakshahiCalendar.prototype = new main.baseCalendar;

var gregorian = main.instance('gregorian');

assign(NanakshahiCalendar.prototype, {
    /** The calendar name.
        @memberof NanakshahiCalendar */
    name: 'Nanakshahi',
    /** Julian date of start of Nanakshahi epoch: 14 March 1469 CE.
        @memberof NanakshahiCalendar */
    jdEpoch: 2257673.5,
    /** Days per month in a common year.
        @memberof NanakshahiCalendar */
    daysPerMonth: [31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 30, 30],
    /** <code>true</code> if has a year zero, <code>false</code> if not.
        @memberof NanakshahiCalendar */
    hasYearZero: false,
    /** The minimum month number.
        @memberof NanakshahiCalendar */
    minMonth: 1,
    /** The first month in the year.
        @memberof NanakshahiCalendar */
    firstMonth: 1,
    /** The minimum day number.
        @memberof NanakshahiCalendar */
    minDay: 1,

    /** Localisations for the plugin.
        Entries are objects indexed by the language code ('' being the default US/English).
        Each object has the following attributes.
        @memberof NanakshahiCalendar
        @property name {string} The calendar name.
        @property epochs {string[]} The epoch names.
        @property monthNames {string[]} The long names of the months of the year.
        @property monthNamesShort {string[]} The short names of the months of the year.
        @property dayNames {string[]} The long names of the days of the week.
        @property dayNamesShort {string[]} The short names of the days of the week.
        @property dayNamesMin {string[]} The minimal names of the days of the week.
        @property dateFormat {string} The date format for this calendar.
                See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
        @property firstDay {number} The number of the first day of the week, starting at 0.
        @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
    regionalOptions: { // Localisations
        '': {
            name: 'Nanakshahi',
            epochs: ['BN', 'AN'],
            monthNames: ['Chet', 'Vaisakh', 'Jeth', 'Harh', 'Sawan', 'Bhadon',
            'Assu', 'Katak', 'Maghar', 'Poh', 'Magh', 'Phagun'],
            monthNamesShort: ['Che', 'Vai', 'Jet', 'Har', 'Saw', 'Bha', 'Ass', 'Kat', 'Mgr', 'Poh', 'Mgh', 'Pha'],
            dayNames: ['Somvaar', 'Mangalvar', 'Budhvaar', 'Veervaar', 'Shukarvaar', 'Sanicharvaar', 'Etvaar'],
            dayNamesShort: ['Som', 'Mangal', 'Budh', 'Veer', 'Shukar', 'Sanichar', 'Et'],
            dayNamesMin: ['So', 'Ma', 'Bu', 'Ve', 'Sh', 'Sa', 'Et'],
            digits: null,
            dateFormat: 'dd-mm-yyyy',
            firstDay: 0,
            isRTL: false
        }
    },

    /** Determine whether this date is in a leap year.
        @memberof NanakshahiCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
        @throws Error if an invalid year or a different calendar used. */
    leapYear: function(year) {
        var date = this._validate(year, this.minMonth, this.minDay,
            main.local.invalidYear || main.regionalOptions[''].invalidYear);
        return gregorian.leapYear(date.year() + (date.year() < 1 ? 1 : 0) + 1469);
    },

    /** Determine the week of the year for a date.
        @memberof NanakshahiCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {number} The week of the year.
        @throws Error if an invalid date or a different calendar used. */
    weekOfYear: function(year, month, day) {
        // Find Monday of this week starting on Monday
        var checkDate = this.newDate(year, month, day);
        checkDate.add(1 - (checkDate.dayOfWeek() || 7), 'd');
        return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
    },

    /** Retrieve the number of days in a month.
        @memberof NanakshahiCalendar
        @param year {CDate|number} The date to examine or the year of the month.
        @param [month] {number} The month.
        @return {number} The number of days in this month.
        @throws Error if an invalid month/year or a different calendar used. */
    daysInMonth: function(year, month) {
        var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
        return this.daysPerMonth[date.month() - 1] +
            (date.month() === 12 && this.leapYear(date.year()) ? 1 : 0);
    },

    /** Determine whether this date is a week day.
        @memberof NanakshahiCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
        @throws Error if an invalid date or a different calendar used. */
    weekDay: function(year, month, day) {
        return (this.dayOfWeek(year, month, day) || 7) < 6;
    },

    /** Retrieve the Julian date equivalent for this date,
        i.e. days since January 1, 4713 BCE Greenwich noon.
        @memberof NanakshahiCalendar
        @param year {CDate|number} The date to convert or the year to convert.
        @param [month] {number} The month to convert.
        @param [day] {number} The day to convert.
        @return {number} The equivalent Julian date.
        @throws Error if an invalid date or a different calendar used. */
    toJD: function(year, month, day) {
        var date = this._validate(year, month, day, main.local.invalidMonth);
        var year = date.year();
        if (year < 0) { year++; } // No year zero
        var doy = date.day();
        for (var m = 1; m < date.month(); m++) {
            doy += this.daysPerMonth[m - 1];
        }
        return doy + gregorian.toJD(year + 1468, 3, 13);
    },

    /** Create a new date from a Julian date.
        @memberof NanakshahiCalendar
        @param jd {number} The Julian date to convert.
        @return {CDate} The equivalent date. */
    fromJD: function(jd) {
        jd = Math.floor(jd + 0.5);
        var year = Math.floor((jd - (this.jdEpoch - 1)) / 366);
        while (jd >= this.toJD(year + 1, 1, 1)) {
            year++;
        }
        var day = jd - Math.floor(this.toJD(year, 1, 1) + 0.5) + 1;
        var month = 1;
        while (day > this.daysInMonth(year, month)) {
            day -= this.daysInMonth(year, month);
            month++;
        }
        return this.newDate(year, month, day);
    }
});

// Nanakshahi calendar implementation
main.calendars.nanakshahi = NanakshahiCalendar;



/***/ }),

/***/ 5422:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/*
 * World Calendars
 * https://github.com/alexcjohnson/world-calendars
 *
 * Batch-converted from kbwood/calendars
 * Many thanks to Keith Wood and all of the contributors to the original project!
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

﻿/* http://keith-wood.name/calendars.html
   Nepali calendar for jQuery v2.0.2.
   Written by Artur Neumann (ict.projects{at}nepal.inf.org) April 2013.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

var main = __webpack_require__(3489);
var assign = __webpack_require__(6131);


/** Implementation of the Nepali civil calendar.
    Based on the ideas from 
    <a href="http://codeissue.com/articles/a04e050dea7468f/algorithm-to-convert-english-date-to-nepali-date-using-c-net">http://codeissue.com/articles/a04e050dea7468f/algorithm-to-convert-english-date-to-nepali-date-using-c-net</a>
    and <a href="http://birenj2ee.blogspot.com/2011/04/nepali-calendar-in-java.html">http://birenj2ee.blogspot.com/2011/04/nepali-calendar-in-java.html</a>
    See also <a href="http://en.wikipedia.org/wiki/Nepali_calendar">http://en.wikipedia.org/wiki/Nepali_calendar</a>
    and <a href="https://en.wikipedia.org/wiki/Bikram_Samwat">https://en.wikipedia.org/wiki/Bikram_Samwat</a>.
    @class NepaliCalendar
    @param [language=''] {string} The language code (default English) for localisation. */
function NepaliCalendar(language) {
    this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
}

NepaliCalendar.prototype = new main.baseCalendar;

assign(NepaliCalendar.prototype, {
    /** The calendar name.
        @memberof NepaliCalendar */
    name: 'Nepali',
    /** Julian date of start of Nepali epoch: 14 April 57 BCE.
        @memberof NepaliCalendar */
    jdEpoch: 1700709.5,
    /** Days per month in a common year.
        @memberof NepaliCalendar */
    daysPerMonth: [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
    /** <code>true</code> if has a year zero, <code>false</code> if not.
        @memberof NepaliCalendar */
    hasYearZero: false,
    /** The minimum month number.
        @memberof NepaliCalendar */
    minMonth: 1,
    /** The first month in the year.
        @memberof NepaliCalendar */
    firstMonth: 1,
    /** The minimum day number.
        @memberof NepaliCalendar */
    minDay: 1, 
    /** The number of days in the year.
        @memberof NepaliCalendar */
    daysPerYear: 365,

    /** Localisations for the plugin.
        Entries are objects indexed by the language code ('' being the default US/English).
        Each object has the following attributes.
        @memberof NepaliCalendar
        @property name {string} The calendar name.
        @property epochs {string[]} The epoch names.
        @property monthNames {string[]} The long names of the months of the year.
        @property monthNamesShort {string[]} The short names of the months of the year.
        @property dayNames {string[]} The long names of the days of the week.
        @property dayNamesShort {string[]} The short names of the days of the week.
        @property dayNamesMin {string[]} The minimal names of the days of the week.
        @property dateFormat {string} The date format for this calendar.
                See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
        @property firstDay {number} The number of the first day of the week, starting at 0.
        @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
    regionalOptions: { // Localisations
        '': {
            name: 'Nepali',
            epochs: ['BBS', 'ABS'],
            monthNames: ['Baisakh', 'Jestha', 'Ashadh', 'Shrawan', 'Bhadra', 'Ashwin',
            'Kartik', 'Mangsir', 'Paush', 'Mangh', 'Falgun', 'Chaitra'],
            monthNamesShort: ['Bai', 'Je', 'As', 'Shra', 'Bha', 'Ash', 'Kar', 'Mang', 'Pau', 'Ma', 'Fal', 'Chai'],
            dayNames: ['Aaitabaar', 'Sombaar', 'Manglbaar', 'Budhabaar', 'Bihibaar', 'Shukrabaar', 'Shanibaar'],
            dayNamesShort: ['Aaita', 'Som', 'Mangl', 'Budha', 'Bihi', 'Shukra', 'Shani'],
            dayNamesMin: ['Aai', 'So', 'Man', 'Bu', 'Bi', 'Shu', 'Sha'],
            digits: null,
            dateFormat: 'dd/mm/yyyy',
            firstDay: 1,
            isRTL: false
        }
    },

    /** Determine whether this date is in a leap year.
        @memberof NepaliCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
        @throws Error if an invalid year or a different calendar used. */
    leapYear: function(year) {
        return this.daysInYear(year) !== this.daysPerYear;
    },

    /** Determine the week of the year for a date.
        @memberof NepaliCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {number} The week of the year.
        @throws Error if an invalid date or a different calendar used. */
    weekOfYear: function(year, month, day) {
        // Find Sunday of this week starting on Sunday
        var checkDate = this.newDate(year, month, day);
        checkDate.add(-checkDate.dayOfWeek(), 'd');
        return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
    },

    /** Retrieve the number of days in a year.
        @memberof NepaliCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {number} The number of days.
        @throws Error if an invalid year or a different calendar used. */
    daysInYear: function(year) {
        var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        year = date.year();
        if (typeof this.NEPALI_CALENDAR_DATA[year] === 'undefined') {
            return this.daysPerYear;
        }
        var daysPerYear = 0;
        for (var month_number = this.minMonth; month_number <= 12; month_number++) {
            daysPerYear += this.NEPALI_CALENDAR_DATA[year][month_number];
        }
        return daysPerYear;
    },

    /** Retrieve the number of days in a month.
        @memberof NepaliCalendar
        @param year {CDate|number| The date to examine or the year of the month.
        @param [month] {number} The month.
        @return {number} The number of days in this month.
        @throws Error if an invalid month/year or a different calendar used. */
    daysInMonth: function(year, month) {
        if (year.year) {
            month = year.month();
            year = year.year();
        }
        this._validate(year, month, this.minDay, main.local.invalidMonth);
        return (typeof this.NEPALI_CALENDAR_DATA[year] === 'undefined' ?
            this.daysPerMonth[month - 1] : this.NEPALI_CALENDAR_DATA[year][month]);
    },

    /** Determine whether this date is a week day.
        @memberof NepaliCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
        @throws Error if an invalid date or a different calendar used. */
    weekDay: function(year, month, day) {
        return this.dayOfWeek(year, month, day) !== 6;
    },

    /** Retrieve the Julian date equivalent for this date,
        i.e. days since January 1, 4713 BCE Greenwich noon.
        @memberof NepaliCalendar
        @param year {CDate|number} The date to convert or the year to convert.
        @param [month] {number} The month to convert.
        @param [day] {number} The day to convert.
        @return {number} The equivalent Julian date.
        @throws Error if an invalid date or a different calendar used. */
    toJD: function(nepaliYear, nepaliMonth, nepaliDay) {
        var date = this._validate(nepaliYear, nepaliMonth, nepaliDay, main.local.invalidDate);
        nepaliYear = date.year();
        nepaliMonth = date.month();
        nepaliDay = date.day();
        var gregorianCalendar = main.instance();
        var gregorianDayOfYear = 0; // We will add all the days that went by since
        // the 1st. January and then we can get the Gregorian Date
        var nepaliMonthToCheck = nepaliMonth;
        var nepaliYearToCheck = nepaliYear;
        this._createMissingCalendarData(nepaliYear);
        // Get the correct year
        var gregorianYear = nepaliYear - (nepaliMonthToCheck > 9 || (nepaliMonthToCheck === 9 &&
            nepaliDay >= this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][0]) ? 56 : 57);
        // First we add the amount of days in the actual Nepali month as the day of year in the
        // Gregorian one because at least this days are gone since the 1st. Jan. 
        if (nepaliMonth !== 9) {
            gregorianDayOfYear = nepaliDay;
            nepaliMonthToCheck--;
        }
        // Now we loop throw all Nepali month and add the amount of days to gregorianDayOfYear 
        // we do this till we reach Paush (9th month). 1st. January always falls in this month  
        while (nepaliMonthToCheck !== 9) {
            if (nepaliMonthToCheck <= 0) {
                nepaliMonthToCheck = 12;
                nepaliYearToCheck--;
            }                
            gregorianDayOfYear += this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][nepaliMonthToCheck];
            nepaliMonthToCheck--;
        }        
        // If the date that has to be converted is in Paush (month no. 9) we have to do some other calculation
        if (nepaliMonth === 9) {
            // Add the days that are passed since the first day of Paush and substract the
            // amount of days that lie between 1st. Jan and 1st Paush
            gregorianDayOfYear += nepaliDay - this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][0];
            // For the first days of Paush we are now in negative values,
            // because in the end of the gregorian year we substract
            // 365 / 366 days (P.S. remember math in school + - gives -)
            if (gregorianDayOfYear < 0) {
                gregorianDayOfYear += gregorianCalendar.daysInYear(gregorianYear);
            }
        }
        else {
            gregorianDayOfYear += this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][9] -
                this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][0];
        }        
        return gregorianCalendar.newDate(gregorianYear, 1 ,1).add(gregorianDayOfYear, 'd').toJD();
    },
    
    /** Create a new date from a Julian date.
        @memberof NepaliCalendar
        @param jd {number} The Julian date to convert.
        @return {CDate} The equivalent date. */
    fromJD: function(jd) {
        var gregorianCalendar =  main.instance();
        var gregorianDate = gregorianCalendar.fromJD(jd);
        var gregorianYear = gregorianDate.year();
        var gregorianDayOfYear = gregorianDate.dayOfYear();
        var nepaliYear = gregorianYear + 56; //this is not final, it could be also +57 but +56 is always true for 1st Jan.
        this._createMissingCalendarData(nepaliYear);
        var nepaliMonth = 9; // Jan 1 always fall in Nepali month Paush which is the 9th month of Nepali calendar.
        // Get the Nepali day in Paush (month 9) of 1st January 
        var dayOfFirstJanInPaush = this.NEPALI_CALENDAR_DATA[nepaliYear][0];
        // Check how many days are left of Paush .
        // Days calculated from 1st Jan till the end of the actual Nepali month, 
        // we use this value to check if the gregorian Date is in the actual Nepali month.
        var daysSinceJanFirstToEndOfNepaliMonth =
            this.NEPALI_CALENDAR_DATA[nepaliYear][nepaliMonth] - dayOfFirstJanInPaush + 1;
        // If the gregorian day-of-year is smaller o equal than the sum of days between the 1st January and 
        // the end of the actual nepali month we found the correct nepali month.
        // Example: 
        // The 4th February 2011 is the gregorianDayOfYear 35 (31 days of January + 4)
        // 1st January 2011 is in the nepali year 2067, where 1st. January is in the 17th day of Paush (9th month)
        // In 2067 Paush has 30days, This means (30-17+1=14) there are 14days between 1st January and end of Paush 
        // (including 17th January)
        // The gregorianDayOfYear (35) is bigger than 14, so we check the next month
        // The next nepali month (Mangh) has 29 days 
        // 29+14=43, this is bigger than gregorianDayOfYear(35) so, we found the correct nepali month
        while (gregorianDayOfYear > daysSinceJanFirstToEndOfNepaliMonth) {
            nepaliMonth++;
            if (nepaliMonth > 12) {
                nepaliMonth = 1;
                nepaliYear++;
            }    
            daysSinceJanFirstToEndOfNepaliMonth += this.NEPALI_CALENDAR_DATA[nepaliYear][nepaliMonth];
        }
        // The last step is to calculate the nepali day-of-month
        // to continue our example from before:
        // we calculated there are 43 days from 1st. January (17 Paush) till end of Mangh (29 days)
        // when we subtract from this 43 days the day-of-year of the the Gregorian date (35),
        // we know how far the searched day is away from the end of the Nepali month.
        // So we simply subtract this number from the amount of days in this month (30) 
        var nepaliDayOfMonth = this.NEPALI_CALENDAR_DATA[nepaliYear][nepaliMonth] -
            (daysSinceJanFirstToEndOfNepaliMonth - gregorianDayOfYear);        
        return this.newDate(nepaliYear, nepaliMonth, nepaliDayOfMonth);
    },
    
    /** Creates missing data in the NEPALI_CALENDAR_DATA table.
        This data will not be correct but just give an estimated result. Mostly -/+ 1 day
        @private
        @param nepaliYear {number} The missing year number. */
    _createMissingCalendarData: function(nepaliYear) {
        var tmp_calendar_data = this.daysPerMonth.slice(0);
        tmp_calendar_data.unshift(17);
        for (var nepaliYearToCreate = (nepaliYear - 1); nepaliYearToCreate < (nepaliYear + 2); nepaliYearToCreate++) {
            if (typeof this.NEPALI_CALENDAR_DATA[nepaliYearToCreate] === 'undefined') {
                this.NEPALI_CALENDAR_DATA[nepaliYearToCreate] = tmp_calendar_data;
            }
        }
    },
    
    NEPALI_CALENDAR_DATA:  {
        // These data are from http://www.ashesh.com.np
        1970: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        1971: [18, 31, 31, 32, 31, 32, 30, 30, 29, 30, 29, 30, 30],
        1972: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
        1973: [19, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
        1974: [19, 31, 31, 32, 30, 31, 31, 30, 29, 30, 29, 30, 30],
        1975: [18, 31, 31, 32, 32, 30, 31, 30, 29, 30, 29, 30, 30],
        1976: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        1977: [18, 31, 32, 31, 32, 31, 31, 29, 30, 29, 30, 29, 31],
        1978: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        1979: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        1980: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        1981: [18, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
        1982: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        1983: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        1984: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        1985: [18, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
        1986: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        1987: [18, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        1988: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        1989: [18, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
        1990: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        1991: [18, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],    
        // These data are from http://nepalicalendar.rat32.com/index.php
        1992: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
        1993: [18, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
        1994: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        1995: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
        1996: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
        1997: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        1998: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        1999: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        2000: [17, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
        2001: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2002: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        2003: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        2004: [17, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
        2005: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2006: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        2007: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        2008: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 29, 31],
        2009: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2010: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        2011: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        2012: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
        2013: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2014: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        2015: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        2016: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
        2017: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2018: [18, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        2019: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
        2020: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
        2021: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2022: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
        2023: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
        2024: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
        2025: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2026: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        2027: [17, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
        2028: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2029: [18, 31, 31, 32, 31, 32, 30, 30, 29, 30, 29, 30, 30],
        2030: [17, 31, 32, 31, 32, 31, 30, 30, 30, 30, 30, 30, 31],
        2031: [17, 31, 32, 31, 32, 31, 31, 31, 31, 31, 31, 31, 31],
        2032: [17, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32],
        2033: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        2034: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        2035: [17, 30, 32, 31, 32, 31, 31, 29, 30, 30, 29, 29, 31],
        2036: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2037: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        2038: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        2039: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
        2040: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2041: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        2042: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        2043: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
        2044: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2045: [18, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        2046: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        2047: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
        2048: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2049: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
        2050: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
        2051: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
        2052: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2053: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
        2054: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
        2055: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 30, 29, 30],
        2056: [17, 31, 31, 32, 31, 32, 30, 30, 29, 30, 29, 30, 30],
        2057: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        2058: [17, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
        2059: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2060: [17, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        2061: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        2062: [17, 30, 32, 31, 32, 31, 31, 29, 30, 29, 30, 29, 31],
        2063: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2064: [17, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        2065: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        2066: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 29, 31],
        2067: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2068: [17, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        2069: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        2070: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
        2071: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2072: [17, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        2073: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
        2074: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
        2075: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2076: [16, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
        2077: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
        2078: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
        2079: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
        2080: [16, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
        // These data are from http://www.ashesh.com.np/nepali-calendar/
        2081: [17, 31, 31, 32, 32, 31, 30, 30, 30, 29, 30, 30, 30],
        2082: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
        2083: [17, 31, 31, 32, 31, 31, 30, 30, 30, 29, 30, 30, 30],
        2084: [17, 31, 31, 32, 31, 31, 30, 30, 30, 29, 30, 30, 30],
        2085: [17, 31, 32, 31, 32, 31, 31, 30, 30, 29, 30, 30, 30],
        2086: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
        2087: [16, 31, 31, 32, 31, 31, 31, 30, 30, 29, 30, 30, 30],
        2088: [16, 30, 31, 32, 32, 30, 31, 30, 30, 29, 30, 30, 30],
        2089: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
        2090: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
        2091: [16, 31, 31, 32, 31, 31, 31, 30, 30, 29, 30, 30, 30],
        2092: [16, 31, 31, 32, 32, 31, 30, 30, 30, 29, 30, 30, 30],
        2093: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
        2094: [17, 31, 31, 32, 31, 31, 30, 30, 30, 29, 30, 30, 30],
        2095: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 30, 30, 30],
        2096: [17, 30, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        2097: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
        2098: [17, 31, 31, 32, 31, 31, 31, 29, 30, 29, 30, 30, 31],
        2099: [17, 31, 31, 32, 31, 31, 31, 30, 29, 29, 30, 30, 30],
        2100: [17, 31, 32, 31, 32, 30, 31, 30, 29, 30, 29, 30, 30]    
    }
});    

// Nepali calendar implementation
main.calendars.nepali = NepaliCalendar;



/***/ }),

/***/ 4320:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/*
 * World Calendars
 * https://github.com/alexcjohnson/world-calendars
 *
 * Batch-converted from kbwood/calendars
 * Many thanks to Keith Wood and all of the contributors to the original project!
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

﻿/* http://keith-wood.name/calendars.html
   Persian calendar for jQuery v2.0.2.
   Written by Keith Wood (wood.keith{at}optusnet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

var main = __webpack_require__(3489);
var assign = __webpack_require__(6131);


/** Implementation of the Persian or Jalali calendar.
    Based on code from <a href="http://www.iranchamber.com/calendar/converter/iranian_calendar_converter.php">http://www.iranchamber.com/calendar/converter/iranian_calendar_converter.php</a>.
    See also <a href="http://en.wikipedia.org/wiki/Iranian_calendar">http://en.wikipedia.org/wiki/Iranian_calendar</a>.
    @class PersianCalendar
    @param [language=''] {string} The language code (default English) for localisation. */
function PersianCalendar(language) {
    this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
}

PersianCalendar.prototype = new main.baseCalendar;

assign(PersianCalendar.prototype, {
    /** The calendar name.
        @memberof PersianCalendar */
    name: 'Persian',
    /** Julian date of start of Persian epoch: 19 March 622 CE.
        @memberof PersianCalendar */
    jdEpoch: 1948320.5,
    /** Days per month in a common year.
        @memberof PersianCalendar */
    daysPerMonth: [31, 31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 29],
    /** <code>true</code> if has a year zero, <code>false</code> if not.
        @memberof PersianCalendar */
    hasYearZero: false,
    /** The minimum month number.
        @memberof PersianCalendar */
    minMonth: 1,
    /** The first month in the year.
        @memberof PersianCalendar */
    firstMonth: 1,
    /** The minimum day number.
        @memberof PersianCalendar */
    minDay: 1,

    /** Localisations for the plugin.
        Entries are objects indexed by the language code ('' being the default US/English).
        Each object has the following attributes.
        @memberof PersianCalendar
        @property name {string} The calendar name.
        @property epochs {string[]} The epoch names.
        @property monthNames {string[]} The long names of the months of the year.
        @property monthNamesShort {string[]} The short names of the months of the year.
        @property dayNames {string[]} The long names of the days of the week.
        @property dayNamesShort {string[]} The short names of the days of the week.
        @property dayNamesMin {string[]} The minimal names of the days of the week.
        @property dateFormat {string} The date format for this calendar.
                See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
        @property firstDay {number} The number of the first day of the week, starting at 0.
        @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
    regionalOptions: { // Localisations
        '': {
            name: 'Persian',
            epochs: ['BP', 'AP'],
            monthNames: ['Farvardin', 'Ordibehesht', 'Khordad', 'Tir', 'Mordad', 'Shahrivar',
            'Mehr', 'Aban', 'Azar', 'Day', 'Bahman', 'Esfand'],
            monthNamesShort: ['Far', 'Ord', 'Kho', 'Tir', 'Mor', 'Sha', 'Meh', 'Aba', 'Aza', 'Day', 'Bah', 'Esf'],
            dayNames: ['Yekshambe', 'Doshambe', 'Seshambe', 'Chæharshambe', 'Panjshambe', 'Jom\'e', 'Shambe'],
            dayNamesShort: ['Yek', 'Do', 'Se', 'Chæ', 'Panj', 'Jom', 'Sha'],
            dayNamesMin: ['Ye','Do','Se','Ch','Pa','Jo','Sh'],
            digits: null,
            dateFormat: 'yyyy/mm/dd',
            firstDay: 6,
            isRTL: false
        }
    },

    /** Determine whether this date is in a leap year.
        @memberof PersianCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
        @throws Error if an invalid year or a different calendar used. */
    leapYear: function(year) {
        var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        return (((((date.year() - (date.year() > 0 ? 474 : 473)) % 2820) +
            474 + 38) * 682) % 2816) < 682;
    },

    /** Determine the week of the year for a date.
        @memberof PersianCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {number} The week of the year.
        @throws Error if an invalid date or a different calendar used. */
    weekOfYear: function(year, month, day) {
        // Find Saturday of this week starting on Saturday
        var checkDate = this.newDate(year, month, day);
        checkDate.add(-((checkDate.dayOfWeek() + 1) % 7), 'd');
        return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
    },

    /** Retrieve the number of days in a month.
        @memberof PersianCalendar
        @param year {CDate|number} The date to examine or the year of the month.
        @param [month] {number} The month.
        @return {number} The number of days in this month.
        @throws Error if an invalid month/year or a different calendar used. */
    daysInMonth: function(year, month) {
        var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
        return this.daysPerMonth[date.month() - 1] +
            (date.month() === 12 && this.leapYear(date.year()) ? 1 : 0);
    },

    /** Determine whether this date is a week day.
        @memberof PersianCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
        @throws Error if an invalid date or a different calendar used. */
    weekDay: function(year, month, day) {
        return this.dayOfWeek(year, month, day) !== 5;
    },

    /** Retrieve the Julian date equivalent for this date,
        i.e. days since January 1, 4713 BCE Greenwich noon.
        @memberof PersianCalendar
        @param year {CDate|number} The date to convert or the year to convert.
        @param [month] {number} The month to convert.
        @param [day] {number} The day to convert.
        @return {number} The equivalent Julian date.
        @throws Error if an invalid date or a different calendar used. */
    toJD: function(year, month, day) {
        var date = this._validate(year, month, day, main.local.invalidDate);
        year = date.year();
        month = date.month();
        day = date.day();
        var epBase = year - (year >= 0 ? 474 : 473);
        var epYear = 474 + mod(epBase, 2820);
        return day + (month <= 7 ? (month - 1) * 31 : (month - 1) * 30 + 6) +
            Math.floor((epYear * 682 - 110) / 2816) + (epYear - 1) * 365 +
            Math.floor(epBase / 2820) * 1029983 + this.jdEpoch - 1;
    },

    /** Create a new date from a Julian date.
        @memberof PersianCalendar
        @param jd {number} The Julian date to convert.
        @return {CDate} The equivalent date. */
    fromJD: function(jd) {
        jd = Math.floor(jd) + 0.5;
        var depoch = jd - this.toJD(475, 1, 1);
        var cycle = Math.floor(depoch / 1029983);
        var cyear = mod(depoch, 1029983);
        var ycycle = 2820;
        if (cyear !== 1029982) {
            var aux1 = Math.floor(cyear / 366);
            var aux2 = mod(cyear, 366);
            ycycle = Math.floor(((2134 * aux1) + (2816 * aux2) + 2815) / 1028522) + aux1 + 1;
        }
        var year = ycycle + (2820 * cycle) + 474;
        year = (year <= 0 ? year - 1 : year);
        var yday = jd - this.toJD(year, 1, 1) + 1;
        var month = (yday <= 186 ? Math.ceil(yday / 31) : Math.ceil((yday - 6) / 30));
        var day = jd - this.toJD(year, month, 1) + 1;
        return this.newDate(year, month, day);
    }
});

// Modulus function which works for non-integers.
function mod(a, b) {
    return a - (b * Math.floor(a / b));
}

// Persian (Jalali) calendar implementation
main.calendars.persian = PersianCalendar;
main.calendars.jalali = PersianCalendar;



/***/ }),

/***/ 1320:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/*
 * World Calendars
 * https://github.com/alexcjohnson/world-calendars
 *
 * Batch-converted from kbwood/calendars
 * Many thanks to Keith Wood and all of the contributors to the original project!
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

﻿/* http://keith-wood.name/calendars.html
   Taiwanese (Minguo) calendar for jQuery v2.0.2.
   Written by Keith Wood (wood.keith{at}optusnet.com.au) February 2010.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

var main = __webpack_require__(3489);
var assign = __webpack_require__(6131);


var gregorianCalendar = main.instance();

/** Implementation of the Taiwanese calendar.
    See http://en.wikipedia.org/wiki/Minguo_calendar.
    @class TaiwanCalendar
    @param [language=''] {string} The language code (default English) for localisation. */
function TaiwanCalendar(language) {
    this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
}

TaiwanCalendar.prototype = new main.baseCalendar;

assign(TaiwanCalendar.prototype, {
    /** The calendar name.
        @memberof TaiwanCalendar */
    name: 'Taiwan',
    /** Julian date of start of Taiwan epoch: 1 January 1912 CE (Gregorian).
        @memberof TaiwanCalendar */
    jdEpoch: 2419402.5,
    /** Difference in years between Taiwan and Gregorian calendars.
        @memberof TaiwanCalendar */
    yearsOffset: 1911,
    /** Days per month in a common year.
        @memberof TaiwanCalendar */
    daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    /** <code>true</code> if has a year zero, <code>false</code> if not.
        @memberof TaiwanCalendar */
    hasYearZero: false,
    /** The minimum month number.
        @memberof TaiwanCalendar */
    minMonth: 1,
    /** The first month in the year.
        @memberof TaiwanCalendar */
    firstMonth: 1,
    /** The minimum day number.
        @memberof TaiwanCalendar */
    minDay: 1,

    /** Localisations for the plugin.
        Entries are objects indexed by the language code ('' being the default US/English).
        Each object has the following attributes.
        @memberof TaiwanCalendar
        @property name {string} The calendar name.
        @property epochs {string[]} The epoch names.
        @property monthNames {string[]} The long names of the months of the year.
        @property monthNamesShort {string[]} The short names of the months of the year.
        @property dayNames {string[]} The long names of the days of the week.
        @property dayNamesShort {string[]} The short names of the days of the week.
        @property dayNamesMin {string[]} The minimal names of the days of the week.
        @property dateFormat {string} The date format for this calendar.
                See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
        @property firstDay {number} The number of the first day of the week, starting at 0.
        @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
    regionalOptions: { // Localisations
        '': {
            name: 'Taiwan',
            epochs: ['BROC', 'ROC'],
            monthNames: ['January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'],
            monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
            digits: null,
            dateFormat: 'yyyy/mm/dd',
            firstDay: 1,
            isRTL: false
        }
    },

    /** Determine whether this date is in a leap year.
        @memberof TaiwanCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
        @throws Error if an invalid year or a different calendar used. */
    leapYear: function(year) {
        var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        var year = this._t2gYear(date.year());
        return gregorianCalendar.leapYear(year);
    },

    /** Determine the week of the year for a date - ISO 8601.
        @memberof TaiwanCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {number} The week of the year.
        @throws Error if an invalid date or a different calendar used. */
    weekOfYear: function(year, month, day) {
        var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        var year = this._t2gYear(date.year());
        return gregorianCalendar.weekOfYear(year, date.month(), date.day());
    },

    /** Retrieve the number of days in a month.
        @memberof TaiwanCalendar
        @param year {CDate|number} The date to examine or the year of the month.
        @param [month] {number} The month.
        @return {number} The number of days in this month.
        @throws Error if an invalid month/year or a different calendar used. */
    daysInMonth: function(year, month) {
        var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
        return this.daysPerMonth[date.month() - 1] +
            (date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
    },

    /** Determine whether this date is a week day.
        @memberof TaiwanCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
        @throws Error if an invalid date or a different calendar used. */
    weekDay: function(year, month, day) {
        return (this.dayOfWeek(year, month, day) || 7) < 6;
    },

    /** Retrieve the Julian date equivalent for this date,
        i.e. days since January 1, 4713 BCE Greenwich noon.
        @memberof TaiwanCalendar
        @param year {CDate|number} The date to convert or the year to convert.
        @param [month] {number} The month to convert.
        @param [day] {number} The day to convert.
        @return {number} The equivalent Julian date.
        @throws Error if an invalid date or a different calendar used. */
    toJD: function(year, month, day) {
        var date = this._validate(year, month, day, main.local.invalidDate);
        var year = this._t2gYear(date.year());
        return gregorianCalendar.toJD(year, date.month(), date.day());
    },

    /** Create a new date from a Julian date.
        @memberof TaiwanCalendar
        @param jd {number} The Julian date to convert.
        @return {CDate} The equivalent date. */
    fromJD: function(jd) {
        var date = gregorianCalendar.fromJD(jd);
        var year = this._g2tYear(date.year());
        return this.newDate(year, date.month(), date.day());
    },

    /** Convert Taiwanese to Gregorian year.
        @memberof TaiwanCalendar
        @private
        @param year {number} The Taiwanese year.
        @return {number} The corresponding Gregorian year. */
    _t2gYear: function(year) {
        return year + this.yearsOffset + (year >= -this.yearsOffset && year <= -1 ? 1 : 0);
    },

    /** Convert Gregorian to Taiwanese year.
        @memberof TaiwanCalendar
        @private
        @param year {number} The Gregorian year.
        @return {number} The corresponding Taiwanese year. */
    _g2tYear: function(year) {
        return year - this.yearsOffset - (year >= 1 && year <= this.yearsOffset ? 1 : 0);
    }
});

// Taiwan calendar implementation
main.calendars.taiwan = TaiwanCalendar;



/***/ }),

/***/ 1367:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/*
 * World Calendars
 * https://github.com/alexcjohnson/world-calendars
 *
 * Batch-converted from kbwood/calendars
 * Many thanks to Keith Wood and all of the contributors to the original project!
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

﻿/* http://keith-wood.name/calendars.html
   Thai calendar for jQuery v2.0.2.
   Written by Keith Wood (wood.keith{at}optusnet.com.au) February 2010.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

var main = __webpack_require__(3489);
var assign = __webpack_require__(6131);


var gregorianCalendar = main.instance();

/** Implementation of the Thai calendar.
    See http://en.wikipedia.org/wiki/Thai_calendar.
    @class ThaiCalendar
    @param [language=''] {string} The language code (default English) for localisation. */
function ThaiCalendar(language) {
    this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
}

ThaiCalendar.prototype = new main.baseCalendar;

assign(ThaiCalendar.prototype, {
    /** The calendar name.
        @memberof ThaiCalendar */
    name: 'Thai',
    /** Julian date of start of Thai epoch: 1 January 543 BCE (Gregorian).
        @memberof ThaiCalendar */
    jdEpoch: 1523098.5,
    /** Difference in years between Thai and Gregorian calendars.
        @memberof ThaiCalendar */
    yearsOffset: 543, 
    /** Days per month in a common year.
        @memberof ThaiCalendar */
    daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    /** <code>true</code> if has a year zero, <code>false</code> if not.
        @memberof ThaiCalendar */
    hasYearZero: false,
    /** The minimum month number.
        @memberof ThaiCalendar */
    minMonth: 1,
    /** The first month in the year.
        @memberof ThaiCalendar */
    firstMonth: 1,
    /** The minimum day number.
        @memberof ThaiCalendar */
    minDay: 1,

    /** Localisations for the plugin.
        Entries are objects indexed by the language code ('' being the default US/English).
        Each object has the following attributes.
        @memberof ThaiCalendar
        @property name {string} The calendar name.
        @property epochs {string[]} The epoch names.
        @property monthNames {string[]} The long names of the months of the year.
        @property monthNamesShort {string[]} The short names of the months of the year.
        @property dayNames {string[]} The long names of the days of the week.
        @property dayNamesShort {string[]} The short names of the days of the week.
        @property dayNamesMin {string[]} The minimal names of the days of the week.
        @property dateFormat {string} The date format for this calendar.
                See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
        @property firstDay {number} The number of the first day of the week, starting at 0.
        @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
    regionalOptions: { // Localisations
        '': {
            name: 'Thai',
            epochs: ['BBE', 'BE'],
            monthNames: ['January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'],
            monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
            digits: null,
            dateFormat: 'dd/mm/yyyy',
            firstDay: 0,
            isRTL: false
        }
    },

    /** Determine whether this date is in a leap year.
        @memberof ThaiCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
        @throws Error if an invalid year or a different calendar used. */
    leapYear: function(year) {
        var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        var year = this._t2gYear(date.year());
        return gregorianCalendar.leapYear(year);
    },

    /** Determine the week of the year for a date - ISO 8601.
        @memberof ThaiCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {number} The week of the year.
        @throws Error if an invalid date or a different calendar used. */
    weekOfYear: function(year, month, day) {
        var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        var year = this._t2gYear(date.year());
        return gregorianCalendar.weekOfYear(year, date.month(), date.day());
    },

    /** Retrieve the number of days in a month.
        @memberof ThaiCalendar
        @param year {CDate|number} The date to examine or the year of the month.
        @param [month] {number} The month.
        @return {number} The number of days in this month.
        @throws Error if an invalid month/year or a different calendar used. */
    daysInMonth: function(year, month) {
        var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
        return this.daysPerMonth[date.month() - 1] +
            (date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
    },

    /** Determine whether this date is a week day.
        @memberof ThaiCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
        @throws Error if an invalid date or a different calendar used. */
    weekDay: function(year, month, day) {
        return (this.dayOfWeek(year, month, day) || 7) < 6;
    },

    /** Retrieve the Julian date equivalent for this date,
        i.e. days since January 1, 4713 BCE Greenwich noon.
        @memberof ThaiCalendar
        @param year {CDate|number} The date to convert or the year to convert.
        @param [month] {number} The month to convert.
        @param [day] {number} The day to convert.
        @return {number} The equivalent Julian date.
        @throws Error if an invalid date or a different calendar used. */
    toJD: function(year, month, day) {
        var date = this._validate(year, month, day, main.local.invalidDate);
        var year = this._t2gYear(date.year());
        return gregorianCalendar.toJD(year, date.month(), date.day());
    },

    /** Create a new date from a Julian date.
        @memberof ThaiCalendar
        @param jd {number} The Julian date to convert.
        @return {CDate} The equivalent date. */
    fromJD: function(jd) {
        var date = gregorianCalendar.fromJD(jd);
        var year = this._g2tYear(date.year());
        return this.newDate(year, date.month(), date.day());
    },

    /** Convert Thai to Gregorian year.
        @memberof ThaiCalendar
        @private
        @param year {number} The Thai year.
        @return {number} The corresponding Gregorian year. */
    _t2gYear: function(year) {
        return year - this.yearsOffset - (year >= 1 && year <= this.yearsOffset ? 1 : 0);
    },

    /** Convert Gregorian to Thai year.
        @memberof ThaiCalendar
        @private
        @param year {number} The Gregorian year.
        @return {number} The corresponding Thai year. */
    _g2tYear: function(year) {
        return year + this.yearsOffset + (year >= -this.yearsOffset && year <= -1 ? 1 : 0);
    }
});

// Thai calendar implementation
main.calendars.thai = ThaiCalendar;



/***/ }),

/***/ 1457:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/*
 * World Calendars
 * https://github.com/alexcjohnson/world-calendars
 *
 * Batch-converted from kbwood/calendars
 * Many thanks to Keith Wood and all of the contributors to the original project!
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

﻿/* http://keith-wood.name/calendars.html
   UmmAlQura calendar for jQuery v2.0.2.
   Written by Amro Osama March 2013.
   Modified by Binnooh.com & www.elm.sa - 2014 - Added dates back to 1276 Hijri year.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

var main = __webpack_require__(3489);
var assign = __webpack_require__(6131);


/** Implementation of the UmmAlQura or 'saudi' calendar.
    See also <a href="http://en.wikipedia.org/wiki/Islamic_calendar#Saudi_Arabia.27s_Umm_al-Qura_calendar">http://en.wikipedia.org/wiki/Islamic_calendar#Saudi_Arabia.27s_Umm_al-Qura_calendar</a>.
    <a href="http://www.ummulqura.org.sa/About.aspx">http://www.ummulqura.org.sa/About.aspx</a>
    <a href="http://www.staff.science.uu.nl/~gent0113/islam/ummalqura.htm">http://www.staff.science.uu.nl/~gent0113/islam/ummalqura.htm</a>
    @class UmmAlQuraCalendar
    @param [language=''] {string} The language code (default English) for localisation. */
function UmmAlQuraCalendar(language) {
    this.local = this.regionalOptions[language || ''] || this.regionalOptions[''];
}

UmmAlQuraCalendar.prototype = new main.baseCalendar;

assign(UmmAlQuraCalendar.prototype, {
    /** The calendar name.
        @memberof UmmAlQuraCalendar */
    name: 'UmmAlQura',
    //jdEpoch: 1948440, // Julian date of start of UmmAlQura epoch: 14 March 1937 CE
    //daysPerMonth: // Days per month in a common year, replaced by a method.
    /** <code>true</code> if has a year zero, <code>false</code> if not.
        @memberof UmmAlQuraCalendar */
    hasYearZero: false,
    /** The minimum month number.
        @memberof UmmAlQuraCalendar */
    minMonth: 1,
    /** The first month in the year.
        @memberof UmmAlQuraCalendar */
    firstMonth: 1,
    /** The minimum day number.
        @memberof UmmAlQuraCalendar */
    minDay: 1,

    /** Localisations for the plugin.
        Entries are objects indexed by the language code ('' being the default US/English).
        Each object has the following attributes.
        @memberof UmmAlQuraCalendar
        @property name {string} The calendar name.
        @property epochs {string[]} The epoch names.
        @property monthNames {string[]} The long names of the months of the year.
        @property monthNamesShort {string[]} The short names of the months of the year.
        @property dayNames {string[]} The long names of the days of the week.
        @property dayNamesShort {string[]} The short names of the days of the week.
        @property dayNamesMin {string[]} The minimal names of the days of the week.
        @property dateFormat {string} The date format for this calendar.
                See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
        @property firstDay {number} The number of the first day of the week, starting at 0.
        @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
    regionalOptions: { // Localisations
        '': {
            name: 'Umm al-Qura',
            epochs: ['BH', 'AH'],
            monthNames: ['Al-Muharram', 'Safar', 'Rabi\' al-awwal', 'Rabi\' Al-Thani', 'Jumada Al-Awwal', 'Jumada Al-Thani',
            'Rajab', 'Sha\'aban', 'Ramadan', 'Shawwal', 'Dhu al-Qi\'dah', 'Dhu al-Hijjah'],
            monthNamesShort: ['Muh', 'Saf', 'Rab1', 'Rab2', 'Jum1', 'Jum2', 'Raj', 'Sha\'', 'Ram', 'Shaw', 'DhuQ', 'DhuH'],
            dayNames: ['Yawm al-Ahad', 'Yawm al-Ithnain', 'Yawm al-Thalāthā’', 'Yawm al-Arba‘ā’', 'Yawm al-Khamīs', 'Yawm al-Jum‘a', 'Yawm al-Sabt'],
            dayNamesMin: ['Ah', 'Ith', 'Th', 'Ar', 'Kh', 'Ju', 'Sa'],
            digits: null,
            dateFormat: 'yyyy/mm/dd',
            firstDay: 6,
            isRTL: true
        }
    },

    /** Determine whether this date is in a leap year.
        @memberof UmmAlQuraCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
        @throws Error if an invalid year or a different calendar used. */
    leapYear: function (year) {
        var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
        return (this.daysInYear(date.year()) === 355);
    },

    /** Determine the week of the year for a date.
        @memberof UmmAlQuraCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {number} The week of the year.
        @throws Error if an invalid date or a different calendar used. */
    weekOfYear: function (year, month, day) {
        // Find Sunday of this week starting on Sunday
        var checkDate = this.newDate(year, month, day);
        checkDate.add(-checkDate.dayOfWeek(), 'd');
        return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
    },

    /** Retrieve the number of days in a year.
        @memberof UmmAlQuraCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {number} The number of days.
        @throws Error if an invalid year or a different calendar used. */
    daysInYear: function (year) {
        var daysCount = 0;
        for (var i = 1; i <= 12; i++) {
            daysCount += this.daysInMonth(year, i);
        }
        return daysCount;
    },

    /** Retrieve the number of days in a month.
        @memberof UmmAlQuraCalendar
        @param year {CDate|number} The date to examine or the year of the month.
        @param [month] {number} The month.
        @return {number} The number of days in this month.
        @throws Error if an invalid month/year or a different calendar used. */
    daysInMonth: function (year, month) {
        var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
        var mcjdn = date.toJD() - 2400000 + 0.5; // Modified Chronological Julian Day Number (MCJDN)
        // the MCJDN's of the start of the lunations in the Umm al-Qura calendar are stored in the 'ummalqura_dat' array
        var index = 0;
        for (var i = 0; i < ummalqura_dat.length; i++) {
            if (ummalqura_dat[i] > mcjdn) {
                return (ummalqura_dat[index] - ummalqura_dat[index - 1]);
            }
            index++;
        }
        return 30; // Unknown outside
    },

    /** Determine whether this date is a week day.
        @memberof UmmAlQuraCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
        @throws Error if an invalid date or a different calendar used. */
    weekDay: function (year, month, day) {
        return this.dayOfWeek(year, month, day) !== 5;
    },

    /** Retrieve the Julian date equivalent for this date,
        i.e. days since January 1, 4713 BCE Greenwich noon.
        @memberof UmmAlQuraCalendar
        @param year {CDate|number} The date to convert or the year to convert.
        @param [month] {number} The month to convert.
        @param [day] {number} The day to convert.
        @return {number} The equivalent Julian date.
        @throws Error if an invalid date or a different calendar used. */
    toJD: function (year, month, day) {
        var date = this._validate(year, month, day, main.local.invalidDate);
        var index = (12 * (date.year() - 1)) + date.month() - 15292;
        var mcjdn = date.day() + ummalqura_dat[index - 1] - 1;
        return mcjdn + 2400000 - 0.5; // Modified Chronological Julian Day Number (MCJDN)
    },

    /** Create a new date from a Julian date.
        @memberof UmmAlQuraCalendar
        @param jd {number} The Julian date to convert.
        @return {CDate} The equivalent date. */
    fromJD: function (jd) {
        var mcjdn = jd - 2400000 + 0.5; // Modified Chronological Julian Day Number (MCJDN)
        // the MCJDN's of the start of the lunations in the Umm al-Qura calendar 
        // are stored in the 'ummalqura_dat' array
        var index = 0;
        for (var i = 0; i < ummalqura_dat.length; i++) {
            if (ummalqura_dat[i] > mcjdn) break;
            index++;
        }
        var lunation = index + 15292; //UmmAlQura Lunation Number
        var ii = Math.floor((lunation - 1) / 12);
        var year = ii + 1;
        var month = lunation - 12 * ii;
        var day = mcjdn - ummalqura_dat[index - 1] + 1;
        return this.newDate(year, month, day);
    },

    /** Determine whether a date is valid for this calendar.
        @memberof UmmAlQuraCalendar
        @param year {number} The year to examine.
        @param month {number} The month to examine.
        @param day {number} The day to examine.
        @return {boolean} <code>true</code> if a valid date, <code>false</code> if not. */
    isValid: function(year, month, day) {
        var valid = main.baseCalendar.prototype.isValid.apply(this, arguments);
        if (valid) {
            year = (year.year != null ? year.year : year);
            valid = (year >= 1276 && year <= 1500);
        }
        return valid;
    },

    /** Check that a candidate date is from the same calendar and is valid.
        @memberof UmmAlQuraCalendar
        @private
        @param year {CDate|number} The date to validate or the year to validate.
        @param month {number} The month to validate.
        @param day {number} The day to validate.
        @param error {string} Error message if invalid.
        @throws Error if different calendars used or invalid date. */
    _validate: function(year, month, day, error) {
        var date = main.baseCalendar.prototype._validate.apply(this, arguments);
        if (date.year < 1276 || date.year > 1500) {
            throw error.replace(/\{0\}/, this.local.name);
        }
        return date;
    }
});

// UmmAlQura calendar implementation
main.calendars.ummalqura = UmmAlQuraCalendar;

var ummalqura_dat = [
    20,    50,    79,    109,   138,   168,   197,   227,   256,   286,   315,   345,   374,   404,   433,   463,   492,   522,   551,   581, 
    611,   641,   670,   700,   729,   759,   788,   818,   847,   877,   906,   936,   965,   995,   1024,  1054,  1083,  1113,  1142,  1172,
    1201,  1231,  1260,  1290,  1320,  1350,  1379,  1409,  1438,  1468,  1497,  1527,  1556,  1586,  1615,  1645,  1674,  1704,  1733,  1763,
    1792,  1822,  1851,  1881,  1910,  1940,  1969,  1999,  2028,  2058,  2087,  2117,  2146,  2176,  2205,  2235,  2264,  2294,  2323,  2353,
    2383,  2413,  2442,  2472,  2501,  2531,  2560,  2590,  2619,  2649,  2678,  2708,  2737,  2767,  2796,  2826,  2855,  2885,  2914,  2944,
    2973,  3003,  3032,  3062,  3091,  3121,  3150,  3180,  3209,  3239,  3268,  3298,  3327,  3357,  3386,  3416,  3446,  3476,  3505,  3535,
    3564,  3594,  3623,  3653,  3682,  3712,  3741,  3771,  3800,  3830,  3859,  3889,  3918,  3948,  3977,  4007,  4036,  4066,  4095,  4125,
    4155,  4185,  4214,  4244,  4273,  4303,  4332,  4362,  4391,  4421,  4450,  4480,  4509,  4539,  4568,  4598,  4627,  4657,  4686,  4716,
    4745,  4775,  4804,  4834,  4863,  4893,  4922,  4952,  4981,  5011,  5040,  5070,  5099,  5129,  5158,  5188,  5218,  5248,  5277,  5307,
    5336,  5366,  5395,  5425,  5454,  5484,  5513,  5543,  5572,  5602,  5631,  5661,  5690,  5720,  5749,  5779,  5808,  5838,  5867,  5897,
    5926,  5956,  5985,  6015,  6044,  6074,  6103,  6133,  6162,  6192,  6221,  6251,  6281,  6311,  6340,  6370,  6399,  6429,  6458,  6488,
    6517,  6547,  6576,  6606,  6635,  6665,  6694,  6724,  6753,  6783,  6812,  6842,  6871,  6901,  6930,  6960,  6989,  7019,  7048,  7078,
    7107,  7137,  7166,  7196,  7225,  7255,  7284,  7314,  7344,  7374,  7403,  7433,  7462,  7492,  7521,  7551,  7580,  7610,  7639,  7669,
    7698,  7728,  7757,  7787,  7816,  7846,  7875,  7905,  7934,  7964,  7993,  8023,  8053,  8083,  8112,  8142,  8171,  8201,  8230,  8260,
    8289,  8319,  8348,  8378,  8407,  8437,  8466,  8496,  8525,  8555,  8584,  8614,  8643,  8673,  8702,  8732,  8761,  8791,  8821,  8850,
    8880,  8909,  8938,  8968,  8997,  9027,  9056,  9086,  9115,  9145,  9175,  9205,  9234,  9264,  9293,  9322,  9352,  9381,  9410,  9440,
    9470,  9499,  9529,  9559,  9589,  9618,  9648,  9677,  9706,  9736,  9765,  9794,  9824,  9853,  9883,  9913,  9943,  9972,  10002, 10032,
    10061, 10090, 10120, 10149, 10178, 10208, 10237, 10267, 10297, 10326, 10356, 10386, 10415, 10445, 10474, 10504, 10533, 10562, 10592, 10621,
    10651, 10680, 10710, 10740, 10770, 10799, 10829, 10858, 10888, 10917, 10947, 10976, 11005, 11035, 11064, 11094, 11124, 11153, 11183, 11213,
    11242, 11272, 11301, 11331, 11360, 11389, 11419, 11448, 11478, 11507, 11537, 11567, 11596, 11626, 11655, 11685, 11715, 11744, 11774, 11803,
    11832, 11862, 11891, 11921, 11950, 11980, 12010, 12039, 12069, 12099, 12128, 12158, 12187, 12216, 12246, 12275, 12304, 12334, 12364, 12393,
    12423, 12453, 12483, 12512, 12542, 12571, 12600, 12630, 12659, 12688, 12718, 12747, 12777, 12807, 12837, 12866, 12896, 12926, 12955, 12984,
    13014, 13043, 13072, 13102, 13131, 13161, 13191, 13220, 13250, 13280, 13310, 13339, 13368, 13398, 13427, 13456, 13486, 13515, 13545, 13574,
    13604, 13634, 13664, 13693, 13723, 13752, 13782, 13811, 13840, 13870, 13899, 13929, 13958, 13988, 14018, 14047, 14077, 14107, 14136, 14166,
    14195, 14224, 14254, 14283, 14313, 14342, 14372, 14401, 14431, 14461, 14490, 14520, 14550, 14579, 14609, 14638, 14667, 14697, 14726, 14756,
    14785, 14815, 14844, 14874, 14904, 14933, 14963, 14993, 15021, 15051, 15081, 15110, 15140, 15169, 15199, 15228, 15258, 15287, 15317, 15347,
    15377, 15406, 15436, 15465, 15494, 15524, 15553, 15582, 15612, 15641, 15671, 15701, 15731, 15760, 15790, 15820, 15849, 15878, 15908, 15937,
    15966, 15996, 16025, 16055, 16085, 16114, 16144, 16174, 16204, 16233, 16262, 16292, 16321, 16350, 16380, 16409, 16439, 16468, 16498, 16528,
    16558, 16587, 16617, 16646, 16676, 16705, 16734, 16764, 16793, 16823, 16852, 16882, 16912, 16941, 16971, 17001, 17030, 17060, 17089, 17118,
    17148, 17177, 17207, 17236, 17266, 17295, 17325, 17355, 17384, 17414, 17444, 17473, 17502, 17532, 17561, 17591, 17620, 17650, 17679, 17709,
    17738, 17768, 17798, 17827, 17857, 17886, 17916, 17945, 17975, 18004, 18034, 18063, 18093, 18122, 18152, 18181, 18211, 18241, 18270, 18300,
    18330, 18359, 18388, 18418, 18447, 18476, 18506, 18535, 18565, 18595, 18625, 18654, 18684, 18714, 18743, 18772, 18802, 18831, 18860, 18890,
    18919, 18949, 18979, 19008, 19038, 19068, 19098, 19127, 19156, 19186, 19215, 19244, 19274, 19303, 19333, 19362, 19392, 19422, 19452, 19481,
    19511, 19540, 19570, 19599, 19628, 19658, 19687, 19717, 19746, 19776, 19806, 19836, 19865, 19895, 19924, 19954, 19983, 20012, 20042, 20071,
    20101, 20130, 20160, 20190, 20219, 20249, 20279, 20308, 20338, 20367, 20396, 20426, 20455, 20485, 20514, 20544, 20573, 20603, 20633, 20662,
    20692, 20721, 20751, 20780, 20810, 20839, 20869, 20898, 20928, 20957, 20987, 21016, 21046, 21076, 21105, 21135, 21164, 21194, 21223, 21253,
    21282, 21312, 21341, 21371, 21400, 21430, 21459, 21489, 21519, 21548, 21578, 21607, 21637, 21666, 21696, 21725, 21754, 21784, 21813, 21843,
    21873, 21902, 21932, 21962, 21991, 22021, 22050, 22080, 22109, 22138, 22168, 22197, 22227, 22256, 22286, 22316, 22346, 22375, 22405, 22434,
    22464, 22493, 22522, 22552, 22581, 22611, 22640, 22670, 22700, 22730, 22759, 22789, 22818, 22848, 22877, 22906, 22936, 22965, 22994, 23024,
    23054, 23083, 23113, 23143, 23173, 23202, 23232, 23261, 23290, 23320, 23349, 23379, 23408, 23438, 23467, 23497, 23527, 23556, 23586, 23616,
    23645, 23674, 23704, 23733, 23763, 23792, 23822, 23851, 23881, 23910, 23940, 23970, 23999, 24029, 24058, 24088, 24117, 24147, 24176, 24206,
    24235, 24265, 24294, 24324, 24353, 24383, 24413, 24442, 24472, 24501, 24531, 24560, 24590, 24619, 24648, 24678, 24707, 24737, 24767, 24796,
    24826, 24856, 24885, 24915, 24944, 24974, 25003, 25032, 25062, 25091, 25121, 25150, 25180, 25210, 25240, 25269, 25299, 25328, 25358, 25387,
    25416, 25446, 25475, 25505, 25534, 25564, 25594, 25624, 25653, 25683, 25712, 25742, 25771, 25800, 25830, 25859, 25888, 25918, 25948, 25977,
    26007, 26037, 26067, 26096, 26126, 26155, 26184, 26214, 26243, 26272, 26302, 26332, 26361, 26391, 26421, 26451, 26480, 26510, 26539, 26568,
    26598, 26627, 26656, 26686, 26715, 26745, 26775, 26805, 26834, 26864, 26893, 26923, 26952, 26982, 27011, 27041, 27070, 27099, 27129, 27159,
    27188, 27218, 27248, 27277, 27307, 27336, 27366, 27395, 27425, 27454, 27484, 27513, 27542, 27572, 27602, 27631, 27661, 27691, 27720, 27750,
    27779, 27809, 27838, 27868, 27897, 27926, 27956, 27985, 28015, 28045, 28074, 28104, 28134, 28163, 28193, 28222, 28252, 28281, 28310, 28340,
    28369, 28399, 28428, 28458, 28488, 28517, 28547, 28577,
    // From 1356
    28607, 28636, 28665, 28695, 28724, 28754, 28783, 28813, 28843, 28872, 28901, 28931, 28960, 28990, 29019, 29049, 29078, 29108, 29137, 29167,
    29196, 29226, 29255, 29285, 29315, 29345, 29375, 29404, 29434, 29463, 29492, 29522, 29551, 29580, 29610, 29640, 29669, 29699, 29729, 29759,
    29788, 29818, 29847, 29876, 29906, 29935, 29964, 29994, 30023, 30053, 30082, 30112, 30141, 30171, 30200, 30230, 30259, 30289, 30318, 30348,
    30378, 30408, 30437, 30467, 30496, 30526, 30555, 30585, 30614, 30644, 30673, 30703, 30732, 30762, 30791, 30821, 30850, 30880, 30909, 30939,
    30968, 30998, 31027, 31057, 31086, 31116, 31145, 31175, 31204, 31234, 31263, 31293, 31322, 31352, 31381, 31411, 31441, 31471, 31500, 31530,
    31559, 31589, 31618, 31648, 31676, 31706, 31736, 31766, 31795, 31825, 31854, 31884, 31913, 31943, 31972, 32002, 32031, 32061, 32090, 32120,
    32150, 32180, 32209, 32239, 32268, 32298, 32327, 32357, 32386, 32416, 32445, 32475, 32504, 32534, 32563, 32593, 32622, 32652, 32681, 32711,
    32740, 32770, 32799, 32829, 32858, 32888, 32917, 32947, 32976, 33006, 33035, 33065, 33094, 33124, 33153, 33183, 33213, 33243, 33272, 33302,
    33331, 33361, 33390, 33420, 33450, 33479, 33509, 33539, 33568, 33598, 33627, 33657, 33686, 33716, 33745, 33775, 33804, 33834, 33863, 33893,
    33922, 33952, 33981, 34011, 34040, 34069, 34099, 34128, 34158, 34187, 34217, 34247, 34277, 34306, 34336, 34365, 34395, 34424, 34454, 34483,
    34512, 34542, 34571, 34601, 34631, 34660, 34690, 34719, 34749, 34778, 34808, 34837, 34867, 34896, 34926, 34955, 34985, 35015, 35044, 35074,
    35103, 35133, 35162, 35192, 35222, 35251, 35280, 35310, 35340, 35370, 35399, 35429, 35458, 35488, 35517, 35547, 35576, 35605, 35635, 35665,
    35694, 35723, 35753, 35782, 35811, 35841, 35871, 35901, 35930, 35960, 35989, 36019, 36048, 36078, 36107, 36136, 36166, 36195, 36225, 36254,
    36284, 36314, 36343, 36373, 36403, 36433, 36462, 36492, 36521, 36551, 36580, 36610, 36639, 36669, 36698, 36728, 36757, 36786, 36816, 36845,
    36875, 36904, 36934, 36963, 36993, 37022, 37052, 37081, 37111, 37141, 37170, 37200, 37229, 37259, 37288, 37318, 37347, 37377, 37406, 37436,
    37465, 37495, 37524, 37554, 37584, 37613, 37643, 37672, 37701, 37731, 37760, 37790, 37819, 37849, 37878, 37908, 37938, 37967, 37997, 38027,
    38056, 38085, 38115, 38144, 38174, 38203, 38233, 38262, 38292, 38322, 38351, 38381, 38410, 38440, 38469, 38499, 38528, 38558, 38587, 38617,
    38646, 38676, 38705, 38735, 38764, 38794, 38823, 38853, 38882, 38912, 38941, 38971, 39001, 39030, 39059, 39089, 39118, 39148, 39178, 39208,
    39237, 39267, 39297, 39326, 39355, 39385, 39414, 39444, 39473, 39503, 39532, 39562, 39592, 39621, 39650, 39680, 39709, 39739, 39768, 39798,
    39827, 39857, 39886, 39916, 39946, 39975, 40005, 40035, 40064, 40094, 40123, 40153, 40182, 40212, 40241, 40271, 40300, 40330, 40359, 40389,
    40418, 40448, 40477, 40507, 40536, 40566, 40595, 40625, 40655, 40685, 40714, 40744, 40773, 40803, 40832, 40862, 40892, 40921, 40951, 40980,
    41009, 41039, 41068, 41098, 41127, 41157, 41186, 41216, 41245, 41275, 41304, 41334, 41364, 41393, 41422, 41452, 41481, 41511, 41540, 41570,
    41599, 41629, 41658, 41688, 41718, 41748, 41777, 41807, 41836, 41865, 41894, 41924, 41953, 41983, 42012, 42042, 42072, 42102, 42131, 42161,
    42190, 42220, 42249, 42279, 42308, 42337, 42367, 42397, 42426, 42456, 42485, 42515, 42545, 42574, 42604, 42633, 42662, 42692, 42721, 42751,
    42780, 42810, 42839, 42869, 42899, 42929, 42958, 42988, 43017, 43046, 43076, 43105, 43135, 43164, 43194, 43223, 43253, 43283, 43312, 43342,
    43371, 43401, 43430, 43460, 43489, 43519, 43548, 43578, 43607, 43637, 43666, 43696, 43726, 43755, 43785, 43814, 43844, 43873, 43903, 43932,
    43962, 43991, 44021, 44050, 44080, 44109, 44139, 44169, 44198, 44228, 44258, 44287, 44317, 44346, 44375, 44405, 44434, 44464, 44493, 44523,
    44553, 44582, 44612, 44641, 44671, 44700, 44730, 44759, 44788, 44818, 44847, 44877, 44906, 44936, 44966, 44996, 45025, 45055, 45084, 45114,
    45143, 45172, 45202, 45231, 45261, 45290, 45320, 45350, 45380, 45409, 45439, 45468, 45498, 45527, 45556, 45586, 45615, 45644, 45674, 45704,
    45733, 45763, 45793, 45823, 45852, 45882, 45911, 45940, 45970, 45999, 46028, 46058, 46088, 46117, 46147, 46177, 46206, 46236, 46265, 46295,
    46324, 46354, 46383, 46413, 46442, 46472, 46501, 46531, 46560, 46590, 46620, 46649, 46679, 46708, 46738, 46767, 46797, 46826, 46856, 46885,
    46915, 46944, 46974, 47003, 47033, 47063, 47092, 47122, 47151, 47181, 47210, 47240, 47269, 47298, 47328, 47357, 47387, 47417, 47446, 47476,
    47506, 47535, 47565, 47594, 47624, 47653, 47682, 47712, 47741, 47771, 47800, 47830, 47860, 47890, 47919, 47949, 47978, 48008, 48037, 48066,
    48096, 48125, 48155, 48184, 48214, 48244, 48273, 48303, 48333, 48362, 48392, 48421, 48450, 48480, 48509, 48538, 48568, 48598, 48627, 48657,
    48687, 48717, 48746, 48776, 48805, 48834, 48864, 48893, 48922, 48952, 48982, 49011, 49041, 49071, 49100, 49130, 49160, 49189, 49218, 49248,
    49277, 49306, 49336, 49365, 49395, 49425, 49455, 49484, 49514, 49543, 49573, 49602, 49632, 49661, 49690, 49720, 49749, 49779, 49809, 49838,
    49868, 49898, 49927, 49957, 49986, 50016, 50045, 50075, 50104, 50133, 50163, 50192, 50222, 50252, 50281, 50311, 50340, 50370, 50400, 50429,
    50459, 50488, 50518, 50547, 50576, 50606, 50635, 50665, 50694, 50724, 50754, 50784, 50813, 50843, 50872, 50902, 50931, 50960, 50990, 51019,
    51049, 51078, 51108, 51138, 51167, 51197, 51227, 51256, 51286, 51315, 51345, 51374, 51403, 51433, 51462, 51492, 51522, 51552, 51582, 51611,
    51641, 51670, 51699, 51729, 51758, 51787, 51816, 51846, 51876, 51906, 51936, 51965, 51995, 52025, 52054, 52083, 52113, 52142, 52171, 52200,
    52230, 52260, 52290, 52319, 52349, 52379, 52408, 52438, 52467, 52497, 52526, 52555, 52585, 52614, 52644, 52673, 52703, 52733, 52762, 52792,
    52822, 52851, 52881, 52910, 52939, 52969, 52998, 53028, 53057, 53087, 53116, 53146, 53176, 53205, 53235, 53264, 53294, 53324, 53353, 53383,
    53412, 53441, 53471, 53500, 53530, 53559, 53589, 53619, 53648, 53678, 53708, 53737, 53767, 53796, 53825, 53855, 53884, 53913, 53943, 53973,
    54003, 54032, 54062, 54092, 54121, 54151, 54180, 54209, 54239, 54268, 54297, 54327, 54357, 54387, 54416, 54446, 54476, 54505, 54535, 54564,
    54593, 54623, 54652, 54681, 54711, 54741, 54770, 54800, 54830, 54859, 54889, 54919, 54948, 54977, 55007, 55036, 55066, 55095, 55125, 55154,
    55184, 55213, 55243, 55273, 55302, 55332, 55361, 55391, 55420, 55450, 55479, 55508, 55538, 55567, 55597, 55627, 55657, 55686, 55716, 55745,
    55775, 55804, 55834, 55863, 55892, 55922, 55951, 55981, 56011, 56040, 56070, 56100, 56129, 56159, 56188, 56218, 56247, 56276, 56306, 56335,
    56365, 56394, 56424, 56454, 56483, 56513, 56543, 56572, 56601, 56631, 56660, 56690, 56719, 56749, 56778, 56808, 56837, 56867, 56897, 56926,
    56956, 56985, 57015, 57044, 57074, 57103, 57133, 57162, 57192, 57221, 57251, 57280, 57310, 57340, 57369, 57399, 57429, 57458, 57487, 57517,
    57546, 57576, 57605, 57634, 57664, 57694, 57723, 57753, 57783, 57813, 57842, 57871, 57901, 57930, 57959, 57989, 58018, 58048, 58077, 58107,
    58137, 58167, 58196, 58226, 58255, 58285, 58314, 58343, 58373, 58402, 58432, 58461, 58491, 58521, 58551, 58580, 58610, 58639, 58669, 58698,
    58727, 58757, 58786, 58816, 58845, 58875, 58905, 58934, 58964, 58994, 59023, 59053, 59082, 59111, 59141, 59170, 59200, 59229, 59259, 59288,
    59318, 59348, 59377, 59407, 59436, 59466, 59495, 59525, 59554, 59584, 59613, 59643, 59672, 59702, 59731, 59761, 59791, 59820, 59850, 59879,
    59909, 59939, 59968, 59997, 60027, 60056, 60086, 60115, 60145, 60174, 60204, 60234, 60264, 60293, 60323, 60352, 60381, 60411, 60440, 60469,
    60499, 60528, 60558, 60588, 60618, 60648, 60677, 60707, 60736, 60765, 60795, 60824, 60853, 60883, 60912, 60942, 60972, 61002, 61031, 61061,
    61090, 61120, 61149, 61179, 61208, 61237, 61267, 61296, 61326, 61356, 61385, 61415, 61445, 61474, 61504, 61533, 61563, 61592, 61621, 61651,
    61680, 61710, 61739, 61769, 61799, 61828, 61858, 61888, 61917, 61947, 61976, 62006, 62035, 62064, 62094, 62123, 62153, 62182, 62212, 62242,
    62271, 62301, 62331, 62360, 62390, 62419, 62448, 62478, 62507, 62537, 62566, 62596, 62625, 62655, 62685, 62715, 62744, 62774, 62803, 62832,
    62862, 62891, 62921, 62950, 62980, 63009, 63039, 63069, 63099, 63128, 63157, 63187, 63216, 63246, 63275, 63305, 63334, 63363, 63393, 63423,
    63453, 63482, 63512, 63541, 63571, 63600, 63630, 63659, 63689, 63718, 63747, 63777, 63807, 63836, 63866, 63895, 63925, 63955, 63984, 64014,
    64043, 64073, 64102, 64131, 64161, 64190, 64220, 64249, 64279, 64309, 64339, 64368, 64398, 64427, 64457, 64486, 64515, 64545, 64574, 64603,
    64633, 64663, 64692, 64722, 64752, 64782, 64811, 64841, 64870, 64899, 64929, 64958, 64987, 65017, 65047, 65076, 65106, 65136, 65166, 65195,
    65225, 65254, 65283, 65313, 65342, 65371, 65401, 65431, 65460, 65490, 65520, 65549, 65579, 65608, 65638, 65667, 65697, 65726, 65755, 65785,
    65815, 65844, 65874, 65903, 65933, 65963, 65992, 66022, 66051, 66081, 66110, 66140, 66169, 66199, 66228, 66258, 66287, 66317, 66346, 66376,
    66405, 66435, 66465, 66494, 66524, 66553, 66583, 66612, 66641, 66671, 66700, 66730, 66760, 66789, 66819, 66849, 66878, 66908, 66937, 66967,
    66996, 67025, 67055, 67084, 67114, 67143, 67173, 67203, 67233, 67262, 67292, 67321, 67351, 67380, 67409, 67439, 67468, 67497, 67527, 67557,
    67587, 67617, 67646, 67676, 67705, 67735, 67764, 67793, 67823, 67852, 67882, 67911, 67941, 67971, 68000, 68030, 68060, 68089, 68119, 68148,
    68177, 68207, 68236, 68266, 68295, 68325, 68354, 68384, 68414, 68443, 68473, 68502, 68532, 68561, 68591, 68620, 68650, 68679, 68708, 68738,
    68768, 68797, 68827, 68857, 68886, 68916, 68946, 68975, 69004, 69034, 69063, 69092, 69122, 69152, 69181, 69211, 69240, 69270, 69300, 69330,
    69359, 69388, 69418, 69447, 69476, 69506, 69535, 69565, 69595, 69624, 69654, 69684, 69713, 69743, 69772, 69802, 69831, 69861, 69890, 69919,
    69949, 69978, 70008, 70038, 70067, 70097, 70126, 70156, 70186, 70215, 70245, 70274, 70303, 70333, 70362, 70392, 70421, 70451, 70481, 70510,
    70540, 70570, 70599, 70629, 70658, 70687, 70717, 70746, 70776, 70805, 70835, 70864, 70894, 70924, 70954, 70983, 71013, 71042, 71071, 71101,
    71130, 71159, 71189, 71218, 71248, 71278, 71308, 71337, 71367, 71397, 71426, 71455, 71485, 71514, 71543, 71573, 71602, 71632, 71662, 71691,
    71721, 71751, 71781, 71810, 71839, 71869, 71898, 71927, 71957, 71986, 72016, 72046, 72075, 72105, 72135, 72164, 72194, 72223, 72253, 72282,
    72311, 72341, 72370, 72400, 72429, 72459, 72489, 72518, 72548, 72577, 72607, 72637, 72666, 72695, 72725, 72754, 72784, 72813, 72843, 72872,
    72902, 72931, 72961, 72991, 73020, 73050, 73080, 73109, 73139, 73168, 73197, 73227, 73256, 73286, 73315, 73345, 73375, 73404, 73434, 73464,
    73493, 73523, 73552, 73581, 73611, 73640, 73669, 73699, 73729, 73758, 73788, 73818, 73848, 73877, 73907, 73936, 73965, 73995, 74024, 74053,
    74083, 74113, 74142, 74172, 74202, 74231, 74261, 74291, 74320, 74349, 74379, 74408, 74437, 74467, 74497, 74526, 74556, 74586, 74615, 74645,
    74675, 74704, 74733, 74763, 74792, 74822, 74851, 74881, 74910, 74940, 74969, 74999, 75029, 75058, 75088, 75117, 75147, 75176, 75206, 75235,
    75264, 75294, 75323, 75353, 75383, 75412, 75442, 75472, 75501, 75531, 75560, 75590, 75619, 75648, 75678, 75707, 75737, 75766, 75796, 75826,
    75856, 75885, 75915, 75944, 75974, 76003, 76032, 76062, 76091, 76121, 76150, 76180, 76210, 76239, 76269, 76299, 76328, 76358, 76387, 76416,
    76446, 76475, 76505, 76534, 76564, 76593, 76623, 76653, 76682, 76712, 76741, 76771, 76801, 76830, 76859, 76889, 76918, 76948, 76977, 77007,
    77036, 77066, 77096, 77125, 77155, 77185, 77214, 77243, 77273, 77302, 77332, 77361, 77390, 77420, 77450, 77479, 77509, 77539, 77569, 77598,
    77627, 77657, 77686, 77715, 77745, 77774, 77804, 77833, 77863, 77893, 77923, 77952, 77982, 78011, 78041, 78070, 78099, 78129, 78158, 78188,
    78217, 78247, 78277, 78307, 78336, 78366, 78395, 78425, 78454, 78483, 78513, 78542, 78572, 78601, 78631, 78661, 78690, 78720, 78750, 78779,
    78808, 78838, 78867, 78897, 78926, 78956, 78985, 79015, 79044, 79074, 79104, 79133, 79163, 79192, 79222, 79251, 79281, 79310, 79340, 79369,
    79399, 79428, 79458, 79487, 79517, 79546, 79576, 79606, 79635, 79665, 79695, 79724, 79753, 79783, 79812, 79841, 79871, 79900, 79930, 79960,
    79990];



/***/ }),

/***/ 3489:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
 * World Calendars
 * https://github.com/alexcjohnson/world-calendars
 *
 * Batch-converted from kbwood/calendars
 * Many thanks to Keith Wood and all of the contributors to the original project!
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

﻿/* http://keith-wood.name/calendars.html
   Calendars for jQuery v2.0.2.
   Written by Keith Wood (wood.keith{at}optusnet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

var assign = __webpack_require__(6131);


function Calendars() {
    this.regionalOptions = [];
    this.regionalOptions[''] = {
        invalidCalendar: 'Calendar {0} not found',
        invalidDate: 'Invalid {0} date',
        invalidMonth: 'Invalid {0} month',
        invalidYear: 'Invalid {0} year',
        differentCalendars: 'Cannot mix {0} and {1} dates'
    };
    this.local = this.regionalOptions[''];
    this.calendars = {};
    this._localCals = {};
}

/** Create the calendars plugin.
    <p>Provides support for various world calendars in a consistent manner.</p>
     @class Calendars
    @example _exports.instance('julian').newDate(2014, 12, 25) */
assign(Calendars.prototype, {

    /** Obtain a calendar implementation and localisation.
        @memberof Calendars
        @param [name='gregorian'] {string} The name of the calendar, e.g. 'gregorian', 'persian', 'islamic'.
        @param [language=''] {string} The language code to use for localisation (default is English).
        @return {Calendar} The calendar and localisation.
        @throws Error if calendar not found. */
    instance: function(name, language) {
        name = (name || 'gregorian').toLowerCase();
        language = language || '';
        var cal = this._localCals[name + '-' + language];
        if (!cal && this.calendars[name]) {
            cal = new this.calendars[name](language);
            this._localCals[name + '-' + language] = cal;
        }
        if (!cal) {
            throw (this.local.invalidCalendar || this.regionalOptions[''].invalidCalendar).
                replace(/\{0\}/, name);
        }
        return cal;
    },

    /** Create a new date - for today if no other parameters given.
        @memberof Calendars
        @param year {CDate|number} The date to copy or the year for the date.
        @param [month] {number} The month for the date.
        @param [day] {number} The day for the date.
        @param [calendar='gregorian'] {BaseCalendar|string} The underlying calendar or the name of the calendar.
        @param [language=''] {string} The language to use for localisation (default English).
        @return {CDate} The new date.
        @throws Error if an invalid date. */
    newDate: function(year, month, day, calendar, language) {
        calendar = (year != null && year.year ? year.calendar() : (typeof calendar === 'string' ?
            this.instance(calendar, language) : calendar)) || this.instance();
        return calendar.newDate(year, month, day);
    },
    
    /** A simple digit substitution function for localising numbers via the Calendar digits option.
        @member Calendars
        @param digits {string[]} The substitute digits, for 0 through 9.
        @return {function} The substitution function. */
    substituteDigits: function(digits) {
        return function(value) {
            return (value + '').replace(/[0-9]/g, function(digit) {
                return digits[digit];
            });
        }
    },
    
    /** Digit substitution function for localising Chinese style numbers via the Calendar digits option.
        @member Calendars
        @param digits {string[]} The substitute digits, for 0 through 9.
        @param powers {string[]} The characters denoting powers of 10, i.e. 1, 10, 100, 1000.
        @return {function} The substitution function. */
    substituteChineseDigits: function(digits, powers) {
        return function(value) {
            var localNumber = '';
            var power = 0;
            while (value > 0) {
                var units = value % 10;
                localNumber = (units === 0 ? '' : digits[units] + powers[power]) + localNumber;
                power++;
                value = Math.floor(value / 10);
            }
            if (localNumber.indexOf(digits[1] + powers[1]) === 0) {
                localNumber = localNumber.substr(1);
            }
            return localNumber || digits[0];
        }
    }
});

/** Generic date, based on a particular calendar.
    @class CDate
    @param calendar {BaseCalendar} The underlying calendar implementation.
    @param year {number} The year for this date.
    @param month {number} The month for this date.
    @param day {number} The day for this date.
    @return {CDate} The date object.
    @throws Error if an invalid date. */
function CDate(calendar, year, month, day) {
    this._calendar = calendar;
    this._year = year;
    this._month = month;
    this._day = day;
    if (this._calendar._validateLevel === 0 &&
            !this._calendar.isValid(this._year, this._month, this._day)) {
        throw (_exports.local.invalidDate || _exports.regionalOptions[''].invalidDate).
            replace(/\{0\}/, this._calendar.local.name);
    }
}

/** Pad a numeric value with leading zeroes.
    @private
    @param value {number} The number to format.
    @param length {number} The minimum length.
    @return {string} The formatted number. */
function pad(value, length) {
    value = '' + value;
    return '000000'.substring(0, length - value.length) + value;
}

assign(CDate.prototype, {

    /** Create a new date.
        @memberof CDate
        @param [year] {CDate|number} The date to copy or the year for the date (default this date).
        @param [month] {number} The month for the date.
        @param [day] {number} The day for the date.
        @return {CDate} The new date.
        @throws Error if an invalid date. */
    newDate: function(year, month, day) {
        return this._calendar.newDate((year == null ? this : year), month, day);
    },

    /** Set or retrieve the year for this date.
        @memberof CDate
        @param [year] {number} The year for the date.
        @return {number|CDate} The date's year (if no parameter) or the updated date.
        @throws Error if an invalid date. */
    year: function(year) {
        return (arguments.length === 0 ? this._year : this.set(year, 'y'));
    },

    /** Set or retrieve the month for this date.
        @memberof CDate
        @param [month] {number} The month for the date.
        @return {number|CDate} The date's month (if no parameter) or the updated date.
        @throws Error if an invalid date. */
    month: function(month) {
        return (arguments.length === 0 ? this._month : this.set(month, 'm'));
    },

    /** Set or retrieve the day for this date.
        @memberof CDate
        @param [day] {number} The day for the date.
        @return {number|CData} The date's day (if no parameter) or the updated date.
        @throws Error if an invalid date. */
    day: function(day) {
        return (arguments.length === 0 ? this._day : this.set(day, 'd'));
    },

    /** Set new values for this date.
        @memberof CDate
        @param year {number} The year for the date.
        @param month {number} The month for the date.
        @param day {number} The day for the date.
        @return {CDate} The updated date.
        @throws Error if an invalid date. */
    date: function(year, month, day) {
        if (!this._calendar.isValid(year, month, day)) {
            throw (_exports.local.invalidDate || _exports.regionalOptions[''].invalidDate).
                replace(/\{0\}/, this._calendar.local.name);
        }
        this._year = year;
        this._month = month;
        this._day = day;
        return this;
    },

    /** Determine whether this date is in a leap year.
        @memberof CDate
        @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not. */
    leapYear: function() {
        return this._calendar.leapYear(this);
    },

    /** Retrieve the epoch designator for this date, e.g. BCE or CE.
        @memberof CDate
        @return {string} The current epoch. */
    epoch: function() {
        return this._calendar.epoch(this);
    },

    /** Format the year, if not a simple sequential number.
        @memberof CDate
        @return {string} The formatted year. */
    formatYear: function() {
        return this._calendar.formatYear(this);
    },

    /** Retrieve the month of the year for this date,
        i.e. the month's position within a numbered year.
        @memberof CDate
        @return {number} The month of the year: <code>minMonth</code> to months per year. */
    monthOfYear: function() {
        return this._calendar.monthOfYear(this);
    },

    /** Retrieve the week of the year for this date.
        @memberof CDate
        @return {number} The week of the year: 1 to weeks per year. */
    weekOfYear: function() {
        return this._calendar.weekOfYear(this);
    },

    /** Retrieve the number of days in the year for this date.
        @memberof CDate
        @return {number} The number of days in this year. */
    daysInYear: function() {
        return this._calendar.daysInYear(this);
    },

    /** Retrieve the day of the year for this date.
        @memberof CDate
        @return {number} The day of the year: 1 to days per year. */
    dayOfYear: function() {
        return this._calendar.dayOfYear(this);
    },

    /** Retrieve the number of days in the month for this date.
        @memberof CDate
        @return {number} The number of days. */
    daysInMonth: function() {
        return this._calendar.daysInMonth(this);
    },

    /** Retrieve the day of the week for this date.
        @memberof CDate
        @return {number} The day of the week: 0 to number of days - 1. */
    dayOfWeek: function() {
        return this._calendar.dayOfWeek(this);
    },

    /** Determine whether this date is a week day.
        @memberof CDate
        @return {boolean} <code>true</code> if a week day, <code>false</code> if not. */
    weekDay: function() {
        return this._calendar.weekDay(this);
    },

    /** Retrieve additional information about this date.
        @memberof CDate
        @return {object} Additional information - contents depends on calendar. */
    extraInfo: function() {
        return this._calendar.extraInfo(this);
    },

    /** Add period(s) to a date.
        @memberof CDate
        @param offset {number} The number of periods to adjust by.
        @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
        @return {CDate} The updated date. */
    add: function(offset, period) {
        return this._calendar.add(this, offset, period);
    },

    /** Set a portion of the date.
        @memberof CDate
        @param value {number} The new value for the period.
        @param period {string} One of 'y' for year, 'm' for month, 'd' for day.
        @return {CDate} The updated date.
        @throws Error if not a valid date. */
    set: function(value, period) {
        return this._calendar.set(this, value, period);
    },

    /** Compare this date to another date.
        @memberof CDate
        @param date {CDate} The other date.
        @return {number} -1 if this date is before the other date,
                0 if they are equal, or +1 if this date is after the other date. */
    compareTo: function(date) {
        if (this._calendar.name !== date._calendar.name) {
            throw (_exports.local.differentCalendars || _exports.regionalOptions[''].differentCalendars).
                replace(/\{0\}/, this._calendar.local.name).replace(/\{1\}/, date._calendar.local.name);
        }
        var c = (this._year !== date._year ? this._year - date._year :
            this._month !== date._month ? this.monthOfYear() - date.monthOfYear() :
            this._day - date._day);
        return (c === 0 ? 0 : (c < 0 ? -1 : +1));
    },

    /** Retrieve the calendar backing this date.
        @memberof CDate
        @return {BaseCalendar} The calendar implementation. */
    calendar: function() {
        return this._calendar;
    },

    /** Retrieve the Julian date equivalent for this date,
        i.e. days since January 1, 4713 BCE Greenwich noon.
        @memberof CDate
        @return {number} The equivalent Julian date. */
    toJD: function() {
        return this._calendar.toJD(this);
    },

    /** Create a new date from a Julian date.
        @memberof CDate
        @param jd {number} The Julian date to convert.
        @return {CDate} The equivalent date. */
    fromJD: function(jd) {
        return this._calendar.fromJD(jd);
    },

    /** Convert this date to a standard (Gregorian) JavaScript Date.
        @memberof CDate
        @return {Date} The equivalent JavaScript date. */
    toJSDate: function() {
        return this._calendar.toJSDate(this);
    },

    /** Create a new date from a standard (Gregorian) JavaScript Date.
        @memberof CDate
        @param jsd {Date} The JavaScript date to convert.
        @return {CDate} The equivalent date. */
    fromJSDate: function(jsd) {
        return this._calendar.fromJSDate(jsd);
    },

    /** Convert to a string for display.
        @memberof CDate
        @return {string} This date as a string. */
    toString: function() {
        return (this.year() < 0 ? '-' : '') + pad(Math.abs(this.year()), 4) +
            '-' + pad(this.month(), 2) + '-' + pad(this.day(), 2);
    }
});

/** Basic functionality for all calendars.
    Other calendars should extend this:
    <pre>OtherCalendar.prototype = new BaseCalendar;</pre>
    @class BaseCalendar */
function BaseCalendar() {
    this.shortYearCutoff = '+10';
}

assign(BaseCalendar.prototype, {
    _validateLevel: 0, // "Stack" to turn validation on/off

    /** Create a new date within this calendar - today if no parameters given.
        @memberof BaseCalendar
        @param year {CDate|number} The date to duplicate or the year for the date.
        @param [month] {number} The month for the date.
        @param [day] {number} The day for the date.
        @return {CDate} The new date.
        @throws Error if not a valid date or a different calendar used. */
    newDate: function(year, month, day) {
        if (year == null) {
            return this.today();
        }
        if (year.year) {
            this._validate(year, month, day,
                _exports.local.invalidDate || _exports.regionalOptions[''].invalidDate);
            day = year.day();
            month = year.month();
            year = year.year();
        }
        return new CDate(this, year, month, day);
    },

    /** Create a new date for today.
        @memberof BaseCalendar
        @return {CDate} Today's date. */
    today: function() {
        return this.fromJSDate(new Date());
    },

    /** Retrieve the epoch designator for this date.
        @memberof BaseCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {string} The current epoch.
        @throws Error if an invalid year or a different calendar used. */
    epoch: function(year) {
        var date = this._validate(year, this.minMonth, this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[''].invalidYear);
        return (date.year() < 0 ? this.local.epochs[0] : this.local.epochs[1]);
    },

    /** Format the year, if not a simple sequential number
        @memberof BaseCalendar
        @param year {CDate|number} The date to format or the year to format.
        @return {string} The formatted year.
        @throws Error if an invalid year or a different calendar used. */
    formatYear: function(year) {
        var date = this._validate(year, this.minMonth, this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[''].invalidYear);
        return (date.year() < 0 ? '-' : '') + pad(Math.abs(date.year()), 4)
    },

    /** Retrieve the number of months in a year.
        @memberof BaseCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {number} The number of months.
        @throws Error if an invalid year or a different calendar used. */
    monthsInYear: function(year) {
        this._validate(year, this.minMonth, this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[''].invalidYear);
        return 12;
    },

    /** Calculate the month's ordinal position within the year -
        for those calendars that don't start at month 1!
        @memberof BaseCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param month {number} The month to examine.
        @return {number} The ordinal position, starting from <code>minMonth</code>.
        @throws Error if an invalid year/month or a different calendar used. */
    monthOfYear: function(year, month) {
        var date = this._validate(year, month, this.minDay,
            _exports.local.invalidMonth || _exports.regionalOptions[''].invalidMonth);
        return (date.month() + this.monthsInYear(date) - this.firstMonth) %
            this.monthsInYear(date) + this.minMonth;
    },

    /** Calculate actual month from ordinal position, starting from minMonth.
        @memberof BaseCalendar
        @param year {number} The year to examine.
        @param ord {number} The month's ordinal position.
        @return {number} The month's number.
        @throws Error if an invalid year/month. */
    fromMonthOfYear: function(year, ord) {
        var m = (ord + this.firstMonth - 2 * this.minMonth) %
            this.monthsInYear(year) + this.minMonth;
        this._validate(year, m, this.minDay,
            _exports.local.invalidMonth || _exports.regionalOptions[''].invalidMonth);
        return m;
    },

    /** Retrieve the number of days in a year.
        @memberof BaseCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {number} The number of days.
        @throws Error if an invalid year or a different calendar used. */
    daysInYear: function(year) {
        var date = this._validate(year, this.minMonth, this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[''].invalidYear);
        return (this.leapYear(date) ? 366 : 365);
    },

    /** Retrieve the day of the year for a date.
        @memberof BaseCalendar
        @param year {CDate|number} The date to convert or the year to convert.
        @param [month] {number} The month to convert.
        @param [day] {number} The day to convert.
        @return {number} The day of the year.
        @throws Error if an invalid date or a different calendar used. */
    dayOfYear: function(year, month, day) {
        var date = this._validate(year, month, day,
            _exports.local.invalidDate || _exports.regionalOptions[''].invalidDate);
        return date.toJD() - this.newDate(date.year(),
            this.fromMonthOfYear(date.year(), this.minMonth), this.minDay).toJD() + 1;
    },

    /** Retrieve the number of days in a week.
        @memberof BaseCalendar
        @return {number} The number of days. */
    daysInWeek: function() {
        return 7;
    },

    /** Retrieve the day of the week for a date.
        @memberof BaseCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {number} The day of the week: 0 to number of days - 1.
        @throws Error if an invalid date or a different calendar used. */
    dayOfWeek: function(year, month, day) {
        var date = this._validate(year, month, day,
            _exports.local.invalidDate || _exports.regionalOptions[''].invalidDate);
        return (Math.floor(this.toJD(date)) + 2) % this.daysInWeek();
    },

    /** Retrieve additional information about a date.
        @memberof BaseCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {object} Additional information - contents depends on calendar.
        @throws Error if an invalid date or a different calendar used. */
    extraInfo: function(year, month, day) {
        this._validate(year, month, day,
            _exports.local.invalidDate || _exports.regionalOptions[''].invalidDate);
        return {};
    },

    /** Add period(s) to a date.
        Cater for no year zero.
        @memberof BaseCalendar
        @param date {CDate} The starting date.
        @param offset {number} The number of periods to adjust by.
        @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
        @return {CDate} The updated date.
        @throws Error if a different calendar used. */
    add: function(date, offset, period) {
        this._validate(date, this.minMonth, this.minDay,
            _exports.local.invalidDate || _exports.regionalOptions[''].invalidDate);
        return this._correctAdd(date, this._add(date, offset, period), offset, period);
    },

    /** Add period(s) to a date.
        @memberof BaseCalendar
        @private
        @param date {CDate} The starting date.
        @param offset {number} The number of periods to adjust by.
        @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
        @return {CDate} The updated date. */
    _add: function(date, offset, period) {
        this._validateLevel++;
        if (period === 'd' || period === 'w') {
            var jd = date.toJD() + offset * (period === 'w' ? this.daysInWeek() : 1);
            var d = date.calendar().fromJD(jd);
            this._validateLevel--;
            return [d.year(), d.month(), d.day()];
        }
        try {
            var y = date.year() + (period === 'y' ? offset : 0);
            var m = date.monthOfYear() + (period === 'm' ? offset : 0);
            var d = date.day();// + (period === 'd' ? offset : 0) +
                //(period === 'w' ? offset * this.daysInWeek() : 0);
            var resyncYearMonth = function(calendar) {
                while (m < calendar.minMonth) {
                    y--;
                    m += calendar.monthsInYear(y);
                }
                var yearMonths = calendar.monthsInYear(y);
                while (m > yearMonths - 1 + calendar.minMonth) {
                    y++;
                    m -= yearMonths;
                    yearMonths = calendar.monthsInYear(y);
                }
            };
            if (period === 'y') {
                if (date.month() !== this.fromMonthOfYear(y, m)) { // Hebrew
                    m = this.newDate(y, date.month(), this.minDay).monthOfYear();
                }
                m = Math.min(m, this.monthsInYear(y));
                d = Math.min(d, this.daysInMonth(y, this.fromMonthOfYear(y, m)));
            }
            else if (period === 'm') {
                resyncYearMonth(this);
                d = Math.min(d, this.daysInMonth(y, this.fromMonthOfYear(y, m)));
            }
            var ymd = [y, this.fromMonthOfYear(y, m), d];
            this._validateLevel--;
            return ymd;
        }
        catch (e) {
            this._validateLevel--;
            throw e;
        }
    },

    /** Correct a candidate date after adding period(s) to a date.
        Handle no year zero if necessary.
        @memberof BaseCalendar
        @private
        @param date {CDate} The starting date.
        @param ymd {number[]} The added date.
        @param offset {number} The number of periods to adjust by.
        @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
        @return {CDate} The updated date. */
    _correctAdd: function(date, ymd, offset, period) {
        if (!this.hasYearZero && (period === 'y' || period === 'm')) {
            if (ymd[0] === 0 || // In year zero
                    (date.year() > 0) !== (ymd[0] > 0)) { // Crossed year zero
                var adj = {y: [1, 1, 'y'], m: [1, this.monthsInYear(-1), 'm'],
                    w: [this.daysInWeek(), this.daysInYear(-1), 'd'],
                    d: [1, this.daysInYear(-1), 'd']}[period];
                var dir = (offset < 0 ? -1 : +1);
                ymd = this._add(date, offset * adj[0] + dir * adj[1], adj[2]);
            }
        }
        return date.date(ymd[0], ymd[1], ymd[2]);
    },

    /** Set a portion of the date.
        @memberof BaseCalendar
        @param date {CDate} The starting date.
        @param value {number} The new value for the period.
        @param period {string} One of 'y' for year, 'm' for month, 'd' for day.
        @return {CDate} The updated date.
        @throws Error if an invalid date or a different calendar used. */
    set: function(date, value, period) {
        this._validate(date, this.minMonth, this.minDay,
            _exports.local.invalidDate || _exports.regionalOptions[''].invalidDate);
        var y = (period === 'y' ? value : date.year());
        var m = (period === 'm' ? value : date.month());
        var d = (period === 'd' ? value : date.day());
        if (period === 'y' || period === 'm') {
            d = Math.min(d, this.daysInMonth(y, m));
        }
        return date.date(y, m, d);
    },

    /** Determine whether a date is valid for this calendar.
        @memberof BaseCalendar
        @param year {number} The year to examine.
        @param month {number} The month to examine.
        @param day {number} The day to examine.
        @return {boolean} <code>true</code> if a valid date, <code>false</code> if not. */
    isValid: function(year, month, day) {
        this._validateLevel++;
        var valid = (this.hasYearZero || year !== 0);
        if (valid) {
            var date = this.newDate(year, month, this.minDay);
            valid = (month >= this.minMonth && month - this.minMonth < this.monthsInYear(date)) &&
                (day >= this.minDay && day - this.minDay < this.daysInMonth(date));
        }
        this._validateLevel--;
        return valid;
    },

    /** Convert the date to a standard (Gregorian) JavaScript Date.
        @memberof BaseCalendar
        @param year {CDate|number} The date to convert or the year to convert.
        @param [month] {number} The month to convert.
        @param [day] {number} The day to convert.
        @return {Date} The equivalent JavaScript date.
        @throws Error if an invalid date or a different calendar used. */
    toJSDate: function(year, month, day) {
        var date = this._validate(year, month, day,
            _exports.local.invalidDate || _exports.regionalOptions[''].invalidDate);
        return _exports.instance().fromJD(this.toJD(date)).toJSDate();
    },

    /** Convert the date from a standard (Gregorian) JavaScript Date.
        @memberof BaseCalendar
        @param jsd {Date} The JavaScript date.
        @return {CDate} The equivalent calendar date. */
    fromJSDate: function(jsd) {
        return this.fromJD(_exports.instance().fromJSDate(jsd).toJD());
    },

    /** Check that a candidate date is from the same calendar and is valid.
        @memberof BaseCalendar
        @private
        @param year {CDate|number} The date to validate or the year to validate.
        @param [month] {number} The month to validate.
        @param [day] {number} The day to validate.
        @param error {string} Rrror message if invalid.
        @throws Error if different calendars used or invalid date. */
    _validate: function(year, month, day, error) {
        if (year.year) {
            if (this._validateLevel === 0 && this.name !== year.calendar().name) {
                throw (_exports.local.differentCalendars || _exports.regionalOptions[''].differentCalendars).
                    replace(/\{0\}/, this.local.name).replace(/\{1\}/, year.calendar().local.name);
            }
            return year;
        }
        try {
            this._validateLevel++;
            if (this._validateLevel === 1 && !this.isValid(year, month, day)) {
                throw error.replace(/\{0\}/, this.local.name);
            }
            var date = this.newDate(year, month, day);
            this._validateLevel--;
            return date;
        }
        catch (e) {
            this._validateLevel--;
            throw e;
        }
    }
});

/** Implementation of the Proleptic Gregorian Calendar.
    See <a href=":http://en.wikipedia.org/wiki/Gregorian_calendar">http://en.wikipedia.org/wiki/Gregorian_calendar</a>
    and <a href="http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar</a>.
    @class GregorianCalendar
    @augments BaseCalendar
    @param [language=''] {string} The language code (default English) for localisation. */
function GregorianCalendar(language) {
    this.local = this.regionalOptions[language] || this.regionalOptions[''];
}

GregorianCalendar.prototype = new BaseCalendar;

assign(GregorianCalendar.prototype, {
    /** The calendar name.
        @memberof GregorianCalendar */
    name: 'Gregorian',
     /** Julian date of start of Gregorian epoch: 1 January 0001 CE.
        @memberof GregorianCalendar */
    jdEpoch: 1721425.5,
     /** Days per month in a common year.
        @memberof GregorianCalendar */
    daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
     /** <code>true</code> if has a year zero, <code>false</code> if not.
        @memberof GregorianCalendar */
    hasYearZero: false,
    /** The minimum month number.
        @memberof GregorianCalendar */
    minMonth: 1,
    /** The first month in the year.
        @memberof GregorianCalendar */
    firstMonth: 1,
     /** The minimum day number.
        @memberof GregorianCalendar */
    minDay: 1,

    /** Localisations for the plugin.
        Entries are objects indexed by the language code ('' being the default US/English).
        Each object has the following attributes.
        @memberof GregorianCalendar
        @property name {string} The calendar name.
        @property epochs {string[]} The epoch names.
        @property monthNames {string[]} The long names of the months of the year.
        @property monthNamesShort {string[]} The short names of the months of the year.
        @property dayNames {string[]} The long names of the days of the week.
        @property dayNamesShort {string[]} The short names of the days of the week.
        @property dayNamesMin {string[]} The minimal names of the days of the week.
        @property dateFormat {string} The date format for this calendar.
                See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
        @property firstDay {number} The number of the first day of the week, starting at 0.
        @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
    regionalOptions: { // Localisations
        '': {
            name: 'Gregorian',
            epochs: ['BCE', 'CE'],
            monthNames: ['January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'],
            monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
            digits: null,
            dateFormat: 'mm/dd/yyyy',
            firstDay: 0,
            isRTL: false
        }
    },
    
    /** Determine whether this date is in a leap year.
        @memberof GregorianCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
        @throws Error if an invalid year or a different calendar used. */
    leapYear: function(year) {
        var date = this._validate(year, this.minMonth, this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[''].invalidYear);
        var year = date.year() + (date.year() < 0 ? 1 : 0); // No year zero
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    },

    /** Determine the week of the year for a date - ISO 8601.
        @memberof GregorianCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {number} The week of the year, starting from 1.
        @throws Error if an invalid date or a different calendar used. */
    weekOfYear: function(year, month, day) {
        // Find Thursday of this week starting on Monday
        var checkDate = this.newDate(year, month, day);
        checkDate.add(4 - (checkDate.dayOfWeek() || 7), 'd');
        return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
    },

    /** Retrieve the number of days in a month.
        @memberof GregorianCalendar
        @param year {CDate|number} The date to examine or the year of the month.
        @param [month] {number} The month.
        @return {number} The number of days in this month.
        @throws Error if an invalid month/year or a different calendar used. */
    daysInMonth: function(year, month) {
        var date = this._validate(year, month, this.minDay,
            _exports.local.invalidMonth || _exports.regionalOptions[''].invalidMonth);
        return this.daysPerMonth[date.month() - 1] +
            (date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
    },

    /** Determine whether this date is a week day.
        @memberof GregorianCalendar
        @param year {CDate|number} The date to examine or the year to examine.
        @param [month] {number} The month to examine.
        @param [day] {number} The day to examine.
        @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
        @throws Error if an invalid date or a different calendar used. */
    weekDay: function(year, month, day) {
        return (this.dayOfWeek(year, month, day) || 7) < 6;
    },

    /** Retrieve the Julian date equivalent for this date,
        i.e. days since January 1, 4713 BCE Greenwich noon.
        @memberof GregorianCalendar
        @param year {CDate|number} The date to convert or the year to convert.
        @param [month] {number} The month to convert.
        @param [day] {number} The day to convert.
        @return {number} The equivalent Julian date.
        @throws Error if an invalid date or a different calendar used. */
    toJD: function(year, month, day) {
        var date = this._validate(year, month, day,
            _exports.local.invalidDate || _exports.regionalOptions[''].invalidDate);
        year = date.year();
        month = date.month();
        day = date.day();
        if (year < 0) { year++; } // No year zero
        // Jean Meeus algorithm, "Astronomical Algorithms", 1991
        if (month < 3) {
            month += 12;
            year--;
        }
        var a = Math.floor(year / 100);
        var b = 2 - a + Math.floor(a / 4);
        return Math.floor(365.25 * (year + 4716)) +
            Math.floor(30.6001 * (month + 1)) + day + b - 1524.5;
    },

    /** Create a new date from a Julian date.
        @memberof GregorianCalendar
        @param jd {number} The Julian date to convert.
        @return {CDate} The equivalent date. */
    fromJD: function(jd) {
        // Jean Meeus algorithm, "Astronomical Algorithms", 1991
        var z = Math.floor(jd + 0.5);
        var a = Math.floor((z - 1867216.25) / 36524.25);
        a = z + 1 + a - Math.floor(a / 4);
        var b = a + 1524;
        var c = Math.floor((b - 122.1) / 365.25);
        var d = Math.floor(365.25 * c);
        var e = Math.floor((b - d) / 30.6001);
        var day = b - d - Math.floor(e * 30.6001);
        var month = e - (e > 13.5 ? 13 : 1);
        var year = c - (month > 2.5 ? 4716 : 4715);
        if (year <= 0) { year--; } // No year zero
        return this.newDate(year, month, day);
    },

    /** Convert this date to a standard (Gregorian) JavaScript Date.
        @memberof GregorianCalendar
        @param year {CDate|number} The date to convert or the year to convert.
        @param [month] {number} The month to convert.
        @param [day] {number} The day to convert.
        @return {Date} The equivalent JavaScript date.
        @throws Error if an invalid date or a different calendar used. */
    toJSDate: function(year, month, day) {
        var date = this._validate(year, month, day,
            _exports.local.invalidDate || _exports.regionalOptions[''].invalidDate);
        var jsd = new Date(date.year(), date.month() - 1, date.day());
        jsd.setHours(0);
        jsd.setMinutes(0);
        jsd.setSeconds(0);
        jsd.setMilliseconds(0);
        // Hours may be non-zero on daylight saving cut-over:
        // > 12 when midnight changeover, but then cannot generate
        // midnight datetime, so jump to 1AM, otherwise reset.
        jsd.setHours(jsd.getHours() > 12 ? jsd.getHours() + 2 : 0);
        return jsd;
    },

    /** Create a new date from a standard (Gregorian) JavaScript Date.
        @memberof GregorianCalendar
        @param jsd {Date} The JavaScript date to convert.
        @return {CDate} The equivalent date. */
    fromJSDate: function(jsd) {
        return this.newDate(jsd.getFullYear(), jsd.getMonth() + 1, jsd.getDate());
    }
});

// Singleton manager
var _exports = module.exports = new Calendars();

// Date template
_exports.cdate = CDate;

// Base calendar template
_exports.baseCalendar = BaseCalendar;

// Gregorian calendar implementation
_exports.calendars.gregorian = GregorianCalendar;



/***/ }),

/***/ 4338:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/*
 * World Calendars
 * https://github.com/alexcjohnson/world-calendars
 *
 * Batch-converted from kbwood/calendars
 * Many thanks to Keith Wood and all of the contributors to the original project!
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

﻿/* http://keith-wood.name/calendars.html
   Calendars extras for jQuery v2.0.2.
   Written by Keith Wood (wood.keith{at}optusnet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

var assign = __webpack_require__(6131);
var main = __webpack_require__(3489);


assign(main.regionalOptions[''], {
    invalidArguments: 'Invalid arguments',
    invalidFormat: 'Cannot format a date from another calendar',
    missingNumberAt: 'Missing number at position {0}',
    unknownNameAt: 'Unknown name at position {0}',
    unexpectedLiteralAt: 'Unexpected literal at position {0}',
    unexpectedText: 'Additional text found at end'
});
main.local = main.regionalOptions[''];

assign(main.cdate.prototype, {

    /** Format this date.
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof CDate
        @param [format] {string} The date format to use (see <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a>).
        @param [settings] {object} Options for the <code>formatDate</code> function.
        @return {string} The formatted date. */
    formatDate: function(format, settings) {
        if (typeof format !== 'string') {
            settings = format;
            format = '';
        }
        return this._calendar.formatDate(format || '', this, settings);
    }
});

assign(main.baseCalendar.prototype, {

    UNIX_EPOCH: main.instance().newDate(1970, 1, 1).toJD(),
    SECS_PER_DAY: 24 * 60 * 60,
    TICKS_EPOCH: main.instance().jdEpoch, // 1 January 0001 CE
    TICKS_PER_DAY: 24 * 60 * 60 * 10000000,

    /** Date form for ATOM (RFC 3339/ISO 8601).
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof BaseCalendar */
    ATOM: 'yyyy-mm-dd',
    /** Date form for cookies.
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof BaseCalendar */
    COOKIE: 'D, dd M yyyy',
    /** Date form for full date.
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof BaseCalendar */
    FULL: 'DD, MM d, yyyy',
    /** Date form for ISO 8601.
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof BaseCalendar */
    ISO_8601: 'yyyy-mm-dd',
    /** Date form for Julian date.
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof BaseCalendar */
    JULIAN: 'J',
    /** Date form for RFC 822.
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof BaseCalendar */
    RFC_822: 'D, d M yy',
    /** Date form for RFC 850.
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof BaseCalendar */
    RFC_850: 'DD, dd-M-yy',
    /** Date form for RFC 1036.
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof BaseCalendar */
    RFC_1036: 'D, d M yy',
    /** Date form for RFC 1123.
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof BaseCalendar */
    RFC_1123: 'D, d M yyyy',
    /** Date form for RFC 2822.
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof BaseCalendar */
    RFC_2822: 'D, d M yyyy',
    /** Date form for RSS (RFC 822).
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof BaseCalendar */
    RSS: 'D, d M yy',
    /** Date form for Windows ticks.
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof BaseCalendar */
    TICKS: '!',
    /** Date form for Unix timestamp.
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof BaseCalendar */
    TIMESTAMP: '@',
    /** Date form for W3c (ISO 8601).
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof BaseCalendar */
    W3C: 'yyyy-mm-dd',

    /** Format a date object into a string value.
        The format can be combinations of the following:
        <ul>
        <li>d  - day of month (no leading zero)</li>
        <li>dd - day of month (two digit)</li>
        <li>o  - day of year (no leading zeros)</li>
        <li>oo - day of year (three digit)</li>
        <li>D  - day name short</li>
        <li>DD - day name long</li>
        <li>w  - week of year (no leading zero)</li>
        <li>ww - week of year (two digit)</li>
        <li>m  - month of year (no leading zero)</li>
        <li>mm - month of year (two digit)</li>
        <li>M  - month name short</li>
        <li>MM - month name long</li>
        <li>yy - year (two digit)</li>
        <li>yyyy - year (four digit)</li>
        <li>YYYY - formatted year</li>
        <li>J  - Julian date (days since January 1, 4713 BCE Greenwich noon)</li>
        <li>@  - Unix timestamp (s since 01/01/1970)</li>
        <li>!  - Windows ticks (100ns since 01/01/0001)</li>
        <li>'...' - literal text</li>
        <li>'' - single quote</li>
        </ul>
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof BaseCalendar
        @param [format] {string} The desired format of the date (defaults to calendar format).
        @param date {CDate} The date value to format.
        @param [settings] {object} Addition options, whose attributes include:
        @property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
        @property [dayNames] {string[]} Names of the days from Sunday.
        @property [monthNamesShort] {string[]} Abbreviated names of the months.
        @property [monthNames] {string[]} Names of the months.
        @property [calculateWeek] {CalendarsPickerCalculateWeek} Function that determines week of the year.
        @property [localNumbers=false] {boolean} <code>true</code> to localise numbers (if available),
                  <code>false</code> to use normal Arabic numerals.
        @return {string} The date in the above format.
        @throws Errors if the date is from a different calendar. */
    formatDate: function(format, date, settings) {
        if (typeof format !== 'string') {
            settings = date;
            date = format;
            format = '';
        }
        if (!date) {
            return '';
        }
        if (date.calendar() !== this) {
            throw main.local.invalidFormat || main.regionalOptions[''].invalidFormat;
        }
        format = format || this.local.dateFormat;
        settings = settings || {};
        var dayNamesShort = settings.dayNamesShort || this.local.dayNamesShort;
        var dayNames = settings.dayNames || this.local.dayNames;
        var monthNumbers = settings.monthNumbers || this.local.monthNumbers;
        var monthNamesShort = settings.monthNamesShort || this.local.monthNamesShort;
        var monthNames = settings.monthNames || this.local.monthNames;
        var calculateWeek = settings.calculateWeek || this.local.calculateWeek;
        // Check whether a format character is doubled
        var doubled = function(match, step) {
            var matches = 1;
            while (iFormat + matches < format.length && format.charAt(iFormat + matches) === match) {
                matches++;
            }
            iFormat += matches - 1;
            return Math.floor(matches / (step || 1)) > 1;
        };
        // Format a number, with leading zeroes if necessary
        var formatNumber = function(match, value, len, step) {
            var num = '' + value;
            if (doubled(match, step)) {
                while (num.length < len) {
                    num = '0' + num;
                }
            }
            return num;
        };
        // Format a name, short or long as requested
        var formatName = function(match, value, shortNames, longNames) {
            return (doubled(match) ? longNames[value] : shortNames[value]);
        };
        // Format month number
        // (e.g. Chinese calendar needs to account for intercalary months)
        var calendar = this;
        var formatMonth = function(date) {
            return (typeof monthNumbers === 'function') ?
                monthNumbers.call(calendar, date, doubled('m')) :
                localiseNumbers(formatNumber('m', date.month(), 2));
        };
        // Format a month name, short or long as requested
        var formatMonthName = function(date, useLongName) {
            if (useLongName) {
                return (typeof monthNames === 'function') ?
                    monthNames.call(calendar, date) :
                    monthNames[date.month() - calendar.minMonth];
            } else {
                return (typeof monthNamesShort === 'function') ?
                    monthNamesShort.call(calendar, date) :
                    monthNamesShort[date.month() - calendar.minMonth];
            }
        };
        // Localise numbers if requested and available
        var digits = this.local.digits;
        var localiseNumbers = function(value) {
            return (settings.localNumbers && digits ? digits(value) : value);
        };
        var output = '';
        var literal = false;
        for (var iFormat = 0; iFormat < format.length; iFormat++) {
            if (literal) {
                if (format.charAt(iFormat) === "'" && !doubled("'")) {
                    literal = false;
                }
                else {
                    output += format.charAt(iFormat);
                }
            }
            else {
                switch (format.charAt(iFormat)) {
                    case 'd': output += localiseNumbers(formatNumber('d', date.day(), 2)); break;
                    case 'D': output += formatName('D', date.dayOfWeek(),
                        dayNamesShort, dayNames); break;
                    case 'o': output += formatNumber('o', date.dayOfYear(), 3); break;
                    case 'w': output += formatNumber('w', date.weekOfYear(), 2); break;
                    case 'm': output += formatMonth(date); break;
                    case 'M': output += formatMonthName(date, doubled('M')); break;
                    case 'y':
                        output += (doubled('y', 2) ? date.year() :
                            (date.year() % 100 < 10 ? '0' : '') + date.year() % 100);
                        break;
                    case 'Y':
                        doubled('Y', 2);
                        output += date.formatYear();
                        break;
                    case 'J': output += date.toJD(); break;
                    case '@': output += (date.toJD() - this.UNIX_EPOCH) * this.SECS_PER_DAY; break;
                    case '!': output += (date.toJD() - this.TICKS_EPOCH) * this.TICKS_PER_DAY; break;
                    case "'":
                        if (doubled("'")) {
                            output += "'";
                        }
                        else {
                            literal = true;
                        }
                        break;
                    default:
                        output += format.charAt(iFormat);
                }
            }
        }
        return output;
    },

    /** Parse a string value into a date object.
        See <a href="#formatDate"><code>formatDate</code></a> for the possible formats, plus:
        <ul>
        <li>* - ignore rest of string</li>
        </ul>
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof BaseCalendar
        @param format {string} The expected format of the date ('' for default calendar format).
        @param value {string} The date in the above format.
        @param [settings] {object} Additional options whose attributes include:
        @property [shortYearCutoff] {number} The cutoff year for determining the century.
        @property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
        @property [dayNames] {string[]} Names of the days from Sunday.
        @property [monthNamesShort] {string[]} Abbreviated names of the months.
        @property [monthNames] {string[]} Names of the months.
        @return {CDate} The extracted date value or <code>null</code> if value is blank.
        @throws Errors if the format and/or value are missing,
                if the value doesn't match the format, or if the date is invalid. */
    parseDate: function(format, value, settings) {
        if (value == null) {
            throw main.local.invalidArguments || main.regionalOptions[''].invalidArguments;
        }
        value = (typeof value === 'object' ? value.toString() : value + '');
        if (value === '') {
            return null;
        }
        format = format || this.local.dateFormat;
        settings = settings || {};
        var shortYearCutoff = settings.shortYearCutoff || this.shortYearCutoff;
        shortYearCutoff = (typeof shortYearCutoff !== 'string' ? shortYearCutoff :
            this.today().year() % 100 + parseInt(shortYearCutoff, 10));
        var dayNamesShort = settings.dayNamesShort || this.local.dayNamesShort;
        var dayNames = settings.dayNames || this.local.dayNames;
        var parseMonth = settings.parseMonth || this.local.parseMonth;
        var monthNumbers = settings.monthNumbers || this.local.monthNumbers;
        var monthNamesShort = settings.monthNamesShort || this.local.monthNamesShort;
        var monthNames = settings.monthNames || this.local.monthNames;
        var jd = -1;
        var year = -1;
        var month = -1;
        var day = -1;
        var doy = -1;
        var shortYear = false;
        var literal = false;
        // Check whether a format character is doubled
        var doubled = function(match, step) {
            var matches = 1;
            while (iFormat + matches < format.length && format.charAt(iFormat + matches) === match) {
                matches++;
            }
            iFormat += matches - 1;
            return Math.floor(matches / (step || 1)) > 1;
        };
        // Extract a number from the string value
        var getNumber = function(match, step) {
            var isDoubled = doubled(match, step);
            var size = [2, 3, isDoubled ? 4 : 2, isDoubled ? 4 : 2, 10, 11, 20]['oyYJ@!'.indexOf(match) + 1];
            var digits = new RegExp('^-?\\d{1,' + size + '}');
            var num = value.substring(iValue).match(digits);
            if (!num) {
                throw (main.local.missingNumberAt || main.regionalOptions[''].missingNumberAt).
                    replace(/\{0\}/, iValue);
            }
            iValue += num[0].length;
            return parseInt(num[0], 10);
        };
        // Extract a month number from the string value
        var calendar = this;
        var getMonthNumber = function() {
            if (typeof monthNumbers === 'function') {
                doubled('m');  // update iFormat
                var month = monthNumbers.call(calendar, value.substring(iValue));
                iValue += month.length;
                return month;
            }

            return getNumber('m');
        };
        // Extract a name from the string value and convert to an index
        var getName = function(match, shortNames, longNames, step) {
            var names = (doubled(match, step) ? longNames : shortNames);
            for (var i = 0; i < names.length; i++) {
                if (value.substr(iValue, names[i].length).toLowerCase() === names[i].toLowerCase()) {
                    iValue += names[i].length;
                    return i + calendar.minMonth;
                }
            }
            throw (main.local.unknownNameAt || main.regionalOptions[''].unknownNameAt).
                replace(/\{0\}/, iValue);
        };
        // Extract a month number from the string value
        var getMonthName = function() {
            if (typeof monthNames === 'function') {
                var month = doubled('M') ?
                    monthNames.call(calendar, value.substring(iValue)) :
                    monthNamesShort.call(calendar, value.substring(iValue));
                iValue += month.length;
                return month;
            }

            return getName('M', monthNamesShort, monthNames);
        };
        // Confirm that a literal character matches the string value
        var checkLiteral = function() {
            if (value.charAt(iValue) !== format.charAt(iFormat)) {
                throw (main.local.unexpectedLiteralAt ||
                    main.regionalOptions[''].unexpectedLiteralAt).replace(/\{0\}/, iValue);
            }
            iValue++;
        };
        var iValue = 0;
        for (var iFormat = 0; iFormat < format.length; iFormat++) {
            if (literal) {
                if (format.charAt(iFormat) === "'" && !doubled("'")) {
                    literal = false;
                }
                else {
                    checkLiteral();
                }
            }
            else {
                switch (format.charAt(iFormat)) {
                    case 'd': day = getNumber('d'); break;
                    case 'D': getName('D', dayNamesShort, dayNames); break;
                    case 'o': doy = getNumber('o'); break;
                    case 'w': getNumber('w'); break;
                    case 'm': month = getMonthNumber(); break;
                    case 'M': month = getMonthName(); break;
                    case 'y':
                        var iSave = iFormat;
                        shortYear = !doubled('y', 2);
                        iFormat = iSave;
                        year = getNumber('y', 2);
                        break;
                    case 'Y': year = getNumber('Y', 2); break;
                    case 'J':
                        jd = getNumber('J') + 0.5;
                        if (value.charAt(iValue) === '.') {
                            iValue++;
                            getNumber('J');
                        }
                        break;
                    case '@': jd = getNumber('@') / this.SECS_PER_DAY + this.UNIX_EPOCH; break;
                    case '!': jd = getNumber('!') / this.TICKS_PER_DAY + this.TICKS_EPOCH; break;
                    case '*': iValue = value.length; break;
                    case "'":
                        if (doubled("'")) {
                            checkLiteral();
                        }
                        else {
                            literal = true;
                        }
                        break;
                    default: checkLiteral();
                }
            }
        }
        if (iValue < value.length) {
            throw main.local.unexpectedText || main.regionalOptions[''].unexpectedText;
        }
        if (year === -1) {
            year = this.today().year();
        }
        else if (year < 100 && shortYear) {
            year += (shortYearCutoff === -1 ? 1900 : this.today().year() -
                this.today().year() % 100 - (year <= shortYearCutoff ? 0 : 100));
        }
        if (typeof month === 'string') {
            month = parseMonth.call(this, year, month);
        }
        if (doy > -1) {
            month = 1;
            day = doy;
            for (var dim = this.daysInMonth(year, month); day > dim; dim = this.daysInMonth(year, month)) {
                month++;
                day -= dim;
            }
        }
        return (jd > -1 ? this.fromJD(jd) : this.newDate(year, month, day));
    },

    /** A date may be specified as an exact value or a relative one.
        Found in the <code>jquery.calendars.plus.js</code> module.
        @memberof BaseCalendar
        @param dateSpec {CDate|number|string} The date as an object or string in the given format or
                an offset - numeric days from today, or string amounts and periods, e.g. '+1m +2w'.
        @param defaultDate {CDate} The date to use if no other supplied, may be <code>null</code>.
        @param currentDate {CDate} The current date as a possible basis for relative dates,
                if <code>null</code> today is used (optional)
        @param [dateFormat] {string} The expected date format - see <a href="#formatDate"><code>formatDate</code></a>.
        @param [settings] {object} Additional options whose attributes include:
        @property [shortYearCutoff] {number} The cutoff year for determining the century.
        @property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
        @property [dayNames] {string[]} Names of the days from Sunday.
        @property [monthNamesShort] {string[]} Abbreviated names of the months.
        @property [monthNames] {string[]} Names of the months.
        @return {CDate} The decoded date. */
    determineDate: function(dateSpec, defaultDate, currentDate, dateFormat, settings) {
        if (currentDate && typeof currentDate !== 'object') {
            settings = dateFormat;
            dateFormat = currentDate;
            currentDate = null;
        }
        if (typeof dateFormat !== 'string') {
            settings = dateFormat;
            dateFormat = '';
        }
        var calendar = this;
        var offsetString = function(offset) {
            try {
                return calendar.parseDate(dateFormat, offset, settings);
            }
            catch (e) {
                // Ignore
            }
            offset = offset.toLowerCase();
            var date = (offset.match(/^c/) && currentDate ?
                currentDate.newDate() : null) || calendar.today();
            var pattern = /([+-]?[0-9]+)\s*(d|w|m|y)?/g;
            var matches = pattern.exec(offset);
            while (matches) {
                date.add(parseInt(matches[1], 10), matches[2] || 'd');
                matches = pattern.exec(offset);
            }
            return date;
        };
        defaultDate = (defaultDate ? defaultDate.newDate() : null);
        dateSpec = (dateSpec == null ? defaultDate :
            (typeof dateSpec === 'string' ? offsetString(dateSpec) : (typeof dateSpec === 'number' ?
            (isNaN(dateSpec) || dateSpec === Infinity || dateSpec === -Infinity ? defaultDate :
            calendar.today().add(dateSpec, 'd')) : calendar.newDate(dateSpec))));
        return dateSpec;
    }
});



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(432);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});