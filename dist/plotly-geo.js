/**
* plotly.js (geo) v3.0.1
* Copyright 2012-2025, Plotly, Inc.
* All rights reserved.
* Licensed under the MIT license
*/
(
 function(root, factory) {
  if (typeof module === "object" && module.exports) {
   module.exports = factory();
  } else {
   root.moduleName = factory();
  }
} (typeof self !== "undefined" ? self : this, () => {
"use strict";
var Plotly = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/version.js
  var require_version = __commonJS({
    "src/version.js"(exports) {
      "use strict";
      exports.version = "3.0.1";
    }
  });

  // node_modules/native-promise-only/lib/npo.src.js
  var require_npo_src = __commonJS({
    "node_modules/native-promise-only/lib/npo.src.js"(exports, module) {
      (function UMD(name, context, definition) {
        context[name] = context[name] || definition();
        if (typeof module != "undefined" && module.exports) {
          module.exports = context[name];
        } else if (typeof define == "function" && false) {
          define(function $AMD$() {
            return context[name];
          });
        }
      })("Promise", typeof window != "undefined" ? window : exports, function DEF() {
        "use strict";
        var builtInProp, cycle, scheduling_queue, ToString = Object.prototype.toString, timer = typeof setImmediate != "undefined" ? function timer2(fn) {
          return setImmediate(fn);
        } : setTimeout;
        try {
          Object.defineProperty({}, "x", {});
          builtInProp = function builtInProp2(obj, name, val, config) {
            return Object.defineProperty(obj, name, {
              value: val,
              writable: true,
              configurable: config !== false
            });
          };
        } catch (err) {
          builtInProp = function builtInProp2(obj, name, val) {
            obj[name] = val;
            return obj;
          };
        }
        scheduling_queue = /* @__PURE__ */ function Queue() {
          var first, last, item;
          function Item(fn, self2) {
            this.fn = fn;
            this.self = self2;
            this.next = void 0;
          }
          return {
            add: function add(fn, self2) {
              item = new Item(fn, self2);
              if (last) {
                last.next = item;
              } else {
                first = item;
              }
              last = item;
              item = void 0;
            },
            drain: function drain() {
              var f = first;
              first = last = cycle = void 0;
              while (f) {
                f.fn.call(f.self);
                f = f.next;
              }
            }
          };
        }();
        function schedule(fn, self2) {
          scheduling_queue.add(fn, self2);
          if (!cycle) {
            cycle = timer(scheduling_queue.drain);
          }
        }
        function isThenable(o) {
          var _then, o_type = typeof o;
          if (o != null && (o_type == "object" || o_type == "function")) {
            _then = o.then;
          }
          return typeof _then == "function" ? _then : false;
        }
        function notify() {
          for (var i = 0; i < this.chain.length; i++) {
            notifyIsolated(
              this,
              this.state === 1 ? this.chain[i].success : this.chain[i].failure,
              this.chain[i]
            );
          }
          this.chain.length = 0;
        }
        function notifyIsolated(self2, cb, chain) {
          var ret, _then;
          try {
            if (cb === false) {
              chain.reject(self2.msg);
            } else {
              if (cb === true) {
                ret = self2.msg;
              } else {
                ret = cb.call(void 0, self2.msg);
              }
              if (ret === chain.promise) {
                chain.reject(TypeError("Promise-chain cycle"));
              } else if (_then = isThenable(ret)) {
                _then.call(ret, chain.resolve, chain.reject);
              } else {
                chain.resolve(ret);
              }
            }
          } catch (err) {
            chain.reject(err);
          }
        }
        function resolve(msg) {
          var _then, self2 = this;
          if (self2.triggered) {
            return;
          }
          self2.triggered = true;
          if (self2.def) {
            self2 = self2.def;
          }
          try {
            if (_then = isThenable(msg)) {
              schedule(function() {
                var def_wrapper = new MakeDefWrapper(self2);
                try {
                  _then.call(
                    msg,
                    function $resolve$() {
                      resolve.apply(def_wrapper, arguments);
                    },
                    function $reject$() {
                      reject.apply(def_wrapper, arguments);
                    }
                  );
                } catch (err) {
                  reject.call(def_wrapper, err);
                }
              });
            } else {
              self2.msg = msg;
              self2.state = 1;
              if (self2.chain.length > 0) {
                schedule(notify, self2);
              }
            }
          } catch (err) {
            reject.call(new MakeDefWrapper(self2), err);
          }
        }
        function reject(msg) {
          var self2 = this;
          if (self2.triggered) {
            return;
          }
          self2.triggered = true;
          if (self2.def) {
            self2 = self2.def;
          }
          self2.msg = msg;
          self2.state = 2;
          if (self2.chain.length > 0) {
            schedule(notify, self2);
          }
        }
        function iteratePromises(Constructor, arr, resolver, rejecter) {
          for (var idx = 0; idx < arr.length; idx++) {
            (function IIFE(idx2) {
              Constructor.resolve(arr[idx2]).then(
                function $resolver$(msg) {
                  resolver(idx2, msg);
                },
                rejecter
              );
            })(idx);
          }
        }
        function MakeDefWrapper(self2) {
          this.def = self2;
          this.triggered = false;
        }
        function MakeDef(self2) {
          this.promise = self2;
          this.state = 0;
          this.triggered = false;
          this.chain = [];
          this.msg = void 0;
        }
        function Promise2(executor) {
          if (typeof executor != "function") {
            throw TypeError("Not a function");
          }
          if (this.__NPO__ !== 0) {
            throw TypeError("Not a promise");
          }
          this.__NPO__ = 1;
          var def = new MakeDef(this);
          this["then"] = function then(success, failure) {
            var o = {
              success: typeof success == "function" ? success : true,
              failure: typeof failure == "function" ? failure : false
            };
            o.promise = new this.constructor(function extractChain(resolve2, reject2) {
              if (typeof resolve2 != "function" || typeof reject2 != "function") {
                throw TypeError("Not a function");
              }
              o.resolve = resolve2;
              o.reject = reject2;
            });
            def.chain.push(o);
            if (def.state !== 0) {
              schedule(notify, def);
            }
            return o.promise;
          };
          this["catch"] = function $catch$(failure) {
            return this.then(void 0, failure);
          };
          try {
            executor.call(
              void 0,
              function publicResolve(msg) {
                resolve.call(def, msg);
              },
              function publicReject(msg) {
                reject.call(def, msg);
              }
            );
          } catch (err) {
            reject.call(def, err);
          }
        }
        var PromisePrototype = builtInProp(
          {},
          "constructor",
          Promise2,
          /*configurable=*/
          false
        );
        Promise2.prototype = PromisePrototype;
        builtInProp(
          PromisePrototype,
          "__NPO__",
          0,
          /*configurable=*/
          false
        );
        builtInProp(Promise2, "resolve", function Promise$resolve(msg) {
          var Constructor = this;
          if (msg && typeof msg == "object" && msg.__NPO__ === 1) {
            return msg;
          }
          return new Constructor(function executor(resolve2, reject2) {
            if (typeof resolve2 != "function" || typeof reject2 != "function") {
              throw TypeError("Not a function");
            }
            resolve2(msg);
          });
        });
        builtInProp(Promise2, "reject", function Promise$reject(msg) {
          return new this(function executor(resolve2, reject2) {
            if (typeof resolve2 != "function" || typeof reject2 != "function") {
              throw TypeError("Not a function");
            }
            reject2(msg);
          });
        });
        builtInProp(Promise2, "all", function Promise$all(arr) {
          var Constructor = this;
          if (ToString.call(arr) != "[object Array]") {
            return Constructor.reject(TypeError("Not an array"));
          }
          if (arr.length === 0) {
            return Constructor.resolve([]);
          }
          return new Constructor(function executor(resolve2, reject2) {
            if (typeof resolve2 != "function" || typeof reject2 != "function") {
              throw TypeError("Not a function");
            }
            var len = arr.length, msgs = Array(len), count = 0;
            iteratePromises(Constructor, arr, function resolver(idx, msg) {
              msgs[idx] = msg;
              if (++count === len) {
                resolve2(msgs);
              }
            }, reject2);
          });
        });
        builtInProp(Promise2, "race", function Promise$race(arr) {
          var Constructor = this;
          if (ToString.call(arr) != "[object Array]") {
            return Constructor.reject(TypeError("Not an array"));
          }
          return new Constructor(function executor(resolve2, reject2) {
            if (typeof resolve2 != "function" || typeof reject2 != "function") {
              throw TypeError("Not a function");
            }
            iteratePromises(Constructor, arr, function resolver(idx, msg) {
              resolve2(msg);
            }, reject2);
          });
        });
        return Promise2;
      });
    }
  });

  // node_modules/@plotly/d3/d3.js
  var require_d3 = __commonJS({
    "node_modules/@plotly/d3/d3.js"(exports, module) {
      !function() {
        var d3 = {
          version: "3.8.2"
        };
        var d3_arraySlice = [].slice, d3_array = function(list) {
          return d3_arraySlice.call(list);
        };
        var d3_document = self.document;
        function d3_documentElement(node) {
          return node && (node.ownerDocument || node.document || node).documentElement;
        }
        function d3_window(node) {
          return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
        }
        if (d3_document) {
          try {
            d3_array(d3_document.documentElement.childNodes)[0].nodeType;
          } catch (e) {
            d3_array = function(list) {
              var i = list.length, array = new Array(i);
              while (i--) array[i] = list[i];
              return array;
            };
          }
        }
        if (!Date.now) Date.now = function() {
          return +/* @__PURE__ */ new Date();
        };
        if (d3_document) {
          try {
            d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
          } catch (error) {
            var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
            d3_element_prototype.setAttribute = function(name, value) {
              d3_element_setAttribute.call(this, name, value + "");
            };
            d3_element_prototype.setAttributeNS = function(space, local, value) {
              d3_element_setAttributeNS.call(this, space, local, value + "");
            };
            d3_style_prototype.setProperty = function(name, value, priority) {
              d3_style_setProperty.call(this, name, value + "", priority);
            };
          }
        }
        d3.ascending = d3_ascending;
        function d3_ascending(a, b) {
          return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
        }
        d3.descending = function(a, b) {
          return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
        };
        d3.min = function(array, f) {
          var i = -1, n = array.length, a, b;
          if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
              a = b;
              break;
            }
            while (++i < n) if ((b = array[i]) != null && a > b) a = b;
          } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = b;
              break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
          }
          return a;
        };
        d3.max = function(array, f) {
          var i = -1, n = array.length, a, b;
          if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
              a = b;
              break;
            }
            while (++i < n) if ((b = array[i]) != null && b > a) a = b;
          } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = b;
              break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
          }
          return a;
        };
        d3.extent = function(array, f) {
          var i = -1, n = array.length, a, b, c;
          if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
              a = c = b;
              break;
            }
            while (++i < n) if ((b = array[i]) != null) {
              if (a > b) a = b;
              if (c < b) c = b;
            }
          } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = c = b;
              break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
              if (a > b) a = b;
              if (c < b) c = b;
            }
          }
          return [a, c];
        };
        function d3_number(x) {
          return x === null ? NaN : +x;
        }
        function d3_numeric(x) {
          return !isNaN(x);
        }
        d3.sum = function(array, f) {
          var s = 0, n = array.length, a, i = -1;
          if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = +array[i])) s += a;
          } else {
            while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
          }
          return s;
        };
        d3.mean = function(array, f) {
          var s = 0, n = array.length, a, i = -1, j = n;
          if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a;
            else --j;
          } else {
            while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a;
            else --j;
          }
          if (j) return s / j;
        };
        d3.quantile = function(values, p) {
          var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
          return e ? v + e * (values[h] - v) : v;
        };
        d3.median = function(array, f) {
          var numbers = [], n = array.length, a, i = -1;
          if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
          } else {
            while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
          }
          if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), 0.5);
        };
        d3.variance = function(array, f) {
          var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
          if (arguments.length === 1) {
            while (++i < n) {
              if (d3_numeric(a = d3_number(array[i]))) {
                d = a - m;
                m += d / ++j;
                s += d * (a - m);
              }
            }
          } else {
            while (++i < n) {
              if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
                d = a - m;
                m += d / ++j;
                s += d * (a - m);
              }
            }
          }
          if (j > 1) return s / (j - 1);
        };
        d3.deviation = function() {
          var v = d3.variance.apply(this, arguments);
          return v ? Math.sqrt(v) : v;
        };
        function d3_bisector(compare) {
          return {
            left: function(a, x, lo, hi) {
              if (arguments.length < 3) lo = 0;
              if (arguments.length < 4) hi = a.length;
              while (lo < hi) {
                var mid = lo + hi >>> 1;
                if (compare(a[mid], x) < 0) lo = mid + 1;
                else hi = mid;
              }
              return lo;
            },
            right: function(a, x, lo, hi) {
              if (arguments.length < 3) lo = 0;
              if (arguments.length < 4) hi = a.length;
              while (lo < hi) {
                var mid = lo + hi >>> 1;
                if (compare(a[mid], x) > 0) hi = mid;
                else lo = mid + 1;
              }
              return lo;
            }
          };
        }
        var d3_bisect = d3_bisector(d3_ascending);
        d3.bisectLeft = d3_bisect.left;
        d3.bisect = d3.bisectRight = d3_bisect.right;
        d3.bisector = function(f) {
          return d3_bisector(f.length === 1 ? function(d, x) {
            return d3_ascending(f(d), x);
          } : f);
        };
        d3.shuffle = function(array, i0, i1) {
          if ((m = arguments.length) < 3) {
            i1 = array.length;
            if (m < 2) i0 = 0;
          }
          var m = i1 - i0, t, i;
          while (m) {
            i = Math.random() * m-- | 0;
            t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
          }
          return array;
        };
        d3.permute = function(array, indexes) {
          var i = indexes.length, permutes = new Array(i);
          while (i--) permutes[i] = array[indexes[i]];
          return permutes;
        };
        d3.pairs = function(array) {
          var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
          while (i < n) pairs[i] = [p0 = p1, p1 = array[++i]];
          return pairs;
        };
        d3.transpose = function(matrix) {
          if (!(n = matrix.length)) return [];
          for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
            for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
              row[j] = matrix[j][i];
            }
          }
          return transpose;
        };
        function d3_transposeLength(d) {
          return d.length;
        }
        d3.zip = function() {
          return d3.transpose(arguments);
        };
        d3.keys = function(map) {
          var keys = [];
          for (var key in map) keys.push(key);
          return keys;
        };
        d3.values = function(map) {
          var values = [];
          for (var key in map) values.push(map[key]);
          return values;
        };
        d3.entries = function(map) {
          var entries = [];
          for (var key in map) entries.push({
            key,
            value: map[key]
          });
          return entries;
        };
        d3.merge = function(arrays) {
          var n = arrays.length, m, i = -1, j = 0, merged, array;
          while (++i < n) j += arrays[i].length;
          merged = new Array(j);
          while (--n >= 0) {
            array = arrays[n];
            m = array.length;
            while (--m >= 0) {
              merged[--j] = array[m];
            }
          }
          return merged;
        };
        var abs = Math.abs;
        d3.range = function(start, stop, step) {
          if (arguments.length < 3) {
            step = 1;
            if (arguments.length < 2) {
              stop = start;
              start = 0;
            }
          }
          if ((stop - start) / step === Infinity) throw new Error("infinite range");
          var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
          start *= k, stop *= k, step *= k;
          if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k);
          else while ((j = start + step * ++i) < stop) range.push(j / k);
          return range;
        };
        function d3_range_integerScale(x) {
          var k = 1;
          while (x * k % 1) k *= 10;
          return k;
        }
        function d3_class(ctor, properties) {
          for (var key in properties) {
            Object.defineProperty(ctor.prototype, key, {
              value: properties[key],
              enumerable: false
            });
          }
        }
        d3.map = function(object, f) {
          var map = new d3_Map();
          if (object instanceof d3_Map) {
            object.forEach(function(key2, value) {
              map.set(key2, value);
            });
          } else if (Array.isArray(object)) {
            var i = -1, n = object.length, o;
            if (arguments.length === 1) while (++i < n) map.set(i, object[i]);
            else while (++i < n) map.set(f.call(object, o = object[i], i), o);
          } else {
            for (var key in object) map.set(key, object[key]);
          }
          return map;
        };
        function d3_Map() {
          this._ = /* @__PURE__ */ Object.create(null);
        }
        var d3_map_proto = "__proto__", d3_map_zero = "\0";
        d3_class(d3_Map, {
          has: d3_map_has,
          get: function(key) {
            return this._[d3_map_escape(key)];
          },
          set: function(key, value) {
            return this._[d3_map_escape(key)] = value;
          },
          remove: d3_map_remove,
          keys: d3_map_keys,
          values: function() {
            var values = [];
            for (var key in this._) values.push(this._[key]);
            return values;
          },
          entries: function() {
            var entries = [];
            for (var key in this._) entries.push({
              key: d3_map_unescape(key),
              value: this._[key]
            });
            return entries;
          },
          size: d3_map_size,
          empty: d3_map_empty,
          forEach: function(f) {
            for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
          }
        });
        function d3_map_escape(key) {
          return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
        }
        function d3_map_unescape(key) {
          return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
        }
        function d3_map_has(key) {
          return d3_map_escape(key) in this._;
        }
        function d3_map_remove(key) {
          return (key = d3_map_escape(key)) in this._ && delete this._[key];
        }
        function d3_map_keys() {
          var keys = [];
          for (var key in this._) keys.push(d3_map_unescape(key));
          return keys;
        }
        function d3_map_size() {
          var size = 0;
          for (var key in this._) ++size;
          return size;
        }
        function d3_map_empty() {
          for (var key in this._) return false;
          return true;
        }
        d3.nest = function() {
          var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
          function map(mapType, array, depth) {
            if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
            var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
            while (++i < n) {
              if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
                values.push(object);
              } else {
                valuesByKey.set(keyValue, [object]);
              }
            }
            if (mapType) {
              object = mapType();
              setter = function(keyValue2, values2) {
                object.set(keyValue2, map(mapType, values2, depth));
              };
            } else {
              object = {};
              setter = function(keyValue2, values2) {
                object[keyValue2] = map(mapType, values2, depth);
              };
            }
            valuesByKey.forEach(setter);
            return object;
          }
          function entries(map2, depth) {
            if (depth >= keys.length) return map2;
            var array = [], sortKey = sortKeys[depth++];
            map2.forEach(function(key, keyMap) {
              array.push({
                key,
                values: entries(keyMap, depth)
              });
            });
            return sortKey ? array.sort(function(a, b) {
              return sortKey(a.key, b.key);
            }) : array;
          }
          nest.map = function(array, mapType) {
            return map(mapType, array, 0);
          };
          nest.entries = function(array) {
            return entries(map(d3.map, array, 0), 0);
          };
          nest.key = function(d) {
            keys.push(d);
            return nest;
          };
          nest.sortKeys = function(order) {
            sortKeys[keys.length - 1] = order;
            return nest;
          };
          nest.sortValues = function(order) {
            sortValues = order;
            return nest;
          };
          nest.rollup = function(f) {
            rollup = f;
            return nest;
          };
          return nest;
        };
        d3.set = function(array) {
          var set = new d3_Set();
          if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
          return set;
        };
        function d3_Set() {
          this._ = /* @__PURE__ */ Object.create(null);
        }
        d3_class(d3_Set, {
          has: d3_map_has,
          add: function(key) {
            this._[d3_map_escape(key += "")] = true;
            return key;
          },
          remove: d3_map_remove,
          values: d3_map_keys,
          size: d3_map_size,
          empty: d3_map_empty,
          forEach: function(f) {
            for (var key in this._) f.call(this, d3_map_unescape(key));
          }
        });
        d3.behavior = {};
        function d3_identity(d) {
          return d;
        }
        d3.rebind = function(target, source) {
          var i = 1, n = arguments.length, method;
          while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
          return target;
        };
        function d3_rebind(target, source, method) {
          return function() {
            var value = method.apply(source, arguments);
            return value === source ? target : value;
          };
        }
        function d3_vendorSymbol(object, name) {
          if (name in object) return name;
          name = name.charAt(0).toUpperCase() + name.slice(1);
          for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
            var prefixName = d3_vendorPrefixes[i] + name;
            if (prefixName in object) return prefixName;
          }
        }
        var d3_vendorPrefixes = ["webkit", "ms", "moz", "Moz", "o", "O"];
        function d3_noop() {
        }
        d3.dispatch = function() {
          var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
          while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
          return dispatch;
        };
        function d3_dispatch() {
        }
        d3_dispatch.prototype.on = function(type, listener) {
          var i = type.indexOf("."), name = "";
          if (i >= 0) {
            name = type.slice(i + 1);
            type = type.slice(0, i);
          }
          if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
          if (arguments.length === 2) {
            if (listener == null) for (type in this) {
              if (this.hasOwnProperty(type)) this[type].on(name, null);
            }
            return this;
          }
        };
        function d3_dispatch_event(dispatch) {
          var listeners = [], listenerByName = new d3_Map();
          function event() {
            var z = listeners, i = -1, n = z.length, l;
            while (++i < n) if (l = z[i].on) l.apply(this, arguments);
            return dispatch;
          }
          event.on = function(name, listener) {
            var l = listenerByName.get(name), i;
            if (arguments.length < 2) return l && l.on;
            if (l) {
              l.on = null;
              listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
              listenerByName.remove(name);
            }
            if (listener) listeners.push(listenerByName.set(name, {
              on: listener
            }));
            return dispatch;
          };
          return event;
        }
        d3.event = null;
        function d3_eventPreventDefault() {
          d3.event.preventDefault();
        }
        function d3_eventSource() {
          var e = d3.event, s;
          while (s = e.sourceEvent) e = s;
          return e;
        }
        function d3_eventDispatch(target) {
          var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
          while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
          dispatch.of = function(thiz, argumentz) {
            return function(e1) {
              try {
                var e0 = e1.sourceEvent = d3.event;
                e1.target = target;
                d3.event = e1;
                dispatch[e1.type].apply(thiz, argumentz);
              } finally {
                d3.event = e0;
              }
            };
          };
          return dispatch;
        }
        d3.requote = function(s) {
          return s.replace(d3_requote_re, "\\$&");
        };
        var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
        var d3_subclass = {}.__proto__ ? function(object, prototype) {
          object.__proto__ = prototype;
        } : function(object, prototype) {
          for (var property in prototype) object[property] = prototype[property];
        };
        function d3_selection(groups) {
          d3_subclass(groups, d3_selectionPrototype);
          return groups;
        }
        var d3_select = function(s, n) {
          return n.querySelector(s);
        }, d3_selectAll = function(s, n) {
          return n.querySelectorAll(s);
        }, d3_selectMatches = function(n, s) {
          var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
          d3_selectMatches = function(n2, s2) {
            return d3_selectMatcher.call(n2, s2);
          };
          return d3_selectMatches(n, s);
        };
        if (typeof Sizzle === "function") {
          d3_select = function(s, n) {
            return Sizzle(s, n)[0] || null;
          };
          d3_selectAll = Sizzle;
          d3_selectMatches = Sizzle.matchesSelector;
        }
        d3.selection = function() {
          return d3.select(d3_document.documentElement);
        };
        var d3_selectionPrototype = d3.selection.prototype = [];
        d3_selectionPrototype.select = function(selector) {
          var subgroups = [], subgroup, subnode, group, node;
          selector = d3_selection_selector(selector);
          for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = -1, n = group.length; ++i < n; ) {
              if (node = group[i]) {
                subgroup.push(subnode = selector.call(node, node.__data__, i, j));
                if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
              } else {
                subgroup.push(null);
              }
            }
          }
          return d3_selection(subgroups);
        };
        function d3_selection_selector(selector) {
          return typeof selector === "function" ? selector : function() {
            return d3_select(selector, this);
          };
        }
        d3_selectionPrototype.selectAll = function(selector) {
          var subgroups = [], subgroup, node;
          selector = d3_selection_selectorAll(selector);
          for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
              if (node = group[i]) {
                subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
                subgroup.parentNode = node;
              }
            }
          }
          return d3_selection(subgroups);
        };
        function d3_selection_selectorAll(selector) {
          return typeof selector === "function" ? selector : function() {
            return d3_selectAll(selector, this);
          };
        }
        var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
        var d3_nsPrefix = {
          svg: "http://www.w3.org/2000/svg",
          xhtml: d3_nsXhtml,
          xlink: "http://www.w3.org/1999/xlink",
          xml: "http://www.w3.org/XML/1998/namespace",
          xmlns: "http://www.w3.org/2000/xmlns/"
        };
        d3.ns = {
          prefix: d3_nsPrefix,
          qualify: function(name) {
            var i = name.indexOf(":"), prefix = name;
            if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
            return d3_nsPrefix.hasOwnProperty(prefix) ? {
              space: d3_nsPrefix[prefix],
              local: name
            } : name;
          }
        };
        d3_selectionPrototype.attr = function(name, value) {
          if (arguments.length < 2) {
            if (typeof name === "string") {
              var node = this.node();
              name = d3.ns.qualify(name);
              return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
            }
            for (value in name) this.each(d3_selection_attr(value, name[value]));
            return this;
          }
          return this.each(d3_selection_attr(name, value));
        };
        function d3_selection_attr(name, value) {
          name = d3.ns.qualify(name);
          function attrNull() {
            this.removeAttribute(name);
          }
          function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
          }
          function attrConstant() {
            this.setAttribute(name, value);
          }
          function attrConstantNS() {
            this.setAttributeNS(name.space, name.local, value);
          }
          function attrFunction() {
            var x = value.apply(this, arguments);
            if (x == null) this.removeAttribute(name);
            else this.setAttribute(name, x);
          }
          function attrFunctionNS() {
            var x = value.apply(this, arguments);
            if (x == null) this.removeAttributeNS(name.space, name.local);
            else this.setAttributeNS(name.space, name.local, x);
          }
          return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
        }
        function d3_collapse(s) {
          return s.trim().replace(/\s+/g, " ");
        }
        d3_selectionPrototype.classed = function(name, value) {
          if (arguments.length < 2) {
            if (typeof name === "string") {
              var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
              if (value = node.classList) {
                while (++i < n) if (!value.contains(name[i])) return false;
              } else {
                value = node.getAttribute("class");
                while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
              }
              return true;
            }
            for (value in name) this.each(d3_selection_classed(value, name[value]));
            return this;
          }
          return this.each(d3_selection_classed(name, value));
        };
        function d3_selection_classedRe(name) {
          return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
        }
        function d3_selection_classes(name) {
          return (name + "").trim().split(/^|\s+/);
        }
        function d3_selection_classed(name, value) {
          name = d3_selection_classes(name).map(d3_selection_classedName);
          var n = name.length;
          function classedConstant() {
            var i = -1;
            while (++i < n) name[i](this, value);
          }
          function classedFunction() {
            var i = -1, x = value.apply(this, arguments);
            while (++i < n) name[i](this, x);
          }
          return typeof value === "function" ? classedFunction : classedConstant;
        }
        function d3_selection_classedName(name) {
          var re = d3_selection_classedRe(name);
          return function(node, value) {
            if (c = node.classList) return value ? c.add(name) : c.remove(name);
            var c = node.getAttribute("class") || "";
            if (value) {
              re.lastIndex = 0;
              if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
            } else {
              node.setAttribute("class", d3_collapse(c.replace(re, " ")));
            }
          };
        }
        d3_selectionPrototype.style = function(name, value, priority) {
          var n = arguments.length;
          if (n < 3) {
            if (typeof name !== "string") {
              if (n < 2) value = "";
              for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
              return this;
            }
            if (n < 2) {
              var node = this.node();
              return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
            }
            priority = "";
          }
          return this.each(d3_selection_style(name, value, priority));
        };
        function d3_selection_style(name, value, priority) {
          function styleNull() {
            this.style.removeProperty(name);
          }
          function styleConstant() {
            this.style.setProperty(name, value, priority);
          }
          function styleFunction() {
            var x = value.apply(this, arguments);
            if (x == null) this.style.removeProperty(name);
            else this.style.setProperty(name, x, priority);
          }
          return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
        }
        d3_selectionPrototype.property = function(name, value) {
          if (arguments.length < 2) {
            if (typeof name === "string") return this.node()[name];
            for (value in name) this.each(d3_selection_property(value, name[value]));
            return this;
          }
          return this.each(d3_selection_property(name, value));
        };
        function d3_selection_property(name, value) {
          function propertyNull() {
            delete this[name];
          }
          function propertyConstant() {
            this[name] = value;
          }
          function propertyFunction() {
            var x = value.apply(this, arguments);
            if (x == null) delete this[name];
            else this[name] = x;
          }
          return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
        }
        d3_selectionPrototype.text = function(value) {
          return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
          } : value == null ? function() {
            this.textContent = "";
          } : function() {
            this.textContent = value;
          }) : this.node().textContent;
        };
        d3_selectionPrototype.html = function(value) {
          return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
          } : value == null ? function() {
            this.innerHTML = "";
          } : function() {
            this.innerHTML = value;
          }) : this.node().innerHTML;
        };
        d3_selectionPrototype.append = function(name) {
          name = d3_selection_creator(name);
          return this.select(function() {
            return this.appendChild(name.apply(this, arguments));
          });
        };
        function d3_selection_creator(name) {
          function create() {
            var document2 = this.ownerDocument, namespace = this.namespaceURI;
            return namespace === d3_nsXhtml && document2.documentElement.namespaceURI === d3_nsXhtml ? document2.createElement(name) : document2.createElementNS(namespace, name);
          }
          function createNS() {
            return this.ownerDocument.createElementNS(name.space, name.local);
          }
          return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
        }
        d3_selectionPrototype.insert = function(name, before) {
          name = d3_selection_creator(name);
          before = d3_selection_selector(before);
          return this.select(function() {
            return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
          });
        };
        d3_selectionPrototype.remove = function() {
          return this.each(d3_selectionRemove);
        };
        function d3_selectionRemove() {
          var parent = this.parentNode;
          if (parent) parent.removeChild(this);
        }
        d3_selectionPrototype.data = function(value, key) {
          var i = -1, n = this.length, group, node;
          if (!arguments.length) {
            value = new Array(n = (group = this[0]).length);
            while (++i < n) {
              if (node = group[i]) {
                value[i] = node.__data__;
              }
            }
            return value;
          }
          function bind(group2, groupData) {
            var i2, n2 = group2.length, m = groupData.length, n0 = Math.min(n2, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n2), node2, nodeData;
            if (key) {
              var nodeByKeyValue = new d3_Map(), keyValues = new Array(n2), keyValue;
              for (i2 = -1; ++i2 < n2; ) {
                if (node2 = group2[i2]) {
                  if (nodeByKeyValue.has(keyValue = key.call(node2, node2.__data__, i2))) {
                    exitNodes[i2] = node2;
                  } else {
                    nodeByKeyValue.set(keyValue, node2);
                  }
                  keyValues[i2] = keyValue;
                }
              }
              for (i2 = -1; ++i2 < m; ) {
                if (!(node2 = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i2], i2)))) {
                  enterNodes[i2] = d3_selection_dataNode(nodeData);
                } else if (node2 !== true) {
                  updateNodes[i2] = node2;
                  node2.__data__ = nodeData;
                }
                nodeByKeyValue.set(keyValue, true);
              }
              for (i2 = -1; ++i2 < n2; ) {
                if (i2 in keyValues && nodeByKeyValue.get(keyValues[i2]) !== true) {
                  exitNodes[i2] = group2[i2];
                }
              }
            } else {
              for (i2 = -1; ++i2 < n0; ) {
                node2 = group2[i2];
                nodeData = groupData[i2];
                if (node2) {
                  node2.__data__ = nodeData;
                  updateNodes[i2] = node2;
                } else {
                  enterNodes[i2] = d3_selection_dataNode(nodeData);
                }
              }
              for (; i2 < m; ++i2) {
                enterNodes[i2] = d3_selection_dataNode(groupData[i2]);
              }
              for (; i2 < n2; ++i2) {
                exitNodes[i2] = group2[i2];
              }
            }
            enterNodes.update = updateNodes;
            enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group2.parentNode;
            enter.push(enterNodes);
            update.push(updateNodes);
            exit.push(exitNodes);
          }
          var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
          if (typeof value === "function") {
            while (++i < n) {
              bind(group = this[i], value.call(group, group.parentNode.__data__, i));
            }
          } else {
            while (++i < n) {
              bind(group = this[i], value);
            }
          }
          update.enter = function() {
            return enter;
          };
          update.exit = function() {
            return exit;
          };
          return update;
        };
        function d3_selection_dataNode(data) {
          return {
            __data__: data
          };
        }
        d3_selectionPrototype.datum = function(value) {
          return arguments.length ? this.property("__data__", value) : this.property("__data__");
        };
        d3_selectionPrototype.filter = function(filter) {
          var subgroups = [], subgroup, group, node;
          if (typeof filter !== "function") filter = d3_selection_filter(filter);
          for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = 0, n = group.length; i < n; i++) {
              if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                subgroup.push(node);
              }
            }
          }
          return d3_selection(subgroups);
        };
        function d3_selection_filter(selector) {
          return function() {
            return d3_selectMatches(this, selector);
          };
        }
        d3_selectionPrototype.order = function() {
          for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
              if (node = group[i]) {
                if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
                next = node;
              }
            }
          }
          return this;
        };
        d3_selectionPrototype.sort = function(comparator) {
          comparator = d3_selection_sortComparator.apply(this, arguments);
          for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
          return this.order();
        };
        function d3_selection_sortComparator(comparator) {
          if (!arguments.length) comparator = d3_ascending;
          return function(a, b) {
            return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
          };
        }
        d3_selectionPrototype.each = function(callback) {
          return d3_selection_each(this, function(node, i, j) {
            callback.call(node, node.__data__, i, j);
          });
        };
        function d3_selection_each(groups, callback) {
          for (var j = 0, m = groups.length; j < m; j++) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
              if (node = group[i]) callback(node, i, j);
            }
          }
          return groups;
        }
        d3_selectionPrototype.call = function(callback) {
          var args = d3_array(arguments);
          callback.apply(args[0] = this, args);
          return this;
        };
        d3_selectionPrototype.empty = function() {
          return !this.node();
        };
        d3_selectionPrototype.node = function() {
          for (var j = 0, m = this.length; j < m; j++) {
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
              var node = group[i];
              if (node) return node;
            }
          }
          return null;
        };
        d3_selectionPrototype.size = function() {
          var n = 0;
          d3_selection_each(this, function() {
            ++n;
          });
          return n;
        };
        function d3_selection_enter(selection) {
          d3_subclass(selection, d3_selection_enterPrototype);
          return selection;
        }
        var d3_selection_enterPrototype = [];
        d3.selection.enter = d3_selection_enter;
        d3.selection.enter.prototype = d3_selection_enterPrototype;
        d3_selection_enterPrototype.append = d3_selectionPrototype.append;
        d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
        d3_selection_enterPrototype.node = d3_selectionPrototype.node;
        d3_selection_enterPrototype.call = d3_selectionPrototype.call;
        d3_selection_enterPrototype.size = d3_selectionPrototype.size;
        d3_selection_enterPrototype.select = function(selector) {
          var subgroups = [], subgroup, subnode, upgroup, group, node;
          for (var j = -1, m = this.length; ++j < m; ) {
            upgroup = (group = this[j]).update;
            subgroups.push(subgroup = []);
            subgroup.parentNode = group.parentNode;
            for (var i = -1, n = group.length; ++i < n; ) {
              if (node = group[i]) {
                subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
                subnode.__data__ = node.__data__;
              } else {
                subgroup.push(null);
              }
            }
          }
          return d3_selection(subgroups);
        };
        d3_selection_enterPrototype.insert = function(name, before) {
          if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
          return d3_selectionPrototype.insert.call(this, name, before);
        };
        function d3_selection_enterInsertBefore(enter) {
          var i0, j0;
          return function(d, i, j) {
            var group = enter[j].update, n = group.length, node;
            if (j != j0) j0 = j, i0 = 0;
            if (i >= i0) i0 = i + 1;
            while (!(node = group[i0]) && ++i0 < n) ;
            return node;
          };
        }
        d3.select = function(node) {
          var group;
          if (typeof node === "string") {
            group = [d3_select(node, d3_document)];
            group.parentNode = d3_document.documentElement;
          } else {
            group = [node];
            group.parentNode = d3_documentElement(node);
          }
          return d3_selection([group]);
        };
        d3.selectAll = function(nodes) {
          var group;
          if (typeof nodes === "string") {
            group = d3_array(d3_selectAll(nodes, d3_document));
            group.parentNode = d3_document.documentElement;
          } else {
            group = d3_array(nodes);
            group.parentNode = null;
          }
          return d3_selection([group]);
        };
        d3_selectionPrototype.on = function(type, listener, capture) {
          var n = arguments.length;
          if (n < 3) {
            if (typeof type !== "string") {
              if (n < 2) listener = false;
              for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
              return this;
            }
            if (n < 2) return (n = this.node()["__on" + type]) && n._;
            capture = false;
          }
          return this.each(d3_selection_on(type, listener, capture));
        };
        function d3_selection_on(type, listener, capture) {
          var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
          if (i > 0) type = type.slice(0, i);
          var filter = d3_selection_onFilters.get(type);
          if (filter) type = filter, wrap = d3_selection_onFilter;
          function onRemove() {
            var l = this[name];
            if (l) {
              this.removeEventListener(type, l, l.$);
              delete this[name];
            }
          }
          function onAdd() {
            var l = wrap(listener, d3_array(arguments));
            onRemove.call(this);
            this.addEventListener(type, this[name] = l, l.$ = capture);
            l._ = listener;
          }
          function removeAll() {
            var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
            for (var name2 in this) {
              if (match = name2.match(re)) {
                var l = this[name2];
                this.removeEventListener(match[1], l, l.$);
                delete this[name2];
              }
            }
          }
          return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
        }
        var d3_selection_onFilters = d3.map({
          mouseenter: "mouseover",
          mouseleave: "mouseout"
        });
        if (d3_document) {
          d3_selection_onFilters.forEach(function(k) {
            if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
          });
        }
        function d3_selection_onListener(listener, argumentz) {
          return function(e) {
            var o = d3.event;
            d3.event = e;
            argumentz[0] = this.__data__;
            try {
              listener.apply(this, argumentz);
            } finally {
              d3.event = o;
            }
          };
        }
        function d3_selection_onFilter(listener, argumentz) {
          var l = d3_selection_onListener(listener, argumentz);
          return function(e) {
            var target = this, related = e.relatedTarget;
            if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
              l.call(target, e);
            }
          };
        }
        var d3_event_dragSelect, d3_event_dragId = 0;
        function d3_event_dragSuppress(node) {
          var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
          if (d3_event_dragSelect == null) {
            d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
          }
          if (d3_event_dragSelect) {
            var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
            style[d3_event_dragSelect] = "none";
          }
          return function(suppressClick) {
            w.on(name, null);
            if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
            if (suppressClick) {
              var off = function() {
                w.on(click, null);
              };
              w.on(click, function() {
                d3_eventPreventDefault();
                off();
              }, true);
              setTimeout(off, 0);
            }
          };
        }
        d3.mouse = function(container) {
          return d3_mousePoint(container, d3_eventSource());
        };
        var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
        function d3_mousePoint(container, e) {
          if (e.changedTouches) e = e.changedTouches[0];
          var svg = container.ownerSVGElement || container;
          if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            if (d3_mouse_bug44083 < 0) {
              var window2 = d3_window(container);
              if (window2.scrollX || window2.scrollY) {
                svg = d3.select("body").append("svg").style({
                  position: "absolute",
                  top: 0,
                  left: 0,
                  margin: 0,
                  padding: 0,
                  border: "none"
                }, "important");
                var ctm = svg[0][0].getScreenCTM();
                d3_mouse_bug44083 = !(ctm.f || ctm.e);
                svg.remove();
              }
            }
            if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY;
            else point.x = e.clientX, point.y = e.clientY;
            point = point.matrixTransform(container.getScreenCTM().inverse());
            return [point.x, point.y];
          }
          var rect = container.getBoundingClientRect();
          return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];
        }
        d3.touch = function(container, touches, identifier) {
          if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
          if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
            if ((touch = touches[i]).identifier === identifier) {
              return d3_mousePoint(container, touch);
            }
          }
        };
        d3.behavior.drag = function() {
          var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
          function drag() {
            this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
          }
          function dragstart(id, position, subject, move, end) {
            return function() {
              var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
              if (origin) {
                dragOffset = origin.apply(that, arguments);
                dragOffset = [dragOffset.x - position0[0], dragOffset.y - position0[1]];
              } else {
                dragOffset = [0, 0];
              }
              dispatch({
                type: "dragstart"
              });
              function moved() {
                var position1 = position(parent, dragId), dx, dy;
                if (!position1) return;
                dx = position1[0] - position0[0];
                dy = position1[1] - position0[1];
                dragged |= dx | dy;
                position0 = position1;
                dispatch({
                  type: "drag",
                  x: position1[0] + dragOffset[0],
                  y: position1[1] + dragOffset[1],
                  dx,
                  dy
                });
              }
              function ended() {
                if (!position(parent, dragId)) return;
                dragSubject.on(move + dragName, null).on(end + dragName, null);
                dragRestore(dragged);
                dispatch({
                  type: "dragend"
                });
              }
            };
          }
          drag.origin = function(x) {
            if (!arguments.length) return origin;
            origin = x;
            return drag;
          };
          return d3.rebind(drag, event, "on");
        };
        function d3_behavior_dragTouchId() {
          return d3.event.changedTouches[0].identifier;
        }
        d3.touches = function(container, touches) {
          if (arguments.length < 2) touches = d3_eventSource().touches;
          return touches ? d3_array(touches).map(function(touch) {
            var point = d3_mousePoint(container, touch);
            point.identifier = touch.identifier;
            return point;
          }) : [];
        };
        var \u03B5 = 1e-6, \u03B52 = \u03B5 * \u03B5, \u03C0 = Math.PI, \u03C4 = 2 * \u03C0, \u03C4\u03B5 = \u03C4 - \u03B5, half\u03C0 = \u03C0 / 2, d3_radians = \u03C0 / 180, d3_degrees = 180 / \u03C0;
        function d3_sgn(x) {
          return x > 0 ? 1 : x < 0 ? -1 : 0;
        }
        function d3_cross2d(a, b, c) {
          return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
        }
        function d3_acos(x) {
          return x > 1 ? 0 : x < -1 ? \u03C0 : Math.acos(x);
        }
        function d3_asin(x) {
          return x > 1 ? half\u03C0 : x < -1 ? -half\u03C0 : Math.asin(x);
        }
        function d3_sinh(x) {
          return ((x = Math.exp(x)) - 1 / x) / 2;
        }
        function d3_cosh(x) {
          return ((x = Math.exp(x)) + 1 / x) / 2;
        }
        function d3_tanh(x) {
          return ((x = Math.exp(2 * x)) - 1) / (x + 1);
        }
        function d3_haversin(x) {
          return (x = Math.sin(x / 2)) * x;
        }
        var \u03C1 = Math.SQRT2, \u03C12 = 2, \u03C14 = 4;
        d3.interpolateZoom = function(p0, p1) {
          var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
          if (d2 < \u03B52) {
            S = Math.log(w1 / w0) / \u03C1;
            i = function(t) {
              return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(\u03C1 * t * S)];
            };
          } else {
            var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + \u03C14 * d2) / (2 * w0 * \u03C12 * d1), b1 = (w1 * w1 - w0 * w0 - \u03C14 * d2) / (2 * w1 * \u03C12 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
            S = (r1 - r0) / \u03C1;
            i = function(t) {
              var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (\u03C12 * d1) * (coshr0 * d3_tanh(\u03C1 * s + r0) - d3_sinh(r0));
              return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(\u03C1 * s + r0)];
            };
          }
          i.duration = S * 1e3;
          return i;
        };
        d3.behavior.zoom = function() {
          var view = {
            x: 0,
            y: 0,
            k: 1
          }, translate0, center0, center, size = [960, 500], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
          if (!d3_behavior_zoomWheel) {
            d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
              return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
            }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
              return d3.event.wheelDelta;
            }, "mousewheel") : (d3_behavior_zoomDelta = function() {
              return -d3.event.detail;
            }, "MozMousePixelScroll");
          }
          function zoom(g) {
            g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
          }
          zoom.event = function(g) {
            g.each(function() {
              var dispatch = event.of(this, arguments), view1 = view;
              if (d3_transitionInheritId) {
                d3.select(this).transition().each("start.zoom", function() {
                  view = this.__chart__ || {
                    x: 0,
                    y: 0,
                    k: 1
                  };
                  zoomstarted(dispatch);
                }).tween("zoom:zoom", function() {
                  var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([(cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k], [(cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k]);
                  return function(t) {
                    var l = i(t), k = dx / l[2];
                    this.__chart__ = view = {
                      x: cx - l[0] * k,
                      y: cy - l[1] * k,
                      k
                    };
                    zoomed(dispatch);
                  };
                }).each("interrupt.zoom", function() {
                  zoomended(dispatch);
                }).each("end.zoom", function() {
                  zoomended(dispatch);
                });
              } else {
                this.__chart__ = view;
                zoomstarted(dispatch);
                zoomed(dispatch);
                zoomended(dispatch);
              }
            });
          };
          zoom.translate = function(_) {
            if (!arguments.length) return [view.x, view.y];
            view = {
              x: +_[0],
              y: +_[1],
              k: view.k
            };
            rescale();
            return zoom;
          };
          zoom.scale = function(_) {
            if (!arguments.length) return view.k;
            view = {
              x: view.x,
              y: view.y,
              k: null
            };
            scaleTo(+_);
            rescale();
            return zoom;
          };
          zoom.scaleExtent = function(_) {
            if (!arguments.length) return scaleExtent;
            scaleExtent = _ == null ? d3_behavior_zoomInfinity : [+_[0], +_[1]];
            return zoom;
          };
          zoom.center = function(_) {
            if (!arguments.length) return center;
            center = _ && [+_[0], +_[1]];
            return zoom;
          };
          zoom.size = function(_) {
            if (!arguments.length) return size;
            size = _ && [+_[0], +_[1]];
            return zoom;
          };
          zoom.duration = function(_) {
            if (!arguments.length) return duration;
            duration = +_;
            return zoom;
          };
          zoom.x = function(z) {
            if (!arguments.length) return x1;
            x1 = z;
            x0 = z.copy();
            view = {
              x: 0,
              y: 0,
              k: 1
            };
            return zoom;
          };
          zoom.y = function(z) {
            if (!arguments.length) return y1;
            y1 = z;
            y0 = z.copy();
            view = {
              x: 0,
              y: 0,
              k: 1
            };
            return zoom;
          };
          function location(p) {
            return [(p[0] - view.x) / view.k, (p[1] - view.y) / view.k];
          }
          function point(l) {
            return [l[0] * view.k + view.x, l[1] * view.k + view.y];
          }
          function scaleTo(s) {
            view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
          }
          function translateTo(p, l) {
            l = point(l);
            view.x += p[0] - l[0];
            view.y += p[1] - l[1];
          }
          function zoomTo(that, p, l, k) {
            that.__chart__ = {
              x: view.x,
              y: view.y,
              k: view.k
            };
            scaleTo(Math.pow(2, k));
            translateTo(center0 = p, l);
            that = d3.select(that);
            if (duration > 0) that = that.transition().duration(duration);
            that.call(zoom.event);
          }
          function rescale() {
            if (x1) x1.domain(x0.range().map(function(x) {
              return (x - view.x) / view.k;
            }).map(x0.invert));
            if (y1) y1.domain(y0.range().map(function(y) {
              return (y - view.y) / view.k;
            }).map(y0.invert));
          }
          function zoomstarted(dispatch) {
            if (!zooming++) dispatch({
              type: "zoomstart"
            });
          }
          function zoomed(dispatch) {
            rescale();
            dispatch({
              type: "zoom",
              scale: view.k,
              translate: [view.x, view.y]
            });
          }
          function zoomended(dispatch) {
            if (!--zooming) dispatch({
              type: "zoomend"
            }), center0 = null;
          }
          function mousedowned() {
            var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
            d3_selection_interrupt.call(that);
            zoomstarted(dispatch);
            function moved() {
              dragged = 1;
              translateTo(d3.mouse(that), location0);
              zoomed(dispatch);
            }
            function ended() {
              subject.on(mousemove, null).on(mouseup, null);
              dragRestore(dragged);
              zoomended(dispatch);
            }
          }
          function touchstarted() {
            var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
            started();
            zoomstarted(dispatch);
            subject.on(mousedown, null).on(touchstart, started);
            function relocate() {
              var touches = d3.touches(that);
              scale0 = view.k;
              touches.forEach(function(t) {
                if (t.identifier in locations0) locations0[t.identifier] = location(t);
              });
              return touches;
            }
            function started() {
              var target = d3.event.target;
              d3.select(target).on(touchmove, moved).on(touchend, ended);
              targets.push(target);
              var changed = d3.event.changedTouches;
              for (var i = 0, n = changed.length; i < n; ++i) {
                locations0[changed[i].identifier] = null;
              }
              var touches = relocate(), now = Date.now();
              if (touches.length === 1) {
                if (now - touchtime < 500) {
                  var p = touches[0];
                  zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                  d3_eventPreventDefault();
                }
                touchtime = now;
              } else if (touches.length > 1) {
                var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
                distance0 = dx * dx + dy * dy;
              }
            }
            function moved() {
              var touches = d3.touches(that), p0, l0, p1, l1;
              d3_selection_interrupt.call(that);
              for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
                p1 = touches[i];
                if (l1 = locations0[p1.identifier]) {
                  if (l0) break;
                  p0 = p1, l0 = l1;
                }
              }
              if (l1) {
                var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
                p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
                l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
                scaleTo(scale1 * scale0);
              }
              touchtime = null;
              translateTo(p0, l0);
              zoomed(dispatch);
            }
            function ended() {
              if (d3.event.touches.length) {
                var changed = d3.event.changedTouches;
                for (var i = 0, n = changed.length; i < n; ++i) {
                  delete locations0[changed[i].identifier];
                }
                for (var identifier in locations0) {
                  return void relocate();
                }
              }
              d3.selectAll(targets).on(zoomName, null);
              subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
              dragRestore();
              zoomended(dispatch);
            }
          }
          function mousewheeled() {
            var dispatch = event.of(this, arguments);
            if (mousewheelTimer) clearTimeout(mousewheelTimer);
            else d3_selection_interrupt.call(this), translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
            mousewheelTimer = setTimeout(function() {
              mousewheelTimer = null;
              zoomended(dispatch);
            }, 50);
            d3_eventPreventDefault();
            scaleTo(Math.pow(2, d3_behavior_zoomDelta() * 2e-3) * view.k);
            translateTo(center0, translate0);
            zoomed(dispatch);
          }
          function dblclicked() {
            var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
            zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
          }
          return d3.rebind(zoom, event, "on");
        };
        var d3_behavior_zoomInfinity = [0, Infinity], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
        d3.color = d3_color;
        function d3_color() {
        }
        d3_color.prototype.toString = function() {
          return this.rgb() + "";
        };
        d3.hsl = d3_hsl;
        function d3_hsl(h, s, l) {
          return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
        }
        var d3_hslPrototype = d3_hsl.prototype = new d3_color();
        d3_hslPrototype.brighter = function(k) {
          k = Math.pow(0.7, arguments.length ? k : 1);
          return new d3_hsl(this.h, this.s, this.l / k);
        };
        d3_hslPrototype.darker = function(k) {
          k = Math.pow(0.7, arguments.length ? k : 1);
          return new d3_hsl(this.h, this.s, k * this.l);
        };
        d3_hslPrototype.rgb = function() {
          return d3_hsl_rgb(this.h, this.s, this.l);
        };
        function d3_hsl_rgb(h, s, l) {
          var m1, m2;
          h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
          s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
          l = l < 0 ? 0 : l > 1 ? 1 : l;
          m2 = l <= 0.5 ? l * (1 + s) : l + s - l * s;
          m1 = 2 * l - m2;
          function v(h2) {
            if (h2 > 360) h2 -= 360;
            else if (h2 < 0) h2 += 360;
            if (h2 < 60) return m1 + (m2 - m1) * h2 / 60;
            if (h2 < 180) return m2;
            if (h2 < 240) return m1 + (m2 - m1) * (240 - h2) / 60;
            return m1;
          }
          function vv(h2) {
            return Math.round(v(h2) * 255);
          }
          return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
        }
        d3.hcl = d3_hcl;
        function d3_hcl(h, c, l) {
          return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
        }
        var d3_hclPrototype = d3_hcl.prototype = new d3_color();
        d3_hclPrototype.brighter = function(k) {
          return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
        };
        d3_hclPrototype.darker = function(k) {
          return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
        };
        d3_hclPrototype.rgb = function() {
          return d3_hcl_lab(this.h, this.c, this.l).rgb();
        };
        function d3_hcl_lab(h, c, l) {
          if (isNaN(h)) h = 0;
          if (isNaN(c)) c = 0;
          return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
        }
        d3.lab = d3_lab;
        function d3_lab(l, a, b) {
          return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
        }
        var d3_lab_K = 18;
        var d3_lab_X = 0.95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
        var d3_labPrototype = d3_lab.prototype = new d3_color();
        d3_labPrototype.brighter = function(k) {
          return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
        };
        d3_labPrototype.darker = function(k) {
          return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
        };
        d3_labPrototype.rgb = function() {
          return d3_lab_rgb(this.l, this.a, this.b);
        };
        function d3_lab_rgb(l, a, b) {
          var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
          x = d3_lab_xyz(x) * d3_lab_X;
          y = d3_lab_xyz(y) * d3_lab_Y;
          z = d3_lab_xyz(z) * d3_lab_Z;
          return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), d3_xyz_rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), d3_xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z));
        }
        function d3_lab_hcl(l, a, b) {
          return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
        }
        function d3_lab_xyz(x) {
          return x > 0.206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
        }
        function d3_xyz_lab(x) {
          return x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
        }
        function d3_xyz_rgb(r) {
          return Math.round(255 * (r <= 304e-5 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055));
        }
        d3.rgb = d3_rgb;
        function d3_rgb(r, g, b) {
          return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
        }
        function d3_rgbNumber(value) {
          return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
        }
        function d3_rgbString(value) {
          return d3_rgbNumber(value) + "";
        }
        var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
        d3_rgbPrototype.brighter = function(k) {
          k = Math.pow(0.7, arguments.length ? k : 1);
          var r = this.r, g = this.g, b = this.b, i = 30;
          if (!r && !g && !b) return new d3_rgb(i, i, i);
          if (r && r < i) r = i;
          if (g && g < i) g = i;
          if (b && b < i) b = i;
          return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
        };
        d3_rgbPrototype.darker = function(k) {
          k = Math.pow(0.7, arguments.length ? k : 1);
          return new d3_rgb(k * this.r, k * this.g, k * this.b);
        };
        d3_rgbPrototype.hsl = function() {
          return d3_rgb_hsl(this.r, this.g, this.b);
        };
        d3_rgbPrototype.toString = function() {
          return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
        };
        function d3_rgb_hex(v) {
          return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
        }
        function d3_rgb_parse(format, rgb, hsl) {
          var r = 0, g = 0, b = 0, m1, m2, color;
          m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
          if (m1) {
            m2 = m1[2].split(",");
            switch (m1[1]) {
              case "hsl": {
                return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
              }
              case "rgb": {
                return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
              }
            }
          }
          if (color = d3_rgb_names.get(format)) {
            return rgb(color.r, color.g, color.b);
          }
          if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
            if (format.length === 4) {
              r = (color & 3840) >> 4;
              r = r >> 4 | r;
              g = color & 240;
              g = g >> 4 | g;
              b = color & 15;
              b = b << 4 | b;
            } else if (format.length === 7) {
              r = (color & 16711680) >> 16;
              g = (color & 65280) >> 8;
              b = color & 255;
            }
          }
          return rgb(r, g, b);
        }
        function d3_rgb_hsl(r, g, b) {
          var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
          if (d) {
            s = l < 0.5 ? d / (max + min) : d / (2 - max - min);
            if (r == max) h = (g - b) / d + (g < b ? 6 : 0);
            else if (g == max) h = (b - r) / d + 2;
            else h = (r - g) / d + 4;
            h *= 60;
          } else {
            h = NaN;
            s = l > 0 && l < 1 ? 0 : h;
          }
          return new d3_hsl(h, s, l);
        }
        function d3_rgb_lab(r, g, b) {
          r = d3_rgb_xyz(r);
          g = d3_rgb_xyz(g);
          b = d3_rgb_xyz(b);
          var x = d3_xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / d3_lab_X), y = d3_xyz_lab((0.2126729 * r + 0.7151522 * g + 0.072175 * b) / d3_lab_Y), z = d3_xyz_lab((0.0193339 * r + 0.119192 * g + 0.9503041 * b) / d3_lab_Z);
          return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
        }
        function d3_rgb_xyz(r) {
          return (r /= 255) <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
        }
        function d3_rgb_parseNumber(c) {
          var f = parseFloat(c);
          return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
        }
        var d3_rgb_names = d3.map({
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074
        });
        d3_rgb_names.forEach(function(key, value) {
          d3_rgb_names.set(key, d3_rgbNumber(value));
        });
        function d3_functor(v) {
          return typeof v === "function" ? v : function() {
            return v;
          };
        }
        d3.functor = d3_functor;
        d3.xhr = d3_xhrType(d3_identity);
        function d3_xhrType(response) {
          return function(url, mimeType, callback) {
            if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, mimeType = null;
            return d3_xhr(url, mimeType, response, callback);
          };
        }
        function d3_xhr(url, mimeType, response, callback) {
          var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
          if (self.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
          "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
            request.readyState > 3 && respond();
          };
          function respond() {
            var status = request.status, result;
            if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
              try {
                result = response.call(xhr, request);
              } catch (e) {
                dispatch.error.call(xhr, e);
                return;
              }
              dispatch.load.call(xhr, result);
            } else {
              dispatch.error.call(xhr, request);
            }
          }
          request.onprogress = function(event) {
            var o = d3.event;
            d3.event = event;
            try {
              dispatch.progress.call(xhr, request);
            } finally {
              d3.event = o;
            }
          };
          xhr.header = function(name, value) {
            name = (name + "").toLowerCase();
            if (arguments.length < 2) return headers[name];
            if (value == null) delete headers[name];
            else headers[name] = value + "";
            return xhr;
          };
          xhr.mimeType = function(value) {
            if (!arguments.length) return mimeType;
            mimeType = value == null ? null : value + "";
            return xhr;
          };
          xhr.responseType = function(value) {
            if (!arguments.length) return responseType;
            responseType = value;
            return xhr;
          };
          xhr.response = function(value) {
            response = value;
            return xhr;
          };
          ["get", "post"].forEach(function(method) {
            xhr[method] = function() {
              return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));
            };
          });
          xhr.send = function(method, data, callback2) {
            if (arguments.length === 2 && typeof data === "function") callback2 = data, data = null;
            request.open(method, url, true);
            if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
            if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
            if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
            if (responseType != null) request.responseType = responseType;
            if (callback2 != null) xhr.on("error", callback2).on("load", function(request2) {
              callback2(null, request2);
            });
            dispatch.beforesend.call(xhr, request);
            request.send(data == null ? null : data);
            return xhr;
          };
          xhr.abort = function() {
            request.abort();
            return xhr;
          };
          d3.rebind(xhr, dispatch, "on");
          return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
        }
        function d3_xhr_fixCallback(callback) {
          return callback.length === 1 ? function(error, request) {
            callback(error == null ? request : null);
          } : callback;
        }
        function d3_xhrHasResponse(request) {
          var type = request.responseType;
          return type && type !== "text" ? request.response : request.responseText;
        }
        d3.dsv = function(delimiter, mimeType) {
          var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
          function dsv(url, row, callback) {
            if (arguments.length < 3) callback = row, row = null;
            var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
            xhr.row = function(_) {
              return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
            };
            return xhr;
          }
          function response(request) {
            return dsv.parse(request.responseText);
          }
          function typedResponse(f) {
            return function(request) {
              return dsv.parse(request.responseText, f);
            };
          }
          dsv.parse = function(text, f) {
            var o;
            return dsv.parseRows(text, function(row, i) {
              if (o) return o(row, i - 1);
              var a = function(d) {
                var obj = {};
                var len = row.length;
                for (var k = 0; k < len; ++k) {
                  obj[row[k]] = d[k];
                }
                return obj;
              };
              o = f ? function(row2, i2) {
                return f(a(row2), i2);
              } : a;
            });
          };
          dsv.parseRows = function(text, f) {
            var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
            function token() {
              if (I >= N) return EOF;
              if (eol) return eol = false, EOL;
              var j = I;
              if (text.charCodeAt(j) === 34) {
                var i = j;
                while (i++ < N) {
                  if (text.charCodeAt(i) === 34) {
                    if (text.charCodeAt(i + 1) !== 34) break;
                    ++i;
                  }
                }
                I = i + 2;
                var c = text.charCodeAt(i + 1);
                if (c === 13) {
                  eol = true;
                  if (text.charCodeAt(i + 2) === 10) ++I;
                } else if (c === 10) {
                  eol = true;
                }
                return text.slice(j + 1, i).replace(/""/g, '"');
              }
              while (I < N) {
                var c = text.charCodeAt(I++), k = 1;
                if (c === 10) eol = true;
                else if (c === 13) {
                  eol = true;
                  if (text.charCodeAt(I) === 10) ++I, ++k;
                } else if (c !== delimiterCode) continue;
                return text.slice(j, I - k);
              }
              return text.slice(j);
            }
            while ((t = token()) !== EOF) {
              var a = [];
              while (t !== EOL && t !== EOF) {
                a.push(t);
                t = token();
              }
              if (f && (a = f(a, n++)) == null) continue;
              rows.push(a);
            }
            return rows;
          };
          dsv.format = function(rows) {
            if (Array.isArray(rows[0])) return dsv.formatRows(rows);
            var fieldSet = new d3_Set(), fields = [];
            rows.forEach(function(row) {
              for (var field in row) {
                if (!fieldSet.has(field)) {
                  fields.push(fieldSet.add(field));
                }
              }
            });
            return [fields.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
              return fields.map(function(field) {
                return formatValue(row[field]);
              }).join(delimiter);
            })).join("\n");
          };
          dsv.formatRows = function(rows) {
            return rows.map(formatRow).join("\n");
          };
          function formatRow(row) {
            return row.map(formatValue).join(delimiter);
          }
          function formatValue(text) {
            return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
          }
          return dsv;
        };
        d3.csv = d3.dsv(",", "text/csv");
        d3.tsv = d3.dsv("	", "text/tab-separated-values");
        var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
          setTimeout(callback, 17);
        };
        d3.timer = function() {
          d3_timer.apply(this, arguments);
        };
        function d3_timer(callback, delay, then) {
          var n = arguments.length;
          if (n < 2) delay = 0;
          if (n < 3) then = Date.now();
          var time = then + delay, timer = {
            c: callback,
            t: time,
            n: null
          };
          if (d3_timer_queueTail) d3_timer_queueTail.n = timer;
          else d3_timer_queueHead = timer;
          d3_timer_queueTail = timer;
          if (!d3_timer_interval) {
            d3_timer_timeout = clearTimeout(d3_timer_timeout);
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
          }
          return timer;
        }
        function d3_timer_step() {
          var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
          if (delay > 24) {
            if (isFinite(delay)) {
              clearTimeout(d3_timer_timeout);
              d3_timer_timeout = setTimeout(d3_timer_step, delay);
            }
            d3_timer_interval = 0;
          } else {
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
          }
        }
        d3.timer.flush = function() {
          d3_timer_mark();
          d3_timer_sweep();
        };
        function d3_timer_mark() {
          var now = Date.now(), timer = d3_timer_queueHead;
          while (timer) {
            if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
            timer = timer.n;
          }
          return now;
        }
        function d3_timer_sweep() {
          var t0, t1 = d3_timer_queueHead, time = Infinity;
          while (t1) {
            if (t1.c) {
              if (t1.t < time) time = t1.t;
              t1 = (t0 = t1).n;
            } else {
              t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
            }
          }
          d3_timer_queueTail = t0;
          return time;
        }
        d3.round = function(x, n) {
          return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
        };
        d3.geom = {};
        function d3_geom_pointX(d) {
          return d[0];
        }
        function d3_geom_pointY(d) {
          return d[1];
        }
        d3.geom.hull = function(vertices) {
          var x = d3_geom_pointX, y = d3_geom_pointY;
          if (arguments.length) return hull(vertices);
          function hull(data) {
            if (data.length < 3) return [];
            var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
            for (i = 0; i < n; i++) {
              points.push([+fx.call(this, data[i], i), +fy.call(this, data[i], i), i]);
            }
            points.sort(d3_geom_hullOrder);
            for (i = 0; i < n; i++) flippedPoints.push([points[i][0], -points[i][1]]);
            var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
            var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
            for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
            for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
            return polygon;
          }
          hull.x = function(_) {
            return arguments.length ? (x = _, hull) : x;
          };
          hull.y = function(_) {
            return arguments.length ? (y = _, hull) : y;
          };
          return hull;
        };
        function d3_geom_hullUpper(points) {
          var n = points.length, hull = [0, 1], hs = 2;
          for (var i = 2; i < n; i++) {
            while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
            hull[hs++] = i;
          }
          return hull.slice(0, hs);
        }
        function d3_geom_hullOrder(a, b) {
          return a[0] - b[0] || a[1] - b[1];
        }
        d3.geom.polygon = function(coordinates) {
          d3_subclass(coordinates, d3_geom_polygonPrototype);
          return coordinates;
        };
        var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
        d3_geom_polygonPrototype.area = function() {
          var i = -1, n = this.length, a, b = this[n - 1], area = 0;
          while (++i < n) {
            a = b;
            b = this[i];
            area += a[1] * b[0] - a[0] * b[1];
          }
          return area * 0.5;
        };
        d3_geom_polygonPrototype.centroid = function(k) {
          var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
          if (!arguments.length) k = -1 / (6 * this.area());
          while (++i < n) {
            a = b;
            b = this[i];
            c = a[0] * b[1] - b[0] * a[1];
            x += (a[0] + b[0]) * c;
            y += (a[1] + b[1]) * c;
          }
          return [x * k, y * k];
        };
        d3_geom_polygonPrototype.clip = function(subject) {
          var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
          while (++i < n) {
            input = subject.slice();
            subject.length = 0;
            b = this[i];
            c = input[(m = input.length - closed) - 1];
            j = -1;
            while (++j < m) {
              d = input[j];
              if (d3_geom_polygonInside(d, a, b)) {
                if (!d3_geom_polygonInside(c, a, b)) {
                  subject.push(d3_geom_polygonIntersect(c, d, a, b));
                }
                subject.push(d);
              } else if (d3_geom_polygonInside(c, a, b)) {
                subject.push(d3_geom_polygonIntersect(c, d, a, b));
              }
              c = d;
            }
            if (closed) subject.push(subject[0]);
            a = b;
          }
          return subject;
        };
        function d3_geom_polygonInside(p, a, b) {
          return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
        }
        function d3_geom_polygonIntersect(c, d, a, b) {
          var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
          return [x1 + ua * x21, y1 + ua * y21];
        }
        function d3_geom_polygonClosed(coordinates) {
          var a = coordinates[0], b = coordinates[coordinates.length - 1];
          return !(a[0] - b[0] || a[1] - b[1]);
        }
        var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
        function d3_geom_voronoiBeach() {
          d3_geom_voronoiRedBlackNode(this);
          this.edge = this.site = this.circle = null;
        }
        function d3_geom_voronoiCreateBeach(site) {
          var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
          beach.site = site;
          return beach;
        }
        function d3_geom_voronoiDetachBeach(beach) {
          d3_geom_voronoiDetachCircle(beach);
          d3_geom_voronoiBeaches.remove(beach);
          d3_geom_voronoiBeachPool.push(beach);
          d3_geom_voronoiRedBlackNode(beach);
        }
        function d3_geom_voronoiRemoveBeach(beach) {
          var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
            x,
            y
          }, previous = beach.P, next = beach.N, disappearing = [beach];
          d3_geom_voronoiDetachBeach(beach);
          var lArc = previous;
          while (lArc.circle && abs(x - lArc.circle.x) < \u03B5 && abs(y - lArc.circle.cy) < \u03B5) {
            previous = lArc.P;
            disappearing.unshift(lArc);
            d3_geom_voronoiDetachBeach(lArc);
            lArc = previous;
          }
          disappearing.unshift(lArc);
          d3_geom_voronoiDetachCircle(lArc);
          var rArc = next;
          while (rArc.circle && abs(x - rArc.circle.x) < \u03B5 && abs(y - rArc.circle.cy) < \u03B5) {
            next = rArc.N;
            disappearing.push(rArc);
            d3_geom_voronoiDetachBeach(rArc);
            rArc = next;
          }
          disappearing.push(rArc);
          d3_geom_voronoiDetachCircle(rArc);
          var nArcs = disappearing.length, iArc;
          for (iArc = 1; iArc < nArcs; ++iArc) {
            rArc = disappearing[iArc];
            lArc = disappearing[iArc - 1];
            d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
          }
          lArc = disappearing[0];
          rArc = disappearing[nArcs - 1];
          rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
          d3_geom_voronoiAttachCircle(lArc);
          d3_geom_voronoiAttachCircle(rArc);
        }
        function d3_geom_voronoiAddBeach(site) {
          var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
          while (node) {
            dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
            if (dxl > \u03B5) node = node.L;
            else {
              dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
              if (dxr > \u03B5) {
                if (!node.R) {
                  lArc = node;
                  break;
                }
                node = node.R;
              } else {
                if (dxl > -\u03B5) {
                  lArc = node.P;
                  rArc = node;
                } else if (dxr > -\u03B5) {
                  lArc = node;
                  rArc = node.N;
                } else {
                  lArc = rArc = node;
                }
                break;
              }
            }
          }
          var newArc = d3_geom_voronoiCreateBeach(site);
          d3_geom_voronoiBeaches.insert(lArc, newArc);
          if (!lArc && !rArc) return;
          if (lArc === rArc) {
            d3_geom_voronoiDetachCircle(lArc);
            rArc = d3_geom_voronoiCreateBeach(lArc.site);
            d3_geom_voronoiBeaches.insert(newArc, rArc);
            newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            d3_geom_voronoiAttachCircle(lArc);
            d3_geom_voronoiAttachCircle(rArc);
            return;
          }
          if (!rArc) {
            newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            return;
          }
          d3_geom_voronoiDetachCircle(lArc);
          d3_geom_voronoiDetachCircle(rArc);
          var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
            x: (cy * hb - by * hc) / d + ax,
            y: (bx * hc - cx * hb) / d + ay
          };
          d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
          newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
          rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
          d3_geom_voronoiAttachCircle(lArc);
          d3_geom_voronoiAttachCircle(rArc);
        }
        function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
          var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
          if (!pby2) return rfocx;
          var lArc = arc.P;
          if (!lArc) return -Infinity;
          site = lArc.site;
          var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
          if (!plby2) return lfocx;
          var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
          if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
          return (rfocx + lfocx) / 2;
        }
        function d3_geom_voronoiRightBreakPoint(arc, directrix) {
          var rArc = arc.N;
          if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
          var site = arc.site;
          return site.y === directrix ? site.x : Infinity;
        }
        function d3_geom_voronoiCell(site) {
          this.site = site;
          this.edges = [];
        }
        d3_geom_voronoiCell.prototype.prepare = function() {
          var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
          while (iHalfEdge--) {
            edge = halfEdges[iHalfEdge].edge;
            if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
          }
          halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
          return halfEdges.length;
        };
        function d3_geom_voronoiCloseCells(extent) {
          var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
          while (iCell--) {
            cell = cells[iCell];
            if (!cell || !cell.prepare()) continue;
            halfEdges = cell.edges;
            nHalfEdges = halfEdges.length;
            iHalfEdge = 0;
            while (iHalfEdge < nHalfEdges) {
              end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
              start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
              if (abs(x3 - x2) > \u03B5 || abs(y3 - y2) > \u03B5) {
                halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < \u03B5 && y1 - y3 > \u03B5 ? {
                  x: x0,
                  y: abs(x2 - x0) < \u03B5 ? y2 : y1
                } : abs(y3 - y1) < \u03B5 && x1 - x3 > \u03B5 ? {
                  x: abs(y2 - y1) < \u03B5 ? x2 : x1,
                  y: y1
                } : abs(x3 - x1) < \u03B5 && y3 - y0 > \u03B5 ? {
                  x: x1,
                  y: abs(x2 - x1) < \u03B5 ? y2 : y0
                } : abs(y3 - y0) < \u03B5 && x3 - x0 > \u03B5 ? {
                  x: abs(y2 - y0) < \u03B5 ? x2 : x0,
                  y: y0
                } : null), cell.site, null));
                ++nHalfEdges;
              }
            }
          }
        }
        function d3_geom_voronoiHalfEdgeOrder(a, b) {
          return b.angle - a.angle;
        }
        function d3_geom_voronoiCircle() {
          d3_geom_voronoiRedBlackNode(this);
          this.x = this.y = this.arc = this.site = this.cy = null;
        }
        function d3_geom_voronoiAttachCircle(arc) {
          var lArc = arc.P, rArc = arc.N;
          if (!lArc || !rArc) return;
          var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
          if (lSite === rSite) return;
          var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
          var d = 2 * (ax * cy - ay * cx);
          if (d >= -\u03B52) return;
          var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
          var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
          circle.arc = arc;
          circle.site = cSite;
          circle.x = x + bx;
          circle.y = cy + Math.sqrt(x * x + y * y);
          circle.cy = cy;
          arc.circle = circle;
          var before = null, node = d3_geom_voronoiCircles._;
          while (node) {
            if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
              if (node.L) node = node.L;
              else {
                before = node.P;
                break;
              }
            } else {
              if (node.R) node = node.R;
              else {
                before = node;
                break;
              }
            }
          }
          d3_geom_voronoiCircles.insert(before, circle);
          if (!before) d3_geom_voronoiFirstCircle = circle;
        }
        function d3_geom_voronoiDetachCircle(arc) {
          var circle = arc.circle;
          if (circle) {
            if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
            d3_geom_voronoiCircles.remove(circle);
            d3_geom_voronoiCirclePool.push(circle);
            d3_geom_voronoiRedBlackNode(circle);
            arc.circle = null;
          }
        }
        function d3_geom_clipLine(x0, y0, x1, y1) {
          return function(line) {
            var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
            r = x0 - ax;
            if (!dx && r > 0) return;
            r /= dx;
            if (dx < 0) {
              if (r < t0) return;
              if (r < t1) t1 = r;
            } else if (dx > 0) {
              if (r > t1) return;
              if (r > t0) t0 = r;
            }
            r = x1 - ax;
            if (!dx && r < 0) return;
            r /= dx;
            if (dx < 0) {
              if (r > t1) return;
              if (r > t0) t0 = r;
            } else if (dx > 0) {
              if (r < t0) return;
              if (r < t1) t1 = r;
            }
            r = y0 - ay;
            if (!dy && r > 0) return;
            r /= dy;
            if (dy < 0) {
              if (r < t0) return;
              if (r < t1) t1 = r;
            } else if (dy > 0) {
              if (r > t1) return;
              if (r > t0) t0 = r;
            }
            r = y1 - ay;
            if (!dy && r < 0) return;
            r /= dy;
            if (dy < 0) {
              if (r > t1) return;
              if (r > t0) t0 = r;
            } else if (dy > 0) {
              if (r < t0) return;
              if (r < t1) t1 = r;
            }
            if (t0 > 0) line.a = {
              x: ax + t0 * dx,
              y: ay + t0 * dy
            };
            if (t1 < 1) line.b = {
              x: ax + t1 * dx,
              y: ay + t1 * dy
            };
            return line;
          };
        }
        function d3_geom_voronoiClipEdges(extent) {
          var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
          while (i--) {
            e = edges[i];
            if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < \u03B5 && abs(e.a.y - e.b.y) < \u03B5) {
              e.a = e.b = null;
              edges.splice(i, 1);
            }
          }
        }
        function d3_geom_voronoiConnectEdge(edge, extent) {
          var vb = edge.b;
          if (vb) return true;
          var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
          if (ry === ly) {
            if (fx < x0 || fx >= x1) return;
            if (lx > rx) {
              if (!va) va = {
                x: fx,
                y: y0
              };
              else if (va.y >= y1) return;
              vb = {
                x: fx,
                y: y1
              };
            } else {
              if (!va) va = {
                x: fx,
                y: y1
              };
              else if (va.y < y0) return;
              vb = {
                x: fx,
                y: y0
              };
            }
          } else {
            fm = (lx - rx) / (ry - ly);
            fb = fy - fm * fx;
            if (fm < -1 || fm > 1) {
              if (lx > rx) {
                if (!va) va = {
                  x: (y0 - fb) / fm,
                  y: y0
                };
                else if (va.y >= y1) return;
                vb = {
                  x: (y1 - fb) / fm,
                  y: y1
                };
              } else {
                if (!va) va = {
                  x: (y1 - fb) / fm,
                  y: y1
                };
                else if (va.y < y0) return;
                vb = {
                  x: (y0 - fb) / fm,
                  y: y0
                };
              }
            } else {
              if (ly < ry) {
                if (!va) va = {
                  x: x0,
                  y: fm * x0 + fb
                };
                else if (va.x >= x1) return;
                vb = {
                  x: x1,
                  y: fm * x1 + fb
                };
              } else {
                if (!va) va = {
                  x: x1,
                  y: fm * x1 + fb
                };
                else if (va.x < x0) return;
                vb = {
                  x: x0,
                  y: fm * x0 + fb
                };
              }
            }
          }
          edge.a = va;
          edge.b = vb;
          return true;
        }
        function d3_geom_voronoiEdge(lSite, rSite) {
          this.l = lSite;
          this.r = rSite;
          this.a = this.b = null;
        }
        function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
          var edge = new d3_geom_voronoiEdge(lSite, rSite);
          d3_geom_voronoiEdges.push(edge);
          if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
          if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
          d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
          d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
          return edge;
        }
        function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
          var edge = new d3_geom_voronoiEdge(lSite, null);
          edge.a = va;
          edge.b = vb;
          d3_geom_voronoiEdges.push(edge);
          return edge;
        }
        function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
          if (!edge.a && !edge.b) {
            edge.a = vertex;
            edge.l = lSite;
            edge.r = rSite;
          } else if (edge.l === rSite) {
            edge.b = vertex;
          } else {
            edge.a = vertex;
          }
        }
        function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
          var va = edge.a, vb = edge.b;
          this.edge = edge;
          this.site = lSite;
          this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
        }
        d3_geom_voronoiHalfEdge.prototype = {
          start: function() {
            return this.edge.l === this.site ? this.edge.a : this.edge.b;
          },
          end: function() {
            return this.edge.l === this.site ? this.edge.b : this.edge.a;
          }
        };
        function d3_geom_voronoiRedBlackTree() {
          this._ = null;
        }
        function d3_geom_voronoiRedBlackNode(node) {
          node.U = node.C = node.L = node.R = node.P = node.N = null;
        }
        d3_geom_voronoiRedBlackTree.prototype = {
          insert: function(after, node) {
            var parent, grandpa, uncle;
            if (after) {
              node.P = after;
              node.N = after.N;
              if (after.N) after.N.P = node;
              after.N = node;
              if (after.R) {
                after = after.R;
                while (after.L) after = after.L;
                after.L = node;
              } else {
                after.R = node;
              }
              parent = after;
            } else if (this._) {
              after = d3_geom_voronoiRedBlackFirst(this._);
              node.P = null;
              node.N = after;
              after.P = after.L = node;
              parent = after;
            } else {
              node.P = node.N = null;
              this._ = node;
              parent = null;
            }
            node.L = node.R = null;
            node.U = parent;
            node.C = true;
            after = node;
            while (parent && parent.C) {
              grandpa = parent.U;
              if (parent === grandpa.L) {
                uncle = grandpa.R;
                if (uncle && uncle.C) {
                  parent.C = uncle.C = false;
                  grandpa.C = true;
                  after = grandpa;
                } else {
                  if (after === parent.R) {
                    d3_geom_voronoiRedBlackRotateLeft(this, parent);
                    after = parent;
                    parent = after.U;
                  }
                  parent.C = false;
                  grandpa.C = true;
                  d3_geom_voronoiRedBlackRotateRight(this, grandpa);
                }
              } else {
                uncle = grandpa.L;
                if (uncle && uncle.C) {
                  parent.C = uncle.C = false;
                  grandpa.C = true;
                  after = grandpa;
                } else {
                  if (after === parent.L) {
                    d3_geom_voronoiRedBlackRotateRight(this, parent);
                    after = parent;
                    parent = after.U;
                  }
                  parent.C = false;
                  grandpa.C = true;
                  d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
                }
              }
              parent = after.U;
            }
            this._.C = false;
          },
          remove: function(node) {
            if (node.N) node.N.P = node.P;
            if (node.P) node.P.N = node.N;
            node.N = node.P = null;
            var parent = node.U, sibling, left = node.L, right = node.R, next, red;
            if (!left) next = right;
            else if (!right) next = left;
            else next = d3_geom_voronoiRedBlackFirst(right);
            if (parent) {
              if (parent.L === node) parent.L = next;
              else parent.R = next;
            } else {
              this._ = next;
            }
            if (left && right) {
              red = next.C;
              next.C = node.C;
              next.L = left;
              left.U = next;
              if (next !== right) {
                parent = next.U;
                next.U = node.U;
                node = next.R;
                parent.L = node;
                next.R = right;
                right.U = next;
              } else {
                next.U = parent;
                parent = next;
                node = next.R;
              }
            } else {
              red = node.C;
              node = next;
            }
            if (node) node.U = parent;
            if (red) return;
            if (node && node.C) {
              node.C = false;
              return;
            }
            do {
              if (node === this._) break;
              if (node === parent.L) {
                sibling = parent.R;
                if (sibling.C) {
                  sibling.C = false;
                  parent.C = true;
                  d3_geom_voronoiRedBlackRotateLeft(this, parent);
                  sibling = parent.R;
                }
                if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                  if (!sibling.R || !sibling.R.C) {
                    sibling.L.C = false;
                    sibling.C = true;
                    d3_geom_voronoiRedBlackRotateRight(this, sibling);
                    sibling = parent.R;
                  }
                  sibling.C = parent.C;
                  parent.C = sibling.R.C = false;
                  d3_geom_voronoiRedBlackRotateLeft(this, parent);
                  node = this._;
                  break;
                }
              } else {
                sibling = parent.L;
                if (sibling.C) {
                  sibling.C = false;
                  parent.C = true;
                  d3_geom_voronoiRedBlackRotateRight(this, parent);
                  sibling = parent.L;
                }
                if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                  if (!sibling.L || !sibling.L.C) {
                    sibling.R.C = false;
                    sibling.C = true;
                    d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                    sibling = parent.L;
                  }
                  sibling.C = parent.C;
                  parent.C = sibling.L.C = false;
                  d3_geom_voronoiRedBlackRotateRight(this, parent);
                  node = this._;
                  break;
                }
              }
              sibling.C = true;
              node = parent;
              parent = parent.U;
            } while (!node.C);
            if (node) node.C = false;
          }
        };
        function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
          var p = node, q = node.R, parent = p.U;
          if (parent) {
            if (parent.L === p) parent.L = q;
            else parent.R = q;
          } else {
            tree._ = q;
          }
          q.U = parent;
          p.U = q;
          p.R = q.L;
          if (p.R) p.R.U = p;
          q.L = p;
        }
        function d3_geom_voronoiRedBlackRotateRight(tree, node) {
          var p = node, q = node.L, parent = p.U;
          if (parent) {
            if (parent.L === p) parent.L = q;
            else parent.R = q;
          } else {
            tree._ = q;
          }
          q.U = parent;
          p.U = q;
          p.L = q.R;
          if (p.L) p.L.U = p;
          q.R = p;
        }
        function d3_geom_voronoiRedBlackFirst(node) {
          while (node.L) node = node.L;
          return node;
        }
        function d3_geom_voronoi(sites, bbox) {
          var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
          d3_geom_voronoiEdges = [];
          d3_geom_voronoiCells = new Array(sites.length);
          d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
          d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
          while (true) {
            circle = d3_geom_voronoiFirstCircle;
            if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
              if (site.x !== x0 || site.y !== y0) {
                d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
                d3_geom_voronoiAddBeach(site);
                x0 = site.x, y0 = site.y;
              }
              site = sites.pop();
            } else if (circle) {
              d3_geom_voronoiRemoveBeach(circle.arc);
            } else {
              break;
            }
          }
          if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
          var diagram = {
            cells: d3_geom_voronoiCells,
            edges: d3_geom_voronoiEdges
          };
          d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
          return diagram;
        }
        function d3_geom_voronoiVertexOrder(a, b) {
          return b.y - a.y || b.x - a.x;
        }
        d3.geom.voronoi = function(points) {
          var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
          if (points) return voronoi(points);
          function voronoi(data) {
            var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
            d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
              var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
                var s = e.start();
                return [s.x, s.y];
              }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]] : [];
              polygon.point = data[i];
            });
            return polygons;
          }
          function sites(data) {
            return data.map(function(d, i) {
              return {
                x: Math.round(fx(d, i) / \u03B5) * \u03B5,
                y: Math.round(fy(d, i) / \u03B5) * \u03B5,
                i
              };
            });
          }
          voronoi.links = function(data) {
            return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
              return edge.l && edge.r;
            }).map(function(edge) {
              return {
                source: data[edge.l.i],
                target: data[edge.r.i]
              };
            });
          };
          voronoi.triangles = function(data) {
            var triangles = [];
            d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
              var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
              while (++j < m) {
                e0 = e1;
                s0 = s1;
                e1 = edges[j].edge;
                s1 = e1.l === site ? e1.r : e1.l;
                if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                  triangles.push([data[i], data[s0.i], data[s1.i]]);
                }
              }
            });
            return triangles;
          };
          voronoi.x = function(_) {
            return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
          };
          voronoi.y = function(_) {
            return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
          };
          voronoi.clipExtent = function(_) {
            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
            clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
            return voronoi;
          };
          voronoi.size = function(_) {
            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
            return voronoi.clipExtent(_ && [[0, 0], _]);
          };
          return voronoi;
        };
        var d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];
        function d3_geom_voronoiTriangleArea(a, b, c) {
          return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
        }
        d3.geom.delaunay = function(vertices) {
          return d3.geom.voronoi().triangles(vertices);
        };
        d3.geom.quadtree = function(points, x1, y1, x2, y2) {
          var x = d3_geom_pointX, y = d3_geom_pointY, compat;
          if (compat = arguments.length) {
            x = d3_geom_quadtreeCompatX;
            y = d3_geom_quadtreeCompatY;
            if (compat === 3) {
              y2 = y1;
              x2 = x1;
              y1 = x1 = 0;
            }
            return quadtree(points);
          }
          function quadtree(data) {
            var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
            if (x1 != null) {
              x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
            } else {
              x2_ = y2_ = -(x1_ = y1_ = Infinity);
              xs = [], ys = [];
              n = data.length;
              if (compat) for (i = 0; i < n; ++i) {
                d = data[i];
                if (d.x < x1_) x1_ = d.x;
                if (d.y < y1_) y1_ = d.y;
                if (d.x > x2_) x2_ = d.x;
                if (d.y > y2_) y2_ = d.y;
                xs.push(d.x);
                ys.push(d.y);
              }
              else for (i = 0; i < n; ++i) {
                var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
                if (x_ < x1_) x1_ = x_;
                if (y_ < y1_) y1_ = y_;
                if (x_ > x2_) x2_ = x_;
                if (y_ > y2_) y2_ = y_;
                xs.push(x_);
                ys.push(y_);
              }
            }
            var dx = x2_ - x1_, dy = y2_ - y1_;
            if (dx > dy) y2_ = y1_ + dx;
            else x2_ = x1_ + dy;
            function insert(n2, d2, x3, y3, x12, y12, x22, y22) {
              if (isNaN(x3) || isNaN(y3)) return;
              if (n2.leaf) {
                var nx = n2.x, ny = n2.y;
                if (nx != null) {
                  if (abs(nx - x3) + abs(ny - y3) < 0.01) {
                    insertChild(n2, d2, x3, y3, x12, y12, x22, y22);
                  } else {
                    var nPoint = n2.point;
                    n2.x = n2.y = n2.point = null;
                    insertChild(n2, nPoint, nx, ny, x12, y12, x22, y22);
                    insertChild(n2, d2, x3, y3, x12, y12, x22, y22);
                  }
                } else {
                  n2.x = x3, n2.y = y3, n2.point = d2;
                }
              } else {
                insertChild(n2, d2, x3, y3, x12, y12, x22, y22);
              }
            }
            function insertChild(n2, d2, x3, y3, x12, y12, x22, y22) {
              var xm = (x12 + x22) * 0.5, ym = (y12 + y22) * 0.5, right = x3 >= xm, below = y3 >= ym, i2 = below << 1 | right;
              n2.leaf = false;
              n2 = n2.nodes[i2] || (n2.nodes[i2] = d3_geom_quadtreeNode());
              if (right) x12 = xm;
              else x22 = xm;
              if (below) y12 = ym;
              else y22 = ym;
              insert(n2, d2, x3, y3, x12, y12, x22, y22);
            }
            var root = d3_geom_quadtreeNode();
            root.add = function(d2) {
              insert(root, d2, +fx(d2, ++i), +fy(d2, i), x1_, y1_, x2_, y2_);
            };
            root.visit = function(f) {
              d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
            };
            root.find = function(point) {
              return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
            };
            i = -1;
            if (x1 == null) {
              while (++i < n) {
                insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
              }
              --i;
            } else data.forEach(root.add);
            xs = ys = data = d = null;
            return root;
          }
          quadtree.x = function(_) {
            return arguments.length ? (x = _, quadtree) : x;
          };
          quadtree.y = function(_) {
            return arguments.length ? (y = _, quadtree) : y;
          };
          quadtree.extent = function(_) {
            if (!arguments.length) return x1 == null ? null : [[x1, y1], [x2, y2]];
            if (_ == null) x1 = y1 = x2 = y2 = null;
            else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], y2 = +_[1][1];
            return quadtree;
          };
          quadtree.size = function(_) {
            if (!arguments.length) return x1 == null ? null : [x2 - x1, y2 - y1];
            if (_ == null) x1 = y1 = x2 = y2 = null;
            else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
            return quadtree;
          };
          return quadtree;
        };
        function d3_geom_quadtreeCompatX(d) {
          return d.x;
        }
        function d3_geom_quadtreeCompatY(d) {
          return d.y;
        }
        function d3_geom_quadtreeNode() {
          return {
            leaf: true,
            nodes: [],
            point: null,
            x: null,
            y: null
          };
        }
        function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
          if (!f(node, x1, y1, x2, y2)) {
            var sx = (x1 + x2) * 0.5, sy = (y1 + y2) * 0.5, children = node.nodes;
            if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
            if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
            if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
            if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
          }
        }
        function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
          var minDistance2 = Infinity, closestPoint;
          (function find(node, x1, y1, x2, y2) {
            if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
            if (point = node.point) {
              var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
              if (distance2 < minDistance2) {
                var distance = Math.sqrt(minDistance2 = distance2);
                x0 = x - distance, y0 = y - distance;
                x3 = x + distance, y3 = y + distance;
                closestPoint = point;
              }
            }
            var children = node.nodes, xm = (x1 + x2) * 0.5, ym = (y1 + y2) * 0.5, right = x >= xm, below = y >= ym;
            for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
              if (node = children[i & 3]) switch (i & 3) {
                case 0:
                  find(node, x1, y1, xm, ym);
                  break;
                case 1:
                  find(node, xm, y1, x2, ym);
                  break;
                case 2:
                  find(node, x1, ym, xm, y2);
                  break;
                case 3:
                  find(node, xm, ym, x2, y2);
                  break;
              }
            }
          })(root, x0, y0, x3, y3);
          return closestPoint;
        }
        d3.interpolateRgb = d3_interpolateRgb;
        function d3_interpolateRgb(a, b) {
          a = d3.rgb(a);
          b = d3.rgb(b);
          var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
          return function(t) {
            return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
          };
        }
        d3.interpolateObject = d3_interpolateObject;
        function d3_interpolateObject(a, b) {
          var i = {}, c = {}, k;
          for (k in a) {
            if (k in b) {
              i[k] = d3_interpolate(a[k], b[k]);
            } else {
              c[k] = a[k];
            }
          }
          for (k in b) {
            if (!(k in a)) {
              c[k] = b[k];
            }
          }
          return function(t) {
            for (k in i) c[k] = i[k](t);
            return c;
          };
        }
        d3.interpolateNumber = d3_interpolateNumber;
        function d3_interpolateNumber(a, b) {
          a = +a, b = +b;
          return function(t) {
            return a * (1 - t) + b * t;
          };
        }
        d3.interpolateString = d3_interpolateString;
        function d3_interpolateString(a, b) {
          var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
          a = a + "", b = b + "";
          while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
            if ((bs = bm.index) > bi) {
              bs = b.slice(bi, bs);
              if (s[i]) s[i] += bs;
              else s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) {
              if (s[i]) s[i] += bm;
              else s[++i] = bm;
            } else {
              s[++i] = null;
              q.push({
                i,
                x: d3_interpolateNumber(am, bm)
              });
            }
            bi = d3_interpolate_numberB.lastIndex;
          }
          if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i]) s[i] += bs;
            else s[++i] = bs;
          }
          return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
            return b(t) + "";
          }) : function() {
            return b;
          } : (b = q.length, function(t) {
            for (var i2 = 0, o; i2 < b; ++i2) s[(o = q[i2]).i] = o.x(t);
            return s.join("");
          });
        }
        var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
        d3.interpolate = d3_interpolate;
        function d3_interpolate(a, b) {
          var i = d3.interpolators.length, f;
          while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
          return f;
        }
        d3.interpolators = [function(a, b) {
          var t = typeof b;
          return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
        }];
        d3.interpolateArray = d3_interpolateArray;
        function d3_interpolateArray(a, b) {
          var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
          for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
          for (; i < na; ++i) c[i] = a[i];
          for (; i < nb; ++i) c[i] = b[i];
          return function(t) {
            for (i = 0; i < n0; ++i) c[i] = x[i](t);
            return c;
          };
        }
        var d3_ease_default = function() {
          return d3_identity;
        };
        var d3_ease = d3.map({
          linear: d3_ease_default,
          poly: d3_ease_poly,
          quad: function() {
            return d3_ease_quad;
          },
          cubic: function() {
            return d3_ease_cubic;
          },
          sin: function() {
            return d3_ease_sin;
          },
          exp: function() {
            return d3_ease_exp;
          },
          circle: function() {
            return d3_ease_circle;
          },
          elastic: d3_ease_elastic,
          back: d3_ease_back,
          bounce: function() {
            return d3_ease_bounce;
          }
        });
        var d3_ease_mode = d3.map({
          "in": d3_identity,
          out: d3_ease_reverse,
          "in-out": d3_ease_reflect,
          "out-in": function(f) {
            return d3_ease_reflect(d3_ease_reverse(f));
          }
        });
        d3.ease = function(name) {
          var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
          t = d3_ease.get(t) || d3_ease_default;
          m = d3_ease_mode.get(m) || d3_identity;
          return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
        };
        function d3_ease_clamp(f) {
          return function(t) {
            return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
          };
        }
        function d3_ease_reverse(f) {
          return function(t) {
            return 1 - f(1 - t);
          };
        }
        function d3_ease_reflect(f) {
          return function(t) {
            return 0.5 * (t < 0.5 ? f(2 * t) : 2 - f(2 - 2 * t));
          };
        }
        function d3_ease_quad(t) {
          return t * t;
        }
        function d3_ease_cubic(t) {
          return t * t * t;
        }
        function d3_ease_cubicInOut(t) {
          if (t <= 0) return 0;
          if (t >= 1) return 1;
          var t2 = t * t, t3 = t2 * t;
          return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
        }
        function d3_ease_poly(e) {
          return function(t) {
            return Math.pow(t, e);
          };
        }
        function d3_ease_sin(t) {
          return 1 - Math.cos(t * half\u03C0);
        }
        function d3_ease_exp(t) {
          return Math.pow(2, 10 * (t - 1));
        }
        function d3_ease_circle(t) {
          return 1 - Math.sqrt(1 - t * t);
        }
        function d3_ease_elastic(a, p) {
          var s;
          if (arguments.length < 2) p = 0.45;
          if (arguments.length) s = p / \u03C4 * Math.asin(1 / a);
          else a = 1, s = p / 4;
          return function(t) {
            return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * \u03C4 / p);
          };
        }
        function d3_ease_back(s) {
          if (!s) s = 1.70158;
          return function(t) {
            return t * t * ((s + 1) * t - s);
          };
        }
        function d3_ease_bounce(t) {
          return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
        }
        d3.interpolateHcl = d3_interpolateHcl;
        function d3_interpolateHcl(a, b) {
          a = d3.hcl(a);
          b = d3.hcl(b);
          var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
          if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
          if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah;
          else if (bh > 180) bh -= 360;
          else if (bh < -180) bh += 360;
          return function(t) {
            return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
          };
        }
        d3.interpolateHsl = d3_interpolateHsl;
        function d3_interpolateHsl(a, b) {
          a = d3.hsl(a);
          b = d3.hsl(b);
          var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
          if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
          if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah;
          else if (bh > 180) bh -= 360;
          else if (bh < -180) bh += 360;
          return function(t) {
            return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
          };
        }
        d3.interpolateLab = d3_interpolateLab;
        function d3_interpolateLab(a, b) {
          a = d3.lab(a);
          b = d3.lab(b);
          var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
          return function(t) {
            return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
          };
        }
        d3.interpolateRound = d3_interpolateRound;
        function d3_interpolateRound(a, b) {
          b -= a;
          return function(t) {
            return Math.round(a + b * t);
          };
        }
        d3.transform = function(string) {
          var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
          return (d3.transform = function(string2) {
            if (string2 != null) {
              g.setAttribute("transform", string2);
              var t = g.transform.baseVal.consolidate();
            }
            return new d3_transform(t ? t.matrix : d3_transformIdentity);
          })(string);
        };
        function d3_transform(m) {
          var r0 = [m.a, m.b], r1 = [m.c, m.d], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
          if (r0[0] * r1[1] < r1[0] * r0[1]) {
            r0[0] *= -1;
            r0[1] *= -1;
            kx *= -1;
            kz *= -1;
          }
          this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
          this.translate = [m.e, m.f];
          this.scale = [kx, ky];
          this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
        }
        d3_transform.prototype.toString = function() {
          return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
        };
        function d3_transformDot(a, b) {
          return a[0] * b[0] + a[1] * b[1];
        }
        function d3_transformNormalize(a) {
          var k = Math.sqrt(d3_transformDot(a, a));
          if (k) {
            a[0] /= k;
            a[1] /= k;
          }
          return k;
        }
        function d3_transformCombine(a, b, k) {
          a[0] += k * b[0];
          a[1] += k * b[1];
          return a;
        }
        var d3_transformIdentity = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: 0,
          f: 0
        };
        d3.interpolateTransform = d3_interpolateTransform;
        function d3_interpolateTransformPop(s) {
          return s.length ? s.pop() + "," : "";
        }
        function d3_interpolateTranslate(ta, tb, s, q) {
          if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
            var i = s.push("translate(", null, ",", null, ")");
            q.push({
              i: i - 4,
              x: d3_interpolateNumber(ta[0], tb[0])
            }, {
              i: i - 2,
              x: d3_interpolateNumber(ta[1], tb[1])
            });
          } else if (tb[0] || tb[1]) {
            s.push("translate(" + tb + ")");
          }
        }
        function d3_interpolateRotate(ra, rb, s, q) {
          if (ra !== rb) {
            if (ra - rb > 180) rb += 360;
            else if (rb - ra > 180) ra += 360;
            q.push({
              i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
              x: d3_interpolateNumber(ra, rb)
            });
          } else if (rb) {
            s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
          }
        }
        function d3_interpolateSkew(wa, wb, s, q) {
          if (wa !== wb) {
            q.push({
              i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
              x: d3_interpolateNumber(wa, wb)
            });
          } else if (wb) {
            s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
          }
        }
        function d3_interpolateScale(ka, kb, s, q) {
          if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
            var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
            q.push({
              i: i - 4,
              x: d3_interpolateNumber(ka[0], kb[0])
            }, {
              i: i - 2,
              x: d3_interpolateNumber(ka[1], kb[1])
            });
          } else if (kb[0] !== 1 || kb[1] !== 1) {
            s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
          }
        }
        function d3_interpolateTransform(a, b) {
          var s = [], q = [];
          a = d3.transform(a), b = d3.transform(b);
          d3_interpolateTranslate(a.translate, b.translate, s, q);
          d3_interpolateRotate(a.rotate, b.rotate, s, q);
          d3_interpolateSkew(a.skew, b.skew, s, q);
          d3_interpolateScale(a.scale, b.scale, s, q);
          a = b = null;
          return function(t) {
            var i = -1, n = q.length, o;
            while (++i < n) s[(o = q[i]).i] = o.x(t);
            return s.join("");
          };
        }
        function d3_uninterpolateNumber(a, b) {
          b = (b -= a = +a) || 1 / b;
          return function(x) {
            return (x - a) / b;
          };
        }
        function d3_uninterpolateClamp(a, b) {
          b = (b -= a = +a) || 1 / b;
          return function(x) {
            return Math.max(0, Math.min(1, (x - a) / b));
          };
        }
        d3.layout = {};
        d3.layout.bundle = function() {
          return function(links) {
            var paths = [], i = -1, n = links.length;
            while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
            return paths;
          };
        };
        function d3_layout_bundlePath(link) {
          var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [start];
          while (start !== lca) {
            start = start.parent;
            points.push(start);
          }
          var k = points.length;
          while (end !== lca) {
            points.splice(k, 0, end);
            end = end.parent;
          }
          return points;
        }
        function d3_layout_bundleAncestors(node) {
          var ancestors = [], parent = node.parent;
          while (parent != null) {
            ancestors.push(node);
            node = parent;
            parent = parent.parent;
          }
          ancestors.push(node);
          return ancestors;
        }
        function d3_layout_bundleLeastCommonAncestor(a, b) {
          if (a === b) return a;
          var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
          while (aNode === bNode) {
            sharedNode = aNode;
            aNode = aNodes.pop();
            bNode = bNodes.pop();
          }
          return sharedNode;
        }
        d3.layout.chord = function() {
          var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
          function relayout() {
            var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
            chords = [];
            groups = [];
            k = 0, i = -1;
            while (++i < n) {
              x = 0, j = -1;
              while (++j < n) {
                x += matrix[i][j];
              }
              groupSums.push(x);
              subgroupIndex.push(d3.range(n));
              k += x;
            }
            if (sortGroups) {
              groupIndex.sort(function(a, b) {
                return sortGroups(groupSums[a], groupSums[b]);
              });
            }
            if (sortSubgroups) {
              subgroupIndex.forEach(function(d, i2) {
                d.sort(function(a, b) {
                  return sortSubgroups(matrix[i2][a], matrix[i2][b]);
                });
              });
            }
            k = (\u03C4 - padding * n) / k;
            x = 0, i = -1;
            while (++i < n) {
              x0 = x, j = -1;
              while (++j < n) {
                var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                subgroups[di + "-" + dj] = {
                  index: di,
                  subindex: dj,
                  startAngle: a0,
                  endAngle: a1,
                  value: v
                };
              }
              groups[di] = {
                index: di,
                startAngle: x0,
                endAngle: x,
                value: groupSums[di]
              };
              x += padding;
            }
            i = -1;
            while (++i < n) {
              j = i - 1;
              while (++j < n) {
                var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
                if (source.value || target.value) {
                  chords.push(source.value < target.value ? {
                    source: target,
                    target: source
                  } : {
                    source,
                    target
                  });
                }
              }
            }
            if (sortChords) resort();
          }
          function resort() {
            chords.sort(function(a, b) {
              return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
            });
          }
          chord.matrix = function(x) {
            if (!arguments.length) return matrix;
            n = (matrix = x) && matrix.length;
            chords = groups = null;
            return chord;
          };
          chord.padding = function(x) {
            if (!arguments.length) return padding;
            padding = x;
            chords = groups = null;
            return chord;
          };
          chord.sortGroups = function(x) {
            if (!arguments.length) return sortGroups;
            sortGroups = x;
            chords = groups = null;
            return chord;
          };
          chord.sortSubgroups = function(x) {
            if (!arguments.length) return sortSubgroups;
            sortSubgroups = x;
            chords = null;
            return chord;
          };
          chord.sortChords = function(x) {
            if (!arguments.length) return sortChords;
            sortChords = x;
            if (chords) resort();
            return chord;
          };
          chord.chords = function() {
            if (!chords) relayout();
            return chords;
          };
          chord.groups = function() {
            if (!groups) relayout();
            return groups;
          };
          return chord;
        };
        d3.layout.force = function() {
          var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [1, 1], drag, alpha, friction = 0.9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = 0.1, theta2 = 0.64, nodes = [], links = [], distances, strengths, charges;
          function repulse(node) {
            return function(quad, x1, _, x2) {
              if (quad.point !== node) {
                var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
                if (dw * dw / theta2 < dn) {
                  if (dn < chargeDistance2) {
                    var k = quad.charge / dn;
                    node.px -= dx * k;
                    node.py -= dy * k;
                  }
                  return true;
                }
                if (quad.point && dn && dn < chargeDistance2) {
                  var k = quad.pointCharge / dn;
                  node.px -= dx * k;
                  node.py -= dy * k;
                }
              }
              return !quad.charge;
            };
          }
          force.tick = function() {
            if ((alpha *= 0.99) < 5e-3) {
              timer = null;
              event.end({
                type: "end",
                alpha: alpha = 0
              });
              return true;
            }
            var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
            for (i = 0; i < m; ++i) {
              o = links[i];
              s = o.source;
              t = o.target;
              x = t.x - s.x;
              y = t.y - s.y;
              if (l = x * x + y * y) {
                l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
                x *= l;
                y *= l;
                t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : 0.5);
                t.y -= y * k;
                s.x += x * (k = 1 - k);
                s.y += y * k;
              }
            }
            if (k = alpha * gravity) {
              x = size[0] / 2;
              y = size[1] / 2;
              i = -1;
              if (k) while (++i < n) {
                o = nodes[i];
                o.x += (x - o.x) * k;
                o.y += (y - o.y) * k;
              }
            }
            if (charge) {
              d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
              i = -1;
              while (++i < n) {
                if (!(o = nodes[i]).fixed) {
                  q.visit(repulse(o));
                }
              }
            }
            i = -1;
            while (++i < n) {
              o = nodes[i];
              if (o.fixed) {
                o.x = o.px;
                o.y = o.py;
              } else {
                o.x -= (o.px - (o.px = o.x)) * friction;
                o.y -= (o.py - (o.py = o.y)) * friction;
              }
            }
            event.tick({
              type: "tick",
              alpha
            });
          };
          force.nodes = function(x) {
            if (!arguments.length) return nodes;
            nodes = x;
            return force;
          };
          force.links = function(x) {
            if (!arguments.length) return links;
            links = x;
            return force;
          };
          force.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return force;
          };
          force.linkDistance = function(x) {
            if (!arguments.length) return linkDistance;
            linkDistance = typeof x === "function" ? x : +x;
            return force;
          };
          force.distance = force.linkDistance;
          force.linkStrength = function(x) {
            if (!arguments.length) return linkStrength;
            linkStrength = typeof x === "function" ? x : +x;
            return force;
          };
          force.friction = function(x) {
            if (!arguments.length) return friction;
            friction = +x;
            return force;
          };
          force.charge = function(x) {
            if (!arguments.length) return charge;
            charge = typeof x === "function" ? x : +x;
            return force;
          };
          force.chargeDistance = function(x) {
            if (!arguments.length) return Math.sqrt(chargeDistance2);
            chargeDistance2 = x * x;
            return force;
          };
          force.gravity = function(x) {
            if (!arguments.length) return gravity;
            gravity = +x;
            return force;
          };
          force.theta = function(x) {
            if (!arguments.length) return Math.sqrt(theta2);
            theta2 = x * x;
            return force;
          };
          force.alpha = function(x) {
            if (!arguments.length) return alpha;
            x = +x;
            if (alpha) {
              if (x > 0) {
                alpha = x;
              } else {
                timer.c = null, timer.t = NaN, timer = null;
                event.end({
                  type: "end",
                  alpha: alpha = 0
                });
              }
            } else if (x > 0) {
              event.start({
                type: "start",
                alpha: alpha = x
              });
              timer = d3_timer(force.tick);
            }
            return force;
          };
          force.start = function() {
            var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
            for (i = 0; i < n; ++i) {
              (o = nodes[i]).index = i;
              o.weight = 0;
            }
            for (i = 0; i < m; ++i) {
              o = links[i];
              if (typeof o.source == "number") o.source = nodes[o.source];
              if (typeof o.target == "number") o.target = nodes[o.target];
              ++o.source.weight;
              ++o.target.weight;
            }
            for (i = 0; i < n; ++i) {
              o = nodes[i];
              if (isNaN(o.x)) o.x = position("x", w);
              if (isNaN(o.y)) o.y = position("y", h);
              if (isNaN(o.px)) o.px = o.x;
              if (isNaN(o.py)) o.py = o.y;
            }
            distances = [];
            if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i);
            else for (i = 0; i < m; ++i) distances[i] = linkDistance;
            strengths = [];
            if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i);
            else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
            charges = [];
            if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i);
            else for (i = 0; i < n; ++i) charges[i] = charge;
            function position(dimension, size2) {
              if (!neighbors) {
                neighbors = new Array(n);
                for (j = 0; j < n; ++j) {
                  neighbors[j] = [];
                }
                for (j = 0; j < m; ++j) {
                  var o2 = links[j];
                  neighbors[o2.source.index].push(o2.target);
                  neighbors[o2.target.index].push(o2.source);
                }
              }
              var candidates = neighbors[i], j = -1, l = candidates.length, x;
              while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
              return Math.random() * size2;
            }
            return force.resume();
          };
          force.resume = function() {
            return force.alpha(0.1);
          };
          force.stop = function() {
            return force.alpha(0);
          };
          force.drag = function() {
            if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
            if (!arguments.length) return drag;
            this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
          };
          function dragmove(d) {
            d.px = d3.event.x, d.py = d3.event.y;
            force.resume();
          }
          return d3.rebind(force, event, "on");
        };
        function d3_layout_forceDragstart(d) {
          d.fixed |= 2;
        }
        function d3_layout_forceDragend(d) {
          d.fixed &= ~6;
        }
        function d3_layout_forceMouseover(d) {
          d.fixed |= 4;
          d.px = d.x, d.py = d.y;
        }
        function d3_layout_forceMouseout(d) {
          d.fixed &= ~4;
        }
        function d3_layout_forceAccumulate(quad, alpha, charges) {
          var cx = 0, cy = 0;
          quad.charge = 0;
          if (!quad.leaf) {
            var nodes = quad.nodes, n = nodes.length, i = -1, c;
            while (++i < n) {
              c = nodes[i];
              if (c == null) continue;
              d3_layout_forceAccumulate(c, alpha, charges);
              quad.charge += c.charge;
              cx += c.charge * c.cx;
              cy += c.charge * c.cy;
            }
          }
          if (quad.point) {
            if (!quad.leaf) {
              quad.point.x += Math.random() - 0.5;
              quad.point.y += Math.random() - 0.5;
            }
            var k = alpha * charges[quad.point.index];
            quad.charge += quad.pointCharge = k;
            cx += k * quad.point.x;
            cy += k * quad.point.y;
          }
          quad.cx = cx / quad.charge;
          quad.cy = cy / quad.charge;
        }
        var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
        d3.layout.hierarchy = function() {
          var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
          function hierarchy(root) {
            var stack = [root], nodes = [], node;
            root.depth = 0;
            while ((node = stack.pop()) != null) {
              nodes.push(node);
              if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
                var n, childs, child;
                while (--n >= 0) {
                  stack.push(child = childs[n]);
                  child.parent = node;
                  child.depth = node.depth + 1;
                }
                if (value) node.value = 0;
                node.children = childs;
              } else {
                if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
                delete node.children;
              }
            }
            d3_layout_hierarchyVisitAfter(root, function(node2) {
              var childs2, parent;
              if (sort && (childs2 = node2.children)) childs2.sort(sort);
              if (value && (parent = node2.parent)) parent.value += node2.value;
            });
            return nodes;
          }
          hierarchy.sort = function(x) {
            if (!arguments.length) return sort;
            sort = x;
            return hierarchy;
          };
          hierarchy.children = function(x) {
            if (!arguments.length) return children;
            children = x;
            return hierarchy;
          };
          hierarchy.value = function(x) {
            if (!arguments.length) return value;
            value = x;
            return hierarchy;
          };
          hierarchy.revalue = function(root) {
            if (value) {
              d3_layout_hierarchyVisitBefore(root, function(node) {
                if (node.children) node.value = 0;
              });
              d3_layout_hierarchyVisitAfter(root, function(node) {
                var parent;
                if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
                if (parent = node.parent) parent.value += node.value;
              });
            }
            return root;
          };
          return hierarchy;
        };
        function d3_layout_hierarchyRebind(object, hierarchy) {
          d3.rebind(object, hierarchy, "sort", "children", "value");
          object.nodes = object;
          object.links = d3_layout_hierarchyLinks;
          return object;
        }
        function d3_layout_hierarchyVisitBefore(node, callback) {
          var nodes = [node];
          while ((node = nodes.pop()) != null) {
            callback(node);
            if ((children = node.children) && (n = children.length)) {
              var n, children;
              while (--n >= 0) nodes.push(children[n]);
            }
          }
        }
        function d3_layout_hierarchyVisitAfter(node, callback) {
          var nodes = [node], nodes2 = [];
          while ((node = nodes.pop()) != null) {
            nodes2.push(node);
            if ((children = node.children) && (n = children.length)) {
              var i = -1, n, children;
              while (++i < n) nodes.push(children[i]);
            }
          }
          while ((node = nodes2.pop()) != null) {
            callback(node);
          }
        }
        function d3_layout_hierarchyChildren(d) {
          return d.children;
        }
        function d3_layout_hierarchyValue(d) {
          return d.value;
        }
        function d3_layout_hierarchySort(a, b) {
          return b.value - a.value;
        }
        function d3_layout_hierarchyLinks(nodes) {
          return d3.merge(nodes.map(function(parent) {
            return (parent.children || []).map(function(child) {
              return {
                source: parent,
                target: child
              };
            });
          }));
        }
        d3.layout.partition = function() {
          var hierarchy = d3.layout.hierarchy(), size = [1, 1];
          function position(node, x, dx, dy) {
            var children = node.children;
            node.x = x;
            node.y = node.depth * dy;
            node.dx = dx;
            node.dy = dy;
            if (children && (n = children.length)) {
              var i = -1, n, c, d;
              dx = node.value ? dx / node.value : 0;
              while (++i < n) {
                position(c = children[i], x, d = c.value * dx, dy);
                x += d;
              }
            }
          }
          function depth(node) {
            var children = node.children, d = 0;
            if (children && (n = children.length)) {
              var i = -1, n;
              while (++i < n) d = Math.max(d, depth(children[i]));
            }
            return 1 + d;
          }
          function partition(d, i) {
            var nodes = hierarchy.call(this, d, i);
            position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
            return nodes;
          }
          partition.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return partition;
          };
          return d3_layout_hierarchyRebind(partition, hierarchy);
        };
        d3.layout.pie = function() {
          var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = \u03C4, padAngle = 0;
          function pie(data) {
            var n = data.length, values = data.map(function(d, i) {
              return +value.call(pie, d, i);
            }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
            if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
              return values[j] - values[i];
            } : function(i, j) {
              return sort(data[i], data[j]);
            });
            index.forEach(function(i) {
              arcs[i] = {
                data: data[i],
                value: v = values[i],
                startAngle: a,
                endAngle: a += v * k + pa,
                padAngle: p
              };
            });
            return arcs;
          }
          pie.value = function(_) {
            if (!arguments.length) return value;
            value = _;
            return pie;
          };
          pie.sort = function(_) {
            if (!arguments.length) return sort;
            sort = _;
            return pie;
          };
          pie.startAngle = function(_) {
            if (!arguments.length) return startAngle;
            startAngle = _;
            return pie;
          };
          pie.endAngle = function(_) {
            if (!arguments.length) return endAngle;
            endAngle = _;
            return pie;
          };
          pie.padAngle = function(_) {
            if (!arguments.length) return padAngle;
            padAngle = _;
            return pie;
          };
          return pie;
        };
        var d3_layout_pieSortByValue = {};
        d3.layout.stack = function() {
          var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
          function stack(data, index) {
            if (!(n = data.length)) return data;
            var series = data.map(function(d, i2) {
              return values.call(stack, d, i2);
            });
            var points = series.map(function(d) {
              return d.map(function(v, i2) {
                return [x.call(stack, v, i2), y.call(stack, v, i2)];
              });
            });
            var orders = order.call(stack, points, index);
            series = d3.permute(series, orders);
            points = d3.permute(points, orders);
            var offsets = offset.call(stack, points, index);
            var m = series[0].length, n, i, j, o;
            for (j = 0; j < m; ++j) {
              out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
              for (i = 1; i < n; ++i) {
                out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
              }
            }
            return data;
          }
          stack.values = function(x2) {
            if (!arguments.length) return values;
            values = x2;
            return stack;
          };
          stack.order = function(x2) {
            if (!arguments.length) return order;
            order = typeof x2 === "function" ? x2 : d3_layout_stackOrders.get(x2) || d3_layout_stackOrderDefault;
            return stack;
          };
          stack.offset = function(x2) {
            if (!arguments.length) return offset;
            offset = typeof x2 === "function" ? x2 : d3_layout_stackOffsets.get(x2) || d3_layout_stackOffsetZero;
            return stack;
          };
          stack.x = function(z) {
            if (!arguments.length) return x;
            x = z;
            return stack;
          };
          stack.y = function(z) {
            if (!arguments.length) return y;
            y = z;
            return stack;
          };
          stack.out = function(z) {
            if (!arguments.length) return out;
            out = z;
            return stack;
          };
          return stack;
        };
        function d3_layout_stackX(d) {
          return d.x;
        }
        function d3_layout_stackY(d) {
          return d.y;
        }
        function d3_layout_stackOut(d, y0, y) {
          d.y0 = y0;
          d.y = y;
        }
        var d3_layout_stackOrders = d3.map({
          "inside-out": function(data) {
            var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
              return max[a] - max[b];
            }), top = 0, bottom = 0, tops = [], bottoms = [];
            for (i = 0; i < n; ++i) {
              j = index[i];
              if (top < bottom) {
                top += sums[j];
                tops.push(j);
              } else {
                bottom += sums[j];
                bottoms.push(j);
              }
            }
            return bottoms.reverse().concat(tops);
          },
          reverse: function(data) {
            return d3.range(data.length).reverse();
          },
          "default": d3_layout_stackOrderDefault
        });
        var d3_layout_stackOffsets = d3.map({
          silhouette: function(data) {
            var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
              for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
              if (o > max) max = o;
              sums.push(o);
            }
            for (j = 0; j < m; ++j) {
              y0[j] = (max - sums[j]) / 2;
            }
            return y0;
          },
          wiggle: function(data) {
            var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
            y0[0] = o = o0 = 0;
            for (j = 1; j < m; ++j) {
              for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
              for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
                for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                  s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
                }
                s2 += s3 * data[i][j][1];
              }
              y0[j] = o -= s1 ? s2 / s1 * dx : 0;
              if (o < o0) o0 = o;
            }
            for (j = 0; j < m; ++j) y0[j] -= o0;
            return y0;
          },
          expand: function(data) {
            var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
              for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
              if (o) for (i = 0; i < n; i++) data[i][j][1] /= o;
              else for (i = 0; i < n; i++) data[i][j][1] = k;
            }
            for (j = 0; j < m; ++j) y0[j] = 0;
            return y0;
          },
          zero: d3_layout_stackOffsetZero
        });
        function d3_layout_stackOrderDefault(data) {
          return d3.range(data.length);
        }
        function d3_layout_stackOffsetZero(data) {
          var j = -1, m = data[0].length, y0 = [];
          while (++j < m) y0[j] = 0;
          return y0;
        }
        function d3_layout_stackMaxIndex(array) {
          var i = 1, j = 0, v = array[0][1], k, n = array.length;
          for (; i < n; ++i) {
            if ((k = array[i][1]) > v) {
              j = i;
              v = k;
            }
          }
          return j;
        }
        function d3_layout_stackReduceSum(d) {
          return d.reduce(d3_layout_stackSum, 0);
        }
        function d3_layout_stackSum(p, d) {
          return p + d[1];
        }
        d3.layout.histogram = function() {
          var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
          function histogram(data, i) {
            var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
            while (++i < m) {
              bin = bins[i] = [];
              bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
              bin.y = 0;
            }
            if (m > 0) {
              i = -1;
              while (++i < n) {
                x = values[i];
                if (x >= range[0] && x <= range[1]) {
                  bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                  bin.y += k;
                  bin.push(data[i]);
                }
              }
            }
            return bins;
          }
          histogram.value = function(x) {
            if (!arguments.length) return valuer;
            valuer = x;
            return histogram;
          };
          histogram.range = function(x) {
            if (!arguments.length) return ranger;
            ranger = d3_functor(x);
            return histogram;
          };
          histogram.bins = function(x) {
            if (!arguments.length) return binner;
            binner = typeof x === "number" ? function(range) {
              return d3_layout_histogramBinFixed(range, x);
            } : d3_functor(x);
            return histogram;
          };
          histogram.frequency = function(x) {
            if (!arguments.length) return frequency;
            frequency = !!x;
            return histogram;
          };
          return histogram;
        };
        function d3_layout_histogramBinSturges(range, values) {
          return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
        }
        function d3_layout_histogramBinFixed(range, n) {
          var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
          while (++x <= n) f[x] = m * x + b;
          return f;
        }
        function d3_layout_histogramRange(values) {
          return [d3.min(values), d3.max(values)];
        }
        d3.layout.pack = function() {
          var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [1, 1], radius;
          function pack(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
              return radius;
            };
            root.x = root.y = 0;
            d3_layout_hierarchyVisitAfter(root, function(d2) {
              d2.r = +r(d2.value);
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            if (padding) {
              var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
              d3_layout_hierarchyVisitAfter(root, function(d2) {
                d2.r += dr;
              });
              d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
              d3_layout_hierarchyVisitAfter(root, function(d2) {
                d2.r -= dr;
              });
            }
            d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
            return nodes;
          }
          pack.size = function(_) {
            if (!arguments.length) return size;
            size = _;
            return pack;
          };
          pack.radius = function(_) {
            if (!arguments.length) return radius;
            radius = _ == null || typeof _ === "function" ? _ : +_;
            return pack;
          };
          pack.padding = function(_) {
            if (!arguments.length) return padding;
            padding = +_;
            return pack;
          };
          return d3_layout_hierarchyRebind(pack, hierarchy);
        };
        function d3_layout_packSort(a, b) {
          return a.value - b.value;
        }
        function d3_layout_packInsert(a, b) {
          var c = a._pack_next;
          a._pack_next = b;
          b._pack_prev = a;
          b._pack_next = c;
          c._pack_prev = b;
        }
        function d3_layout_packSplice(a, b) {
          a._pack_next = b;
          b._pack_prev = a;
        }
        function d3_layout_packIntersects(a, b) {
          var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
          return 0.999 * dr * dr > dx * dx + dy * dy;
        }
        function d3_layout_packSiblings(node) {
          if (!(nodes = node.children) || !(n = nodes.length)) return;
          var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
          function bound(node2) {
            xMin = Math.min(node2.x - node2.r, xMin);
            xMax = Math.max(node2.x + node2.r, xMax);
            yMin = Math.min(node2.y - node2.r, yMin);
            yMax = Math.max(node2.y + node2.r, yMax);
          }
          nodes.forEach(d3_layout_packLink);
          a = nodes[0];
          a.x = -a.r;
          a.y = 0;
          bound(a);
          if (n > 1) {
            b = nodes[1];
            b.x = b.r;
            b.y = 0;
            bound(b);
            if (n > 2) {
              c = nodes[2];
              d3_layout_packPlace(a, b, c);
              bound(c);
              d3_layout_packInsert(a, c);
              a._pack_prev = c;
              d3_layout_packInsert(c, b);
              b = a._pack_next;
              for (i = 3; i < n; i++) {
                d3_layout_packPlace(a, b, c = nodes[i]);
                var isect = 0, s1 = 1, s2 = 1;
                for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                  if (d3_layout_packIntersects(j, c)) {
                    isect = 1;
                    break;
                  }
                }
                if (isect == 1) {
                  for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                    if (d3_layout_packIntersects(k, c)) {
                      break;
                    }
                  }
                }
                if (isect) {
                  if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j);
                  else d3_layout_packSplice(a = k, b);
                  i--;
                } else {
                  d3_layout_packInsert(a, c);
                  b = c;
                  bound(c);
                }
              }
            }
          }
          var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
          for (i = 0; i < n; i++) {
            c = nodes[i];
            c.x -= cx;
            c.y -= cy;
            cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
          }
          node.r = cr;
          nodes.forEach(d3_layout_packUnlink);
        }
        function d3_layout_packLink(node) {
          node._pack_next = node._pack_prev = node;
        }
        function d3_layout_packUnlink(node) {
          delete node._pack_next;
          delete node._pack_prev;
        }
        function d3_layout_packTransform(node, x, y, k) {
          var children = node.children;
          node.x = x += k * node.x;
          node.y = y += k * node.y;
          node.r *= k;
          if (children) {
            var i = -1, n = children.length;
            while (++i < n) d3_layout_packTransform(children[i], x, y, k);
          }
        }
        function d3_layout_packPlace(a, b, c) {
          var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
          if (db && (dx || dy)) {
            var da = b.r + c.r, dc = dx * dx + dy * dy;
            da *= da;
            db *= db;
            var x = 0.5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
            c.x = a.x + x * dx + y * dy;
            c.y = a.y + x * dy - y * dx;
          } else {
            c.x = a.x + db;
            c.y = a.y;
          }
        }
        d3.layout.tree = function() {
          var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [1, 1], nodeSize = null;
          function tree(d, i) {
            var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
            d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
            d3_layout_hierarchyVisitBefore(root1, secondWalk);
            if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode);
            else {
              var left = root0, right = root0, bottom = root0;
              d3_layout_hierarchyVisitBefore(root0, function(node) {
                if (node.x < left.x) left = node;
                if (node.x > right.x) right = node;
                if (node.depth > bottom.depth) bottom = node;
              });
              var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
              d3_layout_hierarchyVisitBefore(root0, function(node) {
                node.x = (node.x + tx) * kx;
                node.y = node.depth * ky;
              });
            }
            return nodes;
          }
          function wrapTree(root0) {
            var root1 = {
              A: null,
              children: [root0]
            }, queue = [root1], node1;
            while ((node1 = queue.pop()) != null) {
              for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
                queue.push((children[i] = child = {
                  _: children[i],
                  parent: node1,
                  children: (child = children[i].children) && child.slice() || [],
                  A: null,
                  a: null,
                  z: 0,
                  m: 0,
                  c: 0,
                  s: 0,
                  t: null,
                  i
                }).a = child);
              }
            }
            return root1.children[0];
          }
          function firstWalk(v) {
            var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
            if (children.length) {
              d3_layout_treeShift(v);
              var midpoint = (children[0].z + children[children.length - 1].z) / 2;
              if (w) {
                v.z = w.z + separation(v._, w._);
                v.m = v.z - midpoint;
              } else {
                v.z = midpoint;
              }
            } else if (w) {
              v.z = w.z + separation(v._, w._);
            }
            v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
          }
          function secondWalk(v) {
            v._.x = v.z + v.parent.m;
            v.m += v.parent.m;
          }
          function apportion(v, w, ancestor) {
            if (w) {
              var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
              while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
                vom = d3_layout_treeLeft(vom);
                vop = d3_layout_treeRight(vop);
                vop.a = v;
                shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                if (shift > 0) {
                  d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                  sip += shift;
                  sop += shift;
                }
                sim += vim.m;
                sip += vip.m;
                som += vom.m;
                sop += vop.m;
              }
              if (vim && !d3_layout_treeRight(vop)) {
                vop.t = vim;
                vop.m += sim - sop;
              }
              if (vip && !d3_layout_treeLeft(vom)) {
                vom.t = vip;
                vom.m += sip - som;
                ancestor = v;
              }
            }
            return ancestor;
          }
          function sizeNode(node) {
            node.x *= size[0];
            node.y = node.depth * size[1];
          }
          tree.separation = function(x) {
            if (!arguments.length) return separation;
            separation = x;
            return tree;
          };
          tree.size = function(x) {
            if (!arguments.length) return nodeSize ? null : size;
            nodeSize = (size = x) == null ? sizeNode : null;
            return tree;
          };
          tree.nodeSize = function(x) {
            if (!arguments.length) return nodeSize ? size : null;
            nodeSize = (size = x) == null ? null : sizeNode;
            return tree;
          };
          return d3_layout_hierarchyRebind(tree, hierarchy);
        };
        function d3_layout_treeSeparation(a, b) {
          return a.parent == b.parent ? 1 : 2;
        }
        function d3_layout_treeLeft(v) {
          var children = v.children;
          return children.length ? children[0] : v.t;
        }
        function d3_layout_treeRight(v) {
          var children = v.children, n;
          return (n = children.length) ? children[n - 1] : v.t;
        }
        function d3_layout_treeMove(wm, wp, shift) {
          var change = shift / (wp.i - wm.i);
          wp.c -= change;
          wp.s += shift;
          wm.c += change;
          wp.z += shift;
          wp.m += shift;
        }
        function d3_layout_treeShift(v) {
          var shift = 0, change = 0, children = v.children, i = children.length, w;
          while (--i >= 0) {
            w = children[i];
            w.z += shift;
            w.m += shift;
            shift += w.s + (change += w.c);
          }
        }
        function d3_layout_treeAncestor(vim, v, ancestor) {
          return vim.a.parent === v.parent ? vim.a : ancestor;
        }
        d3.layout.cluster = function() {
          var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [1, 1], nodeSize = false;
          function cluster(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
            d3_layout_hierarchyVisitAfter(root, function(node) {
              var children = node.children;
              if (children && children.length) {
                node.x = d3_layout_clusterX(children);
                node.y = d3_layout_clusterY(children);
              } else {
                node.x = previousNode ? x += separation(node, previousNode) : 0;
                node.y = 0;
                previousNode = node;
              }
            });
            var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
            d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
              node.x = (node.x - root.x) * size[0];
              node.y = (root.y - node.y) * size[1];
            } : function(node) {
              node.x = (node.x - x0) / (x1 - x0) * size[0];
              node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
            });
            return nodes;
          }
          cluster.separation = function(x) {
            if (!arguments.length) return separation;
            separation = x;
            return cluster;
          };
          cluster.size = function(x) {
            if (!arguments.length) return nodeSize ? null : size;
            nodeSize = (size = x) == null;
            return cluster;
          };
          cluster.nodeSize = function(x) {
            if (!arguments.length) return nodeSize ? size : null;
            nodeSize = (size = x) != null;
            return cluster;
          };
          return d3_layout_hierarchyRebind(cluster, hierarchy);
        };
        function d3_layout_clusterY(children) {
          return 1 + d3.max(children, function(child) {
            return child.y;
          });
        }
        function d3_layout_clusterX(children) {
          return children.reduce(function(x, child) {
            return x + child.x;
          }, 0) / children.length;
        }
        function d3_layout_clusterLeft(node) {
          var children = node.children;
          return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
        }
        function d3_layout_clusterRight(node) {
          var children = node.children, n;
          return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
        }
        d3.layout.treemap = function() {
          var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [1, 1], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = 0.5 * (1 + Math.sqrt(5));
          function scale(children, k) {
            var i = -1, n = children.length, child, area;
            while (++i < n) {
              area = (child = children[i]).value * (k < 0 ? 0 : k);
              child.area = isNaN(area) || area <= 0 ? 0 : area;
            }
          }
          function squarify(node) {
            var children = node.children;
            if (children && children.length) {
              var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
              scale(remaining, rect.dx * rect.dy / node.value);
              row.area = 0;
              while ((n = remaining.length) > 0) {
                row.push(child = remaining[n - 1]);
                row.area += child.area;
                if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                  remaining.pop();
                  best = score;
                } else {
                  row.area -= row.pop().area;
                  position(row, u, rect, false);
                  u = Math.min(rect.dx, rect.dy);
                  row.length = row.area = 0;
                  best = Infinity;
                }
              }
              if (row.length) {
                position(row, u, rect, true);
                row.length = row.area = 0;
              }
              children.forEach(squarify);
            }
          }
          function stickify(node) {
            var children = node.children;
            if (children && children.length) {
              var rect = pad(node), remaining = children.slice(), child, row = [];
              scale(remaining, rect.dx * rect.dy / node.value);
              row.area = 0;
              while (child = remaining.pop()) {
                row.push(child);
                row.area += child.area;
                if (child.z != null) {
                  position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                  row.length = row.area = 0;
                }
              }
              children.forEach(stickify);
            }
          }
          function worst(row, u) {
            var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
            while (++i < n) {
              if (!(r = row[i].area)) continue;
              if (r < rmin) rmin = r;
              if (r > rmax) rmax = r;
            }
            s *= s;
            u *= u;
            return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
          }
          function position(row, u, rect, flush) {
            var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
            if (u == rect.dx) {
              if (flush || v > rect.dy) v = rect.dy;
              while (++i < n) {
                o = row[i];
                o.x = x;
                o.y = y;
                o.dy = v;
                x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
              }
              o.z = true;
              o.dx += rect.x + rect.dx - x;
              rect.y += v;
              rect.dy -= v;
            } else {
              if (flush || v > rect.dx) v = rect.dx;
              while (++i < n) {
                o = row[i];
                o.x = x;
                o.y = y;
                o.dx = v;
                y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
              }
              o.z = false;
              o.dy += rect.y + rect.dy - y;
              rect.x += v;
              rect.dx -= v;
            }
          }
          function treemap(d) {
            var nodes = stickies || hierarchy(d), root = nodes[0];
            root.x = root.y = 0;
            if (root.value) root.dx = size[0], root.dy = size[1];
            else root.dx = root.dy = 0;
            if (stickies) hierarchy.revalue(root);
            scale([root], root.dx * root.dy / root.value);
            (stickies ? stickify : squarify)(root);
            if (sticky) stickies = nodes;
            return nodes;
          }
          treemap.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return treemap;
          };
          treemap.padding = function(x) {
            if (!arguments.length) return padding;
            function padFunction(node) {
              var p = x.call(treemap, node, node.depth);
              return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [p, p, p, p] : p);
            }
            function padConstant(node) {
              return d3_layout_treemapPad(node, x);
            }
            var type;
            pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [x, x, x, x], padConstant) : padConstant;
            return treemap;
          };
          treemap.round = function(x) {
            if (!arguments.length) return round != Number;
            round = x ? Math.round : Number;
            return treemap;
          };
          treemap.sticky = function(x) {
            if (!arguments.length) return sticky;
            sticky = x;
            stickies = null;
            return treemap;
          };
          treemap.ratio = function(x) {
            if (!arguments.length) return ratio;
            ratio = x;
            return treemap;
          };
          treemap.mode = function(x) {
            if (!arguments.length) return mode;
            mode = x + "";
            return treemap;
          };
          return d3_layout_hierarchyRebind(treemap, hierarchy);
        };
        function d3_layout_treemapPadNull(node) {
          return {
            x: node.x,
            y: node.y,
            dx: node.dx,
            dy: node.dy
          };
        }
        function d3_layout_treemapPad(node, padding) {
          var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
          if (dx < 0) {
            x += dx / 2;
            dx = 0;
          }
          if (dy < 0) {
            y += dy / 2;
            dy = 0;
          }
          return {
            x,
            y,
            dx,
            dy
          };
        }
        d3.random = {
          normal: function(mu, sigma) {
            var n = arguments.length;
            if (n < 2) sigma = 1;
            if (n < 1) mu = 0;
            return function() {
              var x, y, r;
              do {
                x = Math.random() * 2 - 1;
                y = Math.random() * 2 - 1;
                r = x * x + y * y;
              } while (!r || r > 1);
              return mu + sigma * x * Math.sqrt(-2 * Math.log(r) / r);
            };
          },
          logNormal: function() {
            var random = d3.random.normal.apply(d3, arguments);
            return function() {
              return Math.exp(random());
            };
          },
          bates: function(m) {
            var random = d3.random.irwinHall(m);
            return function() {
              return random() / m;
            };
          },
          irwinHall: function(m) {
            return function() {
              for (var s = 0, j = 0; j < m; j++) s += Math.random();
              return s;
            };
          }
        };
        d3.scale = {};
        function d3_scaleExtent(domain) {
          var start = domain[0], stop = domain[domain.length - 1];
          return start < stop ? [start, stop] : [stop, start];
        }
        function d3_scaleRange(scale) {
          return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
        }
        function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
          var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
          return function(x) {
            return i(u(x));
          };
        }
        function d3_scale_nice(domain, nice) {
          var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
          if (x1 < x0) {
            dx = i0, i0 = i1, i1 = dx;
            dx = x0, x0 = x1, x1 = dx;
          }
          domain[i0] = nice.floor(x0);
          domain[i1] = nice.ceil(x1);
          return domain;
        }
        function d3_scale_niceStep(step) {
          return step ? {
            floor: function(x) {
              return Math.floor(x / step) * step;
            },
            ceil: function(x) {
              return Math.ceil(x / step) * step;
            }
          } : d3_scale_niceIdentity;
        }
        var d3_scale_niceIdentity = {
          floor: d3_identity,
          ceil: d3_identity
        };
        function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
          var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
          if (domain[k] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
          }
          while (++j <= k) {
            u.push(uninterpolate(domain[j - 1], domain[j]));
            i.push(interpolate(range[j - 1], range[j]));
          }
          return function(x) {
            var j2 = d3.bisect(domain, x, 1, k) - 1;
            return i[j2](u[j2](x));
          };
        }
        d3.scale.linear = function() {
          return d3_scale_linear([0, 1], [0, 1], d3_interpolate, false);
        };
        function d3_scale_linear(domain, range, interpolate, clamp) {
          var output, input;
          function rescale() {
            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
            output = linear(domain, range, uninterpolate, interpolate);
            input = linear(range, domain, uninterpolate, d3_interpolate);
            return scale;
          }
          function scale(x) {
            return output(x);
          }
          scale.invert = function(y) {
            return input(y);
          };
          scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(Number);
            return rescale();
          };
          scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
          };
          scale.rangeRound = function(x) {
            return scale.range(x).interpolate(d3_interpolateRound);
          };
          scale.clamp = function(x) {
            if (!arguments.length) return clamp;
            clamp = x;
            return rescale();
          };
          scale.interpolate = function(x) {
            if (!arguments.length) return interpolate;
            interpolate = x;
            return rescale();
          };
          scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
          };
          scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
          };
          scale.nice = function(m) {
            d3_scale_linearNice(domain, m);
            return rescale();
          };
          scale.copy = function() {
            return d3_scale_linear(domain, range, interpolate, clamp);
          };
          return rescale();
        }
        function d3_scale_linearRebind(scale, linear) {
          return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
        }
        function d3_scale_linearNice(domain, m) {
          d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
          d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
          return domain;
        }
        function d3_scale_linearTickRange(domain, m) {
          if (m == null) m = 10;
          var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
          if (err <= 0.15) step *= 10;
          else if (err <= 0.35) step *= 5;
          else if (err <= 0.75) step *= 2;
          extent[0] = Math.ceil(extent[0] / step) * step;
          extent[1] = Math.floor(extent[1] / step) * step + step * 0.5;
          extent[2] = step;
          return extent;
        }
        function d3_scale_linearTicks(domain, m) {
          return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
        }
        var d3_scale_linearFormatSignificant = {
          s: 1,
          g: 1,
          p: 1,
          r: 1,
          e: 1
        };
        function d3_scale_linearPrecision(value) {
          return -Math.floor(Math.log(value) / Math.LN10 + 0.01);
        }
        function d3_scale_linearFormatPrecision(type, range) {
          var p = d3_scale_linearPrecision(range[2]);
          return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
        }
        d3.scale.log = function() {
          return d3_scale_log(d3.scale.linear().domain([0, 1]), 10, true, [1, 10]);
        };
        function d3_scale_log(linear, base, positive, domain) {
          function log(x) {
            return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
          }
          function pow(x) {
            return positive ? Math.pow(base, x) : -Math.pow(base, -x);
          }
          function scale(x) {
            return linear(log(x));
          }
          scale.invert = function(x) {
            return pow(linear.invert(x));
          };
          scale.domain = function(x) {
            if (!arguments.length) return domain;
            positive = x[0] >= 0;
            linear.domain((domain = x.map(Number)).map(log));
            return scale;
          };
          scale.base = function(_) {
            if (!arguments.length) return base;
            base = +_;
            linear.domain(domain.map(log));
            return scale;
          };
          scale.nice = function() {
            var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
            linear.domain(niced);
            domain = niced.map(pow);
            return scale;
          };
          scale.ticks = function() {
            var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
            if (isFinite(j - i)) {
              if (positive) {
                for (; i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
                ticks.push(pow(i));
              } else {
                ticks.push(pow(i));
                for (; i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
              }
              for (i = 0; ticks[i] < u; i++) {
              }
              for (j = ticks.length; ticks[j - 1] > v; j--) {
              }
              ticks = ticks.slice(i, j);
            }
            return ticks;
          };
          scale.copy = function() {
            return d3_scale_log(linear.copy(), base, positive, domain);
          };
          return d3_scale_linearRebind(scale, linear);
        }
        var d3_scale_logNiceNegative = {
          floor: function(x) {
            return -Math.ceil(-x);
          },
          ceil: function(x) {
            return -Math.floor(-x);
          }
        };
        d3.scale.pow = function() {
          return d3_scale_pow(d3.scale.linear(), 1, [0, 1]);
        };
        function d3_scale_pow(linear, exponent, domain) {
          var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
          function scale(x) {
            return linear(powp(x));
          }
          scale.invert = function(x) {
            return powb(linear.invert(x));
          };
          scale.domain = function(x) {
            if (!arguments.length) return domain;
            linear.domain((domain = x.map(Number)).map(powp));
            return scale;
          };
          scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
          };
          scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
          };
          scale.nice = function(m) {
            return scale.domain(d3_scale_linearNice(domain, m));
          };
          scale.exponent = function(x) {
            if (!arguments.length) return exponent;
            powp = d3_scale_powPow(exponent = x);
            powb = d3_scale_powPow(1 / exponent);
            linear.domain(domain.map(powp));
            return scale;
          };
          scale.copy = function() {
            return d3_scale_pow(linear.copy(), exponent, domain);
          };
          return d3_scale_linearRebind(scale, linear);
        }
        function d3_scale_powPow(e) {
          return function(x) {
            return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
          };
        }
        d3.scale.sqrt = function() {
          return d3.scale.pow().exponent(0.5);
        };
        d3.scale.ordinal = function() {
          return d3_scale_ordinal([], {
            t: "range",
            a: [[]]
          });
        };
        function d3_scale_ordinal(domain, ranger) {
          var index, range, rangeBand;
          function scale(x) {
            return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
          }
          function steps(start, step) {
            return d3.range(domain.length).map(function(i) {
              return start + step * i;
            });
          }
          scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = [];
            index = new d3_Map();
            var i = -1, n = x.length, xi;
            while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
            return scale[ranger.t].apply(scale, ranger.a);
          };
          scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            rangeBand = 0;
            ranger = {
              t: "range",
              a: arguments
            };
            return scale;
          };
          scale.rangePoints = function(x, padding) {
            if (arguments.length < 2) padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 0) : (stop - start) / (domain.length - 1 + padding);
            range = steps(start + step * padding / 2, step);
            rangeBand = 0;
            ranger = {
              t: "rangePoints",
              a: arguments
            };
            return scale;
          };
          scale.rangeRoundPoints = function(x, padding) {
            if (arguments.length < 2) padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 0) : (stop - start) / (domain.length - 1 + padding) | 0;
            range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
            rangeBand = 0;
            ranger = {
              t: "rangeRoundPoints",
              a: arguments
            };
            return scale;
          };
          scale.rangeBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
            range = steps(start + step * outerPadding, step);
            if (reverse) range.reverse();
            rangeBand = step * (1 - padding);
            ranger = {
              t: "rangeBands",
              a: arguments
            };
            return scale;
          };
          scale.rangeRoundBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
            range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
            if (reverse) range.reverse();
            rangeBand = Math.round(step * (1 - padding));
            ranger = {
              t: "rangeRoundBands",
              a: arguments
            };
            return scale;
          };
          scale.rangeBand = function() {
            return rangeBand;
          };
          scale.rangeExtent = function() {
            return d3_scaleExtent(ranger.a[0]);
          };
          scale.copy = function() {
            return d3_scale_ordinal(domain, ranger);
          };
          return scale.domain(domain);
        }
        d3.scale.category10 = function() {
          return d3.scale.ordinal().range(d3_category10);
        };
        d3.scale.category20 = function() {
          return d3.scale.ordinal().range(d3_category20);
        };
        d3.scale.category20b = function() {
          return d3.scale.ordinal().range(d3_category20b);
        };
        d3.scale.category20c = function() {
          return d3.scale.ordinal().range(d3_category20c);
        };
        var d3_category10 = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(d3_rgbString);
        var d3_category20 = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(d3_rgbString);
        var d3_category20b = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(d3_rgbString);
        var d3_category20c = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(d3_rgbString);
        d3.scale.quantile = function() {
          return d3_scale_quantile([], []);
        };
        function d3_scale_quantile(domain, range) {
          var thresholds;
          function rescale() {
            var k = 0, q = range.length;
            thresholds = [];
            while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
            return scale;
          }
          function scale(x) {
            if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
          }
          scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
            return rescale();
          };
          scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
          };
          scale.quantiles = function() {
            return thresholds;
          };
          scale.invertExtent = function(y) {
            y = range.indexOf(y);
            return y < 0 ? [NaN, NaN] : [y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1]];
          };
          scale.copy = function() {
            return d3_scale_quantile(domain, range);
          };
          return rescale();
        }
        d3.scale.quantize = function() {
          return d3_scale_quantize(0, 1, [0, 1]);
        };
        function d3_scale_quantize(x0, x1, range) {
          var kx, i;
          function scale(x) {
            return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
          }
          function rescale() {
            kx = range.length / (x1 - x0);
            i = range.length - 1;
            return scale;
          }
          scale.domain = function(x) {
            if (!arguments.length) return [x0, x1];
            x0 = +x[0];
            x1 = +x[x.length - 1];
            return rescale();
          };
          scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
          };
          scale.invertExtent = function(y) {
            y = range.indexOf(y);
            y = y < 0 ? NaN : y / kx + x0;
            return [y, y + 1 / kx];
          };
          scale.copy = function() {
            return d3_scale_quantize(x0, x1, range);
          };
          return rescale();
        }
        d3.scale.threshold = function() {
          return d3_scale_threshold([0.5], [0, 1]);
        };
        function d3_scale_threshold(domain, range) {
          function scale(x) {
            if (x <= x) return range[d3.bisect(domain, x)];
          }
          scale.domain = function(_) {
            if (!arguments.length) return domain;
            domain = _;
            return scale;
          };
          scale.range = function(_) {
            if (!arguments.length) return range;
            range = _;
            return scale;
          };
          scale.invertExtent = function(y) {
            y = range.indexOf(y);
            return [domain[y - 1], domain[y]];
          };
          scale.copy = function() {
            return d3_scale_threshold(domain, range);
          };
          return scale;
        }
        d3.scale.identity = function() {
          return d3_scale_identity([0, 1]);
        };
        function d3_scale_identity(domain) {
          function identity(x) {
            return +x;
          }
          identity.invert = identity;
          identity.domain = identity.range = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(identity);
            return identity;
          };
          identity.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
          };
          identity.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
          };
          identity.copy = function() {
            return d3_scale_identity(domain);
          };
          return identity;
        }
        d3.svg = {};
        function d3_zero() {
          return 0;
        }
        d3.svg.arc = function() {
          var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
          function arc() {
            var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - half\u03C0, a1 = endAngle.apply(this, arguments) - half\u03C0, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
            if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
            if (da >= \u03C4\u03B5) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
            var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
            if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
              rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
              if (!cw) p1 *= -1;
              if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
              if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
            }
            if (r1) {
              x0 = r1 * Math.cos(a0 + p1);
              y0 = r1 * Math.sin(a0 + p1);
              x1 = r1 * Math.cos(a1 - p1);
              y1 = r1 * Math.sin(a1 - p1);
              var l1 = Math.abs(a1 - a0 - 2 * p1) <= \u03C0 ? 0 : 1;
              if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
                var h1 = (a0 + a1) / 2;
                x0 = r1 * Math.cos(h1);
                y0 = r1 * Math.sin(h1);
                x1 = y1 = null;
              }
            } else {
              x0 = y0 = 0;
            }
            if (r0) {
              x2 = r0 * Math.cos(a1 - p0);
              y2 = r0 * Math.sin(a1 - p0);
              x3 = r0 * Math.cos(a0 + p0);
              y3 = r0 * Math.sin(a0 + p0);
              var l0 = Math.abs(a0 - a1 + 2 * p0) <= \u03C0 ? 0 : 1;
              if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
                var h0 = (a0 + a1) / 2;
                x2 = r0 * Math.cos(h0);
                y2 = r0 * Math.sin(h0);
                x3 = y3 = null;
              }
            } else {
              x2 = y2 = 0;
            }
            if (da > \u03B5 && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > 1e-3) {
              cr = r0 < r1 ^ cw ? 0 : 1;
              var rc1 = rc, rc0 = rc;
              if (da < \u03C0) {
                var oc = x3 == null ? [x2, y2] : x1 == null ? [x0, y0] : d3_geom_polygonIntersect([x0, y0], [x3, y3], [x1, y1], [x2, y2]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
                rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
              }
              if (x1 != null) {
                var t30 = d3_svg_arcCornerTangents(x3 == null ? [x2, y2] : [x3, y3], [x0, y0], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([x1, y1], [x2, y2], r1, rc1, cw);
                if (rc === rc1) {
                  path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
                } else {
                  path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
                }
              } else {
                path.push("M", x0, ",", y0);
              }
              if (x3 != null) {
                var t03 = d3_svg_arcCornerTangents([x0, y0], [x3, y3], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([x2, y2], x1 == null ? [x0, y0] : [x1, y1], r0, -rc0, cw);
                if (rc === rc0) {
                  path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                } else {
                  path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                }
              } else {
                path.push("L", x2, ",", y2);
              }
            } else {
              path.push("M", x0, ",", y0);
              if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
              path.push("L", x2, ",", y2);
              if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
            }
            path.push("Z");
            return path.join("");
          }
          function circleSegment(r1, cw) {
            return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
          }
          arc.innerRadius = function(v) {
            if (!arguments.length) return innerRadius;
            innerRadius = d3_functor(v);
            return arc;
          };
          arc.outerRadius = function(v) {
            if (!arguments.length) return outerRadius;
            outerRadius = d3_functor(v);
            return arc;
          };
          arc.cornerRadius = function(v) {
            if (!arguments.length) return cornerRadius;
            cornerRadius = d3_functor(v);
            return arc;
          };
          arc.padRadius = function(v) {
            if (!arguments.length) return padRadius;
            padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
            return arc;
          };
          arc.startAngle = function(v) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v);
            return arc;
          };
          arc.endAngle = function(v) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v);
            return arc;
          };
          arc.padAngle = function(v) {
            if (!arguments.length) return padAngle;
            padAngle = d3_functor(v);
            return arc;
          };
          arc.centroid = function() {
            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - half\u03C0;
            return [Math.cos(a) * r, Math.sin(a) * r];
          };
          return arc;
        };
        var d3_svg_arcAuto = "auto";
        function d3_svg_arcInnerRadius(d) {
          return d.innerRadius;
        }
        function d3_svg_arcOuterRadius(d) {
          return d.outerRadius;
        }
        function d3_svg_arcStartAngle(d) {
          return d.startAngle;
        }
        function d3_svg_arcEndAngle(d) {
          return d.endAngle;
        }
        function d3_svg_arcPadAngle(d) {
          return d && d.padAngle;
        }
        function d3_svg_arcSweep(x0, y0, x1, y1) {
          return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
        }
        function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
          var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
          if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
          return [[cx0 - ox, cy0 - oy], [cx0 * r1 / r, cy0 * r1 / r]];
        }
        function d3_true() {
          return true;
        }
        function d3_svg_line(projection) {
          var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = 0.7;
          function line(data) {
            var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
            function segment() {
              segments.push("M", interpolate(projection(points), tension));
            }
            while (++i < n) {
              if (defined.call(this, d = data[i], i)) {
                points.push([+fx.call(this, d, i), +fy.call(this, d, i)]);
              } else if (points.length) {
                segment();
                points = [];
              }
            }
            if (points.length) segment();
            return segments.length ? segments.join("") : null;
          }
          line.x = function(_) {
            if (!arguments.length) return x;
            x = _;
            return line;
          };
          line.y = function(_) {
            if (!arguments.length) return y;
            y = _;
            return line;
          };
          line.defined = function(_) {
            if (!arguments.length) return defined;
            defined = _;
            return line;
          };
          line.interpolate = function(_) {
            if (!arguments.length) return interpolateKey;
            if (typeof _ === "function") interpolateKey = interpolate = _;
            else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            return line;
          };
          line.tension = function(_) {
            if (!arguments.length) return tension;
            tension = _;
            return line;
          };
          return line;
        }
        d3.svg.line = function() {
          return d3_svg_line(d3_identity);
        };
        var d3_svg_lineInterpolators = d3.map({
          linear: d3_svg_lineLinear,
          "linear-closed": d3_svg_lineLinearClosed,
          step: d3_svg_lineStep,
          "step-before": d3_svg_lineStepBefore,
          "step-after": d3_svg_lineStepAfter,
          basis: d3_svg_lineBasis,
          "basis-open": d3_svg_lineBasisOpen,
          "basis-closed": d3_svg_lineBasisClosed,
          bundle: d3_svg_lineBundle,
          cardinal: d3_svg_lineCardinal,
          "cardinal-open": d3_svg_lineCardinalOpen,
          "cardinal-closed": d3_svg_lineCardinalClosed,
          monotone: d3_svg_lineMonotone
        });
        d3_svg_lineInterpolators.forEach(function(key, value) {
          value.key = key;
          value.closed = /-closed$/.test(key);
        });
        function d3_svg_lineLinear(points) {
          return points.length > 1 ? points.join("L") : points + "Z";
        }
        function d3_svg_lineLinearClosed(points) {
          return points.join("L") + "Z";
        }
        function d3_svg_lineStep(points) {
          var i = 0, n = points.length, p = points[0], path = [p[0], ",", p[1]];
          while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
          if (n > 1) path.push("H", p[0]);
          return path.join("");
        }
        function d3_svg_lineStepBefore(points) {
          var i = 0, n = points.length, p = points[0], path = [p[0], ",", p[1]];
          while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
          return path.join("");
        }
        function d3_svg_lineStepAfter(points) {
          var i = 0, n = points.length, p = points[0], path = [p[0], ",", p[1]];
          while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
          return path.join("");
        }
        function d3_svg_lineCardinalOpen(points, tension) {
          return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
        }
        function d3_svg_lineCardinalClosed(points, tension) {
          return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));
        }
        function d3_svg_lineCardinal(points, tension) {
          return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
        }
        function d3_svg_lineHermite(points, tangents) {
          if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
            return d3_svg_lineLinear(points);
          }
          var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
          if (quad) {
            path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
            p0 = points[1];
            pi = 2;
          }
          if (tangents.length > 1) {
            t = tangents[1];
            p = points[pi];
            pi++;
            path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            for (var i = 2; i < tangents.length; i++, pi++) {
              p = points[pi];
              t = tangents[i];
              path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            }
          }
          if (quad) {
            var lp = points[pi];
            path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
          }
          return path;
        }
        function d3_svg_lineCardinalTangents(points, tension) {
          var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
          while (++i < n) {
            p0 = p1;
            p1 = p2;
            p2 = points[i];
            tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
          }
          return tangents;
        }
        function d3_svg_lineBasis(points) {
          if (points.length < 3) return d3_svg_lineLinear(points);
          var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [x0, x0, x0, (pi = points[1])[0]], py = [y0, y0, y0, pi[1]], path = [x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
          points.push(points[n - 1]);
          while (++i <= n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
          }
          points.pop();
          path.push("L", pi);
          return path.join("");
        }
        function d3_svg_lineBasisOpen(points) {
          if (points.length < 4) return d3_svg_lineLinear(points);
          var path = [], i = -1, n = points.length, pi, px = [0], py = [0];
          while (++i < 3) {
            pi = points[i];
            px.push(pi[0]);
            py.push(pi[1]);
          }
          path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
          --i;
          while (++i < n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
          }
          return path.join("");
        }
        function d3_svg_lineBasisClosed(points) {
          var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
          while (++i < 4) {
            pi = points[i % n];
            px.push(pi[0]);
            py.push(pi[1]);
          }
          path = [d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
          --i;
          while (++i < m) {
            pi = points[i % n];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
          }
          return path.join("");
        }
        function d3_svg_lineBundle(points, tension) {
          var n = points.length - 1;
          if (n) {
            var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
            while (++i <= n) {
              p = points[i];
              t = i / n;
              p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
              p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
            }
          }
          return d3_svg_lineBasis(points);
        }
        function d3_svg_lineDot4(a, b) {
          return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
        }
        var d3_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0], d3_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0], d3_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];
        function d3_svg_lineBasisBezier(path, x, y) {
          path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
        }
        function d3_svg_lineSlope(p0, p1) {
          return (p1[1] - p0[1]) / (p1[0] - p0[0]);
        }
        function d3_svg_lineFiniteDifferences(points) {
          var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
          while (++i < j) {
            m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
          }
          m[i] = d;
          return m;
        }
        function d3_svg_lineMonotoneTangents(points) {
          var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
          while (++i < j) {
            d = d3_svg_lineSlope(points[i], points[i + 1]);
            if (abs(d) < \u03B5) {
              m[i] = m[i + 1] = 0;
            } else {
              a = m[i] / d;
              b = m[i + 1] / d;
              s = a * a + b * b;
              if (s > 9) {
                s = d * 3 / Math.sqrt(s);
                m[i] = s * a;
                m[i + 1] = s * b;
              }
            }
          }
          i = -1;
          while (++i <= j) {
            s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
            tangents.push([s || 0, m[i] * s || 0]);
          }
          return tangents;
        }
        function d3_svg_lineMonotone(points) {
          return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
        }
        d3.svg.line.radial = function() {
          var line = d3_svg_line(d3_svg_lineRadial);
          line.radius = line.x, delete line.x;
          line.angle = line.y, delete line.y;
          return line;
        };
        function d3_svg_lineRadial(points) {
          var point, i = -1, n = points.length, r, a;
          while (++i < n) {
            point = points[i];
            r = point[0];
            a = point[1] - half\u03C0;
            point[0] = r * Math.cos(a);
            point[1] = r * Math.sin(a);
          }
          return points;
        }
        function d3_svg_area(projection) {
          var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = 0.7;
          function area(data) {
            var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
              return x;
            } : d3_functor(x1), fy1 = y0 === y1 ? function() {
              return y;
            } : d3_functor(y1), x, y;
            function segment() {
              segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
            }
            while (++i < n) {
              if (defined.call(this, d = data[i], i)) {
                points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]);
                points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)]);
              } else if (points0.length) {
                segment();
                points0 = [];
                points1 = [];
              }
            }
            if (points0.length) segment();
            return segments.length ? segments.join("") : null;
          }
          area.x = function(_) {
            if (!arguments.length) return x1;
            x0 = x1 = _;
            return area;
          };
          area.x0 = function(_) {
            if (!arguments.length) return x0;
            x0 = _;
            return area;
          };
          area.x1 = function(_) {
            if (!arguments.length) return x1;
            x1 = _;
            return area;
          };
          area.y = function(_) {
            if (!arguments.length) return y1;
            y0 = y1 = _;
            return area;
          };
          area.y0 = function(_) {
            if (!arguments.length) return y0;
            y0 = _;
            return area;
          };
          area.y1 = function(_) {
            if (!arguments.length) return y1;
            y1 = _;
            return area;
          };
          area.defined = function(_) {
            if (!arguments.length) return defined;
            defined = _;
            return area;
          };
          area.interpolate = function(_) {
            if (!arguments.length) return interpolateKey;
            if (typeof _ === "function") interpolateKey = interpolate = _;
            else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            interpolateReverse = interpolate.reverse || interpolate;
            L = interpolate.closed ? "M" : "L";
            return area;
          };
          area.tension = function(_) {
            if (!arguments.length) return tension;
            tension = _;
            return area;
          };
          return area;
        }
        d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
        d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
        d3.svg.area = function() {
          return d3_svg_area(d3_identity);
        };
        d3.svg.area.radial = function() {
          var area = d3_svg_area(d3_svg_lineRadial);
          area.radius = area.x, delete area.x;
          area.innerRadius = area.x0, delete area.x0;
          area.outerRadius = area.x1, delete area.x1;
          area.angle = area.y, delete area.y;
          area.startAngle = area.y0, delete area.y0;
          area.endAngle = area.y1, delete area.y1;
          return area;
        };
        function d3_source(d) {
          return d.source;
        }
        function d3_target(d) {
          return d.target;
        }
        d3.svg.chord = function() {
          var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
          function chord(d, i) {
            var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
            return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
          }
          function subgroup(self2, f, d, i) {
            var subgroup2 = f.call(self2, d, i), r = radius.call(self2, subgroup2, i), a0 = startAngle.call(self2, subgroup2, i) - half\u03C0, a1 = endAngle.call(self2, subgroup2, i) - half\u03C0;
            return {
              r,
              a0,
              a1,
              p0: [r * Math.cos(a0), r * Math.sin(a0)],
              p1: [r * Math.cos(a1), r * Math.sin(a1)]
            };
          }
          function equals(a, b) {
            return a.a0 == b.a0 && a.a1 == b.a1;
          }
          function arc(r, p, a) {
            return "A" + r + "," + r + " 0 " + +(a > \u03C0) + ",1 " + p;
          }
          function curve(r0, p0, r1, p1) {
            return "Q 0,0 " + p1;
          }
          chord.radius = function(v) {
            if (!arguments.length) return radius;
            radius = d3_functor(v);
            return chord;
          };
          chord.source = function(v) {
            if (!arguments.length) return source;
            source = d3_functor(v);
            return chord;
          };
          chord.target = function(v) {
            if (!arguments.length) return target;
            target = d3_functor(v);
            return chord;
          };
          chord.startAngle = function(v) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v);
            return chord;
          };
          chord.endAngle = function(v) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v);
            return chord;
          };
          return chord;
        };
        function d3_svg_chordRadius(d) {
          return d.radius;
        }
        d3.svg.diagonal = function() {
          var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
          function diagonal(d, i) {
            var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [p0, {
              x: p0.x,
              y: m
            }, {
              x: p3.x,
              y: m
            }, p3];
            p = p.map(projection);
            return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
          }
          diagonal.source = function(x) {
            if (!arguments.length) return source;
            source = d3_functor(x);
            return diagonal;
          };
          diagonal.target = function(x) {
            if (!arguments.length) return target;
            target = d3_functor(x);
            return diagonal;
          };
          diagonal.projection = function(x) {
            if (!arguments.length) return projection;
            projection = x;
            return diagonal;
          };
          return diagonal;
        };
        function d3_svg_diagonalProjection(d) {
          return [d.x, d.y];
        }
        d3.svg.diagonal.radial = function() {
          var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
          diagonal.projection = function(x) {
            return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
          };
          return diagonal;
        };
        function d3_svg_diagonalRadialProjection(projection) {
          return function() {
            var d = projection.apply(this, arguments), r = d[0], a = d[1] - half\u03C0;
            return [r * Math.cos(a), r * Math.sin(a)];
          };
        }
        d3.svg.symbol = function() {
          var type = d3_svg_symbolType, size = d3_svg_symbolSize;
          function symbol(d, i) {
            return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
          }
          symbol.type = function(x) {
            if (!arguments.length) return type;
            type = d3_functor(x);
            return symbol;
          };
          symbol.size = function(x) {
            if (!arguments.length) return size;
            size = d3_functor(x);
            return symbol;
          };
          return symbol;
        };
        function d3_svg_symbolSize() {
          return 64;
        }
        function d3_svg_symbolType() {
          return "circle";
        }
        function d3_svg_symbolCircle(size) {
          var r = Math.sqrt(size / \u03C0);
          return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
        }
        var d3_svg_symbols = d3.map({
          circle: d3_svg_symbolCircle,
          cross: function(size) {
            var r = Math.sqrt(size / 5) / 2;
            return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
          },
          diamond: function(size) {
            var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
            return "M0," + -ry + "L" + rx + ",0 0," + ry + " " + -rx + ",0Z";
          },
          square: function(size) {
            var r = Math.sqrt(size) / 2;
            return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
          },
          "triangle-down": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
          },
          "triangle-up": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
          }
        });
        d3.svg.symbolTypes = d3_svg_symbols.keys();
        var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
        d3_selectionPrototype.transition = function(name) {
          var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
            time: Date.now(),
            ease: d3_ease_cubicInOut,
            delay: 0,
            duration: 250
          };
          for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
              if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
              subgroup.push(node);
            }
          }
          return d3_transition(subgroups, ns, id);
        };
        d3_selectionPrototype.interrupt = function(name) {
          return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
        };
        var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
        function d3_selection_interruptNS(ns) {
          return function() {
            var lock, activeId, active;
            if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
              active.timer.c = null;
              active.timer.t = NaN;
              if (--lock.count) delete lock[activeId];
              else delete this[ns];
              lock.active += 0.5;
              active.event && active.event.interrupt.call(this, this.__data__, active.index);
            }
          };
        }
        function d3_transition(groups, ns, id) {
          d3_subclass(groups, d3_transitionPrototype);
          groups.namespace = ns;
          groups.id = id;
          return groups;
        }
        var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
        d3_transitionPrototype.call = d3_selectionPrototype.call;
        d3_transitionPrototype.empty = d3_selectionPrototype.empty;
        d3_transitionPrototype.node = d3_selectionPrototype.node;
        d3_transitionPrototype.size = d3_selectionPrototype.size;
        d3.transition = function(selection, name) {
          return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
        };
        d3.transition.prototype = d3_transitionPrototype;
        d3_transitionPrototype.select = function(selector) {
          var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
          selector = d3_selection_selector(selector);
          for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
              if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
                if ("__data__" in node) subnode.__data__ = node.__data__;
                d3_transitionNode(subnode, i, ns, id, node[ns][id]);
                subgroup.push(subnode);
              } else {
                subgroup.push(null);
              }
            }
          }
          return d3_transition(subgroups, ns, id);
        };
        d3_transitionPrototype.selectAll = function(selector) {
          var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
          selector = d3_selection_selectorAll(selector);
          for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
              if (node = group[i]) {
                transition = node[ns][id];
                subnodes = selector.call(node, node.__data__, i, j);
                subgroups.push(subgroup = []);
                for (var k = -1, o = subnodes.length; ++k < o; ) {
                  if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
                  subgroup.push(subnode);
                }
              }
            }
          }
          return d3_transition(subgroups, ns, id);
        };
        d3_transitionPrototype.filter = function(filter) {
          var subgroups = [], subgroup, group, node;
          if (typeof filter !== "function") filter = d3_selection_filter(filter);
          for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
              if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                subgroup.push(node);
              }
            }
          }
          return d3_transition(subgroups, this.namespace, this.id);
        };
        d3_transitionPrototype.tween = function(name, tween) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
          return d3_selection_each(this, tween == null ? function(node) {
            node[ns][id].tween.remove(name);
          } : function(node) {
            node[ns][id].tween.set(name, tween);
          });
        };
        function d3_transition_tween(groups, name, value, tween) {
          var id = groups.id, ns = groups.namespace;
          return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
            node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
          } : (value = tween(value), function(node) {
            node[ns][id].tween.set(name, value);
          }));
        }
        d3_transitionPrototype.attr = function(nameNS, value) {
          if (arguments.length < 2) {
            for (value in nameNS) this.attr(value, nameNS[value]);
            return this;
          }
          var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
          function attrNull() {
            this.removeAttribute(name);
          }
          function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
          }
          function attrTween(b) {
            return b == null ? attrNull : (b += "", function() {
              var a = this.getAttribute(name), i;
              return a !== b && (i = interpolate(a, b), function(t) {
                this.setAttribute(name, i(t));
              });
            });
          }
          function attrTweenNS(b) {
            return b == null ? attrNullNS : (b += "", function() {
              var a = this.getAttributeNS(name.space, name.local), i;
              return a !== b && (i = interpolate(a, b), function(t) {
                this.setAttributeNS(name.space, name.local, i(t));
              });
            });
          }
          return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
        };
        d3_transitionPrototype.attrTween = function(nameNS, tween) {
          var name = d3.ns.qualify(nameNS);
          function attrTween(d, i) {
            var f = tween.call(this, d, i, this.getAttribute(name));
            return f && function(t) {
              this.setAttribute(name, f(t));
            };
          }
          function attrTweenNS(d, i) {
            var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
            return f && function(t) {
              this.setAttributeNS(name.space, name.local, f(t));
            };
          }
          return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
        };
        d3_transitionPrototype.style = function(name, value, priority) {
          var n = arguments.length;
          if (n < 3) {
            if (typeof name !== "string") {
              if (n < 2) value = "";
              for (priority in name) this.style(priority, name[priority], value);
              return this;
            }
            priority = "";
          }
          function styleNull() {
            this.style.removeProperty(name);
          }
          function styleString(b) {
            return b == null ? styleNull : (b += "", function() {
              var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
              return a !== b && (i = d3_interpolate(a, b), function(t) {
                this.style.setProperty(name, i(t), priority);
              });
            });
          }
          return d3_transition_tween(this, "style." + name, value, styleString);
        };
        d3_transitionPrototype.styleTween = function(name, tween, priority) {
          if (arguments.length < 3) priority = "";
          function styleTween(d, i) {
            var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
            return f && function(t) {
              this.style.setProperty(name, f(t), priority);
            };
          }
          return this.tween("style." + name, styleTween);
        };
        d3_transitionPrototype.text = function(value) {
          return d3_transition_tween(this, "text", value, d3_transition_text);
        };
        function d3_transition_text(b) {
          if (b == null) b = "";
          return function() {
            this.textContent = b;
          };
        }
        d3_transitionPrototype.remove = function() {
          var ns = this.namespace;
          return this.each("end.transition", function() {
            var p;
            if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
          });
        };
        d3_transitionPrototype.ease = function(value) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 1) return this.node()[ns][id].ease;
          if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
          return d3_selection_each(this, function(node) {
            node[ns][id].ease = value;
          });
        };
        d3_transitionPrototype.delay = function(value) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 1) return this.node()[ns][id].delay;
          return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node[ns][id].delay = +value.call(node, node.__data__, i, j);
          } : (value = +value, function(node) {
            node[ns][id].delay = value;
          }));
        };
        d3_transitionPrototype.duration = function(value) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 1) return this.node()[ns][id].duration;
          return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
          } : (value = Math.max(1, value), function(node) {
            node[ns][id].duration = value;
          }));
        };
        d3_transitionPrototype.each = function(type, listener) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 2) {
            var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
            try {
              d3_transitionInheritId = id;
              d3_selection_each(this, function(node, i, j) {
                d3_transitionInherit = node[ns][id];
                type.call(node, node.__data__, i, j);
              });
            } finally {
              d3_transitionInherit = inherit;
              d3_transitionInheritId = inheritId;
            }
          } else {
            d3_selection_each(this, function(node) {
              var transition = node[ns][id];
              (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
            });
          }
          return this;
        };
        d3_transitionPrototype.transition = function() {
          var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
          for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
              if (node = group[i]) {
                transition = node[ns][id0];
                d3_transitionNode(node, i, ns, id1, {
                  time: transition.time,
                  ease: transition.ease,
                  delay: transition.delay + transition.duration,
                  duration: transition.duration
                });
              }
              subgroup.push(node);
            }
          }
          return d3_transition(subgroups, ns, id1);
        };
        function d3_transitionNamespace(name) {
          return name == null ? "__transition__" : "__transition_" + name + "__";
        }
        function d3_transitionNode(node, i, ns, id, inherit) {
          var lock = node[ns] || (node[ns] = {
            active: 0,
            count: 0
          }), transition = lock[id], time, timer, duration, ease, tweens;
          function schedule(elapsed) {
            var delay = transition.delay;
            timer.t = delay + time;
            if (delay <= elapsed) return start(elapsed - delay);
            timer.c = start;
          }
          function start(elapsed) {
            var activeId = lock.active, active = lock[activeId];
            if (active) {
              active.timer.c = null;
              active.timer.t = NaN;
              --lock.count;
              delete lock[activeId];
              active.event && active.event.interrupt.call(node, node.__data__, active.index);
            }
            for (var cancelId in lock) {
              if (+cancelId < id) {
                var cancel = lock[cancelId];
                cancel.timer.c = null;
                cancel.timer.t = NaN;
                --lock.count;
                delete lock[cancelId];
              }
            }
            timer.c = tick;
            d3_timer(function() {
              if (timer.c && tick(elapsed || 1)) {
                timer.c = null;
                timer.t = NaN;
              }
              return 1;
            }, 0, time);
            lock.active = id;
            transition.event && transition.event.start.call(node, node.__data__, i);
            tweens = [];
            transition.tween.forEach(function(key, value) {
              if (value = value.call(node, node.__data__, i)) {
                tweens.push(value);
              }
            });
            ease = transition.ease;
            duration = transition.duration;
          }
          function tick(elapsed) {
            var t = elapsed / duration, e = ease(t), n = tweens.length;
            while (n > 0) {
              tweens[--n].call(node, e);
            }
            if (t >= 1) {
              transition.event && transition.event.end.call(node, node.__data__, i);
              if (--lock.count) delete lock[id];
              else delete node[ns];
              return 1;
            }
          }
          if (!transition) {
            time = inherit.time;
            timer = d3_timer(schedule, 0, time);
            transition = lock[id] = {
              tween: new d3_Map(),
              time,
              timer,
              delay: inherit.delay,
              duration: inherit.duration,
              ease: inherit.ease,
              index: i
            };
            inherit = null;
            ++lock.count;
          }
        }
        d3.svg.axis = function() {
          var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [10], tickValues = null, tickFormat_;
          function axis(g) {
            g.each(function() {
              var g2 = d3.select(this);
              var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
              var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g2.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", \u03B5), tickExit = d3.transition(tick.exit()).style("opacity", \u03B5).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
              var range = d3_scaleRange(scale1), path = g2.selectAll(".domain").data([0]), pathUpdate = (path.enter().append("path").attr("class", "domain"), d3.transition(path));
              tickEnter.append("line");
              tickEnter.append("text");
              var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
              if (orient === "bottom" || orient === "top") {
                tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
                text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
                pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
              } else {
                tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
                text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
                pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
              }
              lineEnter.attr(y2, sign * innerTickSize);
              textEnter.attr(y1, sign * tickSpacing);
              lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
              textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
              if (scale1.rangeBand) {
                var x = scale1, dx = x.rangeBand() / 2;
                scale0 = scale1 = function(d) {
                  return x(d) + dx;
                };
              } else if (scale0.rangeBand) {
                scale0 = scale1;
              } else {
                tickExit.call(tickTransform, scale1, scale0);
              }
              tickEnter.call(tickTransform, scale0, scale1);
              tickUpdate.call(tickTransform, scale1, scale1);
            });
          }
          axis.scale = function(x) {
            if (!arguments.length) return scale;
            scale = x;
            return axis;
          };
          axis.orient = function(x) {
            if (!arguments.length) return orient;
            orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
            return axis;
          };
          axis.ticks = function() {
            if (!arguments.length) return tickArguments_;
            tickArguments_ = d3_array(arguments);
            return axis;
          };
          axis.tickValues = function(x) {
            if (!arguments.length) return tickValues;
            tickValues = x;
            return axis;
          };
          axis.tickFormat = function(x) {
            if (!arguments.length) return tickFormat_;
            tickFormat_ = x;
            return axis;
          };
          axis.tickSize = function(x) {
            var n = arguments.length;
            if (!n) return innerTickSize;
            innerTickSize = +x;
            outerTickSize = +arguments[n - 1];
            return axis;
          };
          axis.innerTickSize = function(x) {
            if (!arguments.length) return innerTickSize;
            innerTickSize = +x;
            return axis;
          };
          axis.outerTickSize = function(x) {
            if (!arguments.length) return outerTickSize;
            outerTickSize = +x;
            return axis;
          };
          axis.tickPadding = function(x) {
            if (!arguments.length) return tickPadding;
            tickPadding = +x;
            return axis;
          };
          axis.tickSubdivide = function() {
            return arguments.length && axis;
          };
          return axis;
        };
        var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
          top: 1,
          right: 1,
          bottom: 1,
          left: 1
        };
        function d3_svg_axisX(selection, x0, x1) {
          selection.attr("transform", function(d) {
            var v0 = x0(d);
            return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
          });
        }
        function d3_svg_axisY(selection, y0, y1) {
          selection.attr("transform", function(d) {
            var v0 = y0(d);
            return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
          });
        }
        d3.svg.brush = function() {
          var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [0, 0], yExtent = [0, 0], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
          function brush(g) {
            g.each(function() {
              var g2 = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
              var background = g2.selectAll(".background").data([0]);
              background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
              g2.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
              var resize = g2.selectAll(".resize").data(resizes, d3_identity);
              resize.exit().remove();
              resize.enter().append("g").attr("class", function(d) {
                return "resize " + d;
              }).style("cursor", function(d) {
                return d3_svg_brushCursor[d];
              }).append("rect").attr("x", function(d) {
                return /[ew]$/.test(d) ? -3 : null;
              }).attr("y", function(d) {
                return /^[ns]/.test(d) ? -3 : null;
              }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
              resize.style("display", brush.empty() ? "none" : null);
              var gUpdate = d3.transition(g2), backgroundUpdate = d3.transition(background), range;
              if (x) {
                range = d3_scaleRange(x);
                backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
                redrawX(gUpdate);
              }
              if (y) {
                range = d3_scaleRange(y);
                backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
                redrawY(gUpdate);
              }
              redraw(gUpdate);
            });
          }
          brush.event = function(g) {
            g.each(function() {
              var event_ = event.of(this, arguments), extent1 = {
                x: xExtent,
                y: yExtent,
                i: xExtentDomain,
                j: yExtentDomain
              }, extent0 = this.__chart__ || extent1;
              this.__chart__ = extent1;
              if (d3_transitionInheritId) {
                d3.select(this).transition().each("start.brush", function() {
                  xExtentDomain = extent0.i;
                  yExtentDomain = extent0.j;
                  xExtent = extent0.x;
                  yExtent = extent0.y;
                  event_({
                    type: "brushstart"
                  });
                }).tween("brush:brush", function() {
                  var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
                  xExtentDomain = yExtentDomain = null;
                  return function(t) {
                    xExtent = extent1.x = xi(t);
                    yExtent = extent1.y = yi(t);
                    event_({
                      type: "brush",
                      mode: "resize"
                    });
                  };
                }).each("end.brush", function() {
                  xExtentDomain = extent1.i;
                  yExtentDomain = extent1.j;
                  event_({
                    type: "brush",
                    mode: "resize"
                  });
                  event_({
                    type: "brushend"
                  });
                });
              } else {
                event_({
                  type: "brushstart"
                });
                event_({
                  type: "brush",
                  mode: "resize"
                });
                event_({
                  type: "brushend"
                });
              }
            });
          };
          function redraw(g) {
            g.selectAll(".resize").attr("transform", function(d) {
              return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
            });
          }
          function redrawX(g) {
            g.select(".extent").attr("x", xExtent[0]);
            g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
          }
          function redrawY(g) {
            g.select(".extent").attr("y", yExtent[0]);
            g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
          }
          function brushstart() {
            var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
            var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
            if (d3.event.changedTouches) {
              w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
            } else {
              w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
            }
            g.interrupt().selectAll("*").interrupt();
            if (dragging) {
              origin[0] = xExtent[0] - origin[0];
              origin[1] = yExtent[0] - origin[1];
            } else if (resizing) {
              var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
              offset = [xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1]];
              origin[0] = xExtent[ex];
              origin[1] = yExtent[ey];
            } else if (d3.event.altKey) center = origin.slice();
            g.style("pointer-events", "none").selectAll(".resize").style("display", null);
            d3.select("body").style("cursor", eventTarget.style("cursor"));
            event_({
              type: "brushstart"
            });
            brushmove();
            function keydown() {
              if (d3.event.keyCode == 32) {
                if (!dragging) {
                  center = null;
                  origin[0] -= xExtent[1];
                  origin[1] -= yExtent[1];
                  dragging = 2;
                }
                d3_eventPreventDefault();
              }
            }
            function keyup() {
              if (d3.event.keyCode == 32 && dragging == 2) {
                origin[0] += xExtent[1];
                origin[1] += yExtent[1];
                dragging = 0;
                d3_eventPreventDefault();
              }
            }
            function brushmove() {
              var point = d3.mouse(target), moved = false;
              if (offset) {
                point[0] += offset[0];
                point[1] += offset[1];
              }
              if (!dragging) {
                if (d3.event.altKey) {
                  if (!center) center = [(xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2];
                  origin[0] = xExtent[+(point[0] < center[0])];
                  origin[1] = yExtent[+(point[1] < center[1])];
                } else center = null;
              }
              if (resizingX && move1(point, x, 0)) {
                redrawX(g);
                moved = true;
              }
              if (resizingY && move1(point, y, 1)) {
                redrawY(g);
                moved = true;
              }
              if (moved) {
                redraw(g);
                event_({
                  type: "brush",
                  mode: dragging ? "move" : "resize"
                });
              }
            }
            function move1(point, scale, i) {
              var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
              if (dragging) {
                r0 -= position;
                r1 -= size + position;
              }
              min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
              if (dragging) {
                max = (min += position) + size;
              } else {
                if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
                if (position < min) {
                  max = min;
                  min = position;
                } else {
                  max = position;
                }
              }
              if (extent[0] != min || extent[1] != max) {
                if (i) yExtentDomain = null;
                else xExtentDomain = null;
                extent[0] = min;
                extent[1] = max;
                return true;
              }
            }
            function brushend() {
              brushmove();
              g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
              d3.select("body").style("cursor", null);
              w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
              dragRestore();
              event_({
                type: "brushend"
              });
            }
          }
          brush.x = function(z) {
            if (!arguments.length) return x;
            x = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
          };
          brush.y = function(z) {
            if (!arguments.length) return y;
            y = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
          };
          brush.clamp = function(z) {
            if (!arguments.length) return x && y ? [xClamp, yClamp] : x ? xClamp : y ? yClamp : null;
            if (x && y) xClamp = !!z[0], yClamp = !!z[1];
            else if (x) xClamp = !!z;
            else if (y) yClamp = !!z;
            return brush;
          };
          brush.extent = function(z) {
            var x0, x1, y0, y1, t;
            if (!arguments.length) {
              if (x) {
                if (xExtentDomain) {
                  x0 = xExtentDomain[0], x1 = xExtentDomain[1];
                } else {
                  x0 = xExtent[0], x1 = xExtent[1];
                  if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
                  if (x1 < x0) t = x0, x0 = x1, x1 = t;
                }
              }
              if (y) {
                if (yExtentDomain) {
                  y0 = yExtentDomain[0], y1 = yExtentDomain[1];
                } else {
                  y0 = yExtent[0], y1 = yExtent[1];
                  if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
                  if (y1 < y0) t = y0, y0 = y1, y1 = t;
                }
              }
              return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];
            }
            if (x) {
              x0 = z[0], x1 = z[1];
              if (y) x0 = x0[0], x1 = x1[0];
              xExtentDomain = [x0, x1];
              if (x.invert) x0 = x(x0), x1 = x(x1);
              if (x1 < x0) t = x0, x0 = x1, x1 = t;
              if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [x0, x1];
            }
            if (y) {
              y0 = z[0], y1 = z[1];
              if (x) y0 = y0[1], y1 = y1[1];
              yExtentDomain = [y0, y1];
              if (y.invert) y0 = y(y0), y1 = y(y1);
              if (y1 < y0) t = y0, y0 = y1, y1 = t;
              if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [y0, y1];
            }
            return brush;
          };
          brush.clear = function() {
            if (!brush.empty()) {
              xExtent = [0, 0], yExtent = [0, 0];
              xExtentDomain = yExtentDomain = null;
            }
            return brush;
          };
          brush.empty = function() {
            return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
          };
          return d3.rebind(brush, event, "on");
        };
        var d3_svg_brushCursor = {
          n: "ns-resize",
          e: "ew-resize",
          s: "ns-resize",
          w: "ew-resize",
          nw: "nwse-resize",
          ne: "nesw-resize",
          se: "nwse-resize",
          sw: "nesw-resize"
        };
        var d3_svg_brushResizes = [["n", "e", "s", "w", "nw", "ne", "se", "sw"], ["e", "w"], ["n", "s"], []];
        d3.text = d3_xhrType(function(request) {
          return request.responseText;
        });
        d3.json = function(url, callback) {
          return d3_xhr(url, "application/json", d3_json, callback);
        };
        function d3_json(request) {
          return JSON.parse(request.responseText);
        }
        d3.html = function(url, callback) {
          return d3_xhr(url, "text/html", d3_html, callback);
        };
        function d3_html(request) {
          var range = d3_document.createRange();
          range.selectNode(d3_document.body);
          return range.createContextualFragment(request.responseText);
        }
        d3.xml = d3_xhrType(function(request) {
          return request.responseXML;
        });
        if (typeof define === "function" && false) define(d3);
        else if (typeof module === "object" && module.exports) module.exports = d3;
        else this.d3 = d3;
      }.apply(self);
    }
  });

  // node_modules/d3-time/dist/d3-time.js
  var require_d3_time = __commonJS({
    "node_modules/d3-time/dist/d3-time.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && false ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        var t0 = /* @__PURE__ */ new Date(), t1 = /* @__PURE__ */ new Date();
        function newInterval(floori, offseti, count, field) {
          function interval(date) {
            return floori(date = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date)), date;
          }
          interval.floor = function(date) {
            return floori(date = /* @__PURE__ */ new Date(+date)), date;
          };
          interval.ceil = function(date) {
            return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
          };
          interval.round = function(date) {
            var d0 = interval(date), d1 = interval.ceil(date);
            return date - d0 < d1 - date ? d0 : d1;
          };
          interval.offset = function(date, step) {
            return offseti(date = /* @__PURE__ */ new Date(+date), step == null ? 1 : Math.floor(step)), date;
          };
          interval.range = function(start, stop, step) {
            var range = [], previous;
            start = interval.ceil(start);
            step = step == null ? 1 : Math.floor(step);
            if (!(start < stop) || !(step > 0)) return range;
            do
              range.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
            while (previous < start && start < stop);
            return range;
          };
          interval.filter = function(test) {
            return newInterval(function(date) {
              if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
            }, function(date, step) {
              if (date >= date) {
                if (step < 0) while (++step <= 0) {
                  while (offseti(date, -1), !test(date)) {
                  }
                }
                else while (--step >= 0) {
                  while (offseti(date, 1), !test(date)) {
                  }
                }
              }
            });
          };
          if (count) {
            interval.count = function(start, end) {
              t0.setTime(+start), t1.setTime(+end);
              floori(t0), floori(t1);
              return Math.floor(count(t0, t1));
            };
            interval.every = function(step) {
              step = Math.floor(step);
              return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function(d) {
                return field(d) % step === 0;
              } : function(d) {
                return interval.count(0, d) % step === 0;
              });
            };
          }
          return interval;
        }
        var millisecond = newInterval(function() {
        }, function(date, step) {
          date.setTime(+date + step);
        }, function(start, end) {
          return end - start;
        });
        millisecond.every = function(k) {
          k = Math.floor(k);
          if (!isFinite(k) || !(k > 0)) return null;
          if (!(k > 1)) return millisecond;
          return newInterval(function(date) {
            date.setTime(Math.floor(date / k) * k);
          }, function(date, step) {
            date.setTime(+date + step * k);
          }, function(start, end) {
            return (end - start) / k;
          });
        };
        var milliseconds = millisecond.range;
        var durationSecond = 1e3;
        var durationMinute = 6e4;
        var durationHour = 36e5;
        var durationDay = 864e5;
        var durationWeek = 6048e5;
        var second = newInterval(function(date) {
          date.setTime(date - date.getMilliseconds());
        }, function(date, step) {
          date.setTime(+date + step * durationSecond);
        }, function(start, end) {
          return (end - start) / durationSecond;
        }, function(date) {
          return date.getUTCSeconds();
        });
        var seconds = second.range;
        var minute = newInterval(function(date) {
          date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
        }, function(date, step) {
          date.setTime(+date + step * durationMinute);
        }, function(start, end) {
          return (end - start) / durationMinute;
        }, function(date) {
          return date.getMinutes();
        });
        var minutes = minute.range;
        var hour = newInterval(function(date) {
          date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
        }, function(date, step) {
          date.setTime(+date + step * durationHour);
        }, function(start, end) {
          return (end - start) / durationHour;
        }, function(date) {
          return date.getHours();
        });
        var hours = hour.range;
        var day = newInterval(function(date) {
          date.setHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setDate(date.getDate() + step);
        }, function(start, end) {
          return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
        }, function(date) {
          return date.getDate() - 1;
        });
        var days = day.range;
        function weekday(i) {
          return newInterval(function(date) {
            date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
            date.setHours(0, 0, 0, 0);
          }, function(date, step) {
            date.setDate(date.getDate() + step * 7);
          }, function(start, end) {
            return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
          });
        }
        var sunday = weekday(0);
        var monday = weekday(1);
        var tuesday = weekday(2);
        var wednesday = weekday(3);
        var thursday = weekday(4);
        var friday = weekday(5);
        var saturday = weekday(6);
        var sundays = sunday.range;
        var mondays = monday.range;
        var tuesdays = tuesday.range;
        var wednesdays = wednesday.range;
        var thursdays = thursday.range;
        var fridays = friday.range;
        var saturdays = saturday.range;
        var month = newInterval(function(date) {
          date.setDate(1);
          date.setHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setMonth(date.getMonth() + step);
        }, function(start, end) {
          return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
        }, function(date) {
          return date.getMonth();
        });
        var months = month.range;
        var year = newInterval(function(date) {
          date.setMonth(0, 1);
          date.setHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setFullYear(date.getFullYear() + step);
        }, function(start, end) {
          return end.getFullYear() - start.getFullYear();
        }, function(date) {
          return date.getFullYear();
        });
        year.every = function(k) {
          return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
            date.setFullYear(Math.floor(date.getFullYear() / k) * k);
            date.setMonth(0, 1);
            date.setHours(0, 0, 0, 0);
          }, function(date, step) {
            date.setFullYear(date.getFullYear() + step * k);
          });
        };
        var years = year.range;
        var utcMinute = newInterval(function(date) {
          date.setUTCSeconds(0, 0);
        }, function(date, step) {
          date.setTime(+date + step * durationMinute);
        }, function(start, end) {
          return (end - start) / durationMinute;
        }, function(date) {
          return date.getUTCMinutes();
        });
        var utcMinutes = utcMinute.range;
        var utcHour = newInterval(function(date) {
          date.setUTCMinutes(0, 0, 0);
        }, function(date, step) {
          date.setTime(+date + step * durationHour);
        }, function(start, end) {
          return (end - start) / durationHour;
        }, function(date) {
          return date.getUTCHours();
        });
        var utcHours = utcHour.range;
        var utcDay = newInterval(function(date) {
          date.setUTCHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setUTCDate(date.getUTCDate() + step);
        }, function(start, end) {
          return (end - start) / durationDay;
        }, function(date) {
          return date.getUTCDate() - 1;
        });
        var utcDays = utcDay.range;
        function utcWeekday(i) {
          return newInterval(function(date) {
            date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
            date.setUTCHours(0, 0, 0, 0);
          }, function(date, step) {
            date.setUTCDate(date.getUTCDate() + step * 7);
          }, function(start, end) {
            return (end - start) / durationWeek;
          });
        }
        var utcSunday = utcWeekday(0);
        var utcMonday = utcWeekday(1);
        var utcTuesday = utcWeekday(2);
        var utcWednesday = utcWeekday(3);
        var utcThursday = utcWeekday(4);
        var utcFriday = utcWeekday(5);
        var utcSaturday = utcWeekday(6);
        var utcSundays = utcSunday.range;
        var utcMondays = utcMonday.range;
        var utcTuesdays = utcTuesday.range;
        var utcWednesdays = utcWednesday.range;
        var utcThursdays = utcThursday.range;
        var utcFridays = utcFriday.range;
        var utcSaturdays = utcSaturday.range;
        var utcMonth = newInterval(function(date) {
          date.setUTCDate(1);
          date.setUTCHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setUTCMonth(date.getUTCMonth() + step);
        }, function(start, end) {
          return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
        }, function(date) {
          return date.getUTCMonth();
        });
        var utcMonths = utcMonth.range;
        var utcYear = newInterval(function(date) {
          date.setUTCMonth(0, 1);
          date.setUTCHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setUTCFullYear(date.getUTCFullYear() + step);
        }, function(start, end) {
          return end.getUTCFullYear() - start.getUTCFullYear();
        }, function(date) {
          return date.getUTCFullYear();
        });
        utcYear.every = function(k) {
          return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
            date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
            date.setUTCMonth(0, 1);
            date.setUTCHours(0, 0, 0, 0);
          }, function(date, step) {
            date.setUTCFullYear(date.getUTCFullYear() + step * k);
          });
        };
        var utcYears = utcYear.range;
        exports2.timeDay = day;
        exports2.timeDays = days;
        exports2.timeFriday = friday;
        exports2.timeFridays = fridays;
        exports2.timeHour = hour;
        exports2.timeHours = hours;
        exports2.timeInterval = newInterval;
        exports2.timeMillisecond = millisecond;
        exports2.timeMilliseconds = milliseconds;
        exports2.timeMinute = minute;
        exports2.timeMinutes = minutes;
        exports2.timeMonday = monday;
        exports2.timeMondays = mondays;
        exports2.timeMonth = month;
        exports2.timeMonths = months;
        exports2.timeSaturday = saturday;
        exports2.timeSaturdays = saturdays;
        exports2.timeSecond = second;
        exports2.timeSeconds = seconds;
        exports2.timeSunday = sunday;
        exports2.timeSundays = sundays;
        exports2.timeThursday = thursday;
        exports2.timeThursdays = thursdays;
        exports2.timeTuesday = tuesday;
        exports2.timeTuesdays = tuesdays;
        exports2.timeWednesday = wednesday;
        exports2.timeWednesdays = wednesdays;
        exports2.timeWeek = sunday;
        exports2.timeWeeks = sundays;
        exports2.timeYear = year;
        exports2.timeYears = years;
        exports2.utcDay = utcDay;
        exports2.utcDays = utcDays;
        exports2.utcFriday = utcFriday;
        exports2.utcFridays = utcFridays;
        exports2.utcHour = utcHour;
        exports2.utcHours = utcHours;
        exports2.utcMillisecond = millisecond;
        exports2.utcMilliseconds = milliseconds;
        exports2.utcMinute = utcMinute;
        exports2.utcMinutes = utcMinutes;
        exports2.utcMonday = utcMonday;
        exports2.utcMondays = utcMondays;
        exports2.utcMonth = utcMonth;
        exports2.utcMonths = utcMonths;
        exports2.utcSaturday = utcSaturday;
        exports2.utcSaturdays = utcSaturdays;
        exports2.utcSecond = second;
        exports2.utcSeconds = seconds;
        exports2.utcSunday = utcSunday;
        exports2.utcSundays = utcSundays;
        exports2.utcThursday = utcThursday;
        exports2.utcThursdays = utcThursdays;
        exports2.utcTuesday = utcTuesday;
        exports2.utcTuesdays = utcTuesdays;
        exports2.utcWednesday = utcWednesday;
        exports2.utcWednesdays = utcWednesdays;
        exports2.utcWeek = utcSunday;
        exports2.utcWeeks = utcSundays;
        exports2.utcYear = utcYear;
        exports2.utcYears = utcYears;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/d3-time-format/dist/d3-time-format.js
  var require_d3_time_format = __commonJS({
    "node_modules/d3-time-format/dist/d3-time-format.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_time()) : typeof define === "function" && false ? define(["exports", "d3-time"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3));
      })(exports, function(exports2, d3Time) {
        "use strict";
        function localDate(d) {
          if (0 <= d.y && d.y < 100) {
            var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
            date.setFullYear(d.y);
            return date;
          }
          return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
        }
        function utcDate(d) {
          if (0 <= d.y && d.y < 100) {
            var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
            date.setUTCFullYear(d.y);
            return date;
          }
          return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
        }
        function newDate(y, m, d) {
          return { y, m, d, H: 0, M: 0, S: 0, L: 0 };
        }
        function formatLocale(locale2) {
          var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
          var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
          var formats = {
            "a": formatShortWeekday,
            "A": formatWeekday,
            "b": formatShortMonth,
            "B": formatMonth,
            "c": null,
            "d": formatDayOfMonth,
            "e": formatDayOfMonth,
            "f": formatMicroseconds,
            "H": formatHour24,
            "I": formatHour12,
            "j": formatDayOfYear,
            "L": formatMilliseconds,
            "m": formatMonthNumber,
            "M": formatMinutes,
            "p": formatPeriod,
            "q": formatQuarter,
            "Q": formatUnixTimestamp,
            "s": formatUnixTimestampSeconds,
            "S": formatSeconds,
            "u": formatWeekdayNumberMonday,
            "U": formatWeekNumberSunday,
            "V": formatWeekNumberISO,
            "w": formatWeekdayNumberSunday,
            "W": formatWeekNumberMonday,
            "x": null,
            "X": null,
            "y": formatYear,
            "Y": formatFullYear,
            "Z": formatZone,
            "%": formatLiteralPercent
          };
          var utcFormats = {
            "a": formatUTCShortWeekday,
            "A": formatUTCWeekday,
            "b": formatUTCShortMonth,
            "B": formatUTCMonth,
            "c": null,
            "d": formatUTCDayOfMonth,
            "e": formatUTCDayOfMonth,
            "f": formatUTCMicroseconds,
            "H": formatUTCHour24,
            "I": formatUTCHour12,
            "j": formatUTCDayOfYear,
            "L": formatUTCMilliseconds,
            "m": formatUTCMonthNumber,
            "M": formatUTCMinutes,
            "p": formatUTCPeriod,
            "q": formatUTCQuarter,
            "Q": formatUnixTimestamp,
            "s": formatUnixTimestampSeconds,
            "S": formatUTCSeconds,
            "u": formatUTCWeekdayNumberMonday,
            "U": formatUTCWeekNumberSunday,
            "V": formatUTCWeekNumberISO,
            "w": formatUTCWeekdayNumberSunday,
            "W": formatUTCWeekNumberMonday,
            "x": null,
            "X": null,
            "y": formatUTCYear,
            "Y": formatUTCFullYear,
            "Z": formatUTCZone,
            "%": formatLiteralPercent
          };
          var parses = {
            "a": parseShortWeekday,
            "A": parseWeekday,
            "b": parseShortMonth,
            "B": parseMonth,
            "c": parseLocaleDateTime,
            "d": parseDayOfMonth,
            "e": parseDayOfMonth,
            "f": parseMicroseconds,
            "H": parseHour24,
            "I": parseHour24,
            "j": parseDayOfYear,
            "L": parseMilliseconds,
            "m": parseMonthNumber,
            "M": parseMinutes,
            "p": parsePeriod,
            "q": parseQuarter,
            "Q": parseUnixTimestamp,
            "s": parseUnixTimestampSeconds,
            "S": parseSeconds,
            "u": parseWeekdayNumberMonday,
            "U": parseWeekNumberSunday,
            "V": parseWeekNumberISO,
            "w": parseWeekdayNumberSunday,
            "W": parseWeekNumberMonday,
            "x": parseLocaleDate,
            "X": parseLocaleTime,
            "y": parseYear,
            "Y": parseFullYear,
            "Z": parseZone,
            "%": parseLiteralPercent
          };
          formats.x = newFormat(locale_date, formats);
          formats.X = newFormat(locale_time, formats);
          formats.c = newFormat(locale_dateTime, formats);
          utcFormats.x = newFormat(locale_date, utcFormats);
          utcFormats.X = newFormat(locale_time, utcFormats);
          utcFormats.c = newFormat(locale_dateTime, utcFormats);
          function newFormat(specifier, formats2) {
            return function(date) {
              var string = [], i = -1, j = 0, n = specifier.length, c, pad2, format;
              if (!(date instanceof Date)) date = /* @__PURE__ */ new Date(+date);
              while (++i < n) {
                if (specifier.charCodeAt(i) === 37) {
                  string.push(specifier.slice(j, i));
                  if ((pad2 = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
                  else pad2 = c === "e" ? " " : "0";
                  if (format = formats2[c]) c = format(date, pad2);
                  string.push(c);
                  j = i + 1;
                }
              }
              string.push(specifier.slice(j, i));
              return string.join("");
            };
          }
          function newParse(specifier, Z) {
            return function(string) {
              var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
              if (i != string.length) return null;
              if ("Q" in d) return new Date(d.Q);
              if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
              if (Z && !("Z" in d)) d.Z = 0;
              if ("p" in d) d.H = d.H % 12 + d.p * 12;
              if (d.m === void 0) d.m = "q" in d ? d.q : 0;
              if ("V" in d) {
                if (d.V < 1 || d.V > 53) return null;
                if (!("w" in d)) d.w = 1;
                if ("Z" in d) {
                  week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
                  week = day > 4 || day === 0 ? d3Time.utcMonday.ceil(week) : d3Time.utcMonday(week);
                  week = d3Time.utcDay.offset(week, (d.V - 1) * 7);
                  d.y = week.getUTCFullYear();
                  d.m = week.getUTCMonth();
                  d.d = week.getUTCDate() + (d.w + 6) % 7;
                } else {
                  week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
                  week = day > 4 || day === 0 ? d3Time.timeMonday.ceil(week) : d3Time.timeMonday(week);
                  week = d3Time.timeDay.offset(week, (d.V - 1) * 7);
                  d.y = week.getFullYear();
                  d.m = week.getMonth();
                  d.d = week.getDate() + (d.w + 6) % 7;
                }
              } else if ("W" in d || "U" in d) {
                if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
                day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
                d.m = 0;
                d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
              }
              if ("Z" in d) {
                d.H += d.Z / 100 | 0;
                d.M += d.Z % 100;
                return utcDate(d);
              }
              return localDate(d);
            };
          }
          function parseSpecifier(d, specifier, string, j) {
            var i = 0, n = specifier.length, m = string.length, c, parse;
            while (i < n) {
              if (j >= m) return -1;
              c = specifier.charCodeAt(i++);
              if (c === 37) {
                c = specifier.charAt(i++);
                parse = parses[c in pads ? specifier.charAt(i++) : c];
                if (!parse || (j = parse(d, string, j)) < 0) return -1;
              } else if (c != string.charCodeAt(j++)) {
                return -1;
              }
            }
            return j;
          }
          function parsePeriod(d, string, i) {
            var n = periodRe.exec(string.slice(i));
            return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseShortWeekday(d, string, i) {
            var n = shortWeekdayRe.exec(string.slice(i));
            return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseWeekday(d, string, i) {
            var n = weekdayRe.exec(string.slice(i));
            return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseShortMonth(d, string, i) {
            var n = shortMonthRe.exec(string.slice(i));
            return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseMonth(d, string, i) {
            var n = monthRe.exec(string.slice(i));
            return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseLocaleDateTime(d, string, i) {
            return parseSpecifier(d, locale_dateTime, string, i);
          }
          function parseLocaleDate(d, string, i) {
            return parseSpecifier(d, locale_date, string, i);
          }
          function parseLocaleTime(d, string, i) {
            return parseSpecifier(d, locale_time, string, i);
          }
          function formatShortWeekday(d) {
            return locale_shortWeekdays[d.getDay()];
          }
          function formatWeekday(d) {
            return locale_weekdays[d.getDay()];
          }
          function formatShortMonth(d) {
            return locale_shortMonths[d.getMonth()];
          }
          function formatMonth(d) {
            return locale_months[d.getMonth()];
          }
          function formatPeriod(d) {
            return locale_periods[+(d.getHours() >= 12)];
          }
          function formatQuarter(d) {
            return 1 + ~~(d.getMonth() / 3);
          }
          function formatUTCShortWeekday(d) {
            return locale_shortWeekdays[d.getUTCDay()];
          }
          function formatUTCWeekday(d) {
            return locale_weekdays[d.getUTCDay()];
          }
          function formatUTCShortMonth(d) {
            return locale_shortMonths[d.getUTCMonth()];
          }
          function formatUTCMonth(d) {
            return locale_months[d.getUTCMonth()];
          }
          function formatUTCPeriod(d) {
            return locale_periods[+(d.getUTCHours() >= 12)];
          }
          function formatUTCQuarter(d) {
            return 1 + ~~(d.getUTCMonth() / 3);
          }
          return {
            format: function(specifier) {
              var f = newFormat(specifier += "", formats);
              f.toString = function() {
                return specifier;
              };
              return f;
            },
            parse: function(specifier) {
              var p = newParse(specifier += "", false);
              p.toString = function() {
                return specifier;
              };
              return p;
            },
            utcFormat: function(specifier) {
              var f = newFormat(specifier += "", utcFormats);
              f.toString = function() {
                return specifier;
              };
              return f;
            },
            utcParse: function(specifier) {
              var p = newParse(specifier += "", true);
              p.toString = function() {
                return specifier;
              };
              return p;
            }
          };
        }
        var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
        function pad(value, fill, width) {
          var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
          return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
        }
        function requote(s) {
          return s.replace(requoteRe, "\\$&");
        }
        function formatRe(names) {
          return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
        }
        function formatLookup(names) {
          var map = {}, i = -1, n = names.length;
          while (++i < n) map[names[i].toLowerCase()] = i;
          return map;
        }
        function parseWeekdayNumberSunday(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 1));
          return n ? (d.w = +n[0], i + n[0].length) : -1;
        }
        function parseWeekdayNumberMonday(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 1));
          return n ? (d.u = +n[0], i + n[0].length) : -1;
        }
        function parseWeekNumberSunday(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.U = +n[0], i + n[0].length) : -1;
        }
        function parseWeekNumberISO(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.V = +n[0], i + n[0].length) : -1;
        }
        function parseWeekNumberMonday(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.W = +n[0], i + n[0].length) : -1;
        }
        function parseFullYear(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 4));
          return n ? (d.y = +n[0], i + n[0].length) : -1;
        }
        function parseYear(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
        }
        function parseZone(d, string, i) {
          var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
          return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
        }
        function parseQuarter(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 1));
          return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
        }
        function parseMonthNumber(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
        }
        function parseDayOfMonth(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.d = +n[0], i + n[0].length) : -1;
        }
        function parseDayOfYear(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 3));
          return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
        }
        function parseHour24(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.H = +n[0], i + n[0].length) : -1;
        }
        function parseMinutes(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.M = +n[0], i + n[0].length) : -1;
        }
        function parseSeconds(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.S = +n[0], i + n[0].length) : -1;
        }
        function parseMilliseconds(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 3));
          return n ? (d.L = +n[0], i + n[0].length) : -1;
        }
        function parseMicroseconds(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 6));
          return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
        }
        function parseLiteralPercent(d, string, i) {
          var n = percentRe.exec(string.slice(i, i + 1));
          return n ? i + n[0].length : -1;
        }
        function parseUnixTimestamp(d, string, i) {
          var n = numberRe.exec(string.slice(i));
          return n ? (d.Q = +n[0], i + n[0].length) : -1;
        }
        function parseUnixTimestampSeconds(d, string, i) {
          var n = numberRe.exec(string.slice(i));
          return n ? (d.s = +n[0], i + n[0].length) : -1;
        }
        function formatDayOfMonth(d, p) {
          return pad(d.getDate(), p, 2);
        }
        function formatHour24(d, p) {
          return pad(d.getHours(), p, 2);
        }
        function formatHour12(d, p) {
          return pad(d.getHours() % 12 || 12, p, 2);
        }
        function formatDayOfYear(d, p) {
          return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
        }
        function formatMilliseconds(d, p) {
          return pad(d.getMilliseconds(), p, 3);
        }
        function formatMicroseconds(d, p) {
          return formatMilliseconds(d, p) + "000";
        }
        function formatMonthNumber(d, p) {
          return pad(d.getMonth() + 1, p, 2);
        }
        function formatMinutes(d, p) {
          return pad(d.getMinutes(), p, 2);
        }
        function formatSeconds(d, p) {
          return pad(d.getSeconds(), p, 2);
        }
        function formatWeekdayNumberMonday(d) {
          var day = d.getDay();
          return day === 0 ? 7 : day;
        }
        function formatWeekNumberSunday(d, p) {
          return pad(d3Time.timeSunday.count(d3Time.timeYear(d) - 1, d), p, 2);
        }
        function formatWeekNumberISO(d, p) {
          var day = d.getDay();
          d = day >= 4 || day === 0 ? d3Time.timeThursday(d) : d3Time.timeThursday.ceil(d);
          return pad(d3Time.timeThursday.count(d3Time.timeYear(d), d) + (d3Time.timeYear(d).getDay() === 4), p, 2);
        }
        function formatWeekdayNumberSunday(d) {
          return d.getDay();
        }
        function formatWeekNumberMonday(d, p) {
          return pad(d3Time.timeMonday.count(d3Time.timeYear(d) - 1, d), p, 2);
        }
        function formatYear(d, p) {
          return pad(d.getFullYear() % 100, p, 2);
        }
        function formatFullYear(d, p) {
          return pad(d.getFullYear() % 1e4, p, 4);
        }
        function formatZone(d) {
          var z = d.getTimezoneOffset();
          return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
        }
        function formatUTCDayOfMonth(d, p) {
          return pad(d.getUTCDate(), p, 2);
        }
        function formatUTCHour24(d, p) {
          return pad(d.getUTCHours(), p, 2);
        }
        function formatUTCHour12(d, p) {
          return pad(d.getUTCHours() % 12 || 12, p, 2);
        }
        function formatUTCDayOfYear(d, p) {
          return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
        }
        function formatUTCMilliseconds(d, p) {
          return pad(d.getUTCMilliseconds(), p, 3);
        }
        function formatUTCMicroseconds(d, p) {
          return formatUTCMilliseconds(d, p) + "000";
        }
        function formatUTCMonthNumber(d, p) {
          return pad(d.getUTCMonth() + 1, p, 2);
        }
        function formatUTCMinutes(d, p) {
          return pad(d.getUTCMinutes(), p, 2);
        }
        function formatUTCSeconds(d, p) {
          return pad(d.getUTCSeconds(), p, 2);
        }
        function formatUTCWeekdayNumberMonday(d) {
          var dow = d.getUTCDay();
          return dow === 0 ? 7 : dow;
        }
        function formatUTCWeekNumberSunday(d, p) {
          return pad(d3Time.utcSunday.count(d3Time.utcYear(d) - 1, d), p, 2);
        }
        function formatUTCWeekNumberISO(d, p) {
          var day = d.getUTCDay();
          d = day >= 4 || day === 0 ? d3Time.utcThursday(d) : d3Time.utcThursday.ceil(d);
          return pad(d3Time.utcThursday.count(d3Time.utcYear(d), d) + (d3Time.utcYear(d).getUTCDay() === 4), p, 2);
        }
        function formatUTCWeekdayNumberSunday(d) {
          return d.getUTCDay();
        }
        function formatUTCWeekNumberMonday(d, p) {
          return pad(d3Time.utcMonday.count(d3Time.utcYear(d) - 1, d), p, 2);
        }
        function formatUTCYear(d, p) {
          return pad(d.getUTCFullYear() % 100, p, 2);
        }
        function formatUTCFullYear(d, p) {
          return pad(d.getUTCFullYear() % 1e4, p, 4);
        }
        function formatUTCZone() {
          return "+0000";
        }
        function formatLiteralPercent() {
          return "%";
        }
        function formatUnixTimestamp(d) {
          return +d;
        }
        function formatUnixTimestampSeconds(d) {
          return Math.floor(+d / 1e3);
        }
        var locale;
        defaultLocale({
          dateTime: "%x, %X",
          date: "%-m/%-d/%Y",
          time: "%-I:%M:%S %p",
          periods: ["AM", "PM"],
          days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
          shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
        });
        function defaultLocale(definition) {
          locale = formatLocale(definition);
          exports2.timeFormat = locale.format;
          exports2.timeParse = locale.parse;
          exports2.utcFormat = locale.utcFormat;
          exports2.utcParse = locale.utcParse;
          return locale;
        }
        var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
        function formatIsoNative(date) {
          return date.toISOString();
        }
        var formatIso = Date.prototype.toISOString ? formatIsoNative : exports2.utcFormat(isoSpecifier);
        function parseIsoNative(string) {
          var date = new Date(string);
          return isNaN(date) ? null : date;
        }
        var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : exports2.utcParse(isoSpecifier);
        exports2.isoFormat = formatIso;
        exports2.isoParse = parseIso;
        exports2.timeFormatDefaultLocale = defaultLocale;
        exports2.timeFormatLocale = formatLocale;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/d3-format/dist/d3-format.js
  var require_d3_format = __commonJS({
    "node_modules/d3-format/dist/d3-format.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && false ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        function formatDecimal(x) {
          return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
        }
        function formatDecimalParts(x, p) {
          if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null;
          var i, coefficient = x.slice(0, i);
          return [
            coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
            +x.slice(i + 1)
          ];
        }
        function exponent(x) {
          return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
        }
        function formatGroup(grouping, thousands) {
          return function(value, width) {
            var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
            while (i > 0 && g > 0) {
              if (length + g + 1 > width) g = Math.max(1, width - length);
              t.push(value.substring(i -= g, i + g));
              if ((length += g + 1) > width) break;
              g = grouping[j = (j + 1) % grouping.length];
            }
            return t.reverse().join(thousands);
          };
        }
        function formatNumerals(numerals) {
          return function(value) {
            return value.replace(/[0-9]/g, function(i) {
              return numerals[+i];
            });
          };
        }
        var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
        function formatSpecifier(specifier) {
          if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
          var match;
          return new FormatSpecifier({
            fill: match[1],
            align: match[2],
            sign: match[3],
            symbol: match[4],
            zero: match[5],
            width: match[6],
            comma: match[7],
            precision: match[8] && match[8].slice(1),
            trim: match[9],
            type: match[10]
          });
        }
        formatSpecifier.prototype = FormatSpecifier.prototype;
        function FormatSpecifier(specifier) {
          this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
          this.align = specifier.align === void 0 ? ">" : specifier.align + "";
          this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
          this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
          this.zero = !!specifier.zero;
          this.width = specifier.width === void 0 ? void 0 : +specifier.width;
          this.comma = !!specifier.comma;
          this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
          this.trim = !!specifier.trim;
          this.type = specifier.type === void 0 ? "" : specifier.type + "";
        }
        FormatSpecifier.prototype.toString = function() {
          return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
        };
        function formatTrim(s) {
          out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
            switch (s[i]) {
              case ".":
                i0 = i1 = i;
                break;
              case "0":
                if (i0 === 0) i0 = i;
                i1 = i;
                break;
              default:
                if (!+s[i]) break out;
                if (i0 > 0) i0 = 0;
                break;
            }
          }
          return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
        }
        var prefixExponent;
        function formatPrefixAuto(x, p) {
          var d = formatDecimalParts(x, p);
          if (!d) return x + "";
          var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
          return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
        }
        function formatRounded(x, p) {
          var d = formatDecimalParts(x, p);
          if (!d) return x + "";
          var coefficient = d[0], exponent2 = d[1];
          return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
        }
        var formatTypes = {
          "%": function(x, p) {
            return (x * 100).toFixed(p);
          },
          "b": function(x) {
            return Math.round(x).toString(2);
          },
          "c": function(x) {
            return x + "";
          },
          "d": formatDecimal,
          "e": function(x, p) {
            return x.toExponential(p);
          },
          "f": function(x, p) {
            return x.toFixed(p);
          },
          "g": function(x, p) {
            return x.toPrecision(p);
          },
          "o": function(x) {
            return Math.round(x).toString(8);
          },
          "p": function(x, p) {
            return formatRounded(x * 100, p);
          },
          "r": formatRounded,
          "s": formatPrefixAuto,
          "X": function(x) {
            return Math.round(x).toString(16).toUpperCase();
          },
          "x": function(x) {
            return Math.round(x).toString(16);
          }
        };
        function identity(x) {
          return x;
        }
        var map = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
        function formatLocale(locale2) {
          var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity : formatGroup(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity : formatNumerals(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "-" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
          function newFormat(specifier) {
            specifier = formatSpecifier(specifier);
            var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
            if (type === "n") comma = true, type = "g";
            else if (!formatTypes[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
            if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";
            var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
            var formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
            precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
            function format(value) {
              var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
              if (type === "c") {
                valueSuffix = formatType(value) + valueSuffix;
                value = "";
              } else {
                value = +value;
                var valueNegative = value < 0 || 1 / value < 0;
                value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
                if (trim) value = formatTrim(value);
                if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;
                valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
                valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
                if (maybeSuffix) {
                  i = -1, n = value.length;
                  while (++i < n) {
                    if (c = value.charCodeAt(i), 48 > c || c > 57) {
                      valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                      value = value.slice(0, i);
                      break;
                    }
                  }
                }
              }
              if (comma && !zero) value = group(value, Infinity);
              var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
              if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
              switch (align) {
                case "<":
                  value = valuePrefix + value + valueSuffix + padding;
                  break;
                case "=":
                  value = valuePrefix + padding + value + valueSuffix;
                  break;
                case "^":
                  value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
                  break;
                default:
                  value = padding + valuePrefix + value + valueSuffix;
                  break;
              }
              return numerals(value);
            }
            format.toString = function() {
              return specifier + "";
            };
            return format;
          }
          function formatPrefix(specifier, value) {
            var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
            return function(value2) {
              return f(k * value2) + prefix;
            };
          }
          return {
            format: newFormat,
            formatPrefix
          };
        }
        var locale;
        defaultLocale({
          decimal: ".",
          thousands: ",",
          grouping: [3],
          currency: ["$", ""],
          minus: "-"
        });
        function defaultLocale(definition) {
          locale = formatLocale(definition);
          exports2.format = locale.format;
          exports2.formatPrefix = locale.formatPrefix;
          return locale;
        }
        function precisionFixed(step) {
          return Math.max(0, -exponent(Math.abs(step)));
        }
        function precisionPrefix(step, value) {
          return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
        }
        function precisionRound(step, max) {
          step = Math.abs(step), max = Math.abs(max) - step;
          return Math.max(0, exponent(max) - exponent(step)) + 1;
        }
        exports2.FormatSpecifier = FormatSpecifier;
        exports2.formatDefaultLocale = defaultLocale;
        exports2.formatLocale = formatLocale;
        exports2.formatSpecifier = formatSpecifier;
        exports2.precisionFixed = precisionFixed;
        exports2.precisionPrefix = precisionPrefix;
        exports2.precisionRound = precisionRound;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/is-string-blank/index.js
  var require_is_string_blank = __commonJS({
    "node_modules/is-string-blank/index.js"(exports, module) {
      "use strict";
      module.exports = function(str) {
        var l = str.length, a;
        for (var i = 0; i < l; i++) {
          a = str.charCodeAt(i);
          if ((a < 9 || a > 13) && a !== 32 && a !== 133 && a !== 160 && a !== 5760 && a !== 6158 && (a < 8192 || a > 8205) && a !== 8232 && a !== 8233 && a !== 8239 && a !== 8287 && a !== 8288 && a !== 12288 && a !== 65279) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/fast-isnumeric/index.js
  var require_fast_isnumeric = __commonJS({
    "node_modules/fast-isnumeric/index.js"(exports, module) {
      "use strict";
      var allBlankCharCodes = require_is_string_blank();
      module.exports = function(n) {
        var type = typeof n;
        if (type === "string") {
          var original = n;
          n = +n;
          if (n === 0 && allBlankCharCodes(original)) return false;
        } else if (type !== "number") return false;
        return n - n < 1;
      };
    }
  });

  // src/constants/numerical.js
  var require_numerical = __commonJS({
    "src/constants/numerical.js"(exports, module) {
      "use strict";
      module.exports = {
        /**
         * Standardize all missing data in calcdata to use undefined
         * never null or NaN.
         * That way we can use !==undefined, or !== BADNUM,
         * to test for real data
         */
        BADNUM: void 0,
        /*
         * Limit certain operations to well below floating point max value
         * to avoid glitches: Make sure that even when you multiply it by the
         * number of pixels on a giant screen it still works
         */
        FP_SAFE: Number.MAX_VALUE * 1e-4,
        /*
         * conversion of date units to milliseconds
         * year and month constants are marked "AVG"
         * to remind us that not all years and months
         * have the same length
         */
        ONEMAXYEAR: 316224e5,
        // 366 * ONEDAY
        ONEAVGYEAR: 315576e5,
        // 365.25 days
        ONEMINYEAR: 31536e6,
        // 365 * ONEDAY
        ONEMAXQUARTER: 79488e5,
        // 92 * ONEDAY
        ONEAVGQUARTER: 78894e5,
        // 1/4 of ONEAVGYEAR
        ONEMINQUARTER: 76896e5,
        // 89 * ONEDAY
        ONEMAXMONTH: 26784e5,
        // 31 * ONEDAY
        ONEAVGMONTH: 26298e5,
        // 1/12 of ONEAVGYEAR
        ONEMINMONTH: 24192e5,
        // 28 * ONEDAY
        ONEWEEK: 6048e5,
        // 7 * ONEDAY
        ONEDAY: 864e5,
        // 24 * ONEHOUR
        ONEHOUR: 36e5,
        ONEMIN: 6e4,
        ONESEC: 1e3,
        ONEMILLI: 1,
        ONEMICROSEC: 1e-3,
        /*
         * For fast conversion btwn world calendars and epoch ms, the Julian Day Number
         * of the unix epoch. From calendars.instance().newDate(1970, 1, 1).toJD()
         */
        EPOCHJD: 24405875e-1,
        /*
         * Are two values nearly equal? Compare to 1PPM
         */
        ALMOST_EQUAL: 1 - 1e-6,
        /*
         * If we're asked to clip a non-positive log value, how far off-screen
         * do we put it?
         */
        LOG_CLIP: 10,
        /*
         * not a number, but for displaying numbers: the "minus sign" symbol is
         * wider than the regular ascii dash "-"
         */
        MINUS_SIGN: "\u2212"
      };
    }
  });

  // node_modules/base64-arraybuffer/dist/base64-arraybuffer.umd.js
  var require_base64_arraybuffer_umd = __commonJS({
    "node_modules/base64-arraybuffer/dist/base64-arraybuffer.umd.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && false ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2["base64-arraybuffer"] = {}));
      })(exports, function(exports2) {
        "use strict";
        var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
        for (var i = 0; i < chars.length; i++) {
          lookup[chars.charCodeAt(i)] = i;
        }
        var encode = function(arraybuffer) {
          var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = "";
          for (i2 = 0; i2 < len; i2 += 3) {
            base64 += chars[bytes[i2] >> 2];
            base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
            base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
            base64 += chars[bytes[i2 + 2] & 63];
          }
          if (len % 3 === 2) {
            base64 = base64.substring(0, base64.length - 1) + "=";
          } else if (len % 3 === 1) {
            base64 = base64.substring(0, base64.length - 2) + "==";
          }
          return base64;
        };
        var decode = function(base64) {
          var bufferLength = base64.length * 0.75, len = base64.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
          if (base64[base64.length - 1] === "=") {
            bufferLength--;
            if (base64[base64.length - 2] === "=") {
              bufferLength--;
            }
          }
          var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
          for (i2 = 0; i2 < len; i2 += 4) {
            encoded1 = lookup[base64.charCodeAt(i2)];
            encoded2 = lookup[base64.charCodeAt(i2 + 1)];
            encoded3 = lookup[base64.charCodeAt(i2 + 2)];
            encoded4 = lookup[base64.charCodeAt(i2 + 3)];
            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return arraybuffer;
        };
        exports2.decode = decode;
        exports2.encode = encode;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // src/lib/is_plain_object.js
  var require_is_plain_object = __commonJS({
    "src/lib/is_plain_object.js"(exports, module) {
      "use strict";
      module.exports = function isPlainObject(obj) {
        if (window && window.process && window.process.versions) {
          return Object.prototype.toString.call(obj) === "[object Object]";
        }
        return Object.prototype.toString.call(obj) === "[object Object]" && Object.getPrototypeOf(obj).hasOwnProperty("hasOwnProperty");
      };
    }
  });

  // src/lib/array.js
  var require_array = __commonJS({
    "src/lib/array.js"(exports) {
      "use strict";
      var b64decode = require_base64_arraybuffer_umd().decode;
      var isPlainObject = require_is_plain_object();
      var isArray = Array.isArray;
      var ab = ArrayBuffer;
      var dv = DataView;
      function isTypedArray(a) {
        return ab.isView(a) && !(a instanceof dv);
      }
      exports.isTypedArray = isTypedArray;
      function isArrayOrTypedArray(a) {
        return isArray(a) || isTypedArray(a);
      }
      exports.isArrayOrTypedArray = isArrayOrTypedArray;
      function isArray1D(a) {
        return !isArrayOrTypedArray(a[0]);
      }
      exports.isArray1D = isArray1D;
      exports.ensureArray = function(out, n) {
        if (!isArray(out)) out = [];
        out.length = n;
        return out;
      };
      var typedArrays = {
        u1c: typeof Uint8ClampedArray === "undefined" ? void 0 : Uint8ClampedArray,
        // not supported in numpy?
        i1: typeof Int8Array === "undefined" ? void 0 : Int8Array,
        u1: typeof Uint8Array === "undefined" ? void 0 : Uint8Array,
        i2: typeof Int16Array === "undefined" ? void 0 : Int16Array,
        u2: typeof Uint16Array === "undefined" ? void 0 : Uint16Array,
        i4: typeof Int32Array === "undefined" ? void 0 : Int32Array,
        u4: typeof Uint32Array === "undefined" ? void 0 : Uint32Array,
        f4: typeof Float32Array === "undefined" ? void 0 : Float32Array,
        f8: typeof Float64Array === "undefined" ? void 0 : Float64Array
        /* TODO: potentially add Big Int
        
            i8: typeof BigInt64Array === 'undefined' ? undefined :
                       BigInt64Array,
        
            u8: typeof BigUint64Array === 'undefined' ? undefined :
                       BigUint64Array,
            */
      };
      typedArrays.uint8c = typedArrays.u1c;
      typedArrays.uint8 = typedArrays.u1;
      typedArrays.int8 = typedArrays.i1;
      typedArrays.uint16 = typedArrays.u2;
      typedArrays.int16 = typedArrays.i2;
      typedArrays.uint32 = typedArrays.u4;
      typedArrays.int32 = typedArrays.i4;
      typedArrays.float32 = typedArrays.f4;
      typedArrays.float64 = typedArrays.f8;
      function isArrayBuffer(a) {
        return a.constructor === ArrayBuffer;
      }
      exports.isArrayBuffer = isArrayBuffer;
      exports.decodeTypedArraySpec = function(vIn) {
        var out = [];
        var v = coerceTypedArraySpec(vIn);
        var dtype = v.dtype;
        var T = typedArrays[dtype];
        if (!T) throw new Error('Error in dtype: "' + dtype + '"');
        var BYTES_PER_ELEMENT = T.BYTES_PER_ELEMENT;
        var buffer = v.bdata;
        if (!isArrayBuffer(buffer)) {
          buffer = b64decode(buffer);
        }
        var shape = v.shape === void 0 ? (
          // detect 1-d length
          [buffer.byteLength / BYTES_PER_ELEMENT]
        ) : (
          // convert number to string and split to array
          ("" + v.shape).split(",")
        );
        shape.reverse();
        var ndim = shape.length;
        var nj, j;
        var ni = +shape[0];
        var rowBytes = BYTES_PER_ELEMENT * ni;
        var pos = 0;
        if (ndim === 1) {
          out = new T(buffer);
        } else if (ndim === 2) {
          nj = +shape[1];
          for (j = 0; j < nj; j++) {
            out[j] = new T(buffer, pos, ni);
            pos += rowBytes;
          }
        } else if (ndim === 3) {
          nj = +shape[1];
          var nk = +shape[2];
          for (var k = 0; k < nk; k++) {
            out[k] = [];
            for (j = 0; j < nj; j++) {
              out[k][j] = new T(buffer, pos, ni);
              pos += rowBytes;
            }
          }
        } else {
          throw new Error("ndim: " + ndim + 'is not supported with the shape:"' + v.shape + '"');
        }
        out.bdata = v.bdata;
        out.dtype = v.dtype;
        out.shape = shape.reverse().join(",");
        vIn._inputArray = out;
        return out;
      };
      exports.isTypedArraySpec = function(v) {
        return isPlainObject(v) && v.hasOwnProperty("dtype") && typeof v.dtype === "string" && v.hasOwnProperty("bdata") && (typeof v.bdata === "string" || isArrayBuffer(v.bdata)) && (v.shape === void 0 || v.hasOwnProperty("shape") && (typeof v.shape === "string" || typeof v.shape === "number"));
      };
      function coerceTypedArraySpec(v) {
        return {
          bdata: v.bdata,
          dtype: v.dtype,
          shape: v.shape
        };
      }
      exports.concat = function() {
        var args = [];
        var allArray = true;
        var totalLen = 0;
        var _constructor, arg0, i, argi, posi, leni, out, j;
        for (i = 0; i < arguments.length; i++) {
          argi = arguments[i];
          leni = argi.length;
          if (leni) {
            if (arg0) args.push(argi);
            else {
              arg0 = argi;
              posi = leni;
            }
            if (isArray(argi)) {
              _constructor = false;
            } else {
              allArray = false;
              if (!totalLen) {
                _constructor = argi.constructor;
              } else if (_constructor !== argi.constructor) {
                _constructor = false;
              }
            }
            totalLen += leni;
          }
        }
        if (!totalLen) return [];
        if (!args.length) return arg0;
        if (allArray) return arg0.concat.apply(arg0, args);
        if (_constructor) {
          out = new _constructor(totalLen);
          out.set(arg0);
          for (i = 0; i < args.length; i++) {
            argi = args[i];
            out.set(argi, posi);
            posi += argi.length;
          }
          return out;
        }
        out = new Array(totalLen);
        for (j = 0; j < arg0.length; j++) out[j] = arg0[j];
        for (i = 0; i < args.length; i++) {
          argi = args[i];
          for (j = 0; j < argi.length; j++) out[posi + j] = argi[j];
          posi += j;
        }
        return out;
      };
      exports.maxRowLength = function(z) {
        return _rowLength(z, Math.max, 0);
      };
      exports.minRowLength = function(z) {
        return _rowLength(z, Math.min, Infinity);
      };
      function _rowLength(z, fn, len0) {
        if (isArrayOrTypedArray(z)) {
          if (isArrayOrTypedArray(z[0])) {
            var len = len0;
            for (var i = 0; i < z.length; i++) {
              len = fn(len, z[i].length);
            }
            return len;
          } else {
            return z.length;
          }
        }
        return 0;
      }
    }
  });

  // src/lib/nested_property.js
  var require_nested_property = __commonJS({
    "src/lib/nested_property.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var isArrayOrTypedArray = require_array().isArrayOrTypedArray;
      module.exports = function nestedProperty(container, propStr) {
        if (isNumeric(propStr)) propStr = String(propStr);
        else if (typeof propStr !== "string" || propStr.substr(propStr.length - 4) === "[-1]") {
          throw "bad property string";
        }
        var propParts = propStr.split(".");
        var indexed;
        var indices;
        var i, j;
        for (j = 0; j < propParts.length; j++) {
          if (String(propParts[j]).slice(0, 2) === "__") {
            throw "bad property string";
          }
        }
        j = 0;
        while (j < propParts.length) {
          indexed = String(propParts[j]).match(/^([^\[\]]*)((\[\-?[0-9]*\])+)$/);
          if (indexed) {
            if (indexed[1]) propParts[j] = indexed[1];
            else if (j === 0) propParts.splice(0, 1);
            else throw "bad property string";
            indices = indexed[2].substr(1, indexed[2].length - 2).split("][");
            for (i = 0; i < indices.length; i++) {
              j++;
              propParts.splice(j, 0, Number(indices[i]));
            }
          }
          j++;
        }
        if (typeof container !== "object") {
          return badContainer(container, propStr, propParts);
        }
        return {
          set: npSet(container, propParts, propStr),
          get: npGet(container, propParts),
          astr: propStr,
          parts: propParts,
          obj: container
        };
      };
      function npGet(cont, parts) {
        return function(retainNull) {
          var curCont = cont;
          var curPart;
          var allSame;
          var out;
          var i;
          var j;
          for (i = 0; i < parts.length - 1; i++) {
            curPart = parts[i];
            if (curPart === -1) {
              allSame = true;
              out = [];
              for (j = 0; j < curCont.length; j++) {
                out[j] = npGet(curCont[j], parts.slice(i + 1))(retainNull);
                if (out[j] !== out[0]) allSame = false;
              }
              return allSame ? out[0] : out;
            }
            if (typeof curPart === "number" && !isArrayOrTypedArray(curCont)) {
              return void 0;
            }
            curCont = curCont[curPart];
            if (typeof curCont !== "object" || curCont === null) {
              return void 0;
            }
          }
          if (typeof curCont !== "object" || curCont === null) return void 0;
          out = curCont[parts[i]];
          if (!retainNull && out === null) return void 0;
          return out;
        };
      }
      var ARGS_PATTERN = /(^|\.)args\[/;
      function isDeletable(val, propStr) {
        return val === void 0 || val === null && !propStr.match(ARGS_PATTERN);
      }
      function npSet(cont, parts, propStr) {
        return function(val) {
          var curCont = cont;
          var propPart = "";
          var containerLevels = [[cont, propPart]];
          var toDelete = isDeletable(val, propStr);
          var curPart;
          var i;
          for (i = 0; i < parts.length - 1; i++) {
            curPart = parts[i];
            if (typeof curPart === "number" && !isArrayOrTypedArray(curCont)) {
              throw "array index but container is not an array";
            }
            if (curPart === -1) {
              toDelete = !setArrayAll(curCont, parts.slice(i + 1), val, propStr);
              if (toDelete) break;
              else return;
            }
            if (!checkNewContainer(curCont, curPart, parts[i + 1], toDelete)) {
              break;
            }
            curCont = curCont[curPart];
            if (typeof curCont !== "object" || curCont === null) {
              throw "container is not an object";
            }
            propPart = joinPropStr(propPart, curPart);
            containerLevels.push([curCont, propPart]);
          }
          if (toDelete) {
            if (i === parts.length - 1) {
              delete curCont[parts[i]];
              if (Array.isArray(curCont) && +parts[i] === curCont.length - 1) {
                while (curCont.length && curCont[curCont.length - 1] === void 0) {
                  curCont.pop();
                }
              }
            }
          } else curCont[parts[i]] = val;
        };
      }
      function joinPropStr(propStr, newPart) {
        var toAdd = newPart;
        if (isNumeric(newPart)) toAdd = "[" + newPart + "]";
        else if (propStr) toAdd = "." + newPart;
        return propStr + toAdd;
      }
      function setArrayAll(containerArray, innerParts, val, propStr) {
        var arrayVal = isArrayOrTypedArray(val);
        var allSet = true;
        var thisVal = val;
        var thisPropStr = propStr.replace("-1", 0);
        var deleteThis = arrayVal ? false : isDeletable(val, thisPropStr);
        var firstPart = innerParts[0];
        var i;
        for (i = 0; i < containerArray.length; i++) {
          thisPropStr = propStr.replace("-1", i);
          if (arrayVal) {
            thisVal = val[i % val.length];
            deleteThis = isDeletable(thisVal, thisPropStr);
          }
          if (deleteThis) allSet = false;
          if (!checkNewContainer(containerArray, i, firstPart, deleteThis)) {
            continue;
          }
          npSet(containerArray[i], innerParts, propStr.replace("-1", i))(thisVal);
        }
        return allSet;
      }
      function checkNewContainer(container, part, nextPart, toDelete) {
        if (container[part] === void 0) {
          if (toDelete) return false;
          if (typeof nextPart === "number") container[part] = [];
          else container[part] = {};
        }
        return true;
      }
      function badContainer(container, propStr, propParts) {
        return {
          set: function() {
            throw "bad container";
          },
          get: function() {
          },
          astr: propStr,
          parts: propParts,
          obj: container
        };
      }
    }
  });

  // src/lib/keyed_container.js
  var require_keyed_container = __commonJS({
    "src/lib/keyed_container.js"(exports, module) {
      "use strict";
      var nestedProperty = require_nested_property();
      var SIMPLE_PROPERTY_REGEX = /^\w*$/;
      var NONE = 0;
      var NAME = 1;
      var VALUE = 2;
      var BOTH = 3;
      var UNSET = 4;
      module.exports = function keyedContainer(baseObj, path, keyName, valueName) {
        keyName = keyName || "name";
        valueName = valueName || "value";
        var i, arr, baseProp;
        var changeTypes = {};
        if (path && path.length) {
          baseProp = nestedProperty(baseObj, path);
          arr = baseProp.get();
        } else {
          arr = baseObj;
        }
        path = path || "";
        var indexLookup = {};
        if (arr) {
          for (i = 0; i < arr.length; i++) {
            indexLookup[arr[i][keyName]] = i;
          }
        }
        var isSimpleValueProp = SIMPLE_PROPERTY_REGEX.test(valueName);
        var obj = {
          set: function(name, value) {
            var changeType = value === null ? UNSET : NONE;
            if (!arr) {
              if (!baseProp || changeType === UNSET) return;
              arr = [];
              baseProp.set(arr);
            }
            var idx = indexLookup[name];
            if (idx === void 0) {
              if (changeType === UNSET) return;
              changeType = changeType | BOTH;
              idx = arr.length;
              indexLookup[name] = idx;
            } else if (value !== (isSimpleValueProp ? arr[idx][valueName] : nestedProperty(arr[idx], valueName).get())) {
              changeType = changeType | VALUE;
            }
            var newValue = arr[idx] = arr[idx] || {};
            newValue[keyName] = name;
            if (isSimpleValueProp) {
              newValue[valueName] = value;
            } else {
              nestedProperty(newValue, valueName).set(value);
            }
            if (value !== null) {
              changeType = changeType & ~UNSET;
            }
            changeTypes[idx] = changeTypes[idx] | changeType;
            return obj;
          },
          get: function(name) {
            if (!arr) return;
            var idx = indexLookup[name];
            if (idx === void 0) {
              return void 0;
            } else if (isSimpleValueProp) {
              return arr[idx][valueName];
            } else {
              return nestedProperty(arr[idx], valueName).get();
            }
          },
          rename: function(name, newName) {
            var idx = indexLookup[name];
            if (idx === void 0) return obj;
            changeTypes[idx] = changeTypes[idx] | NAME;
            indexLookup[newName] = idx;
            delete indexLookup[name];
            arr[idx][keyName] = newName;
            return obj;
          },
          remove: function(name) {
            var idx = indexLookup[name];
            if (idx === void 0) return obj;
            var object = arr[idx];
            if (Object.keys(object).length > 2) {
              changeTypes[idx] = changeTypes[idx] | VALUE;
              return obj.set(name, null);
            }
            if (isSimpleValueProp) {
              for (i = idx; i < arr.length; i++) {
                changeTypes[i] = changeTypes[i] | BOTH;
              }
              for (i = idx; i < arr.length; i++) {
                indexLookup[arr[i][keyName]]--;
              }
              arr.splice(idx, 1);
              delete indexLookup[name];
            } else {
              nestedProperty(object, valueName).set(null);
              changeTypes[idx] = changeTypes[idx] | VALUE | UNSET;
            }
            return obj;
          },
          constructUpdate: function() {
            var astr, idx;
            var update = {};
            var changed = Object.keys(changeTypes);
            for (var i2 = 0; i2 < changed.length; i2++) {
              idx = changed[i2];
              astr = path + "[" + idx + "]";
              if (arr[idx]) {
                if (changeTypes[idx] & NAME) {
                  update[astr + "." + keyName] = arr[idx][keyName];
                }
                if (changeTypes[idx] & VALUE) {
                  if (isSimpleValueProp) {
                    update[astr + "." + valueName] = changeTypes[idx] & UNSET ? null : arr[idx][valueName];
                  } else {
                    update[astr + "." + valueName] = changeTypes[idx] & UNSET ? null : nestedProperty(arr[idx], valueName).get();
                  }
                }
              } else {
                update[astr] = null;
              }
            }
            return update;
          }
        };
        return obj;
      };
    }
  });

  // src/lib/relative_attr.js
  var require_relative_attr = __commonJS({
    "src/lib/relative_attr.js"(exports, module) {
      "use strict";
      var ASCEND = /^(.*)(\.[^\.\[\]]+|\[\d\])$/;
      var SIMPLEATTR = /^[^\.\[\]]+$/;
      module.exports = function(baseAttr, relativeAttr) {
        while (relativeAttr) {
          var match = baseAttr.match(ASCEND);
          if (match) baseAttr = match[1];
          else if (baseAttr.match(SIMPLEATTR)) baseAttr = "";
          else throw new Error("bad relativeAttr call:" + [baseAttr, relativeAttr]);
          if (relativeAttr.charAt(0) === "^") relativeAttr = relativeAttr.slice(1);
          else break;
        }
        if (baseAttr && relativeAttr.charAt(0) !== "[") {
          return baseAttr + "." + relativeAttr;
        }
        return baseAttr + relativeAttr;
      };
    }
  });

  // src/lib/to_log_range.js
  var require_to_log_range = __commonJS({
    "src/lib/to_log_range.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      module.exports = function toLogRange(val, range) {
        if (val > 0) return Math.log(val) / Math.LN10;
        var newVal = Math.log(Math.min(range[0], range[1])) / Math.LN10;
        if (!isNumeric(newVal)) newVal = Math.log(Math.max(range[0], range[1])) / Math.LN10 - 6;
        return newVal;
      };
    }
  });

  // src/lib/relink_private.js
  var require_relink_private = __commonJS({
    "src/lib/relink_private.js"(exports, module) {
      "use strict";
      var isArrayOrTypedArray = require_array().isArrayOrTypedArray;
      var isPlainObject = require_is_plain_object();
      module.exports = function relinkPrivateKeys(toContainer, fromContainer) {
        for (var k in fromContainer) {
          var fromVal = fromContainer[k];
          var toVal = toContainer[k];
          if (toVal === fromVal) continue;
          if (k.charAt(0) === "_" || typeof fromVal === "function") {
            if (k in toContainer) continue;
            toContainer[k] = fromVal;
          } else if (isArrayOrTypedArray(fromVal) && isArrayOrTypedArray(toVal) && isPlainObject(fromVal[0])) {
            if (k === "customdata" || k === "ids") continue;
            var minLen = Math.min(fromVal.length, toVal.length);
            for (var j = 0; j < minLen; j++) {
              if (toVal[j] !== fromVal[j] && isPlainObject(fromVal[j]) && isPlainObject(toVal[j])) {
                relinkPrivateKeys(toVal[j], fromVal[j]);
              }
            }
          } else if (isPlainObject(fromVal) && isPlainObject(toVal)) {
            relinkPrivateKeys(toVal, fromVal);
            if (!Object.keys(toVal).length) delete toContainer[k];
          }
        }
      };
    }
  });

  // src/lib/mod.js
  var require_mod = __commonJS({
    "src/lib/mod.js"(exports, module) {
      "use strict";
      function mod(v, d) {
        var out = v % d;
        return out < 0 ? out + d : out;
      }
      function modHalf(v, d) {
        return Math.abs(v) > d / 2 ? v - Math.round(v / d) * d : v;
      }
      module.exports = {
        mod,
        modHalf
      };
    }
  });

  // node_modules/tinycolor2/tinycolor.js
  var require_tinycolor = __commonJS({
    "node_modules/tinycolor2/tinycolor.js"(exports, module) {
      (function(Math2) {
        var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
        function tinycolor(color, opts) {
          color = color ? color : "";
          opts = opts || {};
          if (color instanceof tinycolor) {
            return color;
          }
          if (!(this instanceof tinycolor)) {
            return new tinycolor(color, opts);
          }
          var rgb = inputToRGB(color);
          this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
          this._gradientType = opts.gradientType;
          if (this._r < 1) {
            this._r = mathRound(this._r);
          }
          if (this._g < 1) {
            this._g = mathRound(this._g);
          }
          if (this._b < 1) {
            this._b = mathRound(this._b);
          }
          this._ok = rgb.ok;
          this._tc_id = tinyCounter++;
        }
        tinycolor.prototype = {
          isDark: function() {
            return this.getBrightness() < 128;
          },
          isLight: function() {
            return !this.isDark();
          },
          isValid: function() {
            return this._ok;
          },
          getOriginalInput: function() {
            return this._originalInput;
          },
          getFormat: function() {
            return this._format;
          },
          getAlpha: function() {
            return this._a;
          },
          getBrightness: function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
          },
          getLuminance: function() {
            var rgb = this.toRgb();
            var RsRGB, GsRGB, BsRGB, R, G, B;
            RsRGB = rgb.r / 255;
            GsRGB = rgb.g / 255;
            BsRGB = rgb.b / 255;
            if (RsRGB <= 0.03928) {
              R = RsRGB / 12.92;
            } else {
              R = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
            }
            if (GsRGB <= 0.03928) {
              G = GsRGB / 12.92;
            } else {
              G = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
            }
            if (BsRGB <= 0.03928) {
              B = BsRGB / 12.92;
            } else {
              B = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * R + 0.7152 * G + 0.0722 * B;
          },
          setAlpha: function(value) {
            this._a = boundAlpha(value);
            this._roundA = mathRound(100 * this._a) / 100;
            return this;
          },
          toHsv: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
          },
          toHsvString: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
            return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
          },
          toHsl: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
          },
          toHslString: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
            return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
          },
          toHex: function(allow3Char) {
            return rgbToHex(this._r, this._g, this._b, allow3Char);
          },
          toHexString: function(allow3Char) {
            return "#" + this.toHex(allow3Char);
          },
          toHex8: function(allow4Char) {
            return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
          },
          toHex8String: function(allow4Char) {
            return "#" + this.toHex8(allow4Char);
          },
          toRgb: function() {
            return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
          },
          toRgbString: function() {
            return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
          },
          toPercentageRgb: function() {
            return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
          },
          toPercentageRgbString: function() {
            return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
          },
          toName: function() {
            if (this._a === 0) {
              return "transparent";
            }
            if (this._a < 1) {
              return false;
            }
            return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
          },
          toFilter: function(secondColor) {
            var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
            var secondHex8String = hex8String;
            var gradientType = this._gradientType ? "GradientType = 1, " : "";
            if (secondColor) {
              var s = tinycolor(secondColor);
              secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
            }
            return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
          },
          toString: function(format) {
            var formatSet = !!format;
            format = format || this._format;
            var formattedString = false;
            var hasAlpha = this._a < 1 && this._a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
            if (needsAlphaFormat) {
              if (format === "name" && this._a === 0) {
                return this.toName();
              }
              return this.toRgbString();
            }
            if (format === "rgb") {
              formattedString = this.toRgbString();
            }
            if (format === "prgb") {
              formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
              formattedString = this.toHexString();
            }
            if (format === "hex3") {
              formattedString = this.toHexString(true);
            }
            if (format === "hex4") {
              formattedString = this.toHex8String(true);
            }
            if (format === "hex8") {
              formattedString = this.toHex8String();
            }
            if (format === "name") {
              formattedString = this.toName();
            }
            if (format === "hsl") {
              formattedString = this.toHslString();
            }
            if (format === "hsv") {
              formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
          },
          clone: function() {
            return tinycolor(this.toString());
          },
          _applyModification: function(fn, args) {
            var color = fn.apply(null, [this].concat([].slice.call(args)));
            this._r = color._r;
            this._g = color._g;
            this._b = color._b;
            this.setAlpha(color._a);
            return this;
          },
          lighten: function() {
            return this._applyModification(lighten, arguments);
          },
          brighten: function() {
            return this._applyModification(brighten, arguments);
          },
          darken: function() {
            return this._applyModification(darken, arguments);
          },
          desaturate: function() {
            return this._applyModification(desaturate, arguments);
          },
          saturate: function() {
            return this._applyModification(saturate, arguments);
          },
          greyscale: function() {
            return this._applyModification(greyscale, arguments);
          },
          spin: function() {
            return this._applyModification(spin, arguments);
          },
          _applyCombination: function(fn, args) {
            return fn.apply(null, [this].concat([].slice.call(args)));
          },
          analogous: function() {
            return this._applyCombination(analogous, arguments);
          },
          complement: function() {
            return this._applyCombination(complement, arguments);
          },
          monochromatic: function() {
            return this._applyCombination(monochromatic, arguments);
          },
          splitcomplement: function() {
            return this._applyCombination(splitcomplement, arguments);
          },
          triad: function() {
            return this._applyCombination(triad, arguments);
          },
          tetrad: function() {
            return this._applyCombination(tetrad, arguments);
          }
        };
        tinycolor.fromRatio = function(color, opts) {
          if (typeof color == "object") {
            var newColor = {};
            for (var i in color) {
              if (color.hasOwnProperty(i)) {
                if (i === "a") {
                  newColor[i] = color[i];
                } else {
                  newColor[i] = convertToPercentage(color[i]);
                }
              }
            }
            color = newColor;
          }
          return tinycolor(color, opts);
        };
        function inputToRGB(color) {
          var rgb = { r: 0, g: 0, b: 0 };
          var a = 1;
          var s = null;
          var v = null;
          var l = null;
          var ok = false;
          var format = false;
          if (typeof color == "string") {
            color = stringInputToObject(color);
          }
          if (typeof color == "object") {
            if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
              rgb = rgbToRgb(color.r, color.g, color.b);
              ok = true;
              format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
            } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
              s = convertToPercentage(color.s);
              v = convertToPercentage(color.v);
              rgb = hsvToRgb(color.h, s, v);
              ok = true;
              format = "hsv";
            } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
              s = convertToPercentage(color.s);
              l = convertToPercentage(color.l);
              rgb = hslToRgb(color.h, s, l);
              ok = true;
              format = "hsl";
            }
            if (color.hasOwnProperty("a")) {
              a = color.a;
            }
          }
          a = boundAlpha(a);
          return {
            ok,
            format: color.format || format,
            r: mathMin(255, mathMax(rgb.r, 0)),
            g: mathMin(255, mathMax(rgb.g, 0)),
            b: mathMin(255, mathMax(rgb.b, 0)),
            a
          };
        }
        function rgbToRgb(r, g, b) {
          return {
            r: bound01(r, 255) * 255,
            g: bound01(g, 255) * 255,
            b: bound01(b, 255) * 255
          };
        }
        function rgbToHsl(r, g, b) {
          r = bound01(r, 255);
          g = bound01(g, 255);
          b = bound01(b, 255);
          var max = mathMax(r, g, b), min = mathMin(r, g, b);
          var h, s, l = (max + min) / 2;
          if (max == min) {
            h = s = 0;
          } else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }
          return { h, s, l };
        }
        function hslToRgb(h, s, l) {
          var r, g, b;
          h = bound01(h, 360);
          s = bound01(s, 100);
          l = bound01(l, 100);
          function hue2rgb(p2, q2, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;
            if (t < 1 / 2) return q2;
            if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
            return p2;
          }
          if (s === 0) {
            r = g = b = l;
          } else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
          }
          return { r: r * 255, g: g * 255, b: b * 255 };
        }
        function rgbToHsv(r, g, b) {
          r = bound01(r, 255);
          g = bound01(g, 255);
          b = bound01(b, 255);
          var max = mathMax(r, g, b), min = mathMin(r, g, b);
          var h, s, v = max;
          var d = max - min;
          s = max === 0 ? 0 : d / max;
          if (max == min) {
            h = 0;
          } else {
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }
          return { h, s, v };
        }
        function hsvToRgb(h, s, v) {
          h = bound01(h, 360) * 6;
          s = bound01(s, 100);
          v = bound01(v, 100);
          var i = Math2.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b = [p, p, t, v, v, q][mod];
          return { r: r * 255, g: g * 255, b: b * 255 };
        }
        function rgbToHex(r, g, b, allow3Char) {
          var hex = [
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
          ];
          if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
          }
          return hex.join("");
        }
        function rgbaToHex(r, g, b, a, allow4Char) {
          var hex = [
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16)),
            pad2(convertDecimalToHex(a))
          ];
          if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
          }
          return hex.join("");
        }
        function rgbaToArgbHex(r, g, b, a) {
          var hex = [
            pad2(convertDecimalToHex(a)),
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
          ];
          return hex.join("");
        }
        tinycolor.equals = function(color1, color2) {
          if (!color1 || !color2) {
            return false;
          }
          return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
        };
        tinycolor.random = function() {
          return tinycolor.fromRatio({
            r: mathRandom(),
            g: mathRandom(),
            b: mathRandom()
          });
        };
        function desaturate(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.s -= amount / 100;
          hsl.s = clamp01(hsl.s);
          return tinycolor(hsl);
        }
        function saturate(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.s += amount / 100;
          hsl.s = clamp01(hsl.s);
          return tinycolor(hsl);
        }
        function greyscale(color) {
          return tinycolor(color).desaturate(100);
        }
        function lighten(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.l += amount / 100;
          hsl.l = clamp01(hsl.l);
          return tinycolor(hsl);
        }
        function brighten(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var rgb = tinycolor(color).toRgb();
          rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
          rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
          rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
          return tinycolor(rgb);
        }
        function darken(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.l -= amount / 100;
          hsl.l = clamp01(hsl.l);
          return tinycolor(hsl);
        }
        function spin(color, amount) {
          var hsl = tinycolor(color).toHsl();
          var hue = (hsl.h + amount) % 360;
          hsl.h = hue < 0 ? 360 + hue : hue;
          return tinycolor(hsl);
        }
        function complement(color) {
          var hsl = tinycolor(color).toHsl();
          hsl.h = (hsl.h + 180) % 360;
          return tinycolor(hsl);
        }
        function triad(color) {
          var hsl = tinycolor(color).toHsl();
          var h = hsl.h;
          return [
            tinycolor(color),
            tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
          ];
        }
        function tetrad(color) {
          var hsl = tinycolor(color).toHsl();
          var h = hsl.h;
          return [
            tinycolor(color),
            tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
          ];
        }
        function splitcomplement(color) {
          var hsl = tinycolor(color).toHsl();
          var h = hsl.h;
          return [
            tinycolor(color),
            tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
          ];
        }
        function analogous(color, results, slices) {
          results = results || 6;
          slices = slices || 30;
          var hsl = tinycolor(color).toHsl();
          var part = 360 / slices;
          var ret = [tinycolor(color)];
          for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(tinycolor(hsl));
          }
          return ret;
        }
        function monochromatic(color, results) {
          results = results || 6;
          var hsv = tinycolor(color).toHsv();
          var h = hsv.h, s = hsv.s, v = hsv.v;
          var ret = [];
          var modification = 1 / results;
          while (results--) {
            ret.push(tinycolor({ h, s, v }));
            v = (v + modification) % 1;
          }
          return ret;
        }
        tinycolor.mix = function(color1, color2, amount) {
          amount = amount === 0 ? 0 : amount || 50;
          var rgb1 = tinycolor(color1).toRgb();
          var rgb2 = tinycolor(color2).toRgb();
          var p = amount / 100;
          var rgba = {
            r: (rgb2.r - rgb1.r) * p + rgb1.r,
            g: (rgb2.g - rgb1.g) * p + rgb1.g,
            b: (rgb2.b - rgb1.b) * p + rgb1.b,
            a: (rgb2.a - rgb1.a) * p + rgb1.a
          };
          return tinycolor(rgba);
        };
        tinycolor.readability = function(color1, color2) {
          var c1 = tinycolor(color1);
          var c2 = tinycolor(color2);
          return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
        };
        tinycolor.isReadable = function(color1, color2, wcag2) {
          var readability = tinycolor.readability(color1, color2);
          var wcag2Parms, out;
          out = false;
          wcag2Parms = validateWCAG2Parms(wcag2);
          switch (wcag2Parms.level + wcag2Parms.size) {
            case "AAsmall":
            case "AAAlarge":
              out = readability >= 4.5;
              break;
            case "AAlarge":
              out = readability >= 3;
              break;
            case "AAAsmall":
              out = readability >= 7;
              break;
          }
          return out;
        };
        tinycolor.mostReadable = function(baseColor, colorList, args) {
          var bestColor = null;
          var bestScore = 0;
          var readability;
          var includeFallbackColors, level, size;
          args = args || {};
          includeFallbackColors = args.includeFallbackColors;
          level = args.level;
          size = args.size;
          for (var i = 0; i < colorList.length; i++) {
            readability = tinycolor.readability(baseColor, colorList[i]);
            if (readability > bestScore) {
              bestScore = readability;
              bestColor = tinycolor(colorList[i]);
            }
          }
          if (tinycolor.isReadable(baseColor, bestColor, { "level": level, "size": size }) || !includeFallbackColors) {
            return bestColor;
          } else {
            args.includeFallbackColors = false;
            return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
          }
        };
        var names = tinycolor.names = {
          aliceblue: "f0f8ff",
          antiquewhite: "faebd7",
          aqua: "0ff",
          aquamarine: "7fffd4",
          azure: "f0ffff",
          beige: "f5f5dc",
          bisque: "ffe4c4",
          black: "000",
          blanchedalmond: "ffebcd",
          blue: "00f",
          blueviolet: "8a2be2",
          brown: "a52a2a",
          burlywood: "deb887",
          burntsienna: "ea7e5d",
          cadetblue: "5f9ea0",
          chartreuse: "7fff00",
          chocolate: "d2691e",
          coral: "ff7f50",
          cornflowerblue: "6495ed",
          cornsilk: "fff8dc",
          crimson: "dc143c",
          cyan: "0ff",
          darkblue: "00008b",
          darkcyan: "008b8b",
          darkgoldenrod: "b8860b",
          darkgray: "a9a9a9",
          darkgreen: "006400",
          darkgrey: "a9a9a9",
          darkkhaki: "bdb76b",
          darkmagenta: "8b008b",
          darkolivegreen: "556b2f",
          darkorange: "ff8c00",
          darkorchid: "9932cc",
          darkred: "8b0000",
          darksalmon: "e9967a",
          darkseagreen: "8fbc8f",
          darkslateblue: "483d8b",
          darkslategray: "2f4f4f",
          darkslategrey: "2f4f4f",
          darkturquoise: "00ced1",
          darkviolet: "9400d3",
          deeppink: "ff1493",
          deepskyblue: "00bfff",
          dimgray: "696969",
          dimgrey: "696969",
          dodgerblue: "1e90ff",
          firebrick: "b22222",
          floralwhite: "fffaf0",
          forestgreen: "228b22",
          fuchsia: "f0f",
          gainsboro: "dcdcdc",
          ghostwhite: "f8f8ff",
          gold: "ffd700",
          goldenrod: "daa520",
          gray: "808080",
          green: "008000",
          greenyellow: "adff2f",
          grey: "808080",
          honeydew: "f0fff0",
          hotpink: "ff69b4",
          indianred: "cd5c5c",
          indigo: "4b0082",
          ivory: "fffff0",
          khaki: "f0e68c",
          lavender: "e6e6fa",
          lavenderblush: "fff0f5",
          lawngreen: "7cfc00",
          lemonchiffon: "fffacd",
          lightblue: "add8e6",
          lightcoral: "f08080",
          lightcyan: "e0ffff",
          lightgoldenrodyellow: "fafad2",
          lightgray: "d3d3d3",
          lightgreen: "90ee90",
          lightgrey: "d3d3d3",
          lightpink: "ffb6c1",
          lightsalmon: "ffa07a",
          lightseagreen: "20b2aa",
          lightskyblue: "87cefa",
          lightslategray: "789",
          lightslategrey: "789",
          lightsteelblue: "b0c4de",
          lightyellow: "ffffe0",
          lime: "0f0",
          limegreen: "32cd32",
          linen: "faf0e6",
          magenta: "f0f",
          maroon: "800000",
          mediumaquamarine: "66cdaa",
          mediumblue: "0000cd",
          mediumorchid: "ba55d3",
          mediumpurple: "9370db",
          mediumseagreen: "3cb371",
          mediumslateblue: "7b68ee",
          mediumspringgreen: "00fa9a",
          mediumturquoise: "48d1cc",
          mediumvioletred: "c71585",
          midnightblue: "191970",
          mintcream: "f5fffa",
          mistyrose: "ffe4e1",
          moccasin: "ffe4b5",
          navajowhite: "ffdead",
          navy: "000080",
          oldlace: "fdf5e6",
          olive: "808000",
          olivedrab: "6b8e23",
          orange: "ffa500",
          orangered: "ff4500",
          orchid: "da70d6",
          palegoldenrod: "eee8aa",
          palegreen: "98fb98",
          paleturquoise: "afeeee",
          palevioletred: "db7093",
          papayawhip: "ffefd5",
          peachpuff: "ffdab9",
          peru: "cd853f",
          pink: "ffc0cb",
          plum: "dda0dd",
          powderblue: "b0e0e6",
          purple: "800080",
          rebeccapurple: "663399",
          red: "f00",
          rosybrown: "bc8f8f",
          royalblue: "4169e1",
          saddlebrown: "8b4513",
          salmon: "fa8072",
          sandybrown: "f4a460",
          seagreen: "2e8b57",
          seashell: "fff5ee",
          sienna: "a0522d",
          silver: "c0c0c0",
          skyblue: "87ceeb",
          slateblue: "6a5acd",
          slategray: "708090",
          slategrey: "708090",
          snow: "fffafa",
          springgreen: "00ff7f",
          steelblue: "4682b4",
          tan: "d2b48c",
          teal: "008080",
          thistle: "d8bfd8",
          tomato: "ff6347",
          turquoise: "40e0d0",
          violet: "ee82ee",
          wheat: "f5deb3",
          white: "fff",
          whitesmoke: "f5f5f5",
          yellow: "ff0",
          yellowgreen: "9acd32"
        };
        var hexNames = tinycolor.hexNames = flip(names);
        function flip(o) {
          var flipped = {};
          for (var i in o) {
            if (o.hasOwnProperty(i)) {
              flipped[o[i]] = i;
            }
          }
          return flipped;
        }
        function boundAlpha(a) {
          a = parseFloat(a);
          if (isNaN(a) || a < 0 || a > 1) {
            a = 1;
          }
          return a;
        }
        function bound01(n, max) {
          if (isOnePointZero(n)) {
            n = "100%";
          }
          var processPercent = isPercentage(n);
          n = mathMin(max, mathMax(0, parseFloat(n)));
          if (processPercent) {
            n = parseInt(n * max, 10) / 100;
          }
          if (Math2.abs(n - max) < 1e-6) {
            return 1;
          }
          return n % max / parseFloat(max);
        }
        function clamp01(val) {
          return mathMin(1, mathMax(0, val));
        }
        function parseIntFromHex(val) {
          return parseInt(val, 16);
        }
        function isOnePointZero(n) {
          return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
        }
        function isPercentage(n) {
          return typeof n === "string" && n.indexOf("%") != -1;
        }
        function pad2(c) {
          return c.length == 1 ? "0" + c : "" + c;
        }
        function convertToPercentage(n) {
          if (n <= 1) {
            n = n * 100 + "%";
          }
          return n;
        }
        function convertDecimalToHex(d) {
          return Math2.round(parseFloat(d) * 255).toString(16);
        }
        function convertHexToDecimal(h) {
          return parseIntFromHex(h) / 255;
        }
        var matchers = function() {
          var CSS_INTEGER = "[-\\+]?\\d+%?";
          var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
          var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
          var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
          var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
          return {
            CSS_UNIT: new RegExp(CSS_UNIT),
            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
            hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
            hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
          };
        }();
        function isValidCSSUnit(color) {
          return !!matchers.CSS_UNIT.exec(color);
        }
        function stringInputToObject(color) {
          color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
          var named = false;
          if (names[color]) {
            color = names[color];
            named = true;
          } else if (color == "transparent") {
            return { r: 0, g: 0, b: 0, a: 0, format: "name" };
          }
          var match;
          if (match = matchers.rgb.exec(color)) {
            return { r: match[1], g: match[2], b: match[3] };
          }
          if (match = matchers.rgba.exec(color)) {
            return { r: match[1], g: match[2], b: match[3], a: match[4] };
          }
          if (match = matchers.hsl.exec(color)) {
            return { h: match[1], s: match[2], l: match[3] };
          }
          if (match = matchers.hsla.exec(color)) {
            return { h: match[1], s: match[2], l: match[3], a: match[4] };
          }
          if (match = matchers.hsv.exec(color)) {
            return { h: match[1], s: match[2], v: match[3] };
          }
          if (match = matchers.hsva.exec(color)) {
            return { h: match[1], s: match[2], v: match[3], a: match[4] };
          }
          if (match = matchers.hex8.exec(color)) {
            return {
              r: parseIntFromHex(match[1]),
              g: parseIntFromHex(match[2]),
              b: parseIntFromHex(match[3]),
              a: convertHexToDecimal(match[4]),
              format: named ? "name" : "hex8"
            };
          }
          if (match = matchers.hex6.exec(color)) {
            return {
              r: parseIntFromHex(match[1]),
              g: parseIntFromHex(match[2]),
              b: parseIntFromHex(match[3]),
              format: named ? "name" : "hex"
            };
          }
          if (match = matchers.hex4.exec(color)) {
            return {
              r: parseIntFromHex(match[1] + "" + match[1]),
              g: parseIntFromHex(match[2] + "" + match[2]),
              b: parseIntFromHex(match[3] + "" + match[3]),
              a: convertHexToDecimal(match[4] + "" + match[4]),
              format: named ? "name" : "hex8"
            };
          }
          if (match = matchers.hex3.exec(color)) {
            return {
              r: parseIntFromHex(match[1] + "" + match[1]),
              g: parseIntFromHex(match[2] + "" + match[2]),
              b: parseIntFromHex(match[3] + "" + match[3]),
              format: named ? "name" : "hex"
            };
          }
          return false;
        }
        function validateWCAG2Parms(parms) {
          var level, size;
          parms = parms || { "level": "AA", "size": "small" };
          level = (parms.level || "AA").toUpperCase();
          size = (parms.size || "small").toLowerCase();
          if (level !== "AA" && level !== "AAA") {
            level = "AA";
          }
          if (size !== "small" && size !== "large") {
            size = "small";
          }
          return { "level": level, "size": size };
        }
        if (typeof module !== "undefined" && module.exports) {
          module.exports = tinycolor;
        } else if (typeof define === "function" && false) {
          define(function() {
            return tinycolor;
          });
        } else {
          window.tinycolor = tinycolor;
        }
      })(Math);
    }
  });

  // src/lib/extend.js
  var require_extend = __commonJS({
    "src/lib/extend.js"(exports) {
      "use strict";
      var isPlainObject = require_is_plain_object();
      var isArray = Array.isArray;
      function primitivesLoopSplice(source, target) {
        var i, value;
        for (i = 0; i < source.length; i++) {
          value = source[i];
          if (value !== null && typeof value === "object") {
            return false;
          }
          if (value !== void 0) {
            target[i] = value;
          }
        }
        return true;
      }
      exports.extendFlat = function() {
        return _extend(arguments, false, false, false);
      };
      exports.extendDeep = function() {
        return _extend(arguments, true, false, false);
      };
      exports.extendDeepAll = function() {
        return _extend(arguments, true, true, false);
      };
      exports.extendDeepNoArrays = function() {
        return _extend(arguments, true, false, true);
      };
      function _extend(inputs, isDeep, keepAllKeys, noArrayCopies) {
        var target = inputs[0];
        var length = inputs.length;
        var input, key, src, copy, copyIsArray, clone, allPrimitives;
        if (length === 2 && isArray(target) && isArray(inputs[1]) && target.length === 0) {
          allPrimitives = primitivesLoopSplice(inputs[1], target);
          if (allPrimitives) {
            return target;
          } else {
            target.splice(0, target.length);
          }
        }
        for (var i = 1; i < length; i++) {
          input = inputs[i];
          for (key in input) {
            src = target[key];
            copy = input[key];
            if (noArrayCopies && isArray(copy)) {
              target[key] = copy;
            } else if (isDeep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray(src) ? src : [];
              } else {
                clone = src && isPlainObject(src) ? src : {};
              }
              target[key] = _extend([clone, copy], isDeep, keepAllKeys, noArrayCopies);
            } else if (typeof copy !== "undefined" || keepAllKeys) {
              target[key] = copy;
            }
          }
        }
        return target;
      }
    }
  });

  // src/plots/font_attributes.js
  var require_font_attributes = __commonJS({
    "src/plots/font_attributes.js"(exports, module) {
      "use strict";
      module.exports = function(opts) {
        var variantValues = opts.variantValues;
        var editType = opts.editType;
        var colorEditType = opts.colorEditType;
        if (colorEditType === void 0) colorEditType = editType;
        var weight = {
          editType,
          valType: "integer",
          min: 1,
          max: 1e3,
          extras: ["normal", "bold"],
          dflt: "normal"
        };
        if (opts.noNumericWeightValues) {
          weight.valType = "enumerated";
          weight.values = weight.extras;
          weight.extras = void 0;
          weight.min = void 0;
          weight.max = void 0;
        }
        var attrs = {
          family: {
            valType: "string",
            noBlank: true,
            strict: true,
            editType
          },
          size: {
            valType: "number",
            min: 1,
            editType
          },
          color: {
            valType: "color",
            editType: colorEditType
          },
          weight,
          style: {
            editType,
            valType: "enumerated",
            values: ["normal", "italic"],
            dflt: "normal"
          },
          variant: opts.noFontVariant ? void 0 : {
            editType,
            valType: "enumerated",
            values: variantValues || [
              "normal",
              "small-caps",
              "all-small-caps",
              "all-petite-caps",
              "petite-caps",
              "unicase"
            ],
            dflt: "normal"
          },
          textcase: opts.noFontTextcase ? void 0 : {
            editType,
            valType: "enumerated",
            values: ["normal", "word caps", "upper", "lower"],
            dflt: "normal"
          },
          lineposition: opts.noFontLineposition ? void 0 : {
            editType,
            valType: "flaglist",
            flags: ["under", "over", "through"],
            extras: ["none"],
            dflt: "none"
          },
          shadow: opts.noFontShadow ? void 0 : {
            editType,
            valType: "string",
            dflt: opts.autoShadowDflt ? "auto" : "none"
          },
          editType
          // blank strings so compress_attributes can remove
          // TODO - that's uber hacky... better solution?
        };
        if (opts.autoSize) attrs.size.dflt = "auto";
        if (opts.autoColor) attrs.color.dflt = "auto";
        if (opts.arrayOk) {
          attrs.family.arrayOk = true;
          attrs.weight.arrayOk = true;
          attrs.style.arrayOk = true;
          if (!opts.noFontVariant) {
            attrs.variant.arrayOk = true;
          }
          if (!opts.noFontTextcase) {
            attrs.textcase.arrayOk = true;
          }
          if (!opts.noFontLineposition) {
            attrs.lineposition.arrayOk = true;
          }
          if (!opts.noFontShadow) {
            attrs.shadow.arrayOk = true;
          }
          attrs.size.arrayOk = true;
          attrs.color.arrayOk = true;
        }
        return attrs;
      };
    }
  });

  // src/components/fx/constants.js
  var require_constants = __commonJS({
    "src/components/fx/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // hover labels for multiple horizontal bars get tilted by this angle
        YANGLE: 60,
        // size and display constants for hover text
        // pixel size of hover arrows
        HOVERARROWSIZE: 6,
        // pixels padding around text
        HOVERTEXTPAD: 3,
        // hover font
        HOVERFONTSIZE: 13,
        HOVERFONT: "Arial, sans-serif",
        // minimum time (msec) between hover calls
        HOVERMINTIME: 50,
        // ID suffix (with fullLayout._uid) for hover events in the throttle cache
        HOVERID: "-hover"
      };
    }
  });

  // src/components/fx/layout_attributes.js
  var require_layout_attributes = __commonJS({
    "src/components/fx/layout_attributes.js"(exports, module) {
      "use strict";
      var constants = require_constants();
      var fontAttrs = require_font_attributes();
      var font = fontAttrs({
        editType: "none"
      });
      font.family.dflt = constants.HOVERFONT;
      font.size.dflt = constants.HOVERFONTSIZE;
      module.exports = {
        clickmode: {
          valType: "flaglist",
          flags: ["event", "select"],
          dflt: "event",
          editType: "plot",
          extras: ["none"]
        },
        dragmode: {
          valType: "enumerated",
          values: [
            "zoom",
            "pan",
            "select",
            "lasso",
            "drawclosedpath",
            "drawopenpath",
            "drawline",
            "drawrect",
            "drawcircle",
            "orbit",
            "turntable",
            false
          ],
          dflt: "zoom",
          editType: "modebar"
        },
        hovermode: {
          valType: "enumerated",
          values: ["x", "y", "closest", false, "x unified", "y unified"],
          dflt: "closest",
          editType: "modebar"
        },
        hoversubplots: {
          valType: "enumerated",
          values: ["single", "overlaying", "axis"],
          dflt: "overlaying",
          editType: "none"
        },
        hoverdistance: {
          valType: "integer",
          min: -1,
          dflt: 20,
          editType: "none"
        },
        spikedistance: {
          valType: "integer",
          min: -1,
          dflt: -1,
          editType: "none"
        },
        hoverlabel: {
          bgcolor: {
            valType: "color",
            editType: "none"
          },
          bordercolor: {
            valType: "color",
            editType: "none"
          },
          font,
          grouptitlefont: fontAttrs({
            editType: "none"
          }),
          align: {
            valType: "enumerated",
            values: ["left", "right", "auto"],
            dflt: "auto",
            editType: "none"
          },
          namelength: {
            valType: "integer",
            min: -1,
            dflt: 15,
            editType: "none"
          },
          editType: "none"
        },
        selectdirection: {
          valType: "enumerated",
          values: ["h", "v", "d", "any"],
          dflt: "any",
          editType: "none"
        }
      };
    }
  });

  // src/components/fx/attributes.js
  var require_attributes = __commonJS({
    "src/components/fx/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var hoverLabelAttrs = require_layout_attributes().hoverlabel;
      var extendFlat = require_extend().extendFlat;
      module.exports = {
        hoverlabel: {
          bgcolor: extendFlat({}, hoverLabelAttrs.bgcolor, {
            arrayOk: true
          }),
          bordercolor: extendFlat({}, hoverLabelAttrs.bordercolor, {
            arrayOk: true
          }),
          font: fontAttrs({
            arrayOk: true,
            editType: "none"
          }),
          align: extendFlat({}, hoverLabelAttrs.align, { arrayOk: true }),
          namelength: extendFlat({}, hoverLabelAttrs.namelength, { arrayOk: true }),
          editType: "none"
        }
      };
    }
  });

  // src/plots/attributes.js
  var require_attributes2 = __commonJS({
    "src/plots/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var fxAttrs = require_attributes();
      module.exports = {
        type: {
          valType: "enumerated",
          values: [],
          // listed dynamically
          dflt: "scatter",
          editType: "calc+clearAxisTypes",
          _noTemplating: true
          // we handle this at a higher level
        },
        visible: {
          valType: "enumerated",
          values: [true, false, "legendonly"],
          dflt: true,
          editType: "calc"
        },
        showlegend: {
          valType: "boolean",
          dflt: true,
          editType: "style"
        },
        legend: {
          valType: "subplotid",
          dflt: "legend",
          editType: "style"
        },
        legendgroup: {
          valType: "string",
          dflt: "",
          editType: "style"
        },
        legendgrouptitle: {
          text: {
            valType: "string",
            dflt: "",
            editType: "style"
          },
          font: fontAttrs({
            editType: "style"
          }),
          editType: "style"
        },
        legendrank: {
          valType: "number",
          dflt: 1e3,
          editType: "style"
        },
        legendwidth: {
          valType: "number",
          min: 0,
          editType: "style"
        },
        opacity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 1,
          editType: "style"
        },
        name: {
          valType: "string",
          editType: "style"
        },
        uid: {
          valType: "string",
          editType: "plot",
          anim: true
        },
        ids: {
          valType: "data_array",
          editType: "calc",
          anim: true
        },
        customdata: {
          valType: "data_array",
          editType: "calc"
        },
        meta: {
          valType: "any",
          arrayOk: true,
          editType: "plot"
        },
        // N.B. these cannot be 'data_array' as they do not have the same length as
        // other data arrays and arrayOk attributes in general
        //
        // Maybe add another valType:
        // https://github.com/plotly/plotly.js/issues/1894
        selectedpoints: {
          valType: "any",
          editType: "calc"
        },
        hoverinfo: {
          valType: "flaglist",
          flags: ["x", "y", "z", "text", "name"],
          extras: ["all", "none", "skip"],
          arrayOk: true,
          dflt: "all",
          editType: "none"
        },
        hoverlabel: fxAttrs.hoverlabel,
        stream: {
          token: {
            valType: "string",
            noBlank: true,
            strict: true,
            editType: "calc"
          },
          maxpoints: {
            valType: "number",
            min: 0,
            max: 1e4,
            dflt: 500,
            editType: "calc"
          },
          editType: "calc"
        },
        uirevision: {
          valType: "any",
          editType: "none"
        }
      };
    }
  });

  // src/components/colorscale/scales.js
  var require_scales = __commonJS({
    "src/components/colorscale/scales.js"(exports, module) {
      "use strict";
      var tinycolor = require_tinycolor();
      var scales = {
        Greys: [
          [0, "rgb(0,0,0)"],
          [1, "rgb(255,255,255)"]
        ],
        YlGnBu: [
          [0, "rgb(8,29,88)"],
          [0.125, "rgb(37,52,148)"],
          [0.25, "rgb(34,94,168)"],
          [0.375, "rgb(29,145,192)"],
          [0.5, "rgb(65,182,196)"],
          [0.625, "rgb(127,205,187)"],
          [0.75, "rgb(199,233,180)"],
          [0.875, "rgb(237,248,217)"],
          [1, "rgb(255,255,217)"]
        ],
        Greens: [
          [0, "rgb(0,68,27)"],
          [0.125, "rgb(0,109,44)"],
          [0.25, "rgb(35,139,69)"],
          [0.375, "rgb(65,171,93)"],
          [0.5, "rgb(116,196,118)"],
          [0.625, "rgb(161,217,155)"],
          [0.75, "rgb(199,233,192)"],
          [0.875, "rgb(229,245,224)"],
          [1, "rgb(247,252,245)"]
        ],
        YlOrRd: [
          [0, "rgb(128,0,38)"],
          [0.125, "rgb(189,0,38)"],
          [0.25, "rgb(227,26,28)"],
          [0.375, "rgb(252,78,42)"],
          [0.5, "rgb(253,141,60)"],
          [0.625, "rgb(254,178,76)"],
          [0.75, "rgb(254,217,118)"],
          [0.875, "rgb(255,237,160)"],
          [1, "rgb(255,255,204)"]
        ],
        Bluered: [
          [0, "rgb(0,0,255)"],
          [1, "rgb(255,0,0)"]
        ],
        // modified RdBu based on
        // http://www.kennethmoreland.com/color-maps/
        RdBu: [
          [0, "rgb(5,10,172)"],
          [0.35, "rgb(106,137,247)"],
          [0.5, "rgb(190,190,190)"],
          [0.6, "rgb(220,170,132)"],
          [0.7, "rgb(230,145,90)"],
          [1, "rgb(178,10,28)"]
        ],
        // Scale for non-negative numeric values
        Reds: [
          [0, "rgb(220,220,220)"],
          [0.2, "rgb(245,195,157)"],
          [0.4, "rgb(245,160,105)"],
          [1, "rgb(178,10,28)"]
        ],
        // Scale for non-positive numeric values
        Blues: [
          [0, "rgb(5,10,172)"],
          [0.35, "rgb(40,60,190)"],
          [0.5, "rgb(70,100,245)"],
          [0.6, "rgb(90,120,245)"],
          [0.7, "rgb(106,137,247)"],
          [1, "rgb(220,220,220)"]
        ],
        Picnic: [
          [0, "rgb(0,0,255)"],
          [0.1, "rgb(51,153,255)"],
          [0.2, "rgb(102,204,255)"],
          [0.3, "rgb(153,204,255)"],
          [0.4, "rgb(204,204,255)"],
          [0.5, "rgb(255,255,255)"],
          [0.6, "rgb(255,204,255)"],
          [0.7, "rgb(255,153,255)"],
          [0.8, "rgb(255,102,204)"],
          [0.9, "rgb(255,102,102)"],
          [1, "rgb(255,0,0)"]
        ],
        Rainbow: [
          [0, "rgb(150,0,90)"],
          [0.125, "rgb(0,0,200)"],
          [0.25, "rgb(0,25,255)"],
          [0.375, "rgb(0,152,255)"],
          [0.5, "rgb(44,255,150)"],
          [0.625, "rgb(151,255,0)"],
          [0.75, "rgb(255,234,0)"],
          [0.875, "rgb(255,111,0)"],
          [1, "rgb(255,0,0)"]
        ],
        Portland: [
          [0, "rgb(12,51,131)"],
          [0.25, "rgb(10,136,186)"],
          [0.5, "rgb(242,211,56)"],
          [0.75, "rgb(242,143,56)"],
          [1, "rgb(217,30,30)"]
        ],
        Jet: [
          [0, "rgb(0,0,131)"],
          [0.125, "rgb(0,60,170)"],
          [0.375, "rgb(5,255,255)"],
          [0.625, "rgb(255,255,0)"],
          [0.875, "rgb(250,0,0)"],
          [1, "rgb(128,0,0)"]
        ],
        Hot: [
          [0, "rgb(0,0,0)"],
          [0.3, "rgb(230,0,0)"],
          [0.6, "rgb(255,210,0)"],
          [1, "rgb(255,255,255)"]
        ],
        Blackbody: [
          [0, "rgb(0,0,0)"],
          [0.2, "rgb(230,0,0)"],
          [0.4, "rgb(230,210,0)"],
          [0.7, "rgb(255,255,255)"],
          [1, "rgb(160,200,255)"]
        ],
        Earth: [
          [0, "rgb(0,0,130)"],
          [0.1, "rgb(0,180,180)"],
          [0.2, "rgb(40,210,40)"],
          [0.4, "rgb(230,230,50)"],
          [0.6, "rgb(120,70,20)"],
          [1, "rgb(255,255,255)"]
        ],
        Electric: [
          [0, "rgb(0,0,0)"],
          [0.15, "rgb(30,0,100)"],
          [0.4, "rgb(120,0,100)"],
          [0.6, "rgb(160,90,0)"],
          [0.8, "rgb(230,200,0)"],
          [1, "rgb(255,250,220)"]
        ],
        Viridis: [
          [0, "#440154"],
          [0.06274509803921569, "#48186a"],
          [0.12549019607843137, "#472d7b"],
          [0.18823529411764706, "#424086"],
          [0.25098039215686274, "#3b528b"],
          [0.3137254901960784, "#33638d"],
          [0.3764705882352941, "#2c728e"],
          [0.4392156862745098, "#26828e"],
          [0.5019607843137255, "#21918c"],
          [0.5647058823529412, "#1fa088"],
          [0.6274509803921569, "#28ae80"],
          [0.6901960784313725, "#3fbc73"],
          [0.7529411764705882, "#5ec962"],
          [0.8156862745098039, "#84d44b"],
          [0.8784313725490196, "#addc30"],
          [0.9411764705882353, "#d8e219"],
          [1, "#fde725"]
        ],
        Cividis: [
          [0, "rgb(0,32,76)"],
          [0.058824, "rgb(0,42,102)"],
          [0.117647, "rgb(0,52,110)"],
          [0.176471, "rgb(39,63,108)"],
          [0.235294, "rgb(60,74,107)"],
          [0.294118, "rgb(76,85,107)"],
          [0.352941, "rgb(91,95,109)"],
          [0.411765, "rgb(104,106,112)"],
          [0.470588, "rgb(117,117,117)"],
          [0.529412, "rgb(131,129,120)"],
          [0.588235, "rgb(146,140,120)"],
          [0.647059, "rgb(161,152,118)"],
          [0.705882, "rgb(176,165,114)"],
          [0.764706, "rgb(192,177,109)"],
          [0.823529, "rgb(209,191,102)"],
          [0.882353, "rgb(225,204,92)"],
          [0.941176, "rgb(243,219,79)"],
          [1, "rgb(255,233,69)"]
        ]
      };
      var defaultScale = scales.RdBu;
      function getScale(scl, dflt) {
        if (!dflt) dflt = defaultScale;
        if (!scl) return dflt;
        function parseScale() {
          try {
            scl = scales[scl] || JSON.parse(scl);
          } catch (e) {
            scl = dflt;
          }
        }
        if (typeof scl === "string") {
          parseScale();
          if (typeof scl === "string") parseScale();
        }
        if (!isValidScaleArray(scl)) return dflt;
        return scl;
      }
      function isValidScaleArray(scl) {
        var highestVal = 0;
        if (!Array.isArray(scl) || scl.length < 2) return false;
        if (!scl[0] || !scl[scl.length - 1]) return false;
        if (+scl[0][0] !== 0 || +scl[scl.length - 1][0] !== 1) return false;
        for (var i = 0; i < scl.length; i++) {
          var si = scl[i];
          if (si.length !== 2 || +si[0] < highestVal || !tinycolor(si[1]).isValid()) {
            return false;
          }
          highestVal = +si[0];
        }
        return true;
      }
      function isValidScale(scl) {
        if (scales[scl] !== void 0) return true;
        else return isValidScaleArray(scl);
      }
      module.exports = {
        scales,
        defaultScale,
        get: getScale,
        isValid: isValidScale
      };
    }
  });

  // src/components/color/attributes.js
  var require_attributes3 = __commonJS({
    "src/components/color/attributes.js"(exports) {
      "use strict";
      exports.defaults = [
        "#1f77b4",
        // muted blue
        "#ff7f0e",
        // safety orange
        "#2ca02c",
        // cooked asparagus green
        "#d62728",
        // brick red
        "#9467bd",
        // muted purple
        "#8c564b",
        // chestnut brown
        "#e377c2",
        // raspberry yogurt pink
        "#7f7f7f",
        // middle gray
        "#bcbd22",
        // curry yellow-green
        "#17becf"
        // blue-teal
      ];
      exports.defaultLine = "#444";
      exports.lightLine = "#eee";
      exports.background = "#fff";
      exports.borderLine = "#BEC8D9";
      exports.lightFraction = 100 * (14 - 4) / (15 - 4);
    }
  });

  // src/components/color/index.js
  var require_color = __commonJS({
    "src/components/color/index.js"(exports, module) {
      "use strict";
      var tinycolor = require_tinycolor();
      var isNumeric = require_fast_isnumeric();
      var isTypedArray = require_array().isTypedArray;
      var color = module.exports = {};
      var colorAttrs = require_attributes3();
      color.defaults = colorAttrs.defaults;
      var defaultLine = color.defaultLine = colorAttrs.defaultLine;
      color.lightLine = colorAttrs.lightLine;
      var background = color.background = colorAttrs.background;
      color.tinyRGB = function(tc) {
        var c = tc.toRgb();
        return "rgb(" + Math.round(c.r) + ", " + Math.round(c.g) + ", " + Math.round(c.b) + ")";
      };
      color.rgb = function(cstr) {
        return color.tinyRGB(tinycolor(cstr));
      };
      color.opacity = function(cstr) {
        return cstr ? tinycolor(cstr).getAlpha() : 0;
      };
      color.addOpacity = function(cstr, op) {
        var c = tinycolor(cstr).toRgb();
        return "rgba(" + Math.round(c.r) + ", " + Math.round(c.g) + ", " + Math.round(c.b) + ", " + op + ")";
      };
      color.combine = function(front, back) {
        var fc = tinycolor(front).toRgb();
        if (fc.a === 1) return tinycolor(front).toRgbString();
        var bc = tinycolor(back || background).toRgb();
        var bcflat = bc.a === 1 ? bc : {
          r: 255 * (1 - bc.a) + bc.r * bc.a,
          g: 255 * (1 - bc.a) + bc.g * bc.a,
          b: 255 * (1 - bc.a) + bc.b * bc.a
        };
        var fcflat = {
          r: bcflat.r * (1 - fc.a) + fc.r * fc.a,
          g: bcflat.g * (1 - fc.a) + fc.g * fc.a,
          b: bcflat.b * (1 - fc.a) + fc.b * fc.a
        };
        return tinycolor(fcflat).toRgbString();
      };
      color.interpolate = function(first, second, factor) {
        var fc = tinycolor(first).toRgb();
        var sc = tinycolor(second).toRgb();
        var ic = {
          r: factor * fc.r + (1 - factor) * sc.r,
          g: factor * fc.g + (1 - factor) * sc.g,
          b: factor * fc.b + (1 - factor) * sc.b
        };
        return tinycolor(ic).toRgbString();
      };
      color.contrast = function(cstr, lightAmount, darkAmount) {
        var tc = tinycolor(cstr);
        if (tc.getAlpha() !== 1) tc = tinycolor(color.combine(cstr, background));
        var newColor = tc.isDark() ? lightAmount ? tc.lighten(lightAmount) : background : darkAmount ? tc.darken(darkAmount) : defaultLine;
        return newColor.toString();
      };
      color.stroke = function(s, c) {
        var tc = tinycolor(c);
        s.style({ stroke: color.tinyRGB(tc), "stroke-opacity": tc.getAlpha() });
      };
      color.fill = function(s, c) {
        var tc = tinycolor(c);
        s.style({
          fill: color.tinyRGB(tc),
          "fill-opacity": tc.getAlpha()
        });
      };
      color.clean = function(container) {
        if (!container || typeof container !== "object") return;
        var keys = Object.keys(container);
        var i, j, key, val;
        for (i = 0; i < keys.length; i++) {
          key = keys[i];
          val = container[key];
          if (key.substr(key.length - 5) === "color") {
            if (Array.isArray(val)) {
              for (j = 0; j < val.length; j++) val[j] = cleanOne(val[j]);
            } else container[key] = cleanOne(val);
          } else if (key.substr(key.length - 10) === "colorscale" && Array.isArray(val)) {
            for (j = 0; j < val.length; j++) {
              if (Array.isArray(val[j])) val[j][1] = cleanOne(val[j][1]);
            }
          } else if (Array.isArray(val)) {
            var el0 = val[0];
            if (!Array.isArray(el0) && el0 && typeof el0 === "object") {
              for (j = 0; j < val.length; j++) color.clean(val[j]);
            }
          } else if (val && typeof val === "object" && !isTypedArray(val)) color.clean(val);
        }
      };
      function cleanOne(val) {
        if (isNumeric(val) || typeof val !== "string") return val;
        var valTrim = val.trim();
        if (valTrim.substr(0, 3) !== "rgb") return val;
        var match = valTrim.match(/^rgba?\s*\(([^()]*)\)$/);
        if (!match) return val;
        var parts = match[1].trim().split(/\s*[\s,]\s*/);
        var rgba = valTrim.charAt(3) === "a" && parts.length === 4;
        if (!rgba && parts.length !== 3) return val;
        for (var i = 0; i < parts.length; i++) {
          if (!parts[i].length) return val;
          parts[i] = Number(parts[i]);
          if (!(parts[i] >= 0)) {
            return val;
          }
          if (i === 3) {
            if (parts[i] > 1) parts[i] = 1;
          } else if (parts[i] >= 1) {
            return val;
          }
        }
        var rgbStr = Math.round(parts[0] * 255) + ", " + Math.round(parts[1] * 255) + ", " + Math.round(parts[2] * 255);
        if (rgba) return "rgba(" + rgbStr + ", " + parts[3] + ")";
        return "rgb(" + rgbStr + ")";
      }
    }
  });

  // src/constants/interactions.js
  var require_interactions = __commonJS({
    "src/constants/interactions.js"(exports, module) {
      "use strict";
      module.exports = {
        /**
         * Timing information for interactive elements
         */
        SHOW_PLACEHOLDER: 100,
        HIDE_PLACEHOLDER: 1e3,
        // opacity dimming fraction for points that are not in selection
        DESELECTDIM: 0.2
      };
    }
  });

  // src/lib/regex.js
  var require_regex = __commonJS({
    "src/lib/regex.js"(exports) {
      "use strict";
      exports.counter = function(head, tail, openEnded, matchBeginning) {
        var fullTail = (tail || "") + (openEnded ? "" : "$");
        var startWithPrefix = matchBeginning === false ? "" : "^";
        if (head === "xy") {
          return new RegExp(startWithPrefix + "x([2-9]|[1-9][0-9]+)?y([2-9]|[1-9][0-9]+)?" + fullTail);
        }
        return new RegExp(startWithPrefix + head + "([2-9]|[1-9][0-9]+)?" + fullTail);
      };
    }
  });

  // src/lib/coerce.js
  var require_coerce = __commonJS({
    "src/lib/coerce.js"(exports) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var tinycolor = require_tinycolor();
      var extendFlat = require_extend().extendFlat;
      var baseTraceAttrs = require_attributes2();
      var colorscales = require_scales();
      var Color = require_color();
      var DESELECTDIM = require_interactions().DESELECTDIM;
      var nestedProperty = require_nested_property();
      var counterRegex = require_regex().counter;
      var modHalf = require_mod().modHalf;
      var isArrayOrTypedArray = require_array().isArrayOrTypedArray;
      var isTypedArraySpec = require_array().isTypedArraySpec;
      var decodeTypedArraySpec = require_array().decodeTypedArraySpec;
      exports.valObjectMeta = {
        data_array: {
          // You can use *dflt=[] to force said array to exist though.
          coerceFunction: function(v, propOut, dflt) {
            propOut.set(
              isArrayOrTypedArray(v) ? v : isTypedArraySpec(v) ? decodeTypedArraySpec(v) : dflt
            );
          }
        },
        enumerated: {
          coerceFunction: function(v, propOut, dflt, opts) {
            if (opts.coerceNumber) v = +v;
            if (opts.values.indexOf(v) === -1) propOut.set(dflt);
            else propOut.set(v);
          },
          validateFunction: function(v, opts) {
            if (opts.coerceNumber) v = +v;
            var values = opts.values;
            for (var i = 0; i < values.length; i++) {
              var k = String(values[i]);
              if (k.charAt(0) === "/" && k.charAt(k.length - 1) === "/") {
                var regex = new RegExp(k.substr(1, k.length - 2));
                if (regex.test(v)) return true;
              } else if (v === values[i]) return true;
            }
            return false;
          }
        },
        boolean: {
          coerceFunction: function(v, propOut, dflt) {
            if (v === true || v === false) propOut.set(v);
            else propOut.set(dflt);
          }
        },
        number: {
          coerceFunction: function(v, propOut, dflt, opts) {
            if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
            if (!isNumeric(v) || opts.min !== void 0 && v < opts.min || opts.max !== void 0 && v > opts.max) {
              propOut.set(dflt);
            } else propOut.set(+v);
          }
        },
        integer: {
          coerceFunction: function(v, propOut, dflt, opts) {
            if ((opts.extras || []).indexOf(v) !== -1) {
              propOut.set(v);
              return;
            }
            if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
            if (v % 1 || !isNumeric(v) || opts.min !== void 0 && v < opts.min || opts.max !== void 0 && v > opts.max) {
              propOut.set(dflt);
            } else propOut.set(+v);
          }
        },
        string: {
          // TODO 'values shouldn't be in there (edge case: 'dash' in Scatter)
          coerceFunction: function(v, propOut, dflt, opts) {
            if (typeof v !== "string") {
              var okToCoerce = typeof v === "number";
              if (opts.strict === true || !okToCoerce) propOut.set(dflt);
              else propOut.set(String(v));
            } else if (opts.noBlank && !v) propOut.set(dflt);
            else propOut.set(v);
          }
        },
        color: {
          coerceFunction: function(v, propOut, dflt) {
            if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
            if (tinycolor(v).isValid()) propOut.set(v);
            else propOut.set(dflt);
          }
        },
        colorlist: {
          coerceFunction: function(v, propOut, dflt) {
            function isColor(color) {
              return tinycolor(color).isValid();
            }
            if (!Array.isArray(v) || !v.length) propOut.set(dflt);
            else if (v.every(isColor)) propOut.set(v);
            else propOut.set(dflt);
          }
        },
        colorscale: {
          coerceFunction: function(v, propOut, dflt) {
            propOut.set(colorscales.get(v, dflt));
          }
        },
        angle: {
          coerceFunction: function(v, propOut, dflt) {
            if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
            if (v === "auto") propOut.set("auto");
            else if (!isNumeric(v)) propOut.set(dflt);
            else propOut.set(modHalf(+v, 360));
          }
        },
        subplotid: {
          coerceFunction: function(v, propOut, dflt, opts) {
            var regex = opts.regex || counterRegex(dflt);
            if (typeof v === "string" && regex.test(v)) {
              propOut.set(v);
              return;
            }
            propOut.set(dflt);
          },
          validateFunction: function(v, opts) {
            var dflt = opts.dflt;
            if (v === dflt) return true;
            if (typeof v !== "string") return false;
            if (counterRegex(dflt).test(v)) return true;
            return false;
          }
        },
        flaglist: {
          coerceFunction: function(v, propOut, dflt, opts) {
            if ((opts.extras || []).indexOf(v) !== -1) {
              propOut.set(v);
              return;
            }
            if (typeof v !== "string") {
              propOut.set(dflt);
              return;
            }
            var vParts = v.split("+");
            var i = 0;
            while (i < vParts.length) {
              var vi = vParts[i];
              if (opts.flags.indexOf(vi) === -1 || vParts.indexOf(vi) < i) {
                vParts.splice(i, 1);
              } else i++;
            }
            if (!vParts.length) propOut.set(dflt);
            else propOut.set(vParts.join("+"));
          }
        },
        any: {
          coerceFunction: function(v, propOut, dflt) {
            if (v === void 0) {
              propOut.set(dflt);
            } else {
              propOut.set(
                isTypedArraySpec(v) ? decodeTypedArraySpec(v) : v
              );
            }
          }
        },
        info_array: {
          // set `dimensions=2` for a 2D array or '1-2' for either
          // `items` may be a single object instead of an array, in which case
          // `freeLength` must be true.
          // if `dimensions='1-2'` and items is a 1D array, then the value can
          // either be a matching 1D array or an array of such matching 1D arrays
          coerceFunction: function(v, propOut, dflt, opts) {
            function coercePart(v2, opts2, dflt2) {
              var out;
              var propPart = { set: function(v3) {
                out = v3;
              } };
              if (dflt2 === void 0) dflt2 = opts2.dflt;
              exports.valObjectMeta[opts2.valType].coerceFunction(v2, propPart, dflt2, opts2);
              return out;
            }
            if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
            if (!isArrayOrTypedArray(v)) {
              propOut.set(dflt);
              return;
            }
            var twoD = opts.dimensions === 2 || opts.dimensions === "1-2" && Array.isArray(v) && isArrayOrTypedArray(v[0]);
            var items = opts.items;
            var vOut = [];
            var arrayItems = Array.isArray(items);
            var arrayItems2D = arrayItems && twoD && isArrayOrTypedArray(items[0]);
            var innerItemsOnly = twoD && arrayItems && !arrayItems2D;
            var len = arrayItems && !innerItemsOnly ? items.length : v.length;
            var i, j, row, item, len2, vNew;
            dflt = Array.isArray(dflt) ? dflt : [];
            if (twoD) {
              for (i = 0; i < len; i++) {
                vOut[i] = [];
                row = isArrayOrTypedArray(v[i]) ? v[i] : [];
                if (innerItemsOnly) len2 = items.length;
                else if (arrayItems) len2 = items[i].length;
                else len2 = row.length;
                for (j = 0; j < len2; j++) {
                  if (innerItemsOnly) item = items[j];
                  else if (arrayItems) item = items[i][j];
                  else item = items;
                  vNew = coercePart(row[j], item, (dflt[i] || [])[j]);
                  if (vNew !== void 0) vOut[i][j] = vNew;
                }
              }
            } else {
              for (i = 0; i < len; i++) {
                vNew = coercePart(v[i], arrayItems ? items[i] : items, dflt[i]);
                if (vNew !== void 0) vOut[i] = vNew;
              }
            }
            propOut.set(vOut);
          },
          validateFunction: function(v, opts) {
            if (!isArrayOrTypedArray(v)) return false;
            var items = opts.items;
            var arrayItems = Array.isArray(items);
            var twoD = opts.dimensions === 2;
            if (!opts.freeLength && v.length !== items.length) return false;
            for (var i = 0; i < v.length; i++) {
              if (twoD) {
                if (!isArrayOrTypedArray(v[i]) || !opts.freeLength && v[i].length !== items[i].length) {
                  return false;
                }
                for (var j = 0; j < v[i].length; j++) {
                  if (!validate(v[i][j], arrayItems ? items[i][j] : items)) {
                    return false;
                  }
                }
              } else if (!validate(v[i], arrayItems ? items[i] : items)) return false;
            }
            return true;
          }
        }
      };
      exports.coerce = function(containerIn, containerOut, attributes, attribute, dflt) {
        var opts = nestedProperty(attributes, attribute).get();
        var propIn = nestedProperty(containerIn, attribute);
        var propOut = nestedProperty(containerOut, attribute);
        var v = propIn.get();
        var template = containerOut._template;
        if (v === void 0 && template) {
          v = nestedProperty(template, attribute).get();
          template = 0;
        }
        if (dflt === void 0) dflt = opts.dflt;
        if (opts.arrayOk) {
          if (isArrayOrTypedArray(v)) {
            propOut.set(v);
            return v;
          } else {
            if (isTypedArraySpec(v)) {
              v = decodeTypedArraySpec(v);
              propOut.set(v);
              return v;
            }
          }
        }
        var coerceFunction = exports.valObjectMeta[opts.valType].coerceFunction;
        coerceFunction(v, propOut, dflt, opts);
        var out = propOut.get();
        if (template && out === dflt && !validate(v, opts)) {
          v = nestedProperty(template, attribute).get();
          coerceFunction(v, propOut, dflt, opts);
          out = propOut.get();
        }
        return out;
      };
      exports.coerce2 = function(containerIn, containerOut, attributes, attribute, dflt) {
        var propIn = nestedProperty(containerIn, attribute);
        var propOut = exports.coerce(containerIn, containerOut, attributes, attribute, dflt);
        var valIn = propIn.get();
        return valIn !== void 0 && valIn !== null ? propOut : false;
      };
      exports.coerceFont = function(coerce, attr, dfltObj, opts) {
        if (!opts) opts = {};
        dfltObj = extendFlat({}, dfltObj);
        dfltObj = extendFlat(dfltObj, opts.overrideDflt || {});
        var out = {
          family: coerce(attr + ".family", dfltObj.family),
          size: coerce(attr + ".size", dfltObj.size),
          color: coerce(attr + ".color", dfltObj.color),
          weight: coerce(attr + ".weight", dfltObj.weight),
          style: coerce(attr + ".style", dfltObj.style)
        };
        if (!opts.noFontVariant) out.variant = coerce(attr + ".variant", dfltObj.variant);
        if (!opts.noFontLineposition) out.lineposition = coerce(attr + ".lineposition", dfltObj.lineposition);
        if (!opts.noFontTextcase) out.textcase = coerce(attr + ".textcase", dfltObj.textcase);
        if (!opts.noFontShadow) {
          var dfltShadow = dfltObj.shadow;
          if (dfltShadow === "none" && opts.autoShadowDflt) {
            dfltShadow = "auto";
          }
          out.shadow = coerce(attr + ".shadow", dfltShadow);
        }
        return out;
      };
      exports.coercePattern = function(coerce, attr, markerColor, hasMarkerColorscale) {
        var shape = coerce(attr + ".shape");
        if (shape) {
          coerce(attr + ".solidity");
          coerce(attr + ".size");
          var fillmode = coerce(attr + ".fillmode");
          var isOverlay = fillmode === "overlay";
          if (!hasMarkerColorscale) {
            var bgcolor = coerce(
              attr + ".bgcolor",
              isOverlay ? markerColor : void 0
            );
            coerce(
              attr + ".fgcolor",
              isOverlay ? Color.contrast(bgcolor) : markerColor
            );
          }
          coerce(
            attr + ".fgopacity",
            isOverlay ? 0.5 : 1
          );
        }
      };
      exports.coerceHoverinfo = function(traceIn, traceOut, layoutOut) {
        var moduleAttrs = traceOut._module.attributes;
        var attrs = moduleAttrs.hoverinfo ? moduleAttrs : baseTraceAttrs;
        var valObj = attrs.hoverinfo;
        var dflt;
        if (layoutOut._dataLength === 1) {
          var flags = valObj.dflt === "all" ? valObj.flags.slice() : valObj.dflt.split("+");
          flags.splice(flags.indexOf("name"), 1);
          dflt = flags.join("+");
        }
        return exports.coerce(traceIn, traceOut, attrs, "hoverinfo", dflt);
      };
      exports.coerceSelectionMarkerOpacity = function(traceOut, coerce) {
        if (!traceOut.marker) return;
        var mo = traceOut.marker.opacity;
        if (mo === void 0) return;
        var smoDflt;
        var usmoDflt;
        if (!isArrayOrTypedArray(mo) && !traceOut.selected && !traceOut.unselected) {
          smoDflt = mo;
          usmoDflt = DESELECTDIM * mo;
        }
        coerce("selected.marker.opacity", smoDflt);
        coerce("unselected.marker.opacity", usmoDflt);
      };
      function validate(value, opts) {
        var valObjectDef = exports.valObjectMeta[opts.valType];
        if (opts.arrayOk && isArrayOrTypedArray(value)) return true;
        if (valObjectDef.validateFunction) {
          return valObjectDef.validateFunction(value, opts);
        }
        var failed = {};
        var out = failed;
        var propMock = { set: function(v) {
          out = v;
        } };
        valObjectDef.coerceFunction(value, propMock, failed, opts);
        return out !== failed;
      }
      exports.validate = validate;
    }
  });

  // src/plot_api/plot_config.js
  var require_plot_config = __commonJS({
    "src/plot_api/plot_config.js"(exports, module) {
      "use strict";
      var configAttributes = {
        staticPlot: {
          valType: "boolean",
          dflt: false
        },
        typesetMath: {
          valType: "boolean",
          dflt: true
        },
        plotlyServerURL: {
          valType: "string",
          dflt: ""
        },
        editable: {
          valType: "boolean",
          dflt: false
        },
        edits: {
          annotationPosition: {
            valType: "boolean",
            dflt: false
          },
          annotationTail: {
            valType: "boolean",
            dflt: false
          },
          annotationText: {
            valType: "boolean",
            dflt: false
          },
          axisTitleText: {
            valType: "boolean",
            dflt: false
          },
          colorbarPosition: {
            valType: "boolean",
            dflt: false
          },
          colorbarTitleText: {
            valType: "boolean",
            dflt: false
          },
          legendPosition: {
            valType: "boolean",
            dflt: false
          },
          legendText: {
            valType: "boolean",
            dflt: false
          },
          shapePosition: {
            valType: "boolean",
            dflt: false
          },
          titleText: {
            valType: "boolean",
            dflt: false
          }
        },
        editSelection: {
          valType: "boolean",
          dflt: true
        },
        autosizable: {
          valType: "boolean",
          dflt: false
        },
        responsive: {
          valType: "boolean",
          dflt: false
        },
        fillFrame: {
          valType: "boolean",
          dflt: false
        },
        frameMargins: {
          valType: "number",
          dflt: 0,
          min: 0,
          max: 0.5
        },
        scrollZoom: {
          valType: "flaglist",
          flags: ["cartesian", "gl3d", "geo", "mapbox", "map"],
          extras: [true, false],
          dflt: "gl3d+geo+map"
        },
        doubleClick: {
          valType: "enumerated",
          values: [false, "reset", "autosize", "reset+autosize"],
          dflt: "reset+autosize"
        },
        doubleClickDelay: {
          valType: "number",
          dflt: 300,
          min: 0
        },
        showAxisDragHandles: {
          valType: "boolean",
          dflt: true
        },
        showAxisRangeEntryBoxes: {
          valType: "boolean",
          dflt: true
        },
        showTips: {
          valType: "boolean",
          dflt: true
        },
        showLink: {
          valType: "boolean",
          dflt: false
        },
        linkText: {
          valType: "string",
          dflt: "Edit chart",
          noBlank: true
        },
        sendData: {
          valType: "boolean",
          dflt: true
        },
        showSources: {
          valType: "any",
          dflt: false
        },
        displayModeBar: {
          valType: "enumerated",
          values: ["hover", true, false],
          dflt: "hover"
        },
        showSendToCloud: {
          valType: "boolean",
          dflt: false
        },
        showEditInChartStudio: {
          valType: "boolean",
          dflt: false
        },
        modeBarButtonsToRemove: {
          valType: "any",
          dflt: []
        },
        modeBarButtonsToAdd: {
          valType: "any",
          dflt: []
        },
        modeBarButtons: {
          valType: "any",
          dflt: false
        },
        toImageButtonOptions: {
          valType: "any",
          dflt: {}
        },
        displaylogo: {
          valType: "boolean",
          dflt: true
        },
        watermark: {
          valType: "boolean",
          dflt: false
        },
        plotGlPixelRatio: {
          valType: "number",
          dflt: 2,
          min: 1,
          max: 4
        },
        setBackground: {
          valType: "any",
          dflt: "transparent"
        },
        topojsonURL: {
          valType: "string",
          noBlank: true,
          dflt: "https://cdn.plot.ly/"
        },
        mapboxAccessToken: {
          valType: "string",
          dflt: null
        },
        logging: {
          valType: "integer",
          min: 0,
          max: 2,
          dflt: 1
        },
        notifyOnLogging: {
          valType: "integer",
          min: 0,
          max: 2,
          dflt: 0
        },
        queueLength: {
          valType: "integer",
          min: 0,
          dflt: 0
        },
        locale: {
          valType: "string",
          dflt: "en-US"
        },
        locales: {
          valType: "any",
          dflt: {}
        }
      };
      var dfltConfig = {};
      function crawl(src, target) {
        for (var k in src) {
          var obj = src[k];
          if (obj.valType) {
            target[k] = obj.dflt;
          } else {
            if (!target[k]) {
              target[k] = {};
            }
            crawl(obj, target[k]);
          }
        }
      }
      crawl(configAttributes, dfltConfig);
      module.exports = {
        configAttributes,
        dfltConfig
      };
    }
  });

  // src/lib/notifier.js
  var require_notifier = __commonJS({
    "src/lib/notifier.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var NOTEDATA = [];
      module.exports = function(text, displayLength) {
        if (NOTEDATA.indexOf(text) !== -1) return;
        NOTEDATA.push(text);
        var ts = 1e3;
        if (isNumeric(displayLength)) ts = displayLength;
        else if (displayLength === "long") ts = 3e3;
        var notifierContainer = d3.select("body").selectAll(".plotly-notifier").data([0]);
        notifierContainer.enter().append("div").classed("plotly-notifier", true);
        var notes = notifierContainer.selectAll(".notifier-note").data(NOTEDATA);
        function killNote(transition) {
          transition.duration(700).style("opacity", 0).each("end", function(thisText) {
            var thisIndex = NOTEDATA.indexOf(thisText);
            if (thisIndex !== -1) NOTEDATA.splice(thisIndex, 1);
            d3.select(this).remove();
          });
        }
        notes.enter().append("div").classed("notifier-note", true).style("opacity", 0).each(function(thisText) {
          var note = d3.select(this);
          note.append("button").classed("notifier-close", true).html("&times;").on("click", function() {
            note.transition().call(killNote);
          });
          var p = note.append("p");
          var lines = thisText.split(/<br\s*\/?>/g);
          for (var i = 0; i < lines.length; i++) {
            if (i) p.append("br");
            p.append("span").text(lines[i]);
          }
          if (displayLength === "stick") {
            note.transition().duration(350).style("opacity", 1);
          } else {
            note.transition().duration(700).style("opacity", 1).transition().delay(ts).call(killNote);
          }
        });
      };
    }
  });

  // src/lib/loggers.js
  var require_loggers = __commonJS({
    "src/lib/loggers.js"(exports, module) {
      "use strict";
      var dfltConfig = require_plot_config().dfltConfig;
      var notifier = require_notifier();
      var loggers = module.exports = {};
      loggers.log = function() {
        var i;
        if (dfltConfig.logging > 1) {
          var messages = ["LOG:"];
          for (i = 0; i < arguments.length; i++) {
            messages.push(arguments[i]);
          }
          console.trace.apply(console, messages);
        }
        if (dfltConfig.notifyOnLogging > 1) {
          var lines = [];
          for (i = 0; i < arguments.length; i++) {
            lines.push(arguments[i]);
          }
          notifier(lines.join("<br>"), "long");
        }
      };
      loggers.warn = function() {
        var i;
        if (dfltConfig.logging > 0) {
          var messages = ["WARN:"];
          for (i = 0; i < arguments.length; i++) {
            messages.push(arguments[i]);
          }
          console.trace.apply(console, messages);
        }
        if (dfltConfig.notifyOnLogging > 0) {
          var lines = [];
          for (i = 0; i < arguments.length; i++) {
            lines.push(arguments[i]);
          }
          notifier(lines.join("<br>"), "stick");
        }
      };
      loggers.error = function() {
        var i;
        if (dfltConfig.logging > 0) {
          var messages = ["ERROR:"];
          for (i = 0; i < arguments.length; i++) {
            messages.push(arguments[i]);
          }
          console.error.apply(console, messages);
        }
        if (dfltConfig.notifyOnLogging > 0) {
          var lines = [];
          for (i = 0; i < arguments.length; i++) {
            lines.push(arguments[i]);
          }
          notifier(lines.join("<br>"), "stick");
        }
      };
    }
  });

  // src/lib/noop.js
  var require_noop = __commonJS({
    "src/lib/noop.js"(exports, module) {
      "use strict";
      module.exports = function noop() {
      };
    }
  });

  // src/lib/push_unique.js
  var require_push_unique = __commonJS({
    "src/lib/push_unique.js"(exports, module) {
      "use strict";
      module.exports = function pushUnique(array, item) {
        if (item instanceof RegExp) {
          var itemStr = item.toString();
          for (var i = 0; i < array.length; i++) {
            if (array[i] instanceof RegExp && array[i].toString() === itemStr) {
              return array;
            }
          }
          array.push(item);
        } else if ((item || item === 0) && array.indexOf(item) === -1) array.push(item);
        return array;
      };
    }
  });

  // node_modules/gl-mat4/create.js
  var require_create = __commonJS({
    "node_modules/gl-mat4/create.js"(exports, module) {
      module.exports = create;
      function create() {
        var out = new Float32Array(16);
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/clone.js
  var require_clone = __commonJS({
    "node_modules/gl-mat4/clone.js"(exports, module) {
      module.exports = clone;
      function clone(a) {
        var out = new Float32Array(16);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
        return out;
      }
    }
  });

  // node_modules/gl-mat4/copy.js
  var require_copy = __commonJS({
    "node_modules/gl-mat4/copy.js"(exports, module) {
      module.exports = copy;
      function copy(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
        return out;
      }
    }
  });

  // node_modules/gl-mat4/identity.js
  var require_identity = __commonJS({
    "node_modules/gl-mat4/identity.js"(exports, module) {
      module.exports = identity;
      function identity(out) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/transpose.js
  var require_transpose = __commonJS({
    "node_modules/gl-mat4/transpose.js"(exports, module) {
      module.exports = transpose;
      function transpose(out, a) {
        if (out === a) {
          var a01 = a[1], a02 = a[2], a03 = a[3], a12 = a[6], a13 = a[7], a23 = a[11];
          out[1] = a[4];
          out[2] = a[8];
          out[3] = a[12];
          out[4] = a01;
          out[6] = a[9];
          out[7] = a[13];
          out[8] = a02;
          out[9] = a12;
          out[11] = a[14];
          out[12] = a03;
          out[13] = a13;
          out[14] = a23;
        } else {
          out[0] = a[0];
          out[1] = a[4];
          out[2] = a[8];
          out[3] = a[12];
          out[4] = a[1];
          out[5] = a[5];
          out[6] = a[9];
          out[7] = a[13];
          out[8] = a[2];
          out[9] = a[6];
          out[10] = a[10];
          out[11] = a[14];
          out[12] = a[3];
          out[13] = a[7];
          out[14] = a[11];
          out[15] = a[15];
        }
        return out;
      }
    }
  });

  // node_modules/gl-mat4/invert.js
  var require_invert = __commonJS({
    "node_modules/gl-mat4/invert.js"(exports, module) {
      module.exports = invert;
      function invert(out, a) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) {
          return null;
        }
        det = 1 / det;
        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
        out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
        out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
        out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
        out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
        out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
        out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/adjoint.js
  var require_adjoint = __commonJS({
    "node_modules/gl-mat4/adjoint.js"(exports, module) {
      module.exports = adjoint;
      function adjoint(out, a) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
        out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
        out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
        out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
        out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
        out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
        out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
        out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
        out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
        out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
        out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
        out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
        out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
        out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
        out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
        out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
        out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
        return out;
      }
    }
  });

  // node_modules/gl-mat4/determinant.js
  var require_determinant = __commonJS({
    "node_modules/gl-mat4/determinant.js"(exports, module) {
      module.exports = determinant;
      function determinant(a) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;
        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      }
    }
  });

  // node_modules/gl-mat4/multiply.js
  var require_multiply = __commonJS({
    "node_modules/gl-mat4/multiply.js"(exports, module) {
      module.exports = multiply;
      function multiply(out, a, b) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
        out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[4];
        b1 = b[5];
        b2 = b[6];
        b3 = b[7];
        out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[8];
        b1 = b[9];
        b2 = b[10];
        b3 = b[11];
        out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[12];
        b1 = b[13];
        b2 = b[14];
        b3 = b[15];
        out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/translate.js
  var require_translate = __commonJS({
    "node_modules/gl-mat4/translate.js"(exports, module) {
      module.exports = translate;
      function translate(out, a, v) {
        var x = v[0], y = v[1], z = v[2], a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
        if (a === out) {
          out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
          out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
          out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
          out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
        } else {
          a00 = a[0];
          a01 = a[1];
          a02 = a[2];
          a03 = a[3];
          a10 = a[4];
          a11 = a[5];
          a12 = a[6];
          a13 = a[7];
          a20 = a[8];
          a21 = a[9];
          a22 = a[10];
          a23 = a[11];
          out[0] = a00;
          out[1] = a01;
          out[2] = a02;
          out[3] = a03;
          out[4] = a10;
          out[5] = a11;
          out[6] = a12;
          out[7] = a13;
          out[8] = a20;
          out[9] = a21;
          out[10] = a22;
          out[11] = a23;
          out[12] = a00 * x + a10 * y + a20 * z + a[12];
          out[13] = a01 * x + a11 * y + a21 * z + a[13];
          out[14] = a02 * x + a12 * y + a22 * z + a[14];
          out[15] = a03 * x + a13 * y + a23 * z + a[15];
        }
        return out;
      }
    }
  });

  // node_modules/gl-mat4/scale.js
  var require_scale = __commonJS({
    "node_modules/gl-mat4/scale.js"(exports, module) {
      module.exports = scale;
      function scale(out, a, v) {
        var x = v[0], y = v[1], z = v[2];
        out[0] = a[0] * x;
        out[1] = a[1] * x;
        out[2] = a[2] * x;
        out[3] = a[3] * x;
        out[4] = a[4] * y;
        out[5] = a[5] * y;
        out[6] = a[6] * y;
        out[7] = a[7] * y;
        out[8] = a[8] * z;
        out[9] = a[9] * z;
        out[10] = a[10] * z;
        out[11] = a[11] * z;
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
        return out;
      }
    }
  });

  // node_modules/gl-mat4/rotate.js
  var require_rotate = __commonJS({
    "node_modules/gl-mat4/rotate.js"(exports, module) {
      module.exports = rotate;
      function rotate(out, a, rad, axis) {
        var x = axis[0], y = axis[1], z = axis[2], len = Math.sqrt(x * x + y * y + z * z), s, c, t, a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, b00, b01, b02, b10, b11, b12, b20, b21, b22;
        if (Math.abs(len) < 1e-6) {
          return null;
        }
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(rad);
        c = Math.cos(rad);
        t = 1 - c;
        a00 = a[0];
        a01 = a[1];
        a02 = a[2];
        a03 = a[3];
        a10 = a[4];
        a11 = a[5];
        a12 = a[6];
        a13 = a[7];
        a20 = a[8];
        a21 = a[9];
        a22 = a[10];
        a23 = a[11];
        b00 = x * x * t + c;
        b01 = y * x * t + z * s;
        b02 = z * x * t - y * s;
        b10 = x * y * t - z * s;
        b11 = y * y * t + c;
        b12 = z * y * t + x * s;
        b20 = x * z * t + y * s;
        b21 = y * z * t - x * s;
        b22 = z * z * t + c;
        out[0] = a00 * b00 + a10 * b01 + a20 * b02;
        out[1] = a01 * b00 + a11 * b01 + a21 * b02;
        out[2] = a02 * b00 + a12 * b01 + a22 * b02;
        out[3] = a03 * b00 + a13 * b01 + a23 * b02;
        out[4] = a00 * b10 + a10 * b11 + a20 * b12;
        out[5] = a01 * b10 + a11 * b11 + a21 * b12;
        out[6] = a02 * b10 + a12 * b11 + a22 * b12;
        out[7] = a03 * b10 + a13 * b11 + a23 * b12;
        out[8] = a00 * b20 + a10 * b21 + a20 * b22;
        out[9] = a01 * b20 + a11 * b21 + a21 * b22;
        out[10] = a02 * b20 + a12 * b21 + a22 * b22;
        out[11] = a03 * b20 + a13 * b21 + a23 * b22;
        if (a !== out) {
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
        }
        return out;
      }
    }
  });

  // node_modules/gl-mat4/rotateX.js
  var require_rotateX = __commonJS({
    "node_modules/gl-mat4/rotateX.js"(exports, module) {
      module.exports = rotateX;
      function rotateX(out, a, rad) {
        var s = Math.sin(rad), c = Math.cos(rad), a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        if (a !== out) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
        }
        out[4] = a10 * c + a20 * s;
        out[5] = a11 * c + a21 * s;
        out[6] = a12 * c + a22 * s;
        out[7] = a13 * c + a23 * s;
        out[8] = a20 * c - a10 * s;
        out[9] = a21 * c - a11 * s;
        out[10] = a22 * c - a12 * s;
        out[11] = a23 * c - a13 * s;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/rotateY.js
  var require_rotateY = __commonJS({
    "node_modules/gl-mat4/rotateY.js"(exports, module) {
      module.exports = rotateY;
      function rotateY(out, a, rad) {
        var s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        if (a !== out) {
          out[4] = a[4];
          out[5] = a[5];
          out[6] = a[6];
          out[7] = a[7];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
        }
        out[0] = a00 * c - a20 * s;
        out[1] = a01 * c - a21 * s;
        out[2] = a02 * c - a22 * s;
        out[3] = a03 * c - a23 * s;
        out[8] = a00 * s + a20 * c;
        out[9] = a01 * s + a21 * c;
        out[10] = a02 * s + a22 * c;
        out[11] = a03 * s + a23 * c;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/rotateZ.js
  var require_rotateZ = __commonJS({
    "node_modules/gl-mat4/rotateZ.js"(exports, module) {
      module.exports = rotateZ;
      function rotateZ(out, a, rad) {
        var s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
        if (a !== out) {
          out[8] = a[8];
          out[9] = a[9];
          out[10] = a[10];
          out[11] = a[11];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
        }
        out[0] = a00 * c + a10 * s;
        out[1] = a01 * c + a11 * s;
        out[2] = a02 * c + a12 * s;
        out[3] = a03 * c + a13 * s;
        out[4] = a10 * c - a00 * s;
        out[5] = a11 * c - a01 * s;
        out[6] = a12 * c - a02 * s;
        out[7] = a13 * c - a03 * s;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromRotation.js
  var require_fromRotation = __commonJS({
    "node_modules/gl-mat4/fromRotation.js"(exports, module) {
      module.exports = fromRotation;
      function fromRotation(out, rad, axis) {
        var s, c, t;
        var x = axis[0];
        var y = axis[1];
        var z = axis[2];
        var len = Math.sqrt(x * x + y * y + z * z);
        if (Math.abs(len) < 1e-6) {
          return null;
        }
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(rad);
        c = Math.cos(rad);
        t = 1 - c;
        out[0] = x * x * t + c;
        out[1] = y * x * t + z * s;
        out[2] = z * x * t - y * s;
        out[3] = 0;
        out[4] = x * y * t - z * s;
        out[5] = y * y * t + c;
        out[6] = z * y * t + x * s;
        out[7] = 0;
        out[8] = x * z * t + y * s;
        out[9] = y * z * t - x * s;
        out[10] = z * z * t + c;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromRotationTranslation.js
  var require_fromRotationTranslation = __commonJS({
    "node_modules/gl-mat4/fromRotationTranslation.js"(exports, module) {
      module.exports = fromRotationTranslation;
      function fromRotationTranslation(out, q, v) {
        var x = q[0], y = q[1], z = q[2], w = q[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
        out[0] = 1 - (yy + zz);
        out[1] = xy + wz;
        out[2] = xz - wy;
        out[3] = 0;
        out[4] = xy - wz;
        out[5] = 1 - (xx + zz);
        out[6] = yz + wx;
        out[7] = 0;
        out[8] = xz + wy;
        out[9] = yz - wx;
        out[10] = 1 - (xx + yy);
        out[11] = 0;
        out[12] = v[0];
        out[13] = v[1];
        out[14] = v[2];
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromScaling.js
  var require_fromScaling = __commonJS({
    "node_modules/gl-mat4/fromScaling.js"(exports, module) {
      module.exports = fromScaling;
      function fromScaling(out, v) {
        out[0] = v[0];
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = v[1];
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = v[2];
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromTranslation.js
  var require_fromTranslation = __commonJS({
    "node_modules/gl-mat4/fromTranslation.js"(exports, module) {
      module.exports = fromTranslation;
      function fromTranslation(out, v) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = v[0];
        out[13] = v[1];
        out[14] = v[2];
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromXRotation.js
  var require_fromXRotation = __commonJS({
    "node_modules/gl-mat4/fromXRotation.js"(exports, module) {
      module.exports = fromXRotation;
      function fromXRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = c;
        out[6] = s;
        out[7] = 0;
        out[8] = 0;
        out[9] = -s;
        out[10] = c;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromYRotation.js
  var require_fromYRotation = __commonJS({
    "node_modules/gl-mat4/fromYRotation.js"(exports, module) {
      module.exports = fromYRotation;
      function fromYRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        out[0] = c;
        out[1] = 0;
        out[2] = -s;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = s;
        out[9] = 0;
        out[10] = c;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromZRotation.js
  var require_fromZRotation = __commonJS({
    "node_modules/gl-mat4/fromZRotation.js"(exports, module) {
      module.exports = fromZRotation;
      function fromZRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        out[0] = c;
        out[1] = s;
        out[2] = 0;
        out[3] = 0;
        out[4] = -s;
        out[5] = c;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromQuat.js
  var require_fromQuat = __commonJS({
    "node_modules/gl-mat4/fromQuat.js"(exports, module) {
      module.exports = fromQuat;
      function fromQuat(out, q) {
        var x = q[0], y = q[1], z = q[2], w = q[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
        out[0] = 1 - yy - zz;
        out[1] = yx + wz;
        out[2] = zx - wy;
        out[3] = 0;
        out[4] = yx - wz;
        out[5] = 1 - xx - zz;
        out[6] = zy + wx;
        out[7] = 0;
        out[8] = zx + wy;
        out[9] = zy - wx;
        out[10] = 1 - xx - yy;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/frustum.js
  var require_frustum = __commonJS({
    "node_modules/gl-mat4/frustum.js"(exports, module) {
      module.exports = frustum;
      function frustum(out, left, right, bottom, top, near, far) {
        var rl = 1 / (right - left), tb = 1 / (top - bottom), nf = 1 / (near - far);
        out[0] = near * 2 * rl;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = near * 2 * tb;
        out[6] = 0;
        out[7] = 0;
        out[8] = (right + left) * rl;
        out[9] = (top + bottom) * tb;
        out[10] = (far + near) * nf;
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[14] = far * near * 2 * nf;
        out[15] = 0;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/perspective.js
  var require_perspective = __commonJS({
    "node_modules/gl-mat4/perspective.js"(exports, module) {
      module.exports = perspective;
      function perspective(out, fovy, aspect, near, far) {
        var f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
        out[0] = f / aspect;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = f;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = (far + near) * nf;
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[14] = 2 * far * near * nf;
        out[15] = 0;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/perspectiveFromFieldOfView.js
  var require_perspectiveFromFieldOfView = __commonJS({
    "node_modules/gl-mat4/perspectiveFromFieldOfView.js"(exports, module) {
      module.exports = perspectiveFromFieldOfView;
      function perspectiveFromFieldOfView(out, fov, near, far) {
        var upTan = Math.tan(fov.upDegrees * Math.PI / 180), downTan = Math.tan(fov.downDegrees * Math.PI / 180), leftTan = Math.tan(fov.leftDegrees * Math.PI / 180), rightTan = Math.tan(fov.rightDegrees * Math.PI / 180), xScale = 2 / (leftTan + rightTan), yScale = 2 / (upTan + downTan);
        out[0] = xScale;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = yScale;
        out[6] = 0;
        out[7] = 0;
        out[8] = -((leftTan - rightTan) * xScale * 0.5);
        out[9] = (upTan - downTan) * yScale * 0.5;
        out[10] = far / (near - far);
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[14] = far * near / (near - far);
        out[15] = 0;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/ortho.js
  var require_ortho = __commonJS({
    "node_modules/gl-mat4/ortho.js"(exports, module) {
      module.exports = ortho;
      function ortho(out, left, right, bottom, top, near, far) {
        var lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
        out[0] = -2 * lr;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = -2 * bt;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 2 * nf;
        out[11] = 0;
        out[12] = (left + right) * lr;
        out[13] = (top + bottom) * bt;
        out[14] = (far + near) * nf;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/lookAt.js
  var require_lookAt = __commonJS({
    "node_modules/gl-mat4/lookAt.js"(exports, module) {
      var identity = require_identity();
      module.exports = lookAt;
      function lookAt(out, eye, center, up) {
        var x0, x1, x2, y0, y1, y2, z0, z1, z2, len, eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2], centerx = center[0], centery = center[1], centerz = center[2];
        if (Math.abs(eyex - centerx) < 1e-6 && Math.abs(eyey - centery) < 1e-6 && Math.abs(eyez - centerz) < 1e-6) {
          return identity(out);
        }
        z0 = eyex - centerx;
        z1 = eyey - centery;
        z2 = eyez - centerz;
        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;
        x0 = upy * z2 - upz * z1;
        x1 = upz * z0 - upx * z2;
        x2 = upx * z1 - upy * z0;
        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        if (!len) {
          x0 = 0;
          x1 = 0;
          x2 = 0;
        } else {
          len = 1 / len;
          x0 *= len;
          x1 *= len;
          x2 *= len;
        }
        y0 = z1 * x2 - z2 * x1;
        y1 = z2 * x0 - z0 * x2;
        y2 = z0 * x1 - z1 * x0;
        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
        if (!len) {
          y0 = 0;
          y1 = 0;
          y2 = 0;
        } else {
          len = 1 / len;
          y0 *= len;
          y1 *= len;
          y2 *= len;
        }
        out[0] = x0;
        out[1] = y0;
        out[2] = z0;
        out[3] = 0;
        out[4] = x1;
        out[5] = y1;
        out[6] = z1;
        out[7] = 0;
        out[8] = x2;
        out[9] = y2;
        out[10] = z2;
        out[11] = 0;
        out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
        out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
        out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/str.js
  var require_str = __commonJS({
    "node_modules/gl-mat4/str.js"(exports, module) {
      module.exports = str;
      function str(a) {
        return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
      }
    }
  });

  // node_modules/gl-mat4/index.js
  var require_gl_mat4 = __commonJS({
    "node_modules/gl-mat4/index.js"(exports, module) {
      module.exports = {
        create: require_create(),
        clone: require_clone(),
        copy: require_copy(),
        identity: require_identity(),
        transpose: require_transpose(),
        invert: require_invert(),
        adjoint: require_adjoint(),
        determinant: require_determinant(),
        multiply: require_multiply(),
        translate: require_translate(),
        scale: require_scale(),
        rotate: require_rotate(),
        rotateX: require_rotateX(),
        rotateY: require_rotateY(),
        rotateZ: require_rotateZ(),
        fromRotation: require_fromRotation(),
        fromRotationTranslation: require_fromRotationTranslation(),
        fromScaling: require_fromScaling(),
        fromTranslation: require_fromTranslation(),
        fromXRotation: require_fromXRotation(),
        fromYRotation: require_fromYRotation(),
        fromZRotation: require_fromZRotation(),
        fromQuat: require_fromQuat(),
        frustum: require_frustum(),
        perspective: require_perspective(),
        perspectiveFromFieldOfView: require_perspectiveFromFieldOfView(),
        ortho: require_ortho(),
        lookAt: require_lookAt(),
        str: require_str()
      };
    }
  });

  // src/lib/matrix.js
  var require_matrix = __commonJS({
    "src/lib/matrix.js"(exports) {
      "use strict";
      var mat4X4 = require_gl_mat4();
      exports.init2dArray = function(rowLength, colLength) {
        var array = new Array(rowLength);
        for (var i = 0; i < rowLength; i++) array[i] = new Array(colLength);
        return array;
      };
      exports.transposeRagged = function(z) {
        var maxlen = 0;
        var zlen = z.length;
        var i, j;
        for (i = 0; i < zlen; i++) maxlen = Math.max(maxlen, z[i].length);
        var t = new Array(maxlen);
        for (i = 0; i < maxlen; i++) {
          t[i] = new Array(zlen);
          for (j = 0; j < zlen; j++) t[i][j] = z[j][i];
        }
        return t;
      };
      exports.dot = function(x, y) {
        if (!(x.length && y.length) || x.length !== y.length) return null;
        var len = x.length;
        var out;
        var i;
        if (x[0].length) {
          out = new Array(len);
          for (i = 0; i < len; i++) out[i] = exports.dot(x[i], y);
        } else if (y[0].length) {
          var yTranspose = exports.transposeRagged(y);
          out = new Array(yTranspose.length);
          for (i = 0; i < yTranspose.length; i++) out[i] = exports.dot(x, yTranspose[i]);
        } else {
          out = 0;
          for (i = 0; i < len; i++) out += x[i] * y[i];
        }
        return out;
      };
      exports.translationMatrix = function(x, y) {
        return [[1, 0, x], [0, 1, y], [0, 0, 1]];
      };
      exports.rotationMatrix = function(alpha) {
        var a = alpha * Math.PI / 180;
        return [
          [Math.cos(a), -Math.sin(a), 0],
          [Math.sin(a), Math.cos(a), 0],
          [0, 0, 1]
        ];
      };
      exports.rotationXYMatrix = function(a, x, y) {
        return exports.dot(
          exports.dot(
            exports.translationMatrix(x, y),
            exports.rotationMatrix(a)
          ),
          exports.translationMatrix(-x, -y)
        );
      };
      exports.apply3DTransform = function(transform) {
        return function() {
          var args = arguments;
          var xyz = arguments.length === 1 ? args[0] : [args[0], args[1], args[2] || 0];
          return exports.dot(transform, [xyz[0], xyz[1], xyz[2], 1]).slice(0, 3);
        };
      };
      exports.apply2DTransform = function(transform) {
        return function() {
          var args = arguments;
          if (args.length === 3) {
            args = args[0];
          }
          var xy = arguments.length === 1 ? args[0] : [args[0], args[1]];
          return exports.dot(transform, [xy[0], xy[1], 1]).slice(0, 2);
        };
      };
      exports.apply2DTransform2 = function(transform) {
        var at = exports.apply2DTransform(transform);
        return function(xys) {
          return at(xys.slice(0, 2)).concat(at(xys.slice(2, 4)));
        };
      };
      exports.convertCssMatrix = function(m) {
        if (m) {
          var len = m.length;
          if (len === 16) return m;
          if (len === 6) {
            return [
              m[0],
              m[1],
              0,
              0,
              m[2],
              m[3],
              0,
              0,
              0,
              0,
              1,
              0,
              m[4],
              m[5],
              0,
              1
            ];
          }
        }
        return [
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ];
      };
      exports.inverseTransformMatrix = function(m) {
        var out = [];
        mat4X4.invert(out, m);
        return [
          [out[0], out[1], out[2], out[3]],
          [out[4], out[5], out[6], out[7]],
          [out[8], out[9], out[10], out[11]],
          [out[12], out[13], out[14], out[15]]
        ];
      };
    }
  });

  // src/lib/dom.js
  var require_dom = __commonJS({
    "src/lib/dom.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var loggers = require_loggers();
      var matrix = require_matrix();
      var mat4X4 = require_gl_mat4();
      function getGraphDiv(gd) {
        var gdElement;
        if (typeof gd === "string") {
          gdElement = document.getElementById(gd);
          if (gdElement === null) {
            throw new Error("No DOM element with id '" + gd + "' exists on the page.");
          }
          return gdElement;
        } else if (gd === null || gd === void 0) {
          throw new Error("DOM element provided is null or undefined");
        }
        return gd;
      }
      function isPlotDiv(el) {
        var el3 = d3.select(el);
        return el3.node() instanceof HTMLElement && el3.size() && el3.classed("js-plotly-plot");
      }
      function removeElement(el) {
        var elParent = el && el.parentNode;
        if (elParent) elParent.removeChild(el);
      }
      function addStyleRule(selector, styleString) {
        addRelatedStyleRule("global", selector, styleString);
      }
      function addRelatedStyleRule(uid, selector, styleString) {
        var id = "plotly.js-style-" + uid;
        var style = document.getElementById(id);
        if (style && style.matches(".no-inline-styles")) {
          return;
        }
        if (!style) {
          style = document.createElement("style");
          style.setAttribute("id", id);
          style.appendChild(document.createTextNode(""));
          document.head.appendChild(style);
        }
        var styleSheet = style.sheet;
        if (!styleSheet) {
          loggers.warn("Cannot addRelatedStyleRule, probably due to strict CSP...");
        } else if (styleSheet.insertRule) {
          styleSheet.insertRule(selector + "{" + styleString + "}", 0);
        } else if (styleSheet.addRule) {
          styleSheet.addRule(selector, styleString, 0);
        } else loggers.warn("addStyleRule failed");
      }
      function deleteRelatedStyleRule(uid) {
        var id = "plotly.js-style-" + uid;
        var style = document.getElementById(id);
        if (style) removeElement(style);
      }
      function setStyleOnHover(selector, activeSelector, childSelector, activeStyle, inactiveStyle, element) {
        var activeStyleParts = activeStyle.split(":");
        var inactiveStyleParts = inactiveStyle.split(":");
        var eventAddedAttrName = "data-btn-style-event-added";
        if (!element) {
          element = document;
        }
        element.querySelectorAll(selector).forEach(function(el) {
          if (!el.getAttribute(eventAddedAttrName)) {
            el.addEventListener("mouseenter", function() {
              var childEl = this.querySelector(childSelector);
              if (childEl) {
                childEl.style[activeStyleParts[0]] = activeStyleParts[1];
              }
            });
            el.addEventListener("mouseleave", function() {
              var childEl = this.querySelector(childSelector);
              if (childEl) {
                if (activeSelector && this.matches(activeSelector)) {
                  childEl.style[activeStyleParts[0]] = activeStyleParts[1];
                } else {
                  childEl.style[inactiveStyleParts[0]] = inactiveStyleParts[1];
                }
              }
            });
            el.setAttribute(eventAddedAttrName, true);
          }
        });
      }
      function getFullTransformMatrix(element) {
        var allElements = getElementAndAncestors(element);
        var out = [
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ];
        allElements.forEach(function(e) {
          var t = getElementTransformMatrix(e);
          if (t) {
            var m = matrix.convertCssMatrix(t);
            out = mat4X4.multiply(out, out, m);
          }
        });
        return out;
      }
      function getElementTransformMatrix(element) {
        var style = window.getComputedStyle(element, null);
        var transform = style.getPropertyValue("-webkit-transform") || style.getPropertyValue("-moz-transform") || style.getPropertyValue("-ms-transform") || style.getPropertyValue("-o-transform") || style.getPropertyValue("transform");
        if (transform === "none") return null;
        return transform.replace("matrix", "").replace("3d", "").slice(1, -1).split(",").map(function(n) {
          return +n;
        });
      }
      function getElementAndAncestors(element) {
        var allElements = [];
        while (isTransformableElement(element)) {
          allElements.push(element);
          element = element.parentNode;
          if (typeof ShadowRoot === "function" && element instanceof ShadowRoot) {
            element = element.host;
          }
        }
        return allElements;
      }
      function isTransformableElement(element) {
        return element && (element instanceof Element || element instanceof HTMLElement);
      }
      function equalDomRects(a, b) {
        return a && b && a.top === b.top && a.left === b.left && a.right === b.right && a.bottom === b.bottom;
      }
      module.exports = {
        getGraphDiv,
        isPlotDiv,
        removeElement,
        addStyleRule,
        addRelatedStyleRule,
        deleteRelatedStyleRule,
        setStyleOnHover,
        getFullTransformMatrix,
        getElementTransformMatrix,
        getElementAndAncestors,
        equalDomRects
      };
    }
  });

  // src/plots/animation_attributes.js
  var require_animation_attributes = __commonJS({
    "src/plots/animation_attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        mode: {
          valType: "enumerated",
          dflt: "afterall",
          values: ["immediate", "next", "afterall"]
        },
        direction: {
          valType: "enumerated",
          values: ["forward", "reverse"],
          dflt: "forward"
        },
        fromcurrent: {
          valType: "boolean",
          dflt: false
        },
        frame: {
          duration: {
            valType: "number",
            min: 0,
            dflt: 500
          },
          redraw: {
            valType: "boolean",
            dflt: true
          }
        },
        transition: {
          duration: {
            valType: "number",
            min: 0,
            dflt: 500,
            editType: "none"
          },
          easing: {
            valType: "enumerated",
            dflt: "cubic-in-out",
            values: [
              "linear",
              "quad",
              "cubic",
              "sin",
              "exp",
              "circle",
              "elastic",
              "back",
              "bounce",
              "linear-in",
              "quad-in",
              "cubic-in",
              "sin-in",
              "exp-in",
              "circle-in",
              "elastic-in",
              "back-in",
              "bounce-in",
              "linear-out",
              "quad-out",
              "cubic-out",
              "sin-out",
              "exp-out",
              "circle-out",
              "elastic-out",
              "back-out",
              "bounce-out",
              "linear-in-out",
              "quad-in-out",
              "cubic-in-out",
              "sin-in-out",
              "exp-in-out",
              "circle-in-out",
              "elastic-in-out",
              "back-in-out",
              "bounce-in-out"
            ],
            editType: "none"
          },
          ordering: {
            valType: "enumerated",
            values: ["layout first", "traces first"],
            dflt: "layout first",
            editType: "none"
          }
        }
      };
    }
  });

  // src/plot_api/edit_types.js
  var require_edit_types = __commonJS({
    "src/plot_api/edit_types.js"(exports, module) {
      "use strict";
      var extendFlat = require_extend().extendFlat;
      var isPlainObject = require_is_plain_object();
      var traceOpts = {
        valType: "flaglist",
        extras: ["none"],
        flags: ["calc", "clearAxisTypes", "plot", "style", "markerSize", "colorbars"]
      };
      var layoutOpts = {
        valType: "flaglist",
        extras: ["none"],
        flags: [
          "calc",
          "plot",
          "legend",
          "ticks",
          "axrange",
          "layoutstyle",
          "modebar",
          "camera",
          "arraydraw",
          "colorbars"
        ]
      };
      var traceEditTypeFlags = traceOpts.flags.slice().concat(["fullReplot"]);
      var layoutEditTypeFlags = layoutOpts.flags.slice().concat("layoutReplot");
      module.exports = {
        traces: traceOpts,
        layout: layoutOpts,
        /*
         * default (all false) edit flags for restyle (traces)
         * creates a new object each call, so the caller can mutate freely
         */
        traceFlags: function() {
          return falseObj(traceEditTypeFlags);
        },
        /*
         * default (all false) edit flags for relayout
         * creates a new object each call, so the caller can mutate freely
         */
        layoutFlags: function() {
          return falseObj(layoutEditTypeFlags);
        },
        /*
         * update `flags` with the `editType` values found in `attr`
         */
        update: function(flags, attr) {
          var editType = attr.editType;
          if (editType && editType !== "none") {
            var editTypeParts = editType.split("+");
            for (var i = 0; i < editTypeParts.length; i++) {
              flags[editTypeParts[i]] = true;
            }
          }
        },
        overrideAll
      };
      function falseObj(keys) {
        var out = {};
        for (var i = 0; i < keys.length; i++) out[keys[i]] = false;
        return out;
      }
      function overrideAll(attrs, editTypeOverride, overrideContainers) {
        var out = extendFlat({}, attrs);
        for (var key in out) {
          var attr = out[key];
          if (isPlainObject(attr)) {
            out[key] = overrideOne(attr, editTypeOverride, overrideContainers, key);
          }
        }
        if (overrideContainers === "from-root") out.editType = editTypeOverride;
        return out;
      }
      function overrideOne(attr, editTypeOverride, overrideContainers, key) {
        if (attr.valType) {
          var out = extendFlat({}, attr);
          out.editType = editTypeOverride;
          if (Array.isArray(attr.items)) {
            out.items = new Array(attr.items.length);
            for (var i = 0; i < attr.items.length; i++) {
              out.items[i] = overrideOne(attr.items[i], editTypeOverride, "from-root");
            }
          }
          return out;
        } else {
          return overrideAll(
            attr,
            editTypeOverride,
            key.charAt(0) === "_" ? "nested" : "from-root"
          );
        }
      }
    }
  });

  // src/components/drawing/attributes.js
  var require_attributes4 = __commonJS({
    "src/components/drawing/attributes.js"(exports) {
      "use strict";
      exports.dash = {
        valType: "string",
        // string type usually doesn't take values... this one should really be
        // a special type or at least a special coercion function, from the GUI
        // you only get these values but elsewhere the user can supply a list of
        // dash lengths in px, and it will be honored
        values: ["solid", "dot", "dash", "longdash", "dashdot", "longdashdot"],
        dflt: "solid",
        editType: "style"
      };
      exports.pattern = {
        shape: {
          valType: "enumerated",
          values: ["", "/", "\\", "x", "-", "|", "+", "."],
          dflt: "",
          arrayOk: true,
          editType: "style"
        },
        fillmode: {
          valType: "enumerated",
          values: ["replace", "overlay"],
          dflt: "replace",
          editType: "style"
        },
        bgcolor: {
          valType: "color",
          arrayOk: true,
          editType: "style"
        },
        fgcolor: {
          valType: "color",
          arrayOk: true,
          editType: "style"
        },
        fgopacity: {
          valType: "number",
          editType: "style",
          min: 0,
          max: 1
        },
        size: {
          valType: "number",
          min: 0,
          dflt: 8,
          arrayOk: true,
          editType: "style"
        },
        solidity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 0.3,
          arrayOk: true,
          editType: "style"
        },
        editType: "style"
      };
    }
  });

  // src/constants/docs.js
  var require_docs = __commonJS({
    "src/constants/docs.js"(exports, module) {
      "use strict";
      module.exports = {
        FORMAT_LINK: "https://github.com/d3/d3-format/tree/v1.4.5#d3-format",
        DATE_FORMAT_LINK: "https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format"
      };
    }
  });

  // src/plots/template_attributes.js
  var require_template_attributes = __commonJS({
    "src/plots/template_attributes.js"(exports) {
      "use strict";
      var docs = require_docs();
      var FORMAT_LINK = docs.FORMAT_LINK;
      var DATE_FORMAT_LINK = docs.DATE_FORMAT_LINK;
      function describeVariables(extra) {
        var descPart = extra.description ? " " + extra.description : "";
        var keys = extra.keys || [];
        if (keys.length > 0) {
          var quotedKeys = [];
          for (var i = 0; i < keys.length; i++) {
            quotedKeys[i] = "`" + keys[i] + "`";
          }
          descPart = descPart + "Finally, the template string has access to ";
          if (keys.length === 1) {
            descPart = descPart + "variable " + quotedKeys[0];
          } else {
            descPart = descPart + "variables " + quotedKeys.slice(0, -1).join(", ") + " and " + quotedKeys.slice(-1) + ".";
          }
        }
        return descPart;
      }
      exports.hovertemplateAttrs = function(opts, extra) {
        opts = opts || {};
        extra = extra || {};
        var descPart = describeVariables(extra);
        var hovertemplate = {
          valType: "string",
          dflt: "",
          editType: opts.editType || "none"
        };
        if (opts.arrayOk !== false) {
          hovertemplate.arrayOk = true;
        }
        return hovertemplate;
      };
      exports.texttemplateAttrs = function(opts, extra) {
        opts = opts || {};
        extra = extra || {};
        var descPart = describeVariables(extra);
        var texttemplate = {
          valType: "string",
          dflt: "",
          editType: opts.editType || "calc"
        };
        if (opts.arrayOk !== false) {
          texttemplate.arrayOk = true;
        }
        return texttemplate;
      };
      exports.shapeTexttemplateAttrs = function(opts, extra) {
        opts = opts || {};
        extra = extra || {};
        var newStr = opts.newshape ? "new " : "";
        var descPart = describeVariables(extra);
        var texttemplate = {
          valType: "string",
          dflt: "",
          editType: opts.editType || "arraydraw"
        };
        return texttemplate;
      };
    }
  });

  // src/components/shapes/label_texttemplate.js
  var require_label_texttemplate = __commonJS({
    "src/components/shapes/label_texttemplate.js"(exports, module) {
      "use strict";
      function d2l(v, axis) {
        return axis ? axis.d2l(v) : v;
      }
      function l2d(v, axis) {
        return axis ? axis.l2d(v) : v;
      }
      function x0Fn(shape) {
        return shape.x0;
      }
      function x1Fn(shape) {
        return shape.x1;
      }
      function y0Fn(shape) {
        return shape.y0;
      }
      function y1Fn(shape) {
        return shape.y1;
      }
      function x0shiftFn(shape) {
        return shape.x0shift || 0;
      }
      function x1shiftFn(shape) {
        return shape.x1shift || 0;
      }
      function y0shiftFn(shape) {
        return shape.y0shift || 0;
      }
      function y1shiftFn(shape) {
        return shape.y1shift || 0;
      }
      function dxFn(shape, xa) {
        return d2l(shape.x1, xa) + x1shiftFn(shape) - d2l(shape.x0, xa) - x0shiftFn(shape);
      }
      function dyFn(shape, xa, ya) {
        return d2l(shape.y1, ya) + y1shiftFn(shape) - d2l(shape.y0, ya) - y0shiftFn(shape);
      }
      function widthFn(shape, xa) {
        return Math.abs(dxFn(shape, xa));
      }
      function heightFn(shape, xa, ya) {
        return Math.abs(dyFn(shape, xa, ya));
      }
      function lengthFn(shape, xa, ya) {
        return shape.type !== "line" ? void 0 : Math.sqrt(
          Math.pow(dxFn(shape, xa), 2) + Math.pow(dyFn(shape, xa, ya), 2)
        );
      }
      function xcenterFn(shape, xa) {
        return l2d((d2l(shape.x1, xa) + x1shiftFn(shape) + d2l(shape.x0, xa) + x0shiftFn(shape)) / 2, xa);
      }
      function ycenterFn(shape, xa, ya) {
        return l2d((d2l(shape.y1, ya) + y1shiftFn(shape) + d2l(shape.y0, ya) + y0shiftFn(shape)) / 2, ya);
      }
      function slopeFn(shape, xa, ya) {
        return shape.type !== "line" ? void 0 : dyFn(shape, xa, ya) / dxFn(shape, xa);
      }
      module.exports = {
        x0: x0Fn,
        x1: x1Fn,
        y0: y0Fn,
        y1: y1Fn,
        slope: slopeFn,
        dx: dxFn,
        dy: dyFn,
        width: widthFn,
        height: heightFn,
        length: lengthFn,
        xcenter: xcenterFn,
        ycenter: ycenterFn
      };
    }
  });

  // src/components/shapes/draw_newshape/attributes.js
  var require_attributes5 = __commonJS({
    "src/components/shapes/draw_newshape/attributes.js"(exports, module) {
      "use strict";
      var overrideAll = require_edit_types().overrideAll;
      var basePlotAttributes = require_attributes2();
      var fontAttrs = require_font_attributes();
      var dash = require_attributes4().dash;
      var extendFlat = require_extend().extendFlat;
      var shapeTexttemplateAttrs = require_template_attributes().shapeTexttemplateAttrs;
      var shapeLabelTexttemplateVars = require_label_texttemplate();
      module.exports = overrideAll({
        newshape: {
          visible: extendFlat({}, basePlotAttributes.visible, {}),
          showlegend: {
            valType: "boolean",
            dflt: false
          },
          legend: extendFlat({}, basePlotAttributes.legend, {}),
          legendgroup: extendFlat({}, basePlotAttributes.legendgroup, {}),
          legendgrouptitle: {
            text: extendFlat({}, basePlotAttributes.legendgrouptitle.text, {}),
            font: fontAttrs({})
          },
          legendrank: extendFlat({}, basePlotAttributes.legendrank, {}),
          legendwidth: extendFlat({}, basePlotAttributes.legendwidth, {}),
          line: {
            color: {
              valType: "color"
            },
            width: {
              valType: "number",
              min: 0,
              dflt: 4
            },
            dash: extendFlat({}, dash, {
              dflt: "solid"
            })
          },
          fillcolor: {
            valType: "color",
            dflt: "rgba(0,0,0,0)"
          },
          fillrule: {
            valType: "enumerated",
            values: ["evenodd", "nonzero"],
            dflt: "evenodd"
          },
          opacity: {
            valType: "number",
            min: 0,
            max: 1,
            dflt: 1
          },
          layer: {
            valType: "enumerated",
            values: ["below", "above", "between"],
            dflt: "above"
          },
          drawdirection: {
            valType: "enumerated",
            values: ["ortho", "horizontal", "vertical", "diagonal"],
            dflt: "diagonal"
          },
          name: extendFlat({}, basePlotAttributes.name, {}),
          label: {
            text: {
              valType: "string",
              dflt: ""
            },
            texttemplate: shapeTexttemplateAttrs({ newshape: true }, { keys: Object.keys(shapeLabelTexttemplateVars) }),
            font: fontAttrs({}),
            textposition: {
              valType: "enumerated",
              values: [
                "top left",
                "top center",
                "top right",
                "middle left",
                "middle center",
                "middle right",
                "bottom left",
                "bottom center",
                "bottom right",
                "start",
                "middle",
                "end"
              ]
            },
            textangle: {
              valType: "angle",
              dflt: "auto"
            },
            xanchor: {
              valType: "enumerated",
              values: ["auto", "left", "center", "right"],
              dflt: "auto"
            },
            yanchor: {
              valType: "enumerated",
              values: ["top", "middle", "bottom"]
            },
            padding: {
              valType: "number",
              dflt: 3,
              min: 0
            }
          }
        },
        activeshape: {
          fillcolor: {
            valType: "color",
            dflt: "rgb(255,0,255)"
          },
          opacity: {
            valType: "number",
            min: 0,
            max: 1,
            dflt: 0.5
          }
        }
      }, "none", "from-root");
    }
  });

  // src/components/selections/draw_newselection/attributes.js
  var require_attributes6 = __commonJS({
    "src/components/selections/draw_newselection/attributes.js"(exports, module) {
      "use strict";
      var dash = require_attributes4().dash;
      var extendFlat = require_extend().extendFlat;
      module.exports = {
        newselection: {
          mode: {
            valType: "enumerated",
            values: ["immediate", "gradual"],
            dflt: "immediate",
            editType: "none"
          },
          line: {
            color: {
              valType: "color",
              editType: "none"
            },
            width: {
              valType: "number",
              min: 1,
              dflt: 1,
              editType: "none"
            },
            dash: extendFlat({}, dash, {
              dflt: "dot",
              editType: "none"
            }),
            editType: "none"
          },
          // no drawdirection here noting that layout.selectdirection is used instead.
          editType: "none"
        },
        activeselection: {
          fillcolor: {
            valType: "color",
            dflt: "rgba(0,0,0,0)",
            editType: "none"
          },
          opacity: {
            valType: "number",
            min: 0,
            max: 1,
            dflt: 0.5,
            editType: "none"
          },
          editType: "none"
        }
      };
    }
  });

  // src/plots/pad_attributes.js
  var require_pad_attributes = __commonJS({
    "src/plots/pad_attributes.js"(exports, module) {
      "use strict";
      module.exports = function(opts) {
        var editType = opts.editType;
        return {
          t: {
            valType: "number",
            dflt: 0,
            editType
          },
          r: {
            valType: "number",
            dflt: 0,
            editType
          },
          b: {
            valType: "number",
            dflt: 0,
            editType
          },
          l: {
            valType: "number",
            dflt: 0,
            editType
          },
          editType
        };
      };
    }
  });

  // src/plots/layout_attributes.js
  var require_layout_attributes2 = __commonJS({
    "src/plots/layout_attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var animationAttrs = require_animation_attributes();
      var colorAttrs = require_attributes3();
      var drawNewShapeAttrs = require_attributes5();
      var drawNewSelectionAttrs = require_attributes6();
      var padAttrs = require_pad_attributes();
      var extendFlat = require_extend().extendFlat;
      var globalFont = fontAttrs({
        editType: "calc"
      });
      globalFont.family.dflt = '"Open Sans", verdana, arial, sans-serif';
      globalFont.size.dflt = 12;
      globalFont.color.dflt = colorAttrs.defaultLine;
      module.exports = {
        font: globalFont,
        title: {
          text: {
            valType: "string",
            editType: "layoutstyle"
          },
          font: fontAttrs({
            editType: "layoutstyle"
          }),
          subtitle: {
            text: {
              valType: "string",
              editType: "layoutstyle"
            },
            font: fontAttrs({
              editType: "layoutstyle"
            }),
            editType: "layoutstyle"
          },
          xref: {
            valType: "enumerated",
            dflt: "container",
            values: ["container", "paper"],
            editType: "layoutstyle"
          },
          yref: {
            valType: "enumerated",
            dflt: "container",
            values: ["container", "paper"],
            editType: "layoutstyle"
          },
          x: {
            valType: "number",
            min: 0,
            max: 1,
            dflt: 0.5,
            editType: "layoutstyle"
          },
          y: {
            valType: "number",
            min: 0,
            max: 1,
            dflt: "auto",
            editType: "layoutstyle"
          },
          xanchor: {
            valType: "enumerated",
            dflt: "auto",
            values: ["auto", "left", "center", "right"],
            editType: "layoutstyle"
          },
          yanchor: {
            valType: "enumerated",
            dflt: "auto",
            values: ["auto", "top", "middle", "bottom"],
            editType: "layoutstyle"
          },
          pad: extendFlat(padAttrs({ editType: "layoutstyle" }), {}),
          automargin: {
            valType: "boolean",
            dflt: false,
            editType: "plot"
          },
          editType: "layoutstyle"
        },
        uniformtext: {
          mode: {
            valType: "enumerated",
            values: [false, "hide", "show"],
            dflt: false,
            editType: "plot"
          },
          minsize: {
            valType: "number",
            min: 0,
            dflt: 0,
            editType: "plot"
          },
          editType: "plot"
        },
        autosize: {
          valType: "boolean",
          dflt: false,
          // autosize, width, and height get special editType treatment in _relayout
          // so we can handle noop resizes more efficiently
          editType: "none"
        },
        width: {
          valType: "number",
          min: 10,
          dflt: 700,
          editType: "plot"
        },
        height: {
          valType: "number",
          min: 10,
          dflt: 450,
          editType: "plot"
        },
        minreducedwidth: {
          valType: "number",
          min: 2,
          dflt: 64,
          editType: "plot"
        },
        minreducedheight: {
          valType: "number",
          min: 2,
          dflt: 64,
          editType: "plot"
        },
        margin: {
          l: {
            valType: "number",
            min: 0,
            dflt: 80,
            editType: "plot"
          },
          r: {
            valType: "number",
            min: 0,
            dflt: 80,
            editType: "plot"
          },
          t: {
            valType: "number",
            min: 0,
            dflt: 100,
            editType: "plot"
          },
          b: {
            valType: "number",
            min: 0,
            dflt: 80,
            editType: "plot"
          },
          pad: {
            valType: "number",
            min: 0,
            dflt: 0,
            editType: "plot"
          },
          autoexpand: {
            valType: "boolean",
            dflt: true,
            editType: "plot"
          },
          editType: "plot"
        },
        computed: {
          valType: "any",
          editType: "none"
        },
        paper_bgcolor: {
          valType: "color",
          dflt: colorAttrs.background,
          editType: "plot"
        },
        plot_bgcolor: {
          // defined here, but set in cartesian.supplyLayoutDefaults
          // because it needs to know if there are (2D) axes or not
          valType: "color",
          dflt: colorAttrs.background,
          editType: "layoutstyle"
        },
        autotypenumbers: {
          valType: "enumerated",
          values: ["convert types", "strict"],
          dflt: "convert types",
          editType: "calc"
        },
        separators: {
          valType: "string",
          editType: "plot"
        },
        hidesources: {
          valType: "boolean",
          dflt: false,
          editType: "plot"
        },
        showlegend: {
          // handled in legend.supplyLayoutDefaults
          // but included here because it's not in the legend object
          valType: "boolean",
          editType: "legend"
        },
        colorway: {
          valType: "colorlist",
          dflt: colorAttrs.defaults,
          editType: "calc"
        },
        datarevision: {
          valType: "any",
          editType: "calc"
        },
        uirevision: {
          valType: "any",
          editType: "none"
        },
        editrevision: {
          valType: "any",
          editType: "none"
        },
        selectionrevision: {
          valType: "any",
          editType: "none"
        },
        template: {
          valType: "any",
          editType: "calc"
        },
        newshape: drawNewShapeAttrs.newshape,
        activeshape: drawNewShapeAttrs.activeshape,
        newselection: drawNewSelectionAttrs.newselection,
        activeselection: drawNewSelectionAttrs.activeselection,
        meta: {
          valType: "any",
          arrayOk: true,
          editType: "plot"
        },
        transition: extendFlat({}, animationAttrs.transition, {
          editType: "none"
        })
      };
    }
  });

  // temp_stylePlugin:node_modules/maplibre-gl/dist/maplibre-gl.css
  var init_maplibre_gl = __esm({
    "temp_stylePlugin:node_modules/maplibre-gl/dist/maplibre-gl.css"() {
    }
  });

  // stylePlugin:/Users/ekl/code/plotly.js/node_modules/maplibre-gl/dist/maplibre-gl.css
  var maplibre_gl_exports = {};
  var init_maplibre_gl2 = __esm({
    "stylePlugin:/Users/ekl/code/plotly.js/node_modules/maplibre-gl/dist/maplibre-gl.css"() {
      init_maplibre_gl();
    }
  });

  // src/registry.js
  var require_registry = __commonJS({
    "src/registry.js"(exports) {
      "use strict";
      var Loggers = require_loggers();
      var noop = require_noop();
      var pushUnique = require_push_unique();
      var isPlainObject = require_is_plain_object();
      var addStyleRule = require_dom().addStyleRule;
      var ExtendModule = require_extend();
      var basePlotAttributes = require_attributes2();
      var baseLayoutAttributes = require_layout_attributes2();
      var extendFlat = ExtendModule.extendFlat;
      var extendDeepAll = ExtendModule.extendDeepAll;
      exports.modules = {};
      exports.allCategories = {};
      exports.allTypes = [];
      exports.subplotsRegistry = {};
      exports.componentsRegistry = {};
      exports.layoutArrayContainers = [];
      exports.layoutArrayRegexes = [];
      exports.traceLayoutAttributes = {};
      exports.localeRegistry = {};
      exports.apiMethodRegistry = {};
      exports.collectableSubplotTypes = null;
      exports.register = function register(_modules) {
        exports.collectableSubplotTypes = null;
        if (!_modules) {
          throw new Error("No argument passed to Plotly.register.");
        } else if (_modules && !Array.isArray(_modules)) {
          _modules = [_modules];
        }
        for (var i = 0; i < _modules.length; i++) {
          var newModule = _modules[i];
          if (!newModule) {
            throw new Error("Invalid module was attempted to be registered!");
          }
          switch (newModule.moduleType) {
            case "trace":
              registerTraceModule(newModule);
              break;
            case "transform":
              registerTransformModule(newModule);
              break;
            case "component":
              registerComponentModule(newModule);
              break;
            case "locale":
              registerLocale(newModule);
              break;
            case "apiMethod":
              var name = newModule.name;
              exports.apiMethodRegistry[name] = newModule.fn;
              break;
            default:
              throw new Error("Invalid module was attempted to be registered!");
          }
        }
      };
      exports.getModule = function(trace) {
        var _module = exports.modules[getTraceType(trace)];
        if (!_module) return false;
        return _module._module;
      };
      exports.traceIs = function(traceType, category) {
        traceType = getTraceType(traceType);
        if (traceType === "various") return false;
        var _module = exports.modules[traceType];
        if (!_module) {
          if (traceType) {
            Loggers.log("Unrecognized trace type " + traceType + ".");
          }
          _module = exports.modules[basePlotAttributes.type.dflt];
        }
        return !!_module.categories[category];
      };
      exports.getComponentMethod = function(name, method) {
        var _module = exports.componentsRegistry[name];
        if (!_module) return noop;
        return _module[method] || noop;
      };
      exports.call = function() {
        var name = arguments[0];
        var args = [].slice.call(arguments, 1);
        return exports.apiMethodRegistry[name].apply(null, args);
      };
      function registerTraceModule(_module) {
        var thisType = _module.name;
        var categoriesIn = _module.categories;
        var meta = _module.meta;
        if (exports.modules[thisType]) {
          Loggers.log("Type " + thisType + " already registered");
          return;
        }
        if (!exports.subplotsRegistry[_module.basePlotModule.name]) {
          registerSubplot(_module.basePlotModule);
        }
        var categoryObj = {};
        for (var i = 0; i < categoriesIn.length; i++) {
          categoryObj[categoriesIn[i]] = true;
          exports.allCategories[categoriesIn[i]] = true;
        }
        exports.modules[thisType] = {
          _module,
          categories: categoryObj
        };
        if (meta && Object.keys(meta).length) {
          exports.modules[thisType].meta = meta;
        }
        exports.allTypes.push(thisType);
        for (var componentName in exports.componentsRegistry) {
          mergeComponentAttrsToTrace(componentName, thisType);
        }
        if (_module.layoutAttributes) {
          extendFlat(exports.traceLayoutAttributes, _module.layoutAttributes);
        }
        var basePlotModule = _module.basePlotModule;
        var bpmName = basePlotModule.name;
        if (bpmName === "mapbox") {
          var styleRules = basePlotModule.constants.styleRules;
          for (var k in styleRules) {
            addStyleRule(".js-plotly-plot .plotly .mapboxgl-" + k, styleRules[k]);
          }
        }
        if (bpmName === "map") {
          init_maplibre_gl2();
        }
        if ((bpmName === "geo" || bpmName === "mapbox" || bpmName === "map") && window.PlotlyGeoAssets === void 0) {
          window.PlotlyGeoAssets = { topojson: {} };
        }
      }
      function registerSubplot(_module) {
        var plotType = _module.name;
        if (exports.subplotsRegistry[plotType]) {
          Loggers.log("Plot type " + plotType + " already registered.");
          return;
        }
        findArrayRegexps(_module);
        exports.subplotsRegistry[plotType] = _module;
        for (var componentName in exports.componentsRegistry) {
          mergeComponentAttrsToSubplot(componentName, _module.name);
        }
      }
      function registerComponentModule(_module) {
        if (typeof _module.name !== "string") {
          throw new Error("Component module *name* must be a string.");
        }
        var name = _module.name;
        exports.componentsRegistry[name] = _module;
        if (_module.layoutAttributes) {
          if (_module.layoutAttributes._isLinkedToArray) {
            pushUnique(exports.layoutArrayContainers, name);
          }
          findArrayRegexps(_module);
        }
        for (var traceType in exports.modules) {
          mergeComponentAttrsToTrace(name, traceType);
        }
        for (var subplotName in exports.subplotsRegistry) {
          mergeComponentAttrsToSubplot(name, subplotName);
        }
        if (_module.schema && _module.schema.layout) {
          extendDeepAll(baseLayoutAttributes, _module.schema.layout);
        }
      }
      function registerTransformModule(_module) {
        if (typeof _module.name !== "string") {
          throw new Error("Transform module *name* must be a string.");
        }
        var prefix = "Transform module " + _module.name;
        var hasTransform = typeof _module.transform === "function";
        var hasCalcTransform = typeof _module.calcTransform === "function";
        if (!hasTransform && !hasCalcTransform) {
          throw new Error(prefix + " is missing a *transform* or *calcTransform* method.");
        }
        if (hasTransform && hasCalcTransform) {
          Loggers.log([
            prefix + " has both a *transform* and *calcTransform* methods.",
            "Please note that all *transform* methods are executed",
            "before all *calcTransform* methods."
          ].join(" "));
        }
        if (!isPlainObject(_module.attributes)) {
          Loggers.log(prefix + " registered without an *attributes* object.");
        }
        if (typeof _module.supplyDefaults !== "function") {
          Loggers.log(prefix + " registered without a *supplyDefaults* method.");
        }
      }
      function registerLocale(_module) {
        var locale = _module.name;
        var baseLocale = locale.split("-")[0];
        var newDict = _module.dictionary;
        var newFormat = _module.format;
        var hasDict = newDict && Object.keys(newDict).length;
        var hasFormat = newFormat && Object.keys(newFormat).length;
        var locales = exports.localeRegistry;
        var localeObj = locales[locale];
        if (!localeObj) locales[locale] = localeObj = {};
        if (baseLocale !== locale) {
          var baseLocaleObj = locales[baseLocale];
          if (!baseLocaleObj) locales[baseLocale] = baseLocaleObj = {};
          if (hasDict && baseLocaleObj.dictionary === localeObj.dictionary) {
            baseLocaleObj.dictionary = newDict;
          }
          if (hasFormat && baseLocaleObj.format === localeObj.format) {
            baseLocaleObj.format = newFormat;
          }
        }
        if (hasDict) localeObj.dictionary = newDict;
        if (hasFormat) localeObj.format = newFormat;
      }
      function findArrayRegexps(_module) {
        if (_module.layoutAttributes) {
          var arrayAttrRegexps = _module.layoutAttributes._arrayAttrRegexps;
          if (arrayAttrRegexps) {
            for (var i = 0; i < arrayAttrRegexps.length; i++) {
              pushUnique(exports.layoutArrayRegexes, arrayAttrRegexps[i]);
            }
          }
        }
      }
      function mergeComponentAttrsToTrace(componentName, traceType) {
        var componentSchema = exports.componentsRegistry[componentName].schema;
        if (!componentSchema || !componentSchema.traces) return;
        var traceAttrs = componentSchema.traces[traceType];
        if (traceAttrs) {
          extendDeepAll(exports.modules[traceType]._module.attributes, traceAttrs);
        }
      }
      function mergeComponentAttrsToSubplot(componentName, subplotName) {
        var componentSchema = exports.componentsRegistry[componentName].schema;
        if (!componentSchema || !componentSchema.subplots) return;
        var subplotModule = exports.subplotsRegistry[subplotName];
        var subplotAttrs = subplotModule.layoutAttributes;
        var subplotAttr = subplotModule.attr === "subplot" ? subplotModule.name : subplotModule.attr;
        if (Array.isArray(subplotAttr)) subplotAttr = subplotAttr[0];
        var componentLayoutAttrs = componentSchema.subplots[subplotAttr];
        if (subplotAttrs && componentLayoutAttrs) {
          extendDeepAll(subplotAttrs, componentLayoutAttrs);
        }
      }
      function getTraceType(traceType) {
        if (typeof traceType === "object") traceType = traceType.type;
        return traceType;
      }
    }
  });

  // src/lib/dates.js
  var require_dates = __commonJS({
    "src/lib/dates.js"(exports) {
      "use strict";
      var timeFormat = require_d3_time_format().timeFormat;
      var isNumeric = require_fast_isnumeric();
      var Loggers = require_loggers();
      var mod = require_mod().mod;
      var constants = require_numerical();
      var BADNUM = constants.BADNUM;
      var ONEDAY = constants.ONEDAY;
      var ONEHOUR = constants.ONEHOUR;
      var ONEMIN = constants.ONEMIN;
      var ONESEC = constants.ONESEC;
      var EPOCHJD = constants.EPOCHJD;
      var Registry = require_registry();
      var utcFormat = require_d3_time_format().utcFormat;
      var DATETIME_REGEXP = /^\s*(-?\d\d\d\d|\d\d)(-(\d?\d)(-(\d?\d)([ Tt]([01]?\d|2[0-3])(:([0-5]\d)(:([0-5]\d(\.\d+)?))?(Z|z|[+\-]\d\d(:?\d\d)?)?)?)?)?)?\s*$/m;
      var DATETIME_REGEXP_CN = /^\s*(-?\d\d\d\d|\d\d)(-(\d?\di?)(-(\d?\d)([ Tt]([01]?\d|2[0-3])(:([0-5]\d)(:([0-5]\d(\.\d+)?))?(Z|z|[+\-]\d\d(:?\d\d)?)?)?)?)?)?\s*$/m;
      var YFIRST = (/* @__PURE__ */ new Date()).getFullYear() - 70;
      function isWorldCalendar(calendar) {
        return calendar && Registry.componentsRegistry.calendars && typeof calendar === "string" && calendar !== "gregorian";
      }
      exports.dateTick0 = function(calendar, dayOfWeek) {
        var tick0 = _dateTick0(calendar, !!dayOfWeek);
        if (dayOfWeek < 2) return tick0;
        var v = exports.dateTime2ms(tick0, calendar);
        v += ONEDAY * (dayOfWeek - 1);
        return exports.ms2DateTime(v, 0, calendar);
      };
      function _dateTick0(calendar, sunday) {
        if (isWorldCalendar(calendar)) {
          return sunday ? Registry.getComponentMethod("calendars", "CANONICAL_SUNDAY")[calendar] : Registry.getComponentMethod("calendars", "CANONICAL_TICK")[calendar];
        } else {
          return sunday ? "2000-01-02" : "2000-01-01";
        }
      }
      exports.dfltRange = function(calendar) {
        if (isWorldCalendar(calendar)) {
          return Registry.getComponentMethod("calendars", "DFLTRANGE")[calendar];
        } else {
          return ["2000-01-01", "2001-01-01"];
        }
      };
      exports.isJSDate = function(v) {
        return typeof v === "object" && v !== null && typeof v.getTime === "function";
      };
      var MIN_MS;
      var MAX_MS;
      exports.dateTime2ms = function(s, calendar) {
        if (exports.isJSDate(s)) {
          var tzOffset = s.getTimezoneOffset() * ONEMIN;
          var offsetTweak = (s.getUTCMinutes() - s.getMinutes()) * ONEMIN + (s.getUTCSeconds() - s.getSeconds()) * ONESEC + (s.getUTCMilliseconds() - s.getMilliseconds());
          if (offsetTweak) {
            var comb = 3 * ONEMIN;
            tzOffset = tzOffset - comb / 2 + mod(offsetTweak - tzOffset + comb / 2, comb);
          }
          s = Number(s) - tzOffset;
          if (s >= MIN_MS && s <= MAX_MS) return s;
          return BADNUM;
        }
        if (typeof s !== "string" && typeof s !== "number") return BADNUM;
        s = String(s);
        var isWorld = isWorldCalendar(calendar);
        var s0 = s.charAt(0);
        if (isWorld && (s0 === "G" || s0 === "g")) {
          s = s.substr(1);
          calendar = "";
        }
        var isChinese = isWorld && calendar.substr(0, 7) === "chinese";
        var match = s.match(isChinese ? DATETIME_REGEXP_CN : DATETIME_REGEXP);
        if (!match) return BADNUM;
        var y = match[1];
        var m = match[3] || "1";
        var d = Number(match[5] || 1);
        var H = Number(match[7] || 0);
        var M = Number(match[9] || 0);
        var S = Number(match[11] || 0);
        if (isWorld) {
          if (y.length === 2) return BADNUM;
          y = Number(y);
          var cDate;
          try {
            var calInstance = Registry.getComponentMethod("calendars", "getCal")(calendar);
            if (isChinese) {
              var isIntercalary = m.charAt(m.length - 1) === "i";
              m = parseInt(m, 10);
              cDate = calInstance.newDate(y, calInstance.toMonthIndex(y, m, isIntercalary), d);
            } else {
              cDate = calInstance.newDate(y, Number(m), d);
            }
          } catch (e) {
            return BADNUM;
          }
          if (!cDate) return BADNUM;
          return (cDate.toJD() - EPOCHJD) * ONEDAY + H * ONEHOUR + M * ONEMIN + S * ONESEC;
        }
        if (y.length === 2) {
          y = (Number(y) + 2e3 - YFIRST) % 100 + YFIRST;
        } else y = Number(y);
        m -= 1;
        var date = new Date(Date.UTC(2e3, m, d, H, M));
        date.setUTCFullYear(y);
        if (date.getUTCMonth() !== m) return BADNUM;
        if (date.getUTCDate() !== d) return BADNUM;
        return date.getTime() + S * ONESEC;
      };
      MIN_MS = exports.MIN_MS = exports.dateTime2ms("-9999");
      MAX_MS = exports.MAX_MS = exports.dateTime2ms("9999-12-31 23:59:59.9999");
      exports.isDateTime = function(s, calendar) {
        return exports.dateTime2ms(s, calendar) !== BADNUM;
      };
      function lpad(val, digits) {
        return String(val + Math.pow(10, digits)).substr(1);
      }
      var NINETYDAYS = 90 * ONEDAY;
      var THREEHOURS = 3 * ONEHOUR;
      var FIVEMIN = 5 * ONEMIN;
      exports.ms2DateTime = function(ms, r, calendar) {
        if (typeof ms !== "number" || !(ms >= MIN_MS && ms <= MAX_MS)) return BADNUM;
        if (!r) r = 0;
        var msecTenths = Math.floor(mod(ms + 0.05, 1) * 10);
        var msRounded = Math.round(ms - msecTenths / 10);
        var dateStr, h, m, s, msec10, d;
        if (isWorldCalendar(calendar)) {
          var dateJD = Math.floor(msRounded / ONEDAY) + EPOCHJD;
          var timeMs = Math.floor(mod(ms, ONEDAY));
          try {
            dateStr = Registry.getComponentMethod("calendars", "getCal")(calendar).fromJD(dateJD).formatDate("yyyy-mm-dd");
          } catch (e) {
            dateStr = utcFormat("G%Y-%m-%d")(new Date(msRounded));
          }
          if (dateStr.charAt(0) === "-") {
            while (dateStr.length < 11) dateStr = "-0" + dateStr.substr(1);
          } else {
            while (dateStr.length < 10) dateStr = "0" + dateStr;
          }
          h = r < NINETYDAYS ? Math.floor(timeMs / ONEHOUR) : 0;
          m = r < NINETYDAYS ? Math.floor(timeMs % ONEHOUR / ONEMIN) : 0;
          s = r < THREEHOURS ? Math.floor(timeMs % ONEMIN / ONESEC) : 0;
          msec10 = r < FIVEMIN ? timeMs % ONESEC * 10 + msecTenths : 0;
        } else {
          d = new Date(msRounded);
          dateStr = utcFormat("%Y-%m-%d")(d);
          h = r < NINETYDAYS ? d.getUTCHours() : 0;
          m = r < NINETYDAYS ? d.getUTCMinutes() : 0;
          s = r < THREEHOURS ? d.getUTCSeconds() : 0;
          msec10 = r < FIVEMIN ? d.getUTCMilliseconds() * 10 + msecTenths : 0;
        }
        return includeTime(dateStr, h, m, s, msec10);
      };
      exports.ms2DateTimeLocal = function(ms) {
        if (!(ms >= MIN_MS + ONEDAY && ms <= MAX_MS - ONEDAY)) return BADNUM;
        var msecTenths = Math.floor(mod(ms + 0.05, 1) * 10);
        var d = new Date(Math.round(ms - msecTenths / 10));
        var dateStr = timeFormat("%Y-%m-%d")(d);
        var h = d.getHours();
        var m = d.getMinutes();
        var s = d.getSeconds();
        var msec10 = d.getUTCMilliseconds() * 10 + msecTenths;
        return includeTime(dateStr, h, m, s, msec10);
      };
      function includeTime(dateStr, h, m, s, msec10) {
        if (h || m || s || msec10) {
          dateStr += " " + lpad(h, 2) + ":" + lpad(m, 2);
          if (s || msec10) {
            dateStr += ":" + lpad(s, 2);
            if (msec10) {
              var digits = 4;
              while (msec10 % 10 === 0) {
                digits -= 1;
                msec10 /= 10;
              }
              dateStr += "." + lpad(msec10, digits);
            }
          }
        }
        return dateStr;
      }
      exports.cleanDate = function(v, dflt, calendar) {
        if (v === BADNUM) return dflt;
        if (exports.isJSDate(v) || typeof v === "number" && isFinite(v)) {
          if (isWorldCalendar(calendar)) {
            Loggers.error("JS Dates and milliseconds are incompatible with world calendars", v);
            return dflt;
          }
          v = exports.ms2DateTimeLocal(+v);
          if (!v && dflt !== void 0) return dflt;
        } else if (!exports.isDateTime(v, calendar)) {
          Loggers.error("unrecognized date", v);
          return dflt;
        }
        return v;
      };
      var fracMatch = /%\d?f/g;
      var halfYearMatch = /%h/g;
      var quarterToHalfYear = {
        1: "1",
        2: "1",
        3: "2",
        4: "2"
      };
      function modDateFormat(fmt, x, formatter, calendar) {
        fmt = fmt.replace(fracMatch, function(match) {
          var digits = Math.min(+match.charAt(1) || 6, 6);
          var fracSecs = (x / 1e3 % 1 + 2).toFixed(digits).substr(2).replace(/0+$/, "") || "0";
          return fracSecs;
        });
        var d = new Date(Math.floor(x + 0.05));
        fmt = fmt.replace(halfYearMatch, function() {
          return quarterToHalfYear[formatter("%q")(d)];
        });
        if (isWorldCalendar(calendar)) {
          try {
            fmt = Registry.getComponentMethod("calendars", "worldCalFmt")(fmt, x, calendar);
          } catch (e) {
            return "Invalid";
          }
        }
        return formatter(fmt)(d);
      }
      var MAXSECONDS = [59, 59.9, 59.99, 59.999, 59.9999];
      function formatTime(x, tr) {
        var timePart = mod(x + 0.05, ONEDAY);
        var timeStr = lpad(Math.floor(timePart / ONEHOUR), 2) + ":" + lpad(mod(Math.floor(timePart / ONEMIN), 60), 2);
        if (tr !== "M") {
          if (!isNumeric(tr)) tr = 0;
          var sec = Math.min(mod(x / ONESEC, 60), MAXSECONDS[tr]);
          var secStr = (100 + sec).toFixed(tr).substr(1);
          if (tr > 0) {
            secStr = secStr.replace(/0+$/, "").replace(/[\.]$/, "");
          }
          timeStr += ":" + secStr;
        }
        return timeStr;
      }
      exports.formatDate = function(x, fmt, tr, formatter, calendar, extraFormat) {
        calendar = isWorldCalendar(calendar) && calendar;
        if (!fmt) {
          if (tr === "y") fmt = extraFormat.year;
          else if (tr === "m") fmt = extraFormat.month;
          else if (tr === "d") {
            fmt = extraFormat.dayMonth + "\n" + extraFormat.year;
          } else {
            return formatTime(x, tr) + "\n" + modDateFormat(extraFormat.dayMonthYear, x, formatter, calendar);
          }
        }
        return modDateFormat(fmt, x, formatter, calendar);
      };
      var THREEDAYS = 3 * ONEDAY;
      exports.incrementMonth = function(ms, dMonth, calendar) {
        calendar = isWorldCalendar(calendar) && calendar;
        var timeMs = mod(ms, ONEDAY);
        ms = Math.round(ms - timeMs);
        if (calendar) {
          try {
            var dateJD = Math.round(ms / ONEDAY) + EPOCHJD;
            var calInstance = Registry.getComponentMethod("calendars", "getCal")(calendar);
            var cDate = calInstance.fromJD(dateJD);
            if (dMonth % 12) calInstance.add(cDate, dMonth, "m");
            else calInstance.add(cDate, dMonth / 12, "y");
            return (cDate.toJD() - EPOCHJD) * ONEDAY + timeMs;
          } catch (e) {
            Loggers.error("invalid ms " + ms + " in calendar " + calendar);
          }
        }
        var y = new Date(ms + THREEDAYS);
        return y.setUTCMonth(y.getUTCMonth() + dMonth) + timeMs - THREEDAYS;
      };
      exports.findExactDates = function(data, calendar) {
        var exactYears = 0;
        var exactMonths = 0;
        var exactDays = 0;
        var blankCount = 0;
        var d;
        var di;
        var calInstance = isWorldCalendar(calendar) && Registry.getComponentMethod("calendars", "getCal")(calendar);
        for (var i = 0; i < data.length; i++) {
          di = data[i];
          if (!isNumeric(di)) {
            blankCount++;
            continue;
          }
          if (di % ONEDAY) continue;
          if (calInstance) {
            try {
              d = calInstance.fromJD(di / ONEDAY + EPOCHJD);
              if (d.day() === 1) {
                if (d.month() === 1) exactYears++;
                else exactMonths++;
              } else exactDays++;
            } catch (e) {
            }
          } else {
            d = new Date(di);
            if (d.getUTCDate() === 1) {
              if (d.getUTCMonth() === 0) exactYears++;
              else exactMonths++;
            } else exactDays++;
          }
        }
        exactMonths += exactYears;
        exactDays += exactMonths;
        var dataCount = data.length - blankCount;
        return {
          exactYears: exactYears / dataCount,
          exactMonths: exactMonths / dataCount,
          exactDays: exactDays / dataCount
        };
      };
    }
  });

  // src/lib/identity.js
  var require_identity2 = __commonJS({
    "src/lib/identity.js"(exports, module) {
      "use strict";
      module.exports = function identity(d) {
        return d;
      };
    }
  });

  // src/lib/search.js
  var require_search = __commonJS({
    "src/lib/search.js"(exports) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var loggers = require_loggers();
      var identity = require_identity2();
      var BADNUM = require_numerical().BADNUM;
      var roundingError = 1e-9;
      exports.findBin = function(val, bins, linelow) {
        if (isNumeric(bins.start)) {
          return linelow ? Math.ceil((val - bins.start) / bins.size - roundingError) - 1 : Math.floor((val - bins.start) / bins.size + roundingError);
        } else {
          var n1 = 0;
          var n2 = bins.length;
          var c = 0;
          var binSize = n2 > 1 ? (bins[n2 - 1] - bins[0]) / (n2 - 1) : 1;
          var n, test;
          if (binSize >= 0) {
            test = linelow ? lessThan : lessOrEqual;
          } else {
            test = linelow ? greaterOrEqual : greaterThan;
          }
          val += binSize * roundingError * (linelow ? -1 : 1) * (binSize >= 0 ? 1 : -1);
          while (n1 < n2 && c++ < 100) {
            n = Math.floor((n1 + n2) / 2);
            if (test(bins[n], val)) n1 = n + 1;
            else n2 = n;
          }
          if (c > 90) loggers.log("Long binary search...");
          return n1 - 1;
        }
      };
      function lessThan(a, b) {
        return a < b;
      }
      function lessOrEqual(a, b) {
        return a <= b;
      }
      function greaterThan(a, b) {
        return a > b;
      }
      function greaterOrEqual(a, b) {
        return a >= b;
      }
      exports.sorterAsc = function(a, b) {
        return a - b;
      };
      exports.sorterDes = function(a, b) {
        return b - a;
      };
      exports.distinctVals = function(valsIn) {
        var vals = valsIn.slice();
        vals.sort(exports.sorterAsc);
        var last;
        for (last = vals.length - 1; last > -1; last--) {
          if (vals[last] !== BADNUM) break;
        }
        var minDiff = vals[last] - vals[0] || 1;
        var errDiff = minDiff / (last || 1) / 1e4;
        var newVals = [];
        var preV;
        for (var i = 0; i <= last; i++) {
          var v = vals[i];
          var diff = v - preV;
          if (preV === void 0) {
            newVals.push(v);
            preV = v;
          } else if (diff > errDiff) {
            minDiff = Math.min(minDiff, diff);
            newVals.push(v);
            preV = v;
          }
        }
        return { vals: newVals, minDiff };
      };
      exports.roundUp = function(val, arrayIn, reverse) {
        var low = 0;
        var high = arrayIn.length - 1;
        var mid;
        var c = 0;
        var dlow = reverse ? 0 : 1;
        var dhigh = reverse ? 1 : 0;
        var rounded = reverse ? Math.ceil : Math.floor;
        while (low < high && c++ < 100) {
          mid = rounded((low + high) / 2);
          if (arrayIn[mid] <= val) low = mid + dlow;
          else high = mid - dhigh;
        }
        return arrayIn[low];
      };
      exports.sort = function(array, sortFn) {
        var notOrdered = 0;
        var notReversed = 0;
        for (var i = 1; i < array.length; i++) {
          var pairOrder = sortFn(array[i], array[i - 1]);
          if (pairOrder < 0) notOrdered = 1;
          else if (pairOrder > 0) notReversed = 1;
          if (notOrdered && notReversed) return array.sort(sortFn);
        }
        return notReversed ? array : array.reverse();
      };
      exports.findIndexOfMin = function(arr, fn) {
        fn = fn || identity;
        var min = Infinity;
        var ind;
        for (var i = 0; i < arr.length; i++) {
          var v = fn(arr[i]);
          if (v < min) {
            min = v;
            ind = i;
          }
        }
        return ind;
      };
    }
  });

  // src/lib/sort_object_keys.js
  var require_sort_object_keys = __commonJS({
    "src/lib/sort_object_keys.js"(exports, module) {
      "use strict";
      module.exports = function sortObjectKeys(obj) {
        return Object.keys(obj).sort();
      };
    }
  });

  // src/lib/stats.js
  var require_stats = __commonJS({
    "src/lib/stats.js"(exports) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var isArrayOrTypedArray = require_array().isArrayOrTypedArray;
      exports.aggNums = function(f, v, a, len) {
        var i, b;
        if (!len || len > a.length) len = a.length;
        if (!isNumeric(v)) v = false;
        if (isArrayOrTypedArray(a[0])) {
          b = new Array(len);
          for (i = 0; i < len; i++) b[i] = exports.aggNums(f, v, a[i]);
          a = b;
        }
        for (i = 0; i < len; i++) {
          if (!isNumeric(v)) v = a[i];
          else if (isNumeric(a[i])) v = f(+v, +a[i]);
        }
        return v;
      };
      exports.len = function(data) {
        return exports.aggNums(function(a) {
          return a + 1;
        }, 0, data);
      };
      exports.mean = function(data, len) {
        if (!len) len = exports.len(data);
        return exports.aggNums(function(a, b) {
          return a + b;
        }, 0, data) / len;
      };
      exports.geometricMean = function(data, len) {
        if (!len) len = exports.len(data);
        return Math.pow(exports.aggNums(function(a, b) {
          return a * b;
        }, 1, data), 1 / len);
      };
      exports.midRange = function(numArr) {
        if (numArr === void 0 || numArr.length === 0) return void 0;
        return (exports.aggNums(Math.max, null, numArr) + exports.aggNums(Math.min, null, numArr)) / 2;
      };
      exports.variance = function(data, len, mean) {
        if (!len) len = exports.len(data);
        if (!isNumeric(mean)) mean = exports.mean(data, len);
        return exports.aggNums(function(a, b) {
          return a + Math.pow(b - mean, 2);
        }, 0, data) / len;
      };
      exports.stdev = function(data, len, mean) {
        return Math.sqrt(exports.variance(data, len, mean));
      };
      exports.median = function(data) {
        var b = data.slice().sort();
        return exports.interp(b, 0.5);
      };
      exports.interp = function(arr, n) {
        if (!isNumeric(n)) throw "n should be a finite number";
        n = n * arr.length - 0.5;
        if (n < 0) return arr[0];
        if (n > arr.length - 1) return arr[arr.length - 1];
        var frac = n % 1;
        return frac * arr[Math.ceil(n)] + (1 - frac) * arr[Math.floor(n)];
      };
    }
  });

  // src/lib/angles.js
  var require_angles = __commonJS({
    "src/lib/angles.js"(exports, module) {
      "use strict";
      var modModule = require_mod();
      var mod = modModule.mod;
      var modHalf = modModule.modHalf;
      var PI = Math.PI;
      var twoPI = 2 * PI;
      function deg2rad(deg) {
        return deg / 180 * PI;
      }
      function rad2deg(rad) {
        return rad / PI * 180;
      }
      function isFullCircle(aBnds) {
        return Math.abs(aBnds[1] - aBnds[0]) > twoPI - 1e-14;
      }
      function angleDelta(a, b) {
        return modHalf(b - a, twoPI);
      }
      function angleDist(a, b) {
        return Math.abs(angleDelta(a, b));
      }
      function isAngleInsideSector(a, aBnds) {
        if (isFullCircle(aBnds)) return true;
        var s0, s1;
        if (aBnds[0] < aBnds[1]) {
          s0 = aBnds[0];
          s1 = aBnds[1];
        } else {
          s0 = aBnds[1];
          s1 = aBnds[0];
        }
        s0 = mod(s0, twoPI);
        s1 = mod(s1, twoPI);
        if (s0 > s1) s1 += twoPI;
        var a0 = mod(a, twoPI);
        var a1 = a0 + twoPI;
        return a0 >= s0 && a0 <= s1 || a1 >= s0 && a1 <= s1;
      }
      function isPtInsideSector(r, a, rBnds, aBnds) {
        if (!isAngleInsideSector(a, aBnds)) return false;
        var r0, r1;
        if (rBnds[0] < rBnds[1]) {
          r0 = rBnds[0];
          r1 = rBnds[1];
        } else {
          r0 = rBnds[1];
          r1 = rBnds[0];
        }
        return r >= r0 && r <= r1;
      }
      function _path(r0, r1, a0, a1, cx, cy, isClosed) {
        cx = cx || 0;
        cy = cy || 0;
        var isCircle = isFullCircle([a0, a1]);
        var aStart, aMid, aEnd;
        var rStart, rEnd;
        if (isCircle) {
          aStart = 0;
          aMid = PI;
          aEnd = twoPI;
        } else {
          if (a0 < a1) {
            aStart = a0;
            aEnd = a1;
          } else {
            aStart = a1;
            aEnd = a0;
          }
        }
        if (r0 < r1) {
          rStart = r0;
          rEnd = r1;
        } else {
          rStart = r1;
          rEnd = r0;
        }
        function pt(r, a) {
          return [r * Math.cos(a) + cx, cy - r * Math.sin(a)];
        }
        var largeArc = Math.abs(aEnd - aStart) <= PI ? 0 : 1;
        function arc(r, a, cw) {
          return "A" + [r, r] + " " + [0, largeArc, cw] + " " + pt(r, a);
        }
        var p;
        if (isCircle) {
          if (rStart === null) {
            p = "M" + pt(rEnd, aStart) + arc(rEnd, aMid, 0) + arc(rEnd, aEnd, 0) + "Z";
          } else {
            p = "M" + pt(rStart, aStart) + arc(rStart, aMid, 0) + arc(rStart, aEnd, 0) + "ZM" + pt(rEnd, aStart) + arc(rEnd, aMid, 1) + arc(rEnd, aEnd, 1) + "Z";
          }
        } else {
          if (rStart === null) {
            p = "M" + pt(rEnd, aStart) + arc(rEnd, aEnd, 0);
            if (isClosed) p += "L0,0Z";
          } else {
            p = "M" + pt(rStart, aStart) + "L" + pt(rEnd, aStart) + arc(rEnd, aEnd, 0) + "L" + pt(rStart, aEnd) + arc(rStart, aStart, 1) + "Z";
          }
        }
        return p;
      }
      function pathArc(r, a0, a1, cx, cy) {
        return _path(null, r, a0, a1, cx, cy, 0);
      }
      function pathSector(r, a0, a1, cx, cy) {
        return _path(null, r, a0, a1, cx, cy, 1);
      }
      function pathAnnulus(r0, r1, a0, a1, cx, cy) {
        return _path(r0, r1, a0, a1, cx, cy, 1);
      }
      module.exports = {
        deg2rad,
        rad2deg,
        angleDelta,
        angleDist,
        isFullCircle,
        isAngleInsideSector,
        isPtInsideSector,
        pathArc,
        pathSector,
        pathAnnulus
      };
    }
  });

  // src/lib/anchor_utils.js
  var require_anchor_utils = __commonJS({
    "src/lib/anchor_utils.js"(exports) {
      "use strict";
      exports.isLeftAnchor = function isLeftAnchor(opts) {
        return opts.xanchor === "left" || opts.xanchor === "auto" && opts.x <= 1 / 3;
      };
      exports.isCenterAnchor = function isCenterAnchor(opts) {
        return opts.xanchor === "center" || opts.xanchor === "auto" && opts.x > 1 / 3 && opts.x < 2 / 3;
      };
      exports.isRightAnchor = function isRightAnchor(opts) {
        return opts.xanchor === "right" || opts.xanchor === "auto" && opts.x >= 2 / 3;
      };
      exports.isTopAnchor = function isTopAnchor(opts) {
        return opts.yanchor === "top" || opts.yanchor === "auto" && opts.y >= 2 / 3;
      };
      exports.isMiddleAnchor = function isMiddleAnchor(opts) {
        return opts.yanchor === "middle" || opts.yanchor === "auto" && opts.y > 1 / 3 && opts.y < 2 / 3;
      };
      exports.isBottomAnchor = function isBottomAnchor(opts) {
        return opts.yanchor === "bottom" || opts.yanchor === "auto" && opts.y <= 1 / 3;
      };
    }
  });

  // src/lib/geometry2d.js
  var require_geometry2d = __commonJS({
    "src/lib/geometry2d.js"(exports) {
      "use strict";
      var mod = require_mod().mod;
      exports.segmentsIntersect = segmentsIntersect;
      function segmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        var a = x2 - x1;
        var b = x3 - x1;
        var c = x4 - x3;
        var d = y2 - y1;
        var e = y3 - y1;
        var f = y4 - y3;
        var det = a * f - c * d;
        if (det === 0) return null;
        var t = (b * f - c * e) / det;
        var u = (b * d - a * e) / det;
        if (u < 0 || u > 1 || t < 0 || t > 1) return null;
        return { x: x1 + a * t, y: y1 + d * t };
      }
      exports.segmentDistance = function segmentDistance(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (segmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4)) return 0;
        var x12 = x2 - x1;
        var y12 = y2 - y1;
        var x34 = x4 - x3;
        var y34 = y4 - y3;
        var ll12 = x12 * x12 + y12 * y12;
        var ll34 = x34 * x34 + y34 * y34;
        var dist2 = Math.min(
          perpDistance2(x12, y12, ll12, x3 - x1, y3 - y1),
          perpDistance2(x12, y12, ll12, x4 - x1, y4 - y1),
          perpDistance2(x34, y34, ll34, x1 - x3, y1 - y3),
          perpDistance2(x34, y34, ll34, x2 - x3, y2 - y3)
        );
        return Math.sqrt(dist2);
      };
      function perpDistance2(xab, yab, llab, xac, yac) {
        var fcAB = xac * xab + yac * yab;
        if (fcAB < 0) {
          return xac * xac + yac * yac;
        } else if (fcAB > llab) {
          var xbc = xac - xab;
          var ybc = yac - yab;
          return xbc * xbc + ybc * ybc;
        } else {
          var crossProduct = xac * yab - yac * xab;
          return crossProduct * crossProduct / llab;
        }
      }
      var locationCache;
      var workingPath;
      var workingTextWidth;
      exports.getTextLocation = function getTextLocation(path, totalPathLen, positionOnPath, textWidth) {
        if (path !== workingPath || textWidth !== workingTextWidth) {
          locationCache = {};
          workingPath = path;
          workingTextWidth = textWidth;
        }
        if (locationCache[positionOnPath]) {
          return locationCache[positionOnPath];
        }
        var p0 = path.getPointAtLength(mod(positionOnPath - textWidth / 2, totalPathLen));
        var p1 = path.getPointAtLength(mod(positionOnPath + textWidth / 2, totalPathLen));
        var theta = Math.atan((p1.y - p0.y) / (p1.x - p0.x));
        var pCenter = path.getPointAtLength(mod(positionOnPath, totalPathLen));
        var x = (pCenter.x * 4 + p0.x + p1.x) / 6;
        var y = (pCenter.y * 4 + p0.y + p1.y) / 6;
        var out = { x, y, theta };
        locationCache[positionOnPath] = out;
        return out;
      };
      exports.clearLocationCache = function() {
        workingPath = null;
      };
      exports.getVisibleSegment = function getVisibleSegment(path, bounds, buffer) {
        var left = bounds.left;
        var right = bounds.right;
        var top = bounds.top;
        var bottom = bounds.bottom;
        var pMin = 0;
        var pTotal = path.getTotalLength();
        var pMax = pTotal;
        var pt0, ptTotal;
        function getDistToPlot(len) {
          var pt = path.getPointAtLength(len);
          if (len === 0) pt0 = pt;
          else if (len === pTotal) ptTotal = pt;
          var dx = pt.x < left ? left - pt.x : pt.x > right ? pt.x - right : 0;
          var dy = pt.y < top ? top - pt.y : pt.y > bottom ? pt.y - bottom : 0;
          return Math.sqrt(dx * dx + dy * dy);
        }
        var distToPlot = getDistToPlot(pMin);
        while (distToPlot) {
          pMin += distToPlot + buffer;
          if (pMin > pMax) return;
          distToPlot = getDistToPlot(pMin);
        }
        distToPlot = getDistToPlot(pMax);
        while (distToPlot) {
          pMax -= distToPlot + buffer;
          if (pMin > pMax) return;
          distToPlot = getDistToPlot(pMax);
        }
        return {
          min: pMin,
          max: pMax,
          len: pMax - pMin,
          total: pTotal,
          isClosed: pMin === 0 && pMax === pTotal && Math.abs(pt0.x - ptTotal.x) < 0.1 && Math.abs(pt0.y - ptTotal.y) < 0.1
        };
      };
      exports.findPointOnPath = function findPointOnPath(path, val, coord, opts) {
        opts = opts || {};
        var pathLength = opts.pathLength || path.getTotalLength();
        var tolerance = opts.tolerance || 1e-3;
        var iterationLimit = opts.iterationLimit || 30;
        var mul = path.getPointAtLength(0)[coord] > path.getPointAtLength(pathLength)[coord] ? -1 : 1;
        var i = 0;
        var b0 = 0;
        var b1 = pathLength;
        var mid;
        var pt;
        var diff;
        while (i < iterationLimit) {
          mid = (b0 + b1) / 2;
          pt = path.getPointAtLength(mid);
          diff = pt[coord] - val;
          if (Math.abs(diff) < tolerance) {
            return pt;
          } else {
            if (mul * diff > 0) {
              b1 = mid;
            } else {
              b0 = mid;
            }
            i++;
          }
        }
        return pt;
      };
    }
  });

  // src/lib/throttle.js
  var require_throttle = __commonJS({
    "src/lib/throttle.js"(exports) {
      "use strict";
      var timerCache = {};
      exports.throttle = function throttle(id, minInterval, callback) {
        var cache = timerCache[id];
        var now = Date.now();
        if (!cache) {
          for (var idi in timerCache) {
            if (timerCache[idi].ts < now - 6e4) {
              delete timerCache[idi];
            }
          }
          cache = timerCache[id] = { ts: 0, timer: null };
        }
        _clearTimeout(cache);
        function exec() {
          callback();
          cache.ts = Date.now();
          if (cache.onDone) {
            cache.onDone();
            cache.onDone = null;
          }
        }
        if (now > cache.ts + minInterval) {
          exec();
          return;
        }
        cache.timer = setTimeout(function() {
          exec();
          cache.timer = null;
        }, minInterval);
      };
      exports.done = function(id) {
        var cache = timerCache[id];
        if (!cache || !cache.timer) return Promise.resolve();
        return new Promise(function(resolve) {
          var previousOnDone = cache.onDone;
          cache.onDone = function onDone() {
            if (previousOnDone) previousOnDone();
            resolve();
            cache.onDone = null;
          };
        });
      };
      exports.clear = function(id) {
        if (id) {
          _clearTimeout(timerCache[id]);
          delete timerCache[id];
        } else {
          for (var idi in timerCache) exports.clear(idi);
        }
      };
      function _clearTimeout(cache) {
        if (cache && cache.timer !== null) {
          clearTimeout(cache.timer);
          cache.timer = null;
        }
      }
    }
  });

  // src/lib/clear_responsive.js
  var require_clear_responsive = __commonJS({
    "src/lib/clear_responsive.js"(exports, module) {
      "use strict";
      module.exports = function clearResponsive(gd) {
        if (gd._responsiveChartHandler) {
          window.removeEventListener("resize", gd._responsiveChartHandler);
          delete gd._responsiveChartHandler;
        }
      };
    }
  });

  // node_modules/is-mobile/index.js
  var require_is_mobile = __commonJS({
    "node_modules/is-mobile/index.js"(exports, module) {
      "use strict";
      module.exports = isMobile;
      module.exports.isMobile = isMobile;
      module.exports.default = isMobile;
      var mobileRE = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;
      var notMobileRE = /CrOS/;
      var tabletRE = /android|ipad|playbook|silk/i;
      function isMobile(opts) {
        if (!opts) opts = {};
        let ua = opts.ua;
        if (!ua && typeof navigator !== "undefined") ua = navigator.userAgent;
        if (ua && ua.headers && typeof ua.headers["user-agent"] === "string") {
          ua = ua.headers["user-agent"];
        }
        if (typeof ua !== "string") return false;
        let result = mobileRE.test(ua) && !notMobileRE.test(ua) || !!opts.tablet && tabletRE.test(ua);
        if (!result && opts.tablet && opts.featureDetect && navigator && navigator.maxTouchPoints > 1 && ua.indexOf("Macintosh") !== -1 && ua.indexOf("Safari") !== -1) {
          result = true;
        }
        return result;
      }
    }
  });

  // src/lib/preserve_drawing_buffer.js
  var require_preserve_drawing_buffer = __commonJS({
    "src/lib/preserve_drawing_buffer.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var isMobileOrTablet = require_is_mobile();
      module.exports = function preserveDrawingBuffer(opts) {
        var ua;
        if (opts && opts.hasOwnProperty("userAgent")) {
          ua = opts.userAgent;
        } else {
          ua = getUserAgent();
        }
        if (typeof ua !== "string") return true;
        var enable = isMobileOrTablet({
          ua: { headers: { "user-agent": ua } },
          tablet: true,
          featureDetect: false
        });
        if (!enable) {
          var allParts = ua.split(" ");
          for (var i = 1; i < allParts.length; i++) {
            var part = allParts[i];
            if (part.indexOf("Safari") !== -1) {
              for (var k = i - 1; k > -1; k--) {
                var prevPart = allParts[k];
                if (prevPart.substr(0, 8) === "Version/") {
                  var v = prevPart.substr(8).split(".")[0];
                  if (isNumeric(v)) v = +v;
                  if (v >= 13) return true;
                }
              }
            }
          }
        }
        return enable;
      };
      function getUserAgent() {
        var ua;
        if (typeof navigator !== "undefined") {
          ua = navigator.userAgent;
        }
        if (ua && ua.headers && typeof ua.headers["user-agent"] === "string") {
          ua = ua.headers["user-agent"];
        }
        return ua;
      }
    }
  });

  // src/lib/make_trace_groups.js
  var require_make_trace_groups = __commonJS({
    "src/lib/make_trace_groups.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      module.exports = function makeTraceGroups(traceLayer, cdModule, cls) {
        var traces = traceLayer.selectAll("g." + cls.replace(/\s/g, ".")).data(cdModule, function(cd) {
          return cd[0].trace.uid;
        });
        traces.exit().remove();
        traces.enter().append("g").attr("class", cls);
        traces.order();
        var k = traceLayer.classed("rangeplot") ? "nodeRangePlot3" : "node3";
        traces.each(function(cd) {
          cd[0][k] = d3.select(this);
        });
        return traces;
      };
    }
  });

  // src/lib/localize.js
  var require_localize = __commonJS({
    "src/lib/localize.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      module.exports = function localize(gd, s) {
        var locale = gd._context.locale;
        for (var i = 0; i < 2; i++) {
          var locales = gd._context.locales;
          for (var j = 0; j < 2; j++) {
            var dict = (locales[locale] || {}).dictionary;
            if (dict) {
              var out = dict[s];
              if (out) return out;
            }
            locales = Registry.localeRegistry;
          }
          var baseLocale = locale.split("-")[0];
          if (baseLocale === locale) break;
          locale = baseLocale;
        }
        return s;
      };
    }
  });

  // src/lib/filter_unique.js
  var require_filter_unique = __commonJS({
    "src/lib/filter_unique.js"(exports, module) {
      "use strict";
      module.exports = function filterUnique(array) {
        var seen = {};
        var out = [];
        var j = 0;
        for (var i = 0; i < array.length; i++) {
          var item = array[i];
          if (seen[item] !== 1) {
            seen[item] = 1;
            out[j++] = item;
          }
        }
        return out;
      };
    }
  });

  // src/lib/filter_visible.js
  var require_filter_visible = __commonJS({
    "src/lib/filter_visible.js"(exports, module) {
      "use strict";
      module.exports = function filterVisible(container) {
        var filterFn = isCalcData(container) ? calcDataFilter : baseFilter;
        var out = [];
        for (var i = 0; i < container.length; i++) {
          var item = container[i];
          if (filterFn(item)) out.push(item);
        }
        return out;
      };
      function baseFilter(item) {
        return item.visible === true;
      }
      function calcDataFilter(item) {
        var trace = item[0].trace;
        return trace.visible === true && trace._length !== 0;
      }
      function isCalcData(cont) {
        return Array.isArray(cont) && Array.isArray(cont[0]) && cont[0][0] && cont[0][0].trace;
      }
    }
  });

  // src/lib/increment.js
  var require_increment = __commonJS({
    "src/lib/increment.js"(exports, module) {
      "use strict";
      module.exports = function incrementNumeric(x, delta) {
        if (!delta) return x;
        var scale = 1 / Math.abs(delta);
        var newX = scale > 1 ? (scale * x + scale * delta) / scale : x + delta;
        var lenX1 = String(newX).length;
        if (lenX1 > 16) {
          var lenDt = String(delta).length;
          var lenX0 = String(x).length;
          if (lenX1 >= lenX0 + lenDt) {
            var s = parseFloat(newX).toPrecision(12);
            if (s.indexOf("e+") === -1) newX = +s;
          }
        }
        return newX;
      };
    }
  });

  // src/lib/clean_number.js
  var require_clean_number = __commonJS({
    "src/lib/clean_number.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var BADNUM = require_numerical().BADNUM;
      var JUNK = /^['"%,$#\s']+|[, ]|['"%,$#\s']+$/g;
      module.exports = function cleanNumber(v) {
        if (typeof v === "string") {
          v = v.replace(JUNK, "");
        }
        if (isNumeric(v)) return Number(v);
        return BADNUM;
      };
    }
  });

  // src/lib/index.js
  var require_lib = __commonJS({
    "src/lib/index.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var utcFormat = require_d3_time_format().utcFormat;
      var d3Format = require_d3_format().format;
      var isNumeric = require_fast_isnumeric();
      var numConstants = require_numerical();
      var MAX_SAFE = numConstants.FP_SAFE;
      var MIN_SAFE = -MAX_SAFE;
      var BADNUM = numConstants.BADNUM;
      var lib = module.exports = {};
      lib.adjustFormat = function adjustFormat(formatStr) {
        if (!formatStr || /^\d[.]\df/.test(formatStr) || /[.]\d%/.test(formatStr)) return formatStr;
        if (formatStr === "0.f") return "~f";
        if (/^\d%/.test(formatStr)) return "~%";
        if (/^\ds/.test(formatStr)) return "~s";
        if (!/^[~,.0$]/.test(formatStr) && /[&fps]/.test(formatStr)) return "~" + formatStr;
        return formatStr;
      };
      var seenBadFormats = {};
      lib.warnBadFormat = function(f) {
        var key = String(f);
        if (!seenBadFormats[key]) {
          seenBadFormats[key] = 1;
          lib.warn('encountered bad format: "' + key + '"');
        }
      };
      lib.noFormat = function(value) {
        return String(value);
      };
      lib.numberFormat = function(formatStr) {
        var fn;
        try {
          fn = d3Format(lib.adjustFormat(formatStr));
        } catch (e) {
          lib.warnBadFormat(formatStr);
          return lib.noFormat;
        }
        return fn;
      };
      lib.nestedProperty = require_nested_property();
      lib.keyedContainer = require_keyed_container();
      lib.relativeAttr = require_relative_attr();
      lib.isPlainObject = require_is_plain_object();
      lib.toLogRange = require_to_log_range();
      lib.relinkPrivateKeys = require_relink_private();
      var arrayModule = require_array();
      lib.isArrayBuffer = arrayModule.isArrayBuffer;
      lib.isTypedArray = arrayModule.isTypedArray;
      lib.isArrayOrTypedArray = arrayModule.isArrayOrTypedArray;
      lib.isArray1D = arrayModule.isArray1D;
      lib.ensureArray = arrayModule.ensureArray;
      lib.concat = arrayModule.concat;
      lib.maxRowLength = arrayModule.maxRowLength;
      lib.minRowLength = arrayModule.minRowLength;
      var modModule = require_mod();
      lib.mod = modModule.mod;
      lib.modHalf = modModule.modHalf;
      var coerceModule = require_coerce();
      lib.valObjectMeta = coerceModule.valObjectMeta;
      lib.coerce = coerceModule.coerce;
      lib.coerce2 = coerceModule.coerce2;
      lib.coerceFont = coerceModule.coerceFont;
      lib.coercePattern = coerceModule.coercePattern;
      lib.coerceHoverinfo = coerceModule.coerceHoverinfo;
      lib.coerceSelectionMarkerOpacity = coerceModule.coerceSelectionMarkerOpacity;
      lib.validate = coerceModule.validate;
      var datesModule = require_dates();
      lib.dateTime2ms = datesModule.dateTime2ms;
      lib.isDateTime = datesModule.isDateTime;
      lib.ms2DateTime = datesModule.ms2DateTime;
      lib.ms2DateTimeLocal = datesModule.ms2DateTimeLocal;
      lib.cleanDate = datesModule.cleanDate;
      lib.isJSDate = datesModule.isJSDate;
      lib.formatDate = datesModule.formatDate;
      lib.incrementMonth = datesModule.incrementMonth;
      lib.dateTick0 = datesModule.dateTick0;
      lib.dfltRange = datesModule.dfltRange;
      lib.findExactDates = datesModule.findExactDates;
      lib.MIN_MS = datesModule.MIN_MS;
      lib.MAX_MS = datesModule.MAX_MS;
      var searchModule = require_search();
      lib.findBin = searchModule.findBin;
      lib.sorterAsc = searchModule.sorterAsc;
      lib.sorterDes = searchModule.sorterDes;
      lib.distinctVals = searchModule.distinctVals;
      lib.roundUp = searchModule.roundUp;
      lib.sort = searchModule.sort;
      lib.findIndexOfMin = searchModule.findIndexOfMin;
      lib.sortObjectKeys = require_sort_object_keys();
      var statsModule = require_stats();
      lib.aggNums = statsModule.aggNums;
      lib.len = statsModule.len;
      lib.mean = statsModule.mean;
      lib.geometricMean = statsModule.geometricMean;
      lib.median = statsModule.median;
      lib.midRange = statsModule.midRange;
      lib.variance = statsModule.variance;
      lib.stdev = statsModule.stdev;
      lib.interp = statsModule.interp;
      var matrixModule = require_matrix();
      lib.init2dArray = matrixModule.init2dArray;
      lib.transposeRagged = matrixModule.transposeRagged;
      lib.dot = matrixModule.dot;
      lib.translationMatrix = matrixModule.translationMatrix;
      lib.rotationMatrix = matrixModule.rotationMatrix;
      lib.rotationXYMatrix = matrixModule.rotationXYMatrix;
      lib.apply3DTransform = matrixModule.apply3DTransform;
      lib.apply2DTransform = matrixModule.apply2DTransform;
      lib.apply2DTransform2 = matrixModule.apply2DTransform2;
      lib.convertCssMatrix = matrixModule.convertCssMatrix;
      lib.inverseTransformMatrix = matrixModule.inverseTransformMatrix;
      var anglesModule = require_angles();
      lib.deg2rad = anglesModule.deg2rad;
      lib.rad2deg = anglesModule.rad2deg;
      lib.angleDelta = anglesModule.angleDelta;
      lib.angleDist = anglesModule.angleDist;
      lib.isFullCircle = anglesModule.isFullCircle;
      lib.isAngleInsideSector = anglesModule.isAngleInsideSector;
      lib.isPtInsideSector = anglesModule.isPtInsideSector;
      lib.pathArc = anglesModule.pathArc;
      lib.pathSector = anglesModule.pathSector;
      lib.pathAnnulus = anglesModule.pathAnnulus;
      var anchorUtils = require_anchor_utils();
      lib.isLeftAnchor = anchorUtils.isLeftAnchor;
      lib.isCenterAnchor = anchorUtils.isCenterAnchor;
      lib.isRightAnchor = anchorUtils.isRightAnchor;
      lib.isTopAnchor = anchorUtils.isTopAnchor;
      lib.isMiddleAnchor = anchorUtils.isMiddleAnchor;
      lib.isBottomAnchor = anchorUtils.isBottomAnchor;
      var geom2dModule = require_geometry2d();
      lib.segmentsIntersect = geom2dModule.segmentsIntersect;
      lib.segmentDistance = geom2dModule.segmentDistance;
      lib.getTextLocation = geom2dModule.getTextLocation;
      lib.clearLocationCache = geom2dModule.clearLocationCache;
      lib.getVisibleSegment = geom2dModule.getVisibleSegment;
      lib.findPointOnPath = geom2dModule.findPointOnPath;
      var extendModule = require_extend();
      lib.extendFlat = extendModule.extendFlat;
      lib.extendDeep = extendModule.extendDeep;
      lib.extendDeepAll = extendModule.extendDeepAll;
      lib.extendDeepNoArrays = extendModule.extendDeepNoArrays;
      var loggersModule = require_loggers();
      lib.log = loggersModule.log;
      lib.warn = loggersModule.warn;
      lib.error = loggersModule.error;
      var regexModule = require_regex();
      lib.counterRegex = regexModule.counter;
      var throttleModule = require_throttle();
      lib.throttle = throttleModule.throttle;
      lib.throttleDone = throttleModule.done;
      lib.clearThrottle = throttleModule.clear;
      var domModule = require_dom();
      lib.getGraphDiv = domModule.getGraphDiv;
      lib.isPlotDiv = domModule.isPlotDiv;
      lib.removeElement = domModule.removeElement;
      lib.addStyleRule = domModule.addStyleRule;
      lib.addRelatedStyleRule = domModule.addRelatedStyleRule;
      lib.deleteRelatedStyleRule = domModule.deleteRelatedStyleRule;
      lib.setStyleOnHover = domModule.setStyleOnHover;
      lib.getFullTransformMatrix = domModule.getFullTransformMatrix;
      lib.getElementTransformMatrix = domModule.getElementTransformMatrix;
      lib.getElementAndAncestors = domModule.getElementAndAncestors;
      lib.equalDomRects = domModule.equalDomRects;
      lib.clearResponsive = require_clear_responsive();
      lib.preserveDrawingBuffer = require_preserve_drawing_buffer();
      lib.makeTraceGroups = require_make_trace_groups();
      lib._ = require_localize();
      lib.notifier = require_notifier();
      lib.filterUnique = require_filter_unique();
      lib.filterVisible = require_filter_visible();
      lib.pushUnique = require_push_unique();
      lib.increment = require_increment();
      lib.cleanNumber = require_clean_number();
      lib.ensureNumber = function ensureNumber(v) {
        if (!isNumeric(v)) return BADNUM;
        v = Number(v);
        return v > MAX_SAFE || v < MIN_SAFE ? BADNUM : v;
      };
      lib.isIndex = function(v, len) {
        if (len !== void 0 && v >= len) return false;
        return isNumeric(v) && v >= 0 && v % 1 === 0;
      };
      lib.noop = require_noop();
      lib.identity = require_identity2();
      lib.repeat = function(v, cnt) {
        var out = new Array(cnt);
        for (var i = 0; i < cnt; i++) {
          out[i] = v;
        }
        return out;
      };
      lib.swapAttrs = function(cont, attrList, part1, part2) {
        if (!part1) part1 = "x";
        if (!part2) part2 = "y";
        for (var i = 0; i < attrList.length; i++) {
          var attr = attrList[i];
          var xp = lib.nestedProperty(cont, attr.replace("?", part1));
          var yp = lib.nestedProperty(cont, attr.replace("?", part2));
          var temp = xp.get();
          xp.set(yp.get());
          yp.set(temp);
        }
      };
      lib.raiseToTop = function raiseToTop(elem) {
        elem.parentNode.appendChild(elem);
      };
      lib.cancelTransition = function(selection) {
        return selection.transition().duration(0);
      };
      lib.constrain = function(v, v0, v1) {
        if (v0 > v1) return Math.max(v1, Math.min(v0, v));
        return Math.max(v0, Math.min(v1, v));
      };
      lib.bBoxIntersect = function(a, b, pad) {
        pad = pad || 0;
        return a.left <= b.right + pad && b.left <= a.right + pad && a.top <= b.bottom + pad && b.top <= a.bottom + pad;
      };
      lib.simpleMap = function(array, func, x1, x2, opts) {
        var len = array.length;
        var out = new Array(len);
        for (var i = 0; i < len; i++) out[i] = func(array[i], x1, x2, opts);
        return out;
      };
      lib.randstr = function randstr(existing, bits, base, _recursion) {
        if (!base) base = 16;
        if (bits === void 0) bits = 24;
        if (bits <= 0) return "0";
        var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
        var res = "";
        var i, b, x;
        for (i = 2; digits === Infinity; i *= 2) {
          digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
        }
        var rem = digits - Math.floor(digits);
        for (i = 0; i < Math.floor(digits); i++) {
          x = Math.floor(Math.random() * base).toString(base);
          res = x + res;
        }
        if (rem) {
          b = Math.pow(base, rem);
          x = Math.floor(Math.random() * b).toString(base);
          res = x + res;
        }
        var parsed = parseInt(res, base);
        if (existing && existing[res] || parsed !== Infinity && parsed >= Math.pow(2, bits)) {
          if (_recursion > 10) {
            lib.warn("randstr failed uniqueness");
            return res;
          }
          return randstr(existing, bits, base, (_recursion || 0) + 1);
        } else return res;
      };
      lib.OptionControl = function(opt, optname) {
        if (!opt) opt = {};
        if (!optname) optname = "opt";
        var self2 = {};
        self2.optionList = [];
        self2._newoption = function(optObj) {
          optObj[optname] = opt;
          self2[optObj.name] = optObj;
          self2.optionList.push(optObj);
        };
        self2["_" + optname] = opt;
        return self2;
      };
      lib.smooth = function(arrayIn, FWHM) {
        FWHM = Math.round(FWHM) || 0;
        if (FWHM < 2) return arrayIn;
        var alen = arrayIn.length;
        var alen2 = 2 * alen;
        var wlen = 2 * FWHM - 1;
        var w = new Array(wlen);
        var arrayOut = new Array(alen);
        var i;
        var j;
        var k;
        var v;
        for (i = 0; i < wlen; i++) {
          w[i] = (1 - Math.cos(Math.PI * (i + 1) / FWHM)) / (2 * FWHM);
        }
        for (i = 0; i < alen; i++) {
          v = 0;
          for (j = 0; j < wlen; j++) {
            k = i + j + 1 - FWHM;
            if (k < -alen) k -= alen2 * Math.round(k / alen2);
            else if (k >= alen2) k -= alen2 * Math.floor(k / alen2);
            if (k < 0) k = -1 - k;
            else if (k >= alen) k = alen2 - 1 - k;
            v += arrayIn[k] * w[j];
          }
          arrayOut[i] = v;
        }
        return arrayOut;
      };
      lib.syncOrAsync = function(sequence, arg, finalStep) {
        var ret, fni;
        function continueAsync() {
          return lib.syncOrAsync(sequence, arg, finalStep);
        }
        while (sequence.length) {
          fni = sequence.splice(0, 1)[0];
          ret = fni(arg);
          if (ret && ret.then) {
            return ret.then(continueAsync);
          }
        }
        return finalStep && finalStep(arg);
      };
      lib.stripTrailingSlash = function(str) {
        if (str.substr(-1) === "/") return str.substr(0, str.length - 1);
        return str;
      };
      lib.noneOrAll = function(containerIn, containerOut, attrList) {
        if (!containerIn) return;
        var hasAny = false;
        var hasAll = true;
        var i;
        var val;
        for (i = 0; i < attrList.length; i++) {
          val = containerIn[attrList[i]];
          if (val !== void 0 && val !== null) hasAny = true;
          else hasAll = false;
        }
        if (hasAny && !hasAll) {
          for (i = 0; i < attrList.length; i++) {
            containerIn[attrList[i]] = containerOut[attrList[i]];
          }
        }
      };
      lib.mergeArray = function(traceAttr, cd, cdAttr, fn) {
        var hasFn = typeof fn === "function";
        if (lib.isArrayOrTypedArray(traceAttr)) {
          var imax = Math.min(traceAttr.length, cd.length);
          for (var i = 0; i < imax; i++) {
            var v = traceAttr[i];
            cd[i][cdAttr] = hasFn ? fn(v) : v;
          }
        }
      };
      lib.mergeArrayCastPositive = function(traceAttr, cd, cdAttr) {
        return lib.mergeArray(traceAttr, cd, cdAttr, function(v) {
          var w = +v;
          return !isFinite(w) ? 0 : w > 0 ? w : 0;
        });
      };
      lib.fillArray = function(traceAttr, cd, cdAttr, fn) {
        fn = fn || lib.identity;
        if (lib.isArrayOrTypedArray(traceAttr)) {
          for (var i = 0; i < cd.length; i++) {
            cd[i][cdAttr] = fn(traceAttr[i]);
          }
        }
      };
      lib.castOption = function(trace, ptNumber, astr, fn) {
        fn = fn || lib.identity;
        var val = lib.nestedProperty(trace, astr).get();
        if (lib.isArrayOrTypedArray(val)) {
          if (Array.isArray(ptNumber) && lib.isArrayOrTypedArray(val[ptNumber[0]])) {
            return fn(val[ptNumber[0]][ptNumber[1]]);
          } else {
            return fn(val[ptNumber]);
          }
        } else {
          return val;
        }
      };
      lib.extractOption = function(calcPt, trace, calcKey, traceKey) {
        if (calcKey in calcPt) return calcPt[calcKey];
        var traceVal = lib.nestedProperty(trace, traceKey).get();
        if (!Array.isArray(traceVal)) return traceVal;
      };
      function makePtIndex2PtNumber(indexToPoints) {
        var ptIndex2ptNumber = {};
        for (var k in indexToPoints) {
          var pts = indexToPoints[k];
          for (var j = 0; j < pts.length; j++) {
            ptIndex2ptNumber[pts[j]] = +k;
          }
        }
        return ptIndex2ptNumber;
      }
      lib.tagSelected = function(calcTrace, trace, ptNumber2cdIndex) {
        var selectedpoints = trace.selectedpoints;
        var indexToPoints = trace._indexToPoints;
        var ptIndex2ptNumber;
        if (indexToPoints) {
          ptIndex2ptNumber = makePtIndex2PtNumber(indexToPoints);
        }
        function isCdIndexValid(v) {
          return v !== void 0 && v < calcTrace.length;
        }
        for (var i = 0; i < selectedpoints.length; i++) {
          var ptIndex = selectedpoints[i];
          if (lib.isIndex(ptIndex) || lib.isArrayOrTypedArray(ptIndex) && lib.isIndex(ptIndex[0]) && lib.isIndex(ptIndex[1])) {
            var ptNumber = ptIndex2ptNumber ? ptIndex2ptNumber[ptIndex] : ptIndex;
            var cdIndex = ptNumber2cdIndex ? ptNumber2cdIndex[ptNumber] : ptNumber;
            if (isCdIndexValid(cdIndex)) {
              calcTrace[cdIndex].selected = 1;
            }
          }
        }
      };
      lib.selIndices2selPoints = function(trace) {
        var selectedpoints = trace.selectedpoints;
        var indexToPoints = trace._indexToPoints;
        if (indexToPoints) {
          var ptIndex2ptNumber = makePtIndex2PtNumber(indexToPoints);
          var out = [];
          for (var i = 0; i < selectedpoints.length; i++) {
            var ptIndex = selectedpoints[i];
            if (lib.isIndex(ptIndex)) {
              var ptNumber = ptIndex2ptNumber[ptIndex];
              if (lib.isIndex(ptNumber)) {
                out.push(ptNumber);
              }
            }
          }
          return out;
        } else {
          return selectedpoints;
        }
      };
      lib.getTargetArray = function(trace, transformOpts) {
        var target = transformOpts.target;
        if (typeof target === "string" && target) {
          var array = lib.nestedProperty(trace, target).get();
          return lib.isArrayOrTypedArray(array) ? array : false;
        } else if (lib.isArrayOrTypedArray(target)) {
          return target;
        }
        return false;
      };
      function minExtend(obj1, obj2, opt) {
        var objOut = {};
        if (typeof obj2 !== "object") obj2 = {};
        var arrayLen = opt === "pieLike" ? -1 : 3;
        var keys = Object.keys(obj1);
        var i, k, v;
        for (i = 0; i < keys.length; i++) {
          k = keys[i];
          v = obj1[k];
          if (k.charAt(0) === "_" || typeof v === "function") continue;
          else if (k === "module") objOut[k] = v;
          else if (Array.isArray(v)) {
            if (k === "colorscale" || arrayLen === -1) {
              objOut[k] = v.slice();
            } else {
              objOut[k] = v.slice(0, arrayLen);
            }
          } else if (lib.isTypedArray(v)) {
            if (arrayLen === -1) {
              objOut[k] = v.subarray();
            } else {
              objOut[k] = v.subarray(0, arrayLen);
            }
          } else if (v && typeof v === "object") objOut[k] = minExtend(obj1[k], obj2[k], opt);
          else objOut[k] = v;
        }
        keys = Object.keys(obj2);
        for (i = 0; i < keys.length; i++) {
          k = keys[i];
          v = obj2[k];
          if (typeof v !== "object" || !(k in objOut) || typeof objOut[k] !== "object") {
            objOut[k] = v;
          }
        }
        return objOut;
      }
      lib.minExtend = minExtend;
      lib.titleCase = function(s) {
        return s.charAt(0).toUpperCase() + s.substr(1);
      };
      lib.containsAny = function(s, fragments) {
        for (var i = 0; i < fragments.length; i++) {
          if (s.indexOf(fragments[i]) !== -1) return true;
        }
        return false;
      };
      var IS_SAFARI_REGEX = /Version\/[\d\.]+.*Safari/;
      lib.isSafari = function() {
        return IS_SAFARI_REGEX.test(window.navigator.userAgent);
      };
      var IS_IOS_REGEX = /iPad|iPhone|iPod/;
      lib.isIOS = function() {
        return IS_IOS_REGEX.test(window.navigator.userAgent);
      };
      var FIREFOX_VERSION_REGEX = /Firefox\/(\d+)\.\d+/;
      lib.getFirefoxVersion = function() {
        var match = FIREFOX_VERSION_REGEX.exec(window.navigator.userAgent);
        if (match && match.length === 2) {
          var versionInt = parseInt(match[1]);
          if (!isNaN(versionInt)) {
            return versionInt;
          }
        }
        return null;
      };
      lib.isD3Selection = function(obj) {
        return obj instanceof d3.selection;
      };
      lib.ensureSingle = function(parent, nodeType, className, enterFn) {
        var sel = parent.select(nodeType + (className ? "." + className : ""));
        if (sel.size()) return sel;
        var layer = parent.append(nodeType);
        if (className) layer.classed(className, true);
        if (enterFn) layer.call(enterFn);
        return layer;
      };
      lib.ensureSingleById = function(parent, nodeType, id, enterFn) {
        var sel = parent.select(nodeType + "#" + id);
        if (sel.size()) return sel;
        var layer = parent.append(nodeType).attr("id", id);
        if (enterFn) layer.call(enterFn);
        return layer;
      };
      lib.objectFromPath = function(path, value) {
        var keys = path.split(".");
        var tmpObj;
        var obj = tmpObj = {};
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var el = null;
          var parts = keys[i].match(/(.*)\[([0-9]+)\]/);
          if (parts) {
            key = parts[1];
            el = parts[2];
            tmpObj = tmpObj[key] = [];
            if (i === keys.length - 1) {
              tmpObj[el] = value;
            } else {
              tmpObj[el] = {};
            }
            tmpObj = tmpObj[el];
          } else {
            if (i === keys.length - 1) {
              tmpObj[key] = value;
            } else {
              tmpObj[key] = {};
            }
            tmpObj = tmpObj[key];
          }
        }
        return obj;
      };
      var dottedPropertyRegex = /^([^\[\.]+)\.(.+)?/;
      var indexedPropertyRegex = /^([^\.]+)\[([0-9]+)\](\.)?(.+)?/;
      function notValid(prop) {
        return prop.slice(0, 2) === "__";
      }
      lib.expandObjectPaths = function(data) {
        var match, key, prop, datum, idx, dest, trailingPath;
        if (typeof data === "object" && !Array.isArray(data)) {
          for (key in data) {
            if (data.hasOwnProperty(key)) {
              if (match = key.match(dottedPropertyRegex)) {
                datum = data[key];
                prop = match[1];
                if (notValid(prop)) continue;
                delete data[key];
                data[prop] = lib.extendDeepNoArrays(data[prop] || {}, lib.objectFromPath(key, lib.expandObjectPaths(datum))[prop]);
              } else if (match = key.match(indexedPropertyRegex)) {
                datum = data[key];
                prop = match[1];
                if (notValid(prop)) continue;
                idx = parseInt(match[2]);
                delete data[key];
                data[prop] = data[prop] || [];
                if (match[3] === ".") {
                  trailingPath = match[4];
                  dest = data[prop][idx] = data[prop][idx] || {};
                  lib.extendDeepNoArrays(dest, lib.objectFromPath(trailingPath, lib.expandObjectPaths(datum)));
                } else {
                  if (notValid(prop)) continue;
                  data[prop][idx] = lib.expandObjectPaths(datum);
                }
              } else {
                if (notValid(key)) continue;
                data[key] = lib.expandObjectPaths(data[key]);
              }
            }
          }
        }
        return data;
      };
      lib.numSeparate = function(value, separators, separatethousands) {
        if (!separatethousands) separatethousands = false;
        if (typeof separators !== "string" || separators.length === 0) {
          throw new Error("Separator string required for formatting!");
        }
        if (typeof value === "number") {
          value = String(value);
        }
        var thousandsRe = /(\d+)(\d{3})/;
        var decimalSep = separators.charAt(0);
        var thouSep = separators.charAt(1);
        var x = value.split(".");
        var x1 = x[0];
        var x2 = x.length > 1 ? decimalSep + x[1] : "";
        if (thouSep && (x.length > 1 || x1.length > 4 || separatethousands)) {
          while (thousandsRe.test(x1)) {
            x1 = x1.replace(thousandsRe, "$1" + thouSep + "$2");
          }
        }
        return x1 + x2;
      };
      lib.TEMPLATE_STRING_REGEX = /%{([^\s%{}:]*)([:|\|][^}]*)?}/g;
      var SIMPLE_PROPERTY_REGEX = /^\w*$/;
      lib.templateString = function(string, obj) {
        var getterCache = {};
        return string.replace(lib.TEMPLATE_STRING_REGEX, function(dummy, key) {
          var v;
          if (SIMPLE_PROPERTY_REGEX.test(key)) {
            v = obj[key];
          } else {
            getterCache[key] = getterCache[key] || lib.nestedProperty(obj, key).get;
            v = getterCache[key](true);
          }
          return v !== void 0 ? v : "";
        });
      };
      var hovertemplateWarnings = {
        max: 10,
        count: 0,
        name: "hovertemplate"
      };
      lib.hovertemplateString = function() {
        return templateFormatString.apply(hovertemplateWarnings, arguments);
      };
      var texttemplateWarnings = {
        max: 10,
        count: 0,
        name: "texttemplate"
      };
      lib.texttemplateString = function() {
        return templateFormatString.apply(texttemplateWarnings, arguments);
      };
      var MULT_DIV_REGEX = /^(\S+)([\*\/])(-?\d+(\.\d+)?)$/;
      function multDivParser(inputStr) {
        var match = inputStr.match(MULT_DIV_REGEX);
        if (match) return { key: match[1], op: match[2], number: Number(match[3]) };
        return { key: inputStr, op: null, number: null };
      }
      var texttemplateWarningsForShapes = {
        max: 10,
        count: 0,
        name: "texttemplate",
        parseMultDiv: true
      };
      lib.texttemplateStringForShapes = function() {
        return templateFormatString.apply(texttemplateWarningsForShapes, arguments);
      };
      var TEMPLATE_STRING_FORMAT_SEPARATOR = /^[:|\|]/;
      function templateFormatString(string, labels, d3locale) {
        var opts = this;
        var args = arguments;
        if (!labels) labels = {};
        return string.replace(lib.TEMPLATE_STRING_REGEX, function(match, rawKey, format) {
          var isOther = rawKey === "xother" || rawKey === "yother";
          var isSpaceOther = rawKey === "_xother" || rawKey === "_yother";
          var isSpaceOtherSpace = rawKey === "_xother_" || rawKey === "_yother_";
          var isOtherSpace = rawKey === "xother_" || rawKey === "yother_";
          var hasOther = isOther || isSpaceOther || isOtherSpace || isSpaceOtherSpace;
          var key = rawKey;
          if (isSpaceOther || isSpaceOtherSpace) key = key.substring(1);
          if (isOtherSpace || isSpaceOtherSpace) key = key.substring(0, key.length - 1);
          var parsedOp = null;
          var parsedNumber = null;
          if (opts.parseMultDiv) {
            var _match = multDivParser(key);
            key = _match.key;
            parsedOp = _match.op;
            parsedNumber = _match.number;
          }
          var value;
          if (hasOther) {
            value = labels[key];
            if (value === void 0) return "";
          } else {
            var obj, i;
            for (i = 3; i < args.length; i++) {
              obj = args[i];
              if (!obj) continue;
              if (obj.hasOwnProperty(key)) {
                value = obj[key];
                break;
              }
              if (!SIMPLE_PROPERTY_REGEX.test(key)) {
                value = lib.nestedProperty(obj, key).get(true);
              }
              if (value !== void 0) break;
            }
          }
          if (value !== void 0) {
            if (parsedOp === "*") value *= parsedNumber;
            if (parsedOp === "/") value /= parsedNumber;
          }
          if (value === void 0 && opts) {
            if (opts.count < opts.max) {
              lib.warn("Variable '" + key + "' in " + opts.name + " could not be found!");
              value = match;
            }
            if (opts.count === opts.max) {
              lib.warn("Too many " + opts.name + " warnings - additional warnings will be suppressed");
            }
            opts.count++;
            return match;
          }
          if (format) {
            var fmt;
            if (format[0] === ":") {
              fmt = d3locale ? d3locale.numberFormat : lib.numberFormat;
              if (value !== "") {
                value = fmt(format.replace(TEMPLATE_STRING_FORMAT_SEPARATOR, ""))(value);
              }
            }
            if (format[0] === "|") {
              fmt = d3locale ? d3locale.timeFormat : utcFormat;
              var ms = lib.dateTime2ms(value);
              value = lib.formatDate(ms, format.replace(TEMPLATE_STRING_FORMAT_SEPARATOR, ""), false, fmt);
            }
          } else {
            var keyLabel = key + "Label";
            if (labels.hasOwnProperty(keyLabel)) value = labels[keyLabel];
          }
          if (hasOther) {
            value = "(" + value + ")";
            if (isSpaceOther || isSpaceOtherSpace) value = " " + value;
            if (isOtherSpace || isSpaceOtherSpace) value = value + " ";
          }
          return value;
        });
      }
      var char0 = 48;
      var char9 = 57;
      lib.subplotSort = function(a, b) {
        var l = Math.min(a.length, b.length) + 1;
        var numA = 0;
        var numB = 0;
        for (var i = 0; i < l; i++) {
          var charA = a.charCodeAt(i) || 0;
          var charB = b.charCodeAt(i) || 0;
          var isNumA = charA >= char0 && charA <= char9;
          var isNumB = charB >= char0 && charB <= char9;
          if (isNumA) numA = 10 * numA + charA - char0;
          if (isNumB) numB = 10 * numB + charB - char0;
          if (!isNumA || !isNumB) {
            if (numA !== numB) return numA - numB;
            if (charA !== charB) return charA - charB;
          }
        }
        return numB - numA;
      };
      var randSeed = 2e9;
      lib.seedPseudoRandom = function() {
        randSeed = 2e9;
      };
      lib.pseudoRandom = function() {
        var lastVal = randSeed;
        randSeed = (69069 * randSeed + 1) % 4294967296;
        if (Math.abs(randSeed - lastVal) < 429496729) return lib.pseudoRandom();
        return randSeed / 4294967296;
      };
      lib.fillText = function(calcPt, trace, contOut) {
        var fill = Array.isArray(contOut) ? function(v) {
          contOut.push(v);
        } : function(v) {
          contOut.text = v;
        };
        var htx = lib.extractOption(calcPt, trace, "htx", "hovertext");
        if (lib.isValidTextValue(htx)) return fill(htx);
        var tx = lib.extractOption(calcPt, trace, "tx", "text");
        if (lib.isValidTextValue(tx)) return fill(tx);
      };
      lib.isValidTextValue = function(v) {
        return v || v === 0;
      };
      lib.formatPercent = function(ratio, n) {
        n = n || 0;
        var str = (Math.round(100 * ratio * Math.pow(10, n)) * Math.pow(0.1, n)).toFixed(n) + "%";
        for (var i = 0; i < n; i++) {
          if (str.indexOf(".") !== -1) {
            str = str.replace("0%", "%");
            str = str.replace(".%", "%");
          }
        }
        return str;
      };
      lib.isHidden = function(gd) {
        var display = window.getComputedStyle(gd).display;
        return !display || display === "none";
      };
      lib.strTranslate = function(x, y) {
        return x || y ? "translate(" + x + "," + y + ")" : "";
      };
      lib.strRotate = function(a) {
        return a ? "rotate(" + a + ")" : "";
      };
      lib.strScale = function(s) {
        return s !== 1 ? "scale(" + s + ")" : "";
      };
      lib.getTextTransform = function(transform) {
        var noCenter = transform.noCenter;
        var textX = transform.textX;
        var textY = transform.textY;
        var targetX = transform.targetX;
        var targetY = transform.targetY;
        var anchorX = transform.anchorX || 0;
        var anchorY = transform.anchorY || 0;
        var rotate = transform.rotate;
        var scale = transform.scale;
        if (!scale) scale = 0;
        else if (scale > 1) scale = 1;
        return lib.strTranslate(
          targetX - scale * (textX + anchorX),
          targetY - scale * (textY + anchorY)
        ) + lib.strScale(scale) + (rotate ? "rotate(" + rotate + (noCenter ? "" : " " + textX + " " + textY) + ")" : "");
      };
      lib.setTransormAndDisplay = function(s, transform) {
        s.attr("transform", lib.getTextTransform(transform));
        s.style("display", transform.scale ? null : "none");
      };
      lib.ensureUniformFontSize = function(gd, baseFont) {
        var out = lib.extendFlat({}, baseFont);
        out.size = Math.max(
          baseFont.size,
          gd._fullLayout.uniformtext.minsize || 0
        );
        return out;
      };
      lib.join2 = function(arr, mainSeparator, lastSeparator) {
        var len = arr.length;
        if (len > 1) {
          return arr.slice(0, -1).join(mainSeparator) + lastSeparator + arr[len - 1];
        }
        return arr.join(mainSeparator);
      };
      lib.bigFont = function(size) {
        return Math.round(1.2 * size);
      };
      var firefoxVersion = lib.getFirefoxVersion();
      var isProblematicFirefox = firefoxVersion !== null && firefoxVersion < 86;
      lib.getPositionFromD3Event = function() {
        if (isProblematicFirefox) {
          return [
            d3.event.layerX,
            d3.event.layerY
          ];
        } else {
          return [
            d3.event.offsetX,
            d3.event.offsetY
          ];
        }
      };
    }
  });

  // build/plotcss.js
  var require_plotcss = __commonJS({
    "build/plotcss.js"() {
      "use strict";
      var Lib = require_lib();
      var rules = {
        "X,X div": 'direction:ltr;font-family:"Open Sans",verdana,arial,sans-serif;margin:0;padding:0;',
        "X input,X button": 'font-family:"Open Sans",verdana,arial,sans-serif;',
        "X input:focus,X button:focus": "outline:none;",
        "X a": "text-decoration:none;",
        "X a:hover": "text-decoration:none;",
        "X .crisp": "shape-rendering:crispEdges;",
        "X .user-select-none": "-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none;",
        "X svg a": "fill:#447adb;",
        "X svg a:hover": "fill:#3c6dc5;",
        "X .main-svg": "position:absolute;top:0;left:0;pointer-events:none;",
        "X .main-svg .draglayer": "pointer-events:all;",
        "X .cursor-default": "cursor:default;",
        "X .cursor-pointer": "cursor:pointer;",
        "X .cursor-crosshair": "cursor:crosshair;",
        "X .cursor-move": "cursor:move;",
        "X .cursor-col-resize": "cursor:col-resize;",
        "X .cursor-row-resize": "cursor:row-resize;",
        "X .cursor-ns-resize": "cursor:ns-resize;",
        "X .cursor-ew-resize": "cursor:ew-resize;",
        "X .cursor-sw-resize": "cursor:sw-resize;",
        "X .cursor-s-resize": "cursor:s-resize;",
        "X .cursor-se-resize": "cursor:se-resize;",
        "X .cursor-w-resize": "cursor:w-resize;",
        "X .cursor-e-resize": "cursor:e-resize;",
        "X .cursor-nw-resize": "cursor:nw-resize;",
        "X .cursor-n-resize": "cursor:n-resize;",
        "X .cursor-ne-resize": "cursor:ne-resize;",
        "X .cursor-grab": "cursor:-webkit-grab;cursor:grab;",
        "X .modebar": "position:absolute;top:2px;right:2px;",
        "X .ease-bg": "-webkit-transition:background-color .3s ease 0s;-moz-transition:background-color .3s ease 0s;-ms-transition:background-color .3s ease 0s;-o-transition:background-color .3s ease 0s;transition:background-color .3s ease 0s;",
        "X .modebar--hover>:not(.watermark)": "opacity:0;-webkit-transition:opacity .3s ease 0s;-moz-transition:opacity .3s ease 0s;-ms-transition:opacity .3s ease 0s;-o-transition:opacity .3s ease 0s;transition:opacity .3s ease 0s;",
        "X:hover .modebar--hover .modebar-group": "opacity:1;",
        "X .modebar-group": "float:left;display:inline-block;box-sizing:border-box;padding-left:8px;position:relative;vertical-align:middle;white-space:nowrap;",
        "X .modebar-btn": "position:relative;font-size:16px;padding:3px 4px;height:22px;cursor:pointer;line-height:normal;box-sizing:border-box;",
        "X .modebar-btn svg": "position:relative;top:2px;",
        "X .modebar.vertical": "display:flex;flex-direction:column;flex-wrap:wrap;align-content:flex-end;max-height:100%;",
        "X .modebar.vertical svg": "top:-1px;",
        "X .modebar.vertical .modebar-group": "display:block;float:none;padding-left:0px;padding-bottom:8px;",
        "X .modebar.vertical .modebar-group .modebar-btn": "display:block;text-align:center;",
        "X [data-title]:before,X [data-title]:after": "position:absolute;-webkit-transform:translate3d(0, 0, 0);-moz-transform:translate3d(0, 0, 0);-ms-transform:translate3d(0, 0, 0);-o-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);display:none;opacity:0;z-index:1001;pointer-events:none;top:110%;right:50%;",
        "X [data-title]:hover:before,X [data-title]:hover:after": "display:block;opacity:1;",
        "X [data-title]:before": 'content:"";position:absolute;background:rgba(0,0,0,0);border:6px solid rgba(0,0,0,0);z-index:1002;margin-top:-12px;border-bottom-color:#69738a;margin-right:-6px;',
        "X [data-title]:after": "content:attr(data-title);background:#69738a;color:#fff;padding:8px 10px;font-size:12px;line-height:12px;white-space:nowrap;margin-right:-18px;border-radius:2px;",
        "X .vertical [data-title]:before,X .vertical [data-title]:after": "top:0%;right:200%;",
        "X .vertical [data-title]:before": "border:6px solid rgba(0,0,0,0);border-left-color:#69738a;margin-top:8px;margin-right:-30px;",
        Y: 'font-family:"Open Sans",verdana,arial,sans-serif;position:fixed;top:50px;right:20px;z-index:10000;font-size:10pt;max-width:180px;',
        "Y p": "margin:0;",
        "Y .notifier-note": "min-width:180px;max-width:250px;border:1px solid #fff;z-index:3000;margin:0;background-color:#8c97af;background-color:rgba(140,151,175,.9);color:#fff;padding:10px;overflow-wrap:break-word;word-wrap:break-word;-ms-hyphens:auto;-webkit-hyphens:auto;hyphens:auto;",
        "Y .notifier-close": "color:#fff;opacity:.8;float:right;padding:0 5px;background:none;border:none;font-size:20px;font-weight:bold;line-height:20px;",
        "Y .notifier-close:hover": "color:#444;text-decoration:none;cursor:pointer;"
      };
      for (selector in rules) {
        fullSelector = selector.replace(/^,/, " ,").replace(/X/g, ".js-plotly-plot .plotly").replace(/Y/g, ".plotly-notifier");
        Lib.addStyleRule(fullSelector, rules[selector]);
      }
      var fullSelector;
      var selector;
    }
  });

  // node_modules/is-browser/client.js
  var require_client = __commonJS({
    "node_modules/is-browser/client.js"(exports, module) {
      module.exports = true;
    }
  });

  // node_modules/has-hover/index.js
  var require_has_hover = __commonJS({
    "node_modules/has-hover/index.js"(exports, module) {
      "use strict";
      var isBrowser = require_client();
      var hasHover;
      if (typeof window.matchMedia === "function") {
        hasHover = !window.matchMedia("(hover: none)").matches;
      } else {
        hasHover = isBrowser;
      }
      module.exports = hasHover;
    }
  });

  // node_modules/events/events.js
  var require_events = __commonJS({
    "node_modules/events/events.js"(exports, module) {
      "use strict";
      var R = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === "function") {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn) console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      module.exports = EventEmitter;
      module.exports.once = once;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
        }
        this._maxListeners = n;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit(type) {
        var args = [];
        for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err.context = er;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            ReflectApply(listeners[i], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit(
              "newListener",
              type,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m = _getMaxListeners(target);
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i)
          copy[i] = arr[i];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // src/lib/events.js
  var require_events2 = __commonJS({
    "src/lib/events.js"(exports, module) {
      "use strict";
      var EventEmitter = require_events().EventEmitter;
      var Events = {
        init: function(plotObj) {
          if (plotObj._ev instanceof EventEmitter) return plotObj;
          var ev = new EventEmitter();
          var internalEv = new EventEmitter();
          plotObj._ev = ev;
          plotObj._internalEv = internalEv;
          plotObj.on = ev.on.bind(ev);
          plotObj.once = ev.once.bind(ev);
          plotObj.removeListener = ev.removeListener.bind(ev);
          plotObj.removeAllListeners = ev.removeAllListeners.bind(ev);
          plotObj._internalOn = internalEv.on.bind(internalEv);
          plotObj._internalOnce = internalEv.once.bind(internalEv);
          plotObj._removeInternalListener = internalEv.removeListener.bind(internalEv);
          plotObj._removeAllInternalListeners = internalEv.removeAllListeners.bind(internalEv);
          plotObj.emit = function(event, data) {
            ev.emit(event, data);
            internalEv.emit(event, data);
          };
          return plotObj;
        },
        /*
         * This function behaves like jQuery's triggerHandler. It calls
         * all handlers for a particular event and returns the return value
         * of the LAST handler.
         */
        triggerHandler: function(plotObj, event, data) {
          var nodeEventHandlerValue;
          var ev = plotObj._ev;
          if (!ev) return;
          var handlers = ev._events[event];
          if (!handlers) return;
          function apply(handler) {
            if (handler.listener) {
              ev.removeListener(event, handler.listener);
              if (!handler.fired) {
                handler.fired = true;
                return handler.listener.apply(ev, [data]);
              }
            } else {
              return handler.apply(ev, [data]);
            }
          }
          handlers = Array.isArray(handlers) ? handlers : [handlers];
          var i;
          for (i = 0; i < handlers.length - 1; i++) {
            apply(handlers[i]);
          }
          nodeEventHandlerValue = apply(handlers[i]);
          return nodeEventHandlerValue;
        },
        purge: function(plotObj) {
          delete plotObj._ev;
          delete plotObj.on;
          delete plotObj.once;
          delete plotObj.removeListener;
          delete plotObj.removeAllListeners;
          delete plotObj.emit;
          delete plotObj._ev;
          delete plotObj._internalEv;
          delete plotObj._internalOn;
          delete plotObj._internalOnce;
          delete plotObj._removeInternalListener;
          delete plotObj._removeAllInternalListeners;
          return plotObj;
        }
      };
      module.exports = Events;
    }
  });

  // src/lib/queue.js
  var require_queue = __commonJS({
    "src/lib/queue.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var dfltConfig = require_plot_config().dfltConfig;
      function copyArgArray(gd, args) {
        var copy = [];
        var arg;
        for (var i = 0; i < args.length; i++) {
          arg = args[i];
          if (arg === gd) copy[i] = arg;
          else if (typeof arg === "object") {
            copy[i] = Array.isArray(arg) ? Lib.extendDeep([], arg) : Lib.extendDeepAll({}, arg);
          } else copy[i] = arg;
        }
        return copy;
      }
      var queue = {};
      queue.add = function(gd, undoFunc, undoArgs, redoFunc, redoArgs) {
        var queueObj, queueIndex;
        gd.undoQueue = gd.undoQueue || { index: 0, queue: [], sequence: false };
        queueIndex = gd.undoQueue.index;
        if (gd.autoplay) {
          if (!gd.undoQueue.inSequence) gd.autoplay = false;
          return;
        }
        if (!gd.undoQueue.sequence || gd.undoQueue.beginSequence) {
          queueObj = { undo: { calls: [], args: [] }, redo: { calls: [], args: [] } };
          gd.undoQueue.queue.splice(queueIndex, gd.undoQueue.queue.length - queueIndex, queueObj);
          gd.undoQueue.index += 1;
        } else {
          queueObj = gd.undoQueue.queue[queueIndex - 1];
        }
        gd.undoQueue.beginSequence = false;
        if (queueObj) {
          queueObj.undo.calls.unshift(undoFunc);
          queueObj.undo.args.unshift(undoArgs);
          queueObj.redo.calls.push(redoFunc);
          queueObj.redo.args.push(redoArgs);
        }
        if (gd.undoQueue.queue.length > dfltConfig.queueLength) {
          gd.undoQueue.queue.shift();
          gd.undoQueue.index--;
        }
      };
      queue.startSequence = function(gd) {
        gd.undoQueue = gd.undoQueue || { index: 0, queue: [], sequence: false };
        gd.undoQueue.sequence = true;
        gd.undoQueue.beginSequence = true;
      };
      queue.stopSequence = function(gd) {
        gd.undoQueue = gd.undoQueue || { index: 0, queue: [], sequence: false };
        gd.undoQueue.sequence = false;
        gd.undoQueue.beginSequence = false;
      };
      queue.undo = function undo(gd) {
        var queueObj, i;
        if (gd.undoQueue === void 0 || isNaN(gd.undoQueue.index) || gd.undoQueue.index <= 0) {
          return;
        }
        gd.undoQueue.index--;
        queueObj = gd.undoQueue.queue[gd.undoQueue.index];
        gd.undoQueue.inSequence = true;
        for (i = 0; i < queueObj.undo.calls.length; i++) {
          queue.plotDo(gd, queueObj.undo.calls[i], queueObj.undo.args[i]);
        }
        gd.undoQueue.inSequence = false;
        gd.autoplay = false;
      };
      queue.redo = function redo(gd) {
        var queueObj, i;
        if (gd.undoQueue === void 0 || isNaN(gd.undoQueue.index) || gd.undoQueue.index >= gd.undoQueue.queue.length) {
          return;
        }
        queueObj = gd.undoQueue.queue[gd.undoQueue.index];
        gd.undoQueue.inSequence = true;
        for (i = 0; i < queueObj.redo.calls.length; i++) {
          queue.plotDo(gd, queueObj.redo.calls[i], queueObj.redo.args[i]);
        }
        gd.undoQueue.inSequence = false;
        gd.autoplay = false;
        gd.undoQueue.index++;
      };
      queue.plotDo = function(gd, func, args) {
        gd.autoplay = true;
        args = copyArgArray(gd, args);
        func.apply(null, args);
      };
      module.exports = queue;
    }
  });

  // src/plots/frame_attributes.js
  var require_frame_attributes = __commonJS({
    "src/plots/frame_attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        _isLinkedToArray: "frames_entry",
        group: {
          valType: "string"
        },
        name: {
          valType: "string"
        },
        traces: {
          valType: "any"
        },
        baseframe: {
          valType: "string"
        },
        data: {
          valType: "any"
        },
        layout: {
          valType: "any"
        }
      };
    }
  });

  // src/plot_api/plot_schema.js
  var require_plot_schema = __commonJS({
    "src/plot_api/plot_schema.js"(exports) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var baseAttributes = require_attributes2();
      var baseLayoutAttributes = require_layout_attributes2();
      var frameAttributes = require_frame_attributes();
      var animationAttributes = require_animation_attributes();
      var configAttributes = require_plot_config().configAttributes;
      var editTypes = require_edit_types();
      var extendDeepAll = Lib.extendDeepAll;
      var isPlainObject = Lib.isPlainObject;
      var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
      var nestedProperty = Lib.nestedProperty;
      var valObjectMeta = Lib.valObjectMeta;
      var IS_SUBPLOT_OBJ = "_isSubplotObj";
      var IS_LINKED_TO_ARRAY = "_isLinkedToArray";
      var ARRAY_ATTR_REGEXPS = "_arrayAttrRegexps";
      var DEPRECATED = "_deprecated";
      var UNDERSCORE_ATTRS = [IS_SUBPLOT_OBJ, IS_LINKED_TO_ARRAY, ARRAY_ATTR_REGEXPS, DEPRECATED];
      exports.IS_SUBPLOT_OBJ = IS_SUBPLOT_OBJ;
      exports.IS_LINKED_TO_ARRAY = IS_LINKED_TO_ARRAY;
      exports.DEPRECATED = DEPRECATED;
      exports.UNDERSCORE_ATTRS = UNDERSCORE_ATTRS;
      exports.get = function() {
        var traces = {};
        Registry.allTypes.forEach(function(type) {
          traces[type] = getTraceAttributes(type);
        });
        return {
          defs: {
            valObjects: valObjectMeta,
            metaKeys: UNDERSCORE_ATTRS.concat(["description", "role", "editType", "impliedEdits"]),
            editType: {
              traces: editTypes.traces,
              layout: editTypes.layout
            },
            impliedEdits: {}
          },
          traces,
          layout: getLayoutAttributes(),
          frames: getFramesAttributes(),
          animation: formatAttributes(animationAttributes),
          config: formatAttributes(configAttributes)
        };
      };
      exports.crawl = function(attrs, callback, specifiedLevel, attrString) {
        var level = specifiedLevel || 0;
        attrString = attrString || "";
        Object.keys(attrs).forEach(function(attrName) {
          var attr = attrs[attrName];
          if (UNDERSCORE_ATTRS.indexOf(attrName) !== -1) return;
          var fullAttrString = (attrString ? attrString + "." : "") + attrName;
          callback(attr, attrName, attrs, level, fullAttrString);
          if (exports.isValObject(attr)) return;
          if (isPlainObject(attr) && attrName !== "impliedEdits") {
            exports.crawl(attr, callback, level + 1, fullAttrString);
          }
        });
      };
      exports.isValObject = function(obj) {
        return obj && obj.valType !== void 0;
      };
      exports.findArrayAttributes = function(trace) {
        var arrayAttributes = [];
        var stack = [];
        var isArrayStack = [];
        var baseContainer, baseAttrName;
        function callback(attr, attrName, attrs, level) {
          stack = stack.slice(0, level).concat([attrName]);
          isArrayStack = isArrayStack.slice(0, level).concat([attr && attr._isLinkedToArray]);
          var splittableAttr = attr && (attr.valType === "data_array" || attr.arrayOk === true) && !(stack[level - 1] === "colorbar" && (attrName === "ticktext" || attrName === "tickvals"));
          if (!splittableAttr) return;
          crawlIntoTrace(baseContainer, 0, "");
        }
        function crawlIntoTrace(container, i, astrPartial) {
          var item = container[stack[i]];
          var newAstrPartial = astrPartial + stack[i];
          if (i === stack.length - 1) {
            if (isArrayOrTypedArray(item)) {
              arrayAttributes.push(baseAttrName + newAstrPartial);
            }
          } else {
            if (isArrayStack[i]) {
              if (Array.isArray(item)) {
                for (var j = 0; j < item.length; j++) {
                  if (isPlainObject(item[j])) {
                    crawlIntoTrace(item[j], i + 1, newAstrPartial + "[" + j + "].");
                  }
                }
              }
            } else if (isPlainObject(item)) {
              crawlIntoTrace(item, i + 1, newAstrPartial + ".");
            }
          }
        }
        baseContainer = trace;
        baseAttrName = "";
        exports.crawl(baseAttributes, callback);
        if (trace._module && trace._module.attributes) {
          exports.crawl(trace._module.attributes, callback);
        }
        return arrayAttributes;
      };
      exports.getTraceValObject = function(trace, parts) {
        var head = parts[0];
        var i = 1;
        var moduleAttrs, valObject;
        var _module = trace._module;
        if (!_module) _module = (Registry.modules[trace.type || baseAttributes.type.dflt] || {})._module;
        if (!_module) return false;
        moduleAttrs = _module.attributes;
        valObject = moduleAttrs && moduleAttrs[head];
        if (!valObject) {
          var subplotModule = _module.basePlotModule;
          if (subplotModule && subplotModule.attributes) {
            valObject = subplotModule.attributes[head];
          }
        }
        if (!valObject) valObject = baseAttributes[head];
        return recurseIntoValObject(valObject, parts, i);
      };
      exports.getLayoutValObject = function(fullLayout, parts) {
        var valObject = layoutHeadAttr(fullLayout, parts[0]);
        return recurseIntoValObject(valObject, parts, 1);
      };
      function layoutHeadAttr(fullLayout, head) {
        var i, key, _module, attributes;
        var basePlotModules = fullLayout._basePlotModules;
        if (basePlotModules) {
          var out;
          for (i = 0; i < basePlotModules.length; i++) {
            _module = basePlotModules[i];
            if (_module.attrRegex && _module.attrRegex.test(head)) {
              if (_module.layoutAttrOverrides) return _module.layoutAttrOverrides;
              if (!out && _module.layoutAttributes) out = _module.layoutAttributes;
            }
            var baseOverrides = _module.baseLayoutAttrOverrides;
            if (baseOverrides && head in baseOverrides) return baseOverrides[head];
          }
          if (out) return out;
        }
        var modules = fullLayout._modules;
        if (modules) {
          for (i = 0; i < modules.length; i++) {
            attributes = modules[i].layoutAttributes;
            if (attributes && head in attributes) {
              return attributes[head];
            }
          }
        }
        for (key in Registry.componentsRegistry) {
          _module = Registry.componentsRegistry[key];
          if (_module.name === "colorscale" && head.indexOf("coloraxis") === 0) {
            return _module.layoutAttributes[head];
          } else if (!_module.schema && head === _module.name) {
            return _module.layoutAttributes;
          }
        }
        if (head in baseLayoutAttributes) return baseLayoutAttributes[head];
        return false;
      }
      function recurseIntoValObject(valObject, parts, i) {
        if (!valObject) return false;
        if (valObject._isLinkedToArray) {
          if (isIndex(parts[i])) i++;
          else if (i < parts.length) return false;
        }
        for (; i < parts.length; i++) {
          var newValObject = valObject[parts[i]];
          if (isPlainObject(newValObject)) valObject = newValObject;
          else break;
          if (i === parts.length - 1) break;
          if (valObject._isLinkedToArray) {
            i++;
            if (!isIndex(parts[i])) return false;
          } else if (valObject.valType === "info_array") {
            i++;
            var index = parts[i];
            if (!isIndex(index)) return false;
            var items = valObject.items;
            if (Array.isArray(items)) {
              if (index >= items.length) return false;
              if (valObject.dimensions === 2) {
                i++;
                if (parts.length === i) return valObject;
                var index2 = parts[i];
                if (!isIndex(index2)) return false;
                valObject = items[index][index2];
              } else valObject = items[index];
            } else {
              valObject = items;
            }
          }
        }
        return valObject;
      }
      function isIndex(val) {
        return val === Math.round(val) && val >= 0;
      }
      function getTraceAttributes(type) {
        var _module, basePlotModule;
        _module = Registry.modules[type]._module, basePlotModule = _module.basePlotModule;
        var attributes = {};
        attributes.type = null;
        var copyBaseAttributes = extendDeepAll({}, baseAttributes);
        var copyModuleAttributes = extendDeepAll({}, _module.attributes);
        exports.crawl(copyModuleAttributes, function(attr, attrName, attrs, level, fullAttrString) {
          nestedProperty(copyBaseAttributes, fullAttrString).set(void 0);
          if (attr === void 0) nestedProperty(copyModuleAttributes, fullAttrString).set(void 0);
        });
        extendDeepAll(attributes, copyBaseAttributes);
        if (Registry.traceIs(type, "noOpacity")) {
          delete attributes.opacity;
        }
        if (!Registry.traceIs(type, "showLegend")) {
          delete attributes.showlegend;
          delete attributes.legendgroup;
        }
        if (Registry.traceIs(type, "noHover")) {
          delete attributes.hoverinfo;
          delete attributes.hoverlabel;
        }
        if (!_module.selectPoints) {
          delete attributes.selectedpoints;
        }
        extendDeepAll(attributes, copyModuleAttributes);
        if (basePlotModule.attributes) {
          extendDeepAll(attributes, basePlotModule.attributes);
        }
        attributes.type = type;
        var out = {
          meta: _module.meta || {},
          categories: _module.categories || {},
          animatable: Boolean(_module.animatable),
          type,
          attributes: formatAttributes(attributes)
        };
        if (_module.layoutAttributes) {
          var layoutAttributes = {};
          extendDeepAll(layoutAttributes, _module.layoutAttributes);
          out.layoutAttributes = formatAttributes(layoutAttributes);
        }
        if (!_module.animatable) {
          exports.crawl(out, function(attr) {
            if (exports.isValObject(attr) && "anim" in attr) {
              delete attr.anim;
            }
          });
        }
        return out;
      }
      function getLayoutAttributes() {
        var layoutAttributes = {};
        var key, _module;
        extendDeepAll(layoutAttributes, baseLayoutAttributes);
        for (key in Registry.subplotsRegistry) {
          _module = Registry.subplotsRegistry[key];
          if (!_module.layoutAttributes) continue;
          if (Array.isArray(_module.attr)) {
            for (var i = 0; i < _module.attr.length; i++) {
              handleBasePlotModule(layoutAttributes, _module, _module.attr[i]);
            }
          } else {
            var astr = _module.attr === "subplot" ? _module.name : _module.attr;
            handleBasePlotModule(layoutAttributes, _module, astr);
          }
        }
        for (key in Registry.componentsRegistry) {
          _module = Registry.componentsRegistry[key];
          var schema = _module.schema;
          if (schema && (schema.subplots || schema.layout)) {
            var subplots = schema.subplots;
            if (subplots && subplots.xaxis && !subplots.yaxis) {
              for (var xkey in subplots.xaxis) {
                delete layoutAttributes.yaxis[xkey];
              }
            }
            delete layoutAttributes.xaxis.shift;
            delete layoutAttributes.xaxis.autoshift;
          } else if (_module.name === "colorscale") {
            extendDeepAll(layoutAttributes, _module.layoutAttributes);
          } else if (_module.layoutAttributes) {
            insertAttrs(layoutAttributes, _module.layoutAttributes, _module.name);
          }
        }
        return {
          layoutAttributes: formatAttributes(layoutAttributes)
        };
      }
      function getFramesAttributes() {
        var attrs = {
          frames: extendDeepAll({}, frameAttributes)
        };
        formatAttributes(attrs);
        return attrs.frames;
      }
      function formatAttributes(attrs) {
        mergeValTypeAndRole(attrs);
        formatArrayContainers(attrs);
        stringify(attrs);
        return attrs;
      }
      function mergeValTypeAndRole(attrs) {
        function makeSrcAttr(attrName) {
          return {
            valType: "string",
            editType: "none"
          };
        }
        function callback(attr, attrName, attrs2) {
          if (exports.isValObject(attr)) {
            if (attr.arrayOk === true || attr.valType === "data_array") {
              attrs2[attrName + "src"] = makeSrcAttr(attrName);
            }
          } else if (isPlainObject(attr)) {
            attr.role = "object";
          }
        }
        exports.crawl(attrs, callback);
      }
      function formatArrayContainers(attrs) {
        function callback(attr, attrName, attrs2) {
          if (!attr) return;
          var itemName = attr[IS_LINKED_TO_ARRAY];
          if (!itemName) return;
          delete attr[IS_LINKED_TO_ARRAY];
          attrs2[attrName] = { items: {} };
          attrs2[attrName].items[itemName] = attr;
          attrs2[attrName].role = "object";
        }
        exports.crawl(attrs, callback);
      }
      function stringify(attrs) {
        function walk(attr) {
          for (var k in attr) {
            if (isPlainObject(attr[k])) {
              walk(attr[k]);
            } else if (Array.isArray(attr[k])) {
              for (var i = 0; i < attr[k].length; i++) {
                walk(attr[k][i]);
              }
            } else {
              if (attr[k] instanceof RegExp) {
                attr[k] = attr[k].toString();
              }
            }
          }
        }
        walk(attrs);
      }
      function handleBasePlotModule(layoutAttributes, _module, astr) {
        var np = nestedProperty(layoutAttributes, astr);
        var attrs = extendDeepAll({}, _module.layoutAttributes);
        attrs[IS_SUBPLOT_OBJ] = true;
        np.set(attrs);
      }
      function insertAttrs(baseAttrs, newAttrs, astr) {
        var np = nestedProperty(baseAttrs, astr);
        np.set(extendDeepAll(np.get() || {}, newAttrs));
      }
    }
  });

  // src/plot_api/plot_template.js
  var require_plot_template = __commonJS({
    "src/plot_api/plot_template.js"(exports) {
      "use strict";
      var Lib = require_lib();
      var plotAttributes = require_attributes2();
      var TEMPLATEITEMNAME = "templateitemname";
      var templateAttrs = {
        name: {
          valType: "string",
          editType: "none"
        }
      };
      templateAttrs[TEMPLATEITEMNAME] = {
        valType: "string",
        editType: "calc"
      };
      exports.templatedArray = function(name, attrs) {
        attrs._isLinkedToArray = name;
        attrs.name = templateAttrs.name;
        attrs[TEMPLATEITEMNAME] = templateAttrs[TEMPLATEITEMNAME];
        return attrs;
      };
      exports.traceTemplater = function(dataTemplate) {
        var traceCounts = {};
        var traceType, typeTemplates;
        for (traceType in dataTemplate) {
          typeTemplates = dataTemplate[traceType];
          if (Array.isArray(typeTemplates) && typeTemplates.length) {
            traceCounts[traceType] = 0;
          }
        }
        function newTrace(traceIn) {
          traceType = Lib.coerce(traceIn, {}, plotAttributes, "type");
          var traceOut = { type: traceType, _template: null };
          if (traceType in traceCounts) {
            typeTemplates = dataTemplate[traceType];
            var typei = traceCounts[traceType] % typeTemplates.length;
            traceCounts[traceType]++;
            traceOut._template = typeTemplates[typei];
          } else {
          }
          return traceOut;
        }
        return {
          newTrace
          // TODO: function to figure out what's left & what didn't work
        };
      };
      exports.newContainer = function(container, name, baseName) {
        var template = container._template;
        var part = template && (template[name] || baseName && template[baseName]);
        if (!Lib.isPlainObject(part)) part = null;
        var out = container[name] = { _template: part };
        return out;
      };
      exports.arrayTemplater = function(container, name, inclusionAttr) {
        var template = container._template;
        var defaultsTemplate = template && template[arrayDefaultKey(name)];
        var templateItems = template && template[name];
        if (!Array.isArray(templateItems) || !templateItems.length) {
          templateItems = [];
        }
        var usedNames = {};
        function newItem(itemIn) {
          var out = { name: itemIn.name, _input: itemIn };
          var templateItemName = out[TEMPLATEITEMNAME] = itemIn[TEMPLATEITEMNAME];
          if (!validItemName(templateItemName)) {
            out._template = defaultsTemplate;
            return out;
          }
          for (var i = 0; i < templateItems.length; i++) {
            var templateItem = templateItems[i];
            if (templateItem.name === templateItemName) {
              usedNames[templateItemName] = 1;
              out._template = templateItem;
              return out;
            }
          }
          out[inclusionAttr] = itemIn[inclusionAttr] || false;
          out._template = false;
          return out;
        }
        function defaultItems() {
          var out = [];
          for (var i = 0; i < templateItems.length; i++) {
            var templateItem = templateItems[i];
            var name2 = templateItem.name;
            if (validItemName(name2) && !usedNames[name2]) {
              var outi = {
                _template: templateItem,
                name: name2,
                _input: { _templateitemname: name2 }
              };
              outi[TEMPLATEITEMNAME] = templateItem[TEMPLATEITEMNAME];
              out.push(outi);
              usedNames[name2] = 1;
            }
          }
          return out;
        }
        return {
          newItem,
          defaultItems
        };
      };
      function validItemName(name) {
        return name && typeof name === "string";
      }
      function arrayDefaultKey(name) {
        var lastChar = name.length - 1;
        if (name.charAt(lastChar) !== "s") {
          Lib.warn("bad argument to arrayDefaultKey: " + name);
        }
        return name.substr(0, name.length - 1) + "defaults";
      }
      exports.arrayDefaultKey = arrayDefaultKey;
      exports.arrayEditor = function(parentIn, containerStr, itemOut) {
        var lengthIn = (Lib.nestedProperty(parentIn, containerStr).get() || []).length;
        var index = itemOut._index;
        var templateItemName = index >= lengthIn && (itemOut._input || {})._templateitemname;
        if (templateItemName) index = lengthIn;
        var itemStr = containerStr + "[" + index + "]";
        var update;
        function resetUpdate() {
          update = {};
          if (templateItemName) {
            update[itemStr] = {};
            update[itemStr][TEMPLATEITEMNAME] = templateItemName;
          }
        }
        resetUpdate();
        function modifyBase(attr, value) {
          update[attr] = value;
        }
        function modifyItem(attr, value) {
          if (templateItemName) {
            Lib.nestedProperty(update[itemStr], attr).set(value);
          } else {
            update[itemStr + "." + attr] = value;
          }
        }
        function getUpdateObj() {
          var updateOut = update;
          resetUpdate();
          return updateOut;
        }
        function applyUpdate(attr, value) {
          if (attr) modifyItem(attr, value);
          var updateToApply = getUpdateObj();
          for (var key in updateToApply) {
            Lib.nestedProperty(parentIn, key).set(updateToApply[key]);
          }
        }
        return {
          modifyBase,
          modifyItem,
          getUpdateObj,
          applyUpdate
        };
      };
    }
  });

  // src/plots/cartesian/constants.js
  var require_constants2 = __commonJS({
    "src/plots/cartesian/constants.js"(exports, module) {
      "use strict";
      var counterRegex = require_regex().counter;
      module.exports = {
        idRegex: {
          x: counterRegex("x", "( domain)?"),
          y: counterRegex("y", "( domain)?")
        },
        attrRegex: counterRegex("[xy]axis"),
        // axis match regular expression
        xAxisMatch: counterRegex("xaxis"),
        yAxisMatch: counterRegex("yaxis"),
        // pattern matching axis ids and names
        // note that this is more permissive than counterRegex, as
        // id2name, name2id, and cleanId accept "x1" etc
        AX_ID_PATTERN: /^[xyz][0-9]*( domain)?$/,
        AX_NAME_PATTERN: /^[xyz]axis[0-9]*$/,
        // and for 2D subplots
        SUBPLOT_PATTERN: /^x([0-9]*)y([0-9]*)$/,
        HOUR_PATTERN: "hour",
        WEEKDAY_PATTERN: "day of week",
        // pixels to move mouse before you stop clamping to starting point
        MINDRAG: 8,
        // smallest dimension allowed for a zoombox
        MINZOOM: 20,
        // width of axis drag regions
        DRAGGERSIZE: 20,
        // delay before a redraw (relayout) after smooth panning and zooming
        REDRAWDELAY: 50,
        // last resort axis ranges for x and y axes if we have no data
        DFLTRANGEX: [-1, 6],
        DFLTRANGEY: [-1, 4],
        // Layers to keep trace types in the right order
        // N.B. each  'unique' plot method must have its own layer
        traceLayerClasses: [
          "imagelayer",
          "heatmaplayer",
          "contourcarpetlayer",
          "contourlayer",
          "funnellayer",
          "waterfalllayer",
          "barlayer",
          "carpetlayer",
          "violinlayer",
          "boxlayer",
          "ohlclayer",
          "scattercarpetlayer",
          "scatterlayer"
        ],
        clipOnAxisFalseQuery: [
          ".scatterlayer",
          ".barlayer",
          ".funnellayer",
          ".waterfalllayer"
        ],
        layerValue2layerClass: {
          "above traces": "above",
          "below traces": "below"
        },
        zindexSeparator: "z"
        // used for zindex of cartesian subplots e.g. xy, xyz2, xyz3, etc.
      };
    }
  });

  // src/plots/cartesian/axis_ids.js
  var require_axis_ids = __commonJS({
    "src/plots/cartesian/axis_ids.js"(exports) {
      "use strict";
      var Registry = require_registry();
      var constants = require_constants2();
      exports.id2name = function id2name(id) {
        if (typeof id !== "string" || !id.match(constants.AX_ID_PATTERN)) return;
        var axNum = id.split(" ")[0].substr(1);
        if (axNum === "1") axNum = "";
        return id.charAt(0) + "axis" + axNum;
      };
      exports.name2id = function name2id(name) {
        if (!name.match(constants.AX_NAME_PATTERN)) return;
        var axNum = name.substr(5);
        if (axNum === "1") axNum = "";
        return name.charAt(0) + axNum;
      };
      exports.cleanId = function cleanId(id, axLetter, domainId) {
        var domainTest = /( domain)$/.test(id);
        if (typeof id !== "string" || !id.match(constants.AX_ID_PATTERN)) return;
        if (axLetter && id.charAt(0) !== axLetter) return;
        if (domainTest && !domainId) return;
        var axNum = id.split(" ")[0].substr(1).replace(/^0+/, "");
        if (axNum === "1") axNum = "";
        return id.charAt(0) + axNum + (domainTest && domainId ? " domain" : "");
      };
      exports.list = function(gd, axLetter, only2d) {
        var fullLayout = gd._fullLayout;
        if (!fullLayout) return [];
        var idList = exports.listIds(gd, axLetter);
        var out = new Array(idList.length);
        var i;
        for (i = 0; i < idList.length; i++) {
          var idi = idList[i];
          out[i] = fullLayout[idi.charAt(0) + "axis" + idi.substr(1)];
        }
        if (!only2d) {
          var sceneIds3D = fullLayout._subplots.gl3d || [];
          for (i = 0; i < sceneIds3D.length; i++) {
            var scene = fullLayout[sceneIds3D[i]];
            if (axLetter) out.push(scene[axLetter + "axis"]);
            else out.push(scene.xaxis, scene.yaxis, scene.zaxis);
          }
        }
        return out;
      };
      exports.listIds = function(gd, axLetter) {
        var fullLayout = gd._fullLayout;
        if (!fullLayout) return [];
        var subplotLists = fullLayout._subplots;
        if (axLetter) return subplotLists[axLetter + "axis"];
        return subplotLists.xaxis.concat(subplotLists.yaxis);
      };
      exports.getFromId = function(gd, id, type) {
        var fullLayout = gd._fullLayout;
        id = id === void 0 || typeof id !== "string" ? id : id.replace(" domain", "");
        if (type === "x") id = id.replace(/y[0-9]*/, "");
        else if (type === "y") id = id.replace(/x[0-9]*/, "");
        return fullLayout[exports.id2name(id)];
      };
      exports.getFromTrace = function(gd, fullTrace, type) {
        var fullLayout = gd._fullLayout;
        var ax = null;
        if (Registry.traceIs(fullTrace, "gl3d")) {
          var scene = fullTrace.scene;
          if (scene.substr(0, 5) === "scene") {
            ax = fullLayout[scene][type + "axis"];
          }
        } else {
          ax = exports.getFromId(gd, fullTrace[type + "axis"] || type);
        }
        return ax;
      };
      exports.idSort = function(id1, id2) {
        var letter1 = id1.charAt(0);
        var letter2 = id2.charAt(0);
        if (letter1 !== letter2) return letter1 > letter2 ? 1 : -1;
        return +(id1.substr(1) || 1) - +(id2.substr(1) || 1);
      };
      exports.ref2id = function(ar) {
        return /^[xyz]/.test(ar) ? ar.split(" ")[0] : false;
      };
      function isFound(axId, list) {
        if (list && list.length) {
          for (var i = 0; i < list.length; i++) {
            if (list[i][axId]) return true;
          }
        }
        return false;
      }
      exports.isLinked = function(fullLayout, axId) {
        return isFound(axId, fullLayout._axisMatchGroups) || isFound(axId, fullLayout._axisConstraintGroups);
      };
    }
  });

  // src/components/shapes/handle_outline.js
  var require_handle_outline = __commonJS({
    "src/components/shapes/handle_outline.js"(exports, module) {
      "use strict";
      function clearOutlineControllers(gd) {
        var zoomLayer = gd._fullLayout._zoomlayer;
        if (zoomLayer) {
          zoomLayer.selectAll(".outline-controllers").remove();
        }
      }
      function clearOutline(gd) {
        var zoomLayer = gd._fullLayout._zoomlayer;
        if (zoomLayer) {
          zoomLayer.selectAll(".select-outline").remove();
        }
        gd._fullLayout._outlining = false;
      }
      module.exports = {
        clearOutlineControllers,
        clearOutline
      };
    }
  });

  // src/traces/scatter/layout_attributes.js
  var require_layout_attributes3 = __commonJS({
    "src/traces/scatter/layout_attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        scattermode: {
          valType: "enumerated",
          values: ["group", "overlay"],
          dflt: "overlay",
          editType: "calc"
        },
        scattergap: {
          valType: "number",
          min: 0,
          max: 1,
          editType: "calc"
        }
      };
    }
  });

  // src/plots/get_data.js
  var require_get_data = __commonJS({
    "src/plots/get_data.js"(exports) {
      "use strict";
      var Registry = require_registry();
      var SUBPLOT_PATTERN = require_constants2().SUBPLOT_PATTERN;
      exports.getSubplotCalcData = function(calcData, type, subplotId) {
        var basePlotModule = Registry.subplotsRegistry[type];
        if (!basePlotModule) return [];
        var attr = basePlotModule.attr;
        var subplotCalcData = [];
        for (var i = 0; i < calcData.length; i++) {
          var calcTrace = calcData[i];
          var trace = calcTrace[0].trace;
          if (trace[attr] === subplotId) subplotCalcData.push(calcTrace);
        }
        return subplotCalcData;
      };
      exports.getModuleCalcData = function(calcdata, arg1, arg2) {
        var moduleCalcData = [];
        var remainingCalcData = [];
        var plotMethod;
        if (typeof arg1 === "string") {
          plotMethod = Registry.getModule(arg1).plot;
        } else if (typeof arg1 === "function") {
          plotMethod = arg1;
        } else {
          plotMethod = arg1.plot;
        }
        if (!plotMethod) {
          return [moduleCalcData, calcdata];
        }
        var zorder = arg2;
        for (var i = 0; i < calcdata.length; i++) {
          var cd = calcdata[i];
          var trace = cd[0].trace;
          var filterByZ = trace.zorder !== void 0;
          if (trace.visible !== true || trace._length === 0) continue;
          if (trace._module && trace._module.plot === plotMethod && (!filterByZ || trace.zorder === zorder)) {
            moduleCalcData.push(cd);
          } else {
            remainingCalcData.push(cd);
          }
        }
        return [moduleCalcData, remainingCalcData];
      };
      exports.getSubplotData = function getSubplotData(data, type, subplotId) {
        if (!Registry.subplotsRegistry[type]) return [];
        var attr = Registry.subplotsRegistry[type].attr;
        var subplotData = [];
        var trace, subplotX, subplotY;
        for (var i = 0; i < data.length; i++) {
          trace = data[i];
          if (trace[attr] === subplotId) subplotData.push(trace);
        }
        return subplotData;
      };
    }
  });

  // src/plots/command.js
  var require_command = __commonJS({
    "src/plots/command.js"(exports) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      exports.manageCommandObserver = function(gd, container, commandList, onchange) {
        var ret = {};
        var enabled = true;
        if (container && container._commandObserver) {
          ret = container._commandObserver;
        }
        if (!ret.cache) {
          ret.cache = {};
        }
        ret.lookupTable = {};
        var binding = exports.hasSimpleAPICommandBindings(gd, commandList, ret.lookupTable);
        if (container && container._commandObserver) {
          if (!binding) {
            if (container._commandObserver.remove) {
              container._commandObserver.remove();
              container._commandObserver = null;
              return ret;
            }
          } else {
            return ret;
          }
        }
        if (binding) {
          bindingValueHasChanged(gd, binding, ret.cache);
          ret.check = function check() {
            if (!enabled) return;
            var update = bindingValueHasChanged(gd, binding, ret.cache);
            if (update.changed && onchange) {
              if (ret.lookupTable[update.value] !== void 0) {
                ret.disable();
                Promise.resolve(onchange({
                  value: update.value,
                  type: binding.type,
                  prop: binding.prop,
                  traces: binding.traces,
                  index: ret.lookupTable[update.value]
                })).then(ret.enable, ret.enable);
              }
            }
            return update.changed;
          };
          var checkEvents = [
            "plotly_relayout",
            "plotly_redraw",
            "plotly_restyle",
            "plotly_update",
            "plotly_animatingframe",
            "plotly_afterplot"
          ];
          for (var i = 0; i < checkEvents.length; i++) {
            gd._internalOn(checkEvents[i], ret.check);
          }
          ret.remove = function() {
            for (var i2 = 0; i2 < checkEvents.length; i2++) {
              gd._removeInternalListener(checkEvents[i2], ret.check);
            }
          };
        } else {
          Lib.log("Unable to automatically bind plot updates to API command");
          ret.lookupTable = {};
          ret.remove = function() {
          };
        }
        ret.disable = function disable() {
          enabled = false;
        };
        ret.enable = function enable() {
          enabled = true;
        };
        if (container) {
          container._commandObserver = ret;
        }
        return ret;
      };
      exports.hasSimpleAPICommandBindings = function(gd, commandList, bindingsByValue) {
        var i;
        var n = commandList.length;
        var refBinding;
        for (i = 0; i < n; i++) {
          var binding;
          var command = commandList[i];
          var method = command.method;
          var args = command.args;
          if (!Array.isArray(args)) args = [];
          if (!method) {
            return false;
          }
          var bindings = exports.computeAPICommandBindings(gd, method, args);
          if (bindings.length !== 1) {
            return false;
          }
          if (!refBinding) {
            refBinding = bindings[0];
            if (Array.isArray(refBinding.traces)) {
              refBinding.traces.sort();
            }
          } else {
            binding = bindings[0];
            if (binding.type !== refBinding.type) {
              return false;
            }
            if (binding.prop !== refBinding.prop) {
              return false;
            }
            if (Array.isArray(refBinding.traces)) {
              if (Array.isArray(binding.traces)) {
                binding.traces.sort();
                for (var j = 0; j < refBinding.traces.length; j++) {
                  if (refBinding.traces[j] !== binding.traces[j]) {
                    return false;
                  }
                }
              } else {
                return false;
              }
            } else {
              if (binding.prop !== refBinding.prop) {
                return false;
              }
            }
          }
          binding = bindings[0];
          var value = binding.value;
          if (Array.isArray(value)) {
            if (value.length === 1) {
              value = value[0];
            } else {
              return false;
            }
          }
          if (bindingsByValue) {
            bindingsByValue[value] = i;
          }
        }
        return refBinding;
      };
      function bindingValueHasChanged(gd, binding, cache) {
        var container, value, obj;
        var changed = false;
        if (binding.type === "data") {
          container = gd._fullData[binding.traces !== null ? binding.traces[0] : 0];
        } else if (binding.type === "layout") {
          container = gd._fullLayout;
        } else {
          return false;
        }
        value = Lib.nestedProperty(container, binding.prop).get();
        obj = cache[binding.type] = cache[binding.type] || {};
        if (obj.hasOwnProperty(binding.prop)) {
          if (obj[binding.prop] !== value) {
            changed = true;
          }
        }
        obj[binding.prop] = value;
        return {
          changed,
          value
        };
      }
      exports.executeAPICommand = function(gd, method, args) {
        if (method === "skip") return Promise.resolve();
        var _method = Registry.apiMethodRegistry[method];
        var allArgs = [gd];
        if (!Array.isArray(args)) args = [];
        for (var i = 0; i < args.length; i++) {
          allArgs.push(args[i]);
        }
        return _method.apply(null, allArgs).catch(function(err) {
          Lib.warn("API call to Plotly." + method + " rejected.", err);
          return Promise.reject(err);
        });
      };
      exports.computeAPICommandBindings = function(gd, method, args) {
        var bindings;
        if (!Array.isArray(args)) args = [];
        switch (method) {
          case "restyle":
            bindings = computeDataBindings(gd, args);
            break;
          case "relayout":
            bindings = computeLayoutBindings(gd, args);
            break;
          case "update":
            bindings = computeDataBindings(gd, [args[0], args[2]]).concat(computeLayoutBindings(gd, [args[1]]));
            break;
          case "animate":
            bindings = computeAnimateBindings(gd, args);
            break;
          default:
            bindings = [];
        }
        return bindings;
      };
      function computeAnimateBindings(gd, args) {
        if (Array.isArray(args[0]) && args[0].length === 1 && ["string", "number"].indexOf(typeof args[0][0]) !== -1) {
          return [{ type: "layout", prop: "_currentFrame", value: args[0][0].toString() }];
        } else {
          return [];
        }
      }
      function computeLayoutBindings(gd, args) {
        var bindings = [];
        var astr = args[0];
        var aobj = {};
        if (typeof astr === "string") {
          aobj[astr] = args[1];
        } else if (Lib.isPlainObject(astr)) {
          aobj = astr;
        } else {
          return bindings;
        }
        crawl(aobj, function(path, attrName, attr) {
          bindings.push({ type: "layout", prop: path, value: attr });
        }, "", 0);
        return bindings;
      }
      function computeDataBindings(gd, args) {
        var traces, astr, val, aobj;
        var bindings = [];
        astr = args[0];
        val = args[1];
        traces = args[2];
        aobj = {};
        if (typeof astr === "string") {
          aobj[astr] = val;
        } else if (Lib.isPlainObject(astr)) {
          aobj = astr;
          if (traces === void 0) {
            traces = val;
          }
        } else {
          return bindings;
        }
        if (traces === void 0) {
          traces = null;
        }
        crawl(aobj, function(path, attrName, _attr) {
          var thisTraces;
          var attr;
          if (Array.isArray(_attr)) {
            attr = _attr.slice();
            var nAttr = Math.min(attr.length, gd.data.length);
            if (traces) {
              nAttr = Math.min(nAttr, traces.length);
            }
            thisTraces = [];
            for (var j = 0; j < nAttr; j++) {
              thisTraces[j] = traces ? traces[j] : j;
            }
          } else {
            attr = _attr;
            thisTraces = traces ? traces.slice() : null;
          }
          if (thisTraces === null) {
            if (Array.isArray(attr)) {
              attr = attr[0];
            }
          } else if (Array.isArray(thisTraces)) {
            if (!Array.isArray(attr)) {
              var tmp = attr;
              attr = [];
              for (var i = 0; i < thisTraces.length; i++) {
                attr[i] = tmp;
              }
            }
            attr.length = Math.min(thisTraces.length, attr.length);
          }
          bindings.push({
            type: "data",
            prop: path,
            traces: thisTraces,
            value: attr
          });
        }, "", 0);
        return bindings;
      }
      function crawl(attrs, callback, path, depth) {
        Object.keys(attrs).forEach(function(attrName) {
          var attr = attrs[attrName];
          if (attrName[0] === "_") return;
          var thisPath = path + (depth > 0 ? "." : "") + attrName;
          if (Lib.isPlainObject(attr)) {
            crawl(attr, callback, thisPath, depth + 1);
          } else {
            callback(thisPath, attrName, attr);
          }
        });
      }
    }
  });

  // src/plots/plots.js
  var require_plots = __commonJS({
    "src/plots/plots.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var timeFormatLocale = require_d3_time_format().timeFormatLocale;
      var formatLocale = require_d3_format().formatLocale;
      var isNumeric = require_fast_isnumeric();
      var b64encode = require_base64_arraybuffer_umd();
      var Registry = require_registry();
      var PlotSchema = require_plot_schema();
      var Template = require_plot_template();
      var Lib = require_lib();
      var Color = require_color();
      var BADNUM = require_numerical().BADNUM;
      var axisIDs = require_axis_ids();
      var clearOutline = require_handle_outline().clearOutline;
      var scatterAttrs = require_layout_attributes3();
      var animationAttrs = require_animation_attributes();
      var frameAttrs = require_frame_attributes();
      var getModuleCalcData = require_get_data().getModuleCalcData;
      var relinkPrivateKeys = Lib.relinkPrivateKeys;
      var _ = Lib._;
      var plots = module.exports = {};
      Lib.extendFlat(plots, Registry);
      plots.attributes = require_attributes2();
      plots.attributes.type.values = plots.allTypes;
      plots.fontAttrs = require_font_attributes();
      plots.layoutAttributes = require_layout_attributes2();
      var commandModule = require_command();
      plots.executeAPICommand = commandModule.executeAPICommand;
      plots.computeAPICommandBindings = commandModule.computeAPICommandBindings;
      plots.manageCommandObserver = commandModule.manageCommandObserver;
      plots.hasSimpleAPICommandBindings = commandModule.hasSimpleAPICommandBindings;
      plots.redrawText = function(gd) {
        gd = Lib.getGraphDiv(gd);
        return new Promise(function(resolve) {
          setTimeout(function() {
            if (!gd._fullLayout) return;
            Registry.getComponentMethod("annotations", "draw")(gd);
            Registry.getComponentMethod("legend", "draw")(gd);
            Registry.getComponentMethod("colorbar", "draw")(gd);
            resolve(plots.previousPromises(gd));
          }, 300);
        });
      };
      plots.resize = function(gd) {
        gd = Lib.getGraphDiv(gd);
        var resolveLastResize;
        var p = new Promise(function(resolve, reject) {
          if (!gd || Lib.isHidden(gd)) {
            reject(new Error("Resize must be passed a displayed plot div element."));
          }
          if (gd._redrawTimer) clearTimeout(gd._redrawTimer);
          if (gd._resolveResize) resolveLastResize = gd._resolveResize;
          gd._resolveResize = resolve;
          gd._redrawTimer = setTimeout(function() {
            if (!gd.layout || gd.layout.width && gd.layout.height || Lib.isHidden(gd)) {
              resolve(gd);
              return;
            }
            delete gd.layout.width;
            delete gd.layout.height;
            var oldchanged = gd.changed;
            gd.autoplay = true;
            Registry.call("relayout", gd, { autosize: true }).then(function() {
              gd.changed = oldchanged;
              if (gd._resolveResize === resolve) {
                delete gd._resolveResize;
                resolve(gd);
              }
            });
          }, 100);
        });
        if (resolveLastResize) resolveLastResize(p);
        return p;
      };
      plots.previousPromises = function(gd) {
        if ((gd._promises || []).length) {
          return Promise.all(gd._promises).then(function() {
            gd._promises = [];
          });
        }
      };
      plots.addLinks = function(gd) {
        if (!gd._context.showLink && !gd._context.showSources) return;
        var fullLayout = gd._fullLayout;
        var linkContainer = Lib.ensureSingle(fullLayout._paper, "text", "js-plot-link-container", function(s) {
          s.style({
            "font-family": '"Open Sans", Arial, sans-serif',
            "font-size": "12px",
            fill: Color.defaultLine,
            "pointer-events": "all"
          }).each(function() {
            var links = d3.select(this);
            links.append("tspan").classed("js-link-to-tool", true);
            links.append("tspan").classed("js-link-spacer", true);
            links.append("tspan").classed("js-sourcelinks", true);
          });
        });
        var text = linkContainer.node();
        var attrs = { y: fullLayout._paper.attr("height") - 9 };
        if (document.body.contains(text) && text.getComputedTextLength() >= fullLayout.width - 20) {
          attrs["text-anchor"] = "start";
          attrs.x = 5;
        } else {
          attrs["text-anchor"] = "end";
          attrs.x = fullLayout._paper.attr("width") - 7;
        }
        linkContainer.attr(attrs);
        var toolspan = linkContainer.select(".js-link-to-tool");
        var spacespan = linkContainer.select(".js-link-spacer");
        var sourcespan = linkContainer.select(".js-sourcelinks");
        if (gd._context.showSources) gd._context.showSources(gd);
        if (gd._context.showLink) positionPlayWithData(gd, toolspan);
        spacespan.text(toolspan.text() && sourcespan.text() ? " - " : "");
      };
      function positionPlayWithData(gd, container) {
        container.text("");
        var link = container.append("a").attr({
          "xlink:xlink:href": "#",
          class: "link--impt link--embedview",
          "font-weight": "bold"
        }).text(gd._context.linkText + " " + String.fromCharCode(187));
        if (gd._context.sendData) {
          link.on("click", function() {
            plots.sendDataToCloud(gd);
          });
        } else {
          var path = window.location.pathname.split("/");
          var query = window.location.search;
          link.attr({
            "xlink:xlink:show": "new",
            "xlink:xlink:href": "/" + path[2].split(".")[0] + "/" + path[1] + query
          });
        }
      }
      plots.sendDataToCloud = function(gd) {
        var baseUrl = (window.PLOTLYENV || {}).BASE_URL || gd._context.plotlyServerURL;
        if (!baseUrl) return;
        gd.emit("plotly_beforeexport");
        var hiddenformDiv = d3.select(gd).append("div").attr("id", "hiddenform").style("display", "none");
        var hiddenform = hiddenformDiv.append("form").attr({
          action: baseUrl + "/external",
          method: "post",
          target: "_blank"
        });
        var hiddenformInput = hiddenform.append("input").attr({
          type: "text",
          name: "data"
        });
        hiddenformInput.node().value = plots.graphJson(gd, false, "keepdata");
        hiddenform.node().submit();
        hiddenformDiv.remove();
        gd.emit("plotly_afterexport");
        return false;
      };
      var d3FormatKeys = [
        "days",
        "shortDays",
        "months",
        "shortMonths",
        "periods",
        "dateTime",
        "date",
        "time",
        "decimal",
        "thousands",
        "grouping",
        "currency"
      ];
      var extraFormatKeys = [
        "year",
        "month",
        "dayMonth",
        "dayMonthYear"
      ];
      plots.supplyDefaults = function(gd, opts) {
        var skipUpdateCalc = opts && opts.skipUpdateCalc;
        var oldFullLayout = gd._fullLayout || {};
        if (oldFullLayout._skipDefaults) {
          delete oldFullLayout._skipDefaults;
          return;
        }
        var newFullLayout = gd._fullLayout = {};
        var newLayout = gd.layout || {};
        var oldFullData = gd._fullData || [];
        var newFullData = gd._fullData = [];
        var newData = gd.data || [];
        var oldCalcdata = gd.calcdata || [];
        var context = gd._context || {};
        var i;
        if (!gd._transitionData) plots.createTransitionData(gd);
        newFullLayout._dfltTitle = {
          plot: _(gd, "Click to enter Plot title"),
          subtitle: _(gd, "Click to enter Plot subtitle"),
          x: _(gd, "Click to enter X axis title"),
          y: _(gd, "Click to enter Y axis title"),
          colorbar: _(gd, "Click to enter Colorscale title"),
          annotation: _(gd, "new text")
        };
        newFullLayout._traceWord = _(gd, "trace");
        var formatObj = getFormatObj(gd, d3FormatKeys);
        newFullLayout._mapboxAccessToken = context.mapboxAccessToken;
        if (oldFullLayout._initialAutoSizeIsDone) {
          var oldWidth = oldFullLayout.width;
          var oldHeight = oldFullLayout.height;
          plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);
          if (!newLayout.width) newFullLayout.width = oldWidth;
          if (!newLayout.height) newFullLayout.height = oldHeight;
          plots.sanitizeMargins(newFullLayout);
        } else {
          plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);
          var missingWidthOrHeight = !newLayout.width || !newLayout.height;
          var autosize = newFullLayout.autosize;
          var autosizable = context.autosizable;
          var initialAutoSize = missingWidthOrHeight && (autosize || autosizable);
          if (initialAutoSize) plots.plotAutoSize(gd, newLayout, newFullLayout);
          else if (missingWidthOrHeight) plots.sanitizeMargins(newFullLayout);
          if (!autosize && missingWidthOrHeight) {
            newLayout.width = newFullLayout.width;
            newLayout.height = newFullLayout.height;
          }
        }
        newFullLayout._d3locale = getFormatter(formatObj, newFullLayout.separators);
        newFullLayout._extraFormat = getFormatObj(gd, extraFormatKeys);
        newFullLayout._initialAutoSizeIsDone = true;
        newFullLayout._dataLength = newData.length;
        newFullLayout._modules = [];
        newFullLayout._visibleModules = [];
        newFullLayout._basePlotModules = [];
        var subplots = newFullLayout._subplots = emptySubplotLists();
        var splomAxes = newFullLayout._splomAxes = { x: {}, y: {} };
        var splomSubplots = newFullLayout._splomSubplots = {};
        newFullLayout._splomGridDflt = {};
        newFullLayout._scatterStackOpts = {};
        newFullLayout._firstScatter = {};
        newFullLayout._alignmentOpts = {};
        newFullLayout._colorAxes = {};
        newFullLayout._requestRangeslider = {};
        newFullLayout._traceUids = getTraceUids(oldFullData, newData);
        plots.supplyDataDefaults(newData, newFullData, newLayout, newFullLayout);
        var splomXa = Object.keys(splomAxes.x);
        var splomYa = Object.keys(splomAxes.y);
        if (splomXa.length > 1 && splomYa.length > 1) {
          Registry.getComponentMethod("grid", "sizeDefaults")(newLayout, newFullLayout);
          for (i = 0; i < splomXa.length; i++) {
            Lib.pushUnique(subplots.xaxis, splomXa[i]);
          }
          for (i = 0; i < splomYa.length; i++) {
            Lib.pushUnique(subplots.yaxis, splomYa[i]);
          }
          for (var k in splomSubplots) {
            Lib.pushUnique(subplots.cartesian, k);
          }
        }
        newFullLayout._has = plots._hasPlotType.bind(newFullLayout);
        if (oldFullData.length === newFullData.length) {
          for (i = 0; i < newFullData.length; i++) {
            relinkPrivateKeys(newFullData[i], oldFullData[i]);
          }
        }
        plots.supplyLayoutModuleDefaults(newLayout, newFullLayout, newFullData, gd._transitionData);
        var _modules = newFullLayout._visibleModules;
        var crossTraceDefaultsFuncs = [];
        for (i = 0; i < _modules.length; i++) {
          var funci = _modules[i].crossTraceDefaults;
          if (funci) Lib.pushUnique(crossTraceDefaultsFuncs, funci);
        }
        for (i = 0; i < crossTraceDefaultsFuncs.length; i++) {
          crossTraceDefaultsFuncs[i](newFullData, newFullLayout);
        }
        newFullLayout._hasOnlyLargeSploms = newFullLayout._basePlotModules.length === 1 && newFullLayout._basePlotModules[0].name === "splom" && splomXa.length > 15 && splomYa.length > 15 && newFullLayout.shapes.length === 0 && newFullLayout.images.length === 0;
        plots.linkSubplots(newFullData, newFullLayout, oldFullData, oldFullLayout);
        plots.cleanPlot(newFullData, newFullLayout, oldFullData, oldFullLayout);
        var hadCartesian = !!(oldFullLayout._has && oldFullLayout._has("cartesian"));
        var hasCartesian = !!(newFullLayout._has && newFullLayout._has("cartesian"));
        var hadBgLayer = hadCartesian;
        var hasBgLayer = hasCartesian;
        if (hadBgLayer && !hasBgLayer) {
          oldFullLayout._bgLayer.remove();
        } else if (hasBgLayer && !hadBgLayer) {
          newFullLayout._shouldCreateBgLayer = true;
        }
        if (oldFullLayout._zoomlayer && !gd._dragging) {
          clearOutline({
            // mock old gd
            _fullLayout: oldFullLayout
          });
        }
        fillMetaTextHelpers(newFullData, newFullLayout);
        relinkPrivateKeys(newFullLayout, oldFullLayout);
        Registry.getComponentMethod("colorscale", "crossTraceDefaults")(newFullData, newFullLayout);
        if (!newFullLayout._preGUI) newFullLayout._preGUI = {};
        if (!newFullLayout._tracePreGUI) newFullLayout._tracePreGUI = {};
        var tracePreGUI = newFullLayout._tracePreGUI;
        var uids = {};
        var uid;
        for (uid in tracePreGUI) uids[uid] = "old";
        for (i = 0; i < newFullData.length; i++) {
          uid = newFullData[i]._fullInput.uid;
          if (!uids[uid]) tracePreGUI[uid] = {};
          uids[uid] = "new";
        }
        for (uid in uids) {
          if (uids[uid] === "old") delete tracePreGUI[uid];
        }
        initMargins(newFullLayout);
        Registry.getComponentMethod("rangeslider", "makeData")(newFullLayout);
        if (!skipUpdateCalc && oldCalcdata.length === newFullData.length) {
          plots.supplyDefaultsUpdateCalc(oldCalcdata, newFullData);
        }
      };
      plots.supplyDefaultsUpdateCalc = function(oldCalcdata, newFullData) {
        for (var i = 0; i < newFullData.length; i++) {
          var newTrace = newFullData[i];
          var cd0 = (oldCalcdata[i] || [])[0];
          if (cd0 && cd0.trace) {
            var oldTrace = cd0.trace;
            if (oldTrace._hasCalcTransform) {
              var arrayAttrs = oldTrace._arrayAttrs;
              var j, astr, oldArrayVal;
              for (j = 0; j < arrayAttrs.length; j++) {
                astr = arrayAttrs[j];
                oldArrayVal = Lib.nestedProperty(oldTrace, astr).get().slice();
                Lib.nestedProperty(newTrace, astr).set(oldArrayVal);
              }
            }
            cd0.trace = newTrace;
          }
        }
      };
      function getTraceUids(oldFullData, newData) {
        var len = newData.length;
        var oldFullInput = [];
        var i, prevFullInput;
        for (i = 0; i < oldFullData.length; i++) {
          var thisFullInput = oldFullData[i]._fullInput;
          if (thisFullInput !== prevFullInput) oldFullInput.push(thisFullInput);
          prevFullInput = thisFullInput;
        }
        var oldLen = oldFullInput.length;
        var out = new Array(len);
        var seenUids = {};
        function setUid(uid, i2) {
          out[i2] = uid;
          seenUids[uid] = 1;
        }
        function tryUid(uid, i2) {
          if (uid && typeof uid === "string" && !seenUids[uid]) {
            setUid(uid, i2);
            return true;
          }
        }
        for (i = 0; i < len; i++) {
          var newUid = newData[i].uid;
          if (typeof newUid === "number") newUid = String(newUid);
          if (tryUid(newUid, i)) continue;
          if (i < oldLen && tryUid(oldFullInput[i].uid, i)) continue;
          setUid(Lib.randstr(seenUids), i);
        }
        return out;
      }
      function emptySubplotLists() {
        var collectableSubplotTypes = Registry.collectableSubplotTypes;
        var out = {};
        var i, j;
        if (!collectableSubplotTypes) {
          collectableSubplotTypes = [];
          var subplotsRegistry = Registry.subplotsRegistry;
          for (var subplotType in subplotsRegistry) {
            var subplotModule = subplotsRegistry[subplotType];
            var subplotAttr = subplotModule.attr;
            if (subplotAttr) {
              collectableSubplotTypes.push(subplotType);
              if (Array.isArray(subplotAttr)) {
                for (j = 0; j < subplotAttr.length; j++) {
                  Lib.pushUnique(collectableSubplotTypes, subplotAttr[j]);
                }
              }
            }
          }
        }
        for (i = 0; i < collectableSubplotTypes.length; i++) {
          out[collectableSubplotTypes[i]] = [];
        }
        return out;
      }
      function getFormatObj(gd, formatKeys) {
        var locale = gd._context.locale;
        if (!locale) locale = "en-US";
        var formatDone = false;
        var formatObj = {};
        function includeFormat(newFormat) {
          var formatFinished = true;
          for (var i2 = 0; i2 < formatKeys.length; i2++) {
            var formatKey = formatKeys[i2];
            if (!formatObj[formatKey]) {
              if (newFormat[formatKey]) {
                formatObj[formatKey] = newFormat[formatKey];
              } else formatFinished = false;
            }
          }
          if (formatFinished) formatDone = true;
        }
        for (var i = 0; i < 2; i++) {
          var locales = gd._context.locales;
          for (var j = 0; j < 2; j++) {
            var formatj = (locales[locale] || {}).format;
            if (formatj) {
              includeFormat(formatj);
              if (formatDone) break;
            }
            locales = Registry.localeRegistry;
          }
          var baseLocale = locale.split("-")[0];
          if (formatDone || baseLocale === locale) break;
          locale = baseLocale;
        }
        if (!formatDone) includeFormat(Registry.localeRegistry.en.format);
        return formatObj;
      }
      function getFormatter(formatObj, separators) {
        formatObj.decimal = separators.charAt(0);
        formatObj.thousands = separators.charAt(1);
        return {
          numberFormat: function(formatStr) {
            try {
              formatStr = formatLocale(formatObj).format(
                Lib.adjustFormat(formatStr)
              );
            } catch (e) {
              Lib.warnBadFormat(formatStr);
              return Lib.noFormat;
            }
            return formatStr;
          },
          timeFormat: timeFormatLocale(formatObj).utcFormat
        };
      }
      function fillMetaTextHelpers(newFullData, newFullLayout) {
        var _meta;
        var meta4data = [];
        if (newFullLayout.meta) {
          _meta = newFullLayout._meta = {
            meta: newFullLayout.meta,
            layout: { meta: newFullLayout.meta }
          };
        }
        for (var i = 0; i < newFullData.length; i++) {
          var trace = newFullData[i];
          if (trace.meta) {
            meta4data[trace.index] = trace._meta = { meta: trace.meta };
          } else if (newFullLayout.meta) {
            trace._meta = { meta: newFullLayout.meta };
          }
          if (newFullLayout.meta) {
            trace._meta.layout = { meta: newFullLayout.meta };
          }
        }
        if (meta4data.length) {
          if (!_meta) {
            _meta = newFullLayout._meta = {};
          }
          _meta.data = meta4data;
        }
      }
      plots.createTransitionData = function(gd) {
        if (!gd._transitionData) {
          gd._transitionData = {};
        }
        if (!gd._transitionData._frames) {
          gd._transitionData._frames = [];
        }
        if (!gd._transitionData._frameHash) {
          gd._transitionData._frameHash = {};
        }
        if (!gd._transitionData._counter) {
          gd._transitionData._counter = 0;
        }
        if (!gd._transitionData._interruptCallbacks) {
          gd._transitionData._interruptCallbacks = [];
        }
      };
      plots._hasPlotType = function(category) {
        var i;
        var basePlotModules = this._basePlotModules || [];
        for (i = 0; i < basePlotModules.length; i++) {
          if (basePlotModules[i].name === category) return true;
        }
        var modules = this._modules || [];
        for (i = 0; i < modules.length; i++) {
          var name = modules[i].name;
          if (name === category) return true;
          var _module = Registry.modules[name];
          if (_module && _module.categories[category]) return true;
        }
        return false;
      };
      plots.cleanPlot = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {
        var i, j;
        var basePlotModules = oldFullLayout._basePlotModules || [];
        for (i = 0; i < basePlotModules.length; i++) {
          var _module = basePlotModules[i];
          if (_module.clean) {
            _module.clean(newFullData, newFullLayout, oldFullData, oldFullLayout);
          }
        }
        var hadGl = oldFullLayout._has && oldFullLayout._has("gl");
        var hasGl = newFullLayout._has && newFullLayout._has("gl");
        if (hadGl && !hasGl) {
          if (oldFullLayout._glcontainer !== void 0) {
            oldFullLayout._glcontainer.selectAll(".gl-canvas").remove();
            oldFullLayout._glcontainer.selectAll(".no-webgl").remove();
            oldFullLayout._glcanvas = null;
          }
        }
        var hasInfoLayer = !!oldFullLayout._infolayer;
        oldLoop:
          for (i = 0; i < oldFullData.length; i++) {
            var oldTrace = oldFullData[i];
            var oldUid = oldTrace.uid;
            for (j = 0; j < newFullData.length; j++) {
              var newTrace = newFullData[j];
              if (oldUid === newTrace.uid) continue oldLoop;
            }
            if (hasInfoLayer) {
              oldFullLayout._infolayer.select(".cb" + oldUid).remove();
            }
          }
      };
      plots.linkSubplots = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {
        var i, j;
        var oldSubplots = oldFullLayout._plots || {};
        var newSubplots = newFullLayout._plots = {};
        var newSubplotList = newFullLayout._subplots;
        var mockGd = {
          _fullData: newFullData,
          _fullLayout: newFullLayout
        };
        var ids = newSubplotList.cartesian || [];
        for (i = 0; i < ids.length; i++) {
          var id = ids[i];
          var oldSubplot = oldSubplots[id];
          var xaxis = axisIDs.getFromId(mockGd, id, "x");
          var yaxis = axisIDs.getFromId(mockGd, id, "y");
          var plotinfo;
          if (oldSubplot) {
            plotinfo = newSubplots[id] = oldSubplot;
          } else {
            plotinfo = newSubplots[id] = {};
            plotinfo.id = id;
          }
          xaxis._counterAxes.push(yaxis._id);
          yaxis._counterAxes.push(xaxis._id);
          xaxis._subplotsWith.push(id);
          yaxis._subplotsWith.push(id);
          plotinfo.xaxis = xaxis;
          plotinfo.yaxis = yaxis;
          plotinfo._hasClipOnAxisFalse = false;
          for (j = 0; j < newFullData.length; j++) {
            var trace = newFullData[j];
            if (trace.xaxis === plotinfo.xaxis._id && trace.yaxis === plotinfo.yaxis._id && trace.cliponaxis === false) {
              plotinfo._hasClipOnAxisFalse = true;
              break;
            }
          }
        }
        var axList = axisIDs.list(mockGd, null, true);
        var ax;
        for (i = 0; i < axList.length; i++) {
          ax = axList[i];
          var mainAx = null;
          if (ax.overlaying) {
            mainAx = axisIDs.getFromId(mockGd, ax.overlaying);
            if (mainAx && mainAx.overlaying) {
              ax.overlaying = false;
              mainAx = null;
            }
          }
          ax._mainAxis = mainAx || ax;
          if (mainAx) ax.domain = mainAx.domain.slice();
          ax._anchorAxis = ax.anchor === "free" ? null : axisIDs.getFromId(mockGd, ax.anchor);
        }
        for (i = 0; i < axList.length; i++) {
          ax = axList[i];
          ax._counterAxes.sort(axisIDs.idSort);
          ax._subplotsWith.sort(Lib.subplotSort);
          ax._mainSubplot = findMainSubplot(ax, newFullLayout);
          if (ax._counterAxes.length && (ax.spikemode && ax.spikemode.indexOf("across") !== -1 || ax.automargin && ax.mirror && ax.anchor !== "free" || Registry.getComponentMethod("rangeslider", "isVisible")(ax))) {
            var min = 1;
            var max = 0;
            for (j = 0; j < ax._counterAxes.length; j++) {
              var ax2 = axisIDs.getFromId(mockGd, ax._counterAxes[j]);
              min = Math.min(min, ax2.domain[0]);
              max = Math.max(max, ax2.domain[1]);
            }
            if (min < max) {
              ax._counterDomainMin = min;
              ax._counterDomainMax = max;
            }
          }
        }
      };
      function findMainSubplot(ax, fullLayout) {
        var mockGd = { _fullLayout: fullLayout };
        var isX = ax._id.charAt(0) === "x";
        var anchorAx = ax._mainAxis._anchorAxis;
        var mainSubplotID = "";
        var nextBestMainSubplotID = "";
        var anchorID = "";
        if (anchorAx) {
          anchorID = anchorAx._mainAxis._id;
          mainSubplotID = isX ? ax._id + anchorID : anchorID + ax._id;
        }
        if (!mainSubplotID || !fullLayout._plots[mainSubplotID]) {
          mainSubplotID = "";
          var counterIDs = ax._counterAxes;
          for (var j = 0; j < counterIDs.length; j++) {
            var counterPart = counterIDs[j];
            var id = isX ? ax._id + counterPart : counterPart + ax._id;
            if (!nextBestMainSubplotID) nextBestMainSubplotID = id;
            var counterAx = axisIDs.getFromId(mockGd, counterPart);
            if (anchorID && counterAx.overlaying === anchorID) {
              mainSubplotID = id;
              break;
            }
          }
        }
        return mainSubplotID || nextBestMainSubplotID;
      }
      plots.clearExpandedTraceDefaultColors = function(trace) {
        var colorAttrs, path, i;
        function locateColorAttrs(attr, attrName, attrs, level) {
          path[level] = attrName;
          path.length = level + 1;
          if (attr.valType === "color" && attr.dflt === void 0) {
            colorAttrs.push(path.join("."));
          }
        }
        path = [];
        colorAttrs = trace._module._colorAttrs;
        if (!colorAttrs) {
          trace._module._colorAttrs = colorAttrs = [];
          PlotSchema.crawl(
            trace._module.attributes,
            locateColorAttrs
          );
        }
        for (i = 0; i < colorAttrs.length; i++) {
          var origprop = Lib.nestedProperty(trace, "_input." + colorAttrs[i]);
          if (!origprop.get()) {
            Lib.nestedProperty(trace, colorAttrs[i]).set(null);
          }
        }
      };
      plots.supplyDataDefaults = function(dataIn, dataOut, layout, fullLayout) {
        var modules = fullLayout._modules;
        var visibleModules = fullLayout._visibleModules;
        var basePlotModules = fullLayout._basePlotModules;
        var cnt = 0;
        var colorCnt = 0;
        var i, fullTrace, trace;
        fullLayout._transformModules = [];
        function pushModule(fullTrace2) {
          dataOut.push(fullTrace2);
          var _module = fullTrace2._module;
          if (!_module) return;
          Lib.pushUnique(modules, _module);
          if (fullTrace2.visible === true) Lib.pushUnique(visibleModules, _module);
          Lib.pushUnique(basePlotModules, fullTrace2._module.basePlotModule);
          cnt++;
          if (fullTrace2._input.visible !== false) colorCnt++;
        }
        var carpetIndex = {};
        var carpetDependents = [];
        var dataTemplate = (layout.template || {}).data || {};
        var templater = Template.traceTemplater(dataTemplate);
        for (i = 0; i < dataIn.length; i++) {
          trace = dataIn[i];
          fullTrace = templater.newTrace(trace);
          fullTrace.uid = fullLayout._traceUids[i];
          plots.supplyTraceDefaults(trace, fullTrace, colorCnt, fullLayout, i);
          fullTrace.index = i;
          fullTrace._input = trace;
          fullTrace._fullInput = fullTrace;
          pushModule(fullTrace);
          if (Registry.traceIs(fullTrace, "carpetAxis")) {
            carpetIndex[fullTrace.carpet] = fullTrace;
          }
          if (Registry.traceIs(fullTrace, "carpetDependent")) {
            carpetDependents.push(i);
          }
        }
        for (i = 0; i < carpetDependents.length; i++) {
          fullTrace = dataOut[carpetDependents[i]];
          if (!fullTrace.visible) continue;
          var carpetAxis = carpetIndex[fullTrace.carpet];
          fullTrace._carpet = carpetAxis;
          if (!carpetAxis || !carpetAxis.visible) {
            fullTrace.visible = false;
            continue;
          }
          fullTrace.xaxis = carpetAxis.xaxis;
          fullTrace.yaxis = carpetAxis.yaxis;
        }
      };
      plots.supplyAnimationDefaults = function(opts) {
        opts = opts || {};
        var i;
        var optsOut = {};
        function coerce(attr, dflt) {
          return Lib.coerce(opts || {}, optsOut, animationAttrs, attr, dflt);
        }
        coerce("mode");
        coerce("direction");
        coerce("fromcurrent");
        if (Array.isArray(opts.frame)) {
          optsOut.frame = [];
          for (i = 0; i < opts.frame.length; i++) {
            optsOut.frame[i] = plots.supplyAnimationFrameDefaults(opts.frame[i] || {});
          }
        } else {
          optsOut.frame = plots.supplyAnimationFrameDefaults(opts.frame || {});
        }
        if (Array.isArray(opts.transition)) {
          optsOut.transition = [];
          for (i = 0; i < opts.transition.length; i++) {
            optsOut.transition[i] = plots.supplyAnimationTransitionDefaults(opts.transition[i] || {});
          }
        } else {
          optsOut.transition = plots.supplyAnimationTransitionDefaults(opts.transition || {});
        }
        return optsOut;
      };
      plots.supplyAnimationFrameDefaults = function(opts) {
        var optsOut = {};
        function coerce(attr, dflt) {
          return Lib.coerce(opts || {}, optsOut, animationAttrs.frame, attr, dflt);
        }
        coerce("duration");
        coerce("redraw");
        return optsOut;
      };
      plots.supplyAnimationTransitionDefaults = function(opts) {
        var optsOut = {};
        function coerce(attr, dflt) {
          return Lib.coerce(opts || {}, optsOut, animationAttrs.transition, attr, dflt);
        }
        coerce("duration");
        coerce("easing");
        return optsOut;
      };
      plots.supplyFrameDefaults = function(frameIn) {
        var frameOut = {};
        function coerce(attr, dflt) {
          return Lib.coerce(frameIn, frameOut, frameAttrs, attr, dflt);
        }
        coerce("group");
        coerce("name");
        coerce("traces");
        coerce("baseframe");
        coerce("data");
        coerce("layout");
        return frameOut;
      };
      plots.supplyTraceDefaults = function(traceIn, traceOut, colorIndex, layout, traceInIndex) {
        var colorway = layout.colorway || Color.defaults;
        var defaultColor = colorway[colorIndex % colorway.length];
        var i;
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, plots.attributes, attr, dflt);
        }
        var visible = coerce("visible");
        coerce("type");
        coerce("name", layout._traceWord + " " + traceInIndex);
        coerce("uirevision", layout.uirevision);
        var _module = plots.getModule(traceOut);
        traceOut._module = _module;
        if (_module) {
          var basePlotModule = _module.basePlotModule;
          var subplotAttr = basePlotModule.attr;
          var subplotAttrs = basePlotModule.attributes;
          if (subplotAttr && subplotAttrs) {
            var subplots = layout._subplots;
            var subplotId = "";
            if (Array.isArray(subplotAttr)) {
              for (i = 0; i < subplotAttr.length; i++) {
                var attri = subplotAttr[i];
                var vali = Lib.coerce(traceIn, traceOut, subplotAttrs, attri);
                if (subplots[attri]) Lib.pushUnique(subplots[attri], vali);
                subplotId += vali;
              }
            } else {
              subplotId = Lib.coerce(traceIn, traceOut, subplotAttrs, subplotAttr);
            }
            if (subplots[basePlotModule.name]) {
              Lib.pushUnique(subplots[basePlotModule.name], subplotId);
            }
          }
        }
        if (visible) {
          coerce("customdata");
          coerce("ids");
          coerce("meta");
          if (Registry.traceIs(traceOut, "showLegend")) {
            Lib.coerce(
              traceIn,
              traceOut,
              _module.attributes.showlegend ? _module.attributes : plots.attributes,
              "showlegend"
            );
            coerce("legend");
            coerce("legendwidth");
            coerce("legendgroup");
            coerce("legendgrouptitle.text");
            coerce("legendrank");
            traceOut._dfltShowLegend = true;
          } else {
            traceOut._dfltShowLegend = false;
          }
          if (_module) {
            _module.supplyDefaults(traceIn, traceOut, defaultColor, layout);
          }
          if (!Registry.traceIs(traceOut, "noOpacity")) {
            coerce("opacity");
          }
          if (Registry.traceIs(traceOut, "notLegendIsolatable")) {
            traceOut.visible = !!traceOut.visible;
          }
          if (!Registry.traceIs(traceOut, "noHover")) {
            if (!traceOut.hovertemplate) Lib.coerceHoverinfo(traceIn, traceOut, layout);
            if (traceOut.type !== "parcats") {
              Registry.getComponentMethod("fx", "supplyDefaults")(traceIn, traceOut, defaultColor, layout);
            }
          }
          if (_module && _module.selectPoints) {
            var selectedpoints = coerce("selectedpoints");
            if (Lib.isTypedArray(selectedpoints)) {
              traceOut.selectedpoints = Array.from(selectedpoints);
            }
          }
        }
        return traceOut;
      };
      plots.supplyLayoutGlobalDefaults = function(layoutIn, layoutOut, formatObj) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, plots.layoutAttributes, attr, dflt);
        }
        var template = layoutIn.template;
        if (Lib.isPlainObject(template)) {
          layoutOut.template = template;
          layoutOut._template = template.layout;
          layoutOut._dataTemplate = template.data;
        }
        coerce("autotypenumbers");
        var font = Lib.coerceFont(coerce, "font");
        var fontSize = font.size;
        Lib.coerceFont(coerce, "title.font", font, { overrideDflt: {
          size: Math.round(fontSize * 1.4)
        } });
        coerce("title.text", layoutOut._dfltTitle.plot);
        coerce("title.xref");
        var titleYref = coerce("title.yref");
        coerce("title.pad.t");
        coerce("title.pad.r");
        coerce("title.pad.b");
        coerce("title.pad.l");
        var titleAutomargin = coerce("title.automargin");
        coerce("title.x");
        coerce("title.xanchor");
        coerce("title.y");
        coerce("title.yanchor");
        coerce("title.subtitle.text", layoutOut._dfltTitle.subtitle);
        Lib.coerceFont(coerce, "title.subtitle.font", font, {
          overrideDflt: {
            size: Math.round(layoutOut.title.font.size * 0.7)
          }
        });
        if (titleAutomargin) {
          if (titleYref === "paper") {
            if (layoutOut.title.y !== 0) layoutOut.title.y = 1;
            if (layoutOut.title.yanchor === "auto") {
              layoutOut.title.yanchor = layoutOut.title.y === 0 ? "top" : "bottom";
            }
          }
          if (titleYref === "container") {
            if (layoutOut.title.y === "auto") layoutOut.title.y = 1;
            if (layoutOut.title.yanchor === "auto") {
              layoutOut.title.yanchor = layoutOut.title.y < 0.5 ? "bottom" : "top";
            }
          }
        }
        var uniformtextMode = coerce("uniformtext.mode");
        if (uniformtextMode) {
          coerce("uniformtext.minsize");
        }
        coerce("autosize", !(layoutIn.width && layoutIn.height));
        coerce("width");
        coerce("height");
        coerce("minreducedwidth");
        coerce("minreducedheight");
        coerce("margin.l");
        coerce("margin.r");
        coerce("margin.t");
        coerce("margin.b");
        coerce("margin.pad");
        coerce("margin.autoexpand");
        if (layoutIn.width && layoutIn.height) plots.sanitizeMargins(layoutOut);
        Registry.getComponentMethod("grid", "sizeDefaults")(layoutIn, layoutOut);
        coerce("paper_bgcolor");
        coerce("separators", formatObj.decimal + formatObj.thousands);
        coerce("hidesources");
        coerce("colorway");
        coerce("datarevision");
        var uirevision = coerce("uirevision");
        coerce("editrevision", uirevision);
        coerce("selectionrevision", uirevision);
        Registry.getComponentMethod(
          "modebar",
          "supplyLayoutDefaults"
        )(layoutIn, layoutOut);
        Registry.getComponentMethod(
          "shapes",
          "supplyDrawNewShapeDefaults"
        )(layoutIn, layoutOut, coerce);
        Registry.getComponentMethod(
          "selections",
          "supplyDrawNewSelectionDefaults"
        )(layoutIn, layoutOut, coerce);
        coerce("meta");
        if (Lib.isPlainObject(layoutIn.transition)) {
          coerce("transition.duration");
          coerce("transition.easing");
          coerce("transition.ordering");
        }
        Registry.getComponentMethod(
          "calendars",
          "handleDefaults"
        )(layoutIn, layoutOut, "calendar");
        Registry.getComponentMethod(
          "fx",
          "supplyLayoutGlobalDefaults"
        )(layoutIn, layoutOut, coerce);
        Lib.coerce(layoutIn, layoutOut, scatterAttrs, "scattermode");
      };
      function getComputedSize(attr) {
        return typeof attr === "string" && attr.substr(attr.length - 2) === "px" && parseFloat(attr);
      }
      plots.plotAutoSize = function plotAutoSize(gd, layout, fullLayout) {
        var context = gd._context || {};
        var frameMargins = context.frameMargins;
        var newWidth;
        var newHeight;
        var isPlotDiv = Lib.isPlotDiv(gd);
        if (isPlotDiv) gd.emit("plotly_autosize");
        if (context.fillFrame) {
          newWidth = window.innerWidth;
          newHeight = window.innerHeight;
          document.body.style.overflow = "hidden";
        } else {
          var computedStyle = isPlotDiv ? window.getComputedStyle(gd) : {};
          newWidth = getComputedSize(computedStyle.width) || getComputedSize(computedStyle.maxWidth) || fullLayout.width;
          newHeight = getComputedSize(computedStyle.height) || getComputedSize(computedStyle.maxHeight) || fullLayout.height;
          if (isNumeric(frameMargins) && frameMargins > 0) {
            var factor = 1 - 2 * frameMargins;
            newWidth = Math.round(factor * newWidth);
            newHeight = Math.round(factor * newHeight);
          }
        }
        var minWidth = plots.layoutAttributes.width.min;
        var minHeight = plots.layoutAttributes.height.min;
        if (newWidth < minWidth) newWidth = minWidth;
        if (newHeight < minHeight) newHeight = minHeight;
        var widthHasChanged = !layout.width && Math.abs(fullLayout.width - newWidth) > 1;
        var heightHasChanged = !layout.height && Math.abs(fullLayout.height - newHeight) > 1;
        if (heightHasChanged || widthHasChanged) {
          if (widthHasChanged) fullLayout.width = newWidth;
          if (heightHasChanged) fullLayout.height = newHeight;
        }
        if (!gd._initialAutoSize) {
          gd._initialAutoSize = { width: newWidth, height: newHeight };
        }
        plots.sanitizeMargins(fullLayout);
      };
      plots.supplyLayoutModuleDefaults = function(layoutIn, layoutOut, fullData, transitionData) {
        var componentsRegistry = Registry.componentsRegistry;
        var basePlotModules = layoutOut._basePlotModules;
        var component, i, _module;
        var Cartesian = Registry.subplotsRegistry.cartesian;
        for (component in componentsRegistry) {
          _module = componentsRegistry[component];
          if (_module.includeBasePlot) {
            _module.includeBasePlot(layoutIn, layoutOut);
          }
        }
        if (!basePlotModules.length) {
          basePlotModules.push(Cartesian);
        }
        if (layoutOut._has("cartesian")) {
          Registry.getComponentMethod("grid", "contentDefaults")(layoutIn, layoutOut);
          Cartesian.finalizeSubplots(layoutIn, layoutOut);
        }
        for (var subplotType in layoutOut._subplots) {
          layoutOut._subplots[subplotType].sort(Lib.subplotSort);
        }
        for (i = 0; i < basePlotModules.length; i++) {
          _module = basePlotModules[i];
          if (_module.supplyLayoutDefaults) {
            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
          }
        }
        var modules = layoutOut._modules;
        for (i = 0; i < modules.length; i++) {
          _module = modules[i];
          if (_module.supplyLayoutDefaults) {
            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
          }
        }
        var transformModules = layoutOut._transformModules;
        for (i = 0; i < transformModules.length; i++) {
          _module = transformModules[i];
          if (_module.supplyLayoutDefaults) {
            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData, transitionData);
          }
        }
        for (component in componentsRegistry) {
          _module = componentsRegistry[component];
          if (_module.supplyLayoutDefaults) {
            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
          }
        }
      };
      plots.purge = function(gd) {
        var fullLayout = gd._fullLayout || {};
        if (fullLayout._glcontainer !== void 0) {
          fullLayout._glcontainer.selectAll(".gl-canvas").remove();
          fullLayout._glcontainer.remove();
          fullLayout._glcanvas = null;
        }
        if (fullLayout._modeBar) fullLayout._modeBar.destroy();
        if (gd._transitionData) {
          if (gd._transitionData._interruptCallbacks) {
            gd._transitionData._interruptCallbacks.length = 0;
          }
          if (gd._transitionData._animationRaf) {
            window.cancelAnimationFrame(gd._transitionData._animationRaf);
          }
        }
        Lib.clearThrottle();
        Lib.clearResponsive(gd);
        delete gd.data;
        delete gd.layout;
        delete gd._fullData;
        delete gd._fullLayout;
        delete gd.calcdata;
        delete gd.empty;
        delete gd.fid;
        delete gd.undoqueue;
        delete gd.undonum;
        delete gd.autoplay;
        delete gd.changed;
        delete gd._promises;
        delete gd._redrawTimer;
        delete gd._hmlumcount;
        delete gd._hmpixcount;
        delete gd._transitionData;
        delete gd._transitioning;
        delete gd._initialAutoSize;
        delete gd._transitioningWithDuration;
        delete gd._dragging;
        delete gd._dragged;
        delete gd._dragdata;
        delete gd._hoverdata;
        delete gd._snapshotInProgress;
        delete gd._editing;
        delete gd._mouseDownTime;
        delete gd._legendMouseDownTime;
        if (gd.removeAllListeners) gd.removeAllListeners();
      };
      plots.style = function(gd) {
        var _modules = gd._fullLayout._visibleModules;
        var styleModules = [];
        var i;
        for (i = 0; i < _modules.length; i++) {
          var _module = _modules[i];
          if (_module.style) {
            Lib.pushUnique(styleModules, _module.style);
          }
        }
        for (i = 0; i < styleModules.length; i++) {
          styleModules[i](gd);
        }
      };
      plots.sanitizeMargins = function(fullLayout) {
        if (!fullLayout || !fullLayout.margin) return;
        var width = fullLayout.width;
        var height = fullLayout.height;
        var margin = fullLayout.margin;
        var plotWidth = width - (margin.l + margin.r);
        var plotHeight = height - (margin.t + margin.b);
        var correction;
        if (plotWidth < 0) {
          correction = (width - 1) / (margin.l + margin.r);
          margin.l = Math.floor(correction * margin.l);
          margin.r = Math.floor(correction * margin.r);
        }
        if (plotHeight < 0) {
          correction = (height - 1) / (margin.t + margin.b);
          margin.t = Math.floor(correction * margin.t);
          margin.b = Math.floor(correction * margin.b);
        }
      };
      plots.clearAutoMarginIds = function(gd) {
        gd._fullLayout._pushmarginIds = {};
      };
      plots.allowAutoMargin = function(gd, id) {
        gd._fullLayout._pushmarginIds[id] = 1;
      };
      function initMargins(fullLayout) {
        var margin = fullLayout.margin;
        if (!fullLayout._size) {
          var gs = fullLayout._size = {
            l: Math.round(margin.l),
            r: Math.round(margin.r),
            t: Math.round(margin.t),
            b: Math.round(margin.b),
            p: Math.round(margin.pad)
          };
          gs.w = Math.round(fullLayout.width) - gs.l - gs.r;
          gs.h = Math.round(fullLayout.height) - gs.t - gs.b;
        }
        if (!fullLayout._pushmargin) fullLayout._pushmargin = {};
        if (!fullLayout._pushmarginIds) fullLayout._pushmarginIds = {};
        if (!fullLayout._reservedMargin) fullLayout._reservedMargin = {};
      }
      var MIN_SPECIFIED_WIDTH = 2;
      var MIN_SPECIFIED_HEIGHT = 2;
      plots.autoMargin = function(gd, id, o) {
        var fullLayout = gd._fullLayout;
        var width = fullLayout.width;
        var height = fullLayout.height;
        var margin = fullLayout.margin;
        var minreducedwidth = fullLayout.minreducedwidth;
        var minreducedheight = fullLayout.minreducedheight;
        var minFinalWidth = Lib.constrain(
          width - margin.l - margin.r,
          MIN_SPECIFIED_WIDTH,
          minreducedwidth
        );
        var minFinalHeight = Lib.constrain(
          height - margin.t - margin.b,
          MIN_SPECIFIED_HEIGHT,
          minreducedheight
        );
        var maxSpaceW = Math.max(0, width - minFinalWidth);
        var maxSpaceH = Math.max(0, height - minFinalHeight);
        var pushMargin = fullLayout._pushmargin;
        var pushMarginIds = fullLayout._pushmarginIds;
        if (margin.autoexpand !== false) {
          if (!o) {
            delete pushMargin[id];
            delete pushMarginIds[id];
          } else {
            var pad = o.pad;
            if (pad === void 0) {
              pad = Math.min(12, margin.l, margin.r, margin.t, margin.b);
            }
            if (maxSpaceW) {
              var rW = (o.l + o.r) / maxSpaceW;
              if (rW > 1) {
                o.l /= rW;
                o.r /= rW;
              }
            }
            if (maxSpaceH) {
              var rH = (o.t + o.b) / maxSpaceH;
              if (rH > 1) {
                o.t /= rH;
                o.b /= rH;
              }
            }
            var xl = o.xl !== void 0 ? o.xl : o.x;
            var xr = o.xr !== void 0 ? o.xr : o.x;
            var yt = o.yt !== void 0 ? o.yt : o.y;
            var yb = o.yb !== void 0 ? o.yb : o.y;
            pushMargin[id] = {
              l: { val: xl, size: o.l + pad },
              r: { val: xr, size: o.r + pad },
              b: { val: yb, size: o.b + pad },
              t: { val: yt, size: o.t + pad }
            };
            pushMarginIds[id] = 1;
          }
          if (!fullLayout._replotting) {
            return plots.doAutoMargin(gd);
          }
        }
      };
      function needsRedrawForShift(gd) {
        if ("_redrawFromAutoMarginCount" in gd._fullLayout) {
          return false;
        }
        var axList = axisIDs.list(gd, "", true);
        for (var ax in axList) {
          if (axList[ax].autoshift || axList[ax].shift) return true;
        }
        return false;
      }
      plots.doAutoMargin = function(gd) {
        var fullLayout = gd._fullLayout;
        var width = fullLayout.width;
        var height = fullLayout.height;
        if (!fullLayout._size) fullLayout._size = {};
        initMargins(fullLayout);
        var gs = fullLayout._size;
        var margin = fullLayout.margin;
        var reservedMargins = { t: 0, b: 0, l: 0, r: 0 };
        var oldMargins = Lib.extendFlat({}, gs);
        var ml = margin.l;
        var mr = margin.r;
        var mt = margin.t;
        var mb = margin.b;
        var pushMargin = fullLayout._pushmargin;
        var pushMarginIds = fullLayout._pushmarginIds;
        var minreducedwidth = fullLayout.minreducedwidth;
        var minreducedheight = fullLayout.minreducedheight;
        if (margin.autoexpand !== false) {
          for (var k in pushMargin) {
            if (!pushMarginIds[k]) delete pushMargin[k];
          }
          var margins = gd._fullLayout._reservedMargin;
          for (var key in margins) {
            for (var side in margins[key]) {
              var val = margins[key][side];
              reservedMargins[side] = Math.max(reservedMargins[side], val);
            }
          }
          pushMargin.base = {
            l: { val: 0, size: ml },
            r: { val: 1, size: mr },
            t: { val: 1, size: mt },
            b: { val: 0, size: mb }
          };
          for (var s in reservedMargins) {
            var autoMarginPush = 0;
            for (var m in pushMargin) {
              if (m !== "base") {
                if (isNumeric(pushMargin[m][s].size)) {
                  autoMarginPush = pushMargin[m][s].size > autoMarginPush ? pushMargin[m][s].size : autoMarginPush;
                }
              }
            }
            var extraMargin = Math.max(0, margin[s] - autoMarginPush);
            reservedMargins[s] = Math.max(0, reservedMargins[s] - extraMargin);
          }
          for (var k1 in pushMargin) {
            var pushleft = pushMargin[k1].l || {};
            var pushbottom = pushMargin[k1].b || {};
            var fl = pushleft.val;
            var pl = pushleft.size;
            var fb = pushbottom.val;
            var pb = pushbottom.size;
            var availableWidth = width - reservedMargins.r - reservedMargins.l;
            var availableHeight = height - reservedMargins.t - reservedMargins.b;
            for (var k2 in pushMargin) {
              if (isNumeric(pl) && pushMargin[k2].r) {
                var fr = pushMargin[k2].r.val;
                var pr = pushMargin[k2].r.size;
                if (fr > fl) {
                  var newL = (pl * fr + (pr - availableWidth) * fl) / (fr - fl);
                  var newR = (pr * (1 - fl) + (pl - availableWidth) * (1 - fr)) / (fr - fl);
                  if (newL + newR > ml + mr) {
                    ml = newL;
                    mr = newR;
                  }
                }
              }
              if (isNumeric(pb) && pushMargin[k2].t) {
                var ft = pushMargin[k2].t.val;
                var pt = pushMargin[k2].t.size;
                if (ft > fb) {
                  var newB = (pb * ft + (pt - availableHeight) * fb) / (ft - fb);
                  var newT = (pt * (1 - fb) + (pb - availableHeight) * (1 - ft)) / (ft - fb);
                  if (newB + newT > mb + mt) {
                    mb = newB;
                    mt = newT;
                  }
                }
              }
            }
          }
        }
        var minFinalWidth = Lib.constrain(
          width - margin.l - margin.r,
          MIN_SPECIFIED_WIDTH,
          minreducedwidth
        );
        var minFinalHeight = Lib.constrain(
          height - margin.t - margin.b,
          MIN_SPECIFIED_HEIGHT,
          minreducedheight
        );
        var maxSpaceW = Math.max(0, width - minFinalWidth);
        var maxSpaceH = Math.max(0, height - minFinalHeight);
        if (maxSpaceW) {
          var rW = (ml + mr) / maxSpaceW;
          if (rW > 1) {
            ml /= rW;
            mr /= rW;
          }
        }
        if (maxSpaceH) {
          var rH = (mb + mt) / maxSpaceH;
          if (rH > 1) {
            mb /= rH;
            mt /= rH;
          }
        }
        gs.l = Math.round(ml) + reservedMargins.l;
        gs.r = Math.round(mr) + reservedMargins.r;
        gs.t = Math.round(mt) + reservedMargins.t;
        gs.b = Math.round(mb) + reservedMargins.b;
        gs.p = Math.round(margin.pad);
        gs.w = Math.round(width) - gs.l - gs.r;
        gs.h = Math.round(height) - gs.t - gs.b;
        if (!fullLayout._replotting && (plots.didMarginChange(oldMargins, gs) || needsRedrawForShift(gd))) {
          if ("_redrawFromAutoMarginCount" in fullLayout) {
            fullLayout._redrawFromAutoMarginCount++;
          } else {
            fullLayout._redrawFromAutoMarginCount = 1;
          }
          var maxNumberOfRedraws = 3 * (1 + Object.keys(pushMarginIds).length);
          if (fullLayout._redrawFromAutoMarginCount < maxNumberOfRedraws) {
            return Registry.call("_doPlot", gd);
          } else {
            fullLayout._size = oldMargins;
            Lib.warn("Too many auto-margin redraws.");
          }
        }
        refineTicks(gd);
      };
      function refineTicks(gd) {
        var axList = axisIDs.list(gd, "", true);
        [
          "_adjustTickLabelsOverflow",
          "_hideCounterAxisInsideTickLabels"
        ].forEach(function(k) {
          for (var i = 0; i < axList.length; i++) {
            var hideFn = axList[i][k];
            if (hideFn) hideFn();
          }
        });
      }
      var marginKeys = ["l", "r", "t", "b", "p", "w", "h"];
      plots.didMarginChange = function(margin0, margin1) {
        for (var i = 0; i < marginKeys.length; i++) {
          var k = marginKeys[i];
          var m0 = margin0[k];
          var m1 = margin1[k];
          if (!isNumeric(m0) || Math.abs(m1 - m0) > 1) {
            return true;
          }
        }
        return false;
      };
      plots.graphJson = function(gd, dataonly, mode, output, useDefaults, includeConfig) {
        if (useDefaults && dataonly && !gd._fullData || useDefaults && !dataonly && !gd._fullLayout) {
          plots.supplyDefaults(gd);
        }
        var data = useDefaults ? gd._fullData : gd.data;
        var layout = useDefaults ? gd._fullLayout : gd.layout;
        var frames = (gd._transitionData || {})._frames;
        function stripObj(d, keepFunction) {
          if (typeof d === "function") {
            return keepFunction ? "_function_" : null;
          }
          if (Lib.isPlainObject(d)) {
            var o = {};
            var src;
            Object.keys(d).sort().forEach(function(v) {
              if (["_", "["].indexOf(v.charAt(0)) !== -1) return;
              if (typeof d[v] === "function") {
                if (keepFunction) o[v] = "_function";
                return;
              }
              if (mode === "keepdata") {
                if (v.substr(v.length - 3) === "src") {
                  return;
                }
              } else if (mode === "keepstream") {
                src = d[v + "src"];
                if (typeof src === "string" && src.indexOf(":") > 0) {
                  if (!Lib.isPlainObject(d.stream)) {
                    return;
                  }
                }
              } else if (mode !== "keepall") {
                src = d[v + "src"];
                if (typeof src === "string" && src.indexOf(":") > 0) {
                  return;
                }
              }
              o[v] = stripObj(d[v], keepFunction);
            });
            return o;
          }
          var dIsArray = Array.isArray(d);
          var dIsTypedArray = Lib.isTypedArray(d);
          if ((dIsArray || dIsTypedArray) && d.dtype && d.shape) {
            var bdata = d.bdata;
            return stripObj({
              dtype: d.dtype,
              shape: d.shape,
              bdata: (
                // case of ArrayBuffer
                Lib.isArrayBuffer(bdata) ? b64encode.encode(bdata) : (
                  // case of b64 string
                  bdata
                )
              )
            }, keepFunction);
          }
          if (dIsArray) {
            return d.map(function(x) {
              return stripObj(x, keepFunction);
            });
          }
          if (dIsTypedArray) {
            return Lib.simpleMap(d, Lib.identity);
          }
          if (Lib.isJSDate(d)) return Lib.ms2DateTimeLocal(+d);
          return d;
        }
        var obj = {
          data: (data || []).map(function(v) {
            var d = stripObj(v);
            if (dataonly) {
              delete d.fit;
            }
            return d;
          })
        };
        if (!dataonly) {
          obj.layout = stripObj(layout);
          if (useDefaults) {
            var gs = layout._size;
            obj.layout.computed = {
              margin: {
                b: gs.b,
                l: gs.l,
                r: gs.r,
                t: gs.t
              }
            };
          }
        }
        if (frames) obj.frames = stripObj(frames);
        if (includeConfig) obj.config = stripObj(gd._context, true);
        return output === "object" ? obj : JSON.stringify(obj);
      };
      plots.modifyFrames = function(gd, operations) {
        var i, op, frame;
        var _frames = gd._transitionData._frames;
        var _frameHash = gd._transitionData._frameHash;
        for (i = 0; i < operations.length; i++) {
          op = operations[i];
          switch (op.type) {
            // No reason this couldn't exist, but is currently unused/untested:
            /* case 'rename':
                frame = _frames[op.index];
                delete _frameHash[frame.name];
                _frameHash[op.name] = frame;
                frame.name = op.name;
                break;*/
            case "replace":
              frame = op.value;
              var oldName = (_frames[op.index] || {}).name;
              var newName = frame.name;
              _frames[op.index] = _frameHash[newName] = frame;
              if (newName !== oldName) {
                delete _frameHash[oldName];
                _frameHash[newName] = frame;
              }
              break;
            case "insert":
              frame = op.value;
              _frameHash[frame.name] = frame;
              _frames.splice(op.index, 0, frame);
              break;
            case "delete":
              frame = _frames[op.index];
              delete _frameHash[frame.name];
              _frames.splice(op.index, 1);
              break;
          }
        }
        return Promise.resolve();
      };
      plots.computeFrame = function(gd, frameName) {
        var frameLookup = gd._transitionData._frameHash;
        var i, traceIndices, traceIndex, destIndex;
        if (!frameName) {
          throw new Error("computeFrame must be given a string frame name");
        }
        var framePtr = frameLookup[frameName.toString()];
        if (!framePtr) {
          return false;
        }
        var frameStack = [framePtr];
        var frameNameStack = [framePtr.name];
        while (framePtr.baseframe && (framePtr = frameLookup[framePtr.baseframe.toString()])) {
          if (frameNameStack.indexOf(framePtr.name) !== -1) break;
          frameStack.push(framePtr);
          frameNameStack.push(framePtr.name);
        }
        var result = {};
        while (framePtr = frameStack.pop()) {
          if (framePtr.layout) {
            result.layout = plots.extendLayout(result.layout, framePtr.layout);
          }
          if (framePtr.data) {
            if (!result.data) {
              result.data = [];
            }
            traceIndices = framePtr.traces;
            if (!traceIndices) {
              traceIndices = [];
              for (i = 0; i < framePtr.data.length; i++) {
                traceIndices[i] = i;
              }
            }
            if (!result.traces) {
              result.traces = [];
            }
            for (i = 0; i < framePtr.data.length; i++) {
              traceIndex = traceIndices[i];
              if (traceIndex === void 0 || traceIndex === null) {
                continue;
              }
              destIndex = result.traces.indexOf(traceIndex);
              if (destIndex === -1) {
                destIndex = result.data.length;
                result.traces[destIndex] = traceIndex;
              }
              result.data[destIndex] = plots.extendTrace(result.data[destIndex], framePtr.data[i]);
            }
          }
        }
        return result;
      };
      plots.recomputeFrameHash = function(gd) {
        var hash = gd._transitionData._frameHash = {};
        var frames = gd._transitionData._frames;
        for (var i = 0; i < frames.length; i++) {
          var frame = frames[i];
          if (frame && frame.name) {
            hash[frame.name] = frame;
          }
        }
      };
      plots.extendObjectWithContainers = function(dest, src, containerPaths) {
        var containerProp, containerVal, i, j, srcProp, destProp, srcContainer, destContainer;
        var copy = Lib.extendDeepNoArrays({}, src || {});
        var expandedObj = Lib.expandObjectPaths(copy);
        var containerObj = {};
        if (containerPaths && containerPaths.length) {
          for (i = 0; i < containerPaths.length; i++) {
            containerProp = Lib.nestedProperty(expandedObj, containerPaths[i]);
            containerVal = containerProp.get();
            if (containerVal === void 0) {
              Lib.nestedProperty(containerObj, containerPaths[i]).set(null);
            } else {
              containerProp.set(null);
              Lib.nestedProperty(containerObj, containerPaths[i]).set(containerVal);
            }
          }
        }
        dest = Lib.extendDeepNoArrays(dest || {}, expandedObj);
        if (containerPaths && containerPaths.length) {
          for (i = 0; i < containerPaths.length; i++) {
            srcProp = Lib.nestedProperty(containerObj, containerPaths[i]);
            srcContainer = srcProp.get();
            if (!srcContainer) continue;
            destProp = Lib.nestedProperty(dest, containerPaths[i]);
            destContainer = destProp.get();
            if (!Array.isArray(destContainer)) {
              destContainer = [];
              destProp.set(destContainer);
            }
            for (j = 0; j < srcContainer.length; j++) {
              var srcObj = srcContainer[j];
              if (srcObj === null) destContainer[j] = null;
              else {
                destContainer[j] = plots.extendObjectWithContainers(destContainer[j], srcObj);
              }
            }
            destProp.set(destContainer);
          }
        }
        return dest;
      };
      plots.dataArrayContainers = ["transforms", "dimensions"];
      plots.layoutArrayContainers = Registry.layoutArrayContainers;
      plots.extendTrace = function(destTrace, srcTrace) {
        return plots.extendObjectWithContainers(destTrace, srcTrace, plots.dataArrayContainers);
      };
      plots.extendLayout = function(destLayout, srcLayout) {
        return plots.extendObjectWithContainers(destLayout, srcLayout, plots.layoutArrayContainers);
      };
      plots.transition = function(gd, data, layout, traces, frameOpts, transitionOpts) {
        var opts = { redraw: frameOpts.redraw };
        var transitionedTraces = {};
        var axEdits = [];
        opts.prepareFn = function() {
          var dataLength = Array.isArray(data) ? data.length : 0;
          var traceIndices = traces.slice(0, dataLength);
          for (var i = 0; i < traceIndices.length; i++) {
            var traceIdx = traceIndices[i];
            var trace = gd._fullData[traceIdx];
            var _module = trace._module;
            if (!_module) continue;
            if (_module.animatable) {
              var n = _module.basePlotModule.name;
              if (!transitionedTraces[n]) transitionedTraces[n] = [];
              transitionedTraces[n].push(traceIdx);
            }
            gd.data[traceIndices[i]] = plots.extendTrace(gd.data[traceIndices[i]], data[i]);
          }
          var layoutUpdate = Lib.expandObjectPaths(Lib.extendDeepNoArrays({}, layout));
          var axisAttrRe = /^[xy]axis[0-9]*$/;
          for (var attr in layoutUpdate) {
            if (!axisAttrRe.test(attr)) continue;
            delete layoutUpdate[attr].range;
          }
          plots.extendLayout(gd.layout, layoutUpdate);
          delete gd.calcdata;
          plots.supplyDefaults(gd);
          plots.doCalcdata(gd);
          var newLayout = Lib.expandObjectPaths(layout);
          if (newLayout) {
            var subplots = gd._fullLayout._plots;
            for (var k in subplots) {
              var plotinfo = subplots[k];
              var xa = plotinfo.xaxis;
              var ya = plotinfo.yaxis;
              var xr0 = xa.range.slice();
              var yr0 = ya.range.slice();
              var xr1 = null;
              var yr1 = null;
              var editX = null;
              var editY = null;
              if (Array.isArray(newLayout[xa._name + ".range"])) {
                xr1 = newLayout[xa._name + ".range"].slice();
              } else if (Array.isArray((newLayout[xa._name] || {}).range)) {
                xr1 = newLayout[xa._name].range.slice();
              }
              if (Array.isArray(newLayout[ya._name + ".range"])) {
                yr1 = newLayout[ya._name + ".range"].slice();
              } else if (Array.isArray((newLayout[ya._name] || {}).range)) {
                yr1 = newLayout[ya._name].range.slice();
              }
              if (xr0 && xr1 && (xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1]))) {
                editX = { xr0, xr1 };
              }
              if (yr0 && yr1 && (ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1]))) {
                editY = { yr0, yr1 };
              }
              if (editX || editY) {
                axEdits.push(Lib.extendFlat({ plotinfo }, editX, editY));
              }
            }
          }
          return Promise.resolve();
        };
        opts.runFn = function(makeCallback) {
          var traceTransitionOpts;
          var basePlotModules = gd._fullLayout._basePlotModules;
          var hasAxisTransition = axEdits.length;
          var i;
          if (layout) {
            for (i = 0; i < basePlotModules.length; i++) {
              if (basePlotModules[i].transitionAxes) {
                basePlotModules[i].transitionAxes(gd, axEdits, transitionOpts, makeCallback);
              }
            }
          }
          if (hasAxisTransition) {
            traceTransitionOpts = Lib.extendFlat({}, transitionOpts);
            traceTransitionOpts.duration = 0;
            delete transitionedTraces.cartesian;
          } else {
            traceTransitionOpts = transitionOpts;
          }
          for (var n in transitionedTraces) {
            var traceIndices = transitionedTraces[n];
            var _module = gd._fullData[traceIndices[0]]._module;
            _module.basePlotModule.plot(gd, traceIndices, traceTransitionOpts, makeCallback);
          }
        };
        return _transition(gd, transitionOpts, opts);
      };
      plots.transitionFromReact = function(gd, restyleFlags, relayoutFlags, oldFullLayout) {
        var fullLayout = gd._fullLayout;
        var transitionOpts = fullLayout.transition;
        var opts = {};
        var axEdits = [];
        opts.prepareFn = function() {
          var subplots = fullLayout._plots;
          opts.redraw = false;
          if (restyleFlags.anim === "some") opts.redraw = true;
          if (relayoutFlags.anim === "some") opts.redraw = true;
          for (var k in subplots) {
            var plotinfo = subplots[k];
            var xa = plotinfo.xaxis;
            var ya = plotinfo.yaxis;
            var xr0 = oldFullLayout[xa._name].range.slice();
            var yr0 = oldFullLayout[ya._name].range.slice();
            var xr1 = xa.range.slice();
            var yr1 = ya.range.slice();
            xa.setScale();
            ya.setScale();
            var editX = null;
            var editY = null;
            if (xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1])) {
              editX = { xr0, xr1 };
            }
            if (ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1])) {
              editY = { yr0, yr1 };
            }
            if (editX || editY) {
              axEdits.push(Lib.extendFlat({ plotinfo }, editX, editY));
            }
          }
          return Promise.resolve();
        };
        opts.runFn = function(makeCallback) {
          var fullData = gd._fullData;
          var fullLayout2 = gd._fullLayout;
          var basePlotModules = fullLayout2._basePlotModules;
          var axisTransitionOpts;
          var traceTransitionOpts;
          var transitionedTraces;
          var allTraceIndices = [];
          for (var i = 0; i < fullData.length; i++) {
            allTraceIndices.push(i);
          }
          function transitionAxes() {
            if (!gd._fullLayout) return;
            for (var j = 0; j < basePlotModules.length; j++) {
              if (basePlotModules[j].transitionAxes) {
                basePlotModules[j].transitionAxes(gd, axEdits, axisTransitionOpts, makeCallback);
              }
            }
          }
          function transitionTraces() {
            if (!gd._fullLayout) return;
            for (var j = 0; j < basePlotModules.length; j++) {
              basePlotModules[j].plot(gd, transitionedTraces, traceTransitionOpts, makeCallback);
            }
          }
          if (axEdits.length && restyleFlags.anim) {
            if (transitionOpts.ordering === "traces first") {
              axisTransitionOpts = Lib.extendFlat({}, transitionOpts, { duration: 0 });
              transitionedTraces = allTraceIndices;
              traceTransitionOpts = transitionOpts;
              setTimeout(transitionAxes, transitionOpts.duration);
              transitionTraces();
            } else {
              axisTransitionOpts = transitionOpts;
              transitionedTraces = null;
              traceTransitionOpts = Lib.extendFlat({}, transitionOpts, { duration: 0 });
              setTimeout(transitionTraces, axisTransitionOpts.duration);
              transitionAxes();
            }
          } else if (axEdits.length) {
            axisTransitionOpts = transitionOpts;
            transitionAxes();
          } else if (restyleFlags.anim) {
            transitionedTraces = allTraceIndices;
            traceTransitionOpts = transitionOpts;
            transitionTraces();
          }
        };
        return _transition(gd, transitionOpts, opts);
      };
      function _transition(gd, transitionOpts, opts) {
        var aborted = false;
        function executeCallbacks(list) {
          var p = Promise.resolve();
          if (!list) return p;
          while (list.length) {
            p = p.then(list.shift());
          }
          return p;
        }
        function flushCallbacks(list) {
          if (!list) return;
          while (list.length) {
            list.shift();
          }
        }
        function executeTransitions() {
          gd.emit("plotly_transitioning", []);
          return new Promise(function(resolve) {
            gd._transitioning = true;
            if (transitionOpts.duration > 0) {
              gd._transitioningWithDuration = true;
            }
            gd._transitionData._interruptCallbacks.push(function() {
              aborted = true;
            });
            if (opts.redraw) {
              gd._transitionData._interruptCallbacks.push(function() {
                return Registry.call("redraw", gd);
              });
            }
            gd._transitionData._interruptCallbacks.push(function() {
              gd.emit("plotly_transitioninterrupted", []);
            });
            var numCallbacks = 0;
            var numCompleted = 0;
            function makeCallback() {
              numCallbacks++;
              return function() {
                numCompleted++;
                if (!aborted && numCompleted === numCallbacks) {
                  completeTransition(resolve);
                }
              };
            }
            opts.runFn(makeCallback);
            setTimeout(makeCallback());
          });
        }
        function completeTransition(callback) {
          if (!gd._transitionData) return;
          flushCallbacks(gd._transitionData._interruptCallbacks);
          return Promise.resolve().then(function() {
            if (opts.redraw) {
              return Registry.call("redraw", gd);
            }
          }).then(function() {
            gd._transitioning = false;
            gd._transitioningWithDuration = false;
            gd.emit("plotly_transitioned", []);
          }).then(callback);
        }
        function interruptPreviousTransitions() {
          if (!gd._transitionData) return;
          gd._transitioning = false;
          return executeCallbacks(gd._transitionData._interruptCallbacks);
        }
        var seq = [
          plots.previousPromises,
          interruptPreviousTransitions,
          opts.prepareFn,
          plots.rehover,
          plots.reselect,
          executeTransitions
        ];
        var transitionStarting = Lib.syncOrAsync(seq, gd);
        if (!transitionStarting || !transitionStarting.then) {
          transitionStarting = Promise.resolve();
        }
        return transitionStarting.then(function() {
          return gd;
        });
      }
      plots.doCalcdata = function(gd, traces) {
        var axList = axisIDs.list(gd);
        var fullData = gd._fullData;
        var fullLayout = gd._fullLayout;
        var trace, _module, i, j;
        var calcdata = new Array(fullData.length);
        var oldCalcdata = (gd.calcdata || []).slice();
        gd.calcdata = calcdata;
        fullLayout._numBoxes = 0;
        fullLayout._numViolins = 0;
        fullLayout._violinScaleGroupStats = {};
        gd._hmpixcount = 0;
        gd._hmlumcount = 0;
        fullLayout._piecolormap = {};
        fullLayout._sunburstcolormap = {};
        fullLayout._treemapcolormap = {};
        fullLayout._iciclecolormap = {};
        fullLayout._funnelareacolormap = {};
        for (i = 0; i < fullData.length; i++) {
          if (Array.isArray(traces) && traces.indexOf(i) === -1) {
            calcdata[i] = oldCalcdata[i];
            continue;
          }
        }
        for (i = 0; i < fullData.length; i++) {
          trace = fullData[i];
          trace._arrayAttrs = PlotSchema.findArrayAttributes(trace);
          trace._extremes = {};
        }
        var polarIds = fullLayout._subplots.polar || [];
        for (i = 0; i < polarIds.length; i++) {
          axList.push(
            fullLayout[polarIds[i]].radialaxis,
            fullLayout[polarIds[i]].angularaxis
          );
        }
        for (var k in fullLayout._colorAxes) {
          var cOpts = fullLayout[k];
          if (cOpts.cauto !== false) {
            delete cOpts.cmin;
            delete cOpts.cmax;
          }
        }
        var hasCalcTransform = false;
        function transformCalci(i2) {
          trace = fullData[i2];
          _module = trace._module;
          if (trace.visible === true && trace.transforms) {
            if (_module && _module.calc) {
              var cdi = _module.calc(gd, trace);
              if (cdi[0] && cdi[0].t && cdi[0].t._scene) {
                delete cdi[0].t._scene.dirty;
              }
            }
            for (j = 0; j < trace.transforms.length; j++) {
              var transform = trace.transforms[j];
              _module = transformsRegistry[transform.type];
              if (_module && _module.calcTransform) {
                trace._hasCalcTransform = true;
                hasCalcTransform = true;
                _module.calcTransform(gd, trace, transform);
              }
            }
          }
        }
        function calci(i2, isContainer) {
          trace = fullData[i2];
          _module = trace._module;
          if (!!_module.isContainer !== isContainer) return;
          var cd = [];
          if (trace.visible === true && trace._length !== 0) {
            delete trace._indexToPoints;
            var transforms = trace.transforms || [];
            for (j = transforms.length - 1; j >= 0; j--) {
              if (transforms[j].enabled) {
                trace._indexToPoints = transforms[j]._indexToPoints;
                break;
              }
            }
            if (_module && _module.calc) {
              cd = _module.calc(gd, trace);
            }
          }
          if (!Array.isArray(cd) || !cd[0]) {
            cd = [{ x: BADNUM, y: BADNUM }];
          }
          if (!cd[0].t) cd[0].t = {};
          cd[0].trace = trace;
          calcdata[i2] = cd;
        }
        setupAxisCategories(axList, fullData, fullLayout);
        for (i = 0; i < fullData.length; i++) calci(i, true);
        for (i = 0; i < fullData.length; i++) transformCalci(i);
        if (hasCalcTransform) setupAxisCategories(axList, fullData, fullLayout);
        for (i = 0; i < fullData.length; i++) calci(i, true);
        for (i = 0; i < fullData.length; i++) calci(i, false);
        doCrossTraceCalc(gd);
        var sorted = sortAxisCategoriesByValue(axList, gd);
        if (sorted.length) {
          fullLayout._numBoxes = 0;
          fullLayout._numViolins = 0;
          for (i = 0; i < sorted.length; i++) calci(sorted[i], true);
          for (i = 0; i < sorted.length; i++) calci(sorted[i], false);
          doCrossTraceCalc(gd);
        }
        Registry.getComponentMethod("fx", "calc")(gd);
        Registry.getComponentMethod("errorbars", "calc")(gd);
      };
      var sortAxisCategoriesByValueRegex = /(total|sum|min|max|mean|geometric mean|median) (ascending|descending)/;
      function sortAxisCategoriesByValue(axList, gd) {
        var affectedTraces = [];
        var i, j, k, l, o;
        function zMapCategory(type2, ax2, value2) {
          var axLetter2 = ax2._id.charAt(0);
          if (type2 === "histogram2dcontour") {
            var counterAxLetter = ax2._counterAxes[0];
            var counterAx = axisIDs.getFromId(gd, counterAxLetter);
            var xCategorical = axLetter2 === "x" || counterAxLetter === "x" && counterAx.type === "category";
            var yCategorical = axLetter2 === "y" || counterAxLetter === "y" && counterAx.type === "category";
            return function(o2, l2) {
              if (o2 === 0 || l2 === 0) return -1;
              if (xCategorical && o2 === value2[l2].length - 1) return -1;
              if (yCategorical && l2 === value2.length - 1) return -1;
              return (axLetter2 === "y" ? l2 : o2) - 1;
            };
          } else {
            return function(o2, l2) {
              return axLetter2 === "y" ? l2 : o2;
            };
          }
        }
        var aggFn = {
          min: function(values) {
            return Lib.aggNums(Math.min, null, values);
          },
          max: function(values) {
            return Lib.aggNums(Math.max, null, values);
          },
          sum: function(values) {
            return Lib.aggNums(function(a, b) {
              return a + b;
            }, null, values);
          },
          total: function(values) {
            return Lib.aggNums(function(a, b) {
              return a + b;
            }, null, values);
          },
          mean: function(values) {
            return Lib.mean(values);
          },
          "geometric mean": function(values) {
            return Lib.geometricMean(values);
          },
          median: function(values) {
            return Lib.median(values);
          }
        };
        function sortAscending(a, b) {
          return a[1] - b[1];
        }
        function sortDescending(a, b) {
          return b[1] - a[1];
        }
        for (i = 0; i < axList.length; i++) {
          var ax = axList[i];
          if (ax.type !== "category") continue;
          var match = ax.categoryorder.match(sortAxisCategoriesByValueRegex);
          if (match) {
            var aggregator = match[1];
            var order = match[2];
            var axLetter = ax._id.charAt(0);
            var isX = axLetter === "x";
            var categoriesValue = [];
            for (j = 0; j < ax._categories.length; j++) {
              categoriesValue.push([ax._categories[j], []]);
            }
            for (j = 0; j < ax._traceIndices.length; j++) {
              var traceIndex = ax._traceIndices[j];
              var fullTrace = gd._fullData[traceIndex];
              if (fullTrace.visible !== true) continue;
              var type = fullTrace.type;
              if (Registry.traceIs(fullTrace, "histogram")) {
                delete fullTrace._xautoBinFinished;
                delete fullTrace._yautoBinFinished;
              }
              var isSplom = type === "splom";
              var isScattergl = type === "scattergl";
              var cd = gd.calcdata[traceIndex];
              for (k = 0; k < cd.length; k++) {
                var cdi = cd[k];
                var catIndex, value;
                if (isSplom) {
                  var currentDimensionIndex = fullTrace._axesDim[ax._id];
                  if (!isX) {
                    var associatedXAxisID = fullTrace._diag[currentDimensionIndex][0];
                    if (associatedXAxisID) ax = gd._fullLayout[axisIDs.id2name(associatedXAxisID)];
                  }
                  var categories = cdi.trace.dimensions[currentDimensionIndex].values;
                  for (l = 0; l < categories.length; l++) {
                    catIndex = ax._categoriesMap[categories[l]];
                    for (o = 0; o < cdi.trace.dimensions.length; o++) {
                      if (o === currentDimensionIndex) continue;
                      var dimension = cdi.trace.dimensions[o];
                      categoriesValue[catIndex][1].push(dimension.values[l]);
                    }
                  }
                } else if (isScattergl) {
                  for (l = 0; l < cdi.t.x.length; l++) {
                    if (isX) {
                      catIndex = cdi.t.x[l];
                      value = cdi.t.y[l];
                    } else {
                      catIndex = cdi.t.y[l];
                      value = cdi.t.x[l];
                    }
                    categoriesValue[catIndex][1].push(value);
                  }
                  if (cdi.t && cdi.t._scene) {
                    delete cdi.t._scene.dirty;
                  }
                } else if (cdi.hasOwnProperty("z")) {
                  value = cdi.z;
                  var mapping = zMapCategory(fullTrace.type, ax, value);
                  for (l = 0; l < value.length; l++) {
                    for (o = 0; o < value[l].length; o++) {
                      catIndex = mapping(o, l);
                      if (catIndex + 1) categoriesValue[catIndex][1].push(value[l][o]);
                    }
                  }
                } else {
                  catIndex = cdi.p;
                  if (catIndex === void 0) catIndex = cdi[axLetter];
                  value = cdi.s;
                  if (value === void 0) value = cdi.v;
                  if (value === void 0) value = isX ? cdi.y : cdi.x;
                  if (!Array.isArray(value)) {
                    if (value === void 0) value = [];
                    else value = [value];
                  }
                  for (l = 0; l < value.length; l++) {
                    categoriesValue[catIndex][1].push(value[l]);
                  }
                }
              }
            }
            ax._categoriesValue = categoriesValue;
            var categoriesAggregatedValue = [];
            for (j = 0; j < categoriesValue.length; j++) {
              categoriesAggregatedValue.push([
                categoriesValue[j][0],
                aggFn[aggregator](categoriesValue[j][1])
              ]);
            }
            categoriesAggregatedValue.sort(order === "descending" ? sortDescending : sortAscending);
            ax._categoriesAggregatedValue = categoriesAggregatedValue;
            ax._initialCategories = categoriesAggregatedValue.map(function(c) {
              return c[0];
            });
            affectedTraces = affectedTraces.concat(ax.sortByInitialCategories());
          }
        }
        return affectedTraces;
      }
      function setupAxisCategories(axList, fullData, fullLayout) {
        var axLookup = {};
        function setupOne(ax) {
          ax.clearCalc();
          if (ax.type === "multicategory") {
            ax.setupMultiCategory(fullData);
          }
          axLookup[ax._id] = 1;
        }
        Lib.simpleMap(axList, setupOne);
        var matchGroups = fullLayout._axisMatchGroups || [];
        for (var i = 0; i < matchGroups.length; i++) {
          for (var axId in matchGroups[i]) {
            if (!axLookup[axId]) {
              setupOne(fullLayout[axisIDs.id2name(axId)]);
            }
          }
        }
      }
      function doCrossTraceCalc(gd) {
        var fullLayout = gd._fullLayout;
        var modules = fullLayout._visibleModules;
        var hash = {};
        var i, j, k;
        for (j = 0; j < modules.length; j++) {
          var _module = modules[j];
          var fn = _module.crossTraceCalc;
          if (fn) {
            var spType = _module.basePlotModule.name;
            if (hash[spType]) {
              Lib.pushUnique(hash[spType], fn);
            } else {
              hash[spType] = [fn];
            }
          }
        }
        for (k in hash) {
          var methods = hash[k];
          var subplots = fullLayout._subplots[k];
          if (Array.isArray(subplots)) {
            for (i = 0; i < subplots.length; i++) {
              var sp = subplots[i];
              var spInfo = k === "cartesian" ? fullLayout._plots[sp] : fullLayout[sp];
              for (j = 0; j < methods.length; j++) {
                methods[j](gd, spInfo, sp);
              }
            }
          } else {
            for (j = 0; j < methods.length; j++) {
              methods[j](gd);
            }
          }
        }
      }
      plots.rehover = function(gd) {
        if (gd._fullLayout._rehover) {
          gd._fullLayout._rehover();
        }
      };
      plots.redrag = function(gd) {
        if (gd._fullLayout._redrag) {
          gd._fullLayout._redrag();
        }
      };
      plots.reselect = function(gd) {
        var fullLayout = gd._fullLayout;
        var A = (gd.layout || {}).selections;
        var B = fullLayout._previousSelections;
        fullLayout._previousSelections = A;
        var mayEmitSelected = fullLayout._reselect || JSON.stringify(A) !== JSON.stringify(B);
        Registry.getComponentMethod("selections", "reselect")(gd, mayEmitSelected);
      };
      plots.generalUpdatePerTraceModule = function(gd, subplot, subplotCalcData, subplotLayout) {
        var traceHashOld = subplot.traceHash;
        var traceHash = {};
        var i;
        for (i = 0; i < subplotCalcData.length; i++) {
          var calcTraces = subplotCalcData[i];
          var trace = calcTraces[0].trace;
          if (trace.visible) {
            traceHash[trace.type] = traceHash[trace.type] || [];
            traceHash[trace.type].push(calcTraces);
          }
        }
        for (var moduleNameOld in traceHashOld) {
          if (!traceHash[moduleNameOld]) {
            var fakeCalcTrace = traceHashOld[moduleNameOld][0];
            var fakeTrace = fakeCalcTrace[0].trace;
            fakeTrace.visible = false;
            traceHash[moduleNameOld] = [fakeCalcTrace];
          }
        }
        for (var moduleName in traceHash) {
          var moduleCalcData = traceHash[moduleName];
          var _module = moduleCalcData[0][0].trace._module;
          _module.plot(gd, subplot, Lib.filterVisible(moduleCalcData), subplotLayout);
        }
        subplot.traceHash = traceHash;
      };
      plots.plotBasePlot = function(desiredType, gd, traces, transitionOpts, makeOnCompleteCallback) {
        var _module = Registry.getModule(desiredType);
        var cdmodule = getModuleCalcData(gd.calcdata, _module)[0];
        _module.plot(gd, cdmodule, transitionOpts, makeOnCompleteCallback);
      };
      plots.cleanBasePlot = function(desiredType, newFullData, newFullLayout, oldFullData, oldFullLayout) {
        var had = oldFullLayout._has && oldFullLayout._has(desiredType);
        var has = newFullLayout._has && newFullLayout._has(desiredType);
        if (had && !has) {
          oldFullLayout["_" + desiredType + "layer"].selectAll("g.trace").remove();
        }
      };
    }
  });

  // src/constants/xmlns_namespaces.js
  var require_xmlns_namespaces = __commonJS({
    "src/constants/xmlns_namespaces.js"(exports) {
      "use strict";
      exports.xmlns = "http://www.w3.org/2000/xmlns/";
      exports.svg = "http://www.w3.org/2000/svg";
      exports.xlink = "http://www.w3.org/1999/xlink";
      exports.svgAttrs = {
        xmlns: exports.svg,
        "xmlns:xlink": exports.xlink
      };
    }
  });

  // src/constants/alignment.js
  var require_alignment = __commonJS({
    "src/constants/alignment.js"(exports, module) {
      "use strict";
      module.exports = {
        // from bottom left: this is the origin of our paper-reference
        // positioning system
        FROM_BL: {
          left: 0,
          center: 0.5,
          right: 1,
          bottom: 0,
          middle: 0.5,
          top: 1
        },
        // from top left: this is the screen pixel positioning origin
        FROM_TL: {
          left: 0,
          center: 0.5,
          right: 1,
          bottom: 1,
          middle: 0.5,
          top: 0
        },
        // from bottom right: sometimes you just need the opposite of ^^
        FROM_BR: {
          left: 1,
          center: 0.5,
          right: 0,
          bottom: 0,
          middle: 0.5,
          top: 1
        },
        // multiple of fontSize to get the vertical offset between lines
        LINE_SPACING: 1.3,
        // multiple of fontSize to shift from the baseline
        // to the cap (captical letter) line
        // (to use when we don't calculate this shift from Drawing.bBox)
        // This is an approximation since in reality cap height can differ
        // from font to font. However, according to Wikipedia
        //   an "average" font might have a cap height of 70% of the em
        // https://en.wikipedia.org/wiki/Em_(typography)#History
        CAP_SHIFT: 0.7,
        // half the cap height (distance between baseline and cap line)
        // of an "average" font (for more info see above).
        MID_SHIFT: 0.35,
        OPPOSITE_SIDE: {
          left: "right",
          right: "left",
          top: "bottom",
          bottom: "top"
        }
      };
    }
  });

  // src/lib/svg_text_utils.js
  var require_svg_text_utils = __commonJS({
    "src/lib/svg_text_utils.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var xmlnsNamespaces = require_xmlns_namespaces();
      var LINE_SPACING = require_alignment().LINE_SPACING;
      var FIND_TEX = /([^$]*)([$]+[^$]*[$]+)([^$]*)/;
      exports.convertToTspans = function(_context, gd, _callback) {
        var str = _context.text();
        var tex = !_context.attr("data-notex") && gd && gd._context.typesetMath && typeof MathJax !== "undefined" && str.match(FIND_TEX);
        var parent = d3.select(_context.node().parentNode);
        if (parent.empty()) return;
        var svgClass = _context.attr("class") ? _context.attr("class").split(" ")[0] : "text";
        svgClass += "-math";
        parent.selectAll("svg." + svgClass).remove();
        parent.selectAll("g." + svgClass + "-group").remove();
        _context.style("display", null).attr({
          // some callers use data-unformatted *from the <text> element* in 'cancel'
          // so we need it here even if we're going to turn it into math
          // these two (plus style and text-anchor attributes) form the key we're
          // going to use for Drawing.bBox
          "data-unformatted": str,
          "data-math": "N"
        });
        function showText() {
          if (!parent.empty()) {
            svgClass = _context.attr("class") + "-math";
            parent.select("svg." + svgClass).remove();
          }
          _context.text("").style("white-space", "pre");
          var hasLink = buildSVGText(_context.node(), str);
          if (hasLink) {
            _context.style("pointer-events", "all");
          }
          exports.positionText(_context);
          if (_callback) _callback.call(_context);
        }
        if (tex) {
          (gd && gd._promises || []).push(new Promise(function(resolve) {
            _context.style("display", "none");
            var fontSize = parseInt(_context.node().style.fontSize, 10);
            var config = { fontSize };
            texToSVG(tex[2], config, function(_svgEl, _glyphDefs, _svgBBox) {
              parent.selectAll("svg." + svgClass).remove();
              parent.selectAll("g." + svgClass + "-group").remove();
              var newSvg = _svgEl && _svgEl.select("svg");
              if (!newSvg || !newSvg.node()) {
                showText();
                resolve();
                return;
              }
              var mathjaxGroup = parent.append("g").classed(svgClass + "-group", true).attr({
                "pointer-events": "none",
                "data-unformatted": str,
                "data-math": "Y"
              });
              mathjaxGroup.node().appendChild(newSvg.node());
              if (_glyphDefs && _glyphDefs.node()) {
                newSvg.node().insertBefore(
                  _glyphDefs.node().cloneNode(true),
                  newSvg.node().firstChild
                );
              }
              var w0 = _svgBBox.width;
              var h0 = _svgBBox.height;
              newSvg.attr({
                class: svgClass,
                height: h0,
                preserveAspectRatio: "xMinYMin meet"
              }).style({ overflow: "visible", "pointer-events": "none" });
              var fill = _context.node().style.fill || "black";
              var g = newSvg.select("g");
              g.attr({ fill, stroke: fill });
              var bb = g.node().getBoundingClientRect();
              var w = bb.width;
              var h = bb.height;
              if (w > w0 || h > h0) {
                newSvg.style("overflow", "hidden");
                bb = newSvg.node().getBoundingClientRect();
                w = bb.width;
                h = bb.height;
              }
              var x = +_context.attr("x");
              var y = +_context.attr("y");
              var textHeight = fontSize || _context.node().getBoundingClientRect().height;
              var dy = -textHeight / 4;
              if (svgClass[0] === "y") {
                mathjaxGroup.attr({
                  transform: "rotate(" + [-90, x, y] + ")" + strTranslate(-w / 2, dy - h / 2)
                });
              } else if (svgClass[0] === "l") {
                y = dy - h / 2;
              } else if (svgClass[0] === "a" && svgClass.indexOf("atitle") !== 0) {
                x = 0;
                y = dy;
              } else {
                var anchor = _context.attr("text-anchor");
                x = x - w * (anchor === "middle" ? 0.5 : anchor === "end" ? 1 : 0);
                y = y + dy - h / 2;
              }
              newSvg.attr({
                x,
                y
              });
              if (_callback) _callback.call(_context, mathjaxGroup);
              resolve(mathjaxGroup);
            });
          }));
        } else showText();
        return _context;
      };
      var LT_MATCH = /(<|&lt;|&#60;)/g;
      var GT_MATCH = /(>|&gt;|&#62;)/g;
      function cleanEscapesForTex(s) {
        return s.replace(LT_MATCH, "\\lt ").replace(GT_MATCH, "\\gt ");
      }
      var inlineMath = [["$", "$"], ["\\(", "\\)"]];
      function texToSVG(_texString, _config, _callback) {
        var MathJaxVersion = parseInt(
          (MathJax.version || "").split(".")[0]
        );
        if (MathJaxVersion !== 2 && MathJaxVersion !== 3) {
          Lib.warn("No MathJax version:", MathJax.version);
          return;
        }
        var originalRenderer, originalConfig, originalProcessSectionDelay, tmpDiv;
        var setConfig2 = function() {
          originalConfig = Lib.extendDeepAll({}, MathJax.Hub.config);
          originalProcessSectionDelay = MathJax.Hub.processSectionDelay;
          if (MathJax.Hub.processSectionDelay !== void 0) {
            MathJax.Hub.processSectionDelay = 0;
          }
          return MathJax.Hub.Config({
            messageStyle: "none",
            tex2jax: {
              inlineMath
            },
            displayAlign: "left"
          });
        };
        var setConfig3 = function() {
          originalConfig = Lib.extendDeepAll({}, MathJax.config);
          if (!MathJax.config.tex) {
            MathJax.config.tex = {};
          }
          MathJax.config.tex.inlineMath = inlineMath;
        };
        var setRenderer2 = function() {
          originalRenderer = MathJax.Hub.config.menuSettings.renderer;
          if (originalRenderer !== "SVG") {
            return MathJax.Hub.setRenderer("SVG");
          }
        };
        var setRenderer3 = function() {
          originalRenderer = MathJax.config.startup.output;
          if (originalRenderer !== "svg") {
            MathJax.config.startup.output = "svg";
          }
        };
        var initiateMathJax = function() {
          var randomID = "math-output-" + Lib.randstr({}, 64);
          tmpDiv = d3.select("body").append("div").attr({ id: randomID }).style({
            visibility: "hidden",
            position: "absolute",
            "font-size": _config.fontSize + "px"
          }).text(cleanEscapesForTex(_texString));
          var tmpNode = tmpDiv.node();
          return MathJaxVersion === 2 ? MathJax.Hub.Typeset(tmpNode) : MathJax.typeset([tmpNode]);
        };
        var finalizeMathJax = function() {
          var sel = tmpDiv.select(
            MathJaxVersion === 2 ? ".MathJax_SVG" : ".MathJax"
          );
          var node = !sel.empty() && tmpDiv.select("svg").node();
          if (!node) {
            Lib.log("There was an error in the tex syntax.", _texString);
            _callback();
          } else {
            var nodeBBox = node.getBoundingClientRect();
            var glyphDefs;
            if (MathJaxVersion === 2) {
              glyphDefs = d3.select("body").select("#MathJax_SVG_glyphs");
            } else {
              glyphDefs = sel.select("defs");
            }
            _callback(sel, glyphDefs, nodeBBox);
          }
          tmpDiv.remove();
        };
        var resetRenderer2 = function() {
          if (originalRenderer !== "SVG") {
            return MathJax.Hub.setRenderer(originalRenderer);
          }
        };
        var resetRenderer3 = function() {
          if (originalRenderer !== "svg") {
            MathJax.config.startup.output = originalRenderer;
          }
        };
        var resetConfig2 = function() {
          if (originalProcessSectionDelay !== void 0) {
            MathJax.Hub.processSectionDelay = originalProcessSectionDelay;
          }
          return MathJax.Hub.Config(originalConfig);
        };
        var resetConfig3 = function() {
          MathJax.config = originalConfig;
        };
        if (MathJaxVersion === 2) {
          MathJax.Hub.Queue(
            setConfig2,
            setRenderer2,
            initiateMathJax,
            finalizeMathJax,
            resetRenderer2,
            resetConfig2
          );
        } else if (MathJaxVersion === 3) {
          setConfig3();
          setRenderer3();
          MathJax.startup.defaultReady();
          MathJax.startup.promise.then(function() {
            initiateMathJax();
            finalizeMathJax();
            resetRenderer3();
            resetConfig3();
          });
        }
      }
      var TAG_STYLES = {
        // would like to use baseline-shift for sub/sup but FF doesn't support it
        // so we need to use dy along with the uber hacky shift-back-to
        // baseline below
        sup: "font-size:70%",
        sub: "font-size:70%",
        s: "text-decoration:line-through",
        u: "text-decoration:underline",
        b: "font-weight:bold",
        i: "font-style:italic",
        a: "cursor:pointer",
        span: "",
        em: "font-style:italic;font-weight:bold"
      };
      var SHIFT_DY = {
        sub: "0.3em",
        sup: "-0.6em"
      };
      var RESET_DY = {
        sub: "-0.21em",
        sup: "0.42em"
      };
      var ZERO_WIDTH_SPACE = "\u200B";
      var PROTOCOLS = ["http:", "https:", "mailto:", "", void 0, ":"];
      var NEWLINES = exports.NEWLINES = /(\r\n?|\n)/g;
      var SPLIT_TAGS = /(<[^<>]*>)/;
      var ONE_TAG = /<(\/?)([^ >]*)(\s+(.*))?>/i;
      var BR_TAG = /<br(\s+.*)?>/i;
      exports.BR_TAG_ALL = /<br(\s+.*)?>/gi;
      var STYLEMATCH = /(^|[\s"'])style\s*=\s*("([^"]*);?"|'([^']*);?')/i;
      var HREFMATCH = /(^|[\s"'])href\s*=\s*("([^"]*)"|'([^']*)')/i;
      var TARGETMATCH = /(^|[\s"'])target\s*=\s*("([^"\s]*)"|'([^'\s]*)')/i;
      var POPUPMATCH = /(^|[\s"'])popup\s*=\s*("([\w=,]*)"|'([\w=,]*)')/i;
      function getQuotedMatch(_str, re) {
        if (!_str) return null;
        var match = _str.match(re);
        var result = match && (match[3] || match[4]);
        return result && convertEntities(result);
      }
      var COLORMATCH = /(^|;)\s*color:/;
      exports.plainText = function(_str, opts) {
        opts = opts || {};
        var len = opts.len !== void 0 && opts.len !== -1 ? opts.len : Infinity;
        var allowedTags = opts.allowedTags !== void 0 ? opts.allowedTags : ["br"];
        var ellipsis = "...";
        var eLen = ellipsis.length;
        var oldParts = _str.split(SPLIT_TAGS);
        var newParts = [];
        var prevTag = "";
        var l = 0;
        for (var i = 0; i < oldParts.length; i++) {
          var p = oldParts[i];
          var match = p.match(ONE_TAG);
          var tagType = match && match[2].toLowerCase();
          if (tagType) {
            if (allowedTags.indexOf(tagType) !== -1) {
              newParts.push(p);
              prevTag = tagType;
            }
          } else {
            var pLen = p.length;
            if (l + pLen < len) {
              newParts.push(p);
              l += pLen;
            } else if (l < len) {
              var pLen2 = len - l;
              if (prevTag && (prevTag !== "br" || pLen2 <= eLen || pLen <= eLen)) {
                newParts.pop();
              }
              if (len > eLen) {
                newParts.push(p.substr(0, pLen2 - eLen) + ellipsis);
              } else {
                newParts.push(p.substr(0, pLen2));
              }
              break;
            }
            prevTag = "";
          }
        }
        return newParts.join("");
      };
      var entityToUnicode = {
        mu: "\u03BC",
        amp: "&",
        lt: "<",
        gt: ">",
        nbsp: "\xA0",
        times: "\xD7",
        plusmn: "\xB1",
        deg: "\xB0"
      };
      var ENTITY_MATCH = /&(#\d+|#x[\da-fA-F]+|[a-z]+);/g;
      function convertEntities(_str) {
        return _str.replace(ENTITY_MATCH, function(fullMatch, innerMatch) {
          var outChar;
          if (innerMatch.charAt(0) === "#") {
            outChar = fromCodePoint(
              innerMatch.charAt(1) === "x" ? parseInt(innerMatch.substr(2), 16) : parseInt(innerMatch.substr(1), 10)
            );
          } else outChar = entityToUnicode[innerMatch];
          return outChar || fullMatch;
        });
      }
      exports.convertEntities = convertEntities;
      function fromCodePoint(code) {
        if (code > 1114111) return;
        var stringFromCodePoint = String.fromCodePoint;
        if (stringFromCodePoint) return stringFromCodePoint(code);
        var stringFromCharCode = String.fromCharCode;
        if (code <= 65535) return stringFromCharCode(code);
        return stringFromCharCode(
          (code >> 10) + 55232,
          code % 1024 + 56320
        );
      }
      function buildSVGText(containerNode, str) {
        str = str.replace(NEWLINES, " ");
        var hasLink = false;
        var nodeStack = [];
        var currentNode;
        var currentLine = -1;
        function newLine() {
          currentLine++;
          var lineNode = document.createElementNS(xmlnsNamespaces.svg, "tspan");
          d3.select(lineNode).attr({
            class: "line",
            dy: currentLine * LINE_SPACING + "em"
          });
          containerNode.appendChild(lineNode);
          currentNode = lineNode;
          var oldNodeStack = nodeStack;
          nodeStack = [{ node: lineNode }];
          if (oldNodeStack.length > 1) {
            for (var i2 = 1; i2 < oldNodeStack.length; i2++) {
              enterNode(oldNodeStack[i2]);
            }
          }
        }
        function enterNode(nodeSpec2) {
          var type = nodeSpec2.type;
          var nodeAttrs = {};
          var nodeType;
          if (type === "a") {
            nodeType = "a";
            var target = nodeSpec2.target;
            var href2 = nodeSpec2.href;
            var popup = nodeSpec2.popup;
            if (href2) {
              nodeAttrs = {
                "xlink:xlink:show": target === "_blank" || target.charAt(0) !== "_" ? "new" : "replace",
                target,
                "xlink:xlink:href": href2
              };
              if (popup) {
                nodeAttrs.onclick = 'window.open(this.href.baseVal,this.target.baseVal,"' + popup + '");return false;';
              }
            }
          } else nodeType = "tspan";
          if (nodeSpec2.style) nodeAttrs.style = nodeSpec2.style;
          var newNode = document.createElementNS(xmlnsNamespaces.svg, nodeType);
          if (type === "sup" || type === "sub") {
            addTextNode(currentNode, ZERO_WIDTH_SPACE);
            currentNode.appendChild(newNode);
            var resetter = document.createElementNS(xmlnsNamespaces.svg, "tspan");
            addTextNode(resetter, ZERO_WIDTH_SPACE);
            d3.select(resetter).attr("dy", RESET_DY[type]);
            nodeAttrs.dy = SHIFT_DY[type];
            currentNode.appendChild(newNode);
            currentNode.appendChild(resetter);
          } else {
            currentNode.appendChild(newNode);
          }
          d3.select(newNode).attr(nodeAttrs);
          currentNode = nodeSpec2.node = newNode;
          nodeStack.push(nodeSpec2);
        }
        function addTextNode(node, text) {
          node.appendChild(document.createTextNode(text));
        }
        function exitNode(type) {
          if (nodeStack.length === 1) {
            Lib.log("Ignoring unexpected end tag </" + type + ">.", str);
            return;
          }
          var innerNode = nodeStack.pop();
          if (type !== innerNode.type) {
            Lib.log("Start tag <" + innerNode.type + "> doesnt match end tag <" + type + ">. Pretending it did match.", str);
          }
          currentNode = nodeStack[nodeStack.length - 1].node;
        }
        var hasLines = BR_TAG.test(str);
        if (hasLines) newLine();
        else {
          currentNode = containerNode;
          nodeStack = [{ node: containerNode }];
        }
        var parts = str.split(SPLIT_TAGS);
        for (var i = 0; i < parts.length; i++) {
          var parti = parts[i];
          var match = parti.match(ONE_TAG);
          var tagType = match && match[2].toLowerCase();
          var tagStyle = TAG_STYLES[tagType];
          if (tagType === "br") {
            newLine();
          } else if (tagStyle === void 0) {
            addTextNode(currentNode, convertEntities(parti));
          } else {
            if (match[1]) {
              exitNode(tagType);
            } else {
              var extra = match[4];
              var nodeSpec = { type: tagType };
              var css = getQuotedMatch(extra, STYLEMATCH);
              if (css) {
                css = css.replace(COLORMATCH, "$1 fill:");
                if (tagStyle) css += ";" + tagStyle;
              } else if (tagStyle) css = tagStyle;
              if (css) nodeSpec.style = css;
              if (tagType === "a") {
                hasLink = true;
                var href = getQuotedMatch(extra, HREFMATCH);
                if (href) {
                  var safeHref = sanitizeHref(href);
                  if (safeHref) {
                    nodeSpec.href = safeHref;
                    nodeSpec.target = getQuotedMatch(extra, TARGETMATCH) || "_blank";
                    nodeSpec.popup = getQuotedMatch(extra, POPUPMATCH);
                  }
                }
              }
              enterNode(nodeSpec);
            }
          }
        }
        return hasLink;
      }
      function sanitizeHref(href) {
        var decodedHref = encodeURI(decodeURI(href));
        var dummyAnchor1 = document.createElement("a");
        var dummyAnchor2 = document.createElement("a");
        dummyAnchor1.href = href;
        dummyAnchor2.href = decodedHref;
        var p1 = dummyAnchor1.protocol;
        var p2 = dummyAnchor2.protocol;
        if (PROTOCOLS.indexOf(p1) !== -1 && PROTOCOLS.indexOf(p2) !== -1) {
          return decodedHref;
        } else {
          return "";
        }
      }
      exports.sanitizeHTML = function sanitizeHTML(str) {
        str = str.replace(NEWLINES, " ");
        var rootNode = document.createElement("p");
        var currentNode = rootNode;
        var nodeStack = [];
        var parts = str.split(SPLIT_TAGS);
        for (var i = 0; i < parts.length; i++) {
          var parti = parts[i];
          var match = parti.match(ONE_TAG);
          var tagType = match && match[2].toLowerCase();
          if (tagType in TAG_STYLES) {
            if (match[1]) {
              if (nodeStack.length) {
                currentNode = nodeStack.pop();
              }
            } else {
              var extra = match[4];
              var css = getQuotedMatch(extra, STYLEMATCH);
              var nodeAttrs = css ? { style: css } : {};
              if (tagType === "a") {
                var href = getQuotedMatch(extra, HREFMATCH);
                if (href) {
                  var safeHref = sanitizeHref(href);
                  if (safeHref) {
                    nodeAttrs.href = safeHref;
                    var target = getQuotedMatch(extra, TARGETMATCH);
                    if (target) {
                      nodeAttrs.target = target;
                    }
                  }
                }
              }
              var newNode = document.createElement(tagType);
              currentNode.appendChild(newNode);
              d3.select(newNode).attr(nodeAttrs);
              currentNode = newNode;
              nodeStack.push(newNode);
            }
          } else {
            currentNode.appendChild(
              document.createTextNode(convertEntities(parti))
            );
          }
        }
        var key = "innerHTML";
        return rootNode[key];
      };
      exports.lineCount = function lineCount(s) {
        return s.selectAll("tspan.line").size() || 1;
      };
      exports.positionText = function positionText(s, x, y) {
        return s.each(function() {
          var text = d3.select(this);
          function setOrGet(attr, val) {
            if (val === void 0) {
              val = text.attr(attr);
              if (val === null) {
                text.attr(attr, 0);
                val = 0;
              }
            } else text.attr(attr, val);
            return val;
          }
          var thisX = setOrGet("x", x);
          var thisY = setOrGet("y", y);
          if (this.nodeName === "text") {
            text.selectAll("tspan.line").attr({ x: thisX, y: thisY });
          }
        });
      };
      function alignHTMLWith(_base, container, options) {
        var alignH = options.horizontalAlign;
        var alignV = options.verticalAlign || "top";
        var bRect = _base.node().getBoundingClientRect();
        var cRect = container.node().getBoundingClientRect();
        var thisRect;
        var getTop;
        var getLeft;
        if (alignV === "bottom") {
          getTop = function() {
            return bRect.bottom - thisRect.height;
          };
        } else if (alignV === "middle") {
          getTop = function() {
            return bRect.top + (bRect.height - thisRect.height) / 2;
          };
        } else {
          getTop = function() {
            return bRect.top;
          };
        }
        if (alignH === "right") {
          getLeft = function() {
            return bRect.right - thisRect.width;
          };
        } else if (alignH === "center") {
          getLeft = function() {
            return bRect.left + (bRect.width - thisRect.width) / 2;
          };
        } else {
          getLeft = function() {
            return bRect.left;
          };
        }
        return function() {
          thisRect = this.node().getBoundingClientRect();
          var x0 = getLeft() - cRect.left;
          var y0 = getTop() - cRect.top;
          var gd = options.gd || {};
          if (options.gd) {
            gd._fullLayout._calcInverseTransform(gd);
            var transformedCoords = Lib.apply3DTransform(gd._fullLayout._invTransform)(x0, y0);
            x0 = transformedCoords[0];
            y0 = transformedCoords[1];
          }
          this.style({
            top: y0 + "px",
            left: x0 + "px",
            "z-index": 1e3
          });
          return this;
        };
      }
      var onePx = "1px ";
      exports.makeTextShadow = function(color) {
        var x = onePx;
        var y = onePx;
        var b = onePx;
        return x + y + b + color + ", -" + x + "-" + y + b + color + ", " + x + "-" + y + b + color + ", -" + x + y + b + color;
      };
      exports.makeEditable = function(context, options) {
        var gd = options.gd;
        var _delegate = options.delegate;
        var dispatch = d3.dispatch("edit", "input", "cancel");
        var handlerElement = _delegate || context;
        context.style({ "pointer-events": _delegate ? "none" : "all" });
        if (context.size() !== 1) throw new Error("boo");
        function handleClick() {
          appendEditable();
          context.style({ opacity: 0 });
          var svgClass = handlerElement.attr("class");
          var mathjaxClass;
          if (svgClass) mathjaxClass = "." + svgClass.split(" ")[0] + "-math-group";
          else mathjaxClass = "[class*=-math-group]";
          if (mathjaxClass) {
            d3.select(context.node().parentNode).select(mathjaxClass).style({ opacity: 0 });
          }
        }
        function selectElementContents(_el) {
          var el = _el.node();
          var range = document.createRange();
          range.selectNodeContents(el);
          var sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
          el.focus();
        }
        function appendEditable() {
          var plotDiv = d3.select(gd);
          var container = plotDiv.select(".svg-container");
          var div = container.append("div");
          var cStyle = context.node().style;
          var fontSize = parseFloat(cStyle.fontSize || 12);
          var initialText = options.text;
          if (initialText === void 0) initialText = context.attr("data-unformatted");
          div.classed("plugin-editable editable", true).style({
            position: "absolute",
            "font-family": cStyle.fontFamily || "Arial",
            "font-size": fontSize,
            color: options.fill || cStyle.fill || "black",
            opacity: 1,
            "background-color": options.background || "transparent",
            outline: "#ffffff33 1px solid",
            margin: [-fontSize / 8 + 1, 0, 0, -1].join("px ") + "px",
            padding: "0",
            "box-sizing": "border-box"
          }).attr({ contenteditable: true }).text(initialText).call(alignHTMLWith(context, container, options)).on("blur", function() {
            gd._editing = false;
            context.text(this.textContent).style({ opacity: 1 });
            var svgClass = d3.select(this).attr("class");
            var mathjaxClass;
            if (svgClass) mathjaxClass = "." + svgClass.split(" ")[0] + "-math-group";
            else mathjaxClass = "[class*=-math-group]";
            if (mathjaxClass) {
              d3.select(context.node().parentNode).select(mathjaxClass).style({ opacity: 0 });
            }
            var text = this.textContent;
            d3.select(this).transition().duration(0).remove();
            d3.select(document).on("mouseup", null);
            dispatch.edit.call(context, text);
          }).on("focus", function() {
            var editDiv = this;
            gd._editing = true;
            d3.select(document).on("mouseup", function() {
              if (d3.event.target === editDiv) return false;
              if (document.activeElement === div.node()) div.node().blur();
            });
          }).on("keyup", function() {
            if (d3.event.which === 27) {
              gd._editing = false;
              context.style({ opacity: 1 });
              d3.select(this).style({ opacity: 0 }).on("blur", function() {
                return false;
              }).transition().remove();
              dispatch.cancel.call(context, this.textContent);
            } else {
              dispatch.input.call(context, this.textContent);
              d3.select(this).call(alignHTMLWith(context, container, options));
            }
          }).on("keydown", function() {
            if (d3.event.which === 13) this.blur();
          }).call(selectElementContents);
        }
        if (options.immediate) handleClick();
        else handlerElement.on("click", handleClick);
        return d3.rebind(context, dispatch, "on");
      };
    }
  });

  // src/components/colorscale/helpers.js
  var require_helpers = __commonJS({
    "src/components/colorscale/helpers.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var tinycolor = require_tinycolor();
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var Color = require_color();
      var isValidScale = require_scales().isValid;
      function hasColorscale(trace, containerStr, colorKey) {
        var container = containerStr ? Lib.nestedProperty(trace, containerStr).get() || {} : trace;
        var color = container[colorKey || "color"];
        if (color && color._inputArray) color = color._inputArray;
        var isArrayWithOneNumber = false;
        if (Lib.isArrayOrTypedArray(color)) {
          for (var i = 0; i < color.length; i++) {
            if (isNumeric(color[i])) {
              isArrayWithOneNumber = true;
              break;
            }
          }
        }
        return Lib.isPlainObject(container) && (isArrayWithOneNumber || container.showscale === true || isNumeric(container.cmin) && isNumeric(container.cmax) || isValidScale(container.colorscale) || Lib.isPlainObject(container.colorbar));
      }
      var constantAttrs = ["showscale", "autocolorscale", "colorscale", "reversescale", "colorbar"];
      var letterAttrs = ["min", "max", "mid", "auto"];
      function extractOpts(cont) {
        var colorAx = cont._colorAx;
        var cont2 = colorAx ? colorAx : cont;
        var out = {};
        var cLetter;
        var i, k;
        for (i = 0; i < constantAttrs.length; i++) {
          k = constantAttrs[i];
          out[k] = cont2[k];
        }
        if (colorAx) {
          cLetter = "c";
          for (i = 0; i < letterAttrs.length; i++) {
            k = letterAttrs[i];
            out[k] = cont2["c" + k];
          }
        } else {
          var k2;
          for (i = 0; i < letterAttrs.length; i++) {
            k = letterAttrs[i];
            k2 = "c" + k;
            if (k2 in cont2) {
              out[k] = cont2[k2];
              continue;
            }
            k2 = "z" + k;
            if (k2 in cont2) {
              out[k] = cont2[k2];
            }
          }
          cLetter = k2.charAt(0);
        }
        out._sync = function(k3, v) {
          var k22 = letterAttrs.indexOf(k3) !== -1 ? cLetter + k3 : k3;
          cont2[k22] = cont2["_" + k22] = v;
        };
        return out;
      }
      function extractScale(cont) {
        var cOpts = extractOpts(cont);
        var cmin = cOpts.min;
        var cmax = cOpts.max;
        var scl = cOpts.reversescale ? flipScale(cOpts.colorscale) : cOpts.colorscale;
        var N = scl.length;
        var domain = new Array(N);
        var range = new Array(N);
        for (var i = 0; i < N; i++) {
          var si = scl[i];
          domain[i] = cmin + si[0] * (cmax - cmin);
          range[i] = si[1];
        }
        return { domain, range };
      }
      function flipScale(scl) {
        var N = scl.length;
        var sclNew = new Array(N);
        for (var i = N - 1, j = 0; i >= 0; i--, j++) {
          var si = scl[i];
          sclNew[j] = [1 - si[0], si[1]];
        }
        return sclNew;
      }
      function makeColorScaleFunc(specs, opts) {
        opts = opts || {};
        var domain = specs.domain;
        var range = specs.range;
        var N = range.length;
        var _range = new Array(N);
        for (var i = 0; i < N; i++) {
          var rgba = tinycolor(range[i]).toRgb();
          _range[i] = [rgba.r, rgba.g, rgba.b, rgba.a];
        }
        var _sclFunc = d3.scale.linear().domain(domain).range(_range).clamp(true);
        var noNumericCheck = opts.noNumericCheck;
        var returnArray = opts.returnArray;
        var sclFunc;
        if (noNumericCheck && returnArray) {
          sclFunc = _sclFunc;
        } else if (noNumericCheck) {
          sclFunc = function(v) {
            return colorArray2rbga(_sclFunc(v));
          };
        } else if (returnArray) {
          sclFunc = function(v) {
            if (isNumeric(v)) return _sclFunc(v);
            else if (tinycolor(v).isValid()) return v;
            else return Color.defaultLine;
          };
        } else {
          sclFunc = function(v) {
            if (isNumeric(v)) return colorArray2rbga(_sclFunc(v));
            else if (tinycolor(v).isValid()) return v;
            else return Color.defaultLine;
          };
        }
        sclFunc.domain = _sclFunc.domain;
        sclFunc.range = function() {
          return range;
        };
        return sclFunc;
      }
      function makeColorScaleFuncFromTrace(trace, opts) {
        return makeColorScaleFunc(extractScale(trace), opts);
      }
      function colorArray2rbga(colorArray) {
        var colorObj = {
          r: colorArray[0],
          g: colorArray[1],
          b: colorArray[2],
          a: colorArray[3]
        };
        return tinycolor(colorObj).toRgbString();
      }
      module.exports = {
        hasColorscale,
        extractOpts,
        extractScale,
        flipScale,
        makeColorScaleFunc,
        makeColorScaleFuncFromTrace
      };
    }
  });

  // src/plots/cartesian/axis_format_attributes.js
  var require_axis_format_attributes = __commonJS({
    "src/plots/cartesian/axis_format_attributes.js"(exports, module) {
      "use strict";
      var docs = require_docs();
      var FORMAT_LINK = docs.FORMAT_LINK;
      var DATE_FORMAT_LINK = docs.DATE_FORMAT_LINK;
      function axisHoverFormat(x, noDates) {
        return {
          valType: "string",
          dflt: "",
          editType: "none",
          description: (noDates ? descriptionOnlyNumbers : descriptionWithDates)("hover text", x) + [
            "By default the values are formatted using " + (noDates ? "generic number format" : "`" + x + "axis.hoverformat`") + "."
          ].join(" ")
        };
      }
      function descriptionOnlyNumbers(label, x) {
        return [
          "Sets the " + label + " formatting rule" + (x ? "for `" + x + "` " : ""),
          "using d3 formatting mini-languages",
          "which are very similar to those in Python. For numbers, see: " + FORMAT_LINK + "."
        ].join(" ");
      }
      function descriptionWithDates(label, x) {
        return descriptionOnlyNumbers(label, x) + [
          " And for dates see: " + DATE_FORMAT_LINK + ".",
          "We add two items to d3's date formatter:",
          "*%h* for half of the year as a decimal number as well as",
          "*%{n}f* for fractional seconds",
          "with n digits. For example, *2016-10-13 09:15:23.456* with tickformat",
          "*%H~%M~%S.%2f* would display *09~15~23.46*"
        ].join(" ");
      }
      module.exports = {
        axisHoverFormat,
        descriptionOnlyNumbers,
        descriptionWithDates
      };
    }
  });

  // src/plots/cartesian/layout_attributes.js
  var require_layout_attributes4 = __commonJS({
    "src/plots/cartesian/layout_attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var colorAttrs = require_attributes3();
      var dash = require_attributes4().dash;
      var extendFlat = require_extend().extendFlat;
      var templatedArray = require_plot_template().templatedArray;
      var descriptionWithDates = require_axis_format_attributes().descriptionWithDates;
      var ONEDAY = require_numerical().ONEDAY;
      var constants = require_constants2();
      var HOUR = constants.HOUR_PATTERN;
      var DAY_OF_WEEK = constants.WEEKDAY_PATTERN;
      var minorTickmode = {
        valType: "enumerated",
        values: ["auto", "linear", "array"],
        editType: "ticks",
        impliedEdits: { tick0: void 0, dtick: void 0 }
      };
      var tickmode = extendFlat({}, minorTickmode, {
        values: minorTickmode.values.slice().concat(["sync"])
      });
      function makeNticks(minor) {
        return {
          valType: "integer",
          min: 0,
          dflt: minor ? 5 : 0,
          editType: "ticks"
        };
      }
      var tick0 = {
        valType: "any",
        editType: "ticks",
        impliedEdits: { tickmode: "linear" }
      };
      var dtick = {
        valType: "any",
        editType: "ticks",
        impliedEdits: { tickmode: "linear" }
      };
      var tickvals = {
        valType: "data_array",
        editType: "ticks"
      };
      var ticks = {
        valType: "enumerated",
        values: ["outside", "inside", ""],
        editType: "ticks"
      };
      function makeTicklen(minor) {
        var obj = {
          valType: "number",
          min: 0,
          editType: "ticks"
        };
        if (!minor) obj.dflt = 5;
        return obj;
      }
      function makeTickwidth(minor) {
        var obj = {
          valType: "number",
          min: 0,
          editType: "ticks"
        };
        if (!minor) obj.dflt = 1;
        return obj;
      }
      var tickcolor = {
        valType: "color",
        dflt: colorAttrs.defaultLine,
        editType: "ticks"
      };
      var gridcolor = {
        valType: "color",
        dflt: colorAttrs.lightLine,
        editType: "ticks"
      };
      function makeGridwidth(minor) {
        var obj = {
          valType: "number",
          min: 0,
          editType: "ticks"
        };
        if (!minor) obj.dflt = 1;
        return obj;
      }
      var griddash = extendFlat({}, dash, { editType: "ticks" });
      var showgrid = {
        valType: "boolean",
        editType: "ticks"
      };
      module.exports = {
        visible: {
          valType: "boolean",
          editType: "plot"
        },
        color: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "ticks"
        },
        title: {
          text: {
            valType: "string",
            editType: "ticks"
          },
          font: fontAttrs({
            editType: "ticks"
          }),
          standoff: {
            valType: "number",
            min: 0,
            editType: "ticks"
          },
          editType: "ticks"
        },
        type: {
          valType: "enumerated",
          // '-' means we haven't yet run autotype or couldn't find any data
          // it gets turned into linear in gd._fullLayout but not copied back
          // to gd.data like the others are.
          values: ["-", "linear", "log", "date", "category", "multicategory"],
          dflt: "-",
          editType: "calc",
          // we forget when an axis has been autotyped, just writing the auto
          // value back to the input - so it doesn't make sense to template this.
          // Note: we do NOT prohibit this in `coerce`, so if someone enters a
          // type in the template explicitly it will be honored as the default.
          _noTemplating: true
        },
        autotypenumbers: {
          valType: "enumerated",
          values: ["convert types", "strict"],
          dflt: "convert types",
          editType: "calc"
        },
        autorange: {
          valType: "enumerated",
          values: [true, false, "reversed", "min reversed", "max reversed", "min", "max"],
          dflt: true,
          editType: "axrange",
          impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
        },
        autorangeoptions: {
          minallowed: {
            valType: "any",
            editType: "plot",
            impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
          },
          maxallowed: {
            valType: "any",
            editType: "plot",
            impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
          },
          clipmin: {
            valType: "any",
            editType: "plot",
            impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
          },
          clipmax: {
            valType: "any",
            editType: "plot",
            impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
          },
          include: {
            valType: "any",
            arrayOk: true,
            editType: "plot",
            impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
          },
          editType: "plot"
        },
        rangemode: {
          valType: "enumerated",
          values: ["normal", "tozero", "nonnegative"],
          dflt: "normal",
          editType: "plot"
        },
        range: {
          valType: "info_array",
          items: [
            { valType: "any", editType: "axrange", impliedEdits: { "^autorange": false }, anim: true },
            { valType: "any", editType: "axrange", impliedEdits: { "^autorange": false }, anim: true }
          ],
          editType: "axrange",
          impliedEdits: { autorange: false },
          anim: true
        },
        minallowed: {
          valType: "any",
          editType: "plot",
          impliedEdits: { "^autorange": false }
        },
        maxallowed: {
          valType: "any",
          editType: "plot",
          impliedEdits: { "^autorange": false }
        },
        fixedrange: {
          valType: "boolean",
          dflt: false,
          editType: "calc"
        },
        insiderange: {
          valType: "info_array",
          items: [
            { valType: "any", editType: "plot" },
            { valType: "any", editType: "plot" }
          ],
          editType: "plot"
        },
        // scaleanchor: not used directly, just put here for reference
        // values are any opposite-letter axis id, or `false`.
        scaleanchor: {
          valType: "enumerated",
          values: [
            constants.idRegex.x.toString(),
            constants.idRegex.y.toString(),
            false
          ],
          editType: "plot"
        },
        scaleratio: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "plot"
        },
        constrain: {
          valType: "enumerated",
          values: ["range", "domain"],
          editType: "plot"
        },
        // constraintoward: not used directly, just put here for reference
        constraintoward: {
          valType: "enumerated",
          values: ["left", "center", "right", "top", "middle", "bottom"],
          editType: "plot"
        },
        matches: {
          valType: "enumerated",
          values: [
            constants.idRegex.x.toString(),
            constants.idRegex.y.toString()
          ],
          editType: "calc"
        },
        rangebreaks: templatedArray("rangebreak", {
          enabled: {
            valType: "boolean",
            dflt: true,
            editType: "calc"
          },
          bounds: {
            valType: "info_array",
            items: [
              { valType: "any", editType: "calc" },
              { valType: "any", editType: "calc" }
            ],
            editType: "calc"
          },
          pattern: {
            valType: "enumerated",
            values: [DAY_OF_WEEK, HOUR, ""],
            editType: "calc"
          },
          values: {
            valType: "info_array",
            freeLength: true,
            editType: "calc",
            items: {
              valType: "any",
              editType: "calc"
            }
          },
          dvalue: {
            // TODO could become 'any' to add support for 'months', 'years'
            valType: "number",
            editType: "calc",
            min: 0,
            dflt: ONEDAY
          },
          /*
          gap: {
              valType: 'number',
              min: 0,
              dflt: 0, // for *date* axes, maybe something else for *linear*
              editType: 'calc',
          },
          gapmode: {
              valType: 'enumerated',
              values: ['pixels', 'fraction'],
              dflt: 'pixels',
              editType: 'calc',
          },
          */
          // To complete https://github.com/plotly/plotly.js/issues/4210
          // we additionally need `gap` and make this work on *linear*, and
          // possibly all other cartesian axis types. We possibly would also need
          // some style attributes controlling the zig-zag on the corresponding
          // axis.
          editType: "calc"
        }),
        // ticks
        tickmode,
        nticks: makeNticks(),
        tick0,
        dtick,
        ticklabelstep: {
          valType: "integer",
          min: 1,
          dflt: 1,
          editType: "ticks"
        },
        tickvals,
        ticktext: {
          valType: "data_array",
          editType: "ticks"
        },
        ticks,
        tickson: {
          valType: "enumerated",
          values: ["labels", "boundaries"],
          dflt: "labels",
          editType: "ticks"
        },
        ticklabelmode: {
          valType: "enumerated",
          values: ["instant", "period"],
          dflt: "instant",
          editType: "ticks"
        },
        // ticklabelposition: not used directly, as values depend on direction (similar to side)
        // left/right options are for x axes, and top/bottom options are for y axes
        ticklabelposition: {
          valType: "enumerated",
          values: [
            "outside",
            "inside",
            "outside top",
            "inside top",
            "outside left",
            "inside left",
            "outside right",
            "inside right",
            "outside bottom",
            "inside bottom"
          ],
          dflt: "outside",
          editType: "calc"
        },
        ticklabeloverflow: {
          valType: "enumerated",
          values: [
            "allow",
            "hide past div",
            "hide past domain"
          ],
          editType: "calc"
        },
        ticklabelshift: {
          valType: "integer",
          dflt: 0,
          editType: "ticks"
        },
        ticklabelstandoff: {
          valType: "integer",
          dflt: 0,
          editType: "ticks"
        },
        ticklabelindex: {
          // in the future maybe add `extras: ['all', 'minor']` to allow showing labels for all ticks
          // or for all minor ticks.
          valType: "integer",
          arrayOk: true,
          editType: "calc"
        },
        mirror: {
          valType: "enumerated",
          values: [true, "ticks", false, "all", "allticks"],
          dflt: false,
          editType: "ticks+layoutstyle"
        },
        ticklen: makeTicklen(),
        tickwidth: makeTickwidth(),
        tickcolor,
        showticklabels: {
          valType: "boolean",
          dflt: true,
          editType: "ticks"
        },
        labelalias: {
          valType: "any",
          dflt: false,
          editType: "ticks"
        },
        automargin: {
          valType: "flaglist",
          flags: ["height", "width", "left", "right", "top", "bottom"],
          extras: [true, false],
          dflt: false,
          editType: "ticks"
        },
        showspikes: {
          valType: "boolean",
          dflt: false,
          editType: "modebar"
        },
        spikecolor: {
          valType: "color",
          dflt: null,
          editType: "none"
        },
        spikethickness: {
          valType: "number",
          dflt: 3,
          editType: "none"
        },
        spikedash: extendFlat({}, dash, { dflt: "dash", editType: "none" }),
        spikemode: {
          valType: "flaglist",
          flags: ["toaxis", "across", "marker"],
          dflt: "toaxis",
          editType: "none"
        },
        spikesnap: {
          valType: "enumerated",
          values: ["data", "cursor", "hovered data"],
          dflt: "hovered data",
          editType: "none"
        },
        tickfont: fontAttrs({
          editType: "ticks"
        }),
        tickangle: {
          valType: "angle",
          dflt: "auto",
          editType: "ticks"
        },
        autotickangles: {
          valType: "info_array",
          freeLength: true,
          items: {
            valType: "angle"
          },
          dflt: [0, 30, 90],
          editType: "ticks"
        },
        tickprefix: {
          valType: "string",
          dflt: "",
          editType: "ticks"
        },
        showtickprefix: {
          valType: "enumerated",
          values: ["all", "first", "last", "none"],
          dflt: "all",
          editType: "ticks"
        },
        ticksuffix: {
          valType: "string",
          dflt: "",
          editType: "ticks"
        },
        showticksuffix: {
          valType: "enumerated",
          values: ["all", "first", "last", "none"],
          dflt: "all",
          editType: "ticks"
        },
        showexponent: {
          valType: "enumerated",
          values: ["all", "first", "last", "none"],
          dflt: "all",
          editType: "ticks"
        },
        exponentformat: {
          valType: "enumerated",
          values: ["none", "e", "E", "power", "SI", "B"],
          dflt: "B",
          editType: "ticks"
        },
        minexponent: {
          valType: "number",
          dflt: 3,
          min: 0,
          editType: "ticks"
        },
        separatethousands: {
          valType: "boolean",
          dflt: false,
          editType: "ticks"
        },
        tickformat: {
          valType: "string",
          dflt: "",
          editType: "ticks",
          description: descriptionWithDates("tick label")
        },
        tickformatstops: templatedArray("tickformatstop", {
          enabled: {
            valType: "boolean",
            dflt: true,
            editType: "ticks"
          },
          dtickrange: {
            valType: "info_array",
            items: [
              { valType: "any", editType: "ticks" },
              { valType: "any", editType: "ticks" }
            ],
            editType: "ticks"
          },
          value: {
            valType: "string",
            dflt: "",
            editType: "ticks"
          },
          editType: "ticks"
        }),
        hoverformat: {
          valType: "string",
          dflt: "",
          editType: "none",
          description: descriptionWithDates("hover text")
        },
        // lines and grids
        showline: {
          valType: "boolean",
          dflt: false,
          editType: "ticks+layoutstyle"
        },
        linecolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "layoutstyle"
        },
        linewidth: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "ticks+layoutstyle"
        },
        showgrid,
        gridcolor,
        gridwidth: makeGridwidth(),
        griddash,
        zeroline: {
          valType: "boolean",
          editType: "ticks"
        },
        zerolinecolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "ticks"
        },
        zerolinewidth: {
          valType: "number",
          dflt: 1,
          editType: "ticks"
        },
        showdividers: {
          valType: "boolean",
          dflt: true,
          editType: "ticks"
        },
        dividercolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "ticks"
        },
        dividerwidth: {
          valType: "number",
          dflt: 1,
          editType: "ticks"
        },
        // TODO dividerlen: that would override "to label base" length?
        // positioning attributes
        // anchor: not used directly, just put here for reference
        // values are any opposite-letter axis id
        anchor: {
          valType: "enumerated",
          values: [
            "free",
            constants.idRegex.x.toString(),
            constants.idRegex.y.toString()
          ],
          editType: "plot"
        },
        // side: not used directly, as values depend on direction
        // values are top, bottom for x axes, and left, right for y
        side: {
          valType: "enumerated",
          values: ["top", "bottom", "left", "right"],
          editType: "plot"
        },
        // overlaying: not used directly, just put here for reference
        // values are false and any other same-letter axis id that's not
        // itself overlaying anything
        overlaying: {
          valType: "enumerated",
          values: [
            "free",
            constants.idRegex.x.toString(),
            constants.idRegex.y.toString()
          ],
          editType: "plot"
        },
        minor: {
          tickmode: minorTickmode,
          nticks: makeNticks("minor"),
          tick0,
          dtick,
          tickvals,
          ticks,
          ticklen: makeTicklen("minor"),
          tickwidth: makeTickwidth("minor"),
          tickcolor,
          gridcolor,
          gridwidth: makeGridwidth("minor"),
          griddash,
          showgrid,
          editType: "ticks"
        },
        layer: {
          valType: "enumerated",
          values: ["above traces", "below traces"],
          dflt: "above traces",
          editType: "plot"
        },
        domain: {
          valType: "info_array",
          items: [
            { valType: "number", min: 0, max: 1, editType: "plot" },
            { valType: "number", min: 0, max: 1, editType: "plot" }
          ],
          dflt: [0, 1],
          editType: "plot"
        },
        position: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 0,
          editType: "plot"
        },
        autoshift: {
          valType: "boolean",
          dflt: false,
          editType: "plot"
        },
        shift: {
          valType: "number",
          editType: "plot"
        },
        categoryorder: {
          valType: "enumerated",
          values: [
            "trace",
            "category ascending",
            "category descending",
            "array",
            "total ascending",
            "total descending",
            "min ascending",
            "min descending",
            "max ascending",
            "max descending",
            "sum ascending",
            "sum descending",
            "mean ascending",
            "mean descending",
            "geometric mean ascending",
            "geometric mean descending",
            "median ascending",
            "median descending"
          ],
          dflt: "trace",
          editType: "calc"
        },
        categoryarray: {
          valType: "data_array",
          editType: "calc"
        },
        uirevision: {
          valType: "any",
          editType: "none"
        },
        editType: "calc"
      };
    }
  });

  // src/components/colorbar/attributes.js
  var require_attributes7 = __commonJS({
    "src/components/colorbar/attributes.js"(exports, module) {
      "use strict";
      var axesAttrs = require_layout_attributes4();
      var fontAttrs = require_font_attributes();
      var extendFlat = require_extend().extendFlat;
      var overrideAll = require_edit_types().overrideAll;
      module.exports = overrideAll({
        orientation: {
          valType: "enumerated",
          values: ["h", "v"],
          dflt: "v"
        },
        thicknessmode: {
          valType: "enumerated",
          values: ["fraction", "pixels"],
          dflt: "pixels"
        },
        thickness: {
          valType: "number",
          min: 0,
          dflt: 30
        },
        lenmode: {
          valType: "enumerated",
          values: ["fraction", "pixels"],
          dflt: "fraction"
        },
        len: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        x: {
          valType: "number"
        },
        xref: {
          valType: "enumerated",
          dflt: "paper",
          values: ["container", "paper"],
          editType: "layoutstyle"
        },
        xanchor: {
          valType: "enumerated",
          values: ["left", "center", "right"]
        },
        xpad: {
          valType: "number",
          min: 0,
          dflt: 10
        },
        y: {
          valType: "number"
        },
        yref: {
          valType: "enumerated",
          dflt: "paper",
          values: ["container", "paper"],
          editType: "layoutstyle"
        },
        yanchor: {
          valType: "enumerated",
          values: ["top", "middle", "bottom"]
        },
        ypad: {
          valType: "number",
          min: 0,
          dflt: 10
        },
        // a possible line around the bar itself
        outlinecolor: axesAttrs.linecolor,
        outlinewidth: axesAttrs.linewidth,
        // Should outlinewidth have {dflt: 0} ?
        // another possible line outside the padding and tick labels
        bordercolor: axesAttrs.linecolor,
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: 0
        },
        bgcolor: {
          valType: "color",
          dflt: "rgba(0,0,0,0)"
        },
        // tick and title properties named and function exactly as in axes
        tickmode: axesAttrs.minor.tickmode,
        nticks: axesAttrs.nticks,
        tick0: axesAttrs.tick0,
        dtick: axesAttrs.dtick,
        tickvals: axesAttrs.tickvals,
        ticktext: axesAttrs.ticktext,
        ticks: extendFlat({}, axesAttrs.ticks, { dflt: "" }),
        ticklabeloverflow: extendFlat({}, axesAttrs.ticklabeloverflow, {}),
        // ticklabelposition: not used directly, as values depend on orientation
        // left/right options are for x axes, and top/bottom options are for y axes
        ticklabelposition: {
          valType: "enumerated",
          values: [
            "outside",
            "inside",
            "outside top",
            "inside top",
            "outside left",
            "inside left",
            "outside right",
            "inside right",
            "outside bottom",
            "inside bottom"
          ],
          dflt: "outside"
        },
        ticklen: axesAttrs.ticklen,
        tickwidth: axesAttrs.tickwidth,
        tickcolor: axesAttrs.tickcolor,
        ticklabelstep: axesAttrs.ticklabelstep,
        showticklabels: axesAttrs.showticklabels,
        labelalias: axesAttrs.labelalias,
        tickfont: fontAttrs({}),
        tickangle: axesAttrs.tickangle,
        tickformat: axesAttrs.tickformat,
        tickformatstops: axesAttrs.tickformatstops,
        tickprefix: axesAttrs.tickprefix,
        showtickprefix: axesAttrs.showtickprefix,
        ticksuffix: axesAttrs.ticksuffix,
        showticksuffix: axesAttrs.showticksuffix,
        separatethousands: axesAttrs.separatethousands,
        exponentformat: axesAttrs.exponentformat,
        minexponent: axesAttrs.minexponent,
        showexponent: axesAttrs.showexponent,
        title: {
          text: {
            valType: "string"
          },
          font: fontAttrs({}),
          side: {
            valType: "enumerated",
            values: ["right", "top", "bottom"]
          }
        }
      }, "colorbars", "from-root");
    }
  });

  // src/components/colorscale/attributes.js
  var require_attributes8 = __commonJS({
    "src/components/colorscale/attributes.js"(exports, module) {
      "use strict";
      var colorbarAttrs = require_attributes7();
      var counterRegex = require_regex().counter;
      var sortObjectKeys = require_sort_object_keys();
      var palettes = require_scales().scales;
      var paletteStr = sortObjectKeys(palettes);
      function code(s) {
        return "`" + s + "`";
      }
      module.exports = function colorScaleAttrs(context, opts) {
        context = context || "";
        opts = opts || {};
        var cLetter = opts.cLetter || "c";
        var onlyIfNumerical = "onlyIfNumerical" in opts ? opts.onlyIfNumerical : Boolean(context);
        var noScale = "noScale" in opts ? opts.noScale : context === "marker.line";
        var showScaleDflt = "showScaleDflt" in opts ? opts.showScaleDflt : cLetter === "z";
        var colorscaleDflt = typeof opts.colorscaleDflt === "string" ? palettes[opts.colorscaleDflt] : null;
        var editTypeOverride = opts.editTypeOverride || "";
        var contextHead = context ? context + "." : "";
        var colorAttr, colorAttrFull;
        if ("colorAttr" in opts) {
          colorAttr = opts.colorAttr;
          colorAttrFull = opts.colorAttr;
        } else {
          colorAttr = { z: "z", c: "color" }[cLetter];
          colorAttrFull = "in " + code(contextHead + colorAttr);
        }
        var effectDesc = onlyIfNumerical ? " Has an effect only if " + colorAttrFull + " is set to a numerical array." : "";
        var auto = cLetter + "auto";
        var min = cLetter + "min";
        var max = cLetter + "max";
        var mid = cLetter + "mid";
        var autoFull = code(contextHead + auto);
        var minFull = code(contextHead + min);
        var maxFull = code(contextHead + max);
        var minmaxFull = minFull + " and " + maxFull;
        var autoImpliedEdits = {};
        autoImpliedEdits[min] = autoImpliedEdits[max] = void 0;
        var minmaxImpliedEdits = {};
        minmaxImpliedEdits[auto] = false;
        var attrs = {};
        if (colorAttr === "color") {
          attrs.color = {
            valType: "color",
            arrayOk: true,
            editType: editTypeOverride || "style"
          };
          if (opts.anim) {
            attrs.color.anim = true;
          }
        }
        attrs[auto] = {
          valType: "boolean",
          dflt: true,
          editType: "calc",
          impliedEdits: autoImpliedEdits
        };
        attrs[min] = {
          valType: "number",
          dflt: null,
          editType: editTypeOverride || "plot",
          impliedEdits: minmaxImpliedEdits
        };
        attrs[max] = {
          valType: "number",
          dflt: null,
          editType: editTypeOverride || "plot",
          impliedEdits: minmaxImpliedEdits
        };
        attrs[mid] = {
          valType: "number",
          dflt: null,
          editType: "calc",
          impliedEdits: autoImpliedEdits
        };
        attrs.colorscale = {
          valType: "colorscale",
          editType: "calc",
          dflt: colorscaleDflt,
          impliedEdits: { autocolorscale: false }
        };
        attrs.autocolorscale = {
          valType: "boolean",
          // gets overrode in 'heatmap' & 'surface' for backwards comp.
          dflt: opts.autoColorDflt === false ? false : true,
          editType: "calc",
          impliedEdits: { colorscale: void 0 }
        };
        attrs.reversescale = {
          valType: "boolean",
          dflt: false,
          editType: "plot"
        };
        if (!noScale) {
          attrs.showscale = {
            valType: "boolean",
            dflt: showScaleDflt,
            editType: "calc"
          };
          attrs.colorbar = colorbarAttrs;
        }
        if (!opts.noColorAxis) {
          attrs.coloraxis = {
            valType: "subplotid",
            regex: counterRegex("coloraxis"),
            dflt: null,
            editType: "calc"
          };
        }
        return attrs;
      };
    }
  });

  // src/components/colorscale/layout_attributes.js
  var require_layout_attributes5 = __commonJS({
    "src/components/colorscale/layout_attributes.js"(exports, module) {
      "use strict";
      var extendFlat = require_extend().extendFlat;
      var colorScaleAttrs = require_attributes8();
      var scales = require_scales().scales;
      module.exports = {
        editType: "calc",
        colorscale: {
          editType: "calc",
          sequential: {
            valType: "colorscale",
            dflt: scales.Reds,
            editType: "calc"
          },
          sequentialminus: {
            valType: "colorscale",
            dflt: scales.Blues,
            editType: "calc"
          },
          diverging: {
            valType: "colorscale",
            dflt: scales.RdBu,
            editType: "calc"
          }
        },
        coloraxis: extendFlat({
          // not really a 'subplot' attribute container,
          // but this is the flag we use to denote attributes that
          // support yaxis, yaxis2, yaxis3, ... counters
          _isSubplotObj: true,
          editType: "calc"
        }, colorScaleAttrs("", {
          colorAttr: "corresponding trace color array(s)",
          noColorAxis: true,
          showScaleDflt: true
        }))
      };
    }
  });

  // src/components/colorbar/has_colorbar.js
  var require_has_colorbar = __commonJS({
    "src/components/colorbar/has_colorbar.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function hasColorbar(container) {
        return Lib.isPlainObject(container.colorbar);
      };
    }
  });

  // src/plots/cartesian/clean_ticks.js
  var require_clean_ticks = __commonJS({
    "src/plots/cartesian/clean_ticks.js"(exports) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var constants = require_numerical();
      var ONEDAY = constants.ONEDAY;
      var ONEWEEK = constants.ONEWEEK;
      exports.dtick = function(dtick, axType) {
        var isLog = axType === "log";
        var isDate = axType === "date";
        var isCat = axType === "category";
        var dtickDflt = isDate ? ONEDAY : 1;
        if (!dtick) return dtickDflt;
        if (isNumeric(dtick)) {
          dtick = Number(dtick);
          if (dtick <= 0) return dtickDflt;
          if (isCat) {
            return Math.max(1, Math.round(dtick));
          }
          if (isDate) {
            return Math.max(0.1, dtick);
          }
          return dtick;
        }
        if (typeof dtick !== "string" || !(isDate || isLog)) {
          return dtickDflt;
        }
        var prefix = dtick.charAt(0);
        var dtickNum = dtick.substr(1);
        dtickNum = isNumeric(dtickNum) ? Number(dtickNum) : 0;
        if (dtickNum <= 0 || !// "M<n>" gives ticks every (integer) n months
        (isDate && prefix === "M" && dtickNum === Math.round(dtickNum) || // "L<f>" gives ticks linearly spaced in data (not in position) every (float) f
        isLog && prefix === "L" || // "D1" gives powers of 10 with all small digits between, "D2" gives only 2 and 5
        isLog && prefix === "D" && (dtickNum === 1 || dtickNum === 2))) {
          return dtickDflt;
        }
        return dtick;
      };
      exports.tick0 = function(tick0, axType, calendar, dtick) {
        if (axType === "date") {
          return Lib.cleanDate(
            tick0,
            Lib.dateTick0(calendar, dtick % ONEWEEK === 0 ? 1 : 0)
          );
        }
        if (dtick === "D1" || dtick === "D2") {
          return void 0;
        }
        return isNumeric(tick0) ? Number(tick0) : 0;
      };
    }
  });

  // src/plots/cartesian/tick_value_defaults.js
  var require_tick_value_defaults = __commonJS({
    "src/plots/cartesian/tick_value_defaults.js"(exports, module) {
      "use strict";
      var cleanTicks = require_clean_ticks();
      var isArrayOrTypedArray = require_lib().isArrayOrTypedArray;
      var isTypedArraySpec = require_array().isTypedArraySpec;
      var decodeTypedArraySpec = require_array().decodeTypedArraySpec;
      module.exports = function handleTickValueDefaults(containerIn, containerOut, coerce, axType, opts) {
        if (!opts) opts = {};
        var isMinor = opts.isMinor;
        var cIn = isMinor ? containerIn.minor || {} : containerIn;
        var cOut = isMinor ? containerOut.minor : containerOut;
        var prefix = isMinor ? "minor." : "";
        function readInput(attr) {
          var v = cIn[attr];
          if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
          return v !== void 0 ? v : (cOut._template || {})[attr];
        }
        var _tick0 = readInput("tick0");
        var _dtick = readInput("dtick");
        var _tickvals = readInput("tickvals");
        var tickmodeDefault = isArrayOrTypedArray(_tickvals) ? "array" : _dtick ? "linear" : "auto";
        var tickmode = coerce(prefix + "tickmode", tickmodeDefault);
        if (tickmode === "auto" || tickmode === "sync") {
          coerce(prefix + "nticks");
        } else if (tickmode === "linear") {
          var dtick = cOut.dtick = cleanTicks.dtick(
            _dtick,
            axType
          );
          cOut.tick0 = cleanTicks.tick0(
            _tick0,
            axType,
            containerOut.calendar,
            dtick
          );
        } else if (axType !== "multicategory") {
          var tickvals = coerce(prefix + "tickvals");
          if (tickvals === void 0) cOut.tickmode = "auto";
          else if (!isMinor) coerce("ticktext");
        }
      };
    }
  });

  // src/plots/cartesian/tick_mark_defaults.js
  var require_tick_mark_defaults = __commonJS({
    "src/plots/cartesian/tick_mark_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var layoutAttributes = require_layout_attributes4();
      module.exports = function handleTickMarkDefaults(containerIn, containerOut, coerce, options) {
        var isMinor = options.isMinor;
        var cIn = isMinor ? containerIn.minor || {} : containerIn;
        var cOut = isMinor ? containerOut.minor : containerOut;
        var lAttr = isMinor ? layoutAttributes.minor : layoutAttributes;
        var prefix = isMinor ? "minor." : "";
        var tickLen = Lib.coerce2(cIn, cOut, lAttr, "ticklen", isMinor ? (containerOut.ticklen || 5) * 0.6 : void 0);
        var tickWidth = Lib.coerce2(cIn, cOut, lAttr, "tickwidth", isMinor ? containerOut.tickwidth || 1 : void 0);
        var tickColor = Lib.coerce2(cIn, cOut, lAttr, "tickcolor", (isMinor ? containerOut.tickcolor : void 0) || cOut.color);
        var showTicks = coerce(prefix + "ticks", !isMinor && options.outerTicks || tickLen || tickWidth || tickColor ? "outside" : "");
        if (!showTicks) {
          delete cOut.ticklen;
          delete cOut.tickwidth;
          delete cOut.tickcolor;
        }
      };
    }
  });

  // src/plots/cartesian/show_dflt.js
  var require_show_dflt = __commonJS({
    "src/plots/cartesian/show_dflt.js"(exports, module) {
      "use strict";
      module.exports = function getShowAttrDflt(containerIn) {
        var showAttrsAll = ["showexponent", "showtickprefix", "showticksuffix"];
        var showAttrs = showAttrsAll.filter(function(a) {
          return containerIn[a] !== void 0;
        });
        var sameVal = function(a) {
          return containerIn[a] === containerIn[showAttrs[0]];
        };
        if (showAttrs.every(sameVal) || showAttrs.length === 1) {
          return containerIn[showAttrs[0]];
        }
      };
    }
  });

  // src/plots/array_container_defaults.js
  var require_array_container_defaults = __commonJS({
    "src/plots/array_container_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Template = require_plot_template();
      module.exports = function handleArrayContainerDefaults(parentObjIn, parentObjOut, opts) {
        var name = opts.name;
        var inclusionAttr = opts.inclusionAttr || "visible";
        var previousContOut = parentObjOut[name];
        var contIn = Lib.isArrayOrTypedArray(parentObjIn[name]) ? parentObjIn[name] : [];
        var contOut = parentObjOut[name] = [];
        var templater = Template.arrayTemplater(parentObjOut, name, inclusionAttr);
        var i, itemOut;
        for (i = 0; i < contIn.length; i++) {
          var itemIn = contIn[i];
          if (!Lib.isPlainObject(itemIn)) {
            itemOut = templater.newItem({});
            itemOut[inclusionAttr] = false;
          } else {
            itemOut = templater.newItem(itemIn);
          }
          itemOut._index = i;
          if (itemOut[inclusionAttr] !== false) {
            opts.handleItemDefaults(itemIn, itemOut, parentObjOut, opts);
          }
          contOut.push(itemOut);
        }
        var defaultItems = templater.defaultItems();
        for (i = 0; i < defaultItems.length; i++) {
          itemOut = defaultItems[i];
          itemOut._index = contOut.length;
          opts.handleItemDefaults({}, itemOut, parentObjOut, opts, {});
          contOut.push(itemOut);
        }
        if (Lib.isArrayOrTypedArray(previousContOut)) {
          var len = Math.min(previousContOut.length, contOut.length);
          for (i = 0; i < len; i++) {
            Lib.relinkPrivateKeys(contOut[i], previousContOut[i]);
          }
        }
        return contOut;
      };
    }
  });

  // src/plots/cartesian/tick_label_defaults.js
  var require_tick_label_defaults = __commonJS({
    "src/plots/cartesian/tick_label_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var contrast = require_color().contrast;
      var layoutAttributes = require_layout_attributes4();
      var getShowAttrDflt = require_show_dflt();
      var handleArrayContainerDefaults = require_array_container_defaults();
      module.exports = function handleTickLabelDefaults(containerIn, containerOut, coerce, axType, options) {
        if (!options) options = {};
        var labelalias = coerce("labelalias");
        if (!Lib.isPlainObject(labelalias)) delete containerOut.labelalias;
        var showAttrDflt = getShowAttrDflt(containerIn);
        var showTickLabels = coerce("showticklabels");
        if (showTickLabels) {
          if (!options.noTicklabelshift) {
            coerce("ticklabelshift");
          }
          if (!options.noTicklabelstandoff) {
            coerce("ticklabelstandoff");
          }
          var font = options.font || {};
          var contColor = containerOut.color;
          var position = containerOut.ticklabelposition || "";
          var dfltFontColor = position.indexOf("inside") !== -1 ? contrast(options.bgColor) : (
            // as with title.font.color, inherit axis.color only if one was
            // explicitly provided
            contColor && contColor !== layoutAttributes.color.dflt ? contColor : font.color
          );
          Lib.coerceFont(coerce, "tickfont", font, { overrideDflt: {
            color: dfltFontColor
          } });
          if (!options.noTicklabelstep && axType !== "multicategory" && axType !== "log") {
            coerce("ticklabelstep");
          }
          if (!options.noAng) {
            var tickAngle = coerce("tickangle");
            if (!options.noAutotickangles && tickAngle === "auto") {
              coerce("autotickangles");
            }
          }
          if (axType !== "category") {
            var tickFormat = coerce("tickformat");
            handleArrayContainerDefaults(containerIn, containerOut, {
              name: "tickformatstops",
              inclusionAttr: "enabled",
              handleItemDefaults: tickformatstopDefaults
            });
            if (!containerOut.tickformatstops.length) {
              delete containerOut.tickformatstops;
            }
            if (!options.noExp && !tickFormat && axType !== "date") {
              coerce("showexponent", showAttrDflt);
              coerce("exponentformat");
              coerce("minexponent");
              coerce("separatethousands");
            }
          }
        }
      };
      function tickformatstopDefaults(valueIn, valueOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(valueIn, valueOut, layoutAttributes.tickformatstops, attr, dflt);
        }
        var enabled = coerce("enabled");
        if (enabled) {
          coerce("dtickrange");
          coerce("value");
        }
      }
    }
  });

  // src/plots/cartesian/prefix_suffix_defaults.js
  var require_prefix_suffix_defaults = __commonJS({
    "src/plots/cartesian/prefix_suffix_defaults.js"(exports, module) {
      "use strict";
      var getShowAttrDflt = require_show_dflt();
      module.exports = function handlePrefixSuffixDefaults(containerIn, containerOut, coerce, axType, options) {
        if (!options) options = {};
        var tickSuffixDflt = options.tickSuffixDflt;
        var showAttrDflt = getShowAttrDflt(containerIn);
        var tickPrefix = coerce("tickprefix");
        if (tickPrefix) coerce("showtickprefix", showAttrDflt);
        var tickSuffix = coerce("ticksuffix", tickSuffixDflt);
        if (tickSuffix) coerce("showticksuffix", showAttrDflt);
      };
    }
  });

  // src/components/colorbar/defaults.js
  var require_defaults = __commonJS({
    "src/components/colorbar/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Template = require_plot_template();
      var handleTickValueDefaults = require_tick_value_defaults();
      var handleTickMarkDefaults = require_tick_mark_defaults();
      var handleTickLabelDefaults = require_tick_label_defaults();
      var handlePrefixSuffixDefaults = require_prefix_suffix_defaults();
      var attributes = require_attributes7();
      module.exports = function colorbarDefaults(containerIn, containerOut, layout) {
        var colorbarOut = Template.newContainer(containerOut, "colorbar");
        var colorbarIn = containerIn.colorbar || {};
        function coerce(attr, dflt) {
          return Lib.coerce(colorbarIn, colorbarOut, attributes, attr, dflt);
        }
        var margin = layout.margin || { t: 0, b: 0, l: 0, r: 0 };
        var w = layout.width - margin.l - margin.r;
        var h = layout.height - margin.t - margin.b;
        var orientation = coerce("orientation");
        var isVertical = orientation === "v";
        var thicknessmode = coerce("thicknessmode");
        coerce(
          "thickness",
          thicknessmode === "fraction" ? 30 / (isVertical ? w : h) : 30
        );
        var lenmode = coerce("lenmode");
        coerce(
          "len",
          lenmode === "fraction" ? 1 : isVertical ? h : w
        );
        var yref = coerce("yref");
        var xref = coerce("xref");
        var isPaperY = yref === "paper";
        var isPaperX = xref === "paper";
        var defaultX, defaultY, defaultYAnchor;
        var defaultXAnchor = "left";
        if (isVertical) {
          defaultYAnchor = "middle";
          defaultXAnchor = isPaperX ? "left" : "right";
          defaultX = isPaperX ? 1.02 : 1;
          defaultY = 0.5;
        } else {
          defaultYAnchor = isPaperY ? "bottom" : "top";
          defaultXAnchor = "center";
          defaultX = 0.5;
          defaultY = isPaperY ? 1.02 : 1;
        }
        Lib.coerce(colorbarIn, colorbarOut, {
          x: {
            valType: "number",
            min: isPaperX ? -2 : 0,
            max: isPaperX ? 3 : 1,
            dflt: defaultX
          }
        }, "x");
        Lib.coerce(colorbarIn, colorbarOut, {
          y: {
            valType: "number",
            min: isPaperY ? -2 : 0,
            max: isPaperY ? 3 : 1,
            dflt: defaultY
          }
        }, "y");
        coerce("xanchor", defaultXAnchor);
        coerce("xpad");
        coerce("yanchor", defaultYAnchor);
        coerce("ypad");
        Lib.noneOrAll(colorbarIn, colorbarOut, ["x", "y"]);
        coerce("outlinecolor");
        coerce("outlinewidth");
        coerce("bordercolor");
        coerce("borderwidth");
        coerce("bgcolor");
        var ticklabelposition = Lib.coerce(colorbarIn, colorbarOut, {
          ticklabelposition: {
            valType: "enumerated",
            dflt: "outside",
            values: isVertical ? [
              "outside",
              "inside",
              "outside top",
              "inside top",
              "outside bottom",
              "inside bottom"
            ] : [
              "outside",
              "inside",
              "outside left",
              "inside left",
              "outside right",
              "inside right"
            ]
          }
        }, "ticklabelposition");
        coerce("ticklabeloverflow", ticklabelposition.indexOf("inside") !== -1 ? "hide past domain" : "hide past div");
        handleTickValueDefaults(colorbarIn, colorbarOut, coerce, "linear");
        var font = layout.font;
        var opts = {
          noAutotickangles: true,
          noTicklabelshift: true,
          noTicklabelstandoff: true,
          outerTicks: false,
          font
        };
        if (ticklabelposition.indexOf("inside") !== -1) {
          opts.bgColor = "black";
        }
        handlePrefixSuffixDefaults(colorbarIn, colorbarOut, coerce, "linear", opts);
        handleTickLabelDefaults(colorbarIn, colorbarOut, coerce, "linear", opts);
        handleTickMarkDefaults(colorbarIn, colorbarOut, coerce, "linear", opts);
        coerce("title.text", layout._dfltTitle.colorbar);
        var tickFont = colorbarOut.showticklabels ? colorbarOut.tickfont : font;
        var dfltTitleFont = Lib.extendFlat({}, font, {
          family: tickFont.family,
          size: Lib.bigFont(tickFont.size)
        });
        Lib.coerceFont(coerce, "title.font", dfltTitleFont);
        coerce("title.side", isVertical ? "top" : "right");
      };
    }
  });

  // src/components/colorscale/defaults.js
  var require_defaults2 = __commonJS({
    "src/components/colorscale/defaults.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var hasColorbar = require_has_colorbar();
      var colorbarDefaults = require_defaults();
      var isValidScale = require_scales().isValid;
      var traceIs = require_registry().traceIs;
      function npMaybe(parentCont, prefix) {
        var containerStr = prefix.slice(0, prefix.length - 1);
        return prefix ? Lib.nestedProperty(parentCont, containerStr).get() || {} : parentCont;
      }
      module.exports = function colorScaleDefaults(parentContIn, parentContOut, layout, coerce, opts) {
        var prefix = opts.prefix;
        var cLetter = opts.cLetter;
        var inTrace = "_module" in parentContOut;
        var containerIn = npMaybe(parentContIn, prefix);
        var containerOut = npMaybe(parentContOut, prefix);
        var template = npMaybe(parentContOut._template || {}, prefix) || {};
        var thisFn = function() {
          delete parentContIn.coloraxis;
          delete parentContOut.coloraxis;
          return colorScaleDefaults(parentContIn, parentContOut, layout, coerce, opts);
        };
        if (inTrace) {
          var colorAxes = layout._colorAxes || {};
          var colorAx = coerce(prefix + "coloraxis");
          if (colorAx) {
            var colorbarVisuals = traceIs(parentContOut, "contour") && Lib.nestedProperty(parentContOut, "contours.coloring").get() || "heatmap";
            var stash = colorAxes[colorAx];
            if (stash) {
              stash[2].push(thisFn);
              if (stash[0] !== colorbarVisuals) {
                stash[0] = false;
                Lib.warn([
                  "Ignoring coloraxis:",
                  colorAx,
                  "setting",
                  "as it is linked to incompatible colorscales."
                ].join(" "));
              }
            } else {
              colorAxes[colorAx] = [colorbarVisuals, parentContOut, [thisFn]];
            }
            return;
          }
        }
        var minIn = containerIn[cLetter + "min"];
        var maxIn = containerIn[cLetter + "max"];
        var validMinMax = isNumeric(minIn) && isNumeric(maxIn) && minIn < maxIn;
        var auto = coerce(prefix + cLetter + "auto", !validMinMax);
        if (auto) {
          coerce(prefix + cLetter + "mid");
        } else {
          coerce(prefix + cLetter + "min");
          coerce(prefix + cLetter + "max");
        }
        var sclIn = containerIn.colorscale;
        var sclTemplate = template.colorscale;
        var autoColorscaleDflt;
        if (sclIn !== void 0) autoColorscaleDflt = !isValidScale(sclIn);
        if (sclTemplate !== void 0) autoColorscaleDflt = !isValidScale(sclTemplate);
        coerce(prefix + "autocolorscale", autoColorscaleDflt);
        coerce(prefix + "colorscale");
        coerce(prefix + "reversescale");
        if (prefix !== "marker.line.") {
          var showScaleDflt;
          if (prefix && inTrace) showScaleDflt = hasColorbar(containerIn);
          var showScale = coerce(prefix + "showscale", showScaleDflt);
          if (showScale) {
            if (prefix && template) containerOut._template = template;
            colorbarDefaults(containerIn, containerOut, layout);
          }
        }
      };
    }
  });

  // src/components/colorscale/layout_defaults.js
  var require_layout_defaults = __commonJS({
    "src/components/colorscale/layout_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Template = require_plot_template();
      var colorScaleAttrs = require_layout_attributes5();
      var colorScaleDefaults = require_defaults2();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, colorScaleAttrs, attr, dflt);
        }
        coerce("colorscale.sequential");
        coerce("colorscale.sequentialminus");
        coerce("colorscale.diverging");
        var colorAxes = layoutOut._colorAxes;
        var colorAxIn, colorAxOut;
        function coerceAx(attr, dflt) {
          return Lib.coerce(colorAxIn, colorAxOut, colorScaleAttrs.coloraxis, attr, dflt);
        }
        for (var k in colorAxes) {
          var stash = colorAxes[k];
          if (stash[0]) {
            colorAxIn = layoutIn[k] || {};
            colorAxOut = Template.newContainer(layoutOut, k, "coloraxis");
            colorAxOut._name = k;
            colorScaleDefaults(colorAxIn, colorAxOut, layoutOut, coerceAx, { prefix: "", cLetter: "c" });
          } else {
            for (var i = 0; i < stash[2].length; i++) {
              stash[2][i]();
            }
            delete layoutOut._colorAxes[k];
          }
        }
      };
    }
  });

  // src/components/colorscale/cross_trace_defaults.js
  var require_cross_trace_defaults = __commonJS({
    "src/components/colorscale/cross_trace_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var hasColorscale = require_helpers().hasColorscale;
      var extractOpts = require_helpers().extractOpts;
      module.exports = function crossTraceDefaults(fullData, fullLayout) {
        function replace(cont, k2) {
          var val = cont["_" + k2];
          if (val !== void 0) {
            cont[k2] = val;
          }
        }
        function relinkColorAttrs(outerCont, cbOpt) {
          var cont = cbOpt.container ? Lib.nestedProperty(outerCont, cbOpt.container).get() : outerCont;
          if (cont) {
            if (cont.coloraxis) {
              cont._colorAx = fullLayout[cont.coloraxis];
            } else {
              var cOpts = extractOpts(cont);
              var isAuto = cOpts.auto;
              if (isAuto || cOpts.min === void 0) {
                replace(cont, cbOpt.min);
              }
              if (isAuto || cOpts.max === void 0) {
                replace(cont, cbOpt.max);
              }
              if (cOpts.autocolorscale) {
                replace(cont, "colorscale");
              }
            }
          }
        }
        for (var i = 0; i < fullData.length; i++) {
          var trace = fullData[i];
          var cbOpts = trace._module.colorbar;
          if (cbOpts) {
            if (Array.isArray(cbOpts)) {
              for (var j = 0; j < cbOpts.length; j++) {
                relinkColorAttrs(trace, cbOpts[j]);
              }
            } else {
              relinkColorAttrs(trace, cbOpts);
            }
          }
          if (hasColorscale(trace, "marker.line")) {
            relinkColorAttrs(trace, {
              container: "marker.line",
              min: "cmin",
              max: "cmax"
            });
          }
        }
        for (var k in fullLayout._colorAxes) {
          relinkColorAttrs(fullLayout[k], { min: "cmin", max: "cmax" });
        }
      };
    }
  });

  // src/components/colorscale/calc.js
  var require_calc = __commonJS({
    "src/components/colorscale/calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var extractOpts = require_helpers().extractOpts;
      module.exports = function calc(gd, trace, opts) {
        var fullLayout = gd._fullLayout;
        var vals = opts.vals;
        var containerStr = opts.containerStr;
        var container = containerStr ? Lib.nestedProperty(trace, containerStr).get() : trace;
        var cOpts = extractOpts(container);
        var auto = cOpts.auto !== false;
        var min = cOpts.min;
        var max = cOpts.max;
        var mid = cOpts.mid;
        var minVal = function() {
          return Lib.aggNums(Math.min, null, vals);
        };
        var maxVal = function() {
          return Lib.aggNums(Math.max, null, vals);
        };
        if (min === void 0) {
          min = minVal();
        } else if (auto) {
          if (container._colorAx && isNumeric(min)) {
            min = Math.min(min, minVal());
          } else {
            min = minVal();
          }
        }
        if (max === void 0) {
          max = maxVal();
        } else if (auto) {
          if (container._colorAx && isNumeric(max)) {
            max = Math.max(max, maxVal());
          } else {
            max = maxVal();
          }
        }
        if (auto && mid !== void 0) {
          if (max - mid > mid - min) {
            min = mid - (max - mid);
          } else if (max - mid < mid - min) {
            max = mid + (mid - min);
          }
        }
        if (min === max) {
          min -= 0.5;
          max += 0.5;
        }
        cOpts._sync("min", min);
        cOpts._sync("max", max);
        if (cOpts.autocolorscale) {
          var scl;
          if (min * max < 0) scl = fullLayout.colorscale.diverging;
          else if (min >= 0) scl = fullLayout.colorscale.sequential;
          else scl = fullLayout.colorscale.sequentialminus;
          cOpts._sync("colorscale", scl);
        }
      };
    }
  });

  // src/components/colorscale/index.js
  var require_colorscale = __commonJS({
    "src/components/colorscale/index.js"(exports, module) {
      "use strict";
      var scales = require_scales();
      var helpers = require_helpers();
      module.exports = {
        moduleType: "component",
        name: "colorscale",
        attributes: require_attributes8(),
        layoutAttributes: require_layout_attributes5(),
        supplyLayoutDefaults: require_layout_defaults(),
        handleDefaults: require_defaults2(),
        crossTraceDefaults: require_cross_trace_defaults(),
        calc: require_calc(),
        // ./scales.js is required in lib/coerce.js ;
        // it needs to be a separate module to avoid a circular dependency
        scales: scales.scales,
        defaultScale: scales.defaultScale,
        getScale: scales.get,
        isValidScale: scales.isValid,
        hasColorscale: helpers.hasColorscale,
        extractOpts: helpers.extractOpts,
        extractScale: helpers.extractScale,
        flipScale: helpers.flipScale,
        makeColorScaleFunc: helpers.makeColorScaleFunc,
        makeColorScaleFuncFromTrace: helpers.makeColorScaleFuncFromTrace
      };
    }
  });

  // src/traces/scatter/subtypes.js
  var require_subtypes = __commonJS({
    "src/traces/scatter/subtypes.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var isTypedArraySpec = require_array().isTypedArraySpec;
      module.exports = {
        hasLines: function(trace) {
          return trace.visible && trace.mode && trace.mode.indexOf("lines") !== -1;
        },
        hasMarkers: function(trace) {
          return trace.visible && (trace.mode && trace.mode.indexOf("markers") !== -1 || // until splom implements 'mode'
          trace.type === "splom");
        },
        hasText: function(trace) {
          return trace.visible && trace.mode && trace.mode.indexOf("text") !== -1;
        },
        isBubble: function(trace) {
          var marker = trace.marker;
          return Lib.isPlainObject(marker) && (Lib.isArrayOrTypedArray(marker.size) || isTypedArraySpec(marker.size));
        }
      };
    }
  });

  // src/traces/scatter/make_bubble_size_func.js
  var require_make_bubble_size_func = __commonJS({
    "src/traces/scatter/make_bubble_size_func.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      module.exports = function makeBubbleSizeFn(trace, factor) {
        if (!factor) {
          factor = 2;
        }
        var marker = trace.marker;
        var sizeRef = marker.sizeref || 1;
        var sizeMin = marker.sizemin || 0;
        var baseFn = marker.sizemode === "area" ? function(v) {
          return Math.sqrt(v / sizeRef);
        } : function(v) {
          return v / sizeRef;
        };
        return function(v) {
          var baseSize = baseFn(v / factor);
          return isNumeric(baseSize) && baseSize > 0 ? Math.max(baseSize, sizeMin) : 0;
        };
      };
    }
  });

  // src/components/fx/helpers.js
  var require_helpers2 = __commonJS({
    "src/components/fx/helpers.js"(exports) {
      "use strict";
      var Lib = require_lib();
      exports.getSubplot = function(trace) {
        return trace.subplot || trace.xaxis + trace.yaxis || trace.geo;
      };
      exports.isTraceInSubplots = function(trace, subplots) {
        if (trace.type === "splom") {
          var xaxes = trace.xaxes || [];
          var yaxes = trace.yaxes || [];
          for (var i = 0; i < xaxes.length; i++) {
            for (var j = 0; j < yaxes.length; j++) {
              if (subplots.indexOf(xaxes[i] + yaxes[j]) !== -1) {
                return true;
              }
            }
          }
          return false;
        }
        return subplots.indexOf(exports.getSubplot(trace)) !== -1;
      };
      exports.flat = function(subplots, v) {
        var out = new Array(subplots.length);
        for (var i = 0; i < subplots.length; i++) {
          out[i] = v;
        }
        return out;
      };
      exports.p2c = function(axArray, v) {
        var out = new Array(axArray.length);
        for (var i = 0; i < axArray.length; i++) {
          out[i] = axArray[i].p2c(v);
        }
        return out;
      };
      exports.getDistanceFunction = function(mode, dx, dy, dxy) {
        if (mode === "closest") return dxy || exports.quadrature(dx, dy);
        return mode.charAt(0) === "x" ? dx : dy;
      };
      exports.getClosest = function(cd, distfn, pointData) {
        if (pointData.index !== false) {
          if (pointData.index >= 0 && pointData.index < cd.length) {
            pointData.distance = 0;
          } else pointData.index = false;
        } else {
          var newDistance = Infinity;
          var len = cd.length;
          for (var i = 0; i < len; i++) {
            newDistance = distfn(cd[i]);
            if (newDistance <= pointData.distance) {
              pointData.index = i;
              pointData.distance = newDistance;
            }
          }
        }
        return pointData;
      };
      exports.inbox = function(v0, v1, passVal) {
        return v0 * v1 < 0 || v0 === 0 ? passVal : Infinity;
      };
      exports.quadrature = function(dx, dy) {
        return function(di) {
          var x = dx(di);
          var y = dy(di);
          return Math.sqrt(x * x + y * y);
        };
      };
      exports.makeEventData = function(pt, trace, cd) {
        var pointNumber = "index" in pt ? pt.index : pt.pointNumber;
        var out = {
          data: trace._input,
          fullData: trace,
          curveNumber: trace.index,
          pointNumber
        };
        if (trace._indexToPoints) {
          var pointIndices = trace._indexToPoints[pointNumber];
          if (pointIndices.length === 1) {
            out.pointIndex = pointIndices[0];
          } else {
            out.pointIndices = pointIndices;
          }
        } else {
          out.pointIndex = pointNumber;
        }
        if (trace._module.eventData) {
          out = trace._module.eventData(out, pt, trace, cd, pointNumber);
        } else {
          if ("xVal" in pt) out.x = pt.xVal;
          else if ("x" in pt) out.x = pt.x;
          if ("yVal" in pt) out.y = pt.yVal;
          else if ("y" in pt) out.y = pt.y;
          if (pt.xa) out.xaxis = pt.xa;
          if (pt.ya) out.yaxis = pt.ya;
          if (pt.zLabelVal !== void 0) out.z = pt.zLabelVal;
        }
        exports.appendArrayPointValue(out, trace, pointNumber);
        return out;
      };
      exports.appendArrayPointValue = function(pointData, trace, pointNumber) {
        var arrayAttrs = trace._arrayAttrs;
        if (!arrayAttrs) {
          return;
        }
        for (var i = 0; i < arrayAttrs.length; i++) {
          var astr = arrayAttrs[i];
          var key = getPointKey(astr);
          if (pointData[key] === void 0) {
            var val = Lib.nestedProperty(trace, astr).get();
            var pointVal = getPointData(val, pointNumber);
            if (pointVal !== void 0) pointData[key] = pointVal;
          }
        }
      };
      exports.appendArrayMultiPointValues = function(pointData, trace, pointNumbers) {
        var arrayAttrs = trace._arrayAttrs;
        if (!arrayAttrs) {
          return;
        }
        for (var i = 0; i < arrayAttrs.length; i++) {
          var astr = arrayAttrs[i];
          var key = getPointKey(astr);
          if (pointData[key] === void 0) {
            var val = Lib.nestedProperty(trace, astr).get();
            var keyVal = new Array(pointNumbers.length);
            for (var j = 0; j < pointNumbers.length; j++) {
              keyVal[j] = getPointData(val, pointNumbers[j]);
            }
            pointData[key] = keyVal;
          }
        }
      };
      var pointKeyMap = {
        ids: "id",
        locations: "location",
        labels: "label",
        values: "value",
        "marker.colors": "color",
        parents: "parent"
      };
      function getPointKey(astr) {
        return pointKeyMap[astr] || astr;
      }
      function getPointData(val, pointNumber) {
        if (Array.isArray(pointNumber)) {
          if (Array.isArray(val) && Array.isArray(val[pointNumber[0]])) {
            return val[pointNumber[0]][pointNumber[1]];
          }
        } else {
          return val[pointNumber];
        }
      }
      var xyHoverMode = {
        x: true,
        y: true
      };
      var unifiedHoverMode = {
        "x unified": true,
        "y unified": true
      };
      exports.isUnifiedHover = function(hovermode) {
        if (typeof hovermode !== "string") return false;
        return !!unifiedHoverMode[hovermode];
      };
      exports.isXYhover = function(hovermode) {
        if (typeof hovermode !== "string") return false;
        return !!xyHoverMode[hovermode];
      };
    }
  });

  // node_modules/parse-svg-path/index.js
  var require_parse_svg_path = __commonJS({
    "node_modules/parse-svg-path/index.js"(exports, module) {
      module.exports = parse;
      var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
      var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      function parse(path) {
        var data = [];
        path.replace(segment, function(_, command, args) {
          var type = command.toLowerCase();
          args = parseValues(args);
          if (type == "m" && args.length > 2) {
            data.push([command].concat(args.splice(0, 2)));
            type = "l";
            command = command == "m" ? "l" : "L";
          }
          while (true) {
            if (args.length == length[type]) {
              args.unshift(command);
              return data.push(args);
            }
            if (args.length < length[type]) throw new Error("malformed path data");
            data.push([command].concat(args.splice(0, length[type])));
          }
        });
        return data;
      }
      var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
      function parseValues(args) {
        var numbers = args.match(number);
        return numbers ? numbers.map(Number) : [];
      }
    }
  });

  // src/components/drawing/symbol_defs.js
  var require_symbol_defs = __commonJS({
    "src/components/drawing/symbol_defs.js"(exports, module) {
      "use strict";
      var parseSvgPath = require_parse_svg_path();
      var round = (
        // require('@plotly/d3').round;
        function(x, n) {
          return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
        }
      );
      var emptyPath = "M0,0Z";
      var sqrt2 = Math.sqrt(2);
      var sqrt3 = Math.sqrt(3);
      var PI = Math.PI;
      var cos = Math.cos;
      var sin = Math.sin;
      module.exports = {
        circle: {
          n: 0,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            var circle = "M" + rs + ",0A" + rs + "," + rs + " 0 1,1 0,-" + rs + "A" + rs + "," + rs + " 0 0,1 " + rs + ",0Z";
            return standoff ? align(angle, standoff, circle) : circle;
          }
        },
        square: {
          n: 1,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M" + rs + "," + rs + "H-" + rs + "V-" + rs + "H" + rs + "Z");
          }
        },
        diamond: {
          n: 2,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rd = round(r * 1.3, 2);
            return align(angle, standoff, "M" + rd + ",0L0," + rd + "L-" + rd + ",0L0,-" + rd + "Z");
          }
        },
        cross: {
          n: 3,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rc = round(r * 0.4, 2);
            var rc2 = round(r * 1.2, 2);
            return align(angle, standoff, "M" + rc2 + "," + rc + "H" + rc + "V" + rc2 + "H-" + rc + "V" + rc + "H-" + rc2 + "V-" + rc + "H-" + rc + "V-" + rc2 + "H" + rc + "V-" + rc + "H" + rc2 + "Z");
          }
        },
        x: {
          n: 4,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r * 0.8 / sqrt2, 2);
            var ne = "l" + rx + "," + rx;
            var se = "l" + rx + ",-" + rx;
            var sw = "l-" + rx + ",-" + rx;
            var nw = "l-" + rx + "," + rx;
            return align(angle, standoff, "M0," + rx + ne + se + sw + se + sw + nw + sw + nw + ne + nw + ne + "Z");
          }
        },
        "triangle-up": {
          n: 5,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rt = round(r * 2 / sqrt3, 2);
            var r2 = round(r / 2, 2);
            var rs = round(r, 2);
            return align(angle, standoff, "M-" + rt + "," + r2 + "H" + rt + "L0,-" + rs + "Z");
          }
        },
        "triangle-down": {
          n: 6,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rt = round(r * 2 / sqrt3, 2);
            var r2 = round(r / 2, 2);
            var rs = round(r, 2);
            return align(angle, standoff, "M-" + rt + ",-" + r2 + "H" + rt + "L0," + rs + "Z");
          }
        },
        "triangle-left": {
          n: 7,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rt = round(r * 2 / sqrt3, 2);
            var r2 = round(r / 2, 2);
            var rs = round(r, 2);
            return align(angle, standoff, "M" + r2 + ",-" + rt + "V" + rt + "L-" + rs + ",0Z");
          }
        },
        "triangle-right": {
          n: 8,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rt = round(r * 2 / sqrt3, 2);
            var r2 = round(r / 2, 2);
            var rs = round(r, 2);
            return align(angle, standoff, "M-" + r2 + ",-" + rt + "V" + rt + "L" + rs + ",0Z");
          }
        },
        "triangle-ne": {
          n: 9,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var r1 = round(r * 0.6, 2);
            var r2 = round(r * 1.2, 2);
            return align(angle, standoff, "M-" + r2 + ",-" + r1 + "H" + r1 + "V" + r2 + "Z");
          }
        },
        "triangle-se": {
          n: 10,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var r1 = round(r * 0.6, 2);
            var r2 = round(r * 1.2, 2);
            return align(angle, standoff, "M" + r1 + ",-" + r2 + "V" + r1 + "H-" + r2 + "Z");
          }
        },
        "triangle-sw": {
          n: 11,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var r1 = round(r * 0.6, 2);
            var r2 = round(r * 1.2, 2);
            return align(angle, standoff, "M" + r2 + "," + r1 + "H-" + r1 + "V-" + r2 + "Z");
          }
        },
        "triangle-nw": {
          n: 12,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var r1 = round(r * 0.6, 2);
            var r2 = round(r * 1.2, 2);
            return align(angle, standoff, "M-" + r1 + "," + r2 + "V-" + r1 + "H" + r2 + "Z");
          }
        },
        pentagon: {
          n: 13,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x1 = round(r * 0.951, 2);
            var x2 = round(r * 0.588, 2);
            var y0 = round(-r, 2);
            var y1 = round(r * -0.309, 2);
            var y2 = round(r * 0.809, 2);
            return align(angle, standoff, "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + "H-" + x2 + "L-" + x1 + "," + y1 + "L0," + y0 + "Z");
          }
        },
        hexagon: {
          n: 14,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var y0 = round(r, 2);
            var y1 = round(r / 2, 2);
            var x = round(r * sqrt3 / 2, 2);
            return align(angle, standoff, "M" + x + ",-" + y1 + "V" + y1 + "L0," + y0 + "L-" + x + "," + y1 + "V-" + y1 + "L0,-" + y0 + "Z");
          }
        },
        hexagon2: {
          n: 15,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x0 = round(r, 2);
            var x1 = round(r / 2, 2);
            var y = round(r * sqrt3 / 2, 2);
            return align(angle, standoff, "M-" + x1 + "," + y + "H" + x1 + "L" + x0 + ",0L" + x1 + ",-" + y + "H-" + x1 + "L-" + x0 + ",0Z");
          }
        },
        octagon: {
          n: 16,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var a = round(r * 0.924, 2);
            var b = round(r * 0.383, 2);
            return align(angle, standoff, "M-" + b + ",-" + a + "H" + b + "L" + a + ",-" + b + "V" + b + "L" + b + "," + a + "H-" + b + "L-" + a + "," + b + "V-" + b + "Z");
          }
        },
        star: {
          n: 17,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = r * 1.4;
            var x1 = round(rs * 0.225, 2);
            var x2 = round(rs * 0.951, 2);
            var x3 = round(rs * 0.363, 2);
            var x4 = round(rs * 0.588, 2);
            var y0 = round(-rs, 2);
            var y1 = round(rs * -0.309, 2);
            var y3 = round(rs * 0.118, 2);
            var y4 = round(rs * 0.809, 2);
            var y5 = round(rs * 0.382, 2);
            return align(angle, standoff, "M" + x1 + "," + y1 + "H" + x2 + "L" + x3 + "," + y3 + "L" + x4 + "," + y4 + "L0," + y5 + "L-" + x4 + "," + y4 + "L-" + x3 + "," + y3 + "L-" + x2 + "," + y1 + "H-" + x1 + "L0," + y0 + "Z");
          }
        },
        hexagram: {
          n: 18,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var y = round(r * 0.66, 2);
            var x1 = round(r * 0.38, 2);
            var x2 = round(r * 0.76, 2);
            return align(angle, standoff, "M-" + x2 + ",0l-" + x1 + ",-" + y + "h" + x2 + "l" + x1 + ",-" + y + "l" + x1 + "," + y + "h" + x2 + "l-" + x1 + "," + y + "l" + x1 + "," + y + "h-" + x2 + "l-" + x1 + "," + y + "l-" + x1 + ",-" + y + "h-" + x2 + "Z");
          }
        },
        "star-triangle-up": {
          n: 19,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * sqrt3 * 0.8, 2);
            var y1 = round(r * 0.8, 2);
            var y2 = round(r * 1.6, 2);
            var rc = round(r * 4, 2);
            var aPart = "A " + rc + "," + rc + " 0 0 1 ";
            return align(angle, standoff, "M-" + x + "," + y1 + aPart + x + "," + y1 + aPart + "0,-" + y2 + aPart + "-" + x + "," + y1 + "Z");
          }
        },
        "star-triangle-down": {
          n: 20,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * sqrt3 * 0.8, 2);
            var y1 = round(r * 0.8, 2);
            var y2 = round(r * 1.6, 2);
            var rc = round(r * 4, 2);
            var aPart = "A " + rc + "," + rc + " 0 0 1 ";
            return align(angle, standoff, "M" + x + ",-" + y1 + aPart + "-" + x + ",-" + y1 + aPart + "0," + y2 + aPart + x + ",-" + y1 + "Z");
          }
        },
        "star-square": {
          n: 21,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rp = round(r * 1.1, 2);
            var rc = round(r * 2, 2);
            var aPart = "A " + rc + "," + rc + " 0 0 1 ";
            return align(angle, standoff, "M-" + rp + ",-" + rp + aPart + "-" + rp + "," + rp + aPart + rp + "," + rp + aPart + rp + ",-" + rp + aPart + "-" + rp + ",-" + rp + "Z");
          }
        },
        "star-diamond": {
          n: 22,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rp = round(r * 1.4, 2);
            var rc = round(r * 1.9, 2);
            var aPart = "A " + rc + "," + rc + " 0 0 1 ";
            return align(angle, standoff, "M-" + rp + ",0" + aPart + "0," + rp + aPart + rp + ",0" + aPart + "0,-" + rp + aPart + "-" + rp + ",0Z");
          }
        },
        "diamond-tall": {
          n: 23,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * 0.7, 2);
            var y = round(r * 1.4, 2);
            return align(angle, standoff, "M0," + y + "L" + x + ",0L0,-" + y + "L-" + x + ",0Z");
          }
        },
        "diamond-wide": {
          n: 24,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * 1.4, 2);
            var y = round(r * 0.7, 2);
            return align(angle, standoff, "M0," + y + "L" + x + ",0L0,-" + y + "L-" + x + ",0Z");
          }
        },
        hourglass: {
          n: 25,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M" + rs + "," + rs + "H-" + rs + "L" + rs + ",-" + rs + "H-" + rs + "Z");
          },
          noDot: true
        },
        bowtie: {
          n: 26,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M" + rs + "," + rs + "V-" + rs + "L-" + rs + "," + rs + "V-" + rs + "Z");
          },
          noDot: true
        },
        "circle-cross": {
          n: 27,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M0," + rs + "V-" + rs + "M" + rs + ",0H-" + rs + "M" + rs + ",0A" + rs + "," + rs + " 0 1,1 0,-" + rs + "A" + rs + "," + rs + " 0 0,1 " + rs + ",0Z");
          },
          needLine: true,
          noDot: true
        },
        "circle-x": {
          n: 28,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            var rc = round(r / sqrt2, 2);
            return align(angle, standoff, "M" + rc + "," + rc + "L-" + rc + ",-" + rc + "M" + rc + ",-" + rc + "L-" + rc + "," + rc + "M" + rs + ",0A" + rs + "," + rs + " 0 1,1 0,-" + rs + "A" + rs + "," + rs + " 0 0,1 " + rs + ",0Z");
          },
          needLine: true,
          noDot: true
        },
        "square-cross": {
          n: 29,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M0," + rs + "V-" + rs + "M" + rs + ",0H-" + rs + "M" + rs + "," + rs + "H-" + rs + "V-" + rs + "H" + rs + "Z");
          },
          needLine: true,
          noDot: true
        },
        "square-x": {
          n: 30,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M" + rs + "," + rs + "L-" + rs + ",-" + rs + "M" + rs + ",-" + rs + "L-" + rs + "," + rs + "M" + rs + "," + rs + "H-" + rs + "V-" + rs + "H" + rs + "Z");
          },
          needLine: true,
          noDot: true
        },
        "diamond-cross": {
          n: 31,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rd = round(r * 1.3, 2);
            return align(angle, standoff, "M" + rd + ",0L0," + rd + "L-" + rd + ",0L0,-" + rd + "ZM0,-" + rd + "V" + rd + "M-" + rd + ",0H" + rd);
          },
          needLine: true,
          noDot: true
        },
        "diamond-x": {
          n: 32,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rd = round(r * 1.3, 2);
            var r2 = round(r * 0.65, 2);
            return align(angle, standoff, "M" + rd + ",0L0," + rd + "L-" + rd + ",0L0,-" + rd + "ZM-" + r2 + ",-" + r2 + "L" + r2 + "," + r2 + "M-" + r2 + "," + r2 + "L" + r2 + ",-" + r2);
          },
          needLine: true,
          noDot: true
        },
        "cross-thin": {
          n: 33,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rc = round(r * 1.4, 2);
            return align(angle, standoff, "M0," + rc + "V-" + rc + "M" + rc + ",0H-" + rc);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "x-thin": {
          n: 34,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            return align(angle, standoff, "M" + rx + "," + rx + "L-" + rx + ",-" + rx + "M" + rx + ",-" + rx + "L-" + rx + "," + rx);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        asterisk: {
          n: 35,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rc = round(r * 1.2, 2);
            var rs = round(r * 0.85, 2);
            return align(angle, standoff, "M0," + rc + "V-" + rc + "M" + rc + ",0H-" + rc + "M" + rs + "," + rs + "L-" + rs + ",-" + rs + "M" + rs + ",-" + rs + "L-" + rs + "," + rs);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        hash: {
          n: 36,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var r1 = round(r / 2, 2);
            var r2 = round(r, 2);
            return align(angle, standoff, "M" + r1 + "," + r2 + "V-" + r2 + "M" + (r1 - r2) + ",-" + r2 + "V" + r2 + "M" + r2 + "," + r1 + "H-" + r2 + "M-" + r2 + "," + (r1 - r2) + "H" + r2);
          },
          needLine: true,
          noFill: true
        },
        "y-up": {
          n: 37,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * 1.2, 2);
            var y0 = round(r * 1.6, 2);
            var y1 = round(r * 0.8, 2);
            return align(angle, standoff, "M-" + x + "," + y1 + "L0,0M" + x + "," + y1 + "L0,0M0,-" + y0 + "L0,0");
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "y-down": {
          n: 38,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * 1.2, 2);
            var y0 = round(r * 1.6, 2);
            var y1 = round(r * 0.8, 2);
            return align(angle, standoff, "M-" + x + ",-" + y1 + "L0,0M" + x + ",-" + y1 + "L0,0M0," + y0 + "L0,0");
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "y-left": {
          n: 39,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var y = round(r * 1.2, 2);
            var x0 = round(r * 1.6, 2);
            var x1 = round(r * 0.8, 2);
            return align(angle, standoff, "M" + x1 + "," + y + "L0,0M" + x1 + ",-" + y + "L0,0M-" + x0 + ",0L0,0");
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "y-right": {
          n: 40,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var y = round(r * 1.2, 2);
            var x0 = round(r * 1.6, 2);
            var x1 = round(r * 0.8, 2);
            return align(angle, standoff, "M-" + x1 + "," + y + "L0,0M-" + x1 + ",-" + y + "L0,0M" + x0 + ",0L0,0");
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "line-ew": {
          n: 41,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rc = round(r * 1.4, 2);
            return align(angle, standoff, "M" + rc + ",0H-" + rc);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "line-ns": {
          n: 42,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rc = round(r * 1.4, 2);
            return align(angle, standoff, "M0," + rc + "V-" + rc);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "line-ne": {
          n: 43,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            return align(angle, standoff, "M" + rx + ",-" + rx + "L-" + rx + "," + rx);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "line-nw": {
          n: 44,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            return align(angle, standoff, "M" + rx + "," + rx + "L-" + rx + ",-" + rx);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "arrow-up": {
          n: 45,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            var ry = round(r * 2, 2);
            return align(angle, standoff, "M0,0L-" + rx + "," + ry + "H" + rx + "Z");
          },
          backoff: 1,
          noDot: true
        },
        "arrow-down": {
          n: 46,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            var ry = round(r * 2, 2);
            return align(angle, standoff, "M0,0L-" + rx + ",-" + ry + "H" + rx + "Z");
          },
          noDot: true
        },
        "arrow-left": {
          n: 47,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r * 2, 2);
            var ry = round(r, 2);
            return align(angle, standoff, "M0,0L" + rx + ",-" + ry + "V" + ry + "Z");
          },
          noDot: true
        },
        "arrow-right": {
          n: 48,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r * 2, 2);
            var ry = round(r, 2);
            return align(angle, standoff, "M0,0L-" + rx + ",-" + ry + "V" + ry + "Z");
          },
          noDot: true
        },
        "arrow-bar-up": {
          n: 49,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            var ry = round(r * 2, 2);
            return align(angle, standoff, "M-" + rx + ",0H" + rx + "M0,0L-" + rx + "," + ry + "H" + rx + "Z");
          },
          backoff: 1,
          needLine: true,
          noDot: true
        },
        "arrow-bar-down": {
          n: 50,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            var ry = round(r * 2, 2);
            return align(angle, standoff, "M-" + rx + ",0H" + rx + "M0,0L-" + rx + ",-" + ry + "H" + rx + "Z");
          },
          needLine: true,
          noDot: true
        },
        "arrow-bar-left": {
          n: 51,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r * 2, 2);
            var ry = round(r, 2);
            return align(angle, standoff, "M0,-" + ry + "V" + ry + "M0,0L" + rx + ",-" + ry + "V" + ry + "Z");
          },
          needLine: true,
          noDot: true
        },
        "arrow-bar-right": {
          n: 52,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r * 2, 2);
            var ry = round(r, 2);
            return align(angle, standoff, "M0,-" + ry + "V" + ry + "M0,0L-" + rx + ",-" + ry + "V" + ry + "Z");
          },
          needLine: true,
          noDot: true
        },
        arrow: {
          n: 53,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var headAngle = PI / 2.5;
            var x = 2 * r * cos(headAngle);
            var y = 2 * r * sin(headAngle);
            return align(
              angle,
              standoff,
              "M0,0L" + -x + "," + y + "L" + x + "," + y + "Z"
            );
          },
          backoff: 0.9,
          noDot: true
        },
        "arrow-wide": {
          n: 54,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var headAngle = PI / 4;
            var x = 2 * r * cos(headAngle);
            var y = 2 * r * sin(headAngle);
            return align(
              angle,
              standoff,
              "M0,0L" + -x + "," + y + "A " + 2 * r + "," + 2 * r + " 0 0 1 " + x + "," + y + "Z"
            );
          },
          backoff: 0.4,
          noDot: true
        }
      };
      function skipAngle(angle) {
        return angle === null;
      }
      var lastPathIn;
      var lastPathOut;
      var lastAngle;
      var lastStandoff;
      function align(angle, standoff, path) {
        if ((!angle || angle % 360 === 0) && !standoff) return path;
        if (lastAngle === angle && lastStandoff === standoff && lastPathIn === path) return lastPathOut;
        lastAngle = angle;
        lastStandoff = standoff;
        lastPathIn = path;
        function rotate(t2, xy) {
          var cosT = cos(t2);
          var sinT = sin(t2);
          var x2 = xy[0];
          var y2 = xy[1] + (standoff || 0);
          return [
            x2 * cosT - y2 * sinT,
            x2 * sinT + y2 * cosT
          ];
        }
        var t = angle / 180 * PI;
        var x = 0;
        var y = 0;
        var cmd = parseSvgPath(path);
        var str = "";
        for (var i = 0; i < cmd.length; i++) {
          var cmdI = cmd[i];
          var op = cmdI[0];
          var x0 = x;
          var y0 = y;
          if (op === "M" || op === "L") {
            x = +cmdI[1];
            y = +cmdI[2];
          } else if (op === "m" || op === "l") {
            x += +cmdI[1];
            y += +cmdI[2];
          } else if (op === "H") {
            x = +cmdI[1];
          } else if (op === "h") {
            x += +cmdI[1];
          } else if (op === "V") {
            y = +cmdI[1];
          } else if (op === "v") {
            y += +cmdI[1];
          } else if (op === "A") {
            x = +cmdI[1];
            y = +cmdI[2];
            var E = rotate(t, [+cmdI[6], +cmdI[7]]);
            cmdI[6] = E[0];
            cmdI[7] = E[1];
            cmdI[3] = +cmdI[3] + angle;
          }
          if (op === "H" || op === "V") op = "L";
          if (op === "h" || op === "v") op = "l";
          if (op === "m" || op === "l") {
            x -= x0;
            y -= y0;
          }
          var B = rotate(t, [x, y]);
          if (op === "H" || op === "V") op = "L";
          if (op === "M" || op === "L" || op === "m" || op === "l") {
            cmdI[1] = B[0];
            cmdI[2] = B[1];
          }
          cmdI[0] = op;
          str += cmdI[0] + cmdI.slice(1).join(",");
        }
        lastPathOut = str;
        return str;
      }
    }
  });

  // src/components/drawing/index.js
  var require_drawing = __commonJS({
    "src/components/drawing/index.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var numberFormat = Lib.numberFormat;
      var isNumeric = require_fast_isnumeric();
      var tinycolor = require_tinycolor();
      var Registry = require_registry();
      var Color = require_color();
      var Colorscale = require_colorscale();
      var strTranslate = Lib.strTranslate;
      var svgTextUtils = require_svg_text_utils();
      var xmlnsNamespaces = require_xmlns_namespaces();
      var alignment = require_alignment();
      var LINE_SPACING = alignment.LINE_SPACING;
      var DESELECTDIM = require_interactions().DESELECTDIM;
      var subTypes = require_subtypes();
      var makeBubbleSizeFn = require_make_bubble_size_func();
      var appendArrayPointValue = require_helpers2().appendArrayPointValue;
      var drawing = module.exports = {};
      drawing.font = function(s, font) {
        var variant = font.variant;
        var style = font.style;
        var weight = font.weight;
        var color = font.color;
        var size = font.size;
        var family = font.family;
        var shadow = font.shadow;
        var lineposition = font.lineposition;
        var textcase = font.textcase;
        if (family) s.style("font-family", family);
        if (size + 1) s.style("font-size", size + "px");
        if (color) s.call(Color.fill, color);
        if (weight) s.style("font-weight", weight);
        if (style) s.style("font-style", style);
        if (variant) s.style("font-variant", variant);
        if (textcase) s.style("text-transform", dropNone(textcase2transform(textcase)));
        if (shadow) s.style("text-shadow", shadow === "auto" ? svgTextUtils.makeTextShadow(Color.contrast(color)) : dropNone(shadow));
        if (lineposition) s.style("text-decoration-line", dropNone(lineposition2decorationLine(lineposition)));
      };
      function dropNone(a) {
        return a === "none" ? void 0 : a;
      }
      var textcase2transformOptions = {
        normal: "none",
        lower: "lowercase",
        upper: "uppercase",
        "word caps": "capitalize"
      };
      function textcase2transform(textcase) {
        return textcase2transformOptions[textcase];
      }
      function lineposition2decorationLine(lineposition) {
        return lineposition.replace("under", "underline").replace("over", "overline").replace("through", "line-through").split("+").join(" ");
      }
      drawing.setPosition = function(s, x, y) {
        s.attr("x", x).attr("y", y);
      };
      drawing.setSize = function(s, w, h) {
        s.attr("width", w).attr("height", h);
      };
      drawing.setRect = function(s, x, y, w, h) {
        s.call(drawing.setPosition, x, y).call(drawing.setSize, w, h);
      };
      drawing.translatePoint = function(d, sel, xa, ya) {
        var x = xa.c2p(d.x);
        var y = ya.c2p(d.y);
        if (isNumeric(x) && isNumeric(y) && sel.node()) {
          if (sel.node().nodeName === "text") {
            sel.attr("x", x).attr("y", y);
          } else {
            sel.attr("transform", strTranslate(x, y));
          }
        } else {
          return false;
        }
        return true;
      };
      drawing.translatePoints = function(s, xa, ya) {
        s.each(function(d) {
          var sel = d3.select(this);
          drawing.translatePoint(d, sel, xa, ya);
        });
      };
      drawing.hideOutsideRangePoint = function(d, sel, xa, ya, xcalendar, ycalendar) {
        sel.attr(
          "display",
          xa.isPtWithinRange(d, xcalendar) && ya.isPtWithinRange(d, ycalendar) ? null : "none"
        );
      };
      drawing.hideOutsideRangePoints = function(traceGroups, subplot) {
        if (!subplot._hasClipOnAxisFalse) return;
        var xa = subplot.xaxis;
        var ya = subplot.yaxis;
        traceGroups.each(function(d) {
          var trace = d[0].trace;
          var xcalendar = trace.xcalendar;
          var ycalendar = trace.ycalendar;
          var selector = Registry.traceIs(trace, "bar-like") ? ".bartext" : ".point,.textpoint";
          traceGroups.selectAll(selector).each(function(d2) {
            drawing.hideOutsideRangePoint(d2, d3.select(this), xa, ya, xcalendar, ycalendar);
          });
        });
      };
      drawing.crispRound = function(gd, lineWidth, dflt) {
        if (!lineWidth || !isNumeric(lineWidth)) return dflt || 0;
        if (gd._context.staticPlot) return lineWidth;
        if (lineWidth < 1) return 1;
        return Math.round(lineWidth);
      };
      drawing.singleLineStyle = function(d, s, lw, lc, ld) {
        s.style("fill", "none");
        var line = (((d || [])[0] || {}).trace || {}).line || {};
        var lw1 = lw || line.width || 0;
        var dash = ld || line.dash || "";
        Color.stroke(s, lc || line.color);
        drawing.dashLine(s, dash, lw1);
      };
      drawing.lineGroupStyle = function(s, lw, lc, ld) {
        s.style("fill", "none").each(function(d) {
          var line = (((d || [])[0] || {}).trace || {}).line || {};
          var lw1 = lw || line.width || 0;
          var dash = ld || line.dash || "";
          d3.select(this).call(Color.stroke, lc || line.color).call(drawing.dashLine, dash, lw1);
        });
      };
      drawing.dashLine = function(s, dash, lineWidth) {
        lineWidth = +lineWidth || 0;
        dash = drawing.dashStyle(dash, lineWidth);
        s.style({
          "stroke-dasharray": dash,
          "stroke-width": lineWidth + "px"
        });
      };
      drawing.dashStyle = function(dash, lineWidth) {
        lineWidth = +lineWidth || 1;
        var dlw = Math.max(lineWidth, 3);
        if (dash === "solid") dash = "";
        else if (dash === "dot") dash = dlw + "px," + dlw + "px";
        else if (dash === "dash") dash = 3 * dlw + "px," + 3 * dlw + "px";
        else if (dash === "longdash") dash = 5 * dlw + "px," + 5 * dlw + "px";
        else if (dash === "dashdot") {
          dash = 3 * dlw + "px," + dlw + "px," + dlw + "px," + dlw + "px";
        } else if (dash === "longdashdot") {
          dash = 5 * dlw + "px," + 2 * dlw + "px," + dlw + "px," + 2 * dlw + "px";
        }
        return dash;
      };
      function setFillStyle(sel, trace, gd, forLegend) {
        var markerPattern = trace.fillpattern;
        var fillgradient = trace.fillgradient;
        var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, 0, "");
        if (patternShape) {
          var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, 0, null);
          var patternFGColor = drawing.getPatternAttr(markerPattern.fgcolor, 0, null);
          var patternFGOpacity = markerPattern.fgopacity;
          var patternSize = drawing.getPatternAttr(markerPattern.size, 0, 8);
          var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, 0, 0.3);
          var patternID = trace.uid;
          drawing.pattern(
            sel,
            "point",
            gd,
            patternID,
            patternShape,
            patternSize,
            patternSolidity,
            void 0,
            markerPattern.fillmode,
            patternBGColor,
            patternFGColor,
            patternFGOpacity
          );
        } else if (fillgradient && fillgradient.type !== "none") {
          var direction = fillgradient.type;
          var gradientID = "scatterfill-" + trace.uid;
          if (forLegend) {
            gradientID = "legendfill-" + trace.uid;
          }
          if (!forLegend && (fillgradient.start !== void 0 || fillgradient.stop !== void 0)) {
            var start, stop;
            if (direction === "horizontal") {
              start = {
                x: fillgradient.start,
                y: 0
              };
              stop = {
                x: fillgradient.stop,
                y: 0
              };
            } else if (direction === "vertical") {
              start = {
                x: 0,
                y: fillgradient.start
              };
              stop = {
                x: 0,
                y: fillgradient.stop
              };
            }
            start.x = trace._xA.c2p(
              start.x === void 0 ? trace._extremes.x.min[0].val : start.x,
              true
            );
            start.y = trace._yA.c2p(
              start.y === void 0 ? trace._extremes.y.min[0].val : start.y,
              true
            );
            stop.x = trace._xA.c2p(
              stop.x === void 0 ? trace._extremes.x.max[0].val : stop.x,
              true
            );
            stop.y = trace._yA.c2p(
              stop.y === void 0 ? trace._extremes.y.max[0].val : stop.y,
              true
            );
            sel.call(gradientWithBounds, gd, gradientID, "linear", fillgradient.colorscale, "fill", start, stop, true, false);
          } else {
            if (direction === "horizontal") {
              direction = direction + "reversed";
            }
            sel.call(drawing.gradient, gd, gradientID, direction, fillgradient.colorscale, "fill");
          }
        } else if (trace.fillcolor) {
          sel.call(Color.fill, trace.fillcolor);
        }
      }
      drawing.singleFillStyle = function(sel, gd) {
        var node = d3.select(sel.node());
        var data = node.data();
        var trace = ((data[0] || [])[0] || {}).trace || {};
        setFillStyle(sel, trace, gd, false);
      };
      drawing.fillGroupStyle = function(s, gd, forLegend) {
        s.style("stroke-width", 0).each(function(d) {
          var shape = d3.select(this);
          if (d[0].trace) {
            setFillStyle(shape, d[0].trace, gd, forLegend);
          }
        });
      };
      var SYMBOLDEFS = require_symbol_defs();
      drawing.symbolNames = [];
      drawing.symbolFuncs = [];
      drawing.symbolBackOffs = [];
      drawing.symbolNeedLines = {};
      drawing.symbolNoDot = {};
      drawing.symbolNoFill = {};
      drawing.symbolList = [];
      Object.keys(SYMBOLDEFS).forEach(function(k) {
        var symDef = SYMBOLDEFS[k];
        var n = symDef.n;
        drawing.symbolList.push(
          n,
          String(n),
          k,
          n + 100,
          String(n + 100),
          k + "-open"
        );
        drawing.symbolNames[n] = k;
        drawing.symbolFuncs[n] = symDef.f;
        drawing.symbolBackOffs[n] = symDef.backoff || 0;
        if (symDef.needLine) {
          drawing.symbolNeedLines[n] = true;
        }
        if (symDef.noDot) {
          drawing.symbolNoDot[n] = true;
        } else {
          drawing.symbolList.push(
            n + 200,
            String(n + 200),
            k + "-dot",
            n + 300,
            String(n + 300),
            k + "-open-dot"
          );
        }
        if (symDef.noFill) {
          drawing.symbolNoFill[n] = true;
        }
      });
      var MAXSYMBOL = drawing.symbolNames.length;
      var DOTPATH = "M0,0.5L0.5,0L0,-0.5L-0.5,0Z";
      drawing.symbolNumber = function(v) {
        if (isNumeric(v)) {
          v = +v;
        } else if (typeof v === "string") {
          var vbase = 0;
          if (v.indexOf("-open") > 0) {
            vbase = 100;
            v = v.replace("-open", "");
          }
          if (v.indexOf("-dot") > 0) {
            vbase += 200;
            v = v.replace("-dot", "");
          }
          v = drawing.symbolNames.indexOf(v);
          if (v >= 0) {
            v += vbase;
          }
        }
        return v % 100 >= MAXSYMBOL || v >= 400 ? 0 : Math.floor(Math.max(v, 0));
      };
      function makePointPath(symbolNumber, r, t, s) {
        var base = symbolNumber % 100;
        return drawing.symbolFuncs[base](r, t, s) + (symbolNumber >= 200 ? DOTPATH : "");
      }
      var stopFormatter = numberFormat("~f");
      var gradientInfo = {
        radial: { type: "radial" },
        radialreversed: { type: "radial", reversed: true },
        horizontal: { type: "linear", start: { x: 1, y: 0 }, stop: { x: 0, y: 0 } },
        horizontalreversed: { type: "linear", start: { x: 1, y: 0 }, stop: { x: 0, y: 0 }, reversed: true },
        vertical: { type: "linear", start: { x: 0, y: 1 }, stop: { x: 0, y: 0 } },
        verticalreversed: { type: "linear", start: { x: 0, y: 1 }, stop: { x: 0, y: 0 }, reversed: true }
      };
      drawing.gradient = function(sel, gd, gradientID, type, colorscale, prop) {
        var info = gradientInfo[type];
        return gradientWithBounds(
          sel,
          gd,
          gradientID,
          info.type,
          colorscale,
          prop,
          info.start,
          info.stop,
          false,
          info.reversed
        );
      };
      function gradientWithBounds(sel, gd, gradientID, type, colorscale, prop, start, stop, inUserSpace, reversed) {
        var len = colorscale.length;
        var info;
        if (type === "linear") {
          info = {
            node: "linearGradient",
            attrs: {
              x1: start.x,
              y1: start.y,
              x2: stop.x,
              y2: stop.y,
              gradientUnits: inUserSpace ? "userSpaceOnUse" : "objectBoundingBox"
            },
            reversed
          };
        } else if (type === "radial") {
          info = {
            node: "radialGradient",
            reversed
          };
        }
        var colorStops = new Array(len);
        for (var i = 0; i < len; i++) {
          if (info.reversed) {
            colorStops[len - 1 - i] = [stopFormatter((1 - colorscale[i][0]) * 100), colorscale[i][1]];
          } else {
            colorStops[i] = [stopFormatter(colorscale[i][0] * 100), colorscale[i][1]];
          }
        }
        var fullLayout = gd._fullLayout;
        var fullID = "g" + fullLayout._uid + "-" + gradientID;
        var gradient = fullLayout._defs.select(".gradients").selectAll("#" + fullID).data([type + colorStops.join(";")], Lib.identity);
        gradient.exit().remove();
        gradient.enter().append(info.node).each(function() {
          var el = d3.select(this);
          if (info.attrs) el.attr(info.attrs);
          el.attr("id", fullID);
          var stops = el.selectAll("stop").data(colorStops);
          stops.exit().remove();
          stops.enter().append("stop");
          stops.each(function(d) {
            var tc = tinycolor(d[1]);
            d3.select(this).attr({
              offset: d[0] + "%",
              "stop-color": Color.tinyRGB(tc),
              "stop-opacity": tc.getAlpha()
            });
          });
        });
        sel.style(prop, getFullUrl(fullID, gd)).style(prop + "-opacity", null);
        sel.classed("gradient_filled", true);
      }
      drawing.pattern = function(sel, calledBy, gd, patternID, shape, size, solidity, mcc, fillmode, bgcolor, fgcolor, fgopacity) {
        var isLegend = calledBy === "legend";
        if (mcc) {
          if (fillmode === "overlay") {
            bgcolor = mcc;
            fgcolor = Color.contrast(bgcolor);
          } else {
            bgcolor = void 0;
            fgcolor = mcc;
          }
        }
        var fullLayout = gd._fullLayout;
        var fullID = "p" + fullLayout._uid + "-" + patternID;
        var width, height;
        var linearFn = function(x, x0, x1, y0, y1) {
          return y0 + (y1 - y0) * (x - x0) / (x1 - x0);
        };
        var path, linewidth, radius;
        var patternTag;
        var patternAttrs = {};
        var fgC = tinycolor(fgcolor);
        var fgRGB = Color.tinyRGB(fgC);
        var fgAlpha = fgC.getAlpha();
        var opacity = fgopacity * fgAlpha;
        switch (shape) {
          case "/":
            width = size * Math.sqrt(2);
            height = size * Math.sqrt(2);
            path = "M-" + width / 4 + "," + height / 4 + "l" + width / 2 + ",-" + height / 2 + "M0," + height + "L" + width + ",0M" + width / 4 * 3 + "," + height / 4 * 5 + "l" + width / 2 + ",-" + height / 2;
            linewidth = solidity * size;
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case "\\":
            width = size * Math.sqrt(2);
            height = size * Math.sqrt(2);
            path = "M" + width / 4 * 3 + ",-" + height / 4 + "l" + width / 2 + "," + height / 2 + "M0,0L" + width + "," + height + "M-" + width / 4 + "," + height / 4 * 3 + "l" + width / 2 + "," + height / 2;
            linewidth = solidity * size;
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case "x":
            width = size * Math.sqrt(2);
            height = size * Math.sqrt(2);
            path = "M-" + width / 4 + "," + height / 4 + "l" + width / 2 + ",-" + height / 2 + "M0," + height + "L" + width + ",0M" + width / 4 * 3 + "," + height / 4 * 5 + "l" + width / 2 + ",-" + height / 2 + "M" + width / 4 * 3 + ",-" + height / 4 + "l" + width / 2 + "," + height / 2 + "M0,0L" + width + "," + height + "M-" + width / 4 + "," + height / 4 * 3 + "l" + width / 2 + "," + height / 2;
            linewidth = size - size * Math.sqrt(1 - solidity);
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case "|":
            width = size;
            height = size;
            patternTag = "path";
            path = "M" + width / 2 + ",0L" + width / 2 + "," + height;
            linewidth = solidity * size;
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case "-":
            width = size;
            height = size;
            patternTag = "path";
            path = "M0," + height / 2 + "L" + width + "," + height / 2;
            linewidth = solidity * size;
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case "+":
            width = size;
            height = size;
            patternTag = "path";
            path = "M" + width / 2 + ",0L" + width / 2 + "," + height + "M0," + height / 2 + "L" + width + "," + height / 2;
            linewidth = size - size * Math.sqrt(1 - solidity);
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case ".":
            width = size;
            height = size;
            if (solidity < Math.PI / 4) {
              radius = Math.sqrt(solidity * size * size / Math.PI);
            } else {
              radius = linearFn(solidity, Math.PI / 4, 1, size / 2, size / Math.sqrt(2));
            }
            patternTag = "circle";
            patternAttrs = {
              cx: width / 2,
              cy: height / 2,
              r: radius,
              opacity,
              fill: fgRGB
            };
            break;
        }
        var str = [
          shape || "noSh",
          bgcolor || "noBg",
          fgcolor || "noFg",
          size,
          solidity
        ].join(";");
        var pattern = fullLayout._defs.select(".patterns").selectAll("#" + fullID).data([str], Lib.identity);
        pattern.exit().remove();
        pattern.enter().append("pattern").each(function() {
          var el = d3.select(this);
          el.attr({
            id: fullID,
            width: width + "px",
            height: height + "px",
            patternUnits: "userSpaceOnUse",
            // for legends scale down patterns just a bit so that default size (i.e 8) nicely fit in small icons
            patternTransform: isLegend ? "scale(0.8)" : ""
          });
          if (bgcolor) {
            var bgC = tinycolor(bgcolor);
            var bgRGB = Color.tinyRGB(bgC);
            var bgAlpha = bgC.getAlpha();
            var rects = el.selectAll("rect").data([0]);
            rects.exit().remove();
            rects.enter().append("rect").attr({
              width: width + "px",
              height: height + "px",
              fill: bgRGB,
              "fill-opacity": bgAlpha
            });
          }
          var patterns = el.selectAll(patternTag).data([0]);
          patterns.exit().remove();
          patterns.enter().append(patternTag).attr(patternAttrs);
        });
        sel.style("fill", getFullUrl(fullID, gd)).style("fill-opacity", null);
        sel.classed("pattern_filled", true);
      };
      drawing.initGradients = function(gd) {
        var fullLayout = gd._fullLayout;
        var gradientsGroup = Lib.ensureSingle(fullLayout._defs, "g", "gradients");
        gradientsGroup.selectAll("linearGradient,radialGradient").remove();
        d3.select(gd).selectAll(".gradient_filled").classed("gradient_filled", false);
      };
      drawing.initPatterns = function(gd) {
        var fullLayout = gd._fullLayout;
        var patternsGroup = Lib.ensureSingle(fullLayout._defs, "g", "patterns");
        patternsGroup.selectAll("pattern").remove();
        d3.select(gd).selectAll(".pattern_filled").classed("pattern_filled", false);
      };
      drawing.getPatternAttr = function(mp, i, dflt) {
        if (mp && Lib.isArrayOrTypedArray(mp)) {
          return i < mp.length ? mp[i] : dflt;
        }
        return mp;
      };
      drawing.pointStyle = function(s, trace, gd, pt) {
        if (!s.size()) return;
        var fns = drawing.makePointStyleFns(trace);
        s.each(function(d) {
          drawing.singlePointStyle(d, d3.select(this), trace, fns, gd, pt);
        });
      };
      drawing.singlePointStyle = function(d, sel, trace, fns, gd, pt) {
        var marker = trace.marker;
        var markerLine = marker.line;
        if (pt && pt.i >= 0 && d.i === void 0) d.i = pt.i;
        sel.style(
          "opacity",
          fns.selectedOpacityFn ? fns.selectedOpacityFn(d) : d.mo === void 0 ? marker.opacity : d.mo
        );
        if (fns.ms2mrc) {
          var r;
          if (d.ms === "various" || marker.size === "various") {
            r = 3;
          } else {
            r = fns.ms2mrc(d.ms);
          }
          d.mrc = r;
          if (fns.selectedSizeFn) {
            r = d.mrc = fns.selectedSizeFn(d);
          }
          var x = drawing.symbolNumber(d.mx || marker.symbol) || 0;
          d.om = x % 200 >= 100;
          var angle = getMarkerAngle(d, trace);
          var standoff = getMarkerStandoff(d, trace);
          sel.attr("d", makePointPath(x, r, angle, standoff));
        }
        var perPointGradient = false;
        var fillColor, lineColor, lineWidth;
        if (d.so) {
          lineWidth = markerLine.outlierwidth;
          lineColor = markerLine.outliercolor;
          fillColor = marker.outliercolor;
        } else {
          var markerLineWidth = (markerLine || {}).width;
          lineWidth = (d.mlw + 1 || markerLineWidth + 1 || // TODO: we need the latter for legends... can we get rid of it?
          (d.trace ? (d.trace.marker.line || {}).width : 0) + 1) - 1 || 0;
          if ("mlc" in d) lineColor = d.mlcc = fns.lineScale(d.mlc);
          else if (Lib.isArrayOrTypedArray(markerLine.color)) lineColor = Color.defaultLine;
          else lineColor = markerLine.color;
          if (Lib.isArrayOrTypedArray(marker.color)) {
            fillColor = Color.defaultLine;
            perPointGradient = true;
          }
          if ("mc" in d) {
            fillColor = d.mcc = fns.markerScale(d.mc);
          } else {
            fillColor = marker.color || marker.colors || "rgba(0,0,0,0)";
          }
          if (fns.selectedColorFn) {
            fillColor = fns.selectedColorFn(d);
          }
        }
        if (d.om) {
          sel.call(Color.stroke, fillColor).style({
            "stroke-width": (lineWidth || 1) + "px",
            fill: "none"
          });
        } else {
          sel.style("stroke-width", (d.isBlank ? 0 : lineWidth) + "px");
          var markerGradient = marker.gradient;
          var gradientType = d.mgt;
          if (gradientType) perPointGradient = true;
          else gradientType = markerGradient && markerGradient.type;
          if (Lib.isArrayOrTypedArray(gradientType)) {
            gradientType = gradientType[0];
            if (!gradientInfo[gradientType]) gradientType = 0;
          }
          var markerPattern = marker.pattern;
          var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, d.i, "");
          if (gradientType && gradientType !== "none") {
            var gradientColor = d.mgc;
            if (gradientColor) perPointGradient = true;
            else gradientColor = markerGradient.color;
            var gradientID = trace.uid;
            if (perPointGradient) gradientID += "-" + d.i;
            drawing.gradient(
              sel,
              gd,
              gradientID,
              gradientType,
              [[0, gradientColor], [1, fillColor]],
              "fill"
            );
          } else if (patternShape) {
            var perPointPattern = false;
            var fgcolor = markerPattern.fgcolor;
            if (!fgcolor && pt && pt.color) {
              fgcolor = pt.color;
              perPointPattern = true;
            }
            var patternFGColor = drawing.getPatternAttr(fgcolor, d.i, pt && pt.color || null);
            var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, d.i, null);
            var patternFGOpacity = markerPattern.fgopacity;
            var patternSize = drawing.getPatternAttr(markerPattern.size, d.i, 8);
            var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, d.i, 0.3);
            perPointPattern = perPointPattern || d.mcc || Lib.isArrayOrTypedArray(markerPattern.shape) || Lib.isArrayOrTypedArray(markerPattern.bgcolor) || Lib.isArrayOrTypedArray(markerPattern.fgcolor) || Lib.isArrayOrTypedArray(markerPattern.size) || Lib.isArrayOrTypedArray(markerPattern.solidity);
            var patternID = trace.uid;
            if (perPointPattern) patternID += "-" + d.i;
            drawing.pattern(
              sel,
              "point",
              gd,
              patternID,
              patternShape,
              patternSize,
              patternSolidity,
              d.mcc,
              markerPattern.fillmode,
              patternBGColor,
              patternFGColor,
              patternFGOpacity
            );
          } else {
            Lib.isArrayOrTypedArray(fillColor) ? Color.fill(sel, fillColor[d.i]) : Color.fill(sel, fillColor);
          }
          if (lineWidth) {
            Color.stroke(sel, lineColor);
          }
        }
      };
      drawing.makePointStyleFns = function(trace) {
        var out = {};
        var marker = trace.marker;
        out.markerScale = drawing.tryColorscale(marker, "");
        out.lineScale = drawing.tryColorscale(marker, "line");
        if (Registry.traceIs(trace, "symbols")) {
          out.ms2mrc = subTypes.isBubble(trace) ? makeBubbleSizeFn(trace) : function() {
            return (marker.size || 6) / 2;
          };
        }
        if (trace.selectedpoints) {
          Lib.extendFlat(out, drawing.makeSelectedPointStyleFns(trace));
        }
        return out;
      };
      drawing.makeSelectedPointStyleFns = function(trace) {
        var out = {};
        var selectedAttrs = trace.selected || {};
        var unselectedAttrs = trace.unselected || {};
        var marker = trace.marker || {};
        var selectedMarker = selectedAttrs.marker || {};
        var unselectedMarker = unselectedAttrs.marker || {};
        var mo = marker.opacity;
        var smo = selectedMarker.opacity;
        var usmo = unselectedMarker.opacity;
        var smoIsDefined = smo !== void 0;
        var usmoIsDefined = usmo !== void 0;
        if (Lib.isArrayOrTypedArray(mo) || smoIsDefined || usmoIsDefined) {
          out.selectedOpacityFn = function(d) {
            var base = d.mo === void 0 ? marker.opacity : d.mo;
            if (d.selected) {
              return smoIsDefined ? smo : base;
            } else {
              return usmoIsDefined ? usmo : DESELECTDIM * base;
            }
          };
        }
        var mc = marker.color;
        var smc = selectedMarker.color;
        var usmc = unselectedMarker.color;
        if (smc || usmc) {
          out.selectedColorFn = function(d) {
            var base = d.mcc || mc;
            if (d.selected) {
              return smc || base;
            } else {
              return usmc || base;
            }
          };
        }
        var ms = marker.size;
        var sms = selectedMarker.size;
        var usms = unselectedMarker.size;
        var smsIsDefined = sms !== void 0;
        var usmsIsDefined = usms !== void 0;
        if (Registry.traceIs(trace, "symbols") && (smsIsDefined || usmsIsDefined)) {
          out.selectedSizeFn = function(d) {
            var base = d.mrc || ms / 2;
            if (d.selected) {
              return smsIsDefined ? sms / 2 : base;
            } else {
              return usmsIsDefined ? usms / 2 : base;
            }
          };
        }
        return out;
      };
      drawing.makeSelectedTextStyleFns = function(trace) {
        var out = {};
        var selectedAttrs = trace.selected || {};
        var unselectedAttrs = trace.unselected || {};
        var textFont = trace.textfont || {};
        var selectedTextFont = selectedAttrs.textfont || {};
        var unselectedTextFont = unselectedAttrs.textfont || {};
        var tc = textFont.color;
        var stc = selectedTextFont.color;
        var utc = unselectedTextFont.color;
        out.selectedTextColorFn = function(d) {
          var base = d.tc || tc;
          if (d.selected) {
            return stc || base;
          } else {
            if (utc) return utc;
            else return stc ? base : Color.addOpacity(base, DESELECTDIM);
          }
        };
        return out;
      };
      drawing.selectedPointStyle = function(s, trace) {
        if (!s.size() || !trace.selectedpoints) return;
        var fns = drawing.makeSelectedPointStyleFns(trace);
        var marker = trace.marker || {};
        var seq = [];
        if (fns.selectedOpacityFn) {
          seq.push(function(pt, d) {
            pt.style("opacity", fns.selectedOpacityFn(d));
          });
        }
        if (fns.selectedColorFn) {
          seq.push(function(pt, d) {
            Color.fill(pt, fns.selectedColorFn(d));
          });
        }
        if (fns.selectedSizeFn) {
          seq.push(function(pt, d) {
            var mx = d.mx || marker.symbol || 0;
            var mrc2 = fns.selectedSizeFn(d);
            pt.attr("d", makePointPath(drawing.symbolNumber(mx), mrc2, getMarkerAngle(d, trace), getMarkerStandoff(d, trace)));
            d.mrc2 = mrc2;
          });
        }
        if (seq.length) {
          s.each(function(d) {
            var pt = d3.select(this);
            for (var i = 0; i < seq.length; i++) {
              seq[i](pt, d);
            }
          });
        }
      };
      drawing.tryColorscale = function(marker, prefix) {
        var cont = prefix ? Lib.nestedProperty(marker, prefix).get() : marker;
        if (cont) {
          var colorArray = cont.color;
          if ((cont.colorscale || cont._colorAx) && Lib.isArrayOrTypedArray(colorArray)) {
            return Colorscale.makeColorScaleFuncFromTrace(cont);
          }
        }
        return Lib.identity;
      };
      var TEXTOFFSETSIGN = {
        start: 1,
        end: -1,
        middle: 0,
        bottom: 1,
        top: -1
      };
      function textPointPosition(s, textPosition, fontSize, markerRadius, dontTouchParent) {
        var group = d3.select(s.node().parentNode);
        var v = textPosition.indexOf("top") !== -1 ? "top" : textPosition.indexOf("bottom") !== -1 ? "bottom" : "middle";
        var h = textPosition.indexOf("left") !== -1 ? "end" : textPosition.indexOf("right") !== -1 ? "start" : "middle";
        var r = markerRadius ? markerRadius / 0.8 + 1 : 0;
        var numLines = (svgTextUtils.lineCount(s) - 1) * LINE_SPACING + 1;
        var dx = TEXTOFFSETSIGN[h] * r;
        var dy = fontSize * 0.75 + TEXTOFFSETSIGN[v] * r + (TEXTOFFSETSIGN[v] - 1) * numLines * fontSize / 2;
        s.attr("text-anchor", h);
        if (!dontTouchParent) {
          group.attr("transform", strTranslate(dx, dy));
        }
      }
      function extracTextFontSize(d, trace) {
        var fontSize = d.ts || trace.textfont.size;
        return isNumeric(fontSize) && fontSize > 0 ? fontSize : 0;
      }
      drawing.textPointStyle = function(s, trace, gd) {
        if (!s.size()) return;
        var selectedTextColorFn;
        if (trace.selectedpoints) {
          var fns = drawing.makeSelectedTextStyleFns(trace);
          selectedTextColorFn = fns.selectedTextColorFn;
        }
        var texttemplate = trace.texttemplate;
        var fullLayout = gd._fullLayout;
        s.each(function(d) {
          var p = d3.select(this);
          var text = texttemplate ? Lib.extractOption(d, trace, "txt", "texttemplate") : Lib.extractOption(d, trace, "tx", "text");
          if (!text && text !== 0) {
            p.remove();
            return;
          }
          if (texttemplate) {
            var fn = trace._module.formatLabels;
            var labels = fn ? fn(d, trace, fullLayout) : {};
            var pointValues = {};
            appendArrayPointValue(pointValues, trace, d.i);
            var meta = trace._meta || {};
            text = Lib.texttemplateString(text, labels, fullLayout._d3locale, pointValues, d, meta);
          }
          var pos = d.tp || trace.textposition;
          var fontSize = extracTextFontSize(d, trace);
          var fontColor = selectedTextColorFn ? selectedTextColorFn(d) : d.tc || trace.textfont.color;
          p.call(drawing.font, {
            family: d.tf || trace.textfont.family,
            weight: d.tw || trace.textfont.weight,
            style: d.ty || trace.textfont.style,
            variant: d.tv || trace.textfont.variant,
            textcase: d.tC || trace.textfont.textcase,
            lineposition: d.tE || trace.textfont.lineposition,
            shadow: d.tS || trace.textfont.shadow,
            size: fontSize,
            color: fontColor
          }).text(text).call(svgTextUtils.convertToTspans, gd).call(textPointPosition, pos, fontSize, d.mrc);
        });
      };
      drawing.selectedTextStyle = function(s, trace) {
        if (!s.size() || !trace.selectedpoints) return;
        var fns = drawing.makeSelectedTextStyleFns(trace);
        s.each(function(d) {
          var tx = d3.select(this);
          var tc = fns.selectedTextColorFn(d);
          var tp = d.tp || trace.textposition;
          var fontSize = extracTextFontSize(d, trace);
          Color.fill(tx, tc);
          var dontTouchParent = Registry.traceIs(trace, "bar-like");
          textPointPosition(tx, tp, fontSize, d.mrc2 || d.mrc, dontTouchParent);
        });
      };
      var CatmullRomExp = 0.5;
      drawing.smoothopen = function(pts, smoothness) {
        if (pts.length < 3) {
          return "M" + pts.join("L");
        }
        var path = "M" + pts[0];
        var tangents = [];
        var i;
        for (i = 1; i < pts.length - 1; i++) {
          tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));
        }
        path += "Q" + tangents[0][0] + " " + pts[1];
        for (i = 2; i < pts.length - 1; i++) {
          path += "C" + tangents[i - 2][1] + " " + tangents[i - 1][0] + " " + pts[i];
        }
        path += "Q" + tangents[pts.length - 3][1] + " " + pts[pts.length - 1];
        return path;
      };
      drawing.smoothclosed = function(pts, smoothness) {
        if (pts.length < 3) {
          return "M" + pts.join("L") + "Z";
        }
        var path = "M" + pts[0];
        var pLast = pts.length - 1;
        var tangents = [makeTangent(pts[pLast], pts[0], pts[1], smoothness)];
        var i;
        for (i = 1; i < pLast; i++) {
          tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));
        }
        tangents.push(
          makeTangent(pts[pLast - 1], pts[pLast], pts[0], smoothness)
        );
        for (i = 1; i <= pLast; i++) {
          path += "C" + tangents[i - 1][1] + " " + tangents[i][0] + " " + pts[i];
        }
        path += "C" + tangents[pLast][1] + " " + tangents[0][0] + " " + pts[0] + "Z";
        return path;
      };
      var lastDrawnX;
      var lastDrawnY;
      function roundEnd(pt, isY, isLastPoint) {
        if (isLastPoint) pt = applyBackoff(pt);
        return isY ? roundY(pt[1]) : roundX(pt[0]);
      }
      function roundX(p) {
        var v = d3.round(p, 2);
        lastDrawnX = v;
        return v;
      }
      function roundY(p) {
        var v = d3.round(p, 2);
        lastDrawnY = v;
        return v;
      }
      function makeTangent(prevpt, thispt, nextpt, smoothness) {
        var d1x = prevpt[0] - thispt[0];
        var d1y = prevpt[1] - thispt[1];
        var d2x = nextpt[0] - thispt[0];
        var d2y = nextpt[1] - thispt[1];
        var d1a = Math.pow(d1x * d1x + d1y * d1y, CatmullRomExp / 2);
        var d2a = Math.pow(d2x * d2x + d2y * d2y, CatmullRomExp / 2);
        var numx = (d2a * d2a * d1x - d1a * d1a * d2x) * smoothness;
        var numy = (d2a * d2a * d1y - d1a * d1a * d2y) * smoothness;
        var denom1 = 3 * d2a * (d1a + d2a);
        var denom2 = 3 * d1a * (d1a + d2a);
        return [
          [
            roundX(thispt[0] + (denom1 && numx / denom1)),
            roundY(thispt[1] + (denom1 && numy / denom1))
          ],
          [
            roundX(thispt[0] - (denom2 && numx / denom2)),
            roundY(thispt[1] - (denom2 && numy / denom2))
          ]
        ];
      }
      var STEPPATH = {
        hv: function(p0, p1, isLastPoint) {
          return "H" + roundX(p1[0]) + "V" + roundEnd(p1, 1, isLastPoint);
        },
        vh: function(p0, p1, isLastPoint) {
          return "V" + roundY(p1[1]) + "H" + roundEnd(p1, 0, isLastPoint);
        },
        hvh: function(p0, p1, isLastPoint) {
          return "H" + roundX((p0[0] + p1[0]) / 2) + "V" + roundY(p1[1]) + "H" + roundEnd(p1, 0, isLastPoint);
        },
        vhv: function(p0, p1, isLastPoint) {
          return "V" + roundY((p0[1] + p1[1]) / 2) + "H" + roundX(p1[0]) + "V" + roundEnd(p1, 1, isLastPoint);
        }
      };
      var STEPLINEAR = function(p0, p1, isLastPoint) {
        return "L" + roundEnd(p1, 0, isLastPoint) + "," + roundEnd(p1, 1, isLastPoint);
      };
      drawing.steps = function(shape) {
        var onestep = STEPPATH[shape] || STEPLINEAR;
        return function(pts) {
          var path = "M" + roundX(pts[0][0]) + "," + roundY(pts[0][1]);
          var len = pts.length;
          for (var i = 1; i < len; i++) {
            path += onestep(pts[i - 1], pts[i], i === len - 1);
          }
          return path;
        };
      };
      function applyBackoff(pt, start) {
        var backoff = pt.backoff;
        var trace = pt.trace;
        var d = pt.d;
        var i = pt.i;
        if (backoff && trace && trace.marker && trace.marker.angle % 360 === 0 && trace.line && trace.line.shape !== "spline") {
          var arrayBackoff = Lib.isArrayOrTypedArray(backoff);
          var end = pt;
          var x1 = start ? start[0] : lastDrawnX || 0;
          var y1 = start ? start[1] : lastDrawnY || 0;
          var x2 = end[0];
          var y2 = end[1];
          var dx = x2 - x1;
          var dy = y2 - y1;
          var t = Math.atan2(dy, dx);
          var b = arrayBackoff ? backoff[i] : backoff;
          if (b === "auto") {
            var endI = end.i;
            if (trace.type === "scatter") endI--;
            var endMarker = end.marker;
            var endMarkerSymbol = endMarker.symbol;
            if (Lib.isArrayOrTypedArray(endMarkerSymbol)) endMarkerSymbol = endMarkerSymbol[endI];
            var endMarkerSize = endMarker.size;
            if (Lib.isArrayOrTypedArray(endMarkerSize)) endMarkerSize = endMarkerSize[endI];
            b = endMarker ? drawing.symbolBackOffs[drawing.symbolNumber(endMarkerSymbol)] * endMarkerSize : 0;
            b += drawing.getMarkerStandoff(d[endI], trace) || 0;
          }
          var x = x2 - b * Math.cos(t);
          var y = y2 - b * Math.sin(t);
          if ((x <= x2 && x >= x1 || x >= x2 && x <= x1) && (y <= y2 && y >= y1 || y >= y2 && y <= y1)) {
            pt = [x, y];
          }
        }
        return pt;
      }
      drawing.applyBackoff = applyBackoff;
      drawing.makeTester = function() {
        var tester = Lib.ensureSingleById(d3.select("body"), "svg", "js-plotly-tester", function(s) {
          s.attr(xmlnsNamespaces.svgAttrs).style({
            position: "absolute",
            left: "-10000px",
            top: "-10000px",
            width: "9000px",
            height: "9000px",
            "z-index": "1"
          });
        });
        var testref = Lib.ensureSingle(tester, "path", "js-reference-point", function(s) {
          s.attr("d", "M0,0H1V1H0Z").style({
            "stroke-width": 0,
            fill: "black"
          });
        });
        drawing.tester = tester;
        drawing.testref = testref;
      };
      drawing.savedBBoxes = {};
      var savedBBoxesCount = 0;
      var maxSavedBBoxes = 1e4;
      drawing.bBox = function(node, inTester, hash) {
        if (!hash) hash = nodeHash(node);
        var out;
        if (hash) {
          out = drawing.savedBBoxes[hash];
          if (out) return Lib.extendFlat({}, out);
        } else if (node.childNodes.length === 1) {
          var innerNode = node.childNodes[0];
          hash = nodeHash(innerNode);
          if (hash) {
            var x = +innerNode.getAttribute("x") || 0;
            var y = +innerNode.getAttribute("y") || 0;
            var transform = innerNode.getAttribute("transform");
            if (!transform) {
              var innerBB = drawing.bBox(innerNode, false, hash);
              if (x) {
                innerBB.left += x;
                innerBB.right += x;
              }
              if (y) {
                innerBB.top += y;
                innerBB.bottom += y;
              }
              return innerBB;
            }
            hash += "~" + x + "~" + y + "~" + transform;
            out = drawing.savedBBoxes[hash];
            if (out) return Lib.extendFlat({}, out);
          }
        }
        var testNode, tester;
        if (inTester) {
          testNode = node;
        } else {
          tester = drawing.tester.node();
          testNode = node.cloneNode(true);
          tester.appendChild(testNode);
        }
        d3.select(testNode).attr("transform", null).call(svgTextUtils.positionText, 0, 0);
        var testRect = testNode.getBoundingClientRect();
        var refRect = drawing.testref.node().getBoundingClientRect();
        if (!inTester) tester.removeChild(testNode);
        var bb = {
          height: testRect.height,
          width: testRect.width,
          left: testRect.left - refRect.left,
          top: testRect.top - refRect.top,
          right: testRect.right - refRect.left,
          bottom: testRect.bottom - refRect.top
        };
        if (savedBBoxesCount >= maxSavedBBoxes) {
          drawing.savedBBoxes = {};
          savedBBoxesCount = 0;
        }
        if (hash) drawing.savedBBoxes[hash] = bb;
        savedBBoxesCount++;
        return Lib.extendFlat({}, bb);
      };
      function nodeHash(node) {
        var inputText = node.getAttribute("data-unformatted");
        if (inputText === null) return;
        return inputText + node.getAttribute("data-math") + node.getAttribute("text-anchor") + node.getAttribute("style");
      }
      drawing.setClipUrl = function(s, localId, gd) {
        s.attr("clip-path", getFullUrl(localId, gd));
      };
      function getFullUrl(localId, gd) {
        if (!localId) return null;
        var context = gd._context;
        var baseUrl = context._exportedPlot ? "" : context._baseUrl || "";
        return baseUrl ? "url('" + baseUrl + "#" + localId + "')" : "url(#" + localId + ")";
      }
      drawing.getTranslate = function(element) {
        var re = /.*\btranslate\((-?\d*\.?\d*)[^-\d]*(-?\d*\.?\d*)[^\d].*/;
        var getter = element.attr ? "attr" : "getAttribute";
        var transform = element[getter]("transform") || "";
        var translate = transform.replace(re, function(match, p1, p2) {
          return [p1, p2].join(" ");
        }).split(" ");
        return {
          x: +translate[0] || 0,
          y: +translate[1] || 0
        };
      };
      drawing.setTranslate = function(element, x, y) {
        var re = /(\btranslate\(.*?\);?)/;
        var getter = element.attr ? "attr" : "getAttribute";
        var setter = element.attr ? "attr" : "setAttribute";
        var transform = element[getter]("transform") || "";
        x = x || 0;
        y = y || 0;
        transform = transform.replace(re, "").trim();
        transform += strTranslate(x, y);
        transform = transform.trim();
        element[setter]("transform", transform);
        return transform;
      };
      drawing.getScale = function(element) {
        var re = /.*\bscale\((\d*\.?\d*)[^\d]*(\d*\.?\d*)[^\d].*/;
        var getter = element.attr ? "attr" : "getAttribute";
        var transform = element[getter]("transform") || "";
        var translate = transform.replace(re, function(match, p1, p2) {
          return [p1, p2].join(" ");
        }).split(" ");
        return {
          x: +translate[0] || 1,
          y: +translate[1] || 1
        };
      };
      drawing.setScale = function(element, x, y) {
        var re = /(\bscale\(.*?\);?)/;
        var getter = element.attr ? "attr" : "getAttribute";
        var setter = element.attr ? "attr" : "setAttribute";
        var transform = element[getter]("transform") || "";
        x = x || 1;
        y = y || 1;
        transform = transform.replace(re, "").trim();
        transform += "scale(" + x + "," + y + ")";
        transform = transform.trim();
        element[setter]("transform", transform);
        return transform;
      };
      var SCALE_RE = /\s*sc.*/;
      drawing.setPointGroupScale = function(selection, xScale, yScale) {
        xScale = xScale || 1;
        yScale = yScale || 1;
        if (!selection) return;
        var scale = xScale === 1 && yScale === 1 ? "" : "scale(" + xScale + "," + yScale + ")";
        selection.each(function() {
          var t = (this.getAttribute("transform") || "").replace(SCALE_RE, "");
          t += scale;
          t = t.trim();
          this.setAttribute("transform", t);
        });
      };
      var TEXT_POINT_LAST_TRANSLATION_RE = /translate\([^)]*\)\s*$/;
      drawing.setTextPointsScale = function(selection, xScale, yScale) {
        if (!selection) return;
        selection.each(function() {
          var transforms;
          var el = d3.select(this);
          var text = el.select("text");
          if (!text.node()) return;
          var x = parseFloat(text.attr("x") || 0);
          var y = parseFloat(text.attr("y") || 0);
          var existingTransform = (el.attr("transform") || "").match(TEXT_POINT_LAST_TRANSLATION_RE);
          if (xScale === 1 && yScale === 1) {
            transforms = [];
          } else {
            transforms = [
              strTranslate(x, y),
              "scale(" + xScale + "," + yScale + ")",
              strTranslate(-x, -y)
            ];
          }
          if (existingTransform) {
            transforms.push(existingTransform);
          }
          el.attr("transform", transforms.join(""));
        });
      };
      function getMarkerStandoff(d, trace) {
        var standoff;
        if (d) standoff = d.mf;
        if (standoff === void 0) {
          standoff = trace.marker ? trace.marker.standoff || 0 : 0;
        }
        if (!trace._geo && !trace._xA) {
          return -standoff;
        }
        return standoff;
      }
      drawing.getMarkerStandoff = getMarkerStandoff;
      var atan2 = Math.atan2;
      var cos = Math.cos;
      var sin = Math.sin;
      function rotate(t, xy) {
        var x = xy[0];
        var y = xy[1];
        return [
          x * cos(t) - y * sin(t),
          x * sin(t) + y * cos(t)
        ];
      }
      var previousLon;
      var previousLat;
      var previousX;
      var previousY;
      var previousI;
      var previousTraceUid;
      function getMarkerAngle(d, trace) {
        var angle = d.ma;
        if (angle === void 0) {
          angle = trace.marker.angle;
          if (!angle || Lib.isArrayOrTypedArray(angle)) {
            angle = 0;
          }
        }
        var x, y;
        var ref = trace.marker.angleref;
        if (ref === "previous" || ref === "north") {
          if (trace._geo) {
            var p = trace._geo.project(d.lonlat);
            x = p[0];
            y = p[1];
          } else {
            var xa = trace._xA;
            var ya = trace._yA;
            if (xa && ya) {
              x = xa.c2p(d.x);
              y = ya.c2p(d.y);
            } else {
              return 90;
            }
          }
          if (trace._geo) {
            var lon = d.lonlat[0];
            var lat = d.lonlat[1];
            var north = trace._geo.project([
              lon,
              lat + 1e-5
              // epsilon
            ]);
            var east = trace._geo.project([
              lon + 1e-5,
              // epsilon
              lat
            ]);
            var u = atan2(
              east[1] - y,
              east[0] - x
            );
            var v = atan2(
              north[1] - y,
              north[0] - x
            );
            var t;
            if (ref === "north") {
              t = angle / 180 * Math.PI;
            } else if (ref === "previous") {
              var lon1 = lon / 180 * Math.PI;
              var lat1 = lat / 180 * Math.PI;
              var lon2 = previousLon / 180 * Math.PI;
              var lat2 = previousLat / 180 * Math.PI;
              var dLon = lon2 - lon1;
              var deltaY = cos(lat2) * sin(dLon);
              var deltaX = sin(lat2) * cos(lat1) - cos(lat2) * sin(lat1) * cos(dLon);
              t = -atan2(
                deltaY,
                deltaX
              ) - Math.PI;
              previousLon = lon;
              previousLat = lat;
            }
            var A = rotate(u, [cos(t), 0]);
            var B = rotate(v, [sin(t), 0]);
            angle = atan2(
              A[1] + B[1],
              A[0] + B[0]
            ) / Math.PI * 180;
            if (ref === "previous" && !(previousTraceUid === trace.uid && d.i === previousI + 1)) {
              angle = null;
            }
          }
          if (ref === "previous" && !trace._geo) {
            if (previousTraceUid === trace.uid && d.i === previousI + 1 && isNumeric(x) && isNumeric(y)) {
              var dX = x - previousX;
              var dY = y - previousY;
              var shape = trace.line ? trace.line.shape || "" : "";
              var lastShapeChar = shape.slice(shape.length - 1);
              if (lastShapeChar === "h") dY = 0;
              if (lastShapeChar === "v") dX = 0;
              angle += atan2(dY, dX) / Math.PI * 180 + 90;
            } else {
              angle = null;
            }
          }
        }
        previousX = x;
        previousY = y;
        previousI = d.i;
        previousTraceUid = trace.uid;
        return angle;
      }
      drawing.getMarkerAngle = getMarkerAngle;
    }
  });

  // src/components/titles/index.js
  var require_titles = __commonJS({
    "src/components/titles/index.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var Plots = require_plots();
      var Registry = require_registry();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var Drawing = require_drawing();
      var Color = require_color();
      var svgTextUtils = require_svg_text_utils();
      var interactConstants = require_interactions();
      var OPPOSITE_SIDE = require_alignment().OPPOSITE_SIDE;
      var numStripRE = / [XY][0-9]* /;
      var SUBTITLE_PADDING_MATHJAX_EM = 1.6;
      var SUBTITLE_PADDING_EM = 1.6;
      function draw(gd, titleClass, options) {
        var fullLayout = gd._fullLayout;
        var cont = options.propContainer;
        var prop = options.propName;
        var placeholder = options.placeholder;
        var traceIndex = options.traceIndex;
        var avoid = options.avoid || {};
        var attributes = options.attributes;
        var transform = options.transform;
        var group = options.containerGroup;
        var opacity = 1;
        var title = cont.title;
        var txt = (title && title.text ? title.text : "").trim();
        var titleIsPlaceholder = false;
        var font = title && title.font ? title.font : {};
        var fontFamily = font.family;
        var fontSize = font.size;
        var fontColor = font.color;
        var fontWeight = font.weight;
        var fontStyle = font.style;
        var fontVariant = font.variant;
        var fontTextcase = font.textcase;
        var fontLineposition = font.lineposition;
        var fontShadow = font.shadow;
        var subtitleProp = options.subtitlePropName;
        var subtitleEnabled = !!subtitleProp;
        var subtitlePlaceholder = options.subtitlePlaceholder;
        var subtitle = (cont.title || {}).subtitle || { text: "", font: {} };
        var subtitleTxt = subtitle.text.trim();
        var subtitleIsPlaceholder = false;
        var subtitleOpacity = 1;
        var subtitleFont = subtitle.font;
        var subFontFamily = subtitleFont.family;
        var subFontSize = subtitleFont.size;
        var subFontColor = subtitleFont.color;
        var subFontWeight = subtitleFont.weight;
        var subFontStyle = subtitleFont.style;
        var subFontVariant = subtitleFont.variant;
        var subFontTextcase = subtitleFont.textcase;
        var subFontLineposition = subtitleFont.lineposition;
        var subFontShadow = subtitleFont.shadow;
        var editAttr;
        if (prop === "title.text") editAttr = "titleText";
        else if (prop.indexOf("axis") !== -1) editAttr = "axisTitleText";
        else if (prop.indexOf("colorbar" !== -1)) editAttr = "colorbarTitleText";
        var editable = gd._context.edits[editAttr];
        function matchesPlaceholder(text, placeholder2) {
          if (text === void 0 || placeholder2 === void 0) return false;
          return text.replace(numStripRE, " % ") === placeholder2.replace(numStripRE, " % ");
        }
        if (txt === "") opacity = 0;
        else if (matchesPlaceholder(txt, placeholder)) {
          if (!editable) txt = "";
          opacity = 0.2;
          titleIsPlaceholder = true;
        }
        if (subtitleEnabled) {
          if (subtitleTxt === "") subtitleOpacity = 0;
          else if (matchesPlaceholder(subtitleTxt, subtitlePlaceholder)) {
            if (!editable) subtitleTxt = "";
            subtitleOpacity = 0.2;
            subtitleIsPlaceholder = true;
          }
        }
        if (options._meta) {
          txt = Lib.templateString(txt, options._meta);
        } else if (fullLayout._meta) {
          txt = Lib.templateString(txt, fullLayout._meta);
        }
        var elShouldExist = txt || subtitleTxt || editable;
        var hColorbarMoveTitle;
        if (!group) {
          group = Lib.ensureSingle(fullLayout._infolayer, "g", "g-" + titleClass);
          hColorbarMoveTitle = fullLayout._hColorbarMoveTitle;
        }
        var el = group.selectAll("text." + titleClass).data(elShouldExist ? [0] : []);
        el.enter().append("text");
        el.text(txt).attr("class", titleClass);
        el.exit().remove();
        var subtitleEl = null;
        var subtitleClass = titleClass + "-subtitle";
        var subtitleElShouldExist = subtitleTxt || editable;
        if (subtitleEnabled && subtitleElShouldExist) {
          subtitleEl = group.selectAll("text." + subtitleClass).data(subtitleElShouldExist ? [0] : []);
          subtitleEl.enter().append("text");
          subtitleEl.text(subtitleTxt).attr("class", subtitleClass);
          subtitleEl.exit().remove();
        }
        if (!elShouldExist) return group;
        function titleLayout(titleEl, subtitleEl2) {
          Lib.syncOrAsync([drawTitle, scootTitle], { title: titleEl, subtitle: subtitleEl2 });
        }
        function drawTitle(titleAndSubtitleEls) {
          var titleEl = titleAndSubtitleEls.title;
          var subtitleEl2 = titleAndSubtitleEls.subtitle;
          var transformVal;
          if (!transform && hColorbarMoveTitle) {
            transform = {};
          }
          if (transform) {
            transformVal = "";
            if (transform.rotate) {
              transformVal += "rotate(" + [transform.rotate, attributes.x, attributes.y] + ")";
            }
            if (transform.offset || hColorbarMoveTitle) {
              transformVal += strTranslate(0, (transform.offset || 0) - (hColorbarMoveTitle || 0));
            }
          } else {
            transformVal = null;
          }
          titleEl.attr("transform", transformVal);
          function adjustSubtitlePosition(titleElMathGroup2) {
            if (!titleElMathGroup2) return;
            var subtitleElement = d3.select(titleElMathGroup2.node().parentNode).select("." + subtitleClass);
            if (!subtitleElement.empty()) {
              var titleElMathBbox2 = titleElMathGroup2.node().getBBox();
              if (titleElMathBbox2.height) {
                var subtitleY3 = titleElMathBbox2.y + titleElMathBbox2.height + SUBTITLE_PADDING_MATHJAX_EM * subFontSize;
                subtitleElement.attr("y", subtitleY3);
              }
            }
          }
          titleEl.style("opacity", opacity * Color.opacity(fontColor)).call(Drawing.font, {
            color: Color.rgb(fontColor),
            size: d3.round(fontSize, 2),
            family: fontFamily,
            weight: fontWeight,
            style: fontStyle,
            variant: fontVariant,
            textcase: fontTextcase,
            shadow: fontShadow,
            lineposition: fontLineposition
          }).attr(attributes).call(svgTextUtils.convertToTspans, gd, adjustSubtitlePosition);
          if (subtitleEl2) {
            var titleElMathGroup = group.select("." + titleClass + "-math-group");
            var titleElBbox2 = titleEl.node().getBBox();
            var titleElMathBbox = titleElMathGroup.node() ? titleElMathGroup.node().getBBox() : void 0;
            var subtitleY2 = titleElMathBbox ? titleElMathBbox.y + titleElMathBbox.height + SUBTITLE_PADDING_MATHJAX_EM * subFontSize : titleElBbox2.y + titleElBbox2.height + SUBTITLE_PADDING_EM * subFontSize;
            var subtitleAttributes = Lib.extendFlat({}, attributes, {
              y: subtitleY2
            });
            subtitleEl2.attr("transform", transformVal);
            subtitleEl2.style("opacity", subtitleOpacity * Color.opacity(subFontColor)).call(Drawing.font, {
              color: Color.rgb(subFontColor),
              size: d3.round(subFontSize, 2),
              family: subFontFamily,
              weight: subFontWeight,
              style: subFontStyle,
              variant: subFontVariant,
              textcase: subFontTextcase,
              shadow: subFontShadow,
              lineposition: subFontLineposition
            }).attr(subtitleAttributes).call(svgTextUtils.convertToTspans, gd);
          }
          return Plots.previousPromises(gd);
        }
        function scootTitle(titleAndSubtitleEls) {
          var titleElIn = titleAndSubtitleEls.title;
          var titleGroup = d3.select(titleElIn.node().parentNode);
          if (avoid && avoid.selection && avoid.side && txt) {
            titleGroup.attr("transform", null);
            var backside = OPPOSITE_SIDE[avoid.side];
            var shiftSign = avoid.side === "left" || avoid.side === "top" ? -1 : 1;
            var pad = isNumeric(avoid.pad) ? avoid.pad : 2;
            var titlebb = Drawing.bBox(titleGroup.node());
            var reservedMargins = { t: 0, b: 0, l: 0, r: 0 };
            var margins = gd._fullLayout._reservedMargin;
            for (var key in margins) {
              for (var side in margins[key]) {
                var val = margins[key][side];
                reservedMargins[side] = Math.max(reservedMargins[side], val);
              }
            }
            var paperbb = {
              left: reservedMargins.l,
              top: reservedMargins.t,
              right: fullLayout.width - reservedMargins.r,
              bottom: fullLayout.height - reservedMargins.b
            };
            var maxshift = avoid.maxShift || shiftSign * (paperbb[avoid.side] - titlebb[avoid.side]);
            var shift = 0;
            if (maxshift < 0) {
              shift = maxshift;
            } else {
              var offsetLeft = avoid.offsetLeft || 0;
              var offsetTop = avoid.offsetTop || 0;
              titlebb.left -= offsetLeft;
              titlebb.right -= offsetLeft;
              titlebb.top -= offsetTop;
              titlebb.bottom -= offsetTop;
              avoid.selection.each(function() {
                var avoidbb = Drawing.bBox(this);
                if (Lib.bBoxIntersect(titlebb, avoidbb, pad)) {
                  shift = Math.max(shift, shiftSign * (avoidbb[avoid.side] - titlebb[backside]) + pad);
                }
              });
              shift = Math.min(maxshift, shift);
              cont._titleScoot = Math.abs(shift);
            }
            if (shift > 0 || maxshift < 0) {
              var shiftTemplate = {
                left: [-shift, 0],
                right: [shift, 0],
                top: [0, -shift],
                bottom: [0, shift]
              }[avoid.side];
              titleGroup.attr("transform", strTranslate(shiftTemplate[0], shiftTemplate[1]));
            }
          }
        }
        el.call(titleLayout, subtitleEl);
        function setPlaceholder(element, placeholderText) {
          element.text(placeholderText).on("mouseover.opacity", function() {
            d3.select(this).transition().duration(interactConstants.SHOW_PLACEHOLDER).style("opacity", 1);
          }).on("mouseout.opacity", function() {
            d3.select(this).transition().duration(interactConstants.HIDE_PLACEHOLDER).style("opacity", 0);
          });
        }
        if (editable) {
          if (!txt) {
            setPlaceholder(el, placeholder);
            titleIsPlaceholder = true;
          } else el.on(".opacity", null);
          el.call(svgTextUtils.makeEditable, { gd }).on("edit", function(text) {
            if (traceIndex !== void 0) {
              Registry.call("_guiRestyle", gd, prop, text, traceIndex);
            } else {
              Registry.call("_guiRelayout", gd, prop, text);
            }
          }).on("cancel", function() {
            this.text(this.attr("data-unformatted")).call(titleLayout);
          }).on("input", function(d) {
            this.text(d || " ").call(svgTextUtils.positionText, attributes.x, attributes.y);
          });
          if (subtitleEnabled) {
            if (subtitleEnabled && !txt) {
              var titleElBbox = el.node().getBBox();
              var subtitleY = titleElBbox.y + titleElBbox.height + SUBTITLE_PADDING_EM * subFontSize;
              subtitleEl.attr("y", subtitleY);
            }
            if (!subtitleTxt) {
              setPlaceholder(subtitleEl, subtitlePlaceholder);
              subtitleIsPlaceholder = true;
            } else subtitleEl.on(".opacity", null);
            subtitleEl.call(svgTextUtils.makeEditable, { gd }).on("edit", function(text) {
              Registry.call("_guiRelayout", gd, "title.subtitle.text", text);
            }).on("cancel", function() {
              this.text(this.attr("data-unformatted")).call(titleLayout);
            }).on("input", function(d) {
              this.text(d || " ").call(svgTextUtils.positionText, subtitleEl.attr("x"), subtitleEl.attr("y"));
            });
          }
        }
        el.classed("js-placeholder", titleIsPlaceholder);
        if (subtitleEl) subtitleEl.classed("js-placeholder", subtitleIsPlaceholder);
        return group;
      }
      module.exports = {
        draw,
        SUBTITLE_PADDING_EM,
        SUBTITLE_PADDING_MATHJAX_EM
      };
    }
  });

  // src/plots/cartesian/set_convert.js
  var require_set_convert = __commonJS({
    "src/plots/cartesian/set_convert.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var utcFormat = require_d3_time_format().utcFormat;
      var Lib = require_lib();
      var numberFormat = Lib.numberFormat;
      var isNumeric = require_fast_isnumeric();
      var cleanNumber = Lib.cleanNumber;
      var ms2DateTime = Lib.ms2DateTime;
      var dateTime2ms = Lib.dateTime2ms;
      var ensureNumber = Lib.ensureNumber;
      var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
      var numConstants = require_numerical();
      var FP_SAFE = numConstants.FP_SAFE;
      var BADNUM = numConstants.BADNUM;
      var LOG_CLIP = numConstants.LOG_CLIP;
      var ONEWEEK = numConstants.ONEWEEK;
      var ONEDAY = numConstants.ONEDAY;
      var ONEHOUR = numConstants.ONEHOUR;
      var ONEMIN = numConstants.ONEMIN;
      var ONESEC = numConstants.ONESEC;
      var axisIds = require_axis_ids();
      var constants = require_constants2();
      var HOUR_PATTERN = constants.HOUR_PATTERN;
      var WEEKDAY_PATTERN = constants.WEEKDAY_PATTERN;
      function fromLog(v) {
        return Math.pow(10, v);
      }
      function isValidCategory(v) {
        return v !== null && v !== void 0;
      }
      module.exports = function setConvert(ax, fullLayout) {
        fullLayout = fullLayout || {};
        var axId = ax._id || "x";
        var axLetter = axId.charAt(0);
        function toLog(v, clip) {
          if (v > 0) return Math.log(v) / Math.LN10;
          else if (v <= 0 && clip && ax.range && ax.range.length === 2) {
            var r0 = ax.range[0];
            var r1 = ax.range[1];
            return 0.5 * (r0 + r1 - 2 * LOG_CLIP * Math.abs(r0 - r1));
          } else return BADNUM;
        }
        function dt2ms(v, _, calendar, opts) {
          if ((opts || {}).msUTC && isNumeric(v)) {
            return +v;
          }
          var ms = dateTime2ms(v, calendar || ax.calendar);
          if (ms === BADNUM) {
            if (isNumeric(v)) {
              v = +v;
              var msecTenths = Math.floor(Lib.mod(v + 0.05, 1) * 10);
              var msRounded = Math.round(v - msecTenths / 10);
              ms = dateTime2ms(new Date(msRounded)) + msecTenths / 10;
            } else return BADNUM;
          }
          return ms;
        }
        function ms2dt(v, r, calendar) {
          return ms2DateTime(v, r, calendar || ax.calendar);
        }
        function getCategoryName(v) {
          return ax._categories[Math.round(v)];
        }
        function setCategoryIndex(v) {
          if (isValidCategory(v)) {
            if (ax._categoriesMap === void 0) {
              ax._categoriesMap = {};
            }
            if (ax._categoriesMap[v] !== void 0) {
              return ax._categoriesMap[v];
            } else {
              ax._categories.push(typeof v === "number" ? String(v) : v);
              var curLength = ax._categories.length - 1;
              ax._categoriesMap[v] = curLength;
              return curLength;
            }
          }
          return BADNUM;
        }
        function setMultiCategoryIndex(arrayIn, len) {
          var arrayOut = new Array(len);
          for (var i = 0; i < len; i++) {
            var v0 = (arrayIn[0] || [])[i];
            var v1 = (arrayIn[1] || [])[i];
            arrayOut[i] = getCategoryIndex([v0, v1]);
          }
          return arrayOut;
        }
        function getCategoryIndex(v) {
          if (ax._categoriesMap) {
            return ax._categoriesMap[v];
          }
        }
        function getCategoryPosition(v) {
          var index = getCategoryIndex(v);
          if (index !== void 0) return index;
          if (isNumeric(v)) return +v;
        }
        function getRangePosition(v) {
          return isNumeric(v) ? +v : getCategoryIndex(v);
        }
        function _l2p(v, m, b) {
          return d3.round(b + m * v, 2);
        }
        function _p2l(px, m, b) {
          return (px - b) / m;
        }
        var l2p = function l2p2(v) {
          if (!isNumeric(v)) return BADNUM;
          return _l2p(v, ax._m, ax._b);
        };
        var p2l = function(px) {
          return _p2l(px, ax._m, ax._b);
        };
        if (ax.rangebreaks) {
          var isY = axLetter === "y";
          l2p = function(v) {
            if (!isNumeric(v)) return BADNUM;
            var len = ax._rangebreaks.length;
            if (!len) return _l2p(v, ax._m, ax._b);
            var flip = isY;
            if (ax.range[0] > ax.range[1]) flip = !flip;
            var signAx = flip ? -1 : 1;
            var pos = signAx * v;
            var q = 0;
            for (var i = 0; i < len; i++) {
              var min = signAx * ax._rangebreaks[i].min;
              var max = signAx * ax._rangebreaks[i].max;
              if (pos < min) break;
              if (pos > max) q = i + 1;
              else {
                q = pos < (min + max) / 2 ? i : i + 1;
                break;
              }
            }
            var b2 = ax._B[q] || 0;
            if (!isFinite(b2)) return 0;
            return _l2p(v, ax._m2, b2);
          };
          p2l = function(px) {
            var len = ax._rangebreaks.length;
            if (!len) return _p2l(px, ax._m, ax._b);
            var q = 0;
            for (var i = 0; i < len; i++) {
              if (px < ax._rangebreaks[i].pmin) break;
              if (px > ax._rangebreaks[i].pmax) q = i + 1;
            }
            return _p2l(px, ax._m2, ax._B[q]);
          };
        }
        ax.c2l = ax.type === "log" ? toLog : ensureNumber;
        ax.l2c = ax.type === "log" ? fromLog : ensureNumber;
        ax.l2p = l2p;
        ax.p2l = p2l;
        ax.c2p = ax.type === "log" ? function(v, clip) {
          return l2p(toLog(v, clip));
        } : l2p;
        ax.p2c = ax.type === "log" ? function(px) {
          return fromLog(p2l(px));
        } : p2l;
        if (["linear", "-"].indexOf(ax.type) !== -1) {
          ax.d2r = ax.r2d = ax.d2c = ax.r2c = ax.d2l = ax.r2l = cleanNumber;
          ax.c2d = ax.c2r = ax.l2d = ax.l2r = ensureNumber;
          ax.d2p = ax.r2p = function(v) {
            return ax.l2p(cleanNumber(v));
          };
          ax.p2d = ax.p2r = p2l;
          ax.cleanPos = ensureNumber;
        } else if (ax.type === "log") {
          ax.d2r = ax.d2l = function(v, clip) {
            return toLog(cleanNumber(v), clip);
          };
          ax.r2d = ax.r2c = function(v) {
            return fromLog(cleanNumber(v));
          };
          ax.d2c = ax.r2l = cleanNumber;
          ax.c2d = ax.l2r = ensureNumber;
          ax.c2r = toLog;
          ax.l2d = fromLog;
          ax.d2p = function(v, clip) {
            return ax.l2p(ax.d2r(v, clip));
          };
          ax.p2d = function(px) {
            return fromLog(p2l(px));
          };
          ax.r2p = function(v) {
            return ax.l2p(cleanNumber(v));
          };
          ax.p2r = p2l;
          ax.cleanPos = ensureNumber;
        } else if (ax.type === "date") {
          ax.d2r = ax.r2d = Lib.identity;
          ax.d2c = ax.r2c = ax.d2l = ax.r2l = dt2ms;
          ax.c2d = ax.c2r = ax.l2d = ax.l2r = ms2dt;
          ax.d2p = ax.r2p = function(v, _, calendar) {
            return ax.l2p(dt2ms(v, 0, calendar));
          };
          ax.p2d = ax.p2r = function(px, r, calendar) {
            return ms2dt(p2l(px), r, calendar);
          };
          ax.cleanPos = function(v) {
            return Lib.cleanDate(v, BADNUM, ax.calendar);
          };
        } else if (ax.type === "category") {
          ax.d2c = ax.d2l = setCategoryIndex;
          ax.r2d = ax.c2d = ax.l2d = getCategoryName;
          ax.d2r = ax.d2l_noadd = getCategoryPosition;
          ax.r2c = function(v) {
            var index = getRangePosition(v);
            return index !== void 0 ? index : ax.fraction2r(0.5);
          };
          ax.l2r = ax.c2r = ensureNumber;
          ax.r2l = getRangePosition;
          ax.d2p = function(v) {
            return ax.l2p(ax.r2c(v));
          };
          ax.p2d = function(px) {
            return getCategoryName(p2l(px));
          };
          ax.r2p = ax.d2p;
          ax.p2r = p2l;
          ax.cleanPos = function(v) {
            if (typeof v === "string" && v !== "") return v;
            return ensureNumber(v);
          };
        } else if (ax.type === "multicategory") {
          ax.r2d = ax.c2d = ax.l2d = getCategoryName;
          ax.d2r = ax.d2l_noadd = getCategoryPosition;
          ax.r2c = function(v) {
            var index = getCategoryPosition(v);
            return index !== void 0 ? index : ax.fraction2r(0.5);
          };
          ax.r2c_just_indices = getCategoryIndex;
          ax.l2r = ax.c2r = ensureNumber;
          ax.r2l = getCategoryPosition;
          ax.d2p = function(v) {
            return ax.l2p(ax.r2c(v));
          };
          ax.p2d = function(px) {
            return getCategoryName(p2l(px));
          };
          ax.r2p = ax.d2p;
          ax.p2r = p2l;
          ax.cleanPos = function(v) {
            if (Array.isArray(v) || typeof v === "string" && v !== "") return v;
            return ensureNumber(v);
          };
          ax.setupMultiCategory = function(fullData) {
            var traceIndices = ax._traceIndices;
            var i, j;
            var group = ax._matchGroup;
            if (group && ax._categories.length === 0) {
              for (var axId2 in group) {
                if (axId2 !== axId) {
                  var ax2 = fullLayout[axisIds.id2name(axId2)];
                  traceIndices = traceIndices.concat(ax2._traceIndices);
                }
              }
            }
            var seen = [[0, {}], [0, {}]];
            var list = [];
            for (i = 0; i < traceIndices.length; i++) {
              var trace = fullData[traceIndices[i]];
              if (axLetter in trace) {
                var arrayIn = trace[axLetter];
                var len = trace._length || Lib.minRowLength(arrayIn);
                if (isArrayOrTypedArray(arrayIn[0]) && isArrayOrTypedArray(arrayIn[1])) {
                  for (j = 0; j < len; j++) {
                    var v0 = arrayIn[0][j];
                    var v1 = arrayIn[1][j];
                    if (isValidCategory(v0) && isValidCategory(v1)) {
                      list.push([v0, v1]);
                      if (!(v0 in seen[0][1])) {
                        seen[0][1][v0] = seen[0][0]++;
                      }
                      if (!(v1 in seen[1][1])) {
                        seen[1][1][v1] = seen[1][0]++;
                      }
                    }
                  }
                }
              }
            }
            list.sort(function(a, b) {
              var ind0 = seen[0][1];
              var d = ind0[a[0]] - ind0[b[0]];
              if (d) return d;
              var ind1 = seen[1][1];
              return ind1[a[1]] - ind1[b[1]];
            });
            for (i = 0; i < list.length; i++) {
              setCategoryIndex(list[i]);
            }
          };
        }
        ax.fraction2r = function(v) {
          var rl0 = ax.r2l(ax.range[0]);
          var rl1 = ax.r2l(ax.range[1]);
          return ax.l2r(rl0 + v * (rl1 - rl0));
        };
        ax.r2fraction = function(v) {
          var rl0 = ax.r2l(ax.range[0]);
          var rl1 = ax.r2l(ax.range[1]);
          return (ax.r2l(v) - rl0) / (rl1 - rl0);
        };
        ax.limitRange = function(rangeAttr) {
          var minallowed = ax.minallowed;
          var maxallowed = ax.maxallowed;
          if (minallowed === void 0 && maxallowed === void 0) return;
          if (!rangeAttr) rangeAttr = "range";
          var range = Lib.nestedProperty(ax, rangeAttr).get();
          var rng = Lib.simpleMap(range, ax.r2l);
          var axrev = rng[1] < rng[0];
          if (axrev) rng.reverse();
          var bounds = Lib.simpleMap([minallowed, maxallowed], ax.r2l);
          if (minallowed !== void 0 && rng[0] < bounds[0]) range[axrev ? 1 : 0] = minallowed;
          if (maxallowed !== void 0 && rng[1] > bounds[1]) range[axrev ? 0 : 1] = maxallowed;
          if (range[0] === range[1]) {
            var minL = ax.l2r(minallowed);
            var maxL = ax.l2r(maxallowed);
            if (minallowed !== void 0) {
              var _max = minL + 1;
              if (maxallowed !== void 0) _max = Math.min(_max, maxL);
              range[axrev ? 1 : 0] = _max;
            }
            if (maxallowed !== void 0) {
              var _min = maxL + 1;
              if (minallowed !== void 0) _min = Math.max(_min, minL);
              range[axrev ? 0 : 1] = _min;
            }
          }
        };
        ax.cleanRange = function(rangeAttr, opts) {
          ax._cleanRange(rangeAttr, opts);
          ax.limitRange(rangeAttr);
        };
        ax._cleanRange = function(rangeAttr, opts) {
          if (!opts) opts = {};
          if (!rangeAttr) rangeAttr = "range";
          var range = Lib.nestedProperty(ax, rangeAttr).get();
          var i, dflt;
          if (ax.type === "date") dflt = Lib.dfltRange(ax.calendar);
          else if (axLetter === "y") dflt = constants.DFLTRANGEY;
          else if (ax._name === "realaxis") dflt = [0, 1];
          else dflt = opts.dfltRange || constants.DFLTRANGEX;
          dflt = dflt.slice();
          if (ax.rangemode === "tozero" || ax.rangemode === "nonnegative") {
            dflt[0] = 0;
          }
          if (!range || range.length !== 2) {
            Lib.nestedProperty(ax, rangeAttr).set(dflt);
            return;
          }
          var nullRange0 = range[0] === null;
          var nullRange1 = range[1] === null;
          if (ax.type === "date" && !ax.autorange) {
            range[0] = Lib.cleanDate(range[0], BADNUM, ax.calendar);
            range[1] = Lib.cleanDate(range[1], BADNUM, ax.calendar);
          }
          for (i = 0; i < 2; i++) {
            if (ax.type === "date") {
              if (!Lib.isDateTime(range[i], ax.calendar)) {
                ax[rangeAttr] = dflt;
                break;
              }
              if (ax.r2l(range[0]) === ax.r2l(range[1])) {
                var linCenter = Lib.constrain(
                  ax.r2l(range[0]),
                  Lib.MIN_MS + 1e3,
                  Lib.MAX_MS - 1e3
                );
                range[0] = ax.l2r(linCenter - 1e3);
                range[1] = ax.l2r(linCenter + 1e3);
                break;
              }
            } else {
              if (!isNumeric(range[i])) {
                if (!(nullRange0 || nullRange1) && isNumeric(range[1 - i])) {
                  range[i] = range[1 - i] * (i ? 10 : 0.1);
                } else {
                  ax[rangeAttr] = dflt;
                  break;
                }
              }
              if (range[i] < -FP_SAFE) range[i] = -FP_SAFE;
              else if (range[i] > FP_SAFE) range[i] = FP_SAFE;
              if (range[0] === range[1]) {
                var inc = Math.max(1, Math.abs(range[0] * 1e-6));
                range[0] -= inc;
                range[1] += inc;
              }
            }
          }
        };
        ax.setScale = function(usePrivateRange) {
          var gs = fullLayout._size;
          if (ax.overlaying) {
            var ax2 = axisIds.getFromId({ _fullLayout: fullLayout }, ax.overlaying);
            ax.domain = ax2.domain;
          }
          var rangeAttr = usePrivateRange && ax._r ? "_r" : "range";
          var calendar = ax.calendar;
          ax.cleanRange(rangeAttr);
          var rl0 = ax.r2l(ax[rangeAttr][0], calendar);
          var rl1 = ax.r2l(ax[rangeAttr][1], calendar);
          var isY2 = axLetter === "y";
          if (isY2) {
            ax._offset = gs.t + (1 - ax.domain[1]) * gs.h;
            ax._length = gs.h * (ax.domain[1] - ax.domain[0]);
            ax._m = ax._length / (rl0 - rl1);
            ax._b = -ax._m * rl1;
          } else {
            ax._offset = gs.l + ax.domain[0] * gs.w;
            ax._length = gs.w * (ax.domain[1] - ax.domain[0]);
            ax._m = ax._length / (rl1 - rl0);
            ax._b = -ax._m * rl0;
          }
          ax._rangebreaks = [];
          ax._lBreaks = 0;
          ax._m2 = 0;
          ax._B = [];
          if (ax.rangebreaks) {
            var i, brk;
            ax._rangebreaks = ax.locateBreaks(
              Math.min(rl0, rl1),
              Math.max(rl0, rl1)
            );
            if (ax._rangebreaks.length) {
              for (i = 0; i < ax._rangebreaks.length; i++) {
                brk = ax._rangebreaks[i];
                ax._lBreaks += Math.abs(brk.max - brk.min);
              }
              var flip = isY2;
              if (rl0 > rl1) flip = !flip;
              if (flip) ax._rangebreaks.reverse();
              var sign = flip ? -1 : 1;
              ax._m2 = sign * ax._length / (Math.abs(rl1 - rl0) - ax._lBreaks);
              ax._B.push(-ax._m2 * (isY2 ? rl1 : rl0));
              for (i = 0; i < ax._rangebreaks.length; i++) {
                brk = ax._rangebreaks[i];
                ax._B.push(
                  ax._B[ax._B.length - 1] - sign * ax._m2 * (brk.max - brk.min)
                );
              }
              for (i = 0; i < ax._rangebreaks.length; i++) {
                brk = ax._rangebreaks[i];
                brk.pmin = l2p(brk.min);
                brk.pmax = l2p(brk.max);
              }
            }
          }
          if (!isFinite(ax._m) || !isFinite(ax._b) || ax._length < 0) {
            fullLayout._replotting = false;
            throw new Error("Something went wrong with axis scaling");
          }
        };
        ax.maskBreaks = function(v) {
          var rangebreaksIn = ax.rangebreaks || [];
          var bnds, b0, b1, vb, vDate;
          if (!rangebreaksIn._cachedPatterns) {
            rangebreaksIn._cachedPatterns = rangebreaksIn.map(function(brk2) {
              return brk2.enabled && brk2.bounds ? Lib.simpleMap(
                brk2.bounds,
                brk2.pattern ? cleanNumber : ax.d2c
                // case of pattern: ''
              ) : null;
            });
          }
          if (!rangebreaksIn._cachedValues) {
            rangebreaksIn._cachedValues = rangebreaksIn.map(function(brk2) {
              return brk2.enabled && brk2.values ? Lib.simpleMap(brk2.values, ax.d2c).sort(Lib.sorterAsc) : null;
            });
          }
          for (var i = 0; i < rangebreaksIn.length; i++) {
            var brk = rangebreaksIn[i];
            if (brk.enabled) {
              if (brk.bounds) {
                var pattern = brk.pattern;
                bnds = rangebreaksIn._cachedPatterns[i];
                b0 = bnds[0];
                b1 = bnds[1];
                switch (pattern) {
                  case WEEKDAY_PATTERN:
                    vDate = new Date(v);
                    vb = vDate.getUTCDay();
                    if (b0 > b1) {
                      b1 += 7;
                      if (vb < b0) vb += 7;
                    }
                    break;
                  case HOUR_PATTERN:
                    vDate = new Date(v);
                    var hours = vDate.getUTCHours();
                    var minutes = vDate.getUTCMinutes();
                    var seconds = vDate.getUTCSeconds();
                    var milliseconds = vDate.getUTCMilliseconds();
                    vb = hours + (minutes / 60 + seconds / 3600 + milliseconds / 36e5);
                    if (b0 > b1) {
                      b1 += 24;
                      if (vb < b0) vb += 24;
                    }
                    break;
                  case "":
                    vb = v;
                    break;
                }
                if (vb >= b0 && vb < b1) return BADNUM;
              } else {
                var vals = rangebreaksIn._cachedValues[i];
                for (var j = 0; j < vals.length; j++) {
                  b0 = vals[j];
                  b1 = b0 + brk.dvalue;
                  if (v >= b0 && v < b1) return BADNUM;
                }
              }
            }
          }
          return v;
        };
        ax.locateBreaks = function(r0, r1) {
          var i, bnds, b0, b1;
          var rangebreaksOut = [];
          if (!ax.rangebreaks) return rangebreaksOut;
          var rangebreaksIn = ax.rangebreaks.slice().sort(function(a, b) {
            if (a.pattern === WEEKDAY_PATTERN && b.pattern === HOUR_PATTERN) return -1;
            if (b.pattern === WEEKDAY_PATTERN && a.pattern === HOUR_PATTERN) return 1;
            return 0;
          });
          var addBreak = function(min, max) {
            min = Lib.constrain(min, r0, r1);
            max = Lib.constrain(max, r0, r1);
            if (min === max) return;
            var isNewBreak = true;
            for (var j2 = 0; j2 < rangebreaksOut.length; j2++) {
              var brkj = rangebreaksOut[j2];
              if (min < brkj.max && max >= brkj.min) {
                if (min < brkj.min) {
                  brkj.min = min;
                }
                if (max > brkj.max) {
                  brkj.max = max;
                }
                isNewBreak = false;
              }
            }
            if (isNewBreak) {
              rangebreaksOut.push({ min, max });
            }
          };
          for (i = 0; i < rangebreaksIn.length; i++) {
            var brk = rangebreaksIn[i];
            if (brk.enabled) {
              if (brk.bounds) {
                var t0 = r0;
                var t1 = r1;
                if (brk.pattern) {
                  t0 = Math.floor(t0);
                }
                bnds = Lib.simpleMap(brk.bounds, brk.pattern ? cleanNumber : ax.r2l);
                b0 = bnds[0];
                b1 = bnds[1];
                var t0Date = new Date(t0);
                var bndDelta;
                var step;
                switch (brk.pattern) {
                  case WEEKDAY_PATTERN:
                    step = ONEWEEK;
                    bndDelta = ((b1 < b0 ? 7 : 0) + (b1 - b0)) * ONEDAY;
                    t0 += b0 * ONEDAY - (t0Date.getUTCDay() * ONEDAY + t0Date.getUTCHours() * ONEHOUR + t0Date.getUTCMinutes() * ONEMIN + t0Date.getUTCSeconds() * ONESEC + t0Date.getUTCMilliseconds());
                    break;
                  case HOUR_PATTERN:
                    step = ONEDAY;
                    bndDelta = ((b1 < b0 ? 24 : 0) + (b1 - b0)) * ONEHOUR;
                    t0 += b0 * ONEHOUR - (t0Date.getUTCHours() * ONEHOUR + t0Date.getUTCMinutes() * ONEMIN + t0Date.getUTCSeconds() * ONESEC + t0Date.getUTCMilliseconds());
                    break;
                  default:
                    t0 = Math.min(bnds[0], bnds[1]);
                    t1 = Math.max(bnds[0], bnds[1]);
                    step = t1 - t0;
                    bndDelta = step;
                }
                for (var t = t0; t < t1; t += step) {
                  addBreak(t, t + bndDelta);
                }
              } else {
                var vals = Lib.simpleMap(brk.values, ax.d2c);
                for (var j = 0; j < vals.length; j++) {
                  b0 = vals[j];
                  b1 = b0 + brk.dvalue;
                  addBreak(b0, b1);
                }
              }
            }
          }
          rangebreaksOut.sort(function(a, b) {
            return a.min - b.min;
          });
          return rangebreaksOut;
        };
        ax.makeCalcdata = function(trace, axLetter2, opts) {
          var arrayIn, arrayOut, i, len;
          var axType = ax.type;
          var cal = axType === "date" && trace[axLetter2 + "calendar"];
          if (axLetter2 in trace) {
            arrayIn = trace[axLetter2];
            len = trace._length || Lib.minRowLength(arrayIn);
            if (Lib.isTypedArray(arrayIn) && (axType === "linear" || axType === "log")) {
              if (len === arrayIn.length) {
                return arrayIn;
              } else if (arrayIn.subarray) {
                return arrayIn.subarray(0, len);
              }
            }
            if (axType === "multicategory") {
              return setMultiCategoryIndex(arrayIn, len);
            }
            arrayOut = new Array(len);
            for (i = 0; i < len; i++) {
              arrayOut[i] = ax.d2c(arrayIn[i], 0, cal, opts);
            }
          } else {
            var v0 = axLetter2 + "0" in trace ? ax.d2c(trace[axLetter2 + "0"], 0, cal) : 0;
            var dv = trace["d" + axLetter2] ? Number(trace["d" + axLetter2]) : 1;
            arrayIn = trace[{ x: "y", y: "x" }[axLetter2]];
            len = trace._length || arrayIn.length;
            arrayOut = new Array(len);
            for (i = 0; i < len; i++) {
              arrayOut[i] = v0 + i * dv;
            }
          }
          if (ax.rangebreaks) {
            for (i = 0; i < len; i++) {
              arrayOut[i] = ax.maskBreaks(arrayOut[i]);
            }
          }
          return arrayOut;
        };
        ax.isValidRange = function(range, nullOk) {
          return Array.isArray(range) && range.length === 2 && (nullOk && range[0] === null || isNumeric(ax.r2l(range[0]))) && (nullOk && range[1] === null || isNumeric(ax.r2l(range[1])));
        };
        ax.getAutorangeDflt = function(range, options) {
          var autorangeDflt = !ax.isValidRange(range, "nullOk");
          if (autorangeDflt && options && options.reverseDflt) autorangeDflt = "reversed";
          else if (range) {
            if (range[0] === null && range[1] === null) {
              autorangeDflt = true;
            } else if (range[0] === null && range[1] !== null) {
              autorangeDflt = "min";
            } else if (range[0] !== null && range[1] === null) {
              autorangeDflt = "max";
            }
          }
          return autorangeDflt;
        };
        ax.isReversed = function() {
          var autorange = ax.autorange;
          return autorange === "reversed" || autorange === "min reversed" || autorange === "max reversed";
        };
        ax.isPtWithinRange = function(d, calendar) {
          var coord = ax.c2l(d[axLetter], null, calendar);
          var r0 = ax.r2l(ax.range[0]);
          var r1 = ax.r2l(ax.range[1]);
          if (r0 < r1) {
            return r0 <= coord && coord <= r1;
          } else {
            return r1 <= coord && coord <= r0;
          }
        };
        ax._emptyCategories = function() {
          ax._categories = [];
          ax._categoriesMap = {};
        };
        ax.clearCalc = function() {
          var group = ax._matchGroup;
          if (group) {
            var categories = null;
            var categoriesMap = null;
            for (var axId2 in group) {
              var ax2 = fullLayout[axisIds.id2name(axId2)];
              if (ax2._categories) {
                categories = ax2._categories;
                categoriesMap = ax2._categoriesMap;
                break;
              }
            }
            if (categories && categoriesMap) {
              ax._categories = categories;
              ax._categoriesMap = categoriesMap;
            } else {
              ax._emptyCategories();
            }
          } else {
            ax._emptyCategories();
          }
          if (ax._initialCategories) {
            for (var j = 0; j < ax._initialCategories.length; j++) {
              setCategoryIndex(ax._initialCategories[j]);
            }
          }
        };
        ax.sortByInitialCategories = function() {
          var affectedTraces = [];
          ax._emptyCategories();
          if (ax._initialCategories) {
            for (var j = 0; j < ax._initialCategories.length; j++) {
              setCategoryIndex(ax._initialCategories[j]);
            }
          }
          affectedTraces = affectedTraces.concat(ax._traceIndices);
          var group = ax._matchGroup;
          for (var axId2 in group) {
            if (axId === axId2) continue;
            var ax2 = fullLayout[axisIds.id2name(axId2)];
            ax2._categories = ax._categories;
            ax2._categoriesMap = ax._categoriesMap;
            affectedTraces = affectedTraces.concat(ax2._traceIndices);
          }
          return affectedTraces;
        };
        var locale = fullLayout._d3locale;
        if (ax.type === "date") {
          ax._dateFormat = locale ? locale.timeFormat : utcFormat;
          ax._extraFormat = fullLayout._extraFormat;
        }
        ax._separators = fullLayout.separators;
        ax._numFormat = locale ? locale.numberFormat : numberFormat;
        delete ax._minDtick;
        delete ax._forceTick0;
      };
    }
  });

  // src/plots/cartesian/axis_autotype.js
  var require_axis_autotype = __commonJS({
    "src/plots/cartesian/axis_autotype.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var BADNUM = require_numerical().BADNUM;
      var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
      var isDateTime = Lib.isDateTime;
      var cleanNumber = Lib.cleanNumber;
      var round = Math.round;
      module.exports = function autoType(array, calendar, opts) {
        var a = array;
        var noMultiCategory = opts.noMultiCategory;
        if (isArrayOrTypedArray(a) && !a.length) return "-";
        if (!noMultiCategory && multiCategory(a)) return "multicategory";
        if (noMultiCategory && Array.isArray(a[0])) {
          var b = [];
          for (var i = 0; i < a.length; i++) {
            if (isArrayOrTypedArray(a[i])) {
              for (var j = 0; j < a[i].length; j++) {
                b.push(a[i][j]);
              }
            }
          }
          a = b;
        }
        if (moreDates(a, calendar)) return "date";
        var convertNumeric = opts.autotypenumbers !== "strict";
        if (category(a, convertNumeric)) return "category";
        if (linearOK(a, convertNumeric)) return "linear";
        return "-";
      };
      function hasTypeNumber(v, convertNumeric) {
        return convertNumeric ? isNumeric(v) : typeof v === "number";
      }
      function linearOK(a, convertNumeric) {
        var len = a.length;
        for (var i = 0; i < len; i++) {
          if (hasTypeNumber(a[i], convertNumeric)) return true;
        }
        return false;
      }
      function moreDates(a, calendar) {
        var len = a.length;
        var inc = getIncrement(len);
        var dats = 0;
        var nums = 0;
        var seen = {};
        for (var f = 0; f < len; f += inc) {
          var i = round(f);
          var ai = a[i];
          var stri = String(ai);
          if (seen[stri]) continue;
          seen[stri] = 1;
          if (isDateTime(ai, calendar)) dats++;
          if (isNumeric(ai)) nums++;
        }
        return dats > nums * 2;
      }
      function getIncrement(len) {
        return Math.max(1, (len - 1) / 1e3);
      }
      function category(a, convertNumeric) {
        var len = a.length;
        var inc = getIncrement(len);
        var nums = 0;
        var cats = 0;
        var seen = {};
        for (var f = 0; f < len; f += inc) {
          var i = round(f);
          var ai = a[i];
          var stri = String(ai);
          if (seen[stri]) continue;
          seen[stri] = 1;
          var t = typeof ai;
          if (t === "boolean") cats++;
          else if (convertNumeric ? cleanNumber(ai) !== BADNUM : t === "number") nums++;
          else if (t === "string") cats++;
        }
        return cats > nums * 2;
      }
      function multiCategory(a) {
        return isArrayOrTypedArray(a[0]) && isArrayOrTypedArray(a[1]);
      }
    }
  });

  // src/plots/cartesian/autorange.js
  var require_autorange = __commonJS({
    "src/plots/cartesian/autorange.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var FP_SAFE = require_numerical().FP_SAFE;
      var Registry = require_registry();
      var Drawing = require_drawing();
      var axIds = require_axis_ids();
      var getFromId = axIds.getFromId;
      var isLinked = axIds.isLinked;
      module.exports = {
        applyAutorangeOptions,
        getAutoRange,
        makePadFn,
        doAutoRange,
        findExtremes,
        concatExtremes
      };
      function getAutoRange(gd, ax) {
        var i, j;
        var newRange = [];
        var fullLayout = gd._fullLayout;
        var getPadMin = makePadFn(fullLayout, ax, 0);
        var getPadMax = makePadFn(fullLayout, ax, 1);
        var extremes = concatExtremes(gd, ax);
        var minArray = extremes.min;
        var maxArray = extremes.max;
        if (minArray.length === 0 || maxArray.length === 0) {
          return Lib.simpleMap(ax.range, ax.r2l);
        }
        var minmin = minArray[0].val;
        var maxmax = maxArray[0].val;
        for (i = 1; i < minArray.length; i++) {
          if (minmin !== maxmax) break;
          minmin = Math.min(minmin, minArray[i].val);
        }
        for (i = 1; i < maxArray.length; i++) {
          if (minmin !== maxmax) break;
          maxmax = Math.max(maxmax, maxArray[i].val);
        }
        var autorange = ax.autorange;
        var axReverse = autorange === "reversed" || autorange === "min reversed" || autorange === "max reversed";
        if (!axReverse && ax.range) {
          var rng = Lib.simpleMap(ax.range, ax.r2l);
          axReverse = rng[1] < rng[0];
        }
        if (ax.autorange === "reversed") {
          ax.autorange = true;
        }
        var rangeMode = ax.rangemode;
        var toZero = rangeMode === "tozero";
        var nonNegative = rangeMode === "nonnegative";
        var axLen = ax._length;
        var minSpan = axLen / 10;
        var mbest = 0;
        var minpt, maxpt, minbest, maxbest, dp, dv;
        for (i = 0; i < minArray.length; i++) {
          minpt = minArray[i];
          for (j = 0; j < maxArray.length; j++) {
            maxpt = maxArray[j];
            dv = maxpt.val - minpt.val - calcBreaksLength(ax, minpt.val, maxpt.val);
            if (dv > 0) {
              dp = axLen - getPadMin(minpt) - getPadMax(maxpt);
              if (dp > minSpan) {
                if (dv / dp > mbest) {
                  minbest = minpt;
                  maxbest = maxpt;
                  mbest = dv / dp;
                }
              } else if (dv / axLen > mbest) {
                minbest = { val: minpt.val, nopad: 1 };
                maxbest = { val: maxpt.val, nopad: 1 };
                mbest = dv / axLen;
              }
            }
          }
        }
        function maximumPad(prev, pt) {
          return Math.max(prev, getPadMax(pt));
        }
        if (minmin === maxmax) {
          var lower = minmin - 1;
          var upper = minmin + 1;
          if (toZero) {
            if (minmin === 0) {
              newRange = [0, 1];
            } else {
              var maxPad = (minmin > 0 ? maxArray : minArray).reduce(maximumPad, 0);
              var rangeEnd = minmin / (1 - Math.min(0.5, maxPad / axLen));
              newRange = minmin > 0 ? [0, rangeEnd] : [rangeEnd, 0];
            }
          } else if (nonNegative) {
            newRange = [Math.max(0, lower), Math.max(1, upper)];
          } else {
            newRange = [lower, upper];
          }
        } else {
          if (toZero) {
            if (minbest.val >= 0) {
              minbest = { val: 0, nopad: 1 };
            }
            if (maxbest.val <= 0) {
              maxbest = { val: 0, nopad: 1 };
            }
          } else if (nonNegative) {
            if (minbest.val - mbest * getPadMin(minbest) < 0) {
              minbest = { val: 0, nopad: 1 };
            }
            if (maxbest.val <= 0) {
              maxbest = { val: 1, nopad: 1 };
            }
          }
          mbest = (maxbest.val - minbest.val - calcBreaksLength(ax, minpt.val, maxpt.val)) / (axLen - getPadMin(minbest) - getPadMax(maxbest));
          newRange = [
            minbest.val - mbest * getPadMin(minbest),
            maxbest.val + mbest * getPadMax(maxbest)
          ];
        }
        newRange = applyAutorangeOptions(newRange, ax);
        if (ax.limitRange) ax.limitRange();
        if (axReverse) newRange.reverse();
        return Lib.simpleMap(newRange, ax.l2r || Number);
      }
      function calcBreaksLength(ax, v0, v1) {
        var lBreaks = 0;
        if (ax.rangebreaks) {
          var rangebreaksOut = ax.locateBreaks(v0, v1);
          for (var i = 0; i < rangebreaksOut.length; i++) {
            var brk = rangebreaksOut[i];
            lBreaks += brk.max - brk.min;
          }
        }
        return lBreaks;
      }
      function makePadFn(fullLayout, ax, max) {
        var extrappad = 0.05 * ax._length;
        var anchorAxis = ax._anchorAxis || {};
        if ((ax.ticklabelposition || "").indexOf("inside") !== -1 || (anchorAxis.ticklabelposition || "").indexOf("inside") !== -1) {
          var axReverse = ax.isReversed();
          if (!axReverse) {
            var rng = Lib.simpleMap(ax.range, ax.r2l);
            axReverse = rng[1] < rng[0];
          }
          if (axReverse) max = !max;
        }
        var zero = 0;
        if (!isLinked(fullLayout, ax._id)) {
          zero = padInsideLabelsOnAnchorAxis(fullLayout, ax, max);
        }
        extrappad = Math.max(zero, extrappad);
        if (ax.constrain === "domain" && ax._inputDomain) {
          extrappad *= (ax._inputDomain[1] - ax._inputDomain[0]) / (ax.domain[1] - ax.domain[0]);
        }
        return function getPad(pt) {
          if (pt.nopad) return 0;
          return pt.pad + (pt.extrapad ? extrappad : zero);
        };
      }
      var TEXTPAD = 3;
      function padInsideLabelsOnAnchorAxis(fullLayout, ax, max) {
        var pad = 0;
        var isX = ax._id.charAt(0) === "x";
        for (var subplot in fullLayout._plots) {
          var plotinfo = fullLayout._plots[subplot];
          if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;
          var anchorAxis = (isX ? plotinfo.yaxis : plotinfo.xaxis) || {};
          if ((anchorAxis.ticklabelposition || "").indexOf("inside") !== -1) {
            if (!max && (anchorAxis.side === "left" || anchorAxis.side === "bottom") || max && (anchorAxis.side === "top" || anchorAxis.side === "right")) {
              if (anchorAxis._vals) {
                var rad = Lib.deg2rad(anchorAxis._tickAngles[anchorAxis._id + "tick"] || 0);
                var cosA = Math.abs(Math.cos(rad));
                var sinA = Math.abs(Math.sin(rad));
                if (!anchorAxis._vals[0].bb) {
                  var cls = anchorAxis._id + "tick";
                  var tickLabels = anchorAxis._selections[cls];
                  tickLabels.each(function(d) {
                    var thisLabel = d3.select(this);
                    var mathjaxGroup = thisLabel.select(".text-math-group");
                    if (mathjaxGroup.empty()) {
                      d.bb = Drawing.bBox(thisLabel.node());
                    }
                  });
                }
                for (var i = 0; i < anchorAxis._vals.length; i++) {
                  var t = anchorAxis._vals[i];
                  var bb = t.bb;
                  if (bb) {
                    var w = 2 * TEXTPAD + bb.width;
                    var h = 2 * TEXTPAD + bb.height;
                    pad = Math.max(
                      pad,
                      isX ? Math.max(w * cosA, h * sinA) : Math.max(h * cosA, w * sinA)
                    );
                  }
                }
              }
              if (anchorAxis.ticks === "inside" && anchorAxis.ticklabelposition === "inside") {
                pad += anchorAxis.ticklen || 0;
              }
            }
          }
        }
        return pad;
      }
      function concatExtremes(gd, ax, noMatch) {
        var axId = ax._id;
        var fullData = gd._fullData;
        var fullLayout = gd._fullLayout;
        var minArray = [];
        var maxArray = [];
        var i, j, d;
        function _concat(cont, indices) {
          for (i = 0; i < indices.length; i++) {
            var item = cont[indices[i]];
            var extremes = (item._extremes || {})[axId];
            if (item.visible === true && extremes) {
              for (j = 0; j < extremes.min.length; j++) {
                d = extremes.min[j];
                collapseMinArray(minArray, d.val, d.pad, { extrapad: d.extrapad });
              }
              for (j = 0; j < extremes.max.length; j++) {
                d = extremes.max[j];
                collapseMaxArray(maxArray, d.val, d.pad, { extrapad: d.extrapad });
              }
            }
          }
        }
        _concat(fullData, ax._traceIndices);
        _concat(fullLayout.annotations || [], ax._annIndices || []);
        _concat(fullLayout.shapes || [], ax._shapeIndices || []);
        if (ax._matchGroup && !noMatch) {
          for (var axId2 in ax._matchGroup) {
            if (axId2 !== ax._id) {
              var ax2 = getFromId(gd, axId2);
              var extremes2 = concatExtremes(gd, ax2, true);
              var lenRatio = ax._length / ax2._length;
              for (j = 0; j < extremes2.min.length; j++) {
                d = extremes2.min[j];
                collapseMinArray(minArray, d.val, d.pad * lenRatio, { extrapad: d.extrapad });
              }
              for (j = 0; j < extremes2.max.length; j++) {
                d = extremes2.max[j];
                collapseMaxArray(maxArray, d.val, d.pad * lenRatio, { extrapad: d.extrapad });
              }
            }
          }
        }
        return { min: minArray, max: maxArray };
      }
      function doAutoRange(gd, ax, presetRange) {
        ax.setScale();
        if (ax.autorange) {
          ax.range = presetRange ? presetRange.slice() : getAutoRange(gd, ax);
          ax._r = ax.range.slice();
          ax._rl = Lib.simpleMap(ax._r, ax.r2l);
          var axIn = ax._input;
          var edits = {};
          edits[ax._attr + ".range"] = ax.range;
          edits[ax._attr + ".autorange"] = ax.autorange;
          Registry.call("_storeDirectGUIEdit", gd.layout, gd._fullLayout._preGUI, edits);
          axIn.range = ax.range.slice();
          axIn.autorange = ax.autorange;
        }
        var anchorAx = ax._anchorAxis;
        if (anchorAx && anchorAx.rangeslider) {
          var axeRangeOpts = anchorAx.rangeslider[ax._name];
          if (axeRangeOpts) {
            if (axeRangeOpts.rangemode === "auto") {
              axeRangeOpts.range = getAutoRange(gd, ax);
            }
          }
          anchorAx._input.rangeslider[ax._name] = Lib.extendFlat({}, axeRangeOpts);
        }
      }
      function findExtremes(ax, data, opts) {
        if (!opts) opts = {};
        if (!ax._m) ax.setScale();
        var minArray = [];
        var maxArray = [];
        var len = data.length;
        var extrapad = opts.padded || false;
        var tozero = opts.tozero && (ax.type === "linear" || ax.type === "-");
        var isLog = ax.type === "log";
        var hasArrayOption = false;
        var vpadLinearized = opts.vpadLinearized || false;
        var i, v, di, dmin, dmax, ppadiplus, ppadiminus, vmin, vmax;
        function makePadAccessor(item) {
          if (Array.isArray(item)) {
            hasArrayOption = true;
            return function(i2) {
              return Math.max(Number(item[i2] || 0), 0);
            };
          } else {
            var v2 = Math.max(Number(item || 0), 0);
            return function() {
              return v2;
            };
          }
        }
        var ppadplus = makePadAccessor((ax._m > 0 ? opts.ppadplus : opts.ppadminus) || opts.ppad || 0);
        var ppadminus = makePadAccessor((ax._m > 0 ? opts.ppadminus : opts.ppadplus) || opts.ppad || 0);
        var vpadplus = makePadAccessor(opts.vpadplus || opts.vpad);
        var vpadminus = makePadAccessor(opts.vpadminus || opts.vpad);
        if (!hasArrayOption) {
          vmin = Infinity;
          vmax = -Infinity;
          if (isLog) {
            for (i = 0; i < len; i++) {
              v = data[i];
              if (v < vmin && v > 0) vmin = v;
              if (v > vmax && v < FP_SAFE) vmax = v;
            }
          } else {
            for (i = 0; i < len; i++) {
              v = data[i];
              if (v < vmin && v > -FP_SAFE) vmin = v;
              if (v > vmax && v < FP_SAFE) vmax = v;
            }
          }
          data = [vmin, vmax];
          len = 2;
        }
        var collapseOpts = { tozero, extrapad };
        function addItem(i2) {
          di = data[i2];
          if (!isNumeric(di)) return;
          ppadiplus = ppadplus(i2);
          ppadiminus = ppadminus(i2);
          if (vpadLinearized) {
            dmin = ax.c2l(di) - vpadminus(i2);
            dmax = ax.c2l(di) + vpadplus(i2);
          } else {
            vmin = di - vpadminus(i2);
            vmax = di + vpadplus(i2);
            if (isLog && vmin < vmax / 10) vmin = vmax / 10;
            dmin = ax.c2l(vmin);
            dmax = ax.c2l(vmax);
          }
          if (tozero) {
            dmin = Math.min(0, dmin);
            dmax = Math.max(0, dmax);
          }
          if (goodNumber(dmin)) {
            collapseMinArray(minArray, dmin, ppadiminus, collapseOpts);
          }
          if (goodNumber(dmax)) {
            collapseMaxArray(maxArray, dmax, ppadiplus, collapseOpts);
          }
        }
        var iMax = Math.min(6, len);
        for (i = 0; i < iMax; i++) addItem(i);
        for (i = len - 1; i >= iMax; i--) addItem(i);
        return {
          min: minArray,
          max: maxArray,
          opts
        };
      }
      function collapseMinArray(array, newVal, newPad, opts) {
        collapseArray(array, newVal, newPad, opts, lessOrEqual);
      }
      function collapseMaxArray(array, newVal, newPad, opts) {
        collapseArray(array, newVal, newPad, opts, greaterOrEqual);
      }
      function collapseArray(array, newVal, newPad, opts, atLeastAsExtreme) {
        var tozero = opts.tozero;
        var extrapad = opts.extrapad;
        var includeThis = true;
        for (var j = 0; j < array.length && includeThis; j++) {
          var v = array[j];
          if (atLeastAsExtreme(v.val, newVal) && v.pad >= newPad && (v.extrapad || !extrapad)) {
            includeThis = false;
            break;
          } else if (atLeastAsExtreme(newVal, v.val) && v.pad <= newPad && (extrapad || !v.extrapad)) {
            array.splice(j, 1);
            j--;
          }
        }
        if (includeThis) {
          var clipAtZero = tozero && newVal === 0;
          array.push({
            val: newVal,
            pad: clipAtZero ? 0 : newPad,
            extrapad: clipAtZero ? false : extrapad
          });
        }
      }
      function goodNumber(v) {
        return isNumeric(v) && Math.abs(v) < FP_SAFE;
      }
      function lessOrEqual(v0, v1) {
        return v0 <= v1;
      }
      function greaterOrEqual(v0, v1) {
        return v0 >= v1;
      }
      function applyAutorangeMinOptions(v, ax) {
        var autorangeoptions = ax.autorangeoptions;
        if (autorangeoptions && autorangeoptions.minallowed !== void 0 && hasValidMinAndMax(ax, autorangeoptions.minallowed, autorangeoptions.maxallowed)) {
          return autorangeoptions.minallowed;
        }
        if (autorangeoptions && autorangeoptions.clipmin !== void 0 && hasValidMinAndMax(ax, autorangeoptions.clipmin, autorangeoptions.clipmax)) {
          return Math.max(v, ax.d2l(autorangeoptions.clipmin));
        }
        return v;
      }
      function applyAutorangeMaxOptions(v, ax) {
        var autorangeoptions = ax.autorangeoptions;
        if (autorangeoptions && autorangeoptions.maxallowed !== void 0 && hasValidMinAndMax(ax, autorangeoptions.minallowed, autorangeoptions.maxallowed)) {
          return autorangeoptions.maxallowed;
        }
        if (autorangeoptions && autorangeoptions.clipmax !== void 0 && hasValidMinAndMax(ax, autorangeoptions.clipmin, autorangeoptions.clipmax)) {
          return Math.min(v, ax.d2l(autorangeoptions.clipmax));
        }
        return v;
      }
      function hasValidMinAndMax(ax, min, max) {
        if (min !== void 0 && max !== void 0) {
          min = ax.d2l(min);
          max = ax.d2l(max);
          return min < max;
        }
        return true;
      }
      function applyAutorangeOptions(range, ax) {
        if (!ax || !ax.autorangeoptions) return range;
        var min = range[0];
        var max = range[1];
        var include = ax.autorangeoptions.include;
        if (include !== void 0) {
          var lMin = ax.d2l(min);
          var lMax = ax.d2l(max);
          if (!Lib.isArrayOrTypedArray(include)) include = [include];
          for (var i = 0; i < include.length; i++) {
            var v = ax.d2l(include[i]);
            if (lMin >= v) {
              lMin = v;
              min = v;
            }
            if (lMax <= v) {
              lMax = v;
              max = v;
            }
          }
        }
        min = applyAutorangeMinOptions(min, ax);
        max = applyAutorangeMaxOptions(max, ax);
        return [min, max];
      }
    }
  });

  // src/plots/cartesian/axes.js
  var require_axes = __commonJS({
    "src/plots/cartesian/axes.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var Plots = require_plots();
      var Registry = require_registry();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var svgTextUtils = require_svg_text_utils();
      var Titles = require_titles();
      var Color = require_color();
      var Drawing = require_drawing();
      var axAttrs = require_layout_attributes4();
      var cleanTicks = require_clean_ticks();
      var constants = require_numerical();
      var ONEMAXYEAR = constants.ONEMAXYEAR;
      var ONEAVGYEAR = constants.ONEAVGYEAR;
      var ONEMINYEAR = constants.ONEMINYEAR;
      var ONEMAXQUARTER = constants.ONEMAXQUARTER;
      var ONEAVGQUARTER = constants.ONEAVGQUARTER;
      var ONEMINQUARTER = constants.ONEMINQUARTER;
      var ONEMAXMONTH = constants.ONEMAXMONTH;
      var ONEAVGMONTH = constants.ONEAVGMONTH;
      var ONEMINMONTH = constants.ONEMINMONTH;
      var ONEWEEK = constants.ONEWEEK;
      var ONEDAY = constants.ONEDAY;
      var HALFDAY = ONEDAY / 2;
      var ONEHOUR = constants.ONEHOUR;
      var ONEMIN = constants.ONEMIN;
      var ONESEC = constants.ONESEC;
      var ONEMILLI = constants.ONEMILLI;
      var ONEMICROSEC = constants.ONEMICROSEC;
      var MINUS_SIGN = constants.MINUS_SIGN;
      var BADNUM = constants.BADNUM;
      var ZERO_PATH = { K: "zeroline" };
      var GRID_PATH = { K: "gridline", L: "path" };
      var MINORGRID_PATH = { K: "minor-gridline", L: "path" };
      var TICK_PATH = { K: "tick", L: "path" };
      var TICK_TEXT = { K: "tick", L: "text" };
      var MARGIN_MAPPING = {
        width: ["x", "r", "l", "xl", "xr"],
        height: ["y", "t", "b", "yt", "yb"],
        right: ["r", "xr"],
        left: ["l", "xl"],
        top: ["t", "yt"],
        bottom: ["b", "yb"]
      };
      var alignmentConstants = require_alignment();
      var MID_SHIFT = alignmentConstants.MID_SHIFT;
      var CAP_SHIFT = alignmentConstants.CAP_SHIFT;
      var LINE_SPACING = alignmentConstants.LINE_SPACING;
      var OPPOSITE_SIDE = alignmentConstants.OPPOSITE_SIDE;
      var TEXTPAD = 3;
      var axes = module.exports = {};
      axes.setConvert = require_set_convert();
      var autoType = require_axis_autotype();
      var axisIds = require_axis_ids();
      var idSort = axisIds.idSort;
      var isLinked = axisIds.isLinked;
      axes.id2name = axisIds.id2name;
      axes.name2id = axisIds.name2id;
      axes.cleanId = axisIds.cleanId;
      axes.list = axisIds.list;
      axes.listIds = axisIds.listIds;
      axes.getFromId = axisIds.getFromId;
      axes.getFromTrace = axisIds.getFromTrace;
      var autorange = require_autorange();
      axes.getAutoRange = autorange.getAutoRange;
      axes.findExtremes = autorange.findExtremes;
      var epsilon = 1e-4;
      function expandRange(range) {
        var delta = (range[1] - range[0]) * epsilon;
        return [
          range[0] - delta,
          range[1] + delta
        ];
      }
      axes.coerceRef = function(containerIn, containerOut, gd, attr, dflt, extraOption) {
        var axLetter = attr.charAt(attr.length - 1);
        var axlist = gd._fullLayout._subplots[axLetter + "axis"];
        var refAttr = attr + "ref";
        var attrDef = {};
        if (!dflt) dflt = axlist[0] || (typeof extraOption === "string" ? extraOption : extraOption[0]);
        if (!extraOption) extraOption = dflt;
        axlist = axlist.concat(axlist.map(function(x) {
          return x + " domain";
        }));
        attrDef[refAttr] = {
          valType: "enumerated",
          values: axlist.concat(extraOption ? typeof extraOption === "string" ? [extraOption] : extraOption : []),
          dflt
        };
        return Lib.coerce(containerIn, containerOut, attrDef, refAttr);
      };
      axes.getRefType = function(ar) {
        if (ar === void 0) {
          return ar;
        }
        if (ar === "paper") {
          return "paper";
        }
        if (ar === "pixel") {
          return "pixel";
        }
        if (/( domain)$/.test(ar)) {
          return "domain";
        } else {
          return "range";
        }
      };
      axes.coercePosition = function(containerOut, gd, coerce, axRef, attr, dflt) {
        var cleanPos, pos;
        var axRefType = axes.getRefType(axRef);
        if (axRefType !== "range") {
          cleanPos = Lib.ensureNumber;
          pos = coerce(attr, dflt);
        } else {
          var ax = axes.getFromId(gd, axRef);
          dflt = ax.fraction2r(dflt);
          pos = coerce(attr, dflt);
          cleanPos = ax.cleanPos;
        }
        containerOut[attr] = cleanPos(pos);
      };
      axes.cleanPosition = function(pos, gd, axRef) {
        var cleanPos = axRef === "paper" || axRef === "pixel" ? Lib.ensureNumber : axes.getFromId(gd, axRef).cleanPos;
        return cleanPos(pos);
      };
      axes.redrawComponents = function(gd, axIds) {
        axIds = axIds ? axIds : axes.listIds(gd);
        var fullLayout = gd._fullLayout;
        function _redrawOneComp(moduleName, methodName, stashName, shortCircuit) {
          var method = Registry.getComponentMethod(moduleName, methodName);
          var stash = {};
          for (var i = 0; i < axIds.length; i++) {
            var ax = fullLayout[axes.id2name(axIds[i])];
            var indices = ax[stashName];
            for (var j = 0; j < indices.length; j++) {
              var ind = indices[j];
              if (!stash[ind]) {
                method(gd, ind);
                stash[ind] = 1;
                if (shortCircuit) return;
              }
            }
          }
        }
        _redrawOneComp("annotations", "drawOne", "_annIndices");
        _redrawOneComp("shapes", "drawOne", "_shapeIndices");
        _redrawOneComp("images", "draw", "_imgIndices", true);
        _redrawOneComp("selections", "drawOne", "_selectionIndices");
      };
      var getDataConversions = axes.getDataConversions = function(gd, trace, target, targetArray) {
        var ax;
        var d2cTarget = target === "x" || target === "y" || target === "z" ? target : targetArray;
        if (Lib.isArrayOrTypedArray(d2cTarget)) {
          ax = {
            type: autoType(targetArray, void 0, {
              autotypenumbers: gd._fullLayout.autotypenumbers
            }),
            _categories: []
          };
          axes.setConvert(ax);
          if (ax.type === "category") {
            for (var i = 0; i < targetArray.length; i++) {
              ax.d2c(targetArray[i]);
            }
          }
        } else {
          ax = axes.getFromTrace(gd, trace, d2cTarget);
        }
        if (ax) return { d2c: ax.d2c, c2d: ax.c2d };
        if (d2cTarget === "ids") return { d2c: toString, c2d: toString };
        return { d2c: toNum, c2d: toNum };
      };
      function toNum(v) {
        return +v;
      }
      function toString(v) {
        return String(v);
      }
      axes.getDataToCoordFunc = function(gd, trace, target, targetArray) {
        return getDataConversions(gd, trace, target, targetArray).d2c;
      };
      axes.counterLetter = function(id) {
        var axLetter = id.charAt(0);
        if (axLetter === "x") return "y";
        if (axLetter === "y") return "x";
      };
      axes.minDtick = function(ax, newDiff, newFirst, allow) {
        if (["log", "category", "multicategory"].indexOf(ax.type) !== -1 || !allow) {
          ax._minDtick = 0;
        } else if (ax._minDtick === void 0) {
          ax._minDtick = newDiff;
          ax._forceTick0 = newFirst;
        } else if (ax._minDtick) {
          if ((ax._minDtick / newDiff + 1e-6) % 1 < 2e-6 && // existing minDtick is an integer multiple of newDiff
          // (within rounding err)
          // and forceTick0 can be shifted to newFirst
          ((newFirst - ax._forceTick0) / newDiff % 1 + 1.000001) % 1 < 2e-6) {
            ax._minDtick = newDiff;
            ax._forceTick0 = newFirst;
          } else if ((newDiff / ax._minDtick + 1e-6) % 1 > 2e-6 || // if the converse is true (newDiff is a multiple of minDtick and
          // newFirst can be shifted to forceTick0) then do nothing - same
          // forcing stands. Otherwise, cancel forced minimum
          ((newFirst - ax._forceTick0) / ax._minDtick % 1 + 1.000001) % 1 > 2e-6) {
            ax._minDtick = 0;
          }
        }
      };
      axes.saveRangeInitial = function(gd, overwrite) {
        var axList = axes.list(gd, "", true);
        var hasOneAxisChanged = false;
        for (var i = 0; i < axList.length; i++) {
          var ax = axList[i];
          var isNew = ax._rangeInitial0 === void 0 && ax._rangeInitial1 === void 0;
          var hasChanged = isNew || (ax.range[0] !== ax._rangeInitial0 || ax.range[1] !== ax._rangeInitial1);
          var autorange2 = ax.autorange;
          if (isNew && autorange2 !== true || overwrite && hasChanged) {
            ax._rangeInitial0 = autorange2 === "min" || autorange2 === "max reversed" ? void 0 : ax.range[0];
            ax._rangeInitial1 = autorange2 === "max" || autorange2 === "min reversed" ? void 0 : ax.range[1];
            ax._autorangeInitial = autorange2;
            hasOneAxisChanged = true;
          }
        }
        return hasOneAxisChanged;
      };
      axes.saveShowSpikeInitial = function(gd, overwrite) {
        var axList = axes.list(gd, "", true);
        var hasOneAxisChanged = false;
        var allSpikesEnabled = "on";
        for (var i = 0; i < axList.length; i++) {
          var ax = axList[i];
          var isNew = ax._showSpikeInitial === void 0;
          var hasChanged = isNew || !(ax.showspikes === ax._showspikes);
          if (isNew || overwrite && hasChanged) {
            ax._showSpikeInitial = ax.showspikes;
            hasOneAxisChanged = true;
          }
          if (allSpikesEnabled === "on" && !ax.showspikes) {
            allSpikesEnabled = "off";
          }
        }
        gd._fullLayout._cartesianSpikesEnabled = allSpikesEnabled;
        return hasOneAxisChanged;
      };
      axes.autoBin = function(data, ax, nbins, is2d, calendar, size) {
        var dataMin = Lib.aggNums(Math.min, null, data);
        var dataMax = Lib.aggNums(Math.max, null, data);
        if (ax.type === "category" || ax.type === "multicategory") {
          return {
            start: dataMin - 0.5,
            end: dataMax + 0.5,
            size: Math.max(1, Math.round(size) || 1),
            _dataSpan: dataMax - dataMin
          };
        }
        if (!calendar) calendar = ax.calendar;
        var dummyAx;
        if (ax.type === "log") {
          dummyAx = {
            type: "linear",
            range: [dataMin, dataMax]
          };
        } else {
          dummyAx = {
            type: ax.type,
            range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),
            calendar
          };
        }
        axes.setConvert(dummyAx);
        size = size && cleanTicks.dtick(size, dummyAx.type);
        if (size) {
          dummyAx.dtick = size;
          dummyAx.tick0 = cleanTicks.tick0(void 0, dummyAx.type, calendar);
        } else {
          var size0;
          if (nbins) size0 = (dataMax - dataMin) / nbins;
          else {
            var distinctData = Lib.distinctVals(data);
            var msexp = Math.pow(10, Math.floor(
              Math.log(distinctData.minDiff) / Math.LN10
            ));
            var minSize = msexp * Lib.roundUp(
              distinctData.minDiff / msexp,
              [0.9, 1.9, 4.9, 9.9],
              true
            );
            size0 = Math.max(minSize, 2 * Lib.stdev(data) / Math.pow(data.length, is2d ? 0.25 : 0.4));
            if (!isNumeric(size0)) size0 = 1;
          }
          axes.autoTicks(dummyAx, size0);
        }
        var finalSize = dummyAx.dtick;
        var binStart = axes.tickIncrement(
          axes.tickFirst(dummyAx),
          finalSize,
          "reverse",
          calendar
        );
        var binEnd, bincount;
        if (typeof finalSize === "number") {
          binStart = autoShiftNumericBins(binStart, data, dummyAx, dataMin, dataMax);
          bincount = 1 + Math.floor((dataMax - binStart) / finalSize);
          binEnd = binStart + bincount * finalSize;
        } else {
          if (dummyAx.dtick.charAt(0) === "M") {
            binStart = autoShiftMonthBins(binStart, data, finalSize, dataMin, calendar);
          }
          binEnd = binStart;
          bincount = 0;
          while (binEnd <= dataMax) {
            binEnd = axes.tickIncrement(binEnd, finalSize, false, calendar);
            bincount++;
          }
        }
        return {
          start: ax.c2r(binStart, 0, calendar),
          end: ax.c2r(binEnd, 0, calendar),
          size: finalSize,
          _dataSpan: dataMax - dataMin
        };
      };
      function autoShiftNumericBins(binStart, data, ax, dataMin, dataMax) {
        var edgecount = 0;
        var midcount = 0;
        var intcount = 0;
        var blankCount = 0;
        function nearEdge(v) {
          return (1 + (v - binStart) * 100 / ax.dtick) % 100 < 2;
        }
        for (var i = 0; i < data.length; i++) {
          if (data[i] % 1 === 0) intcount++;
          else if (!isNumeric(data[i])) blankCount++;
          if (nearEdge(data[i])) edgecount++;
          if (nearEdge(data[i] + ax.dtick / 2)) midcount++;
        }
        var dataCount = data.length - blankCount;
        if (intcount === dataCount && ax.type !== "date") {
          if (ax.dtick < 1) {
            binStart = dataMin - 0.5 * ax.dtick;
          } else {
            binStart -= 0.5;
            if (binStart + ax.dtick < dataMin) binStart += ax.dtick;
          }
        } else if (midcount < dataCount * 0.1) {
          if (edgecount > dataCount * 0.3 || nearEdge(dataMin) || nearEdge(dataMax)) {
            var binshift = ax.dtick / 2;
            binStart += binStart + binshift < dataMin ? binshift : -binshift;
          }
        }
        return binStart;
      }
      function autoShiftMonthBins(binStart, data, dtick, dataMin, calendar) {
        var stats = Lib.findExactDates(data, calendar);
        var threshold = 0.8;
        if (stats.exactDays > threshold) {
          var numMonths = Number(dtick.substr(1));
          if (stats.exactYears > threshold && numMonths % 12 === 0) {
            binStart = axes.tickIncrement(binStart, "M6", "reverse") + ONEDAY * 1.5;
          } else if (stats.exactMonths > threshold) {
            binStart = axes.tickIncrement(binStart, "M1", "reverse") + ONEDAY * 15.5;
          } else {
            binStart -= HALFDAY;
          }
          var nextBinStart = axes.tickIncrement(binStart, dtick);
          if (nextBinStart <= dataMin) return nextBinStart;
        }
        return binStart;
      }
      axes.prepMinorTicks = function(mockAx, ax, opts) {
        if (!ax.minor.dtick) {
          delete mockAx.dtick;
          var hasMajor = ax.dtick && isNumeric(ax._tmin);
          var mockMinorRange;
          if (hasMajor) {
            var tick2 = axes.tickIncrement(ax._tmin, ax.dtick, true);
            mockMinorRange = [ax._tmin, tick2 * 0.99 + ax._tmin * 0.01];
          } else {
            var rl = Lib.simpleMap(ax.range, ax.r2l);
            mockMinorRange = [rl[0], 0.8 * rl[0] + 0.2 * rl[1]];
          }
          mockAx.range = Lib.simpleMap(mockMinorRange, ax.l2r);
          mockAx._isMinor = true;
          axes.prepTicks(mockAx, opts);
          if (hasMajor) {
            var numericMajor = isNumeric(ax.dtick);
            var numericMinor = isNumeric(mockAx.dtick);
            var majorNum = numericMajor ? ax.dtick : +ax.dtick.substring(1);
            var minorNum = numericMinor ? mockAx.dtick : +mockAx.dtick.substring(1);
            if (numericMajor && numericMinor) {
              if (!isMultiple(majorNum, minorNum)) {
                if (majorNum === 2 * ONEWEEK && minorNum === 3 * ONEDAY) {
                  mockAx.dtick = ONEWEEK;
                } else if (majorNum === ONEWEEK && !(ax._input.minor || {}).nticks) {
                  mockAx.dtick = ONEDAY;
                } else if (isClose(majorNum / minorNum, 2.5)) {
                  mockAx.dtick = majorNum / 2;
                } else {
                  mockAx.dtick = majorNum;
                }
              } else if (majorNum === 2 * ONEWEEK && minorNum === 2 * ONEDAY) {
                mockAx.dtick = ONEWEEK;
              }
            } else if (String(ax.dtick).charAt(0) === "M") {
              if (numericMinor) {
                mockAx.dtick = "M1";
              } else {
                if (!isMultiple(majorNum, minorNum)) {
                  mockAx.dtick = ax.dtick;
                } else if (majorNum >= 12 && minorNum === 2) {
                  mockAx.dtick = "M3";
                }
              }
            } else if (String(mockAx.dtick).charAt(0) === "L") {
              if (String(ax.dtick).charAt(0) === "L") {
                if (!isMultiple(majorNum, minorNum)) {
                  mockAx.dtick = isClose(majorNum / minorNum, 2.5) ? ax.dtick / 2 : ax.dtick;
                }
              } else {
                mockAx.dtick = "D1";
              }
            } else if (mockAx.dtick === "D2" && +ax.dtick > 1) {
              mockAx.dtick = 1;
            }
          }
          mockAx.range = ax.range;
        }
        if (ax.minor._tick0Init === void 0) {
          mockAx.tick0 = ax.tick0;
        }
      };
      function isMultiple(bigger, smaller) {
        return Math.abs((bigger / smaller + 0.5) % 1 - 0.5) < 1e-3;
      }
      function isClose(a, b) {
        return Math.abs(a / b - 1) < 1e-3;
      }
      axes.prepTicks = function(ax, opts) {
        var rng = Lib.simpleMap(ax.range, ax.r2l, void 0, void 0, opts);
        if (ax.tickmode === "auto" || !ax.dtick) {
          var nt = ax.nticks;
          var minPx;
          if (!nt) {
            if (ax.type === "category" || ax.type === "multicategory") {
              minPx = ax.tickfont ? Lib.bigFont(ax.tickfont.size || 12) : 15;
              nt = ax._length / minPx;
            } else {
              minPx = ax._id.charAt(0) === "y" ? 40 : 80;
              nt = Lib.constrain(ax._length / minPx, 4, 9) + 1;
            }
            if (ax._name === "radialaxis") nt *= 2;
          }
          if (!(ax.minor && ax.minor.tickmode !== "array")) {
            if (ax.tickmode === "array") nt *= 100;
          }
          ax._roughDTick = Math.abs(rng[1] - rng[0]) / nt;
          axes.autoTicks(ax, ax._roughDTick);
          if (ax._minDtick > 0 && ax.dtick < ax._minDtick * 2) {
            ax.dtick = ax._minDtick;
            ax.tick0 = ax.l2r(ax._forceTick0);
          }
        }
        if (ax.ticklabelmode === "period") {
          adjustPeriodDelta(ax);
        }
        if (!ax.tick0) {
          ax.tick0 = ax.type === "date" ? "2000-01-01" : 0;
        }
        if (ax.type === "date" && ax.dtick < 0.1) ax.dtick = 0.1;
        autoTickRound(ax);
      };
      function nMonths(dtick) {
        return +dtick.substring(1);
      }
      function adjustPeriodDelta(ax) {
        var definedDelta;
        function mDate() {
          return !(isNumeric(ax.dtick) || ax.dtick.charAt(0) !== "M");
        }
        var isMDate = mDate();
        var tickformat = axes.getTickFormat(ax);
        if (tickformat) {
          var noDtick = ax._dtickInit !== ax.dtick;
          if (!/%[fLQsSMX]/.test(tickformat)) {
            if (/%[HI]/.test(tickformat)) {
              definedDelta = ONEHOUR;
              if (noDtick && !isMDate && ax.dtick < ONEHOUR) ax.dtick = ONEHOUR;
            } else if (/%p/.test(tickformat)) {
              definedDelta = HALFDAY;
              if (noDtick && !isMDate && ax.dtick < HALFDAY) ax.dtick = HALFDAY;
            } else if (/%[Aadejuwx]/.test(tickformat)) {
              definedDelta = ONEDAY;
              if (noDtick && !isMDate && ax.dtick < ONEDAY) ax.dtick = ONEDAY;
            } else if (/%[UVW]/.test(tickformat)) {
              definedDelta = ONEWEEK;
              if (noDtick && !isMDate && ax.dtick < ONEWEEK) ax.dtick = ONEWEEK;
            } else if (/%[Bbm]/.test(tickformat)) {
              definedDelta = ONEAVGMONTH;
              if (noDtick && (isMDate ? nMonths(ax.dtick) < 1 : ax.dtick < ONEMINMONTH)) ax.dtick = "M1";
            } else if (/%[q]/.test(tickformat)) {
              definedDelta = ONEAVGQUARTER;
              if (noDtick && (isMDate ? nMonths(ax.dtick) < 3 : ax.dtick < ONEMINQUARTER)) ax.dtick = "M3";
            } else if (/%[Yy]/.test(tickformat)) {
              definedDelta = ONEAVGYEAR;
              if (noDtick && (isMDate ? nMonths(ax.dtick) < 12 : ax.dtick < ONEMINYEAR)) ax.dtick = "M12";
            }
          }
        }
        isMDate = mDate();
        if (isMDate && ax.tick0 === ax._dowTick0) {
          ax.tick0 = ax._rawTick0;
        }
        ax._definedDelta = definedDelta;
      }
      function positionPeriodTicks(tickVals, ax, definedDelta) {
        for (var i = 0; i < tickVals.length; i++) {
          var v = tickVals[i].value;
          var a = i;
          var b = i + 1;
          if (i < tickVals.length - 1) {
            a = i;
            b = i + 1;
          } else if (i > 0) {
            a = i - 1;
            b = i;
          } else {
            a = i;
            b = i;
          }
          var A = tickVals[a].value;
          var B = tickVals[b].value;
          var actualDelta = Math.abs(B - A);
          var delta = definedDelta || actualDelta;
          var periodLength = 0;
          if (delta >= ONEMINYEAR) {
            if (actualDelta >= ONEMINYEAR && actualDelta <= ONEMAXYEAR) {
              periodLength = actualDelta;
            } else {
              periodLength = ONEAVGYEAR;
            }
          } else if (definedDelta === ONEAVGQUARTER && delta >= ONEMINQUARTER) {
            if (actualDelta >= ONEMINQUARTER && actualDelta <= ONEMAXQUARTER) {
              periodLength = actualDelta;
            } else {
              periodLength = ONEAVGQUARTER;
            }
          } else if (delta >= ONEMINMONTH) {
            if (actualDelta >= ONEMINMONTH && actualDelta <= ONEMAXMONTH) {
              periodLength = actualDelta;
            } else {
              periodLength = ONEAVGMONTH;
            }
          } else if (definedDelta === ONEWEEK && delta >= ONEWEEK) {
            periodLength = ONEWEEK;
          } else if (delta >= ONEDAY) {
            periodLength = ONEDAY;
          } else if (definedDelta === HALFDAY && delta >= HALFDAY) {
            periodLength = HALFDAY;
          } else if (definedDelta === ONEHOUR && delta >= ONEHOUR) {
            periodLength = ONEHOUR;
          }
          var inBetween;
          if (periodLength >= actualDelta) {
            periodLength = actualDelta;
            inBetween = true;
          }
          var endPeriod = v + periodLength;
          if (ax.rangebreaks && periodLength > 0) {
            var nAll = 84;
            var n = 0;
            for (var c = 0; c < nAll; c++) {
              var r = (c + 0.5) / nAll;
              if (ax.maskBreaks(v * (1 - r) + r * endPeriod) !== BADNUM) n++;
            }
            periodLength *= n / nAll;
            if (!periodLength) {
              tickVals[i].drop = true;
            }
            if (inBetween && actualDelta > ONEWEEK) periodLength = actualDelta;
          }
          if (periodLength > 0 || // not instant
          i === 0) {
            tickVals[i].periodX = v + periodLength / 2;
          }
        }
      }
      axes.calcTicks = function calcTicks(ax, opts) {
        var type = ax.type;
        var calendar = ax.calendar;
        var ticklabelstep = ax.ticklabelstep;
        var isPeriod = ax.ticklabelmode === "period";
        var isReversed = ax.range[0] > ax.range[1];
        var ticklabelIndex = !ax.ticklabelindex || Lib.isArrayOrTypedArray(ax.ticklabelindex) ? ax.ticklabelindex : [ax.ticklabelindex];
        var rng = Lib.simpleMap(ax.range, ax.r2l, void 0, void 0, opts);
        var axrev = rng[1] < rng[0];
        var minRange = Math.min(rng[0], rng[1]);
        var maxRange = Math.max(rng[0], rng[1]);
        var maxTicks = Math.max(1e3, ax._length || 0);
        var ticksOut = [];
        var minorTicks = [];
        var tickVals = [];
        var minorTickVals = [];
        var allTicklabelVals = [];
        var hasMinor = ax.minor && (ax.minor.ticks || ax.minor.showgrid);
        for (var major = 1; major >= (hasMinor ? 0 : 1); major--) {
          var isMinor = !major;
          if (major) {
            ax._dtickInit = ax.dtick;
            ax._tick0Init = ax.tick0;
          } else {
            ax.minor._dtickInit = ax.minor.dtick;
            ax.minor._tick0Init = ax.minor.tick0;
          }
          var mockAx = major ? ax : Lib.extendFlat({}, ax, ax.minor);
          if (isMinor) {
            axes.prepMinorTicks(mockAx, ax, opts);
          } else {
            axes.prepTicks(mockAx, opts);
          }
          if (mockAx.tickmode === "array") {
            if (major) {
              tickVals = [];
              ticksOut = arrayTicks(ax, !isMinor);
            } else {
              minorTickVals = [];
              minorTicks = arrayTicks(ax, !isMinor);
            }
            continue;
          }
          if (mockAx.tickmode === "sync") {
            tickVals = [];
            ticksOut = syncTicks(ax);
            continue;
          }
          var exRng = expandRange(rng);
          var startTick = exRng[0];
          var endTick = exRng[1];
          var numDtick = isNumeric(mockAx.dtick);
          var isDLog = type === "log" && !(numDtick || mockAx.dtick.charAt(0) === "L");
          var x0 = axes.tickFirst(mockAx, opts);
          if (major) {
            ax._tmin = x0;
            if (x0 < startTick !== axrev) break;
            if (type === "category" || type === "multicategory") {
              endTick = axrev ? Math.max(-0.5, endTick) : Math.min(ax._categories.length - 0.5, endTick);
            }
          }
          var prevX = null;
          var x = x0;
          var majorId;
          if (major) {
            var _dTick;
            if (numDtick) {
              _dTick = ax.dtick;
            } else {
              if (type === "date") {
                if (typeof ax.dtick === "string" && ax.dtick.charAt(0) === "M") {
                  _dTick = ONEAVGMONTH * ax.dtick.substring(1);
                }
              } else {
                _dTick = ax._roughDTick;
              }
            }
            majorId = Math.round((ax.r2l(x) - ax.r2l(ax.tick0)) / _dTick) - 1;
          }
          var dtick = mockAx.dtick;
          if (mockAx.rangebreaks && mockAx._tick0Init !== mockAx.tick0) {
            x = moveOutsideBreak(x, ax);
            if (!axrev) {
              x = axes.tickIncrement(x, dtick, !axrev, calendar);
            }
          }
          if (major && isPeriod) {
            x = axes.tickIncrement(x, dtick, !axrev, calendar);
            majorId--;
          }
          for (; axrev ? x >= endTick : x <= endTick; x = axes.tickIncrement(
            x,
            dtick,
            axrev,
            calendar
          )) {
            if (major) majorId++;
            if (mockAx.rangebreaks) {
              if (!axrev) {
                if (x < startTick) continue;
                if (mockAx.maskBreaks(x) === BADNUM && moveOutsideBreak(x, mockAx) >= maxRange) break;
              }
            }
            if (tickVals.length > maxTicks || x === prevX) break;
            prevX = x;
            var obj = { value: x };
            if (major) {
              if (isDLog && x !== (x | 0)) {
                obj.simpleLabel = true;
              }
              if (ticklabelstep > 1 && majorId % ticklabelstep) {
                obj.skipLabel = true;
              }
              tickVals.push(obj);
            } else {
              obj.minor = true;
              minorTickVals.push(obj);
            }
          }
        }
        if (!minorTickVals || minorTickVals.length < 2) {
          ticklabelIndex = false;
        } else {
          var diff = (minorTickVals[1].value - minorTickVals[0].value) * (isReversed ? -1 : 1);
          if (!periodCompatibleWithTickformat(diff, ax.tickformat)) {
            ticklabelIndex = false;
          }
        }
        if (!ticklabelIndex) {
          allTicklabelVals = tickVals;
        } else {
          var allTickVals = tickVals.concat(minorTickVals);
          if (isPeriod && tickVals.length) {
            allTickVals = allTickVals.slice(1);
          }
          allTickVals = allTickVals.sort(function(a, b) {
            return a.value - b.value;
          }).filter(function(tick, index, self2) {
            return index === 0 || tick.value !== self2[index - 1].value;
          });
          var majorTickIndices = allTickVals.map(function(item, index) {
            return item.minor === void 0 && !item.skipLabel ? index : null;
          }).filter(function(index) {
            return index !== null;
          });
          majorTickIndices.forEach(function(majorIdx) {
            ticklabelIndex.map(function(nextLabelIdx) {
              var minorIdx = majorIdx + nextLabelIdx;
              if (minorIdx >= 0 && minorIdx < allTickVals.length) {
                Lib.pushUnique(allTicklabelVals, allTickVals[minorIdx]);
              }
            });
          });
        }
        if (hasMinor) {
          var canOverlap = ax.minor.ticks === "inside" && ax.ticks === "outside" || ax.minor.ticks === "outside" && ax.ticks === "inside";
          if (!canOverlap) {
            var majorValues = tickVals.map(function(d) {
              return d.value;
            });
            var list = [];
            for (var k = 0; k < minorTickVals.length; k++) {
              var T = minorTickVals[k];
              var v = T.value;
              if (majorValues.indexOf(v) !== -1) {
                continue;
              }
              var found = false;
              for (var q = 0; !found && q < tickVals.length; q++) {
                if (
                  // add 10e6 to eliminate problematic digits
                  1e7 + tickVals[q].value === 1e7 + v
                ) {
                  found = true;
                }
              }
              if (!found) list.push(T);
            }
            minorTickVals = list;
          }
        }
        if (isPeriod) positionPeriodTicks(allTicklabelVals, ax, ax._definedDelta);
        var i;
        if (ax.rangebreaks) {
          var flip = ax._id.charAt(0) === "y";
          var fontSize = 1;
          if (ax.tickmode === "auto") {
            fontSize = ax.tickfont ? ax.tickfont.size : 12;
          }
          var prevL = NaN;
          for (i = tickVals.length - 1; i > -1; i--) {
            if (tickVals[i].drop) {
              tickVals.splice(i, 1);
              continue;
            }
            tickVals[i].value = moveOutsideBreak(tickVals[i].value, ax);
            var l = ax.c2p(tickVals[i].value);
            if (flip ? prevL > l - fontSize : prevL < l + fontSize) {
              tickVals.splice(axrev ? i + 1 : i, 1);
            } else {
              prevL = l;
            }
          }
        }
        if (isAngular(ax) && Math.abs(rng[1] - rng[0]) === 360) {
          tickVals.pop();
        }
        ax._tmax = (tickVals[tickVals.length - 1] || {}).value;
        ax._prevDateHead = "";
        ax._inCalcTicks = true;
        var lastVisibleHead;
        var hideLabel = function(tick) {
          tick.text = "";
          ax._prevDateHead = lastVisibleHead;
        };
        tickVals = tickVals.concat(minorTickVals);
        function setTickLabel(ax2, tickVal) {
          var text = axes.tickText(
            ax2,
            tickVal.value,
            false,
            // hover
            tickVal.simpleLabel
            // noSuffixPrefix
          );
          var p = tickVal.periodX;
          if (p !== void 0) {
            text.periodX = p;
            if (p > maxRange || p < minRange) {
              if (p > maxRange) text.periodX = maxRange;
              if (p < minRange) text.periodX = minRange;
              hideLabel(text);
            }
          }
          return text;
        }
        var t;
        for (i = 0; i < tickVals.length; i++) {
          var _minor = tickVals[i].minor;
          var _value = tickVals[i].value;
          if (_minor) {
            if (ticklabelIndex && allTicklabelVals.indexOf(tickVals[i]) !== -1) {
              t = setTickLabel(ax, tickVals[i]);
            } else {
              t = { x: _value };
            }
            t.minor = true;
            minorTicks.push(t);
          } else {
            lastVisibleHead = ax._prevDateHead;
            t = setTickLabel(ax, tickVals[i]);
            if (tickVals[i].skipLabel || ticklabelIndex && allTicklabelVals.indexOf(tickVals[i]) === -1) {
              hideLabel(t);
            }
            ticksOut.push(t);
          }
        }
        ticksOut = ticksOut.concat(minorTicks);
        ax._inCalcTicks = false;
        if (isPeriod && ticksOut.length) {
          ticksOut[0].noTick = true;
        }
        return ticksOut;
      };
      function filterRangeBreaks(ax, ticksOut) {
        if (ax.rangebreaks) {
          ticksOut = ticksOut.filter(function(d) {
            return ax.maskBreaks(d.x) !== BADNUM;
          });
        }
        return ticksOut;
      }
      function syncTicks(ax) {
        var baseAxis = ax._mainAxis;
        var ticksOut = [];
        if (baseAxis._vals) {
          for (var i = 0; i < baseAxis._vals.length; i++) {
            if (baseAxis._vals[i].noTick) {
              continue;
            }
            var pos = baseAxis.l2p(baseAxis._vals[i].x);
            var vali = ax.p2l(pos);
            var obj = axes.tickText(ax, vali);
            if (baseAxis._vals[i].minor) {
              obj.minor = true;
              obj.text = "";
            }
            ticksOut.push(obj);
          }
        }
        ticksOut = filterRangeBreaks(ax, ticksOut);
        return ticksOut;
      }
      function arrayTicks(ax, majorOnly) {
        var rng = Lib.simpleMap(ax.range, ax.r2l);
        var exRng = expandRange(rng);
        var tickMin = Math.min(exRng[0], exRng[1]);
        var tickMax = Math.max(exRng[0], exRng[1]);
        var tickVal2l = ax.type === "category" ? ax.d2l_noadd : ax.d2l;
        if (ax.type === "log" && String(ax.dtick).charAt(0) !== "L") {
          ax.dtick = "L" + Math.pow(10, Math.floor(Math.min(ax.range[0], ax.range[1])) - 1);
        }
        var ticksOut = [];
        for (var isMinor = 0; isMinor <= 1; isMinor++) {
          if (majorOnly !== void 0 && (majorOnly && isMinor || majorOnly === false && !isMinor)) continue;
          if (isMinor && !ax.minor) continue;
          var vals = !isMinor ? ax.tickvals : ax.minor.tickvals;
          var text = !isMinor ? ax.ticktext : [];
          if (!vals) continue;
          if (!Lib.isArrayOrTypedArray(text)) text = [];
          for (var i = 0; i < vals.length; i++) {
            var vali = tickVal2l(vals[i]);
            if (vali > tickMin && vali < tickMax) {
              var obj = axes.tickText(ax, vali, false, String(text[i]));
              if (isMinor) {
                obj.minor = true;
                obj.text = "";
              }
              ticksOut.push(obj);
            }
          }
        }
        ticksOut = filterRangeBreaks(ax, ticksOut);
        return ticksOut;
      }
      var roundBase10 = [2, 5, 10];
      var roundBase24 = [1, 2, 3, 6, 12];
      var roundBase60 = [1, 2, 5, 10, 15, 30];
      var roundDays = [1, 2, 3, 7, 14];
      var roundLog1 = [-0.046, 0, 0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1];
      var roundLog2 = [-0.301, 0, 0.301, 0.699, 1];
      var roundAngles = [15, 30, 45, 90, 180];
      function roundDTick(roughDTick, base, roundingSet) {
        return base * Lib.roundUp(roughDTick / base, roundingSet);
      }
      axes.autoTicks = function(ax, roughDTick, isMinor) {
        var base;
        function getBase(v) {
          return Math.pow(v, Math.floor(Math.log(roughDTick) / Math.LN10));
        }
        if (ax.type === "date") {
          ax.tick0 = Lib.dateTick0(ax.calendar, 0);
          var roughX2 = 2 * roughDTick;
          if (roughX2 > ONEAVGYEAR) {
            roughDTick /= ONEAVGYEAR;
            base = getBase(10);
            ax.dtick = "M" + 12 * roundDTick(roughDTick, base, roundBase10);
          } else if (roughX2 > ONEAVGMONTH) {
            roughDTick /= ONEAVGMONTH;
            ax.dtick = "M" + roundDTick(roughDTick, 1, roundBase24);
          } else if (roughX2 > ONEDAY) {
            ax.dtick = roundDTick(roughDTick, ONEDAY, ax._hasDayOfWeekBreaks ? [1, 2, 7, 14] : roundDays);
            if (!isMinor) {
              var tickformat = axes.getTickFormat(ax);
              var isPeriod = ax.ticklabelmode === "period";
              if (isPeriod) ax._rawTick0 = ax.tick0;
              if (/%[uVW]/.test(tickformat)) {
                ax.tick0 = Lib.dateTick0(ax.calendar, 2);
              } else {
                ax.tick0 = Lib.dateTick0(ax.calendar, 1);
              }
              if (isPeriod) ax._dowTick0 = ax.tick0;
            }
          } else if (roughX2 > ONEHOUR) {
            ax.dtick = roundDTick(roughDTick, ONEHOUR, roundBase24);
          } else if (roughX2 > ONEMIN) {
            ax.dtick = roundDTick(roughDTick, ONEMIN, roundBase60);
          } else if (roughX2 > ONESEC) {
            ax.dtick = roundDTick(roughDTick, ONESEC, roundBase60);
          } else {
            base = getBase(10);
            ax.dtick = roundDTick(roughDTick, base, roundBase10);
          }
        } else if (ax.type === "log") {
          ax.tick0 = 0;
          var rng = Lib.simpleMap(ax.range, ax.r2l);
          if (ax._isMinor) {
            roughDTick *= 1.5;
          }
          if (roughDTick > 0.7) {
            ax.dtick = Math.ceil(roughDTick);
          } else if (Math.abs(rng[1] - rng[0]) < 1) {
            var nt = 1.5 * Math.abs((rng[1] - rng[0]) / roughDTick);
            roughDTick = Math.abs(Math.pow(10, rng[1]) - Math.pow(10, rng[0])) / nt;
            base = getBase(10);
            ax.dtick = "L" + roundDTick(roughDTick, base, roundBase10);
          } else {
            ax.dtick = roughDTick > 0.3 ? "D2" : "D1";
          }
        } else if (ax.type === "category" || ax.type === "multicategory") {
          ax.tick0 = 0;
          ax.dtick = Math.ceil(Math.max(roughDTick, 1));
        } else if (isAngular(ax)) {
          ax.tick0 = 0;
          base = 1;
          ax.dtick = roundDTick(roughDTick, base, roundAngles);
        } else {
          ax.tick0 = 0;
          base = getBase(10);
          ax.dtick = roundDTick(roughDTick, base, roundBase10);
        }
        if (ax.dtick === 0) ax.dtick = 1;
        if (!isNumeric(ax.dtick) && typeof ax.dtick !== "string") {
          var olddtick = ax.dtick;
          ax.dtick = 1;
          throw "ax.dtick error: " + String(olddtick);
        }
      };
      function autoTickRound(ax) {
        var dtick = ax.dtick;
        ax._tickexponent = 0;
        if (!isNumeric(dtick) && typeof dtick !== "string") {
          dtick = 1;
        }
        if (ax.type === "category" || ax.type === "multicategory") {
          ax._tickround = null;
        }
        if (ax.type === "date") {
          var tick0ms = ax.r2l(ax.tick0);
          var tick0str = ax.l2r(tick0ms).replace(/(^-|i)/g, "");
          var tick0len = tick0str.length;
          if (String(dtick).charAt(0) === "M") {
            if (tick0len > 10 || tick0str.substr(5) !== "01-01") ax._tickround = "d";
            else ax._tickround = +dtick.substr(1) % 12 === 0 ? "y" : "m";
          } else if (dtick >= ONEDAY && tick0len <= 10 || dtick >= ONEDAY * 15) ax._tickround = "d";
          else if (dtick >= ONEMIN && tick0len <= 16 || dtick >= ONEHOUR) ax._tickround = "M";
          else if (dtick >= ONESEC && tick0len <= 19 || dtick >= ONEMIN) ax._tickround = "S";
          else {
            var tick1len = ax.l2r(tick0ms + dtick).replace(/^-/, "").length;
            ax._tickround = Math.max(tick0len, tick1len) - 20;
            if (ax._tickround < 0) ax._tickround = 4;
          }
        } else if (isNumeric(dtick) || dtick.charAt(0) === "L") {
          var rng = ax.range.map(ax.r2d || Number);
          if (!isNumeric(dtick)) dtick = Number(dtick.substr(1));
          ax._tickround = 2 - Math.floor(Math.log(dtick) / Math.LN10 + 0.01);
          var maxend = Math.max(Math.abs(rng[0]), Math.abs(rng[1]));
          var rangeexp = Math.floor(Math.log(maxend) / Math.LN10 + 0.01);
          var minexponent = ax.minexponent === void 0 ? 3 : ax.minexponent;
          if (Math.abs(rangeexp) > minexponent) {
            if (isSIFormat(ax.exponentformat) && !beyondSI(rangeexp)) {
              ax._tickexponent = 3 * Math.round((rangeexp - 1) / 3);
            } else ax._tickexponent = rangeexp;
          }
        } else {
          ax._tickround = null;
        }
      }
      axes.tickIncrement = function(x, dtick, axrev, calendar) {
        var axSign = axrev ? -1 : 1;
        if (isNumeric(dtick)) return Lib.increment(x, axSign * dtick);
        var tType = dtick.charAt(0);
        var dtSigned = axSign * Number(dtick.substr(1));
        if (tType === "M") return Lib.incrementMonth(x, dtSigned, calendar);
        if (tType === "L") return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10;
        if (tType === "D") {
          var tickset = dtick === "D2" ? roundLog2 : roundLog1;
          var x2 = x + axSign * 0.01;
          var frac = Lib.roundUp(Lib.mod(x2, 1), tickset, axrev);
          return Math.floor(x2) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;
        }
        throw "unrecognized dtick " + String(dtick);
      };
      axes.tickFirst = function(ax, opts) {
        var r2l = ax.r2l || Number;
        var rng = Lib.simpleMap(ax.range, r2l, void 0, void 0, opts);
        var axrev = rng[1] < rng[0];
        var sRound = axrev ? Math.floor : Math.ceil;
        var r0 = expandRange(rng)[0];
        var dtick = ax.dtick;
        var tick0 = r2l(ax.tick0);
        if (isNumeric(dtick)) {
          var tmin = sRound((r0 - tick0) / dtick) * dtick + tick0;
          if (ax.type === "category" || ax.type === "multicategory") {
            tmin = Lib.constrain(tmin, 0, ax._categories.length - 1);
          }
          return tmin;
        }
        var tType = dtick.charAt(0);
        var dtNum = Number(dtick.substr(1));
        if (tType === "M") {
          var cnt = 0;
          var t0 = tick0;
          var t1, mult, newDTick;
          while (cnt < 10) {
            t1 = axes.tickIncrement(t0, dtick, axrev, ax.calendar);
            if ((t1 - r0) * (t0 - r0) <= 0) {
              if (axrev) return Math.min(t0, t1);
              return Math.max(t0, t1);
            }
            mult = (r0 - (t0 + t1) / 2) / (t1 - t0);
            newDTick = tType + (Math.abs(Math.round(mult)) || 1) * dtNum;
            t0 = axes.tickIncrement(t0, newDTick, mult < 0 ? !axrev : axrev, ax.calendar);
            cnt++;
          }
          Lib.error("tickFirst did not converge", ax);
          return t0;
        } else if (tType === "L") {
          return Math.log(sRound(
            (Math.pow(10, r0) - tick0) / dtNum
          ) * dtNum + tick0) / Math.LN10;
        } else if (tType === "D") {
          var tickset = dtick === "D2" ? roundLog2 : roundLog1;
          var frac = Lib.roundUp(Lib.mod(r0, 1), tickset, axrev);
          return Math.floor(r0) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;
        } else throw "unrecognized dtick " + String(dtick);
      };
      axes.tickText = function(ax, x, hover, noSuffixPrefix) {
        var out = tickTextObj(ax, x);
        var arrayMode = ax.tickmode === "array";
        var extraPrecision = hover || arrayMode;
        var axType = ax.type;
        var tickVal2l = axType === "category" ? ax.d2l_noadd : ax.d2l;
        var i;
        var inbounds = function(v) {
          var p = ax.l2p(v);
          return p >= 0 && p <= ax._length ? v : null;
        };
        if (arrayMode && Lib.isArrayOrTypedArray(ax.ticktext)) {
          var rng = Lib.simpleMap(ax.range, ax.r2l);
          var minDiff = (Math.abs(rng[1] - rng[0]) - (ax._lBreaks || 0)) / 1e4;
          for (i = 0; i < ax.ticktext.length; i++) {
            if (Math.abs(x - tickVal2l(ax.tickvals[i])) < minDiff) break;
          }
          if (i < ax.ticktext.length) {
            out.text = String(ax.ticktext[i]);
            out.xbnd = [
              inbounds(out.x - 0.5),
              inbounds(out.x + ax.dtick - 0.5)
            ];
            return out;
          }
        }
        function isHidden(showAttr) {
          if (showAttr === void 0) return true;
          if (hover) return showAttr === "none";
          var firstOrLast = {
            first: ax._tmin,
            last: ax._tmax
          }[showAttr];
          return showAttr !== "all" && x !== firstOrLast;
        }
        var hideexp = hover ? "never" : ax.exponentformat !== "none" && isHidden(ax.showexponent) ? "hide" : "";
        if (axType === "date") formatDate(ax, out, hover, extraPrecision);
        else if (axType === "log") formatLog(ax, out, hover, extraPrecision, hideexp);
        else if (axType === "category") formatCategory(ax, out);
        else if (axType === "multicategory") formatMultiCategory(ax, out, hover);
        else if (isAngular(ax)) formatAngle(ax, out, hover, extraPrecision, hideexp);
        else formatLinear(ax, out, hover, extraPrecision, hideexp);
        if (!noSuffixPrefix) {
          if (ax.tickprefix && !isHidden(ax.showtickprefix)) out.text = ax.tickprefix + out.text;
          if (ax.ticksuffix && !isHidden(ax.showticksuffix)) out.text += ax.ticksuffix;
        }
        if (ax.labelalias && ax.labelalias.hasOwnProperty(out.text)) {
          var t = ax.labelalias[out.text];
          if (typeof t === "string") out.text = t;
        }
        if (ax.tickson === "boundaries" || ax.showdividers) {
          out.xbnd = [
            inbounds(out.x - 0.5),
            inbounds(out.x + ax.dtick - 0.5)
          ];
        }
        return out;
      };
      axes.hoverLabelText = function(ax, values, hoverformat) {
        if (hoverformat) ax = Lib.extendFlat({}, ax, { hoverformat });
        var val = Lib.isArrayOrTypedArray(values) ? values[0] : values;
        var val2 = Lib.isArrayOrTypedArray(values) ? values[1] : void 0;
        if (val2 !== void 0 && val2 !== val) {
          return axes.hoverLabelText(ax, val, hoverformat) + " - " + axes.hoverLabelText(ax, val2, hoverformat);
        }
        var logOffScale = ax.type === "log" && val <= 0;
        var tx = axes.tickText(ax, ax.c2l(logOffScale ? -val : val), "hover").text;
        if (logOffScale) {
          return val === 0 ? "0" : MINUS_SIGN + tx;
        }
        return tx;
      };
      function tickTextObj(ax, x, text) {
        var tf = ax.tickfont || {};
        return {
          x,
          dx: 0,
          dy: 0,
          text: text || "",
          fontSize: tf.size,
          font: tf.family,
          fontWeight: tf.weight,
          fontStyle: tf.style,
          fontVariant: tf.variant,
          fontTextcase: tf.textcase,
          fontLineposition: tf.lineposition,
          fontShadow: tf.shadow,
          fontColor: tf.color
        };
      }
      function formatDate(ax, out, hover, extraPrecision) {
        var tr = ax._tickround;
        var fmt = hover && ax.hoverformat || axes.getTickFormat(ax);
        extraPrecision = !fmt && extraPrecision;
        if (extraPrecision) {
          if (isNumeric(tr)) tr = 4;
          else tr = { y: "m", m: "d", d: "M", M: "S", S: 4 }[tr];
        }
        var dateStr = Lib.formatDate(out.x, fmt, tr, ax._dateFormat, ax.calendar, ax._extraFormat);
        var headStr;
        var splitIndex = dateStr.indexOf("\n");
        if (splitIndex !== -1) {
          headStr = dateStr.substr(splitIndex + 1);
          dateStr = dateStr.substr(0, splitIndex);
        }
        if (extraPrecision) {
          if (headStr !== void 0 && (dateStr === "00:00:00" || dateStr === "00:00")) {
            dateStr = headStr;
            headStr = "";
          } else if (dateStr.length === 8) {
            dateStr = dateStr.replace(/:00$/, "");
          }
        }
        if (headStr) {
          if (hover) {
            if (tr === "d") dateStr += ", " + headStr;
            else dateStr = headStr + (dateStr ? ", " + dateStr : "");
          } else {
            if (!ax._inCalcTicks || ax._prevDateHead !== headStr) {
              ax._prevDateHead = headStr;
              dateStr += "<br>" + headStr;
            } else {
              var isInside = insideTicklabelposition(ax);
              var side = ax._trueSide || ax.side;
              if (!isInside && side === "top" || isInside && side === "bottom") {
                dateStr += "<br> ";
              }
            }
          }
        }
        out.text = dateStr;
      }
      function formatLog(ax, out, hover, extraPrecision, hideexp) {
        var dtick = ax.dtick;
        var x = out.x;
        var tickformat = ax.tickformat;
        var dtChar0 = typeof dtick === "string" && dtick.charAt(0);
        if (hideexp === "never") {
          hideexp = "";
        }
        if (extraPrecision && dtChar0 !== "L") {
          dtick = "L3";
          dtChar0 = "L";
        }
        if (tickformat || dtChar0 === "L") {
          out.text = numFormat(Math.pow(10, x), ax, hideexp, extraPrecision);
        } else if (isNumeric(dtick) || dtChar0 === "D" && Lib.mod(x + 0.01, 1) < 0.1) {
          var p = Math.round(x);
          var absP = Math.abs(p);
          var exponentFormat = ax.exponentformat;
          if (exponentFormat === "power" || isSIFormat(exponentFormat) && beyondSI(p)) {
            if (p === 0) out.text = 1;
            else if (p === 1) out.text = "10";
            else out.text = "10<sup>" + (p > 1 ? "" : MINUS_SIGN) + absP + "</sup>";
            out.fontSize *= 1.25;
          } else if ((exponentFormat === "e" || exponentFormat === "E") && absP > 2) {
            out.text = "1" + exponentFormat + (p > 0 ? "+" : MINUS_SIGN) + absP;
          } else {
            out.text = numFormat(Math.pow(10, x), ax, "", "fakehover");
            if (dtick === "D1" && ax._id.charAt(0) === "y") {
              out.dy -= out.fontSize / 6;
            }
          }
        } else if (dtChar0 === "D") {
          out.text = String(Math.round(Math.pow(10, Lib.mod(x, 1))));
          out.fontSize *= 0.75;
        } else throw "unrecognized dtick " + String(dtick);
        if (ax.dtick === "D1") {
          var firstChar = String(out.text).charAt(0);
          if (firstChar === "0" || firstChar === "1") {
            if (ax._id.charAt(0) === "y") {
              out.dx -= out.fontSize / 4;
            } else {
              out.dy += out.fontSize / 2;
              out.dx += (ax.range[1] > ax.range[0] ? 1 : -1) * out.fontSize * (x < 0 ? 0.5 : 0.25);
            }
          }
        }
      }
      function formatCategory(ax, out) {
        var tt = ax._categories[Math.round(out.x)];
        if (tt === void 0) tt = "";
        out.text = String(tt);
      }
      function formatMultiCategory(ax, out, hover) {
        var v = Math.round(out.x);
        var cats = ax._categories[v] || [];
        var tt = cats[1] === void 0 ? "" : String(cats[1]);
        var tt2 = cats[0] === void 0 ? "" : String(cats[0]);
        if (hover) {
          out.text = tt2 + " - " + tt;
        } else {
          out.text = tt;
          out.text2 = tt2;
        }
      }
      function formatLinear(ax, out, hover, extraPrecision, hideexp) {
        if (hideexp === "never") {
          hideexp = "";
        } else if (ax.showexponent === "all" && Math.abs(out.x / ax.dtick) < 1e-6) {
          hideexp = "hide";
        }
        out.text = numFormat(out.x, ax, hideexp, extraPrecision);
      }
      function formatAngle(ax, out, hover, extraPrecision, hideexp) {
        if (ax.thetaunit === "radians" && !hover) {
          var num = out.x / 180;
          if (num === 0) {
            out.text = "0";
          } else {
            var frac = num2frac(num);
            if (frac[1] >= 100) {
              out.text = numFormat(Lib.deg2rad(out.x), ax, hideexp, extraPrecision);
            } else {
              var isNeg = out.x < 0;
              if (frac[1] === 1) {
                if (frac[0] === 1) out.text = "\u03C0";
                else out.text = frac[0] + "\u03C0";
              } else {
                out.text = [
                  "<sup>",
                  frac[0],
                  "</sup>",
                  "\u2044",
                  "<sub>",
                  frac[1],
                  "</sub>",
                  "\u03C0"
                ].join("");
              }
              if (isNeg) out.text = MINUS_SIGN + out.text;
            }
          }
        } else {
          out.text = numFormat(out.x, ax, hideexp, extraPrecision);
        }
      }
      function num2frac(num) {
        function almostEq(a, b) {
          return Math.abs(a - b) <= 1e-6;
        }
        function findGCD(a, b) {
          return almostEq(b, 0) ? a : findGCD(b, a % b);
        }
        function findPrecision(n) {
          var e = 1;
          while (!almostEq(Math.round(n * e) / e, n)) {
            e *= 10;
          }
          return e;
        }
        var precision = findPrecision(num);
        var number = num * precision;
        var gcd = Math.abs(findGCD(number, precision));
        return [
          // numerator
          Math.round(number / gcd),
          // denominator
          Math.round(precision / gcd)
        ];
      }
      var SIPREFIXES = ["f", "p", "n", "\u03BC", "m", "", "k", "M", "G", "T"];
      function isSIFormat(exponentFormat) {
        return exponentFormat === "SI" || exponentFormat === "B";
      }
      function beyondSI(exponent) {
        return exponent > 14 || exponent < -15;
      }
      function numFormat(v, ax, fmtoverride, hover) {
        var isNeg = v < 0;
        var tickRound = ax._tickround;
        var exponentFormat = fmtoverride || ax.exponentformat || "B";
        var exponent = ax._tickexponent;
        var tickformat = axes.getTickFormat(ax);
        var separatethousands = ax.separatethousands;
        if (hover) {
          var ah = {
            exponentformat: exponentFormat,
            minexponent: ax.minexponent,
            dtick: ax.showexponent === "none" ? ax.dtick : isNumeric(v) ? Math.abs(v) || 1 : 1,
            // if not showing any exponents, don't change the exponent
            // from what we calculate
            range: ax.showexponent === "none" ? ax.range.map(ax.r2d) : [0, v || 1]
          };
          autoTickRound(ah);
          tickRound = (Number(ah._tickround) || 0) + 4;
          exponent = ah._tickexponent;
          if (ax.hoverformat) tickformat = ax.hoverformat;
        }
        if (tickformat) return ax._numFormat(tickformat)(v).replace(/-/g, MINUS_SIGN);
        var e = Math.pow(10, -tickRound) / 2;
        if (exponentFormat === "none") exponent = 0;
        v = Math.abs(v);
        if (v < e) {
          v = "0";
          isNeg = false;
        } else {
          v += e;
          if (exponent) {
            v *= Math.pow(10, -exponent);
            tickRound += exponent;
          }
          if (tickRound === 0) v = String(Math.floor(v));
          else if (tickRound < 0) {
            v = String(Math.round(v));
            v = v.substr(0, v.length + tickRound);
            for (var i = tickRound; i < 0; i++) v += "0";
          } else {
            v = String(v);
            var dp = v.indexOf(".") + 1;
            if (dp) v = v.substr(0, dp + tickRound).replace(/\.?0+$/, "");
          }
          v = Lib.numSeparate(v, ax._separators, separatethousands);
        }
        if (exponent && exponentFormat !== "hide") {
          if (isSIFormat(exponentFormat) && beyondSI(exponent)) exponentFormat = "power";
          var signedExponent;
          if (exponent < 0) signedExponent = MINUS_SIGN + -exponent;
          else if (exponentFormat !== "power") signedExponent = "+" + exponent;
          else signedExponent = String(exponent);
          if (exponentFormat === "e" || exponentFormat === "E") {
            v += exponentFormat + signedExponent;
          } else if (exponentFormat === "power") {
            v += "\xD710<sup>" + signedExponent + "</sup>";
          } else if (exponentFormat === "B" && exponent === 9) {
            v += "B";
          } else if (isSIFormat(exponentFormat)) {
            v += SIPREFIXES[exponent / 3 + 5];
          }
        }
        if (isNeg) return MINUS_SIGN + v;
        return v;
      }
      axes.getTickFormat = function(ax) {
        var i;
        function convertToMs(dtick) {
          return typeof dtick !== "string" ? dtick : Number(dtick.replace("M", "")) * ONEAVGMONTH;
        }
        function compareLogTicks(left, right) {
          var priority = ["L", "D"];
          if (typeof left === typeof right) {
            if (typeof left === "number") {
              return left - right;
            } else {
              var leftPriority = priority.indexOf(left.charAt(0));
              var rightPriority = priority.indexOf(right.charAt(0));
              if (leftPriority === rightPriority) {
                return Number(left.replace(/(L|D)/g, "")) - Number(right.replace(/(L|D)/g, ""));
              } else {
                return leftPriority - rightPriority;
              }
            }
          } else {
            return typeof left === "number" ? 1 : -1;
          }
        }
        function isProperStop(dtick, range, convert) {
          var convertFn = convert || function(x) {
            return x;
          };
          var leftDtick = range[0];
          var rightDtick = range[1];
          return (!leftDtick && typeof leftDtick !== "number" || convertFn(leftDtick) <= convertFn(dtick)) && (!rightDtick && typeof rightDtick !== "number" || convertFn(rightDtick) >= convertFn(dtick));
        }
        function isProperLogStop(dtick, range) {
          var isLeftDtickNull = range[0] === null;
          var isRightDtickNull = range[1] === null;
          var isDtickInRangeLeft = compareLogTicks(dtick, range[0]) >= 0;
          var isDtickInRangeRight = compareLogTicks(dtick, range[1]) <= 0;
          return (isLeftDtickNull || isDtickInRangeLeft) && (isRightDtickNull || isDtickInRangeRight);
        }
        var tickstop, stopi;
        if (ax.tickformatstops && ax.tickformatstops.length > 0) {
          switch (ax.type) {
            case "date":
            case "linear": {
              for (i = 0; i < ax.tickformatstops.length; i++) {
                stopi = ax.tickformatstops[i];
                if (stopi.enabled && isProperStop(ax.dtick, stopi.dtickrange, convertToMs)) {
                  tickstop = stopi;
                  break;
                }
              }
              break;
            }
            case "log": {
              for (i = 0; i < ax.tickformatstops.length; i++) {
                stopi = ax.tickformatstops[i];
                if (stopi.enabled && isProperLogStop(ax.dtick, stopi.dtickrange)) {
                  tickstop = stopi;
                  break;
                }
              }
              break;
            }
            default:
          }
        }
        return tickstop ? tickstop.value : ax.tickformat;
      };
      axes.getSubplots = function(gd, ax) {
        var subplotObj = gd._fullLayout._subplots;
        var allSubplots = subplotObj.cartesian.concat(subplotObj.gl2d || []);
        var out = ax ? axes.findSubplotsWithAxis(allSubplots, ax) : allSubplots;
        out.sort(function(a, b) {
          var aParts = a.substr(1).split("y");
          var bParts = b.substr(1).split("y");
          if (aParts[0] === bParts[0]) return +aParts[1] - +bParts[1];
          return +aParts[0] - +bParts[0];
        });
        return out;
      };
      axes.findSubplotsWithAxis = function(subplots, ax) {
        var axMatch = new RegExp(
          ax._id.charAt(0) === "x" ? "^" + ax._id + "y" : ax._id + "$"
        );
        var subplotsWithAx = [];
        for (var i = 0; i < subplots.length; i++) {
          var sp = subplots[i];
          if (axMatch.test(sp)) subplotsWithAx.push(sp);
        }
        return subplotsWithAx;
      };
      axes.makeClipPaths = function(gd) {
        var fullLayout = gd._fullLayout;
        if (fullLayout._hasOnlyLargeSploms) return;
        var fullWidth = { _offset: 0, _length: fullLayout.width, _id: "" };
        var fullHeight = { _offset: 0, _length: fullLayout.height, _id: "" };
        var xaList = axes.list(gd, "x", true);
        var yaList = axes.list(gd, "y", true);
        var clipList = [];
        var i, j;
        for (i = 0; i < xaList.length; i++) {
          clipList.push({ x: xaList[i], y: fullHeight });
          for (j = 0; j < yaList.length; j++) {
            if (i === 0) clipList.push({ x: fullWidth, y: yaList[j] });
            clipList.push({ x: xaList[i], y: yaList[j] });
          }
        }
        var axClips = fullLayout._clips.selectAll(".axesclip").data(clipList, function(d) {
          return d.x._id + d.y._id;
        });
        axClips.enter().append("clipPath").classed("axesclip", true).attr("id", function(d) {
          return "clip" + fullLayout._uid + d.x._id + d.y._id;
        }).append("rect");
        axClips.exit().remove();
        axClips.each(function(d) {
          d3.select(this).select("rect").attr({
            x: d.x._offset || 0,
            y: d.y._offset || 0,
            width: d.x._length || 1,
            height: d.y._length || 1
          });
        });
      };
      axes.draw = function(gd, arg, opts) {
        var fullLayout = gd._fullLayout;
        if (arg === "redraw") {
          fullLayout._paper.selectAll("g.subplot").each(function(d) {
            var id = d[0];
            var plotinfo = fullLayout._plots[id];
            if (plotinfo) {
              var xa = plotinfo.xaxis;
              var ya = plotinfo.yaxis;
              plotinfo.xaxislayer.selectAll("." + xa._id + "tick").remove();
              plotinfo.yaxislayer.selectAll("." + ya._id + "tick").remove();
              plotinfo.xaxislayer.selectAll("." + xa._id + "tick2").remove();
              plotinfo.yaxislayer.selectAll("." + ya._id + "tick2").remove();
              plotinfo.xaxislayer.selectAll("." + xa._id + "divider").remove();
              plotinfo.yaxislayer.selectAll("." + ya._id + "divider").remove();
              if (plotinfo.minorGridlayer) plotinfo.minorGridlayer.selectAll("path").remove();
              if (plotinfo.gridlayer) plotinfo.gridlayer.selectAll("path").remove();
              if (plotinfo.zerolinelayer) plotinfo.zerolinelayer.selectAll("path").remove();
              fullLayout._infolayer.select(".g-" + xa._id + "title").remove();
              fullLayout._infolayer.select(".g-" + ya._id + "title").remove();
            }
          });
        }
        var axList = !arg || arg === "redraw" ? axes.listIds(gd) : arg;
        var fullAxList = axes.list(gd);
        var overlayingShiftedAx = fullAxList.filter(function(ax) {
          return ax.autoshift;
        }).map(function(ax) {
          return ax.overlaying;
        });
        axList.map(function(axId) {
          var ax = axes.getFromId(gd, axId);
          if (ax.tickmode === "sync" && ax.overlaying) {
            var overlayingIndex = axList.findIndex(function(axis) {
              return axis === ax.overlaying;
            });
            if (overlayingIndex >= 0) {
              axList.unshift(axList.splice(overlayingIndex, 1).shift());
            }
          }
        });
        var axShifts = { false: { left: 0, right: 0 } };
        return Lib.syncOrAsync(axList.map(function(axId) {
          return function() {
            if (!axId) return;
            var ax = axes.getFromId(gd, axId);
            if (!opts) opts = {};
            opts.axShifts = axShifts;
            opts.overlayingShiftedAx = overlayingShiftedAx;
            var axDone = axes.drawOne(gd, ax, opts);
            if (ax._shiftPusher) {
              incrementShift(ax, ax._fullDepth || 0, axShifts, true);
            }
            ax._r = ax.range.slice();
            ax._rl = Lib.simpleMap(ax._r, ax.r2l);
            return axDone;
          };
        }));
      };
      axes.drawOne = function(gd, ax, opts) {
        opts = opts || {};
        var axShifts = opts.axShifts || {};
        var overlayingShiftedAx = opts.overlayingShiftedAx || [];
        var i, sp, plotinfo;
        ax.setScale();
        var fullLayout = gd._fullLayout;
        var axId = ax._id;
        var axLetter = axId.charAt(0);
        var counterLetter = axes.counterLetter(axId);
        var mainPlotinfo = fullLayout._plots[ax._mainSubplot];
        if (!mainPlotinfo) return;
        ax._shiftPusher = ax.autoshift || overlayingShiftedAx.indexOf(ax._id) !== -1 || overlayingShiftedAx.indexOf(ax.overlaying) !== -1;
        if (ax._shiftPusher & ax.anchor === "free") {
          var selfPush = ax.linewidth / 2 || 0;
          if (ax.ticks === "inside") {
            selfPush += ax.ticklen;
          }
          incrementShift(ax, selfPush, axShifts, true);
          incrementShift(ax, ax.shift || 0, axShifts, false);
        }
        if (opts.skipTitle !== true || ax._shift === void 0) ax._shift = setShiftVal(ax, axShifts);
        var mainAxLayer = mainPlotinfo[axLetter + "axislayer"];
        var mainLinePosition = ax._mainLinePosition;
        var mainLinePositionShift = mainLinePosition += ax._shift;
        var mainMirrorPosition = ax._mainMirrorPosition;
        var vals = ax._vals = axes.calcTicks(ax);
        var axInfo = [ax.mirror, mainLinePositionShift, mainMirrorPosition].join("_");
        for (i = 0; i < vals.length; i++) {
          vals[i].axInfo = axInfo;
        }
        ax._selections = {};
        if (ax._tickAngles) ax._prevTickAngles = ax._tickAngles;
        ax._tickAngles = {};
        ax._depth = null;
        var llbboxes = {};
        function getLabelLevelBbox(suffix) {
          var cls = axId + (suffix || "tick");
          if (!llbboxes[cls]) llbboxes[cls] = calcLabelLevelBbox(ax, cls, mainLinePositionShift);
          return llbboxes[cls];
        }
        if (!ax.visible) return;
        var transTickFn = axes.makeTransTickFn(ax);
        var transTickLabelFn = axes.makeTransTickLabelFn(ax);
        var tickVals;
        var valsClipped;
        var insideTicks = ax.ticks === "inside";
        var outsideTicks = ax.ticks === "outside";
        if (ax.tickson === "boundaries") {
          var boundaryVals = getBoundaryVals(ax, vals);
          valsClipped = axes.clipEnds(ax, boundaryVals);
          tickVals = insideTicks ? valsClipped : boundaryVals;
        } else {
          valsClipped = axes.clipEnds(ax, vals);
          tickVals = insideTicks && ax.ticklabelmode !== "period" ? valsClipped : vals;
        }
        var gridVals = ax._gridVals = valsClipped;
        var dividerVals = getDividerVals(ax, vals);
        if (!fullLayout._hasOnlyLargeSploms) {
          var subplotsWithAx = ax._subplotsWith;
          var finishedGrids = {};
          for (i = 0; i < subplotsWithAx.length; i++) {
            sp = subplotsWithAx[i];
            plotinfo = fullLayout._plots[sp];
            var counterAxis = plotinfo[counterLetter + "axis"];
            var mainCounterID = counterAxis._mainAxis._id;
            if (finishedGrids[mainCounterID]) continue;
            finishedGrids[mainCounterID] = 1;
            var gridPath = axLetter === "x" ? "M0," + counterAxis._offset + "v" + counterAxis._length : "M" + counterAxis._offset + ",0h" + counterAxis._length;
            axes.drawGrid(gd, ax, {
              vals: gridVals,
              counterAxis,
              layer: plotinfo.gridlayer.select("." + axId),
              minorLayer: plotinfo.minorGridlayer.select("." + axId),
              path: gridPath,
              transFn: transTickFn
            });
            axes.drawZeroLine(gd, ax, {
              counterAxis,
              layer: plotinfo.zerolinelayer,
              path: gridPath,
              transFn: transTickFn
            });
          }
        }
        var tickPath;
        var majorTickSigns = axes.getTickSigns(ax);
        var minorTickSigns = axes.getTickSigns(ax, "minor");
        if (ax.ticks || ax.minor && ax.minor.ticks) {
          var majorTickPath = axes.makeTickPath(ax, mainLinePositionShift, majorTickSigns[2]);
          var minorTickPath = axes.makeTickPath(ax, mainLinePositionShift, minorTickSigns[2], { minor: true });
          var mirrorMajorTickPath;
          var mirrorMinorTickPath;
          var fullMajorTickPath;
          var fullMinorTickPath;
          if (ax._anchorAxis && ax.mirror && ax.mirror !== true) {
            mirrorMajorTickPath = axes.makeTickPath(ax, mainMirrorPosition, majorTickSigns[3]);
            mirrorMinorTickPath = axes.makeTickPath(ax, mainMirrorPosition, minorTickSigns[3], { minor: true });
            fullMajorTickPath = majorTickPath + mirrorMajorTickPath;
            fullMinorTickPath = minorTickPath + mirrorMinorTickPath;
          } else {
            mirrorMajorTickPath = "";
            mirrorMinorTickPath = "";
            fullMajorTickPath = majorTickPath;
            fullMinorTickPath = minorTickPath;
          }
          if (ax.showdividers && outsideTicks && ax.tickson === "boundaries") {
            var dividerLookup = {};
            for (i = 0; i < dividerVals.length; i++) {
              dividerLookup[dividerVals[i].x] = 1;
            }
            tickPath = function(d) {
              return dividerLookup[d.x] ? mirrorMajorTickPath : fullMajorTickPath;
            };
          } else {
            tickPath = function(d) {
              return d.minor ? fullMinorTickPath : fullMajorTickPath;
            };
          }
        }
        axes.drawTicks(gd, ax, {
          vals: tickVals,
          layer: mainAxLayer,
          path: tickPath,
          transFn: transTickFn
        });
        if (ax.mirror === "allticks") {
          var tickSubplots = Object.keys(ax._linepositions || {});
          for (i = 0; i < tickSubplots.length; i++) {
            sp = tickSubplots[i];
            plotinfo = fullLayout._plots[sp];
            var linepositions = ax._linepositions[sp] || [];
            var p0 = linepositions[0];
            var p1 = linepositions[1];
            var isMinor = linepositions[2];
            var spTickPath = axes.makeTickPath(
              ax,
              p0,
              isMinor ? majorTickSigns[0] : minorTickSigns[0],
              { minor: isMinor }
            ) + axes.makeTickPath(
              ax,
              p1,
              isMinor ? majorTickSigns[1] : minorTickSigns[1],
              { minor: isMinor }
            );
            axes.drawTicks(gd, ax, {
              vals: tickVals,
              layer: plotinfo[axLetter + "axislayer"],
              path: spTickPath,
              transFn: transTickFn
            });
          }
        }
        var seq = [];
        seq.push(function() {
          return axes.drawLabels(gd, ax, {
            vals,
            layer: mainAxLayer,
            plotinfo,
            transFn: transTickLabelFn,
            labelFns: axes.makeLabelFns(ax, mainLinePositionShift)
          });
        });
        if (ax.type === "multicategory") {
          var pad = { x: 2, y: 10 }[axLetter];
          seq.push(function() {
            var bboxKey = { x: "height", y: "width" }[axLetter];
            var standoff = getLabelLevelBbox()[bboxKey] + pad + (ax._tickAngles[axId + "tick"] ? ax.tickfont.size * LINE_SPACING : 0);
            return axes.drawLabels(gd, ax, {
              vals: getSecondaryLabelVals(ax, vals),
              layer: mainAxLayer,
              cls: axId + "tick2",
              repositionOnUpdate: true,
              secondary: true,
              transFn: transTickFn,
              labelFns: axes.makeLabelFns(ax, mainLinePositionShift + standoff * majorTickSigns[4])
            });
          });
          seq.push(function() {
            ax._depth = majorTickSigns[4] * (getLabelLevelBbox("tick2")[ax.side] - mainLinePositionShift);
            return drawDividers(gd, ax, {
              vals: dividerVals,
              layer: mainAxLayer,
              path: axes.makeTickPath(ax, mainLinePositionShift, majorTickSigns[4], { len: ax._depth }),
              transFn: transTickFn
            });
          });
        } else if (ax.title.hasOwnProperty("standoff")) {
          seq.push(function() {
            ax._depth = majorTickSigns[4] * (getLabelLevelBbox()[ax.side] - mainLinePositionShift);
          });
        }
        var hasRangeSlider = Registry.getComponentMethod("rangeslider", "isVisible")(ax);
        if (!opts.skipTitle && !(hasRangeSlider && ax.side === "bottom")) {
          seq.push(function() {
            return drawTitle(gd, ax);
          });
        }
        seq.push(function() {
          var s = ax.side.charAt(0);
          var sMirror = OPPOSITE_SIDE[ax.side].charAt(0);
          var pos = axes.getPxPosition(gd, ax);
          var outsideTickLen = outsideTicks ? ax.ticklen : 0;
          var llbbox;
          var push;
          var mirrorPush;
          var rangeSliderPush;
          if (ax.automargin || hasRangeSlider || ax._shiftPusher) {
            if (ax.type === "multicategory") {
              llbbox = getLabelLevelBbox("tick2");
            } else {
              llbbox = getLabelLevelBbox();
              if (axLetter === "x" && s === "b") {
                ax._depth = Math.max(llbbox.width > 0 ? llbbox.bottom - pos : 0, outsideTickLen);
              }
            }
          }
          var axDepth = 0;
          var titleDepth = 0;
          if (ax._shiftPusher) {
            axDepth = Math.max(
              outsideTickLen,
              llbbox.height > 0 ? s === "l" ? pos - llbbox.left : llbbox.right - pos : 0
            );
            if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {
              titleDepth = (ax._titleStandoff || 0) + (ax._titleScoot || 0);
              if (s === "l") {
                titleDepth += approxTitleDepth(ax);
              }
            }
            ax._fullDepth = Math.max(axDepth, titleDepth);
          }
          if (ax.automargin) {
            push = { x: 0, y: 0, r: 0, l: 0, t: 0, b: 0 };
            var domainIndices = [0, 1];
            var shift = typeof ax._shift === "number" ? ax._shift : 0;
            if (axLetter === "x") {
              if (s === "b") {
                push[s] = ax._depth;
              } else {
                push[s] = ax._depth = Math.max(llbbox.width > 0 ? pos - llbbox.top : 0, outsideTickLen);
                domainIndices.reverse();
              }
              if (llbbox.width > 0) {
                var rExtra = llbbox.right - (ax._offset + ax._length);
                if (rExtra > 0) {
                  push.xr = 1;
                  push.r = rExtra;
                }
                var lExtra = ax._offset - llbbox.left;
                if (lExtra > 0) {
                  push.xl = 0;
                  push.l = lExtra;
                }
              }
            } else {
              if (s === "l") {
                ax._depth = Math.max(llbbox.height > 0 ? pos - llbbox.left : 0, outsideTickLen);
                push[s] = ax._depth - shift;
              } else {
                ax._depth = Math.max(llbbox.height > 0 ? llbbox.right - pos : 0, outsideTickLen);
                push[s] = ax._depth + shift;
                domainIndices.reverse();
              }
              if (llbbox.height > 0) {
                var bExtra = llbbox.bottom - (ax._offset + ax._length);
                if (bExtra > 0) {
                  push.yb = 0;
                  push.b = bExtra;
                }
                var tExtra = ax._offset - llbbox.top;
                if (tExtra > 0) {
                  push.yt = 1;
                  push.t = tExtra;
                }
              }
            }
            push[counterLetter] = ax.anchor === "free" ? ax.position : ax._anchorAxis.domain[domainIndices[0]];
            if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {
              push[s] += approxTitleDepth(ax) + (ax.title.standoff || 0);
            }
            if (ax.mirror && ax.anchor !== "free") {
              mirrorPush = { x: 0, y: 0, r: 0, l: 0, t: 0, b: 0 };
              mirrorPush[sMirror] = ax.linewidth;
              if (ax.mirror && ax.mirror !== true) mirrorPush[sMirror] += outsideTickLen;
              if (ax.mirror === true || ax.mirror === "ticks") {
                mirrorPush[counterLetter] = ax._anchorAxis.domain[domainIndices[1]];
              } else if (ax.mirror === "all" || ax.mirror === "allticks") {
                mirrorPush[counterLetter] = [ax._counterDomainMin, ax._counterDomainMax][domainIndices[1]];
              }
            }
          }
          if (hasRangeSlider) {
            rangeSliderPush = Registry.getComponentMethod("rangeslider", "autoMarginOpts")(gd, ax);
          }
          if (typeof ax.automargin === "string") {
            filterPush(push, ax.automargin);
            filterPush(mirrorPush, ax.automargin);
          }
          Plots.autoMargin(gd, axAutoMarginID(ax), push);
          Plots.autoMargin(gd, axMirrorAutoMarginID(ax), mirrorPush);
          Plots.autoMargin(gd, rangeSliderAutoMarginID(ax), rangeSliderPush);
        });
        return Lib.syncOrAsync(seq);
      };
      function filterPush(push, automargin) {
        if (!push) return;
        var keepMargin = Object.keys(MARGIN_MAPPING).reduce(function(data, nextKey) {
          if (automargin.indexOf(nextKey) !== -1) {
            MARGIN_MAPPING[nextKey].forEach(function(key) {
              data[key] = 1;
            });
          }
          return data;
        }, {});
        Object.keys(push).forEach(function(key) {
          if (!keepMargin[key]) {
            if (key.length === 1) push[key] = 0;
            else delete push[key];
          }
        });
      }
      function getBoundaryVals(ax, vals) {
        var out = [];
        var i;
        var _push = function(d, bndIndex) {
          var xb = d.xbnd[bndIndex];
          if (xb !== null) {
            out.push(Lib.extendFlat({}, d, { x: xb }));
          }
        };
        if (vals.length) {
          for (i = 0; i < vals.length; i++) {
            _push(vals[i], 0);
          }
          _push(vals[i - 1], 1);
        }
        return out;
      }
      function getSecondaryLabelVals(ax, vals) {
        var out = [];
        var lookup = {};
        for (var i = 0; i < vals.length; i++) {
          var d = vals[i];
          if (lookup[d.text2]) {
            lookup[d.text2].push(d.x);
          } else {
            lookup[d.text2] = [d.x];
          }
        }
        for (var k in lookup) {
          out.push(tickTextObj(ax, Lib.interp(lookup[k], 0.5), k));
        }
        return out;
      }
      function getDividerVals(ax, vals) {
        var out = [];
        var i, current;
        var reversed = vals.length && vals[vals.length - 1].x < vals[0].x;
        var _push = function(d2, bndIndex) {
          var xb = d2.xbnd[bndIndex];
          if (xb !== null) {
            out.push(Lib.extendFlat({}, d2, { x: xb }));
          }
        };
        if (ax.showdividers && vals.length) {
          for (i = 0; i < vals.length; i++) {
            var d = vals[i];
            if (d.text2 !== current) {
              _push(d, reversed ? 1 : 0);
            }
            current = d.text2;
          }
          _push(vals[i - 1], reversed ? 0 : 1);
        }
        return out;
      }
      function calcLabelLevelBbox(ax, cls, mainLinePositionShift) {
        var top, bottom;
        var left, right;
        if (ax._selections[cls].size()) {
          top = Infinity;
          bottom = -Infinity;
          left = Infinity;
          right = -Infinity;
          ax._selections[cls].each(function() {
            var thisLabel = selectTickLabel(this);
            var bb = Drawing.bBox(thisLabel.node().parentNode);
            top = Math.min(top, bb.top);
            bottom = Math.max(bottom, bb.bottom);
            left = Math.min(left, bb.left);
            right = Math.max(right, bb.right);
          });
        } else {
          var dummyCalc = axes.makeLabelFns(ax, mainLinePositionShift);
          top = bottom = dummyCalc.yFn({ dx: 0, dy: 0, fontSize: 0 });
          left = right = dummyCalc.xFn({ dx: 0, dy: 0, fontSize: 0 });
        }
        return {
          top,
          bottom,
          left,
          right,
          height: bottom - top,
          width: right - left
        };
      }
      axes.getTickSigns = function(ax, minor) {
        var axLetter = ax._id.charAt(0);
        var sideOpposite = { x: "top", y: "right" }[axLetter];
        var main = ax.side === sideOpposite ? 1 : -1;
        var out = [-1, 1, main, -main];
        var ticks = minor ? (ax.minor || {}).ticks : ax.ticks;
        if (ticks !== "inside" === (axLetter === "x")) {
          out = out.map(function(v) {
            return -v;
          });
        }
        if (ax.side) {
          out.push({ l: -1, t: -1, r: 1, b: 1 }[ax.side.charAt(0)]);
        }
        return out;
      };
      axes.makeTransTickFn = function(ax) {
        return ax._id.charAt(0) === "x" ? function(d) {
          return strTranslate(ax._offset + ax.l2p(d.x), 0);
        } : function(d) {
          return strTranslate(0, ax._offset + ax.l2p(d.x));
        };
      };
      axes.makeTransTickLabelFn = function(ax) {
        var uv = getTickLabelUV(ax);
        var shift = ax.ticklabelshift || 0;
        var standoff = ax.ticklabelstandoff || 0;
        var u = uv[0];
        var v = uv[1];
        var isReversed = ax.range[0] > ax.range[1];
        var labelsInside = ax.ticklabelposition && ax.ticklabelposition.indexOf("inside") !== -1;
        var labelsOutside = !labelsInside;
        if (shift) {
          var shiftSign = isReversed ? -1 : 1;
          shift = shift * shiftSign;
        }
        if (standoff) {
          var side = ax.side;
          var standoffSign = labelsInside && (side === "top" || side === "left") || labelsOutside && (side === "bottom" || side === "right") ? 1 : -1;
          standoff = standoff * standoffSign;
        }
        return ax._id.charAt(0) === "x" ? function(d) {
          return strTranslate(
            u + ax._offset + ax.l2p(getPosX(d)) + shift,
            v + standoff
          );
        } : function(d) {
          return strTranslate(
            v + standoff,
            u + ax._offset + ax.l2p(getPosX(d)) + shift
          );
        };
      };
      function getPosX(d) {
        return d.periodX !== void 0 ? d.periodX : d.x;
      }
      function getTickLabelUV(ax) {
        var ticklabelposition = ax.ticklabelposition || "";
        var has = function(str) {
          return ticklabelposition.indexOf(str) !== -1;
        };
        var isTop = has("top");
        var isLeft = has("left");
        var isRight = has("right");
        var isBottom = has("bottom");
        var isInside = has("inside");
        var isAligned = isBottom || isLeft || isTop || isRight;
        if (!isAligned && !isInside) return [0, 0];
        var side = ax.side;
        var u = isAligned ? (ax.tickwidth || 0) / 2 : 0;
        var v = TEXTPAD;
        var fontSize = ax.tickfont ? ax.tickfont.size : 12;
        if (isBottom || isTop) {
          u += fontSize * CAP_SHIFT;
          v += (ax.linewidth || 0) / 2;
        }
        if (isLeft || isRight) {
          u += (ax.linewidth || 0) / 2;
          v += TEXTPAD;
        }
        if (isInside && side === "top") {
          v -= fontSize * (1 - CAP_SHIFT);
        }
        if (isLeft || isTop) u = -u;
        if (side === "bottom" || side === "right") v = -v;
        return [
          isAligned ? u : 0,
          isInside ? v : 0
        ];
      }
      axes.makeTickPath = function(ax, shift, sgn, opts) {
        if (!opts) opts = {};
        var minor = opts.minor;
        if (minor && !ax.minor) return "";
        var len = opts.len !== void 0 ? opts.len : minor ? ax.minor.ticklen : ax.ticklen;
        var axLetter = ax._id.charAt(0);
        var pad = (ax.linewidth || 1) / 2;
        return axLetter === "x" ? "M0," + (shift + pad * sgn) + "v" + len * sgn : "M" + (shift + pad * sgn) + ",0h" + len * sgn;
      };
      axes.makeLabelFns = function(ax, shift, angle) {
        var ticklabelposition = ax.ticklabelposition || "";
        var has = function(str) {
          return ticklabelposition.indexOf(str) !== -1;
        };
        var isTop = has("top");
        var isLeft = has("left");
        var isRight = has("right");
        var isBottom = has("bottom");
        var isAligned = isBottom || isLeft || isTop || isRight;
        var insideTickLabels = has("inside");
        var labelsOverTicks = ticklabelposition === "inside" && ax.ticks === "inside" || !insideTickLabels && ax.ticks === "outside" && ax.tickson !== "boundaries";
        var labelStandoff = 0;
        var labelShift = 0;
        var tickLen = labelsOverTicks ? ax.ticklen : 0;
        if (insideTickLabels) {
          tickLen *= -1;
        } else if (isAligned) {
          tickLen = 0;
        }
        if (labelsOverTicks) {
          labelStandoff += tickLen;
          if (angle) {
            var rad = Lib.deg2rad(angle);
            labelStandoff = tickLen * Math.cos(rad) + 1;
            labelShift = tickLen * Math.sin(rad);
          }
        }
        if (ax.showticklabels && (labelsOverTicks || ax.showline)) {
          labelStandoff += 0.2 * ax.tickfont.size;
        }
        labelStandoff += (ax.linewidth || 1) / 2 * (insideTickLabels ? -1 : 1);
        var out = {
          labelStandoff,
          labelShift
        };
        var x0, y0, ff, flipIt;
        var xQ = 0;
        var side = ax.side;
        var axLetter = ax._id.charAt(0);
        var tickangle = ax.tickangle;
        var endSide;
        if (axLetter === "x") {
          endSide = !insideTickLabels && side === "bottom" || insideTickLabels && side === "top";
          flipIt = endSide ? 1 : -1;
          if (insideTickLabels) flipIt *= -1;
          x0 = labelShift * flipIt;
          y0 = shift + labelStandoff * flipIt;
          ff = endSide ? 1 : -0.2;
          if (Math.abs(tickangle) === 90) {
            if (insideTickLabels) {
              ff += MID_SHIFT;
            } else {
              if (tickangle === -90 && side === "bottom") {
                ff = CAP_SHIFT;
              } else if (tickangle === 90 && side === "top") {
                ff = MID_SHIFT;
              } else {
                ff = 0.5;
              }
            }
            xQ = MID_SHIFT / 2 * (tickangle / 90);
          }
          out.xFn = function(d) {
            return d.dx + x0 + xQ * d.fontSize;
          };
          out.yFn = function(d) {
            return d.dy + y0 + d.fontSize * ff;
          };
          out.anchorFn = function(d, a) {
            if (isAligned) {
              if (isLeft) return "end";
              if (isRight) return "start";
            }
            if (!isNumeric(a) || a === 0 || a === 180) {
              return "middle";
            }
            return a * flipIt < 0 !== insideTickLabels ? "end" : "start";
          };
          out.heightFn = function(d, a, h) {
            return a < -60 || a > 60 ? -0.5 * h : ax.side === "top" !== insideTickLabels ? -h : 0;
          };
        } else if (axLetter === "y") {
          endSide = !insideTickLabels && side === "left" || insideTickLabels && side === "right";
          flipIt = endSide ? 1 : -1;
          if (insideTickLabels) flipIt *= -1;
          x0 = labelStandoff;
          y0 = labelShift * flipIt;
          ff = 0;
          if (!insideTickLabels && Math.abs(tickangle) === 90) {
            if (tickangle === -90 && side === "left" || tickangle === 90 && side === "right") {
              ff = CAP_SHIFT;
            } else {
              ff = 0.5;
            }
          }
          if (insideTickLabels) {
            var ang = isNumeric(tickangle) ? +tickangle : 0;
            if (ang !== 0) {
              var rA = Lib.deg2rad(ang);
              xQ = Math.abs(Math.sin(rA)) * CAP_SHIFT * flipIt;
              ff = 0;
            }
          }
          out.xFn = function(d) {
            return d.dx + shift - (x0 + d.fontSize * ff) * flipIt + xQ * d.fontSize;
          };
          out.yFn = function(d) {
            return d.dy + y0 + d.fontSize * MID_SHIFT;
          };
          out.anchorFn = function(d, a) {
            if (isNumeric(a) && Math.abs(a) === 90) {
              return "middle";
            }
            return endSide ? "end" : "start";
          };
          out.heightFn = function(d, a, h) {
            if (ax.side === "right") a *= -1;
            return a < -30 ? -h : a < 30 ? -0.5 * h : 0;
          };
        }
        return out;
      };
      function tickDataFn(d) {
        return [d.text, d.x, d.axInfo, d.font, d.fontSize, d.fontColor].join("_");
      }
      axes.drawTicks = function(gd, ax, opts) {
        opts = opts || {};
        var cls = ax._id + "tick";
        var vals = [].concat(
          ax.minor && ax.minor.ticks ? (
            // minor vals
            opts.vals.filter(function(d) {
              return d.minor && !d.noTick;
            })
          ) : []
        ).concat(
          ax.ticks ? (
            // major vals
            opts.vals.filter(function(d) {
              return !d.minor && !d.noTick;
            })
          ) : []
        );
        var ticks = opts.layer.selectAll("path." + cls).data(vals, tickDataFn);
        ticks.exit().remove();
        ticks.enter().append("path").classed(cls, 1).classed("ticks", 1).classed("crisp", opts.crisp !== false).each(function(d) {
          return Color.stroke(d3.select(this), d.minor ? ax.minor.tickcolor : ax.tickcolor);
        }).style("stroke-width", function(d) {
          return Drawing.crispRound(
            gd,
            d.minor ? ax.minor.tickwidth : ax.tickwidth,
            1
          ) + "px";
        }).attr("d", opts.path).style("display", null);
        hideCounterAxisInsideTickLabels(ax, [TICK_PATH]);
        ticks.attr("transform", opts.transFn);
      };
      axes.drawGrid = function(gd, ax, opts) {
        opts = opts || {};
        if (ax.tickmode === "sync") {
          return;
        }
        var cls = ax._id + "grid";
        var hasMinor = ax.minor && ax.minor.showgrid;
        var minorVals = hasMinor ? opts.vals.filter(function(d) {
          return d.minor;
        }) : [];
        var majorVals = ax.showgrid ? opts.vals.filter(function(d) {
          return !d.minor;
        }) : [];
        var counterAx = opts.counterAxis;
        if (counterAx && axes.shouldShowZeroLine(gd, ax, counterAx)) {
          var isArrayMode = ax.tickmode === "array";
          for (var i = 0; i < majorVals.length; i++) {
            var xi = majorVals[i].x;
            if (isArrayMode ? !xi : Math.abs(xi) < ax.dtick / 100) {
              majorVals = majorVals.slice(0, i).concat(majorVals.slice(i + 1));
              if (isArrayMode) i--;
              else break;
            }
          }
        }
        ax._gw = Drawing.crispRound(gd, ax.gridwidth, 1);
        var wMinor = !hasMinor ? 0 : Drawing.crispRound(gd, ax.minor.gridwidth, 1);
        var majorLayer = opts.layer;
        var minorLayer = opts.minorLayer;
        for (var major = 1; major >= 0; major--) {
          var layer = major ? majorLayer : minorLayer;
          if (!layer) continue;
          var grid = layer.selectAll("path." + cls).data(major ? majorVals : minorVals, tickDataFn);
          grid.exit().remove();
          grid.enter().append("path").classed(cls, 1).classed("crisp", opts.crisp !== false);
          grid.attr("transform", opts.transFn).attr("d", opts.path).each(function(d) {
            return Color.stroke(
              d3.select(this),
              d.minor ? ax.minor.gridcolor : ax.gridcolor || "#ddd"
            );
          }).style("stroke-dasharray", function(d) {
            return Drawing.dashStyle(
              d.minor ? ax.minor.griddash : ax.griddash,
              d.minor ? ax.minor.gridwidth : ax.gridwidth
            );
          }).style("stroke-width", function(d) {
            return (d.minor ? wMinor : ax._gw) + "px";
          }).style("display", null);
          if (typeof opts.path === "function") grid.attr("d", opts.path);
        }
        hideCounterAxisInsideTickLabels(ax, [GRID_PATH, MINORGRID_PATH]);
      };
      axes.drawZeroLine = function(gd, ax, opts) {
        opts = opts || opts;
        var cls = ax._id + "zl";
        var show = axes.shouldShowZeroLine(gd, ax, opts.counterAxis);
        var zl = opts.layer.selectAll("path." + cls).data(show ? [{ x: 0, id: ax._id }] : []);
        zl.exit().remove();
        zl.enter().append("path").classed(cls, 1).classed("zl", 1).classed("crisp", opts.crisp !== false).each(function() {
          opts.layer.selectAll("path").sort(function(da, db) {
            return idSort(da.id, db.id);
          });
        });
        zl.attr("transform", opts.transFn).attr("d", opts.path).call(Color.stroke, ax.zerolinecolor || Color.defaultLine).style("stroke-width", Drawing.crispRound(gd, ax.zerolinewidth, ax._gw || 1) + "px").style("display", null);
        hideCounterAxisInsideTickLabels(ax, [ZERO_PATH]);
      };
      axes.drawLabels = function(gd, ax, opts) {
        opts = opts || {};
        var fullLayout = gd._fullLayout;
        var axId = ax._id;
        var cls = opts.cls || axId + "tick";
        var vals = opts.vals.filter(function(d) {
          return d.text;
        });
        var labelFns = opts.labelFns;
        var tickAngle = opts.secondary ? 0 : ax.tickangle;
        var prevAngle = (ax._prevTickAngles || {})[cls];
        var tickLabels = opts.layer.selectAll("g." + cls).data(ax.showticklabels ? vals : [], tickDataFn);
        var labelsReady = [];
        tickLabels.enter().append("g").classed(cls, 1).append("text").attr("text-anchor", "middle").each(function(d) {
          var thisLabel = d3.select(this);
          var newPromise = gd._promises.length;
          thisLabel.call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d)).call(Drawing.font, {
            family: d.font,
            size: d.fontSize,
            color: d.fontColor,
            weight: d.fontWeight,
            style: d.fontStyle,
            variant: d.fontVariant,
            textcase: d.fontTextcase,
            lineposition: d.fontLineposition,
            shadow: d.fontShadow
          }).text(d.text).call(svgTextUtils.convertToTspans, gd);
          if (gd._promises[newPromise]) {
            labelsReady.push(gd._promises.pop().then(function() {
              positionLabels(thisLabel, tickAngle);
            }));
          } else {
            positionLabels(thisLabel, tickAngle);
          }
        });
        hideCounterAxisInsideTickLabels(ax, [TICK_TEXT]);
        tickLabels.exit().remove();
        if (opts.repositionOnUpdate) {
          tickLabels.each(function(d) {
            d3.select(this).select("text").call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d));
          });
        }
        function positionLabels(s, angle) {
          s.each(function(d) {
            var thisLabel = d3.select(this);
            var mathjaxGroup = thisLabel.select(".text-math-group");
            var anchor = labelFns.anchorFn(d, angle);
            var transform = opts.transFn.call(thisLabel.node(), d) + (isNumeric(angle) && +angle !== 0 ? " rotate(" + angle + "," + labelFns.xFn(d) + "," + (labelFns.yFn(d) - d.fontSize / 2) + ")" : "");
            var nLines = svgTextUtils.lineCount(thisLabel);
            var lineHeight = LINE_SPACING * d.fontSize;
            var anchorHeight = labelFns.heightFn(d, isNumeric(angle) ? +angle : 0, (nLines - 1) * lineHeight);
            if (anchorHeight) {
              transform += strTranslate(0, anchorHeight);
            }
            if (mathjaxGroup.empty()) {
              var thisText = thisLabel.select("text");
              thisText.attr({
                transform,
                "text-anchor": anchor
              });
              thisText.style("opacity", 1);
              if (ax._adjustTickLabelsOverflow) {
                ax._adjustTickLabelsOverflow();
              }
            } else {
              var mjWidth = Drawing.bBox(mathjaxGroup.node()).width;
              var mjShift = mjWidth * { end: -0.5, start: 0.5 }[anchor];
              mathjaxGroup.attr("transform", transform + strTranslate(mjShift, 0));
            }
          });
        }
        ax._adjustTickLabelsOverflow = function() {
          var ticklabeloverflow = ax.ticklabeloverflow;
          if (!ticklabeloverflow || ticklabeloverflow === "allow") return;
          var hideOverflow = ticklabeloverflow.indexOf("hide") !== -1;
          var isX = ax._id.charAt(0) === "x";
          var p02 = 0;
          var p12 = isX ? gd._fullLayout.width : gd._fullLayout.height;
          if (ticklabeloverflow.indexOf("domain") !== -1) {
            var rl = Lib.simpleMap(ax.range, ax.r2l);
            p02 = ax.l2p(rl[0]) + ax._offset;
            p12 = ax.l2p(rl[1]) + ax._offset;
          }
          var min = Math.min(p02, p12);
          var max = Math.max(p02, p12);
          var side = ax.side;
          var visibleLabelMin = Infinity;
          var visibleLabelMax = -Infinity;
          tickLabels.each(function(d) {
            var thisLabel = d3.select(this);
            var mathjaxGroup = thisLabel.select(".text-math-group");
            if (mathjaxGroup.empty()) {
              var bb = Drawing.bBox(thisLabel.node());
              var adjust = 0;
              if (isX) {
                if (bb.right > max) adjust = 1;
                else if (bb.left < min) adjust = 1;
              } else {
                if (bb.bottom > max) adjust = 1;
                else if (bb.top + (ax.tickangle ? 0 : d.fontSize / 4) < min) adjust = 1;
              }
              var t = thisLabel.select("text");
              if (adjust) {
                if (hideOverflow) t.style("opacity", 0);
              } else {
                t.style("opacity", 1);
                if (side === "bottom" || side === "right") {
                  visibleLabelMin = Math.min(visibleLabelMin, isX ? bb.top : bb.left);
                } else {
                  visibleLabelMin = -Infinity;
                }
                if (side === "top" || side === "left") {
                  visibleLabelMax = Math.max(visibleLabelMax, isX ? bb.bottom : bb.right);
                } else {
                  visibleLabelMax = Infinity;
                }
              }
            }
          });
          for (var subplot in fullLayout._plots) {
            var plotinfo = fullLayout._plots[subplot];
            if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;
            var anchorAx2 = isX ? plotinfo.yaxis : plotinfo.xaxis;
            if (anchorAx2) {
              anchorAx2["_visibleLabelMin_" + ax._id] = visibleLabelMin;
              anchorAx2["_visibleLabelMax_" + ax._id] = visibleLabelMax;
            }
          }
        };
        ax._hideCounterAxisInsideTickLabels = function(partialOpts) {
          var isX = ax._id.charAt(0) === "x";
          var anchoredAxes = [];
          for (var subplot in fullLayout._plots) {
            var plotinfo = fullLayout._plots[subplot];
            if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;
            anchoredAxes.push(isX ? plotinfo.yaxis : plotinfo.xaxis);
          }
          anchoredAxes.forEach(function(anchorAx2, idx) {
            if (anchorAx2 && insideTicklabelposition(anchorAx2)) {
              (partialOpts || [
                ZERO_PATH,
                MINORGRID_PATH,
                GRID_PATH,
                TICK_PATH,
                TICK_TEXT
              ]).forEach(function(e) {
                var isPeriodLabel = e.K === "tick" && e.L === "text" && ax.ticklabelmode === "period";
                var mainPlotinfo = fullLayout._plots[ax._mainSubplot];
                var sel;
                if (e.K === ZERO_PATH.K) sel = mainPlotinfo.zerolinelayer.selectAll("." + ax._id + "zl");
                else if (e.K === MINORGRID_PATH.K) sel = mainPlotinfo.minorGridlayer.selectAll("." + ax._id);
                else if (e.K === GRID_PATH.K) sel = mainPlotinfo.gridlayer.selectAll("." + ax._id);
                else sel = mainPlotinfo[ax._id.charAt(0) + "axislayer"];
                sel.each(function() {
                  var w = d3.select(this);
                  if (e.L) w = w.selectAll(e.L);
                  w.each(function(d) {
                    var q = ax.l2p(
                      isPeriodLabel ? getPosX(d) : d.x
                    ) + ax._offset;
                    var t = d3.select(this);
                    if (q < ax["_visibleLabelMax_" + anchorAx2._id] && q > ax["_visibleLabelMin_" + anchorAx2._id]) {
                      t.style("display", "none");
                    } else if (e.K === "tick" && !idx) {
                      t.style("display", null);
                    }
                  });
                });
              });
            }
          });
        };
        positionLabels(tickLabels, prevAngle + 1 ? prevAngle : tickAngle);
        function allLabelsReady() {
          return labelsReady.length && Promise.all(labelsReady);
        }
        var autoangle = null;
        function fixLabelOverlaps() {
          positionLabels(tickLabels, tickAngle);
          if (vals.length && ax.autotickangles && (ax.type !== "log" || String(ax.dtick).charAt(0) !== "D")) {
            autoangle = ax.autotickangles[0];
            var maxFontSize = 0;
            var lbbArray = [];
            var i;
            var maxLines = 1;
            tickLabels.each(function(d) {
              maxFontSize = Math.max(maxFontSize, d.fontSize);
              var x = ax.l2p(d.x);
              var thisLabel = selectTickLabel(this);
              var bb = Drawing.bBox(thisLabel.node());
              maxLines = Math.max(maxLines, svgTextUtils.lineCount(thisLabel));
              lbbArray.push({
                // ignore about y, just deal with x overlaps
                top: 0,
                bottom: 10,
                height: 10,
                left: x - bb.width / 2,
                // impose a 2px gap
                right: x + bb.width / 2 + 2,
                width: bb.width + 2
              });
            });
            var preventOverlapWithTick = (ax.tickson === "boundaries" || ax.showdividers) && !opts.secondary;
            var vLen = vals.length;
            var tickSpacing = Math.abs((vals[vLen - 1].x - vals[0].x) * ax._m) / (vLen - 1);
            var adjacent = preventOverlapWithTick ? tickSpacing / 2 : tickSpacing;
            var opposite = preventOverlapWithTick ? ax.ticklen : maxFontSize * 1.25 * maxLines;
            var hypotenuse = Math.sqrt(Math.pow(adjacent, 2) + Math.pow(opposite, 2));
            var maxCos = adjacent / hypotenuse;
            var autoTickAnglesRadians = ax.autotickangles.map(
              function(degrees) {
                return degrees * Math.PI / 180;
              }
            );
            var angleRadians = autoTickAnglesRadians.find(
              function(angle) {
                return Math.abs(Math.cos(angle)) <= maxCos;
              }
            );
            if (angleRadians === void 0) {
              angleRadians = autoTickAnglesRadians.reduce(
                function(currentMax, nextAngle) {
                  return Math.abs(Math.cos(currentMax)) < Math.abs(Math.cos(nextAngle)) ? currentMax : nextAngle;
                },
                autoTickAnglesRadians[0]
              );
            }
            var newAngle = angleRadians * (180 / Math.PI);
            if (preventOverlapWithTick) {
              var gap = 2;
              if (ax.ticks) gap += ax.tickwidth / 2;
              for (i = 0; i < lbbArray.length; i++) {
                var xbnd = vals[i].xbnd;
                var lbb = lbbArray[i];
                if (xbnd[0] !== null && lbb.left - ax.l2p(xbnd[0]) < gap || xbnd[1] !== null && ax.l2p(xbnd[1]) - lbb.right < gap) {
                  autoangle = newAngle;
                  break;
                }
              }
            } else {
              var ticklabelposition = ax.ticklabelposition || "";
              var has = function(str) {
                return ticklabelposition.indexOf(str) !== -1;
              };
              var isTop = has("top");
              var isLeft = has("left");
              var isRight = has("right");
              var isBottom = has("bottom");
              var isAligned = isBottom || isLeft || isTop || isRight;
              var pad = !isAligned ? 0 : (ax.tickwidth || 0) + 2 * TEXTPAD;
              for (i = 0; i < lbbArray.length - 1; i++) {
                if (Lib.bBoxIntersect(lbbArray[i], lbbArray[i + 1], pad)) {
                  autoangle = newAngle;
                  break;
                }
              }
            }
            if (autoangle) {
              positionLabels(tickLabels, autoangle);
            }
          }
        }
        if (ax._selections) {
          ax._selections[cls] = tickLabels;
        }
        var seq = [allLabelsReady];
        if (ax.automargin && fullLayout._redrawFromAutoMarginCount && prevAngle === 90) {
          autoangle = prevAngle;
          seq.push(function() {
            positionLabels(tickLabels, prevAngle);
          });
        } else {
          seq.push(fixLabelOverlaps);
        }
        if (ax._tickAngles) {
          seq.push(function() {
            ax._tickAngles[cls] = autoangle === null ? isNumeric(tickAngle) ? tickAngle : 0 : autoangle;
          });
        }
        var computeTickLabelBoundingBoxes = function() {
          var labelsMaxW = 0;
          var labelsMaxH = 0;
          tickLabels.each(function(d, i) {
            var thisLabel = selectTickLabel(this);
            var mathjaxGroup = thisLabel.select(".text-math-group");
            if (mathjaxGroup.empty()) {
              var bb;
              if (ax._vals[i]) {
                bb = ax._vals[i].bb || Drawing.bBox(thisLabel.node());
                ax._vals[i].bb = bb;
              }
              labelsMaxW = Math.max(labelsMaxW, bb.width);
              labelsMaxH = Math.max(labelsMaxH, bb.height);
            }
          });
          return {
            labelsMaxW,
            labelsMaxH
          };
        };
        var anchorAx = ax._anchorAxis;
        if (anchorAx && (anchorAx.autorange || anchorAx.insiderange) && insideTicklabelposition(ax) && !isLinked(fullLayout, ax._id)) {
          if (!fullLayout._insideTickLabelsUpdaterange) {
            fullLayout._insideTickLabelsUpdaterange = {};
          }
          if (anchorAx.autorange) {
            fullLayout._insideTickLabelsUpdaterange[anchorAx._name + ".autorange"] = anchorAx.autorange;
            seq.push(computeTickLabelBoundingBoxes);
          }
          if (anchorAx.insiderange) {
            var BBs = computeTickLabelBoundingBoxes();
            var move = ax._id.charAt(0) === "y" ? BBs.labelsMaxW : BBs.labelsMaxH;
            move += 2 * TEXTPAD;
            if (ax.ticklabelposition === "inside") {
              move += ax.ticklen || 0;
            }
            var sgn = ax.side === "right" || ax.side === "top" ? 1 : -1;
            var index = sgn === 1 ? 1 : 0;
            var otherIndex = sgn === 1 ? 0 : 1;
            var newRange = [];
            newRange[otherIndex] = anchorAx.range[otherIndex];
            var anchorAxRange = anchorAx.range;
            var p0 = anchorAx.r2p(anchorAxRange[index]);
            var p1 = anchorAx.r2p(anchorAxRange[otherIndex]);
            var _tempNewRange = fullLayout._insideTickLabelsUpdaterange[anchorAx._name + ".range"];
            if (_tempNewRange) {
              var q0 = anchorAx.r2p(_tempNewRange[index]);
              var q1 = anchorAx.r2p(_tempNewRange[otherIndex]);
              var dir = sgn * (ax._id.charAt(0) === "y" ? 1 : -1);
              if (dir * p0 < dir * q0) {
                p0 = q0;
                newRange[index] = anchorAxRange[index] = _tempNewRange[index];
              }
              if (dir * p1 > dir * q1) {
                p1 = q1;
                newRange[otherIndex] = anchorAxRange[otherIndex] = _tempNewRange[otherIndex];
              }
            }
            var dist = Math.abs(p1 - p0);
            if (dist - move > 0) {
              dist -= move;
              move *= 1 + move / dist;
            } else {
              move = 0;
            }
            if (ax._id.charAt(0) !== "y") move = -move;
            newRange[index] = anchorAx.p2r(
              anchorAx.r2p(anchorAxRange[index]) + sgn * move
            );
            if (anchorAx.autorange === "min" || anchorAx.autorange === "max reversed") {
              newRange[0] = null;
              anchorAx._rangeInitial0 = void 0;
              anchorAx._rangeInitial1 = void 0;
            } else if (anchorAx.autorange === "max" || anchorAx.autorange === "min reversed") {
              newRange[1] = null;
              anchorAx._rangeInitial0 = void 0;
              anchorAx._rangeInitial1 = void 0;
            }
            fullLayout._insideTickLabelsUpdaterange[anchorAx._name + ".range"] = newRange;
          }
        }
        var done = Lib.syncOrAsync(seq);
        if (done && done.then) gd._promises.push(done);
        return done;
      };
      function drawDividers(gd, ax, opts) {
        var cls = ax._id + "divider";
        var vals = opts.vals;
        var dividers = opts.layer.selectAll("path." + cls).data(vals, tickDataFn);
        dividers.exit().remove();
        dividers.enter().insert("path", ":first-child").classed(cls, 1).classed("crisp", 1).call(Color.stroke, ax.dividercolor).style("stroke-width", Drawing.crispRound(gd, ax.dividerwidth, 1) + "px");
        dividers.attr("transform", opts.transFn).attr("d", opts.path);
      }
      axes.getPxPosition = function(gd, ax) {
        var gs = gd._fullLayout._size;
        var axLetter = ax._id.charAt(0);
        var side = ax.side;
        var anchorAxis;
        if (ax.anchor !== "free") {
          anchorAxis = ax._anchorAxis;
        } else if (axLetter === "x") {
          anchorAxis = {
            _offset: gs.t + (1 - (ax.position || 0)) * gs.h,
            _length: 0
          };
        } else if (axLetter === "y") {
          anchorAxis = {
            _offset: gs.l + (ax.position || 0) * gs.w + ax._shift,
            _length: 0
          };
        }
        if (side === "top" || side === "left") {
          return anchorAxis._offset;
        } else if (side === "bottom" || side === "right") {
          return anchorAxis._offset + anchorAxis._length;
        }
      };
      function approxTitleDepth(ax) {
        var fontSize = ax.title.font.size;
        var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;
        if (ax.title.hasOwnProperty("standoff")) {
          return fontSize * (CAP_SHIFT + extraLines * LINE_SPACING);
        } else {
          return extraLines ? fontSize * (extraLines + 1) * LINE_SPACING : fontSize;
        }
      }
      function drawTitle(gd, ax) {
        var fullLayout = gd._fullLayout;
        var axId = ax._id;
        var axLetter = axId.charAt(0);
        var fontSize = ax.title.font.size;
        var titleStandoff;
        var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;
        if (ax.title.hasOwnProperty("standoff")) {
          if (ax.side === "bottom" || ax.side === "right") {
            titleStandoff = ax._depth + ax.title.standoff + fontSize * CAP_SHIFT;
          } else if (ax.side === "top" || ax.side === "left") {
            titleStandoff = ax._depth + ax.title.standoff + fontSize * (MID_SHIFT + extraLines * LINE_SPACING);
          }
        } else {
          var isInside = insideTicklabelposition(ax);
          if (ax.type === "multicategory") {
            titleStandoff = ax._depth;
          } else {
            var offsetBase = 1.5 * fontSize;
            if (isInside) {
              offsetBase = 0.5 * fontSize;
              if (ax.ticks === "outside") {
                offsetBase += ax.ticklen;
              }
            }
            titleStandoff = 10 + offsetBase + (ax.linewidth ? ax.linewidth - 1 : 0);
          }
          if (!isInside) {
            if (axLetter === "x") {
              titleStandoff += ax.side === "top" ? fontSize * (ax.showticklabels ? 1 : 0) : fontSize * (ax.showticklabels ? 1.5 : 0.5);
            } else {
              titleStandoff += ax.side === "right" ? fontSize * (ax.showticklabels ? 1 : 0.5) : fontSize * (ax.showticklabels ? 0.5 : 0);
            }
          }
        }
        var pos = axes.getPxPosition(gd, ax);
        var transform, x, y;
        if (axLetter === "x") {
          x = ax._offset + ax._length / 2;
          y = ax.side === "top" ? pos - titleStandoff : pos + titleStandoff;
        } else {
          y = ax._offset + ax._length / 2;
          x = ax.side === "right" ? pos + titleStandoff : pos - titleStandoff;
          transform = { rotate: "-90", offset: 0 };
        }
        var avoid;
        if (ax.type !== "multicategory") {
          var tickLabels = ax._selections[ax._id + "tick"];
          avoid = {
            selection: tickLabels,
            side: ax.side
          };
          if (tickLabels && tickLabels.node() && tickLabels.node().parentNode) {
            var translation = Drawing.getTranslate(tickLabels.node().parentNode);
            avoid.offsetLeft = translation.x;
            avoid.offsetTop = translation.y;
          }
          if (ax.title.hasOwnProperty("standoff")) {
            avoid.pad = 0;
          }
        }
        ax._titleStandoff = titleStandoff;
        return Titles.draw(gd, axId + "title", {
          propContainer: ax,
          propName: ax._name + ".title.text",
          placeholder: fullLayout._dfltTitle[axLetter],
          avoid,
          transform,
          attributes: { x, y, "text-anchor": "middle" }
        });
      }
      axes.shouldShowZeroLine = function(gd, ax, counterAxis) {
        var rng = Lib.simpleMap(ax.range, ax.r2l);
        return rng[0] * rng[1] <= 0 && ax.zeroline && (ax.type === "linear" || ax.type === "-") && !(ax.rangebreaks && ax.maskBreaks(0) === BADNUM) && (clipEnds(ax, 0) || !anyCounterAxLineAtZero(gd, ax, counterAxis, rng) || hasBarsOrFill(gd, ax));
      };
      axes.clipEnds = function(ax, vals) {
        return vals.filter(function(d) {
          return clipEnds(ax, d.x);
        });
      };
      function clipEnds(ax, l) {
        var p = ax.l2p(l);
        return p > 1 && p < ax._length - 1;
      }
      function anyCounterAxLineAtZero(gd, ax, counterAxis, rng) {
        var mainCounterAxis = counterAxis._mainAxis;
        if (!mainCounterAxis) return;
        var fullLayout = gd._fullLayout;
        var axLetter = ax._id.charAt(0);
        var counterLetter = axes.counterLetter(ax._id);
        var zeroPosition = ax._offset + (Math.abs(rng[0]) < Math.abs(rng[1]) === (axLetter === "x") ? 0 : ax._length);
        function lineNearZero(ax2) {
          if (!ax2.showline || !ax2.linewidth) return false;
          var tolerance = Math.max((ax2.linewidth + ax.zerolinewidth) / 2, 1);
          function closeEnough(pos2) {
            return typeof pos2 === "number" && Math.abs(pos2 - zeroPosition) < tolerance;
          }
          if (closeEnough(ax2._mainLinePosition) || closeEnough(ax2._mainMirrorPosition)) {
            return true;
          }
          var linePositions = ax2._linepositions || {};
          for (var k in linePositions) {
            if (closeEnough(linePositions[k][0]) || closeEnough(linePositions[k][1])) {
              return true;
            }
          }
        }
        var plotinfo = fullLayout._plots[counterAxis._mainSubplot];
        if (!(plotinfo.mainplotinfo || plotinfo).overlays.length) {
          return lineNearZero(counterAxis, zeroPosition);
        }
        var counterLetterAxes = axes.list(gd, counterLetter);
        for (var i = 0; i < counterLetterAxes.length; i++) {
          var counterAxis2 = counterLetterAxes[i];
          if (counterAxis2._mainAxis === mainCounterAxis && lineNearZero(counterAxis2, zeroPosition)) {
            return true;
          }
        }
      }
      function hasBarsOrFill(gd, ax) {
        var fullData = gd._fullData;
        var subplot = ax._mainSubplot;
        var axLetter = ax._id.charAt(0);
        for (var i = 0; i < fullData.length; i++) {
          var trace = fullData[i];
          if (trace.visible === true && trace.xaxis + trace.yaxis === subplot) {
            if (Registry.traceIs(trace, "bar-like") && trace.orientation === { x: "h", y: "v" }[axLetter]) return true;
            if (trace.fill && trace.fill.charAt(trace.fill.length - 1) === axLetter) return true;
          }
        }
        return false;
      }
      function selectTickLabel(gTick) {
        var s = d3.select(gTick);
        var mj = s.select(".text-math-group");
        return mj.empty() ? s.select("text") : mj;
      }
      axes.allowAutoMargin = function(gd) {
        var axList = axes.list(gd, "", true);
        for (var i = 0; i < axList.length; i++) {
          var ax = axList[i];
          if (ax.automargin) {
            Plots.allowAutoMargin(gd, axAutoMarginID(ax));
            if (ax.mirror) {
              Plots.allowAutoMargin(gd, axMirrorAutoMarginID(ax));
            }
          }
          if (Registry.getComponentMethod("rangeslider", "isVisible")(ax)) {
            Plots.allowAutoMargin(gd, rangeSliderAutoMarginID(ax));
          }
        }
      };
      function axAutoMarginID(ax) {
        return ax._id + ".automargin";
      }
      function axMirrorAutoMarginID(ax) {
        return axAutoMarginID(ax) + ".mirror";
      }
      function rangeSliderAutoMarginID(ax) {
        return ax._id + ".rangeslider";
      }
      axes.swap = function(gd, traces) {
        var axGroups = makeAxisGroups(gd, traces);
        for (var i = 0; i < axGroups.length; i++) {
          swapAxisGroup(gd, axGroups[i].x, axGroups[i].y);
        }
      };
      function makeAxisGroups(gd, traces) {
        var groups = [];
        var i, j;
        for (i = 0; i < traces.length; i++) {
          var groupsi = [];
          var xi = gd._fullData[traces[i]].xaxis;
          var yi = gd._fullData[traces[i]].yaxis;
          if (!xi || !yi) continue;
          for (j = 0; j < groups.length; j++) {
            if (groups[j].x.indexOf(xi) !== -1 || groups[j].y.indexOf(yi) !== -1) {
              groupsi.push(j);
            }
          }
          if (!groupsi.length) {
            groups.push({ x: [xi], y: [yi] });
            continue;
          }
          var group0 = groups[groupsi[0]];
          var groupj;
          if (groupsi.length > 1) {
            for (j = 1; j < groupsi.length; j++) {
              groupj = groups[groupsi[j]];
              mergeAxisGroups(group0.x, groupj.x);
              mergeAxisGroups(group0.y, groupj.y);
            }
          }
          mergeAxisGroups(group0.x, [xi]);
          mergeAxisGroups(group0.y, [yi]);
        }
        return groups;
      }
      function mergeAxisGroups(intoSet, fromSet) {
        for (var i = 0; i < fromSet.length; i++) {
          if (intoSet.indexOf(fromSet[i]) === -1) intoSet.push(fromSet[i]);
        }
      }
      function swapAxisGroup(gd, xIds, yIds) {
        var xFullAxes = [];
        var yFullAxes = [];
        var layout = gd.layout;
        var i, j;
        for (i = 0; i < xIds.length; i++) xFullAxes.push(axes.getFromId(gd, xIds[i]));
        for (i = 0; i < yIds.length; i++) yFullAxes.push(axes.getFromId(gd, yIds[i]));
        var allAxKeys = Object.keys(axAttrs);
        var noSwapAttrs = [
          "anchor",
          "domain",
          "overlaying",
          "position",
          "side",
          "tickangle",
          "editType"
        ];
        var numericTypes = ["linear", "log"];
        for (i = 0; i < allAxKeys.length; i++) {
          var keyi = allAxKeys[i];
          var xVal = xFullAxes[0][keyi];
          var yVal = yFullAxes[0][keyi];
          var allEqual = true;
          var coerceLinearX = false;
          var coerceLinearY = false;
          if (keyi.charAt(0) === "_" || typeof xVal === "function" || noSwapAttrs.indexOf(keyi) !== -1) {
            continue;
          }
          for (j = 1; j < xFullAxes.length && allEqual; j++) {
            var xVali = xFullAxes[j][keyi];
            if (keyi === "type" && numericTypes.indexOf(xVal) !== -1 && numericTypes.indexOf(xVali) !== -1 && xVal !== xVali) {
              coerceLinearX = true;
            } else if (xVali !== xVal) allEqual = false;
          }
          for (j = 1; j < yFullAxes.length && allEqual; j++) {
            var yVali = yFullAxes[j][keyi];
            if (keyi === "type" && numericTypes.indexOf(yVal) !== -1 && numericTypes.indexOf(yVali) !== -1 && yVal !== yVali) {
              coerceLinearY = true;
            } else if (yFullAxes[j][keyi] !== yVal) allEqual = false;
          }
          if (allEqual) {
            if (coerceLinearX) layout[xFullAxes[0]._name].type = "linear";
            if (coerceLinearY) layout[yFullAxes[0]._name].type = "linear";
            swapAxisAttrs(layout, keyi, xFullAxes, yFullAxes, gd._fullLayout._dfltTitle);
          }
        }
        for (i = 0; i < gd._fullLayout.annotations.length; i++) {
          var ann = gd._fullLayout.annotations[i];
          if (xIds.indexOf(ann.xref) !== -1 && yIds.indexOf(ann.yref) !== -1) {
            Lib.swapAttrs(layout.annotations[i], ["?"]);
          }
        }
      }
      function swapAxisAttrs(layout, key, xFullAxes, yFullAxes, dfltTitle) {
        var np = Lib.nestedProperty;
        var xVal = np(layout[xFullAxes[0]._name], key).get();
        var yVal = np(layout[yFullAxes[0]._name], key).get();
        var i;
        if (key === "title") {
          if (xVal && xVal.text === dfltTitle.x) {
            xVal.text = dfltTitle.y;
          }
          if (yVal && yVal.text === dfltTitle.y) {
            yVal.text = dfltTitle.x;
          }
        }
        for (i = 0; i < xFullAxes.length; i++) {
          np(layout, xFullAxes[i]._name + "." + key).set(yVal);
        }
        for (i = 0; i < yFullAxes.length; i++) {
          np(layout, yFullAxes[i]._name + "." + key).set(xVal);
        }
      }
      function isAngular(ax) {
        return ax._id === "angularaxis";
      }
      function moveOutsideBreak(v, ax) {
        var len = ax._rangebreaks.length;
        for (var k = 0; k < len; k++) {
          var brk = ax._rangebreaks[k];
          if (v >= brk.min && v < brk.max) {
            return brk.max;
          }
        }
        return v;
      }
      function insideTicklabelposition(ax) {
        return (ax.ticklabelposition || "").indexOf("inside") !== -1;
      }
      function hideCounterAxisInsideTickLabels(ax, opts) {
        if (insideTicklabelposition(ax._anchorAxis || {})) {
          if (ax._hideCounterAxisInsideTickLabels) {
            ax._hideCounterAxisInsideTickLabels(opts);
          }
        }
      }
      function incrementShift(ax, shiftVal, axShifts, normalize) {
        var overlay = ax.anchor !== "free" && (ax.overlaying === void 0 || ax.overlaying === false) ? ax._id : ax.overlaying;
        var shiftValAdj;
        if (normalize) {
          shiftValAdj = ax.side === "right" ? shiftVal : -shiftVal;
        } else {
          shiftValAdj = shiftVal;
        }
        if (!(overlay in axShifts)) {
          axShifts[overlay] = {};
        }
        if (!(ax.side in axShifts[overlay])) {
          axShifts[overlay][ax.side] = 0;
        }
        axShifts[overlay][ax.side] += shiftValAdj;
      }
      function setShiftVal(ax, axShifts) {
        return ax.autoshift ? axShifts[ax.overlaying][ax.side] : ax.shift || 0;
      }
      function periodCompatibleWithTickformat(period, tickformat) {
        return /%f/.test(tickformat) ? period >= ONEMICROSEC : /%L/.test(tickformat) ? period >= ONEMILLI : /%[SX]/.test(tickformat) ? period >= ONESEC : /%M/.test(tickformat) ? period >= ONEMIN : /%[HI]/.test(tickformat) ? period >= ONEHOUR : /%p/.test(tickformat) ? period >= HALFDAY : /%[Aadejuwx]/.test(tickformat) ? period >= ONEDAY : /%[UVW]/.test(tickformat) ? period >= ONEWEEK : /%[Bbm]/.test(tickformat) ? period >= ONEMINMONTH : /%[q]/.test(tickformat) ? period >= ONEMINQUARTER : /%[Yy]/.test(tickformat) ? period >= ONEMINYEAR : true;
      }
    }
  });

  // src/plots/cartesian/autorange_options_defaults.js
  var require_autorange_options_defaults = __commonJS({
    "src/plots/cartesian/autorange_options_defaults.js"(exports, module) {
      "use strict";
      module.exports = function handleAutorangeOptionsDefaults(coerce, autorange, range) {
        var minRange, maxRange;
        if (range) {
          var isReversed = autorange === "reversed" || autorange === "min reversed" || autorange === "max reversed";
          minRange = range[isReversed ? 1 : 0];
          maxRange = range[isReversed ? 0 : 1];
        }
        var minallowed = coerce("autorangeoptions.minallowed", maxRange === null ? minRange : void 0);
        var maxallowed = coerce("autorangeoptions.maxallowed", minRange === null ? maxRange : void 0);
        if (minallowed === void 0) coerce("autorangeoptions.clipmin");
        if (maxallowed === void 0) coerce("autorangeoptions.clipmax");
        coerce("autorangeoptions.include");
      };
    }
  });

  // src/plots/cartesian/range_defaults.js
  var require_range_defaults = __commonJS({
    "src/plots/cartesian/range_defaults.js"(exports, module) {
      "use strict";
      var handleAutorangeOptionsDefaults = require_autorange_options_defaults();
      module.exports = function handleRangeDefaults(containerIn, containerOut, coerce, options) {
        var axTemplate = containerOut._template || {};
        var axType = containerOut.type || axTemplate.type || "-";
        coerce("minallowed");
        coerce("maxallowed");
        var range = coerce("range");
        if (!range) {
          var insiderange;
          if (!options.noInsiderange && axType !== "log") {
            insiderange = coerce("insiderange");
            if (insiderange && (insiderange[0] === null || insiderange[1] === null)) {
              containerOut.insiderange = false;
              insiderange = void 0;
            }
            if (insiderange) range = coerce("range", insiderange);
          }
        }
        var autorangeDflt = containerOut.getAutorangeDflt(range, options);
        var autorange = coerce("autorange", autorangeDflt);
        var shouldAutorange;
        if (range && (range[0] === null && range[1] === null || (range[0] === null || range[1] === null) && (autorange === "reversed" || autorange === true) || range[0] !== null && (autorange === "min" || autorange === "max reversed") || range[1] !== null && (autorange === "max" || autorange === "min reversed"))) {
          range = void 0;
          delete containerOut.range;
          containerOut.autorange = true;
          shouldAutorange = true;
        }
        if (!shouldAutorange) {
          autorangeDflt = containerOut.getAutorangeDflt(range, options);
          autorange = coerce("autorange", autorangeDflt);
        }
        if (autorange) {
          handleAutorangeOptionsDefaults(coerce, autorange, range);
          if (axType === "linear" || axType === "-") coerce("rangemode");
        }
        containerOut.cleanRange();
      };
    }
  });

  // node_modules/mouse-event-offset/index.js
  var require_mouse_event_offset = __commonJS({
    "node_modules/mouse-event-offset/index.js"(exports, module) {
      var rootPosition = { left: 0, top: 0 };
      module.exports = mouseEventOffset;
      function mouseEventOffset(ev, target, out) {
        target = target || ev.currentTarget || ev.srcElement;
        if (!Array.isArray(out)) {
          out = [0, 0];
        }
        var cx = ev.clientX || 0;
        var cy = ev.clientY || 0;
        var rect = getBoundingClientOffset(target);
        out[0] = cx - rect.left;
        out[1] = cy - rect.top;
        return out;
      }
      function getBoundingClientOffset(element) {
        if (element === window || element === document || element === document.body) {
          return rootPosition;
        } else {
          return element.getBoundingClientRect();
        }
      }
    }
  });

  // node_modules/has-passive-events/index.js
  var require_has_passive_events = __commonJS({
    "node_modules/has-passive-events/index.js"(exports, module) {
      "use strict";
      var isBrowser = require_client();
      function detect() {
        var supported = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supported = true;
            }
          });
          window.addEventListener("test", null, opts);
          window.removeEventListener("test", null, opts);
        } catch (e) {
          supported = false;
        }
        return supported;
      }
      module.exports = isBrowser && detect();
    }
  });

  // src/components/dragelement/align.js
  var require_align = __commonJS({
    "src/components/dragelement/align.js"(exports, module) {
      "use strict";
      module.exports = function align(v, dv, v0, v1, anchor) {
        var vmin = (v - v0) / (v1 - v0);
        var vmax = vmin + dv / (v1 - v0);
        var vc = (vmin + vmax) / 2;
        if (anchor === "left" || anchor === "bottom") return vmin;
        if (anchor === "center" || anchor === "middle") return vc;
        if (anchor === "right" || anchor === "top") return vmax;
        if (vmin < 2 / 3 - vc) return vmin;
        if (vmax > 4 / 3 - vc) return vmax;
        return vc;
      };
    }
  });

  // src/components/dragelement/cursor.js
  var require_cursor = __commonJS({
    "src/components/dragelement/cursor.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var cursorset = [
        ["sw-resize", "s-resize", "se-resize"],
        ["w-resize", "move", "e-resize"],
        ["nw-resize", "n-resize", "ne-resize"]
      ];
      module.exports = function getCursor(x, y, xanchor, yanchor) {
        if (xanchor === "left") x = 0;
        else if (xanchor === "center") x = 1;
        else if (xanchor === "right") x = 2;
        else x = Lib.constrain(Math.floor(x * 3), 0, 2);
        if (yanchor === "bottom") y = 0;
        else if (yanchor === "middle") y = 1;
        else if (yanchor === "top") y = 2;
        else y = Lib.constrain(Math.floor(y * 3), 0, 2);
        return cursorset[y][x];
      };
    }
  });

  // src/components/dragelement/unhover.js
  var require_unhover = __commonJS({
    "src/components/dragelement/unhover.js"(exports, module) {
      "use strict";
      var Events = require_events2();
      var throttle = require_throttle();
      var getGraphDiv = require_dom().getGraphDiv;
      var hoverConstants = require_constants();
      var unhover = module.exports = {};
      unhover.wrapped = function(gd, evt, subplot) {
        gd = getGraphDiv(gd);
        if (gd._fullLayout) {
          throttle.clear(gd._fullLayout._uid + hoverConstants.HOVERID);
        }
        unhover.raw(gd, evt, subplot);
      };
      unhover.raw = function raw(gd, evt) {
        var fullLayout = gd._fullLayout;
        var oldhoverdata = gd._hoverdata;
        if (!evt) evt = {};
        if (evt.target && !gd._dragged && Events.triggerHandler(gd, "plotly_beforehover", evt) === false) {
          return;
        }
        fullLayout._hoverlayer.selectAll("g").remove();
        fullLayout._hoverlayer.selectAll("line").remove();
        fullLayout._hoverlayer.selectAll("circle").remove();
        gd._hoverdata = void 0;
        if (evt.target && oldhoverdata) {
          gd.emit("plotly_unhover", {
            event: evt,
            points: oldhoverdata
          });
        }
      };
    }
  });

  // src/components/dragelement/index.js
  var require_dragelement = __commonJS({
    "src/components/dragelement/index.js"(exports, module) {
      "use strict";
      var mouseOffset = require_mouse_event_offset();
      var hasHover = require_has_hover();
      var supportsPassive = require_has_passive_events();
      var removeElement = require_lib().removeElement;
      var constants = require_constants2();
      var dragElement = module.exports = {};
      dragElement.align = require_align();
      dragElement.getCursor = require_cursor();
      var unhover = require_unhover();
      dragElement.unhover = unhover.wrapped;
      dragElement.unhoverRaw = unhover.raw;
      dragElement.init = function init(options) {
        var gd = options.gd;
        var numClicks = 1;
        var doubleClickDelay = gd._context.doubleClickDelay;
        var element = options.element;
        var startX, startY, newMouseDownTime, cursor, dragCover, initialEvent, initialTarget, rightClick;
        if (!gd._mouseDownTime) gd._mouseDownTime = 0;
        element.style.pointerEvents = "all";
        element.onmousedown = onStart;
        if (!supportsPassive) {
          element.ontouchstart = onStart;
        } else {
          if (element._ontouchstart) {
            element.removeEventListener("touchstart", element._ontouchstart);
          }
          element._ontouchstart = onStart;
          element.addEventListener("touchstart", onStart, { passive: false });
        }
        function _clampFn(dx, dy, minDrag) {
          if (Math.abs(dx) < minDrag) dx = 0;
          if (Math.abs(dy) < minDrag) dy = 0;
          return [dx, dy];
        }
        var clampFn = options.clampFn || _clampFn;
        function onStart(e) {
          gd._dragged = false;
          gd._dragging = true;
          var offset = pointerOffset(e);
          startX = offset[0];
          startY = offset[1];
          initialTarget = e.target;
          initialEvent = e;
          rightClick = e.buttons === 2 || e.ctrlKey;
          if (typeof e.clientX === "undefined" && typeof e.clientY === "undefined") {
            e.clientX = startX;
            e.clientY = startY;
          }
          newMouseDownTime = (/* @__PURE__ */ new Date()).getTime();
          if (newMouseDownTime - gd._mouseDownTime < doubleClickDelay) {
            numClicks += 1;
          } else {
            numClicks = 1;
            gd._mouseDownTime = newMouseDownTime;
          }
          if (options.prepFn) options.prepFn(e, startX, startY);
          if (hasHover && !rightClick) {
            dragCover = coverSlip();
            dragCover.style.cursor = window.getComputedStyle(element).cursor;
          } else if (!hasHover) {
            dragCover = document;
            cursor = window.getComputedStyle(document.documentElement).cursor;
            document.documentElement.style.cursor = window.getComputedStyle(element).cursor;
          }
          document.addEventListener("mouseup", onDone);
          document.addEventListener("touchend", onDone);
          if (options.dragmode !== false) {
            e.preventDefault();
            document.addEventListener("mousemove", onMove);
            document.addEventListener("touchmove", onMove, { passive: false });
          }
          return;
        }
        function onMove(e) {
          e.preventDefault();
          var offset = pointerOffset(e);
          var minDrag = options.minDrag || constants.MINDRAG;
          var dxdy = clampFn(offset[0] - startX, offset[1] - startY, minDrag);
          var dx = dxdy[0];
          var dy = dxdy[1];
          if (dx || dy) {
            gd._dragged = true;
            dragElement.unhover(gd, e);
          }
          if (gd._dragged && options.moveFn && !rightClick) {
            gd._dragdata = {
              element,
              dx,
              dy
            };
            options.moveFn(dx, dy);
          }
          return;
        }
        function onDone(e) {
          delete gd._dragdata;
          if (options.dragmode !== false) {
            e.preventDefault();
            document.removeEventListener("mousemove", onMove);
            document.removeEventListener("touchmove", onMove);
          }
          document.removeEventListener("mouseup", onDone);
          document.removeEventListener("touchend", onDone);
          if (hasHover) {
            removeElement(dragCover);
          } else if (cursor) {
            dragCover.documentElement.style.cursor = cursor;
            cursor = null;
          }
          if (!gd._dragging) {
            gd._dragged = false;
            return;
          }
          gd._dragging = false;
          if ((/* @__PURE__ */ new Date()).getTime() - gd._mouseDownTime > doubleClickDelay) {
            numClicks = Math.max(numClicks - 1, 1);
          }
          if (gd._dragged) {
            if (options.doneFn) options.doneFn();
          } else {
            var clickEvent;
            if (initialEvent.target === initialTarget) {
              clickEvent = initialEvent;
            } else {
              clickEvent = {
                target: initialTarget,
                srcElement: initialTarget,
                toElement: initialTarget
              };
              Object.keys(initialEvent).concat(Object.keys(initialEvent.__proto__)).forEach((k) => {
                var v = initialEvent[k];
                if (!clickEvent[k] && typeof v !== "function") {
                  clickEvent[k] = v;
                }
              });
            }
            if (options.clickFn) options.clickFn(numClicks, clickEvent);
            if (!rightClick) {
              initialTarget.dispatchEvent(new MouseEvent("click", e));
            }
          }
          gd._dragging = false;
          gd._dragged = false;
          return;
        }
      };
      function coverSlip() {
        var cover = document.createElement("div");
        cover.className = "dragcover";
        var cStyle = cover.style;
        cStyle.position = "fixed";
        cStyle.left = 0;
        cStyle.right = 0;
        cStyle.top = 0;
        cStyle.bottom = 0;
        cStyle.zIndex = 999999999;
        cStyle.background = "none";
        document.body.appendChild(cover);
        return cover;
      }
      dragElement.coverSlip = coverSlip;
      function pointerOffset(e) {
        return mouseOffset(
          e.changedTouches ? e.changedTouches[0] : e,
          document.body
        );
      }
    }
  });

  // src/lib/setcursor.js
  var require_setcursor = __commonJS({
    "src/lib/setcursor.js"(exports, module) {
      "use strict";
      module.exports = function setCursor(el3, csr) {
        (el3.attr("class") || "").split(" ").forEach(function(cls) {
          if (cls.indexOf("cursor-") === 0) el3.classed(cls, false);
        });
        if (csr) el3.classed("cursor-" + csr, true);
      };
    }
  });

  // src/lib/override_cursor.js
  var require_override_cursor = __commonJS({
    "src/lib/override_cursor.js"(exports, module) {
      "use strict";
      var setCursor = require_setcursor();
      var STASHATTR = "data-savedcursor";
      var NO_CURSOR = "!!";
      module.exports = function overrideCursor(el3, csr) {
        var savedCursor = el3.attr(STASHATTR);
        if (csr) {
          if (!savedCursor) {
            var classes = (el3.attr("class") || "").split(" ");
            for (var i = 0; i < classes.length; i++) {
              var cls = classes[i];
              if (cls.indexOf("cursor-") === 0) {
                el3.attr(STASHATTR, cls.substr(7)).classed(cls, false);
              }
            }
            if (!el3.attr(STASHATTR)) {
              el3.attr(STASHATTR, NO_CURSOR);
            }
          }
          setCursor(el3, csr);
        } else if (savedCursor) {
          el3.attr(STASHATTR, null);
          if (savedCursor === NO_CURSOR) setCursor(el3);
          else setCursor(el3, savedCursor);
        }
      };
    }
  });

  // src/components/legend/attributes.js
  var require_attributes9 = __commonJS({
    "src/components/legend/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var colorAttrs = require_attributes3();
      module.exports = {
        // not really a 'subplot' attribute container,
        // but this is the flag we use to denote attributes that
        // support yaxis, yaxis2, yaxis3, ... counters
        _isSubplotObj: true,
        visible: {
          valType: "boolean",
          dflt: true,
          editType: "legend"
        },
        bgcolor: {
          valType: "color",
          editType: "legend"
        },
        bordercolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "legend"
        },
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: 0,
          editType: "legend"
        },
        font: fontAttrs({
          editType: "legend"
        }),
        grouptitlefont: fontAttrs({
          editType: "legend"
        }),
        orientation: {
          valType: "enumerated",
          values: ["v", "h"],
          dflt: "v",
          editType: "legend"
        },
        traceorder: {
          valType: "flaglist",
          flags: ["reversed", "grouped"],
          extras: ["normal"],
          editType: "legend"
        },
        tracegroupgap: {
          valType: "number",
          min: 0,
          dflt: 10,
          editType: "legend"
        },
        entrywidth: {
          valType: "number",
          min: 0,
          editType: "legend"
        },
        entrywidthmode: {
          valType: "enumerated",
          values: ["fraction", "pixels"],
          dflt: "pixels",
          editType: "legend"
        },
        indentation: {
          valType: "number",
          min: -15,
          dflt: 0,
          editType: "legend"
        },
        itemsizing: {
          valType: "enumerated",
          values: ["trace", "constant"],
          dflt: "trace",
          editType: "legend"
        },
        itemwidth: {
          valType: "number",
          min: 30,
          dflt: 30,
          editType: "legend"
        },
        itemclick: {
          valType: "enumerated",
          values: ["toggle", "toggleothers", false],
          dflt: "toggle",
          editType: "legend"
        },
        itemdoubleclick: {
          valType: "enumerated",
          values: ["toggle", "toggleothers", false],
          dflt: "toggleothers",
          editType: "legend"
        },
        groupclick: {
          valType: "enumerated",
          values: ["toggleitem", "togglegroup"],
          dflt: "togglegroup",
          editType: "legend"
        },
        x: {
          valType: "number",
          editType: "legend"
        },
        xref: {
          valType: "enumerated",
          dflt: "paper",
          values: ["container", "paper"],
          editType: "layoutstyle"
        },
        xanchor: {
          valType: "enumerated",
          values: ["auto", "left", "center", "right"],
          dflt: "left",
          editType: "legend"
        },
        y: {
          valType: "number",
          editType: "legend"
        },
        yref: {
          valType: "enumerated",
          dflt: "paper",
          values: ["container", "paper"],
          editType: "layoutstyle"
        },
        yanchor: {
          valType: "enumerated",
          values: ["auto", "top", "middle", "bottom"],
          editType: "legend"
        },
        uirevision: {
          valType: "any",
          editType: "none"
        },
        valign: {
          valType: "enumerated",
          values: ["top", "middle", "bottom"],
          dflt: "middle",
          editType: "legend"
        },
        title: {
          text: {
            valType: "string",
            dflt: "",
            editType: "legend"
          },
          font: fontAttrs({
            editType: "legend"
          }),
          side: {
            valType: "enumerated",
            values: ["top", "left", "top left", "top center", "top right"],
            editType: "legend"
          },
          editType: "legend"
        },
        editType: "legend"
      };
    }
  });

  // src/components/legend/helpers.js
  var require_helpers3 = __commonJS({
    "src/components/legend/helpers.js"(exports) {
      "use strict";
      exports.isGrouped = function isGrouped(legendLayout) {
        return (legendLayout.traceorder || "").indexOf("grouped") !== -1;
      };
      exports.isVertical = function isVertical(legendLayout) {
        return legendLayout.orientation !== "h";
      };
      exports.isReversed = function isReversed(legendLayout) {
        return (legendLayout.traceorder || "").indexOf("reversed") !== -1;
      };
    }
  });

  // src/components/legend/defaults.js
  var require_defaults3 = __commonJS({
    "src/components/legend/defaults.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var Template = require_plot_template();
      var plotsAttrs = require_attributes2();
      var attributes = require_attributes9();
      var basePlotLayoutAttributes = require_layout_attributes2();
      var helpers = require_helpers3();
      function groupDefaults(legendId, layoutIn, layoutOut, fullData) {
        var containerIn = layoutIn[legendId] || {};
        var containerOut = Template.newContainer(layoutOut, legendId);
        function coerce(attr, dflt) {
          return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
        }
        var itemFont = Lib.coerceFont(coerce, "font", layoutOut.font);
        coerce("bgcolor", layoutOut.paper_bgcolor);
        coerce("bordercolor");
        var visible = coerce("visible");
        if (!visible) return;
        var trace;
        var traceCoerce = function(attr, dflt) {
          var traceIn = trace._input;
          var traceOut = trace;
          return Lib.coerce(traceIn, traceOut, plotsAttrs, attr, dflt);
        };
        var globalFont = layoutOut.font || {};
        var grouptitlefont = Lib.coerceFont(coerce, "grouptitlefont", globalFont, { overrideDflt: {
          size: Math.round(globalFont.size * 1.1)
        } });
        var legendTraceCount = 0;
        var legendReallyHasATrace = false;
        var defaultOrder = "normal";
        var shapesWithLegend = (layoutOut.shapes || []).filter(function(d) {
          return d.showlegend;
        });
        var allLegendItems = fullData.concat(shapesWithLegend).filter(function(d) {
          return legendId === (d.legend || "legend");
        });
        for (var i = 0; i < allLegendItems.length; i++) {
          trace = allLegendItems[i];
          if (!trace.visible) continue;
          var isShape = trace._isShape;
          if (trace.showlegend || trace._dfltShowLegend && !(trace._module && trace._module.attributes && trace._module.attributes.showlegend && trace._module.attributes.showlegend.dflt === false)) {
            legendTraceCount++;
            if (trace.showlegend) {
              legendReallyHasATrace = true;
              if (!isShape && Registry.traceIs(trace, "pie-like") || trace._input.showlegend === true) {
                legendTraceCount++;
              }
            }
            Lib.coerceFont(traceCoerce, "legendgrouptitle.font", grouptitlefont);
          }
          if (!isShape && Registry.traceIs(trace, "bar") && layoutOut.barmode === "stack" || ["tonextx", "tonexty"].indexOf(trace.fill) !== -1) {
            defaultOrder = helpers.isGrouped({ traceorder: defaultOrder }) ? "grouped+reversed" : "reversed";
          }
          if (trace.legendgroup !== void 0 && trace.legendgroup !== "") {
            defaultOrder = helpers.isReversed({ traceorder: defaultOrder }) ? "reversed+grouped" : "grouped";
          }
        }
        var showLegend = Lib.coerce(
          layoutIn,
          layoutOut,
          basePlotLayoutAttributes,
          "showlegend",
          legendReallyHasATrace && legendTraceCount > (legendId === "legend" ? 1 : 0)
        );
        if (showLegend === false) layoutOut[legendId] = void 0;
        if (showLegend === false && !containerIn.uirevision) return;
        coerce("uirevision", layoutOut.uirevision);
        if (showLegend === false) return;
        coerce("borderwidth");
        var orientation = coerce("orientation");
        var yref = coerce("yref");
        var xref = coerce("xref");
        var isHorizontal = orientation === "h";
        var isPaperY = yref === "paper";
        var isPaperX = xref === "paper";
        var defaultX, defaultY, defaultYAnchor;
        var defaultXAnchor = "left";
        if (isHorizontal) {
          defaultX = 0;
          if (Registry.getComponentMethod("rangeslider", "isVisible")(layoutIn.xaxis)) {
            if (isPaperY) {
              defaultY = 1.1;
              defaultYAnchor = "bottom";
            } else {
              defaultY = 1;
              defaultYAnchor = "top";
            }
          } else {
            if (isPaperY) {
              defaultY = -0.1;
              defaultYAnchor = "top";
            } else {
              defaultY = 0;
              defaultYAnchor = "bottom";
            }
          }
        } else {
          defaultY = 1;
          defaultYAnchor = "auto";
          if (isPaperX) {
            defaultX = 1.02;
          } else {
            defaultX = 1;
            defaultXAnchor = "right";
          }
        }
        Lib.coerce(containerIn, containerOut, {
          x: {
            valType: "number",
            editType: "legend",
            min: isPaperX ? -2 : 0,
            max: isPaperX ? 3 : 1,
            dflt: defaultX
          }
        }, "x");
        Lib.coerce(containerIn, containerOut, {
          y: {
            valType: "number",
            editType: "legend",
            min: isPaperY ? -2 : 0,
            max: isPaperY ? 3 : 1,
            dflt: defaultY
          }
        }, "y");
        coerce("traceorder", defaultOrder);
        if (helpers.isGrouped(layoutOut[legendId])) coerce("tracegroupgap");
        coerce("entrywidth");
        coerce("entrywidthmode");
        coerce("indentation");
        coerce("itemsizing");
        coerce("itemwidth");
        coerce("itemclick");
        coerce("itemdoubleclick");
        coerce("groupclick");
        coerce("xanchor", defaultXAnchor);
        coerce("yanchor", defaultYAnchor);
        coerce("valign");
        Lib.noneOrAll(containerIn, containerOut, ["x", "y"]);
        var titleText = coerce("title.text");
        if (titleText) {
          coerce("title.side", isHorizontal ? "left" : "top");
          var dfltTitleFont = Lib.extendFlat({}, itemFont, {
            size: Lib.bigFont(itemFont.size)
          });
          Lib.coerceFont(coerce, "title.font", dfltTitleFont);
        }
      }
      module.exports = function legendDefaults(layoutIn, layoutOut, fullData) {
        var i;
        var allLegendsData = fullData.slice();
        var shapes = layoutOut.shapes;
        if (shapes) {
          for (i = 0; i < shapes.length; i++) {
            var shape = shapes[i];
            if (!shape.showlegend) continue;
            var mockTrace = {
              _input: shape._input,
              visible: shape.visible,
              showlegend: shape.showlegend,
              legend: shape.legend
            };
            allLegendsData.push(mockTrace);
          }
        }
        var legends = ["legend"];
        for (i = 0; i < allLegendsData.length; i++) {
          Lib.pushUnique(legends, allLegendsData[i].legend);
        }
        layoutOut._legends = [];
        for (i = 0; i < legends.length; i++) {
          var legendId = legends[i];
          groupDefaults(legendId, layoutIn, layoutOut, allLegendsData);
          if (layoutOut[legendId] && layoutOut[legendId].visible) {
            layoutOut[legendId]._id = legendId;
          }
          layoutOut._legends.push(legendId);
        }
      };
    }
  });

  // src/components/legend/handle_click.js
  var require_handle_click = __commonJS({
    "src/components/legend/handle_click.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var pushUnique = Lib.pushUnique;
      var SHOWISOLATETIP = true;
      module.exports = function handleClick(g, gd, numClicks) {
        var fullLayout = gd._fullLayout;
        if (gd._dragged || gd._editing) return;
        var itemClick = fullLayout.legend.itemclick;
        var itemDoubleClick = fullLayout.legend.itemdoubleclick;
        var groupClick = fullLayout.legend.groupclick;
        if (numClicks === 1 && itemClick === "toggle" && itemDoubleClick === "toggleothers" && SHOWISOLATETIP && gd.data && gd._context.showTips) {
          Lib.notifier(Lib._(gd, "Double-click on legend to isolate one trace"), "long");
          SHOWISOLATETIP = false;
        } else {
          SHOWISOLATETIP = false;
        }
        var mode;
        if (numClicks === 1) mode = itemClick;
        else if (numClicks === 2) mode = itemDoubleClick;
        if (!mode) return;
        var toggleGroup = groupClick === "togglegroup";
        var hiddenSlices = fullLayout.hiddenlabels ? fullLayout.hiddenlabels.slice() : [];
        var legendItem = g.data()[0][0];
        if (legendItem.groupTitle && legendItem.noClick) return;
        var fullData = gd._fullData;
        var shapesWithLegend = (fullLayout.shapes || []).filter(function(d2) {
          return d2.showlegend;
        });
        var allLegendItems = fullData.concat(shapesWithLegend);
        var fullTrace = legendItem.trace;
        if (fullTrace._isShape) {
          fullTrace = fullTrace._fullInput;
        }
        var legendgroup = fullTrace.legendgroup;
        var i, j, kcont, key, keys, val;
        var dataUpdate = {};
        var dataIndices = [];
        var carrs = [];
        var carrIdx = [];
        function insertDataUpdate(traceIndex, value) {
          var attrIndex = dataIndices.indexOf(traceIndex);
          var valueArray = dataUpdate.visible;
          if (!valueArray) {
            valueArray = dataUpdate.visible = [];
          }
          if (dataIndices.indexOf(traceIndex) === -1) {
            dataIndices.push(traceIndex);
            attrIndex = dataIndices.length - 1;
          }
          valueArray[attrIndex] = value;
          return attrIndex;
        }
        var updatedShapes = (fullLayout.shapes || []).map(function(d2) {
          return d2._input;
        });
        var shapesUpdated = false;
        function insertShapesUpdate(shapeIndex, value) {
          updatedShapes[shapeIndex].visible = value;
          shapesUpdated = true;
        }
        function setVisibility(fullTrace2, visibility) {
          if (legendItem.groupTitle && !toggleGroup) return;
          var fullInput2 = fullTrace2._fullInput || fullTrace2;
          var isShape2 = fullInput2._isShape;
          var index = fullInput2.index;
          if (index === void 0) index = fullInput2._index;
          var nextVisibility2 = fullInput2.visible === false ? false : visibility;
          if (isShape2) {
            insertShapesUpdate(index, nextVisibility2);
          } else {
            insertDataUpdate(index, nextVisibility2);
          }
        }
        var thisLegend = fullTrace.legend;
        var fullInput = fullTrace._fullInput;
        var isShape = fullInput && fullInput._isShape;
        if (!isShape && Registry.traceIs(fullTrace, "pie-like")) {
          var thisLabel = legendItem.label;
          var thisLabelIndex = hiddenSlices.indexOf(thisLabel);
          if (mode === "toggle") {
            if (thisLabelIndex === -1) hiddenSlices.push(thisLabel);
            else hiddenSlices.splice(thisLabelIndex, 1);
          } else if (mode === "toggleothers") {
            var changed = thisLabelIndex !== -1;
            var unhideList = [];
            for (i = 0; i < gd.calcdata.length; i++) {
              var cdi = gd.calcdata[i];
              for (j = 0; j < cdi.length; j++) {
                var d = cdi[j];
                var dLabel = d.label;
                if (thisLegend === cdi[0].trace.legend) {
                  if (thisLabel !== dLabel) {
                    if (hiddenSlices.indexOf(dLabel) === -1) changed = true;
                    pushUnique(hiddenSlices, dLabel);
                    unhideList.push(dLabel);
                  }
                }
              }
            }
            if (!changed) {
              for (var q = 0; q < unhideList.length; q++) {
                var pos = hiddenSlices.indexOf(unhideList[q]);
                if (pos !== -1) {
                  hiddenSlices.splice(pos, 1);
                }
              }
            }
          }
          Registry.call("_guiRelayout", gd, "hiddenlabels", hiddenSlices);
        } else {
          var hasLegendgroup = legendgroup && legendgroup.length;
          var traceIndicesInGroup = [];
          var tracei;
          if (hasLegendgroup) {
            for (i = 0; i < allLegendItems.length; i++) {
              tracei = allLegendItems[i];
              if (!tracei.visible) continue;
              if (tracei.legendgroup === legendgroup) {
                traceIndicesInGroup.push(i);
              }
            }
          }
          if (mode === "toggle") {
            var nextVisibility;
            switch (fullTrace.visible) {
              case true:
                nextVisibility = "legendonly";
                break;
              case false:
                nextVisibility = false;
                break;
              case "legendonly":
                nextVisibility = true;
                break;
            }
            if (hasLegendgroup) {
              if (toggleGroup) {
                for (i = 0; i < allLegendItems.length; i++) {
                  var item = allLegendItems[i];
                  if (item.visible !== false && item.legendgroup === legendgroup) {
                    setVisibility(item, nextVisibility);
                  }
                }
              } else {
                setVisibility(fullTrace, nextVisibility);
              }
            } else {
              setVisibility(fullTrace, nextVisibility);
            }
          } else if (mode === "toggleothers") {
            var isClicked, isInGroup, notInLegend, otherState, _item;
            var isIsolated = true;
            for (i = 0; i < allLegendItems.length; i++) {
              _item = allLegendItems[i];
              isClicked = _item === fullTrace;
              notInLegend = _item.showlegend !== true;
              if (isClicked || notInLegend) continue;
              isInGroup = hasLegendgroup && _item.legendgroup === legendgroup;
              if (!isInGroup && _item.legend === thisLegend && _item.visible === true && !Registry.traceIs(_item, "notLegendIsolatable")) {
                isIsolated = false;
                break;
              }
            }
            for (i = 0; i < allLegendItems.length; i++) {
              _item = allLegendItems[i];
              if (_item.visible === false || _item.legend !== thisLegend) continue;
              if (Registry.traceIs(_item, "notLegendIsolatable")) {
                continue;
              }
              switch (fullTrace.visible) {
                case "legendonly":
                  setVisibility(_item, true);
                  break;
                case true:
                  otherState = isIsolated ? true : "legendonly";
                  isClicked = _item === fullTrace;
                  notInLegend = _item.showlegend !== true && !_item.legendgroup;
                  isInGroup = isClicked || hasLegendgroup && _item.legendgroup === legendgroup;
                  setVisibility(_item, isInGroup || notInLegend ? true : otherState);
                  break;
              }
            }
          }
          for (i = 0; i < carrs.length; i++) {
            kcont = carrs[i];
            if (!kcont) continue;
            var update = kcont.constructUpdate();
            var updateKeys = Object.keys(update);
            for (j = 0; j < updateKeys.length; j++) {
              key = updateKeys[j];
              val = dataUpdate[key] = dataUpdate[key] || [];
              val[carrIdx[i]] = update[key];
            }
          }
          keys = Object.keys(dataUpdate);
          for (i = 0; i < keys.length; i++) {
            key = keys[i];
            for (j = 0; j < dataIndices.length; j++) {
              if (!dataUpdate[key].hasOwnProperty(j)) {
                dataUpdate[key][j] = void 0;
              }
            }
          }
          if (shapesUpdated) {
            Registry.call("_guiUpdate", gd, dataUpdate, { shapes: updatedShapes }, dataIndices);
          } else {
            Registry.call("_guiRestyle", gd, dataUpdate, dataIndices);
          }
        }
      };
    }
  });

  // src/components/legend/constants.js
  var require_constants3 = __commonJS({
    "src/components/legend/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        scrollBarWidth: 6,
        scrollBarMinHeight: 20,
        scrollBarColor: "#808BA4",
        scrollBarMargin: 4,
        scrollBarEnterAttrs: { rx: 20, ry: 3, width: 0, height: 0 },
        // number of px between legend title and (left) side of legend (always in x direction and from inner border)
        titlePad: 2,
        // number of px between each legend item (x and/or y direction)
        itemGap: 5
      };
    }
  });

  // src/components/legend/get_legend_data.js
  var require_get_legend_data = __commonJS({
    "src/components/legend/get_legend_data.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var helpers = require_helpers3();
      module.exports = function getLegendData(calcdata, opts, hasMultipleLegends) {
        var inHover = opts._inHover;
        var grouped = helpers.isGrouped(opts);
        var reversed = helpers.isReversed(opts);
        var lgroupToTraces = {};
        var lgroups = [];
        var hasOneNonBlankGroup = false;
        var slicesShown = {};
        var lgroupi = 0;
        var maxNameLength = 0;
        var i, j;
        function addOneItem(legendId, legendGroup, legendItem) {
          if (opts.visible === false) return;
          if (hasMultipleLegends && legendId !== opts._id) return;
          if (legendGroup === "" || !helpers.isGrouped(opts)) {
            var uniqueGroup = "~~i" + lgroupi;
            lgroups.push(uniqueGroup);
            lgroupToTraces[uniqueGroup] = [legendItem];
            lgroupi++;
          } else if (lgroups.indexOf(legendGroup) === -1) {
            lgroups.push(legendGroup);
            hasOneNonBlankGroup = true;
            lgroupToTraces[legendGroup] = [legendItem];
          } else {
            lgroupToTraces[legendGroup].push(legendItem);
          }
        }
        for (i = 0; i < calcdata.length; i++) {
          var cd = calcdata[i];
          var cd0 = cd[0];
          var trace = cd0.trace;
          var lid = trace.legend;
          var lgroup = trace.legendgroup;
          if (!inHover && (!trace.visible || !trace.showlegend)) continue;
          if (Registry.traceIs(trace, "pie-like")) {
            if (!slicesShown[lgroup]) slicesShown[lgroup] = {};
            for (j = 0; j < cd.length; j++) {
              var labelj = cd[j].label;
              if (!slicesShown[lgroup][labelj]) {
                addOneItem(lid, lgroup, {
                  label: labelj,
                  color: cd[j].color,
                  i: cd[j].i,
                  trace,
                  pts: cd[j].pts
                });
                slicesShown[lgroup][labelj] = true;
                maxNameLength = Math.max(maxNameLength, (labelj || "").length);
              }
            }
          } else {
            addOneItem(lid, lgroup, cd0);
            maxNameLength = Math.max(maxNameLength, (trace.name || "").length);
          }
        }
        if (!lgroups.length) return [];
        var shouldCollapse = !hasOneNonBlankGroup || !grouped;
        var legendData = [];
        for (i = 0; i < lgroups.length; i++) {
          var t = lgroupToTraces[lgroups[i]];
          if (shouldCollapse) {
            legendData.push(t[0]);
          } else {
            legendData.push(t);
          }
        }
        if (shouldCollapse) legendData = [legendData];
        for (i = 0; i < legendData.length; i++) {
          var groupMinRank = Infinity;
          for (j = 0; j < legendData[i].length; j++) {
            var rank = legendData[i][j].trace.legendrank;
            if (groupMinRank > rank) groupMinRank = rank;
          }
          legendData[i][0]._groupMinRank = groupMinRank;
          legendData[i][0]._preGroupSort = i;
        }
        var orderFn1 = function(a, b) {
          return a[0]._groupMinRank - b[0]._groupMinRank || a[0]._preGroupSort - b[0]._preGroupSort;
        };
        var orderFn2 = function(a, b) {
          return a.trace.legendrank - b.trace.legendrank || a._preSort - b._preSort;
        };
        legendData.forEach(function(a, k) {
          a[0]._preGroupSort = k;
        });
        legendData.sort(orderFn1);
        for (i = 0; i < legendData.length; i++) {
          legendData[i].forEach(function(a, k) {
            a._preSort = k;
          });
          legendData[i].sort(orderFn2);
          var firstItemTrace = legendData[i][0].trace;
          var groupTitle = null;
          for (j = 0; j < legendData[i].length; j++) {
            var gt = legendData[i][j].trace.legendgrouptitle;
            if (gt && gt.text) {
              groupTitle = gt;
              if (inHover) gt.font = opts._groupTitleFont;
              break;
            }
          }
          if (reversed) legendData[i].reverse();
          if (groupTitle) {
            var hasPieLike = false;
            for (j = 0; j < legendData[i].length; j++) {
              if (Registry.traceIs(legendData[i][j].trace, "pie-like")) {
                hasPieLike = true;
                break;
              }
            }
            legendData[i].unshift({
              i: -1,
              groupTitle,
              noClick: hasPieLike,
              trace: {
                showlegend: firstItemTrace.showlegend,
                legendgroup: firstItemTrace.legendgroup,
                visible: opts.groupclick === "toggleitem" ? true : firstItemTrace.visible
              }
            });
          }
          for (j = 0; j < legendData[i].length; j++) {
            legendData[i][j] = [
              legendData[i][j]
            ];
          }
        }
        opts._lgroupsLength = legendData.length;
        opts._maxNameLength = maxNameLength;
        return legendData;
      };
    }
  });

  // src/traces/pie/helpers.js
  var require_helpers4 = __commonJS({
    "src/traces/pie/helpers.js"(exports) {
      "use strict";
      var Lib = require_lib();
      function format(vRounded) {
        return vRounded.indexOf("e") !== -1 ? vRounded.replace(/[.]?0+e/, "e") : vRounded.indexOf(".") !== -1 ? vRounded.replace(/[.]?0+$/, "") : vRounded;
      }
      exports.formatPiePercent = function formatPiePercent(v, separators) {
        var vRounded = format((v * 100).toPrecision(3));
        return Lib.numSeparate(vRounded, separators) + "%";
      };
      exports.formatPieValue = function formatPieValue(v, separators) {
        var vRounded = format(v.toPrecision(10));
        return Lib.numSeparate(vRounded, separators);
      };
      exports.getFirstFilled = function getFirstFilled(array, indices) {
        if (!Lib.isArrayOrTypedArray(array)) return;
        for (var i = 0; i < indices.length; i++) {
          var v = array[indices[i]];
          if (v || v === 0 || v === "") return v;
        }
      };
      exports.castOption = function castOption(item, indices) {
        if (Lib.isArrayOrTypedArray(item)) return exports.getFirstFilled(item, indices);
        else if (item) return item;
      };
      exports.getRotationAngle = function(rotation) {
        return (rotation === "auto" ? 0 : rotation) * Math.PI / 180;
      };
    }
  });

  // src/traces/pie/fill_one.js
  var require_fill_one = __commonJS({
    "src/traces/pie/fill_one.js"(exports, module) {
      "use strict";
      var Drawing = require_drawing();
      var Color = require_color();
      module.exports = function fillOne(s, pt, trace, gd) {
        var pattern = trace.marker.pattern;
        if (pattern && pattern.shape) {
          Drawing.pointStyle(s, trace, gd, pt);
        } else {
          Color.fill(s, pt.color);
        }
      };
    }
  });

  // src/traces/pie/style_one.js
  var require_style_one = __commonJS({
    "src/traces/pie/style_one.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var castOption = require_helpers4().castOption;
      var fillOne = require_fill_one();
      module.exports = function styleOne(s, pt, trace, gd) {
        var line = trace.marker.line;
        var lineColor = castOption(line.color, pt.pts) || Color.defaultLine;
        var lineWidth = castOption(line.width, pt.pts) || 0;
        s.call(fillOne, pt, trace, gd).style("stroke-width", lineWidth).call(Color.stroke, lineColor);
      };
    }
  });

  // src/components/legend/style.js
  var require_style = __commonJS({
    "src/components/legend/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var Drawing = require_drawing();
      var Color = require_color();
      var extractOpts = require_helpers().extractOpts;
      var subTypes = require_subtypes();
      var stylePie = require_style_one();
      var pieCastOption = require_helpers4().castOption;
      var constants = require_constants3();
      var CST_MARKER_SIZE = 12;
      var CST_LINE_WIDTH = 5;
      var CST_MARKER_LINE_WIDTH = 2;
      var MAX_LINE_WIDTH = 10;
      var MAX_MARKER_LINE_WIDTH = 5;
      module.exports = function style(s, gd, legend) {
        var fullLayout = gd._fullLayout;
        if (!legend) legend = fullLayout.legend;
        var constantItemSizing = legend.itemsizing === "constant";
        var itemWidth = legend.itemwidth;
        var centerPos = (itemWidth + constants.itemGap * 2) / 2;
        var centerTransform = strTranslate(centerPos, 0);
        var boundLineWidth = function(mlw, cont, max, cst) {
          var v;
          if (mlw + 1) {
            v = mlw;
          } else if (cont && cont.width > 0) {
            v = cont.width;
          } else {
            return 0;
          }
          return constantItemSizing ? cst : Math.min(v, max);
        };
        s.each(function(d) {
          var traceGroup = d3.select(this);
          var layers = Lib.ensureSingle(traceGroup, "g", "layers");
          layers.style("opacity", d[0].trace.opacity);
          var indentation = legend.indentation;
          var valign = legend.valign;
          var lineHeight = d[0].lineHeight;
          var height = d[0].height;
          if (valign === "middle" && indentation === 0 || !lineHeight || !height) {
            layers.attr("transform", null);
          } else {
            var factor = { top: 1, bottom: -1 }[valign];
            var markerOffsetY = factor * (0.5 * (lineHeight - height + 3)) || 0;
            var markerOffsetX = legend.indentation;
            layers.attr("transform", strTranslate(markerOffsetX, markerOffsetY));
          }
          var fill = layers.selectAll("g.legendfill").data([d]);
          fill.enter().append("g").classed("legendfill", true);
          var line = layers.selectAll("g.legendlines").data([d]);
          line.enter().append("g").classed("legendlines", true);
          var symbol = layers.selectAll("g.legendsymbols").data([d]);
          symbol.enter().append("g").classed("legendsymbols", true);
          symbol.selectAll("g.legendpoints").data([d]).enter().append("g").classed("legendpoints", true);
        }).each(styleSpatial).each(styleWaterfalls).each(styleFunnels).each(styleBars).each(styleBoxes).each(styleFunnelareas).each(stylePies).each(styleLines).each(stylePoints).each(styleCandles).each(styleOHLC);
        function styleLines(d) {
          var styleGuide = getStyleGuide(d);
          var showFill = styleGuide.showFill;
          var showLine = styleGuide.showLine;
          var showGradientLine = styleGuide.showGradientLine;
          var showGradientFill = styleGuide.showGradientFill;
          var anyFill = styleGuide.anyFill;
          var anyLine = styleGuide.anyLine;
          var d0 = d[0];
          var trace = d0.trace;
          var dMod, tMod;
          var cOpts = extractOpts(trace);
          var colorscale = cOpts.colorscale;
          var reversescale = cOpts.reversescale;
          var fillStyle = function(s2) {
            if (s2.size()) {
              if (showFill) {
                Drawing.fillGroupStyle(s2, gd, true);
              } else {
                var gradientID = "legendfill-" + trace.uid;
                Drawing.gradient(
                  s2,
                  gd,
                  gradientID,
                  getGradientDirection(reversescale),
                  colorscale,
                  "fill"
                );
              }
            }
          };
          var lineGradient = function(s2) {
            if (s2.size()) {
              var gradientID = "legendline-" + trace.uid;
              Drawing.lineGroupStyle(s2);
              Drawing.gradient(
                s2,
                gd,
                gradientID,
                getGradientDirection(reversescale),
                colorscale,
                "stroke"
              );
            }
          };
          var pathStart = subTypes.hasMarkers(trace) || !anyFill ? "M5,0" : (
            // with a line leave it slightly below center, to leave room for the
            // line thickness and because the line is usually more prominent
            anyLine ? "M5,-2" : "M5,-3"
          );
          var this3 = d3.select(this);
          var fill = this3.select(".legendfill").selectAll("path").data(showFill || showGradientFill ? [d] : []);
          fill.enter().append("path").classed("js-fill", true);
          fill.exit().remove();
          fill.attr("d", pathStart + "h" + itemWidth + "v6h-" + itemWidth + "z").call(fillStyle);
          if (showLine || showGradientLine) {
            var lw = boundLineWidth(void 0, trace.line, MAX_LINE_WIDTH, CST_LINE_WIDTH);
            tMod = Lib.minExtend(trace, { line: { width: lw } });
            dMod = [Lib.minExtend(d0, { trace: tMod })];
          }
          var line = this3.select(".legendlines").selectAll("path").data(showLine || showGradientLine ? [dMod] : []);
          line.enter().append("path").classed("js-line", true);
          line.exit().remove();
          line.attr("d", pathStart + (showGradientLine ? "l" + itemWidth + ",0.0001" : "h" + itemWidth)).call(showLine ? Drawing.lineGroupStyle : lineGradient);
        }
        function stylePoints(d) {
          var styleGuide = getStyleGuide(d);
          var anyFill = styleGuide.anyFill;
          var anyLine = styleGuide.anyLine;
          var showLine = styleGuide.showLine;
          var showMarker = styleGuide.showMarker;
          var d0 = d[0];
          var trace = d0.trace;
          var showText = !showMarker && !anyLine && !anyFill && subTypes.hasText(trace);
          var dMod, tMod;
          function boundVal(attrIn, arrayToValFn, bounds, cst) {
            var valIn = Lib.nestedProperty(trace, attrIn).get();
            var valToBound = Lib.isArrayOrTypedArray(valIn) && arrayToValFn ? arrayToValFn(valIn) : valIn;
            if (constantItemSizing && valToBound && cst !== void 0) {
              valToBound = cst;
            }
            if (bounds) {
              if (valToBound < bounds[0]) return bounds[0];
              else if (valToBound > bounds[1]) return bounds[1];
            }
            return valToBound;
          }
          function pickFirst(array) {
            if (d0._distinct && d0.index && array[d0.index]) return array[d0.index];
            return array[0];
          }
          if (showMarker || showText || showLine) {
            var dEdit = {};
            var tEdit = {};
            if (showMarker) {
              dEdit.mc = boundVal("marker.color", pickFirst);
              dEdit.mx = boundVal("marker.symbol", pickFirst);
              dEdit.mo = boundVal("marker.opacity", Lib.mean, [0.2, 1]);
              dEdit.mlc = boundVal("marker.line.color", pickFirst);
              dEdit.mlw = boundVal("marker.line.width", Lib.mean, [0, 5], CST_MARKER_LINE_WIDTH);
              tEdit.marker = {
                sizeref: 1,
                sizemin: 1,
                sizemode: "diameter"
              };
              var ms = boundVal("marker.size", Lib.mean, [2, 16], CST_MARKER_SIZE);
              dEdit.ms = ms;
              tEdit.marker.size = ms;
            }
            if (showLine) {
              tEdit.line = {
                width: boundVal("line.width", pickFirst, [0, 10], CST_LINE_WIDTH)
              };
            }
            if (showText) {
              dEdit.tx = "Aa";
              dEdit.tp = boundVal("textposition", pickFirst);
              dEdit.ts = 10;
              dEdit.tc = boundVal("textfont.color", pickFirst);
              dEdit.tf = boundVal("textfont.family", pickFirst);
              dEdit.tw = boundVal("textfont.weight", pickFirst);
              dEdit.ty = boundVal("textfont.style", pickFirst);
              dEdit.tv = boundVal("textfont.variant", pickFirst);
              dEdit.tC = boundVal("textfont.textcase", pickFirst);
              dEdit.tE = boundVal("textfont.lineposition", pickFirst);
              dEdit.tS = boundVal("textfont.shadow", pickFirst);
            }
            dMod = [Lib.minExtend(d0, dEdit)];
            tMod = Lib.minExtend(trace, tEdit);
            tMod.selectedpoints = null;
            tMod.texttemplate = null;
          }
          var ptgroup = d3.select(this).select("g.legendpoints");
          var pts = ptgroup.selectAll("path.scatterpts").data(showMarker ? dMod : []);
          pts.enter().insert("path", ":first-child").classed("scatterpts", true).attr("transform", centerTransform);
          pts.exit().remove();
          pts.call(Drawing.pointStyle, tMod, gd);
          if (showMarker) dMod[0].mrc = 3;
          var txt = ptgroup.selectAll("g.pointtext").data(showText ? dMod : []);
          txt.enter().append("g").classed("pointtext", true).append("text").attr("transform", centerTransform);
          txt.exit().remove();
          txt.selectAll("text").call(Drawing.textPointStyle, tMod, gd);
        }
        function styleWaterfalls(d) {
          var trace = d[0].trace;
          var isWaterfall = trace.type === "waterfall";
          if (d[0]._distinct && isWaterfall) {
            var cont = d[0].trace[d[0].dir].marker;
            d[0].mc = cont.color;
            d[0].mlw = cont.line.width;
            d[0].mlc = cont.line.color;
            return styleBarLike(d, this, "waterfall");
          }
          var ptsData = [];
          if (trace.visible && isWaterfall) {
            ptsData = d[0].hasTotals ? [["increasing", "M-6,-6V6H0Z"], ["totals", "M6,6H0L-6,-6H-0Z"], ["decreasing", "M6,6V-6H0Z"]] : [["increasing", "M-6,-6V6H6Z"], ["decreasing", "M6,6V-6H-6Z"]];
          }
          var pts = d3.select(this).select("g.legendpoints").selectAll("path.legendwaterfall").data(ptsData);
          pts.enter().append("path").classed("legendwaterfall", true).attr("transform", centerTransform).style("stroke-miterlimit", 1);
          pts.exit().remove();
          pts.each(function(dd) {
            var pt = d3.select(this);
            var cont2 = trace[dd[0]].marker;
            var lw = boundLineWidth(void 0, cont2.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
            pt.attr("d", dd[1]).style("stroke-width", lw + "px").call(Color.fill, cont2.color);
            if (lw) {
              pt.call(Color.stroke, cont2.line.color);
            }
          });
        }
        function styleBars(d) {
          styleBarLike(d, this);
        }
        function styleFunnels(d) {
          styleBarLike(d, this, "funnel");
        }
        function styleBarLike(d, lThis, desiredType) {
          var trace = d[0].trace;
          var marker = trace.marker || {};
          var markerLine = marker.line || {};
          var pathStr = marker.cornerradius ? "M6,3a3,3,0,0,1-3,3H-3a3,3,0,0,1-3-3V-3a3,3,0,0,1,3-3H3a3,3,0,0,1,3,3Z" : (
            // Square with rounded corners
            "M6,6H-6V-6H6Z"
          );
          var isVisible = !desiredType ? Registry.traceIs(trace, "bar") : trace.visible && trace.type === desiredType;
          var barpath = d3.select(lThis).select("g.legendpoints").selectAll("path.legend" + desiredType).data(isVisible ? [d] : []);
          barpath.enter().append("path").classed("legend" + desiredType, true).attr("d", pathStr).attr("transform", centerTransform);
          barpath.exit().remove();
          barpath.each(function(d2) {
            var p = d3.select(this);
            var d0 = d2[0];
            var w = boundLineWidth(d0.mlw, marker.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
            p.style("stroke-width", w + "px");
            var mcc = d0.mcc;
            if (!legend._inHover && "mc" in d0) {
              var cOpts = extractOpts(marker);
              var mid = cOpts.mid;
              if (mid === void 0) mid = (cOpts.max + cOpts.min) / 2;
              mcc = Drawing.tryColorscale(marker, "")(mid);
            }
            var fillColor = mcc || d0.mc || marker.color;
            var markerPattern = marker.pattern;
            var patternShape = markerPattern && Drawing.getPatternAttr(markerPattern.shape, 0, "");
            if (patternShape) {
              var patternBGColor = Drawing.getPatternAttr(markerPattern.bgcolor, 0, null);
              var patternFGColor = Drawing.getPatternAttr(markerPattern.fgcolor, 0, null);
              var patternFGOpacity = markerPattern.fgopacity;
              var patternSize = dimAttr(markerPattern.size, 8, 10);
              var patternSolidity = dimAttr(markerPattern.solidity, 0.5, 1);
              var patternID = "legend-" + trace.uid;
              p.call(
                Drawing.pattern,
                "legend",
                gd,
                patternID,
                patternShape,
                patternSize,
                patternSolidity,
                mcc,
                markerPattern.fillmode,
                patternBGColor,
                patternFGColor,
                patternFGOpacity
              );
            } else {
              p.call(Color.fill, fillColor);
            }
            if (w) Color.stroke(p, d0.mlc || markerLine.color);
          });
        }
        function styleBoxes(d) {
          var trace = d[0].trace;
          var pts = d3.select(this).select("g.legendpoints").selectAll("path.legendbox").data(trace.visible && Registry.traceIs(trace, "box-violin") ? [d] : []);
          pts.enter().append("path").classed("legendbox", true).attr("d", "M6,6H-6V-6H6Z").attr("transform", centerTransform);
          pts.exit().remove();
          pts.each(function() {
            var p = d3.select(this);
            if ((trace.boxpoints === "all" || trace.points === "all") && Color.opacity(trace.fillcolor) === 0 && Color.opacity((trace.line || {}).color) === 0) {
              var tMod = Lib.minExtend(trace, {
                marker: {
                  size: constantItemSizing ? CST_MARKER_SIZE : Lib.constrain(trace.marker.size, 2, 16),
                  sizeref: 1,
                  sizemin: 1,
                  sizemode: "diameter"
                }
              });
              pts.call(Drawing.pointStyle, tMod, gd);
            } else {
              var w = boundLineWidth(void 0, trace.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
              p.style("stroke-width", w + "px").call(Color.fill, trace.fillcolor);
              if (w) Color.stroke(p, trace.line.color);
            }
          });
        }
        function styleCandles(d) {
          var trace = d[0].trace;
          var pts = d3.select(this).select("g.legendpoints").selectAll("path.legendcandle").data(trace.visible && trace.type === "candlestick" ? [d, d] : []);
          pts.enter().append("path").classed("legendcandle", true).attr("d", function(_, i) {
            if (i) return "M-15,0H-8M-8,6V-6H8Z";
            return "M15,0H8M8,-6V6H-8Z";
          }).attr("transform", centerTransform).style("stroke-miterlimit", 1);
          pts.exit().remove();
          pts.each(function(_, i) {
            var p = d3.select(this);
            var cont = trace[i ? "increasing" : "decreasing"];
            var w = boundLineWidth(void 0, cont.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
            p.style("stroke-width", w + "px").call(Color.fill, cont.fillcolor);
            if (w) Color.stroke(p, cont.line.color);
          });
        }
        function styleOHLC(d) {
          var trace = d[0].trace;
          var pts = d3.select(this).select("g.legendpoints").selectAll("path.legendohlc").data(trace.visible && trace.type === "ohlc" ? [d, d] : []);
          pts.enter().append("path").classed("legendohlc", true).attr("d", function(_, i) {
            if (i) return "M-15,0H0M-8,-6V0";
            return "M15,0H0M8,6V0";
          }).attr("transform", centerTransform).style("stroke-miterlimit", 1);
          pts.exit().remove();
          pts.each(function(_, i) {
            var p = d3.select(this);
            var cont = trace[i ? "increasing" : "decreasing"];
            var w = boundLineWidth(void 0, cont.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
            p.style("fill", "none").call(Drawing.dashLine, cont.line.dash, w);
            if (w) Color.stroke(p, cont.line.color);
          });
        }
        function stylePies(d) {
          stylePieLike(d, this, "pie");
        }
        function styleFunnelareas(d) {
          stylePieLike(d, this, "funnelarea");
        }
        function stylePieLike(d, lThis, desiredType) {
          var d0 = d[0];
          var trace = d0.trace;
          var isVisible = !desiredType ? Registry.traceIs(trace, desiredType) : trace.visible && trace.type === desiredType;
          var pts = d3.select(lThis).select("g.legendpoints").selectAll("path.legend" + desiredType).data(isVisible ? [d] : []);
          pts.enter().append("path").classed("legend" + desiredType, true).attr("d", "M6,6H-6V-6H6Z").attr("transform", centerTransform);
          pts.exit().remove();
          if (pts.size()) {
            var cont = trace.marker || {};
            var lw = boundLineWidth(pieCastOption(cont.line.width, d0.pts), cont.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
            var opt = "pieLike";
            var tMod = Lib.minExtend(trace, { marker: { line: { width: lw } } }, opt);
            var d0Mod = Lib.minExtend(d0, { trace: tMod }, opt);
            stylePie(pts, d0Mod, tMod, gd);
          }
        }
        function styleSpatial(d) {
          var trace = d[0].trace;
          var useGradient;
          var ptsData = [];
          if (trace.visible) {
            switch (trace.type) {
              case "histogram2d":
              case "heatmap":
                ptsData = [
                  ["M-15,-2V4H15V-2Z"]
                  // similar to contour
                ];
                useGradient = true;
                break;
              case "choropleth":
              case "choroplethmapbox":
              case "choroplethmap":
                ptsData = [
                  ["M-6,-6V6H6V-6Z"]
                ];
                useGradient = true;
                break;
              case "densitymapbox":
              case "densitymap":
                ptsData = [
                  ["M-6,0 a6,6 0 1,0 12,0 a 6,6 0 1,0 -12,0"]
                ];
                useGradient = "radial";
                break;
              case "cone":
                ptsData = [
                  ["M-6,2 A2,2 0 0,0 -6,6 V6L6,4Z"],
                  ["M-6,-6 A2,2 0 0,0 -6,-2 L6,-4Z"],
                  ["M-6,-2 A2,2 0 0,0 -6,2 L6,0Z"]
                ];
                useGradient = false;
                break;
              case "streamtube":
                ptsData = [
                  ["M-6,2 A2,2 0 0,0 -6,6 H6 A2,2 0 0,1 6,2 Z"],
                  ["M-6,-6 A2,2 0 0,0 -6,-2 H6 A2,2 0 0,1 6,-6 Z"],
                  ["M-6,-2 A2,2 0 0,0 -6,2 H6 A2,2 0 0,1 6,-2 Z"]
                ];
                useGradient = false;
                break;
              case "surface":
                ptsData = [
                  ["M-6,-6 A2,3 0 0,0 -6,0 H6 A2,3 0 0,1 6,-6 Z"],
                  ["M-6,1 A2,3 0 0,1 -6,6 H6 A2,3 0 0,0 6,0 Z"]
                ];
                useGradient = true;
                break;
              case "mesh3d":
                ptsData = [
                  ["M-6,6H0L-6,-6Z"],
                  ["M6,6H0L6,-6Z"],
                  ["M-6,-6H6L0,6Z"]
                ];
                useGradient = false;
                break;
              case "volume":
                ptsData = [
                  ["M-6,6H0L-6,-6Z"],
                  ["M6,6H0L6,-6Z"],
                  ["M-6,-6H6L0,6Z"]
                ];
                useGradient = true;
                break;
              case "isosurface":
                ptsData = [
                  ["M-6,6H0L-6,-6Z"],
                  ["M6,6H0L6,-6Z"],
                  ["M-6,-6 A12,24 0 0,0 6,-6 L0,6Z"]
                ];
                useGradient = false;
                break;
            }
          }
          var pts = d3.select(this).select("g.legendpoints").selectAll("path.legend3dandfriends").data(ptsData);
          pts.enter().append("path").classed("legend3dandfriends", true).attr("transform", centerTransform).style("stroke-miterlimit", 1);
          pts.exit().remove();
          pts.each(function(dd, i) {
            var pt = d3.select(this);
            var cOpts = extractOpts(trace);
            var colorscale = cOpts.colorscale;
            var reversescale = cOpts.reversescale;
            var fillGradient = function(s2) {
              if (s2.size()) {
                var gradientID = "legendfill-" + trace.uid;
                Drawing.gradient(
                  s2,
                  gd,
                  gradientID,
                  getGradientDirection(reversescale, useGradient === "radial"),
                  colorscale,
                  "fill"
                );
              }
            };
            var fillColor;
            if (!colorscale) {
              var color = trace.vertexcolor || trace.facecolor || trace.color;
              fillColor = Lib.isArrayOrTypedArray(color) ? color[i] || color[0] : color;
            } else {
              if (!useGradient) {
                var len = colorscale.length;
                fillColor = i === 0 ? colorscale[reversescale ? len - 1 : 0][1] : (
                  // minimum
                  i === 1 ? colorscale[reversescale ? 0 : len - 1][1] : (
                    // maximum
                    colorscale[Math.floor((len - 1) / 2)][1]
                  )
                );
              }
            }
            pt.attr("d", dd[0]);
            if (fillColor) {
              pt.call(Color.fill, fillColor);
            } else {
              pt.call(fillGradient);
            }
          });
        }
      };
      function getGradientDirection(reversescale, isRadial) {
        var str = isRadial ? "radial" : "horizontal";
        return str + (reversescale ? "" : "reversed");
      }
      function getStyleGuide(d) {
        var trace = d[0].trace;
        var contours = trace.contours;
        var showLine = subTypes.hasLines(trace);
        var showMarker = subTypes.hasMarkers(trace);
        var showFill = trace.visible && trace.fill && trace.fill !== "none";
        var showGradientLine = false;
        var showGradientFill = false;
        if (contours) {
          var coloring = contours.coloring;
          if (coloring === "lines") {
            showGradientLine = true;
          } else {
            showLine = coloring === "none" || coloring === "heatmap" || contours.showlines;
          }
          if (contours.type === "constraint") {
            showFill = contours._operation !== "=";
          } else if (coloring === "fill" || coloring === "heatmap") {
            showGradientFill = true;
          }
        }
        return {
          showMarker,
          showLine,
          showFill,
          showGradientLine,
          showGradientFill,
          anyLine: showLine || showGradientLine,
          anyFill: showFill || showGradientFill
        };
      }
      function dimAttr(v, dflt, max) {
        if (v && Lib.isArrayOrTypedArray(v)) return dflt;
        if (v > max) return max;
        return v;
      }
    }
  });

  // src/components/legend/draw.js
  var require_draw = __commonJS({
    "src/components/legend/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var Plots = require_plots();
      var Registry = require_registry();
      var Events = require_events2();
      var dragElement = require_dragelement();
      var Drawing = require_drawing();
      var Color = require_color();
      var svgTextUtils = require_svg_text_utils();
      var handleClick = require_handle_click();
      var constants = require_constants3();
      var alignmentConstants = require_alignment();
      var LINE_SPACING = alignmentConstants.LINE_SPACING;
      var FROM_TL = alignmentConstants.FROM_TL;
      var FROM_BR = alignmentConstants.FROM_BR;
      var getLegendData = require_get_legend_data();
      var style = require_style();
      var helpers = require_helpers3();
      var MAIN_TITLE = 1;
      var LEGEND_PATTERN = /^legend[0-9]*$/;
      module.exports = function draw(gd, opts) {
        if (opts) {
          drawOne(gd, opts);
        } else {
          var fullLayout = gd._fullLayout;
          var newLegends = fullLayout._legends;
          var oldLegends = fullLayout._infolayer.selectAll('[class^="legend"]');
          oldLegends.each(function() {
            var el = d3.select(this);
            var classes = el.attr("class");
            var cls = classes.split(" ")[0];
            if (cls.match(LEGEND_PATTERN) && newLegends.indexOf(cls) === -1) {
              el.remove();
            }
          });
          for (var i = 0; i < newLegends.length; i++) {
            var legendId = newLegends[i];
            var legendObj = gd._fullLayout[legendId];
            drawOne(gd, legendObj);
          }
        }
      };
      function horizontalAlignTitle(titleEl, legendObj, bw) {
        if (legendObj.title.side !== "top center" && legendObj.title.side !== "top right") return;
        var font = legendObj.title.font;
        var lineHeight = font.size * LINE_SPACING;
        var titleOffset = 0;
        var textNode = titleEl.node();
        var width = Drawing.bBox(textNode).width;
        if (legendObj.title.side === "top center") {
          titleOffset = 0.5 * (legendObj._width - 2 * bw - 2 * constants.titlePad - width);
        } else if (legendObj.title.side === "top right") {
          titleOffset = legendObj._width - 2 * bw - 2 * constants.titlePad - width;
        }
        svgTextUtils.positionText(
          titleEl,
          bw + constants.titlePad + titleOffset,
          bw + lineHeight
        );
      }
      function drawOne(gd, opts) {
        var legendObj = opts || {};
        var fullLayout = gd._fullLayout;
        var legendId = getId(legendObj);
        var clipId, layer;
        var inHover = legendObj._inHover;
        if (inHover) {
          layer = legendObj.layer;
          clipId = "hover";
        } else {
          layer = fullLayout._infolayer;
          clipId = legendId;
        }
        if (!layer) return;
        clipId += fullLayout._uid;
        if (!gd._legendMouseDownTime) gd._legendMouseDownTime = 0;
        var legendData;
        if (!inHover) {
          var calcdata = (gd.calcdata || []).slice();
          var shapes = fullLayout.shapes;
          for (var i = 0; i < shapes.length; i++) {
            var shape = shapes[i];
            if (!shape.showlegend) continue;
            var shapeLegend = {
              _isShape: true,
              _fullInput: shape,
              index: shape._index,
              name: shape.name || shape.label.text || "shape " + shape._index,
              legend: shape.legend,
              legendgroup: shape.legendgroup,
              legendgrouptitle: shape.legendgrouptitle,
              legendrank: shape.legendrank,
              legendwidth: shape.legendwidth,
              showlegend: shape.showlegend,
              visible: shape.visible,
              opacity: shape.opacity,
              mode: shape.type === "line" ? "lines" : "markers",
              line: shape.line,
              marker: {
                line: shape.line,
                color: shape.fillcolor,
                size: 12,
                symbol: shape.type === "rect" ? "square" : shape.type === "circle" ? "circle" : (
                  // case of path
                  "hexagon2"
                )
              }
            };
            calcdata.push([{ trace: shapeLegend }]);
          }
          legendData = fullLayout.showlegend && getLegendData(calcdata, legendObj, fullLayout._legends.length > 1);
        } else {
          if (!legendObj.entries) return;
          legendData = getLegendData(legendObj.entries, legendObj);
        }
        var hiddenSlices = fullLayout.hiddenlabels || [];
        if (!inHover && (!fullLayout.showlegend || !legendData.length)) {
          layer.selectAll("." + legendId).remove();
          fullLayout._topdefs.select("#" + clipId).remove();
          return Plots.autoMargin(gd, legendId);
        }
        var legend = Lib.ensureSingle(layer, "g", legendId, function(s) {
          if (!inHover) s.attr("pointer-events", "all");
        });
        var clipPath = Lib.ensureSingleById(fullLayout._topdefs, "clipPath", clipId, function(s) {
          s.append("rect");
        });
        var bg = Lib.ensureSingle(legend, "rect", "bg", function(s) {
          s.attr("shape-rendering", "crispEdges");
        });
        bg.call(Color.stroke, legendObj.bordercolor).call(Color.fill, legendObj.bgcolor).style("stroke-width", legendObj.borderwidth + "px");
        var scrollBox = Lib.ensureSingle(legend, "g", "scrollbox");
        var title = legendObj.title;
        legendObj._titleWidth = 0;
        legendObj._titleHeight = 0;
        var titleEl;
        if (title.text) {
          titleEl = Lib.ensureSingle(scrollBox, "text", legendId + "titletext");
          titleEl.attr("text-anchor", "start").call(Drawing.font, title.font).text(title.text);
          textLayout(titleEl, scrollBox, gd, legendObj, MAIN_TITLE);
        } else {
          scrollBox.selectAll("." + legendId + "titletext").remove();
        }
        var scrollBar = Lib.ensureSingle(legend, "rect", "scrollbar", function(s) {
          s.attr(constants.scrollBarEnterAttrs).call(Color.fill, constants.scrollBarColor);
        });
        var groups = scrollBox.selectAll("g.groups").data(legendData);
        groups.enter().append("g").attr("class", "groups");
        groups.exit().remove();
        var traces = groups.selectAll("g.traces").data(Lib.identity);
        traces.enter().append("g").attr("class", "traces");
        traces.exit().remove();
        traces.style("opacity", function(d) {
          var trace = d[0].trace;
          if (Registry.traceIs(trace, "pie-like")) {
            return hiddenSlices.indexOf(d[0].label) !== -1 ? 0.5 : 1;
          } else {
            return trace.visible === "legendonly" ? 0.5 : 1;
          }
        }).each(function() {
          d3.select(this).call(drawTexts, gd, legendObj);
        }).call(style, gd, legendObj).each(function() {
          if (!inHover) d3.select(this).call(setupTraceToggle, gd, legendId);
        });
        Lib.syncOrAsync([
          Plots.previousPromises,
          function() {
            return computeLegendDimensions(gd, groups, traces, legendObj);
          },
          function() {
            var gs = fullLayout._size;
            var bw = legendObj.borderwidth;
            var isPaperX = legendObj.xref === "paper";
            var isPaperY = legendObj.yref === "paper";
            if (title.text) {
              horizontalAlignTitle(titleEl, legendObj, bw);
            }
            if (!inHover) {
              var lx, ly;
              if (isPaperX) {
                lx = gs.l + gs.w * legendObj.x - FROM_TL[getXanchor(legendObj)] * legendObj._width;
              } else {
                lx = fullLayout.width * legendObj.x - FROM_TL[getXanchor(legendObj)] * legendObj._width;
              }
              if (isPaperY) {
                ly = gs.t + gs.h * (1 - legendObj.y) - FROM_TL[getYanchor(legendObj)] * legendObj._effHeight;
              } else {
                ly = fullLayout.height * (1 - legendObj.y) - FROM_TL[getYanchor(legendObj)] * legendObj._effHeight;
              }
              var expMargin = expandMargin(gd, legendId, lx, ly);
              if (expMargin) return;
              if (fullLayout.margin.autoexpand) {
                var lx0 = lx;
                var ly0 = ly;
                lx = isPaperX ? Lib.constrain(lx, 0, fullLayout.width - legendObj._width) : lx0;
                ly = isPaperY ? Lib.constrain(ly, 0, fullLayout.height - legendObj._effHeight) : ly0;
                if (lx !== lx0) {
                  Lib.log("Constrain " + legendId + ".x to make legend fit inside graph");
                }
                if (ly !== ly0) {
                  Lib.log("Constrain " + legendId + ".y to make legend fit inside graph");
                }
              }
              Drawing.setTranslate(legend, lx, ly);
            }
            scrollBar.on(".drag", null);
            legend.on("wheel", null);
            if (inHover || legendObj._height <= legendObj._maxHeight || gd._context.staticPlot) {
              var height = legendObj._effHeight;
              if (inHover) height = legendObj._height;
              bg.attr({
                width: legendObj._width - bw,
                height: height - bw,
                x: bw / 2,
                y: bw / 2
              });
              Drawing.setTranslate(scrollBox, 0, 0);
              clipPath.select("rect").attr({
                width: legendObj._width - 2 * bw,
                height: height - 2 * bw,
                x: bw,
                y: bw
              });
              Drawing.setClipUrl(scrollBox, clipId, gd);
              Drawing.setRect(scrollBar, 0, 0, 0, 0);
              delete legendObj._scrollY;
            } else {
              var scrollBarHeight = Math.max(
                constants.scrollBarMinHeight,
                legendObj._effHeight * legendObj._effHeight / legendObj._height
              );
              var scrollBarYMax = legendObj._effHeight - scrollBarHeight - 2 * constants.scrollBarMargin;
              var scrollBoxYMax = legendObj._height - legendObj._effHeight;
              var scrollRatio = scrollBarYMax / scrollBoxYMax;
              var scrollBoxY = Math.min(legendObj._scrollY || 0, scrollBoxYMax);
              bg.attr({
                width: legendObj._width - 2 * bw + constants.scrollBarWidth + constants.scrollBarMargin,
                height: legendObj._effHeight - bw,
                x: bw / 2,
                y: bw / 2
              });
              clipPath.select("rect").attr({
                width: legendObj._width - 2 * bw + constants.scrollBarWidth + constants.scrollBarMargin,
                height: legendObj._effHeight - 2 * bw,
                x: bw,
                y: bw + scrollBoxY
              });
              Drawing.setClipUrl(scrollBox, clipId, gd);
              scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);
              legend.on("wheel", function() {
                scrollBoxY = Lib.constrain(
                  legendObj._scrollY + d3.event.deltaY / scrollBarYMax * scrollBoxYMax,
                  0,
                  scrollBoxYMax
                );
                scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);
                if (scrollBoxY !== 0 && scrollBoxY !== scrollBoxYMax) {
                  d3.event.preventDefault();
                }
              });
              var eventY0, eventY1, scrollBoxY0;
              var getScrollBarDragY = function(scrollBoxY02, eventY02, eventY12) {
                var y = (eventY12 - eventY02) / scrollRatio + scrollBoxY02;
                return Lib.constrain(y, 0, scrollBoxYMax);
              };
              var getNaturalDragY = function(scrollBoxY02, eventY02, eventY12) {
                var y = (eventY02 - eventY12) / scrollRatio + scrollBoxY02;
                return Lib.constrain(y, 0, scrollBoxYMax);
              };
              var scrollBarDrag = d3.behavior.drag().on("dragstart", function() {
                var e = d3.event.sourceEvent;
                if (e.type === "touchstart") {
                  eventY0 = e.changedTouches[0].clientY;
                } else {
                  eventY0 = e.clientY;
                }
                scrollBoxY0 = scrollBoxY;
              }).on("drag", function() {
                var e = d3.event.sourceEvent;
                if (e.buttons === 2 || e.ctrlKey) return;
                if (e.type === "touchmove") {
                  eventY1 = e.changedTouches[0].clientY;
                } else {
                  eventY1 = e.clientY;
                }
                scrollBoxY = getScrollBarDragY(scrollBoxY0, eventY0, eventY1);
                scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);
              });
              scrollBar.call(scrollBarDrag);
              var scrollBoxTouchDrag = d3.behavior.drag().on("dragstart", function() {
                var e = d3.event.sourceEvent;
                if (e.type === "touchstart") {
                  eventY0 = e.changedTouches[0].clientY;
                  scrollBoxY0 = scrollBoxY;
                }
              }).on("drag", function() {
                var e = d3.event.sourceEvent;
                if (e.type === "touchmove") {
                  eventY1 = e.changedTouches[0].clientY;
                  scrollBoxY = getNaturalDragY(scrollBoxY0, eventY0, eventY1);
                  scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);
                }
              });
              scrollBox.call(scrollBoxTouchDrag);
            }
            function scrollHandler(scrollBoxY2, scrollBarHeight2, scrollRatio2) {
              legendObj._scrollY = gd._fullLayout[legendId]._scrollY = scrollBoxY2;
              Drawing.setTranslate(scrollBox, 0, -scrollBoxY2);
              Drawing.setRect(
                scrollBar,
                legendObj._width,
                constants.scrollBarMargin + scrollBoxY2 * scrollRatio2,
                constants.scrollBarWidth,
                scrollBarHeight2
              );
              clipPath.select("rect").attr("y", bw + scrollBoxY2);
            }
            if (gd._context.edits.legendPosition) {
              var xf, yf, x0, y0;
              legend.classed("cursor-move", true);
              dragElement.init({
                element: legend.node(),
                gd,
                prepFn: function(e) {
                  if (e.target === scrollBar.node()) {
                    return;
                  }
                  var transform = Drawing.getTranslate(legend);
                  x0 = transform.x;
                  y0 = transform.y;
                },
                moveFn: function(dx, dy) {
                  if (x0 !== void 0 && y0 !== void 0) {
                    var newX = x0 + dx;
                    var newY = y0 + dy;
                    Drawing.setTranslate(legend, newX, newY);
                    xf = dragElement.align(newX, legendObj._width, gs.l, gs.l + gs.w, legendObj.xanchor);
                    yf = dragElement.align(newY + legendObj._height, -legendObj._height, gs.t + gs.h, gs.t, legendObj.yanchor);
                  }
                },
                doneFn: function() {
                  if (xf !== void 0 && yf !== void 0) {
                    var obj = {};
                    obj[legendId + ".x"] = xf;
                    obj[legendId + ".y"] = yf;
                    Registry.call("_guiRelayout", gd, obj);
                  }
                },
                clickFn: function(numClicks, e) {
                  var clickedTrace = layer.selectAll("g.traces").filter(function() {
                    var bbox = this.getBoundingClientRect();
                    return e.clientX >= bbox.left && e.clientX <= bbox.right && e.clientY >= bbox.top && e.clientY <= bbox.bottom;
                  });
                  if (clickedTrace.size() > 0) {
                    clickOrDoubleClick(gd, legend, clickedTrace, numClicks, e);
                  }
                }
              });
            }
          }
        ], gd);
      }
      function getTraceWidth(d, legendObj, textGap) {
        var legendItem = d[0];
        var legendWidth = legendItem.width;
        var mode = legendObj.entrywidthmode;
        var traceLegendWidth = legendItem.trace.legendwidth || legendObj.entrywidth;
        if (mode === "fraction") return legendObj._maxWidth * traceLegendWidth;
        return textGap + (traceLegendWidth || legendWidth);
      }
      function clickOrDoubleClick(gd, legend, legendItem, numClicks, evt) {
        var trace = legendItem.data()[0][0].trace;
        var evtData = {
          event: evt,
          node: legendItem.node(),
          curveNumber: trace.index,
          expandedIndex: trace.index,
          data: gd.data,
          layout: gd.layout,
          frames: gd._transitionData._frames,
          config: gd._context,
          fullData: gd._fullData,
          fullLayout: gd._fullLayout
        };
        if (trace._group) {
          evtData.group = trace._group;
        }
        if (Registry.traceIs(trace, "pie-like")) {
          evtData.label = legendItem.datum()[0].label;
        }
        var clickVal = Events.triggerHandler(gd, "plotly_legendclick", evtData);
        if (numClicks === 1) {
          if (clickVal === false) return;
          legend._clickTimeout = setTimeout(function() {
            if (!gd._fullLayout) return;
            handleClick(legendItem, gd, numClicks);
          }, gd._context.doubleClickDelay);
        } else if (numClicks === 2) {
          if (legend._clickTimeout) clearTimeout(legend._clickTimeout);
          gd._legendMouseDownTime = 0;
          var dblClickVal = Events.triggerHandler(gd, "plotly_legenddoubleclick", evtData);
          if (dblClickVal !== false && clickVal !== false) handleClick(legendItem, gd, numClicks);
        }
      }
      function drawTexts(g, gd, legendObj) {
        var legendId = getId(legendObj);
        var legendItem = g.data()[0][0];
        var trace = legendItem.trace;
        var isPieLike = Registry.traceIs(trace, "pie-like");
        var isEditable = !legendObj._inHover && gd._context.edits.legendText && !isPieLike;
        var maxNameLength = legendObj._maxNameLength;
        var name, font;
        if (legendItem.groupTitle) {
          name = legendItem.groupTitle.text;
          font = legendItem.groupTitle.font;
        } else {
          font = legendObj.font;
          if (!legendObj.entries) {
            name = isPieLike ? legendItem.label : trace.name;
            if (trace._meta) {
              name = Lib.templateString(name, trace._meta);
            }
          } else {
            name = legendItem.text;
          }
        }
        var textEl = Lib.ensureSingle(g, "text", legendId + "text");
        textEl.attr("text-anchor", "start").call(Drawing.font, font).text(isEditable ? ensureLength(name, maxNameLength) : name);
        var textGap = legendObj.indentation + legendObj.itemwidth + constants.itemGap * 2;
        svgTextUtils.positionText(textEl, textGap, 0);
        if (isEditable) {
          textEl.call(svgTextUtils.makeEditable, { gd, text: name }).call(textLayout, g, gd, legendObj).on("edit", function(newName) {
            this.text(ensureLength(newName, maxNameLength)).call(textLayout, g, gd, legendObj);
            var fullInput = legendItem.trace._fullInput || {};
            var update = {};
            update.name = newName;
            if (fullInput._isShape) {
              return Registry.call("_guiRelayout", gd, "shapes[" + trace.index + "].name", update.name);
            } else {
              return Registry.call("_guiRestyle", gd, update, trace.index);
            }
          });
        } else {
          textLayout(textEl, g, gd, legendObj);
        }
      }
      function ensureLength(str, maxLength) {
        var targetLength = Math.max(4, maxLength);
        if (str && str.trim().length >= targetLength / 2) return str;
        str = str || "";
        for (var i = targetLength - str.length; i > 0; i--) str += " ";
        return str;
      }
      function setupTraceToggle(g, gd, legendId) {
        var doubleClickDelay = gd._context.doubleClickDelay;
        var newMouseDownTime;
        var numClicks = 1;
        var traceToggle = Lib.ensureSingle(g, "rect", legendId + "toggle", function(s) {
          if (!gd._context.staticPlot) {
            s.style("cursor", "pointer").attr("pointer-events", "all");
          }
          s.call(Color.fill, "rgba(0,0,0,0)");
        });
        if (gd._context.staticPlot) return;
        traceToggle.on("mousedown", function() {
          newMouseDownTime = (/* @__PURE__ */ new Date()).getTime();
          if (newMouseDownTime - gd._legendMouseDownTime < doubleClickDelay) {
            numClicks += 1;
          } else {
            numClicks = 1;
            gd._legendMouseDownTime = newMouseDownTime;
          }
        });
        traceToggle.on("mouseup", function() {
          if (gd._dragged || gd._editing) return;
          var legend = gd._fullLayout[legendId];
          if ((/* @__PURE__ */ new Date()).getTime() - gd._legendMouseDownTime > doubleClickDelay) {
            numClicks = Math.max(numClicks - 1, 1);
          }
          clickOrDoubleClick(gd, legend, g, numClicks, d3.event);
        });
      }
      function textLayout(s, g, gd, legendObj, aTitle) {
        if (legendObj._inHover) s.attr("data-notex", true);
        svgTextUtils.convertToTspans(s, gd, function() {
          computeTextDimensions(g, gd, legendObj, aTitle);
        });
      }
      function computeTextDimensions(g, gd, legendObj, aTitle) {
        var legendItem = g.data()[0][0];
        if (!legendObj._inHover && legendItem && !legendItem.trace.showlegend) {
          g.remove();
          return;
        }
        var mathjaxGroup = g.select("g[class*=math-group]");
        var mathjaxNode = mathjaxGroup.node();
        var legendId = getId(legendObj);
        if (!legendObj) {
          legendObj = gd._fullLayout[legendId];
        }
        var bw = legendObj.borderwidth;
        var font;
        if (aTitle === MAIN_TITLE) {
          font = legendObj.title.font;
        } else if (legendItem.groupTitle) {
          font = legendItem.groupTitle.font;
        } else {
          font = legendObj.font;
        }
        var lineHeight = font.size * LINE_SPACING;
        var height, width;
        if (mathjaxNode) {
          var mathjaxBB = Drawing.bBox(mathjaxNode);
          height = mathjaxBB.height;
          width = mathjaxBB.width;
          if (aTitle === MAIN_TITLE) {
            Drawing.setTranslate(mathjaxGroup, bw, bw + height * 0.75);
          } else {
            Drawing.setTranslate(mathjaxGroup, 0, height * 0.25);
          }
        } else {
          var cls = "." + legendId + (aTitle === MAIN_TITLE ? "title" : "") + "text";
          var textEl = g.select(cls);
          var textLines = svgTextUtils.lineCount(textEl);
          var textNode = textEl.node();
          height = lineHeight * textLines;
          width = textNode ? Drawing.bBox(textNode).width : 0;
          if (aTitle === MAIN_TITLE) {
            if (legendObj.title.side === "left") {
              width += constants.itemGap * 2;
            }
            svgTextUtils.positionText(
              textEl,
              bw + constants.titlePad,
              bw + lineHeight
            );
          } else {
            var x = constants.itemGap * 2 + legendObj.indentation + legendObj.itemwidth;
            if (legendItem.groupTitle) {
              x = constants.itemGap;
              width -= legendObj.indentation + legendObj.itemwidth;
            }
            svgTextUtils.positionText(
              textEl,
              x,
              -lineHeight * ((textLines - 1) / 2 - 0.3)
            );
          }
        }
        if (aTitle === MAIN_TITLE) {
          legendObj._titleWidth = width;
          legendObj._titleHeight = height;
        } else {
          legendItem.lineHeight = lineHeight;
          legendItem.height = Math.max(height, 16) + 3;
          legendItem.width = width;
        }
      }
      function getTitleSize(legendObj) {
        var w = 0;
        var h = 0;
        var side = legendObj.title.side;
        if (side) {
          if (side.indexOf("left") !== -1) {
            w = legendObj._titleWidth;
          }
          if (side.indexOf("top") !== -1) {
            h = legendObj._titleHeight;
          }
        }
        return [w, h];
      }
      function computeLegendDimensions(gd, groups, traces, legendObj) {
        var fullLayout = gd._fullLayout;
        var legendId = getId(legendObj);
        if (!legendObj) {
          legendObj = fullLayout[legendId];
        }
        var gs = fullLayout._size;
        var isVertical = helpers.isVertical(legendObj);
        var isGrouped = helpers.isGrouped(legendObj);
        var isFraction = legendObj.entrywidthmode === "fraction";
        var bw = legendObj.borderwidth;
        var bw2 = 2 * bw;
        var itemGap = constants.itemGap;
        var textGap = legendObj.indentation + legendObj.itemwidth + itemGap * 2;
        var endPad = 2 * (bw + itemGap);
        var yanchor = getYanchor(legendObj);
        var isBelowPlotArea = legendObj.y < 0 || legendObj.y === 0 && yanchor === "top";
        var isAbovePlotArea = legendObj.y > 1 || legendObj.y === 1 && yanchor === "bottom";
        var traceGroupGap = legendObj.tracegroupgap;
        var legendGroupWidths = {};
        legendObj._maxHeight = Math.max(
          isBelowPlotArea || isAbovePlotArea ? fullLayout.height / 2 : gs.h,
          30
        );
        var toggleRectWidth = 0;
        legendObj._width = 0;
        legendObj._height = 0;
        var titleSize = getTitleSize(legendObj);
        if (isVertical) {
          traces.each(function(d) {
            var h = d[0].height;
            Drawing.setTranslate(
              this,
              bw + titleSize[0],
              bw + titleSize[1] + legendObj._height + h / 2 + itemGap
            );
            legendObj._height += h;
            legendObj._width = Math.max(legendObj._width, d[0].width);
          });
          toggleRectWidth = textGap + legendObj._width;
          legendObj._width += itemGap + textGap + bw2;
          legendObj._height += endPad;
          if (isGrouped) {
            groups.each(function(d, i) {
              Drawing.setTranslate(this, 0, i * legendObj.tracegroupgap);
            });
            legendObj._height += (legendObj._lgroupsLength - 1) * legendObj.tracegroupgap;
          }
        } else {
          var xanchor = getXanchor(legendObj);
          var isLeftOfPlotArea = legendObj.x < 0 || legendObj.x === 0 && xanchor === "right";
          var isRightOfPlotArea = legendObj.x > 1 || legendObj.x === 1 && xanchor === "left";
          var isBeyondPlotAreaY = isAbovePlotArea || isBelowPlotArea;
          var hw = fullLayout.width / 2;
          legendObj._maxWidth = Math.max(
            isLeftOfPlotArea ? isBeyondPlotAreaY && xanchor === "left" ? gs.l + gs.w : hw : isRightOfPlotArea ? isBeyondPlotAreaY && xanchor === "right" ? gs.r + gs.w : hw : gs.w,
            2 * textGap
          );
          var maxItemWidth = 0;
          var combinedItemWidth = 0;
          traces.each(function(d) {
            var w = getTraceWidth(d, legendObj, textGap);
            maxItemWidth = Math.max(maxItemWidth, w);
            combinedItemWidth += w;
          });
          toggleRectWidth = null;
          var maxRowWidth = 0;
          if (isGrouped) {
            var maxGroupHeightInRow = 0;
            var groupOffsetX = 0;
            var groupOffsetY = 0;
            groups.each(function() {
              var maxWidthInGroup = 0;
              var offsetY2 = 0;
              d3.select(this).selectAll("g.traces").each(function(d) {
                var w = getTraceWidth(d, legendObj, textGap);
                var h = d[0].height;
                Drawing.setTranslate(
                  this,
                  titleSize[0],
                  titleSize[1] + bw + itemGap + h / 2 + offsetY2
                );
                offsetY2 += h;
                maxWidthInGroup = Math.max(maxWidthInGroup, w);
                legendGroupWidths[d[0].trace.legendgroup] = maxWidthInGroup;
              });
              var next = maxWidthInGroup + itemGap;
              if (
                // not on the first column already
                groupOffsetX > 0 && // goes beyound limit
                next + bw + groupOffsetX > legendObj._maxWidth
              ) {
                maxRowWidth = Math.max(maxRowWidth, groupOffsetX);
                groupOffsetX = 0;
                groupOffsetY += maxGroupHeightInRow + traceGroupGap;
                maxGroupHeightInRow = offsetY2;
              } else {
                maxGroupHeightInRow = Math.max(maxGroupHeightInRow, offsetY2);
              }
              Drawing.setTranslate(this, groupOffsetX, groupOffsetY);
              groupOffsetX += next;
            });
            legendObj._width = Math.max(maxRowWidth, groupOffsetX) + bw;
            legendObj._height = groupOffsetY + maxGroupHeightInRow + endPad;
          } else {
            var nTraces = traces.size();
            var oneRowLegend = combinedItemWidth + bw2 + (nTraces - 1) * itemGap < legendObj._maxWidth;
            var maxItemHeightInRow = 0;
            var offsetX = 0;
            var offsetY = 0;
            var rowWidth = 0;
            traces.each(function(d) {
              var h = d[0].height;
              var w = getTraceWidth(d, legendObj, textGap, isGrouped);
              var next = oneRowLegend ? w : maxItemWidth;
              if (!isFraction) {
                next += itemGap;
              }
              if (next + bw + offsetX - itemGap >= legendObj._maxWidth) {
                maxRowWidth = Math.max(maxRowWidth, rowWidth);
                offsetX = 0;
                offsetY += maxItemHeightInRow;
                legendObj._height += maxItemHeightInRow;
                maxItemHeightInRow = 0;
              }
              Drawing.setTranslate(
                this,
                titleSize[0] + bw + offsetX,
                titleSize[1] + bw + offsetY + h / 2 + itemGap
              );
              rowWidth = offsetX + w + itemGap;
              offsetX += next;
              maxItemHeightInRow = Math.max(maxItemHeightInRow, h);
            });
            if (oneRowLegend) {
              legendObj._width = offsetX + bw2;
              legendObj._height = maxItemHeightInRow + endPad;
            } else {
              legendObj._width = Math.max(maxRowWidth, rowWidth) + bw2;
              legendObj._height += maxItemHeightInRow + endPad;
            }
          }
        }
        legendObj._width = Math.ceil(
          Math.max(
            legendObj._width + titleSize[0],
            legendObj._titleWidth + 2 * (bw + constants.titlePad)
          )
        );
        legendObj._height = Math.ceil(
          Math.max(
            legendObj._height + titleSize[1],
            legendObj._titleHeight + 2 * (bw + constants.itemGap)
          )
        );
        legendObj._effHeight = Math.min(legendObj._height, legendObj._maxHeight);
        var edits = gd._context.edits;
        var isEditable = edits.legendText || edits.legendPosition;
        traces.each(function(d) {
          var traceToggle = d3.select(this).select("." + legendId + "toggle");
          var h = d[0].height;
          var legendgroup = d[0].trace.legendgroup;
          var traceWidth = getTraceWidth(d, legendObj, textGap);
          if (isGrouped && legendgroup !== "") {
            traceWidth = legendGroupWidths[legendgroup];
          }
          var w = isEditable ? textGap : toggleRectWidth || traceWidth;
          if (!isVertical && !isFraction) {
            w += itemGap / 2;
          }
          Drawing.setRect(traceToggle, 0, -h / 2, w, h);
        });
      }
      function expandMargin(gd, legendId, lx, ly) {
        var fullLayout = gd._fullLayout;
        var legendObj = fullLayout[legendId];
        var xanchor = getXanchor(legendObj);
        var yanchor = getYanchor(legendObj);
        var isPaperX = legendObj.xref === "paper";
        var isPaperY = legendObj.yref === "paper";
        gd._fullLayout._reservedMargin[legendId] = {};
        var sideY = legendObj.y < 0.5 ? "b" : "t";
        var sideX = legendObj.x < 0.5 ? "l" : "r";
        var possibleReservedMargins = {
          r: fullLayout.width - lx,
          l: lx + legendObj._width,
          b: fullLayout.height - ly,
          t: ly + legendObj._effHeight
        };
        if (isPaperX && isPaperY) {
          return Plots.autoMargin(gd, legendId, {
            x: legendObj.x,
            y: legendObj.y,
            l: legendObj._width * FROM_TL[xanchor],
            r: legendObj._width * FROM_BR[xanchor],
            b: legendObj._effHeight * FROM_BR[yanchor],
            t: legendObj._effHeight * FROM_TL[yanchor]
          });
        } else if (isPaperX) {
          gd._fullLayout._reservedMargin[legendId][sideY] = possibleReservedMargins[sideY];
        } else if (isPaperY) {
          gd._fullLayout._reservedMargin[legendId][sideX] = possibleReservedMargins[sideX];
        } else {
          if (legendObj.orientation === "v") {
            gd._fullLayout._reservedMargin[legendId][sideX] = possibleReservedMargins[sideX];
          } else {
            gd._fullLayout._reservedMargin[legendId][sideY] = possibleReservedMargins[sideY];
          }
        }
      }
      function getXanchor(legendObj) {
        return Lib.isRightAnchor(legendObj) ? "right" : Lib.isCenterAnchor(legendObj) ? "center" : "left";
      }
      function getYanchor(legendObj) {
        return Lib.isBottomAnchor(legendObj) ? "bottom" : Lib.isMiddleAnchor(legendObj) ? "middle" : "top";
      }
      function getId(legendObj) {
        return legendObj._id || "legend";
      }
    }
  });

  // src/components/fx/hover.js
  var require_hover = __commonJS({
    "src/components/fx/hover.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var tinycolor = require_tinycolor();
      var Lib = require_lib();
      var pushUnique = Lib.pushUnique;
      var strTranslate = Lib.strTranslate;
      var strRotate = Lib.strRotate;
      var Events = require_events2();
      var svgTextUtils = require_svg_text_utils();
      var overrideCursor = require_override_cursor();
      var Drawing = require_drawing();
      var Color = require_color();
      var dragElement = require_dragelement();
      var Axes = require_axes();
      var zindexSeparator = require_constants2().zindexSeparator;
      var Registry = require_registry();
      var helpers = require_helpers2();
      var constants = require_constants();
      var legendSupplyDefaults = require_defaults3();
      var legendDraw = require_draw();
      var YANGLE = constants.YANGLE;
      var YA_RADIANS = Math.PI * YANGLE / 180;
      var YFACTOR = 1 / Math.sin(YA_RADIANS);
      var YSHIFTX = Math.cos(YA_RADIANS);
      var YSHIFTY = Math.sin(YA_RADIANS);
      var HOVERARROWSIZE = constants.HOVERARROWSIZE;
      var HOVERTEXTPAD = constants.HOVERTEXTPAD;
      var multipleHoverPoints = {
        box: true,
        ohlc: true,
        violin: true,
        candlestick: true
      };
      var cartesianScatterPoints = {
        scatter: true,
        scattergl: true,
        splom: true
      };
      function distanceSort(a, b) {
        return a.distance - b.distance;
      }
      exports.hover = function hover(gd, evt, subplot, noHoverEvent) {
        gd = Lib.getGraphDiv(gd);
        var eventTarget = evt.target;
        Lib.throttle(
          gd._fullLayout._uid + constants.HOVERID,
          constants.HOVERMINTIME,
          function() {
            _hover(gd, evt, subplot, noHoverEvent, eventTarget);
          }
        );
      };
      exports.loneHover = function loneHover(hoverItems, opts) {
        var multiHover = true;
        if (!Array.isArray(hoverItems)) {
          multiHover = false;
          hoverItems = [hoverItems];
        }
        var gd = opts.gd;
        var gTop = getTopOffset(gd);
        var gLeft = getLeftOffset(gd);
        var pointsData = hoverItems.map(function(hoverItem) {
          var _x0 = hoverItem._x0 || hoverItem.x0 || hoverItem.x || 0;
          var _x1 = hoverItem._x1 || hoverItem.x1 || hoverItem.x || 0;
          var _y0 = hoverItem._y0 || hoverItem.y0 || hoverItem.y || 0;
          var _y1 = hoverItem._y1 || hoverItem.y1 || hoverItem.y || 0;
          var eventData = hoverItem.eventData;
          if (eventData) {
            var x0 = Math.min(_x0, _x1);
            var x1 = Math.max(_x0, _x1);
            var y0 = Math.min(_y0, _y1);
            var y1 = Math.max(_y0, _y1);
            var trace = hoverItem.trace;
            if (Registry.traceIs(trace, "gl3d")) {
              var container = gd._fullLayout[trace.scene]._scene.container;
              var dx = container.offsetLeft;
              var dy = container.offsetTop;
              x0 += dx;
              x1 += dx;
              y0 += dy;
              y1 += dy;
            }
            eventData.bbox = {
              x0: x0 + gLeft,
              x1: x1 + gLeft,
              y0: y0 + gTop,
              y1: y1 + gTop
            };
            if (opts.inOut_bbox) {
              opts.inOut_bbox.push(eventData.bbox);
            }
          } else {
            eventData = false;
          }
          return {
            color: hoverItem.color || Color.defaultLine,
            x0: hoverItem.x0 || hoverItem.x || 0,
            x1: hoverItem.x1 || hoverItem.x || 0,
            y0: hoverItem.y0 || hoverItem.y || 0,
            y1: hoverItem.y1 || hoverItem.y || 0,
            xLabel: hoverItem.xLabel,
            yLabel: hoverItem.yLabel,
            zLabel: hoverItem.zLabel,
            text: hoverItem.text,
            name: hoverItem.name,
            idealAlign: hoverItem.idealAlign,
            // optional extra bits of styling
            borderColor: hoverItem.borderColor,
            fontFamily: hoverItem.fontFamily,
            fontSize: hoverItem.fontSize,
            fontColor: hoverItem.fontColor,
            fontWeight: hoverItem.fontWeight,
            fontStyle: hoverItem.fontStyle,
            fontVariant: hoverItem.fontVariant,
            nameLength: hoverItem.nameLength,
            textAlign: hoverItem.textAlign,
            // filler to make createHoverText happy
            trace: hoverItem.trace || {
              index: 0,
              hoverinfo: ""
            },
            xa: { _offset: 0 },
            ya: { _offset: 0 },
            index: 0,
            hovertemplate: hoverItem.hovertemplate || false,
            hovertemplateLabels: hoverItem.hovertemplateLabels || false,
            eventData
          };
        });
        var rotateLabels = false;
        var hoverText = createHoverText(pointsData, {
          gd,
          hovermode: "closest",
          rotateLabels,
          bgColor: opts.bgColor || Color.background,
          container: d3.select(opts.container),
          outerContainer: opts.outerContainer || opts.container
        });
        var hoverLabel = hoverText.hoverLabels;
        var tooltipSpacing = 5;
        var lastBottomY = 0;
        var anchor = 0;
        hoverLabel.sort(function(a, b) {
          return a.y0 - b.y0;
        }).each(function(d, i) {
          var topY = d.y0 - d.by / 2;
          if (topY - tooltipSpacing < lastBottomY) {
            d.offset = lastBottomY - topY + tooltipSpacing;
          } else {
            d.offset = 0;
          }
          lastBottomY = topY + d.by + d.offset;
          if (i === opts.anchorIndex || 0) anchor = d.offset;
        }).each(function(d) {
          d.offset -= anchor;
        });
        var scaleX = gd._fullLayout._invScaleX;
        var scaleY = gd._fullLayout._invScaleY;
        alignHoverText(hoverLabel, rotateLabels, scaleX, scaleY);
        return multiHover ? hoverLabel : hoverLabel.node();
      };
      function _hover(gd, evt, subplot, noHoverEvent, eventTarget) {
        if (!subplot) subplot = "xy";
        if (typeof subplot === "string") {
          subplot = subplot.split(zindexSeparator)[0];
        }
        var subplots = Array.isArray(subplot) ? subplot : [subplot];
        var spId;
        var fullLayout = gd._fullLayout;
        var hoversubplots = fullLayout.hoversubplots;
        var plots = fullLayout._plots || [];
        var plotinfo = plots[subplot];
        var hasCartesian = fullLayout._has("cartesian");
        var hovermode = evt.hovermode || fullLayout.hovermode;
        var hovermodeHasX = (hovermode || "").charAt(0) === "x";
        var hovermodeHasY = (hovermode || "").charAt(0) === "y";
        var firstXaxis;
        var firstYaxis;
        if (hasCartesian && (hovermodeHasX || hovermodeHasY) && hoversubplots === "axis") {
          var subplotsLength = subplots.length;
          for (var p = 0; p < subplotsLength; p++) {
            spId = subplots[p];
            if (plots[spId]) {
              firstXaxis = Axes.getFromId(gd, spId, "x");
              firstYaxis = Axes.getFromId(gd, spId, "y");
              var subplotsWith = (hovermodeHasX ? firstXaxis : firstYaxis)._subplotsWith;
              if (subplotsWith && subplotsWith.length) {
                for (var q = 0; q < subplotsWith.length; q++) {
                  pushUnique(subplots, subplotsWith[q]);
                }
              }
            }
          }
        }
        if (plotinfo && hoversubplots !== "single") {
          var overlayedSubplots = plotinfo.overlays.map(function(pi) {
            return pi.id;
          });
          subplots = subplots.concat(overlayedSubplots);
        }
        var len = subplots.length;
        var xaArray = new Array(len);
        var yaArray = new Array(len);
        var supportsCompare = false;
        for (var i = 0; i < len; i++) {
          spId = subplots[i];
          if (plots[spId]) {
            supportsCompare = true;
            xaArray[i] = plots[spId].xaxis;
            yaArray[i] = plots[spId].yaxis;
          } else if (fullLayout[spId] && fullLayout[spId]._subplot) {
            var _subplot = fullLayout[spId]._subplot;
            xaArray[i] = _subplot.xaxis;
            yaArray[i] = _subplot.yaxis;
          } else {
            Lib.warn("Unrecognized subplot: " + spId);
            return;
          }
        }
        if (hovermode && !supportsCompare) hovermode = "closest";
        if (["x", "y", "closest", "x unified", "y unified"].indexOf(hovermode) === -1 || !gd.calcdata || gd.querySelector(".zoombox") || gd._dragging) {
          return dragElement.unhoverRaw(gd, evt);
        }
        var hoverdistance = fullLayout.hoverdistance;
        if (hoverdistance === -1) hoverdistance = Infinity;
        var spikedistance = fullLayout.spikedistance;
        if (spikedistance === -1) spikedistance = Infinity;
        var hoverData = [];
        var searchData = [];
        var xvalArray, yvalArray;
        var itemnum, curvenum, cd, trace, subplotId, subploti, _mode, xval, yval, pointData, closedataPreviousLength;
        var spikePoints = {
          hLinePoint: null,
          vLinePoint: null
        };
        var hasOneHorizontalTrace = false;
        if (Array.isArray(evt)) {
          hovermode = "array";
          for (itemnum = 0; itemnum < evt.length; itemnum++) {
            cd = gd.calcdata[evt[itemnum].curveNumber || 0];
            if (cd) {
              trace = cd[0].trace;
              if (cd[0].trace.hoverinfo !== "skip") {
                searchData.push(cd);
                if (trace.orientation === "h") {
                  hasOneHorizontalTrace = true;
                }
              }
            }
          }
        } else {
          var zorderedCalcdata = gd.calcdata.slice();
          zorderedCalcdata.sort(function(a, b) {
            var aZorder = a[0].trace.zorder || 0;
            var bZorder = b[0].trace.zorder || 0;
            return aZorder - bZorder;
          });
          for (curvenum = 0; curvenum < zorderedCalcdata.length; curvenum++) {
            cd = zorderedCalcdata[curvenum];
            trace = cd[0].trace;
            if (trace.hoverinfo !== "skip" && helpers.isTraceInSubplots(trace, subplots)) {
              searchData.push(cd);
              if (trace.orientation === "h") {
                hasOneHorizontalTrace = true;
              }
            }
          }
          var hasUserCalledHover = !eventTarget;
          var xpx, ypx;
          if (hasUserCalledHover) {
            if ("xpx" in evt) xpx = evt.xpx;
            else xpx = xaArray[0]._length / 2;
            if ("ypx" in evt) ypx = evt.ypx;
            else ypx = yaArray[0]._length / 2;
          } else {
            if (Events.triggerHandler(gd, "plotly_beforehover", evt) === false) {
              return;
            }
            var dbb = eventTarget.getBoundingClientRect();
            xpx = evt.clientX - dbb.left;
            ypx = evt.clientY - dbb.top;
            fullLayout._calcInverseTransform(gd);
            var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(xpx, ypx);
            xpx = transformedCoords[0];
            ypx = transformedCoords[1];
            if (xpx < 0 || xpx > xaArray[0]._length || ypx < 0 || ypx > yaArray[0]._length) {
              return dragElement.unhoverRaw(gd, evt);
            }
          }
          evt.pointerX = xpx + xaArray[0]._offset;
          evt.pointerY = ypx + yaArray[0]._offset;
          if ("xval" in evt) xvalArray = helpers.flat(subplots, evt.xval);
          else xvalArray = helpers.p2c(xaArray, xpx);
          if ("yval" in evt) yvalArray = helpers.flat(subplots, evt.yval);
          else yvalArray = helpers.p2c(yaArray, ypx);
          if (!isNumeric(xvalArray[0]) || !isNumeric(yvalArray[0])) {
            Lib.warn("Fx.hover failed", evt, gd);
            return dragElement.unhoverRaw(gd, evt);
          }
        }
        var distance = Infinity;
        function findHoverPoints(customXVal, customYVal) {
          for (curvenum = 0; curvenum < searchData.length; curvenum++) {
            cd = searchData[curvenum];
            if (!cd || !cd[0] || !cd[0].trace) continue;
            trace = cd[0].trace;
            if (trace.visible !== true || trace._length === 0) continue;
            if (["carpet", "contourcarpet"].indexOf(trace._module.name) !== -1) continue;
            _mode = hovermode;
            if (helpers.isUnifiedHover(_mode)) {
              _mode = _mode.charAt(0);
            }
            if (trace.type === "splom") {
              subploti = 0;
              subplotId = subplots[subploti];
            } else {
              subplotId = helpers.getSubplot(trace);
              subploti = subplots.indexOf(subplotId);
            }
            pointData = {
              // trace properties
              cd,
              trace,
              xa: xaArray[subploti],
              ya: yaArray[subploti],
              // max distances for hover and spikes - for points that want to show but do not
              // want to override other points, set distance/spikeDistance equal to max*Distance
              // and it will not get filtered out but it will be guaranteed to have a greater
              // distance than any point that calculated a real distance.
              maxHoverDistance: hoverdistance,
              maxSpikeDistance: spikedistance,
              // point properties - override all of these
              index: false,
              // point index in trace - only used by plotly.js hoverdata consumers
              distance: Math.min(distance, hoverdistance),
              // pixel distance or pseudo-distance
              // distance/pseudo-distance for spikes. This distance should always be calculated
              // as if in "closest" mode, and should only be set if this point should
              // generate a spike.
              spikeDistance: Infinity,
              // in some cases the spikes have different positioning from the hover label
              // they don't need x0/x1, just one position
              xSpike: void 0,
              ySpike: void 0,
              // where and how to display the hover label
              color: Color.defaultLine,
              // trace color
              name: trace.name,
              x0: void 0,
              x1: void 0,
              y0: void 0,
              y1: void 0,
              xLabelVal: void 0,
              yLabelVal: void 0,
              zLabelVal: void 0,
              text: void 0
            };
            if (fullLayout[subplotId]) {
              pointData.subplot = fullLayout[subplotId]._subplot;
            }
            if (fullLayout._splomScenes && fullLayout._splomScenes[trace.uid]) {
              pointData.scene = fullLayout._splomScenes[trace.uid];
            }
            if (_mode === "array") {
              var selection = evt[curvenum];
              if ("pointNumber" in selection) {
                pointData.index = selection.pointNumber;
                _mode = "closest";
              } else {
                _mode = "";
                if ("xval" in selection) {
                  xval = selection.xval;
                  _mode = "x";
                }
                if ("yval" in selection) {
                  yval = selection.yval;
                  _mode = _mode ? "closest" : "y";
                }
              }
            } else if (customXVal !== void 0 && customYVal !== void 0) {
              xval = customXVal;
              yval = customYVal;
            } else {
              xval = xvalArray[subploti];
              yval = yvalArray[subploti];
            }
            closedataPreviousLength = hoverData.length;
            if (hoverdistance !== 0) {
              if (trace._module && trace._module.hoverPoints) {
                var newPoints = trace._module.hoverPoints(pointData, xval, yval, _mode, {
                  finiteRange: true,
                  hoverLayer: fullLayout._hoverlayer,
                  // options for splom when hovering on same axis
                  hoversubplots,
                  gd
                });
                if (newPoints) {
                  var newPoint;
                  for (var newPointNum = 0; newPointNum < newPoints.length; newPointNum++) {
                    newPoint = newPoints[newPointNum];
                    if (isNumeric(newPoint.x0) && isNumeric(newPoint.y0)) {
                      hoverData.push(cleanPoint(newPoint, hovermode));
                    }
                  }
                }
              } else {
                Lib.log("Unrecognized trace type in hover:", trace);
              }
            }
            if (hovermode === "closest" && hoverData.length > closedataPreviousLength) {
              hoverData.splice(0, closedataPreviousLength);
              distance = hoverData[0].distance;
            }
            if (hasCartesian && spikedistance !== 0) {
              if (hoverData.length === 0) {
                pointData.distance = spikedistance;
                pointData.index = false;
                var closestPoints = trace._module.hoverPoints(pointData, xval, yval, "closest", {
                  hoverLayer: fullLayout._hoverlayer
                });
                if (closestPoints) {
                  closestPoints = closestPoints.filter(function(point) {
                    return point.spikeDistance <= spikedistance;
                  });
                }
                if (closestPoints && closestPoints.length) {
                  var tmpPoint;
                  var closestVPoints = closestPoints.filter(function(point) {
                    return point.xa.showspikes && point.xa.spikesnap !== "hovered data";
                  });
                  if (closestVPoints.length) {
                    var closestVPt = closestVPoints[0];
                    if (isNumeric(closestVPt.x0) && isNumeric(closestVPt.y0)) {
                      tmpPoint = fillSpikePoint(closestVPt);
                      if (!spikePoints.vLinePoint || spikePoints.vLinePoint.spikeDistance > tmpPoint.spikeDistance) {
                        spikePoints.vLinePoint = tmpPoint;
                      }
                    }
                  }
                  var closestHPoints = closestPoints.filter(function(point) {
                    return point.ya.showspikes && point.ya.spikesnap !== "hovered data";
                  });
                  if (closestHPoints.length) {
                    var closestHPt = closestHPoints[0];
                    if (isNumeric(closestHPt.x0) && isNumeric(closestHPt.y0)) {
                      tmpPoint = fillSpikePoint(closestHPt);
                      if (!spikePoints.hLinePoint || spikePoints.hLinePoint.spikeDistance > tmpPoint.spikeDistance) {
                        spikePoints.hLinePoint = tmpPoint;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        findHoverPoints();
        function selectClosestPoint(pointsData, spikedistance2, spikeOnWinning2) {
          var resultPoint = null;
          var minDistance = Infinity;
          var thisSpikeDistance;
          for (var i2 = 0; i2 < pointsData.length; i2++) {
            if (firstXaxis && firstXaxis._id !== pointsData[i2].xa._id) continue;
            if (firstYaxis && firstYaxis._id !== pointsData[i2].ya._id) continue;
            thisSpikeDistance = pointsData[i2].spikeDistance;
            if (spikeOnWinning2 && i2 === 0) thisSpikeDistance = -Infinity;
            if (thisSpikeDistance <= minDistance && thisSpikeDistance <= spikedistance2) {
              resultPoint = pointsData[i2];
              minDistance = thisSpikeDistance;
            }
          }
          return resultPoint;
        }
        function fillSpikePoint(point) {
          if (!point) return null;
          return {
            xa: point.xa,
            ya: point.ya,
            x: point.xSpike !== void 0 ? point.xSpike : (point.x0 + point.x1) / 2,
            y: point.ySpike !== void 0 ? point.ySpike : (point.y0 + point.y1) / 2,
            distance: point.distance,
            spikeDistance: point.spikeDistance,
            curveNumber: point.trace.index,
            color: point.color,
            pointNumber: point.index
          };
        }
        var spikelineOpts = {
          fullLayout,
          container: fullLayout._hoverlayer,
          event: evt
        };
        var oldspikepoints = gd._spikepoints;
        var newspikepoints = {
          vLinePoint: spikePoints.vLinePoint,
          hLinePoint: spikePoints.hLinePoint
        };
        gd._spikepoints = newspikepoints;
        var sortHoverData = function() {
          var hoverDataInSubplot = hoverData.filter(function(a) {
            return firstXaxis && firstXaxis._id === a.xa._id && (firstYaxis && firstYaxis._id === a.ya._id);
          });
          var hoverDataOutSubplot = hoverData.filter(function(a) {
            return !(firstXaxis && firstXaxis._id === a.xa._id && (firstYaxis && firstYaxis._id === a.ya._id));
          });
          hoverDataInSubplot.sort(distanceSort);
          hoverDataOutSubplot.sort(distanceSort);
          hoverData = hoverDataInSubplot.concat(hoverDataOutSubplot);
          hoverData = orderRangePoints(hoverData, hovermode);
        };
        sortHoverData();
        var axLetter = hovermode.charAt(0);
        var spikeOnWinning = (axLetter === "x" || axLetter === "y") && hoverData[0] && cartesianScatterPoints[hoverData[0].trace.type];
        if (hasCartesian && spikedistance !== 0) {
          if (hoverData.length !== 0) {
            var tmpHPointData = hoverData.filter(function(point) {
              return point.ya.showspikes;
            });
            var tmpHPoint = selectClosestPoint(tmpHPointData, spikedistance, spikeOnWinning);
            spikePoints.hLinePoint = fillSpikePoint(tmpHPoint);
            var tmpVPointData = hoverData.filter(function(point) {
              return point.xa.showspikes;
            });
            var tmpVPoint = selectClosestPoint(tmpVPointData, spikedistance, spikeOnWinning);
            spikePoints.vLinePoint = fillSpikePoint(tmpVPoint);
          }
        }
        if (hoverData.length === 0) {
          var result = dragElement.unhoverRaw(gd, evt);
          if (hasCartesian && (spikePoints.hLinePoint !== null || spikePoints.vLinePoint !== null)) {
            if (spikesChanged(oldspikepoints)) {
              createSpikelines(gd, spikePoints, spikelineOpts);
            }
          }
          return result;
        }
        if (hasCartesian) {
          if (spikesChanged(oldspikepoints)) {
            createSpikelines(gd, spikePoints, spikelineOpts);
          }
        }
        if (helpers.isXYhover(_mode) && hoverData[0].length !== 0 && hoverData[0].trace.type !== "splom") {
          var winningPoint = hoverData[0];
          if (multipleHoverPoints[winningPoint.trace.type]) {
            hoverData = hoverData.filter(function(d) {
              return d.trace.index === winningPoint.trace.index;
            });
          } else {
            hoverData = [winningPoint];
          }
          var initLen = hoverData.length;
          var winX = getCoord("x", winningPoint, fullLayout);
          var winY = getCoord("y", winningPoint, fullLayout);
          findHoverPoints(winX, winY);
          var finalPoints = [];
          var seen = {};
          var id = 0;
          var insert = function(newHd) {
            var key = multipleHoverPoints[newHd.trace.type] ? hoverDataKey(newHd) : newHd.trace.index;
            if (!seen[key]) {
              id++;
              seen[key] = id;
              finalPoints.push(newHd);
            } else {
              var oldId = seen[key] - 1;
              var oldHd = finalPoints[oldId];
              if (oldId > 0 && Math.abs(newHd.distance) < Math.abs(oldHd.distance)) {
                finalPoints[oldId] = newHd;
              }
            }
          };
          var k;
          for (k = 0; k < initLen; k++) {
            insert(hoverData[k]);
          }
          for (k = hoverData.length - 1; k > initLen - 1; k--) {
            insert(hoverData[k]);
          }
          hoverData = finalPoints;
          sortHoverData();
        }
        var oldhoverdata = gd._hoverdata;
        var newhoverdata = [];
        var gTop = getTopOffset(gd);
        var gLeft = getLeftOffset(gd);
        for (itemnum = 0; itemnum < hoverData.length; itemnum++) {
          var pt = hoverData[itemnum];
          var eventData = helpers.makeEventData(pt, pt.trace, pt.cd);
          if (pt.hovertemplate !== false) {
            var ht = false;
            if (pt.cd[pt.index] && pt.cd[pt.index].ht) {
              ht = pt.cd[pt.index].ht;
            }
            pt.hovertemplate = ht || pt.trace.hovertemplate || false;
          }
          if (pt.xa && pt.ya) {
            var _x0 = pt.x0 + pt.xa._offset;
            var _x1 = pt.x1 + pt.xa._offset;
            var _y0 = pt.y0 + pt.ya._offset;
            var _y1 = pt.y1 + pt.ya._offset;
            var x0 = Math.min(_x0, _x1);
            var x1 = Math.max(_x0, _x1);
            var y0 = Math.min(_y0, _y1);
            var y1 = Math.max(_y0, _y1);
            eventData.bbox = {
              x0: x0 + gLeft,
              x1: x1 + gLeft,
              y0: y0 + gTop,
              y1: y1 + gTop
            };
          }
          pt.eventData = [eventData];
          newhoverdata.push(eventData);
        }
        gd._hoverdata = newhoverdata;
        var rotateLabels = hovermode === "y" && (searchData.length > 1 || hoverData.length > 1) || hovermode === "closest" && hasOneHorizontalTrace && hoverData.length > 1;
        var bgColor = Color.combine(
          fullLayout.plot_bgcolor || Color.background,
          fullLayout.paper_bgcolor
        );
        var hoverText = createHoverText(hoverData, {
          gd,
          hovermode,
          rotateLabels,
          bgColor,
          container: fullLayout._hoverlayer,
          outerContainer: fullLayout._paper.node(),
          commonLabelOpts: fullLayout.hoverlabel,
          hoverdistance: fullLayout.hoverdistance
        });
        var hoverLabels = hoverText.hoverLabels;
        if (!helpers.isUnifiedHover(hovermode)) {
          hoverAvoidOverlaps(hoverLabels, rotateLabels, fullLayout, hoverText.commonLabelBoundingBox);
          alignHoverText(hoverLabels, rotateLabels, fullLayout._invScaleX, fullLayout._invScaleY);
        }
        if (eventTarget && eventTarget.tagName) {
          var hasClickToShow = Registry.getComponentMethod("annotations", "hasClickToShow")(gd, newhoverdata);
          overrideCursor(d3.select(eventTarget), hasClickToShow ? "pointer" : "");
        }
        if (!eventTarget || noHoverEvent || !hoverChanged(gd, evt, oldhoverdata)) return;
        if (oldhoverdata) {
          gd.emit("plotly_unhover", {
            event: evt,
            points: oldhoverdata
          });
        }
        gd.emit("plotly_hover", {
          event: evt,
          points: gd._hoverdata,
          xaxes: xaArray,
          yaxes: yaArray,
          xvals: xvalArray,
          yvals: yvalArray
        });
      }
      function hoverDataKey(d) {
        return [d.trace.index, d.index, d.x0, d.y0, d.name, d.attr, d.xa ? d.xa._id : "", d.ya ? d.ya._id : ""].join(",");
      }
      var EXTRA_STRING_REGEX = /<extra>([\s\S]*)<\/extra>/;
      function createHoverText(hoverData, opts) {
        var gd = opts.gd;
        var fullLayout = gd._fullLayout;
        var hovermode = opts.hovermode;
        var rotateLabels = opts.rotateLabels;
        var bgColor = opts.bgColor;
        var container = opts.container;
        var outerContainer = opts.outerContainer;
        var commonLabelOpts = opts.commonLabelOpts || {};
        if (hoverData.length === 0) return [[]];
        var fontFamily = opts.fontFamily || constants.HOVERFONT;
        var fontSize = opts.fontSize || constants.HOVERFONTSIZE;
        var fontWeight = opts.fontWeight || fullLayout.font.weight;
        var fontStyle = opts.fontStyle || fullLayout.font.style;
        var fontVariant = opts.fontVariant || fullLayout.font.variant;
        var fontTextcase = opts.fontTextcase || fullLayout.font.textcase;
        var fontLineposition = opts.fontLineposition || fullLayout.font.lineposition;
        var fontShadow = opts.fontShadow || fullLayout.font.shadow;
        var c0 = hoverData[0];
        var xa = c0.xa;
        var ya = c0.ya;
        var axLetter = hovermode.charAt(0);
        var axLabel = axLetter + "Label";
        var t0 = c0[axLabel];
        if (t0 === void 0 && xa.type === "multicategory") {
          for (var q = 0; q < hoverData.length; q++) {
            t0 = hoverData[q][axLabel];
            if (t0 !== void 0) break;
          }
        }
        var outerContainerBB = getBoundingClientRect(gd, outerContainer);
        var outerTop = outerContainerBB.top;
        var outerWidth = outerContainerBB.width;
        var outerHeight = outerContainerBB.height;
        var showCommonLabel = t0 !== void 0 && c0.distance <= opts.hoverdistance && (hovermode === "x" || hovermode === "y");
        if (showCommonLabel) {
          var allHaveZ = true;
          var i, traceHoverinfo;
          for (i = 0; i < hoverData.length; i++) {
            if (allHaveZ && hoverData[i].zLabel === void 0) allHaveZ = false;
            traceHoverinfo = hoverData[i].hoverinfo || hoverData[i].trace.hoverinfo;
            if (traceHoverinfo) {
              var parts = Array.isArray(traceHoverinfo) ? traceHoverinfo : traceHoverinfo.split("+");
              if (parts.indexOf("all") === -1 && parts.indexOf(hovermode) === -1) {
                showCommonLabel = false;
                break;
              }
            }
          }
          if (allHaveZ) showCommonLabel = false;
        }
        var commonLabel = container.selectAll("g.axistext").data(showCommonLabel ? [0] : []);
        commonLabel.enter().append("g").classed("axistext", true);
        commonLabel.exit().remove();
        var commonLabelRect = {
          minX: 0,
          maxX: 0,
          minY: 0,
          maxY: 0
        };
        commonLabel.each(function() {
          var label = d3.select(this);
          var lpath = Lib.ensureSingle(label, "path", "", function(s) {
            s.style({ "stroke-width": "1px" });
          });
          var ltext = Lib.ensureSingle(label, "text", "", function(s) {
            s.attr("data-notex", 1);
          });
          var commonBgColor = commonLabelOpts.bgcolor || Color.defaultLine;
          var commonStroke = commonLabelOpts.bordercolor || Color.contrast(commonBgColor);
          var contrastColor = Color.contrast(commonBgColor);
          var commonLabelOptsFont = commonLabelOpts.font;
          var commonLabelFont = {
            weight: commonLabelOptsFont.weight || fontWeight,
            style: commonLabelOptsFont.style || fontStyle,
            variant: commonLabelOptsFont.variant || fontVariant,
            textcase: commonLabelOptsFont.textcase || fontTextcase,
            lineposition: commonLabelOptsFont.lineposition || fontLineposition,
            shadow: commonLabelOptsFont.shadow || fontShadow,
            family: commonLabelOptsFont.family || fontFamily,
            size: commonLabelOptsFont.size || fontSize,
            color: commonLabelOptsFont.color || contrastColor
          };
          lpath.style({
            fill: commonBgColor,
            stroke: commonStroke
          });
          ltext.text(t0).call(Drawing.font, commonLabelFont).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);
          label.attr("transform", "");
          var tbb2 = getBoundingClientRect(gd, ltext.node());
          var lx2, ly2;
          if (hovermode === "x") {
            var topsign = xa.side === "top" ? "-" : "";
            ltext.attr("text-anchor", "middle").call(svgTextUtils.positionText, 0, xa.side === "top" ? outerTop - tbb2.bottom - HOVERARROWSIZE - HOVERTEXTPAD : outerTop - tbb2.top + HOVERARROWSIZE + HOVERTEXTPAD);
            lx2 = xa._offset + (c0.x0 + c0.x1) / 2;
            ly2 = ya._offset + (xa.side === "top" ? 0 : ya._length);
            var halfWidth = tbb2.width / 2 + HOVERTEXTPAD;
            var tooltipMidX = lx2;
            if (lx2 < halfWidth) {
              tooltipMidX = halfWidth;
            } else if (lx2 > fullLayout.width - halfWidth) {
              tooltipMidX = fullLayout.width - halfWidth;
            }
            lpath.attr("d", "M" + (lx2 - tooltipMidX) + ",0L" + (lx2 - tooltipMidX + HOVERARROWSIZE) + "," + topsign + HOVERARROWSIZE + "H" + halfWidth + "v" + topsign + (HOVERTEXTPAD * 2 + tbb2.height) + "H" + -halfWidth + "V" + topsign + HOVERARROWSIZE + "H" + (lx2 - tooltipMidX - HOVERARROWSIZE) + "Z");
            lx2 = tooltipMidX;
            commonLabelRect.minX = lx2 - halfWidth;
            commonLabelRect.maxX = lx2 + halfWidth;
            if (xa.side === "top") {
              commonLabelRect.minY = ly2 - (HOVERTEXTPAD * 2 + tbb2.height);
              commonLabelRect.maxY = ly2 - HOVERTEXTPAD;
            } else {
              commonLabelRect.minY = ly2 + HOVERTEXTPAD;
              commonLabelRect.maxY = ly2 + (HOVERTEXTPAD * 2 + tbb2.height);
            }
          } else {
            var anchor;
            var sgn;
            var leftsign;
            if (ya.side === "right") {
              anchor = "start";
              sgn = 1;
              leftsign = "";
              lx2 = xa._offset + xa._length;
            } else {
              anchor = "end";
              sgn = -1;
              leftsign = "-";
              lx2 = xa._offset;
            }
            ly2 = ya._offset + (c0.y0 + c0.y1) / 2;
            ltext.attr("text-anchor", anchor);
            lpath.attr("d", "M0,0L" + leftsign + HOVERARROWSIZE + "," + HOVERARROWSIZE + "V" + (HOVERTEXTPAD + tbb2.height / 2) + "h" + leftsign + (HOVERTEXTPAD * 2 + tbb2.width) + "V-" + (HOVERTEXTPAD + tbb2.height / 2) + "H" + leftsign + HOVERARROWSIZE + "V-" + HOVERARROWSIZE + "Z");
            commonLabelRect.minY = ly2 - (HOVERTEXTPAD + tbb2.height / 2);
            commonLabelRect.maxY = ly2 + (HOVERTEXTPAD + tbb2.height / 2);
            if (ya.side === "right") {
              commonLabelRect.minX = lx2 + HOVERARROWSIZE;
              commonLabelRect.maxX = lx2 + HOVERARROWSIZE + (HOVERTEXTPAD * 2 + tbb2.width);
            } else {
              commonLabelRect.minX = lx2 - HOVERARROWSIZE - (HOVERTEXTPAD * 2 + tbb2.width);
              commonLabelRect.maxX = lx2 - HOVERARROWSIZE;
            }
            var halfHeight = tbb2.height / 2;
            var lty = outerTop - tbb2.top - halfHeight;
            var clipId = "clip" + fullLayout._uid + "commonlabel" + ya._id;
            var clipPath;
            if (lx2 < tbb2.width + 2 * HOVERTEXTPAD + HOVERARROWSIZE) {
              clipPath = "M-" + (HOVERARROWSIZE + HOVERTEXTPAD) + "-" + halfHeight + "h-" + (tbb2.width - HOVERTEXTPAD) + "V" + halfHeight + "h" + (tbb2.width - HOVERTEXTPAD) + "Z";
              var ltx = tbb2.width - lx2 + HOVERTEXTPAD;
              svgTextUtils.positionText(ltext, ltx, lty);
              if (anchor === "end") {
                ltext.selectAll("tspan").each(function() {
                  var s = d3.select(this);
                  var dummy = Drawing.tester.append("text").text(s.text()).call(Drawing.font, commonLabelFont);
                  var dummyBB = getBoundingClientRect(gd, dummy.node());
                  if (Math.round(dummyBB.width) < Math.round(tbb2.width)) {
                    s.attr("x", ltx - dummyBB.width);
                  }
                  dummy.remove();
                });
              }
            } else {
              svgTextUtils.positionText(ltext, sgn * (HOVERTEXTPAD + HOVERARROWSIZE), lty);
              clipPath = null;
            }
            var textClip = fullLayout._topclips.selectAll("#" + clipId).data(clipPath ? [0] : []);
            textClip.enter().append("clipPath").attr("id", clipId).append("path");
            textClip.exit().remove();
            textClip.select("path").attr("d", clipPath);
            Drawing.setClipUrl(ltext, clipPath ? clipId : null, gd);
          }
          label.attr("transform", strTranslate(lx2, ly2));
        });
        if (helpers.isUnifiedHover(hovermode)) {
          container.selectAll("g.hovertext").remove();
          var groupedHoverData = hoverData.filter(function(data) {
            return data.hoverinfo !== "none";
          });
          if (groupedHoverData.length === 0) return [];
          var hoverlabel = fullLayout.hoverlabel;
          var font = hoverlabel.font;
          var mockLayoutIn = {
            showlegend: true,
            legend: {
              title: { text: t0, font },
              font,
              bgcolor: hoverlabel.bgcolor,
              bordercolor: hoverlabel.bordercolor,
              borderwidth: 1,
              tracegroupgap: 7,
              traceorder: fullLayout.legend ? fullLayout.legend.traceorder : void 0,
              orientation: "v"
            }
          };
          var mockLayoutOut = {
            font
          };
          legendSupplyDefaults(mockLayoutIn, mockLayoutOut, gd._fullData);
          var mockLegend = mockLayoutOut.legend;
          mockLegend.entries = [];
          for (var j = 0; j < groupedHoverData.length; j++) {
            var pt = groupedHoverData[j];
            if (pt.hoverinfo === "none") continue;
            var texts = getHoverLabelText(pt, true, hovermode, fullLayout, t0);
            var text = texts[0];
            var name = texts[1];
            pt.name = name;
            if (name !== "") {
              pt.text = name + " : " + text;
            } else {
              pt.text = text;
            }
            var cd = pt.cd[pt.index];
            if (cd) {
              if (cd.mc) pt.mc = cd.mc;
              if (cd.mcc) pt.mc = cd.mcc;
              if (cd.mlc) pt.mlc = cd.mlc;
              if (cd.mlcc) pt.mlc = cd.mlcc;
              if (cd.mlw) pt.mlw = cd.mlw;
              if (cd.mrc) pt.mrc = cd.mrc;
              if (cd.dir) pt.dir = cd.dir;
            }
            pt._distinct = true;
            mockLegend.entries.push([pt]);
          }
          mockLegend.entries.sort(function(a, b) {
            return a[0].trace.index - b[0].trace.index;
          });
          mockLegend.layer = container;
          mockLegend._inHover = true;
          mockLegend._groupTitleFont = hoverlabel.grouptitlefont;
          legendDraw(gd, mockLegend);
          var legendContainer = container.select("g.legend");
          var tbb = getBoundingClientRect(gd, legendContainer.node());
          var tWidth = tbb.width + 2 * HOVERTEXTPAD;
          var tHeight = tbb.height + 2 * HOVERTEXTPAD;
          var winningPoint = groupedHoverData[0];
          var avgX = (winningPoint.x0 + winningPoint.x1) / 2;
          var avgY = (winningPoint.y0 + winningPoint.y1) / 2;
          var pointWon = !(Registry.traceIs(winningPoint.trace, "bar-like") || Registry.traceIs(winningPoint.trace, "box-violin"));
          var lyBottom, lyTop;
          if (axLetter === "y") {
            if (pointWon) {
              lyTop = avgY - HOVERTEXTPAD;
              lyBottom = avgY + HOVERTEXTPAD;
            } else {
              lyTop = Math.min.apply(null, groupedHoverData.map(function(c) {
                return Math.min(c.y0, c.y1);
              }));
              lyBottom = Math.max.apply(null, groupedHoverData.map(function(c) {
                return Math.max(c.y0, c.y1);
              }));
            }
          } else {
            lyTop = lyBottom = Lib.mean(groupedHoverData.map(function(c) {
              return (c.y0 + c.y1) / 2;
            })) - tHeight / 2;
          }
          var lxRight, lxLeft;
          if (axLetter === "x") {
            if (pointWon) {
              lxRight = avgX + HOVERTEXTPAD;
              lxLeft = avgX - HOVERTEXTPAD;
            } else {
              lxRight = Math.max.apply(null, groupedHoverData.map(function(c) {
                return Math.max(c.x0, c.x1);
              }));
              lxLeft = Math.min.apply(null, groupedHoverData.map(function(c) {
                return Math.min(c.x0, c.x1);
              }));
            }
          } else {
            lxRight = lxLeft = Lib.mean(groupedHoverData.map(function(c) {
              return (c.x0 + c.x1) / 2;
            })) - tWidth / 2;
          }
          var xOffset = xa._offset;
          var yOffset = ya._offset;
          lyBottom += yOffset;
          lxRight += xOffset;
          lxLeft += xOffset - tWidth;
          lyTop += yOffset - tHeight;
          var lx, ly;
          if (lxRight + tWidth < outerWidth && lxRight >= 0) {
            lx = lxRight;
          } else if (lxLeft + tWidth < outerWidth && lxLeft >= 0) {
            lx = lxLeft;
          } else if (xOffset + tWidth < outerWidth) {
            lx = xOffset;
          } else {
            if (lxRight - avgX < avgX - lxLeft + tWidth) {
              lx = outerWidth - tWidth;
            } else {
              lx = 0;
            }
          }
          lx += HOVERTEXTPAD;
          if (lyBottom + tHeight < outerHeight && lyBottom >= 0) {
            ly = lyBottom;
          } else if (lyTop + tHeight < outerHeight && lyTop >= 0) {
            ly = lyTop;
          } else if (yOffset + tHeight < outerHeight) {
            ly = yOffset;
          } else {
            if (lyBottom - avgY < avgY - lyTop + tHeight) {
              ly = outerHeight - tHeight;
            } else {
              ly = 0;
            }
          }
          ly += HOVERTEXTPAD;
          legendContainer.attr("transform", strTranslate(lx - 1, ly - 1));
          return legendContainer;
        }
        var hoverLabels = container.selectAll("g.hovertext").data(hoverData, function(d) {
          return hoverDataKey(d);
        });
        hoverLabels.enter().append("g").classed("hovertext", true).each(function() {
          var g = d3.select(this);
          g.append("rect").call(Color.fill, Color.addOpacity(bgColor, 0.8));
          g.append("text").classed("name", true);
          g.append("path").style("stroke-width", "1px");
          g.append("text").classed("nums", true).call(Drawing.font, {
            weight: fontWeight,
            style: fontStyle,
            variant: fontVariant,
            textcase: fontTextcase,
            lineposition: fontLineposition,
            shadow: fontShadow,
            family: fontFamily,
            size: fontSize
          });
        });
        hoverLabels.exit().remove();
        hoverLabels.each(function(d) {
          var g = d3.select(this).attr("transform", "");
          var dColor = d.color;
          if (Array.isArray(dColor)) {
            dColor = dColor[d.eventData[0].pointNumber];
          }
          var color0 = d.bgcolor || dColor;
          var numsColor = Color.combine(
            Color.opacity(color0) ? color0 : Color.defaultLine,
            bgColor
          );
          var nameColor = Color.combine(
            Color.opacity(dColor) ? dColor : Color.defaultLine,
            bgColor
          );
          var contrastColor = d.borderColor || Color.contrast(numsColor);
          var texts2 = getHoverLabelText(d, showCommonLabel, hovermode, fullLayout, t0, g);
          var text2 = texts2[0];
          var name2 = texts2[1];
          var tx = g.select("text.nums").call(Drawing.font, {
            family: d.fontFamily || fontFamily,
            size: d.fontSize || fontSize,
            color: d.fontColor || contrastColor,
            weight: d.fontWeight || fontWeight,
            style: d.fontStyle || fontStyle,
            variant: d.fontVariant || fontVariant,
            textcase: d.fontTextcase || fontTextcase,
            lineposition: d.fontLineposition || fontLineposition,
            shadow: d.fontShadow || fontShadow
          }).text(text2).attr("data-notex", 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);
          var tx2 = g.select("text.name");
          var tx2width = 0;
          var tx2height = 0;
          if (name2 && name2 !== text2) {
            tx2.call(Drawing.font, {
              family: d.fontFamily || fontFamily,
              size: d.fontSize || fontSize,
              color: nameColor,
              weight: d.fontWeight || fontWeight,
              style: d.fontStyle || fontStyle,
              variant: d.fontVariant || fontVariant,
              textcase: d.fontTextcase || fontTextcase,
              lineposition: d.fontLineposition || fontLineposition,
              shadow: d.fontShadow || fontShadow
            }).text(name2).attr("data-notex", 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);
            var t2bb = getBoundingClientRect(gd, tx2.node());
            tx2width = t2bb.width + 2 * HOVERTEXTPAD;
            tx2height = t2bb.height + 2 * HOVERTEXTPAD;
          } else {
            tx2.remove();
            g.select("rect").remove();
          }
          g.select("path").style({
            fill: numsColor,
            stroke: contrastColor
          });
          var htx = d.xa._offset + (d.x0 + d.x1) / 2;
          var hty = d.ya._offset + (d.y0 + d.y1) / 2;
          var dx = Math.abs(d.x1 - d.x0);
          var dy = Math.abs(d.y1 - d.y0);
          var tbb2 = getBoundingClientRect(gd, tx.node());
          var tbbWidth = tbb2.width / fullLayout._invScaleX;
          var tbbHeight = tbb2.height / fullLayout._invScaleY;
          d.ty0 = (outerTop - tbb2.top) / fullLayout._invScaleY;
          d.bx = tbbWidth + 2 * HOVERTEXTPAD;
          d.by = Math.max(tbbHeight + 2 * HOVERTEXTPAD, tx2height);
          d.anchor = "start";
          d.txwidth = tbbWidth;
          d.tx2width = tx2width;
          d.offset = 0;
          var txTotalWidth = (tbbWidth + HOVERARROWSIZE + HOVERTEXTPAD + tx2width) * fullLayout._invScaleX;
          var anchorStartOK, anchorEndOK;
          if (rotateLabels) {
            d.pos = htx;
            anchorStartOK = hty + dy / 2 + txTotalWidth <= outerHeight;
            anchorEndOK = hty - dy / 2 - txTotalWidth >= 0;
            if ((d.idealAlign === "top" || !anchorStartOK) && anchorEndOK) {
              hty -= dy / 2;
              d.anchor = "end";
            } else if (anchorStartOK) {
              hty += dy / 2;
              d.anchor = "start";
            } else {
              d.anchor = "middle";
            }
            d.crossPos = hty;
          } else {
            d.pos = hty;
            anchorStartOK = htx + dx / 2 + txTotalWidth <= outerWidth;
            anchorEndOK = htx - dx / 2 - txTotalWidth >= 0;
            if ((d.idealAlign === "left" || !anchorStartOK) && anchorEndOK) {
              htx -= dx / 2;
              d.anchor = "end";
            } else if (anchorStartOK) {
              htx += dx / 2;
              d.anchor = "start";
            } else {
              d.anchor = "middle";
              var txHalfWidth = txTotalWidth / 2;
              var overflowR = htx + txHalfWidth - outerWidth;
              var overflowL = htx - txHalfWidth;
              if (overflowR > 0) htx -= overflowR;
              if (overflowL < 0) htx += -overflowL;
            }
            d.crossPos = htx;
          }
          tx.attr("text-anchor", d.anchor);
          if (tx2width) tx2.attr("text-anchor", d.anchor);
          g.attr("transform", strTranslate(htx, hty) + (rotateLabels ? strRotate(YANGLE) : ""));
        });
        return {
          hoverLabels,
          commonLabelBoundingBox: commonLabelRect
        };
      }
      function getHoverLabelText(d, showCommonLabel, hovermode, fullLayout, t0, g) {
        var name = "";
        var text = "";
        if (d.nameOverride !== void 0) d.name = d.nameOverride;
        if (d.name) {
          if (d.trace._meta) {
            d.name = Lib.templateString(d.name, d.trace._meta);
          }
          name = plainText(d.name, d.nameLength);
        }
        var h0 = hovermode.charAt(0);
        var h1 = h0 === "x" ? "y" : "x";
        if (d.zLabel !== void 0) {
          if (d.xLabel !== void 0) text += "x: " + d.xLabel + "<br>";
          if (d.yLabel !== void 0) text += "y: " + d.yLabel + "<br>";
          if (d.trace.type !== "choropleth" && d.trace.type !== "choroplethmapbox" && d.trace.type !== "choroplethmap") {
            text += (text ? "z: " : "") + d.zLabel;
          }
        } else if (showCommonLabel && d[h0 + "Label"] === t0) {
          text = d[h1 + "Label"] || "";
        } else if (d.xLabel === void 0) {
          if (d.yLabel !== void 0 && d.trace.type !== "scattercarpet") {
            text = d.yLabel;
          }
        } else if (d.yLabel === void 0) text = d.xLabel;
        else text = "(" + d.xLabel + ", " + d.yLabel + ")";
        if ((d.text || d.text === 0) && !Array.isArray(d.text)) {
          text += (text ? "<br>" : "") + d.text;
        }
        if (d.extraText !== void 0) text += (text ? "<br>" : "") + d.extraText;
        if (g && text === "" && !d.hovertemplate) {
          if (name === "") g.remove();
          text = name;
        }
        var hovertemplate = d.hovertemplate || false;
        if (hovertemplate) {
          var labels = d.hovertemplateLabels || d;
          if (d[h0 + "Label"] !== t0) {
            labels[h0 + "other"] = labels[h0 + "Val"];
            labels[h0 + "otherLabel"] = labels[h0 + "Label"];
          }
          text = Lib.hovertemplateString(
            hovertemplate,
            labels,
            fullLayout._d3locale,
            d.eventData[0] || {},
            d.trace._meta
          );
          text = text.replace(EXTRA_STRING_REGEX, function(match, extra) {
            name = plainText(extra, d.nameLength);
            return "";
          });
        }
        return [text, name];
      }
      function hoverAvoidOverlaps(hoverLabels, rotateLabels, fullLayout, commonLabelBoundingBox) {
        var axKey = rotateLabels ? "xa" : "ya";
        var crossAxKey = rotateLabels ? "ya" : "xa";
        var nummoves = 0;
        var axSign = 1;
        var nLabels = hoverLabels.size();
        var pointgroups = new Array(nLabels);
        var k = 0;
        var axisLabelMinX = commonLabelBoundingBox.minX;
        var axisLabelMaxX = commonLabelBoundingBox.maxX;
        var axisLabelMinY = commonLabelBoundingBox.minY;
        var axisLabelMaxY = commonLabelBoundingBox.maxY;
        var pX = function(x) {
          return x * fullLayout._invScaleX;
        };
        var pY = function(y) {
          return y * fullLayout._invScaleY;
        };
        hoverLabels.each(function(d) {
          var ax = d[axKey];
          var crossAx = d[crossAxKey];
          var axIsX = ax._id.charAt(0) === "x";
          var rng = ax.range;
          if (k === 0 && rng && rng[0] > rng[1] !== axIsX) {
            axSign = -1;
          }
          var pmin = 0;
          var pmax = axIsX ? fullLayout.width : fullLayout.height;
          if (fullLayout.hovermode === "x" || fullLayout.hovermode === "y") {
            var offsets = getHoverLabelOffsets(d, rotateLabels);
            var anchor = d.anchor;
            var horzSign = anchor === "end" ? -1 : 1;
            var labelMin;
            var labelMax;
            if (anchor === "middle") {
              labelMin = d.crossPos + (axIsX ? pY(offsets.y - d.by / 2) : pX(d.bx / 2 + d.tx2width / 2));
              labelMax = labelMin + (axIsX ? pY(d.by) : pX(d.bx));
            } else {
              if (axIsX) {
                labelMin = d.crossPos + pY(HOVERARROWSIZE + offsets.y) - pY(d.by / 2 - HOVERARROWSIZE);
                labelMax = labelMin + pY(d.by);
              } else {
                var startX = pX(horzSign * HOVERARROWSIZE + offsets.x);
                var endX = startX + pX(horzSign * d.bx);
                labelMin = d.crossPos + Math.min(startX, endX);
                labelMax = d.crossPos + Math.max(startX, endX);
              }
            }
            if (axIsX) {
              if (axisLabelMinY !== void 0 && axisLabelMaxY !== void 0 && Math.min(labelMax, axisLabelMaxY) - Math.max(labelMin, axisLabelMinY) > 1) {
                if (crossAx.side === "left") {
                  pmin = crossAx._mainLinePosition;
                  pmax = fullLayout.width;
                } else {
                  pmax = crossAx._mainLinePosition;
                }
              }
            } else {
              if (axisLabelMinX !== void 0 && axisLabelMaxX !== void 0 && Math.min(labelMax, axisLabelMaxX) - Math.max(labelMin, axisLabelMinX) > 1) {
                if (crossAx.side === "top") {
                  pmin = crossAx._mainLinePosition;
                  pmax = fullLayout.height;
                } else {
                  pmax = crossAx._mainLinePosition;
                }
              }
            }
          }
          pointgroups[k++] = [{
            datum: d,
            traceIndex: d.trace.index,
            dp: 0,
            pos: d.pos,
            posref: d.posref,
            size: d.by * (axIsX ? YFACTOR : 1) / 2,
            pmin,
            pmax
          }];
        });
        pointgroups.sort(function(a, b) {
          return a[0].posref - b[0].posref || // for equal positions, sort trace indices increasing or decreasing
          // depending on whether the axis is reversed or not... so stacked
          // traces will generally keep their order even if one trace adds
          // nothing to the stack.
          axSign * (b[0].traceIndex - a[0].traceIndex);
        });
        var donepositioning, topOverlap, bottomOverlap, i, j, pti, sumdp;
        function constrainGroup(grp2) {
          var minPt = grp2[0];
          var maxPt = grp2[grp2.length - 1];
          topOverlap = minPt.pmin - minPt.pos - minPt.dp + minPt.size;
          bottomOverlap = maxPt.pos + maxPt.dp + maxPt.size - minPt.pmax;
          if (topOverlap > 0.01) {
            for (j = grp2.length - 1; j >= 0; j--) grp2[j].dp += topOverlap;
            donepositioning = false;
          }
          if (bottomOverlap < 0.01) return;
          if (topOverlap < -0.01) {
            for (j = grp2.length - 1; j >= 0; j--) grp2[j].dp -= bottomOverlap;
            donepositioning = false;
          }
          if (!donepositioning) return;
          var deleteCount = 0;
          for (i = 0; i < grp2.length; i++) {
            pti = grp2[i];
            if (pti.pos + pti.dp + pti.size > minPt.pmax) deleteCount++;
          }
          for (i = grp2.length - 1; i >= 0; i--) {
            if (deleteCount <= 0) break;
            pti = grp2[i];
            if (pti.pos > minPt.pmax - 1) {
              pti.del = true;
              deleteCount--;
            }
          }
          for (i = 0; i < grp2.length; i++) {
            if (deleteCount <= 0) break;
            pti = grp2[i];
            if (pti.pos < minPt.pmin + 1) {
              pti.del = true;
              deleteCount--;
              bottomOverlap = pti.size * 2;
              for (j = grp2.length - 1; j >= 0; j--) grp2[j].dp -= bottomOverlap;
            }
          }
          for (i = grp2.length - 1; i >= 0; i--) {
            if (deleteCount <= 0) break;
            pti = grp2[i];
            if (pti.pos + pti.dp + pti.size > minPt.pmax) {
              pti.del = true;
              deleteCount--;
            }
          }
        }
        while (!donepositioning && nummoves <= nLabels) {
          nummoves++;
          donepositioning = true;
          i = 0;
          while (i < pointgroups.length - 1) {
            var g0 = pointgroups[i];
            var g1 = pointgroups[i + 1];
            var p0 = g0[g0.length - 1];
            var p1 = g1[0];
            topOverlap = p0.pos + p0.dp + p0.size - p1.pos - p1.dp + p1.size;
            if (topOverlap > 0.01) {
              for (j = g1.length - 1; j >= 0; j--) g1[j].dp += topOverlap;
              g0.push.apply(g0, g1);
              pointgroups.splice(i + 1, 1);
              sumdp = 0;
              for (j = g0.length - 1; j >= 0; j--) sumdp += g0[j].dp;
              bottomOverlap = sumdp / g0.length;
              for (j = g0.length - 1; j >= 0; j--) g0[j].dp -= bottomOverlap;
              donepositioning = false;
            } else i++;
          }
          pointgroups.forEach(constrainGroup);
        }
        for (i = pointgroups.length - 1; i >= 0; i--) {
          var grp = pointgroups[i];
          for (j = grp.length - 1; j >= 0; j--) {
            var pt = grp[j];
            var hoverPt = pt.datum;
            hoverPt.offset = pt.dp;
            hoverPt.del = pt.del;
          }
        }
      }
      function getHoverLabelOffsets(hoverLabel, rotateLabels) {
        var offsetX = 0;
        var offsetY = hoverLabel.offset;
        if (rotateLabels) {
          offsetY *= -YSHIFTY;
          offsetX = hoverLabel.offset * YSHIFTX;
        }
        return {
          x: offsetX,
          y: offsetY
        };
      }
      function getTextShiftX(hoverLabel) {
        var alignShift = { start: 1, end: -1, middle: 0 }[hoverLabel.anchor];
        var textShiftX = alignShift * (HOVERARROWSIZE + HOVERTEXTPAD);
        var text2ShiftX = textShiftX + alignShift * (hoverLabel.txwidth + HOVERTEXTPAD);
        var isMiddle = hoverLabel.anchor === "middle";
        if (isMiddle) {
          textShiftX -= hoverLabel.tx2width / 2;
          text2ShiftX += hoverLabel.txwidth / 2 + HOVERTEXTPAD;
        }
        return {
          alignShift,
          textShiftX,
          text2ShiftX
        };
      }
      function alignHoverText(hoverLabels, rotateLabels, scaleX, scaleY) {
        var pX = function(x) {
          return x * scaleX;
        };
        var pY = function(y) {
          return y * scaleY;
        };
        hoverLabels.each(function(d) {
          var g = d3.select(this);
          if (d.del) return g.remove();
          var tx = g.select("text.nums");
          var anchor = d.anchor;
          var horzSign = anchor === "end" ? -1 : 1;
          var shiftX = getTextShiftX(d);
          var offsets = getHoverLabelOffsets(d, rotateLabels);
          var offsetX = offsets.x;
          var offsetY = offsets.y;
          var isMiddle = anchor === "middle";
          g.select("path").attr("d", isMiddle ? (
            // middle aligned: rect centered on data
            "M-" + pX(d.bx / 2 + d.tx2width / 2) + "," + pY(offsetY - d.by / 2) + "h" + pX(d.bx) + "v" + pY(d.by) + "h-" + pX(d.bx) + "Z"
          ) : (
            // left or right aligned: side rect with arrow to data
            "M0,0L" + pX(horzSign * HOVERARROWSIZE + offsetX) + "," + pY(HOVERARROWSIZE + offsetY) + "v" + pY(d.by / 2 - HOVERARROWSIZE) + "h" + pX(horzSign * d.bx) + "v-" + pY(d.by) + "H" + pX(horzSign * HOVERARROWSIZE + offsetX) + "V" + pY(offsetY - HOVERARROWSIZE) + "Z"
          ));
          var posX = offsetX + shiftX.textShiftX;
          var posY = offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD;
          var textAlign = d.textAlign || "auto";
          if (textAlign !== "auto") {
            if (textAlign === "left" && anchor !== "start") {
              tx.attr("text-anchor", "start");
              posX = isMiddle ? -d.bx / 2 - d.tx2width / 2 + HOVERTEXTPAD : -d.bx - HOVERTEXTPAD;
            } else if (textAlign === "right" && anchor !== "end") {
              tx.attr("text-anchor", "end");
              posX = isMiddle ? d.bx / 2 - d.tx2width / 2 - HOVERTEXTPAD : d.bx + HOVERTEXTPAD;
            }
          }
          tx.call(svgTextUtils.positionText, pX(posX), pY(posY));
          if (d.tx2width) {
            g.select("text.name").call(
              svgTextUtils.positionText,
              pX(shiftX.text2ShiftX + shiftX.alignShift * HOVERTEXTPAD + offsetX),
              pY(offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD)
            );
            g.select("rect").call(
              Drawing.setRect,
              pX(shiftX.text2ShiftX + (shiftX.alignShift - 1) * d.tx2width / 2 + offsetX),
              pY(offsetY - d.by / 2 - 1),
              pX(d.tx2width),
              pY(d.by + 2)
            );
          }
        });
      }
      function cleanPoint(d, hovermode) {
        var index = d.index;
        var trace = d.trace || {};
        var cd0 = d.cd[0];
        var cd = d.cd[index] || {};
        function pass(v) {
          return v || isNumeric(v) && v === 0;
        }
        var getVal = Array.isArray(index) ? function(calcKey, traceKey) {
          var v = Lib.castOption(cd0, index, calcKey);
          return pass(v) ? v : Lib.extractOption({}, trace, "", traceKey);
        } : function(calcKey, traceKey) {
          return Lib.extractOption(cd, trace, calcKey, traceKey);
        };
        function fill(key, calcKey, traceKey) {
          var val = getVal(calcKey, traceKey);
          if (pass(val)) d[key] = val;
        }
        fill("hoverinfo", "hi", "hoverinfo");
        fill("bgcolor", "hbg", "hoverlabel.bgcolor");
        fill("borderColor", "hbc", "hoverlabel.bordercolor");
        fill("fontFamily", "htf", "hoverlabel.font.family");
        fill("fontSize", "hts", "hoverlabel.font.size");
        fill("fontColor", "htc", "hoverlabel.font.color");
        fill("fontWeight", "htw", "hoverlabel.font.weight");
        fill("fontStyle", "hty", "hoverlabel.font.style");
        fill("fontVariant", "htv", "hoverlabel.font.variant");
        fill("nameLength", "hnl", "hoverlabel.namelength");
        fill("textAlign", "hta", "hoverlabel.align");
        d.posref = hovermode === "y" || hovermode === "closest" && trace.orientation === "h" ? d.xa._offset + (d.x0 + d.x1) / 2 : d.ya._offset + (d.y0 + d.y1) / 2;
        d.x0 = Lib.constrain(d.x0, 0, d.xa._length);
        d.x1 = Lib.constrain(d.x1, 0, d.xa._length);
        d.y0 = Lib.constrain(d.y0, 0, d.ya._length);
        d.y1 = Lib.constrain(d.y1, 0, d.ya._length);
        if (d.xLabelVal !== void 0) {
          d.xLabel = "xLabel" in d ? d.xLabel : Axes.hoverLabelText(d.xa, d.xLabelVal, trace.xhoverformat);
          d.xVal = d.xa.c2d(d.xLabelVal);
        }
        if (d.yLabelVal !== void 0) {
          d.yLabel = "yLabel" in d ? d.yLabel : Axes.hoverLabelText(d.ya, d.yLabelVal, trace.yhoverformat);
          d.yVal = d.ya.c2d(d.yLabelVal);
        }
        if (d.zLabelVal !== void 0 && d.zLabel === void 0) {
          d.zLabel = String(d.zLabelVal);
        }
        if (!isNaN(d.xerr) && !(d.xa.type === "log" && d.xerr <= 0)) {
          var xeText = Axes.tickText(d.xa, d.xa.c2l(d.xerr), "hover").text;
          if (d.xerrneg !== void 0) {
            d.xLabel += " +" + xeText + " / -" + Axes.tickText(d.xa, d.xa.c2l(d.xerrneg), "hover").text;
          } else d.xLabel += " \xB1 " + xeText;
          if (hovermode === "x") d.distance += 1;
        }
        if (!isNaN(d.yerr) && !(d.ya.type === "log" && d.yerr <= 0)) {
          var yeText = Axes.tickText(d.ya, d.ya.c2l(d.yerr), "hover").text;
          if (d.yerrneg !== void 0) {
            d.yLabel += " +" + yeText + " / -" + Axes.tickText(d.ya, d.ya.c2l(d.yerrneg), "hover").text;
          } else d.yLabel += " \xB1 " + yeText;
          if (hovermode === "y") d.distance += 1;
        }
        var infomode = d.hoverinfo || d.trace.hoverinfo;
        if (infomode && infomode !== "all") {
          infomode = Array.isArray(infomode) ? infomode : infomode.split("+");
          if (infomode.indexOf("x") === -1) d.xLabel = void 0;
          if (infomode.indexOf("y") === -1) d.yLabel = void 0;
          if (infomode.indexOf("z") === -1) d.zLabel = void 0;
          if (infomode.indexOf("text") === -1) d.text = void 0;
          if (infomode.indexOf("name") === -1) d.name = void 0;
        }
        return d;
      }
      function createSpikelines(gd, closestPoints, opts) {
        var container = opts.container;
        var fullLayout = opts.fullLayout;
        var gs = fullLayout._size;
        var evt = opts.event;
        var showY = !!closestPoints.hLinePoint;
        var showX = !!closestPoints.vLinePoint;
        var xa, ya;
        container.selectAll(".spikeline").remove();
        if (!(showX || showY)) return;
        var contrastColor = Color.combine(fullLayout.plot_bgcolor, fullLayout.paper_bgcolor);
        if (showY) {
          var hLinePoint = closestPoints.hLinePoint;
          var hLinePointX, hLinePointY;
          xa = hLinePoint && hLinePoint.xa;
          ya = hLinePoint && hLinePoint.ya;
          var ySnap = ya.spikesnap;
          if (ySnap === "cursor") {
            hLinePointX = evt.pointerX;
            hLinePointY = evt.pointerY;
          } else {
            hLinePointX = xa._offset + hLinePoint.x;
            hLinePointY = ya._offset + hLinePoint.y;
          }
          var dfltHLineColor = tinycolor.readability(hLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : hLinePoint.color;
          var yMode = ya.spikemode;
          var yThickness = ya.spikethickness;
          var yColor = ya.spikecolor || dfltHLineColor;
          var xEdge = Axes.getPxPosition(gd, ya);
          var xBase, xEndSpike;
          if (yMode.indexOf("toaxis") !== -1 || yMode.indexOf("across") !== -1) {
            if (yMode.indexOf("toaxis") !== -1) {
              xBase = xEdge;
              xEndSpike = hLinePointX;
            }
            if (yMode.indexOf("across") !== -1) {
              var xAcross0 = ya._counterDomainMin;
              var xAcross1 = ya._counterDomainMax;
              if (ya.anchor === "free") {
                xAcross0 = Math.min(xAcross0, ya.position);
                xAcross1 = Math.max(xAcross1, ya.position);
              }
              xBase = gs.l + xAcross0 * gs.w;
              xEndSpike = gs.l + xAcross1 * gs.w;
            }
            container.insert("line", ":first-child").attr({
              x1: xBase,
              x2: xEndSpike,
              y1: hLinePointY,
              y2: hLinePointY,
              "stroke-width": yThickness,
              stroke: yColor,
              "stroke-dasharray": Drawing.dashStyle(ya.spikedash, yThickness)
            }).classed("spikeline", true).classed("crisp", true);
            container.insert("line", ":first-child").attr({
              x1: xBase,
              x2: xEndSpike,
              y1: hLinePointY,
              y2: hLinePointY,
              "stroke-width": yThickness + 2,
              stroke: contrastColor
            }).classed("spikeline", true).classed("crisp", true);
          }
          if (yMode.indexOf("marker") !== -1) {
            container.insert("circle", ":first-child").attr({
              cx: xEdge + (ya.side !== "right" ? yThickness : -yThickness),
              cy: hLinePointY,
              r: yThickness,
              fill: yColor
            }).classed("spikeline", true);
          }
        }
        if (showX) {
          var vLinePoint = closestPoints.vLinePoint;
          var vLinePointX, vLinePointY;
          xa = vLinePoint && vLinePoint.xa;
          ya = vLinePoint && vLinePoint.ya;
          var xSnap = xa.spikesnap;
          if (xSnap === "cursor") {
            vLinePointX = evt.pointerX;
            vLinePointY = evt.pointerY;
          } else {
            vLinePointX = xa._offset + vLinePoint.x;
            vLinePointY = ya._offset + vLinePoint.y;
          }
          var dfltVLineColor = tinycolor.readability(vLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : vLinePoint.color;
          var xMode = xa.spikemode;
          var xThickness = xa.spikethickness;
          var xColor = xa.spikecolor || dfltVLineColor;
          var yEdge = Axes.getPxPosition(gd, xa);
          var yBase, yEndSpike;
          if (xMode.indexOf("toaxis") !== -1 || xMode.indexOf("across") !== -1) {
            if (xMode.indexOf("toaxis") !== -1) {
              yBase = yEdge;
              yEndSpike = vLinePointY;
            }
            if (xMode.indexOf("across") !== -1) {
              var yAcross0 = xa._counterDomainMin;
              var yAcross1 = xa._counterDomainMax;
              if (xa.anchor === "free") {
                yAcross0 = Math.min(yAcross0, xa.position);
                yAcross1 = Math.max(yAcross1, xa.position);
              }
              yBase = gs.t + (1 - yAcross1) * gs.h;
              yEndSpike = gs.t + (1 - yAcross0) * gs.h;
            }
            container.insert("line", ":first-child").attr({
              x1: vLinePointX,
              x2: vLinePointX,
              y1: yBase,
              y2: yEndSpike,
              "stroke-width": xThickness,
              stroke: xColor,
              "stroke-dasharray": Drawing.dashStyle(xa.spikedash, xThickness)
            }).classed("spikeline", true).classed("crisp", true);
            container.insert("line", ":first-child").attr({
              x1: vLinePointX,
              x2: vLinePointX,
              y1: yBase,
              y2: yEndSpike,
              "stroke-width": xThickness + 2,
              stroke: contrastColor
            }).classed("spikeline", true).classed("crisp", true);
          }
          if (xMode.indexOf("marker") !== -1) {
            container.insert("circle", ":first-child").attr({
              cx: vLinePointX,
              cy: yEdge - (xa.side !== "top" ? xThickness : -xThickness),
              r: xThickness,
              fill: xColor
            }).classed("spikeline", true);
          }
        }
      }
      function hoverChanged(gd, evt, oldhoverdata) {
        if (!oldhoverdata || oldhoverdata.length !== gd._hoverdata.length) return true;
        for (var i = oldhoverdata.length - 1; i >= 0; i--) {
          var oldPt = oldhoverdata[i];
          var newPt = gd._hoverdata[i];
          if (oldPt.curveNumber !== newPt.curveNumber || String(oldPt.pointNumber) !== String(newPt.pointNumber) || String(oldPt.pointNumbers) !== String(newPt.pointNumbers)) {
            return true;
          }
        }
        return false;
      }
      function spikesChanged(gd, oldspikepoints) {
        if (!oldspikepoints) return true;
        if (oldspikepoints.vLinePoint !== gd._spikepoints.vLinePoint || oldspikepoints.hLinePoint !== gd._spikepoints.hLinePoint) return true;
        return false;
      }
      function plainText(s, len) {
        return svgTextUtils.plainText(s || "", {
          len,
          allowedTags: ["br", "sub", "sup", "b", "i", "em", "s", "u"]
        });
      }
      function orderRangePoints(hoverData, hovermode) {
        var axLetter = hovermode.charAt(0);
        var first = [];
        var second = [];
        var last = [];
        for (var i = 0; i < hoverData.length; i++) {
          var d = hoverData[i];
          if (Registry.traceIs(d.trace, "bar-like") || Registry.traceIs(d.trace, "box-violin")) {
            last.push(d);
          } else if (d.trace[axLetter + "period"]) {
            second.push(d);
          } else {
            first.push(d);
          }
        }
        return first.concat(second).concat(last);
      }
      function getCoord(axLetter, winningPoint, fullLayout) {
        var ax = winningPoint[axLetter + "a"];
        var val = winningPoint[axLetter + "Val"];
        var cd0 = winningPoint.cd[0];
        if (ax.type === "category" || ax.type === "multicategory") val = ax._categoriesMap[val];
        else if (ax.type === "date") {
          var periodalignment = winningPoint.trace[axLetter + "periodalignment"];
          if (periodalignment) {
            var d = winningPoint.cd[winningPoint.index];
            var start = d[axLetter + "Start"];
            if (start === void 0) start = d[axLetter];
            var end = d[axLetter + "End"];
            if (end === void 0) end = d[axLetter];
            var diff = end - start;
            if (periodalignment === "end") {
              val += diff;
            } else if (periodalignment === "middle") {
              val += diff / 2;
            }
          }
          val = ax.d2c(val);
        }
        if (cd0 && cd0.t && cd0.t.posLetter === ax._id) {
          if (fullLayout.boxmode === "group" || fullLayout.violinmode === "group") {
            val += cd0.t.dPos;
          }
        }
        return val;
      }
      function getTopOffset(gd) {
        return gd.offsetTop + gd.clientTop;
      }
      function getLeftOffset(gd) {
        return gd.offsetLeft + gd.clientLeft;
      }
      function getBoundingClientRect(gd, node) {
        var fullLayout = gd._fullLayout;
        var rect = node.getBoundingClientRect();
        var x0 = rect.left;
        var y0 = rect.top;
        var x1 = x0 + rect.width;
        var y1 = y0 + rect.height;
        var A = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);
        var B = Lib.apply3DTransform(fullLayout._invTransform)(x1, y1);
        var Ax = A[0];
        var Ay = A[1];
        var Bx = B[0];
        var By = B[1];
        return {
          x: Ax,
          y: Ay,
          width: Bx - Ax,
          height: By - Ay,
          top: Math.min(Ay, By),
          left: Math.min(Ax, Bx),
          right: Math.max(Ax, Bx),
          bottom: Math.max(Ay, By)
        };
      }
    }
  });

  // src/components/fx/hoverlabel_defaults.js
  var require_hoverlabel_defaults = __commonJS({
    "src/components/fx/hoverlabel_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Color = require_color();
      var isUnifiedHover = require_helpers2().isUnifiedHover;
      module.exports = function handleHoverLabelDefaults(contIn, contOut, coerce, opts) {
        opts = opts || {};
        var hasLegend = contOut.legend;
        function inheritFontAttr(attr) {
          if (!opts.font[attr]) {
            opts.font[attr] = hasLegend ? contOut.legend.font[attr] : contOut.font[attr];
          }
        }
        if (contOut && isUnifiedHover(contOut.hovermode)) {
          if (!opts.font) opts.font = {};
          inheritFontAttr("size");
          inheritFontAttr("family");
          inheritFontAttr("color");
          inheritFontAttr("weight");
          inheritFontAttr("style");
          inheritFontAttr("variant");
          if (hasLegend) {
            if (!opts.bgcolor) opts.bgcolor = Color.combine(contOut.legend.bgcolor, contOut.paper_bgcolor);
            if (!opts.bordercolor) opts.bordercolor = contOut.legend.bordercolor;
          } else {
            if (!opts.bgcolor) opts.bgcolor = contOut.paper_bgcolor;
          }
        }
        coerce("hoverlabel.bgcolor", opts.bgcolor);
        coerce("hoverlabel.bordercolor", opts.bordercolor);
        coerce("hoverlabel.namelength", opts.namelength);
        Lib.coerceFont(coerce, "hoverlabel.font", opts.font);
        coerce("hoverlabel.align", opts.align);
      };
    }
  });

  // src/components/fx/layout_global_defaults.js
  var require_layout_global_defaults = __commonJS({
    "src/components/fx/layout_global_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleHoverLabelDefaults = require_hoverlabel_defaults();
      var layoutAttributes = require_layout_attributes();
      module.exports = function supplyLayoutGlobalDefaults(layoutIn, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
        }
        handleHoverLabelDefaults(layoutIn, layoutOut, coerce);
      };
    }
  });

  // src/components/fx/defaults.js
  var require_defaults4 = __commonJS({
    "src/components/fx/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var attributes = require_attributes();
      var handleHoverLabelDefaults = require_hoverlabel_defaults();
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        var opts = Lib.extendFlat({}, layout.hoverlabel);
        if (traceOut.hovertemplate) opts.namelength = -1;
        handleHoverLabelDefaults(traceIn, traceOut, coerce, opts);
      };
    }
  });

  // src/components/fx/hovermode_defaults.js
  var require_hovermode_defaults = __commonJS({
    "src/components/fx/hovermode_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var layoutAttributes = require_layout_attributes();
      module.exports = function handleHoverModeDefaults(layoutIn, layoutOut) {
        function coerce(attr, dflt) {
          if (layoutOut[attr] !== void 0) return layoutOut[attr];
          return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
        }
        coerce("clickmode");
        coerce("hoversubplots");
        return coerce("hovermode");
      };
    }
  });

  // src/components/fx/layout_defaults.js
  var require_layout_defaults2 = __commonJS({
    "src/components/fx/layout_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var layoutAttributes = require_layout_attributes();
      var handleHoverModeDefaults = require_hovermode_defaults();
      var handleHoverLabelDefaults = require_hoverlabel_defaults();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
        }
        var hoverMode = handleHoverModeDefaults(layoutIn, layoutOut);
        if (hoverMode) {
          coerce("hoverdistance");
          coerce("spikedistance");
        }
        var dragMode = coerce("dragmode");
        if (dragMode === "select") coerce("selectdirection");
        var hasMapbox = layoutOut._has("mapbox");
        var hasMap = layoutOut._has("map");
        var hasGeo = layoutOut._has("geo");
        var len = layoutOut._basePlotModules.length;
        if (layoutOut.dragmode === "zoom" && ((hasMapbox || hasMap || hasGeo) && len === 1 || (hasMapbox || hasMap) && hasGeo && len === 2)) {
          layoutOut.dragmode = "pan";
        }
        handleHoverLabelDefaults(layoutIn, layoutOut, coerce);
        Lib.coerceFont(coerce, "hoverlabel.grouptitlefont", layoutOut.hoverlabel.font);
      };
    }
  });

  // src/components/fx/calc.js
  var require_calc2 = __commonJS({
    "src/components/fx/calc.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Registry = require_registry();
      module.exports = function calc(gd) {
        var calcdata = gd.calcdata;
        var fullLayout = gd._fullLayout;
        function makeCoerceHoverInfo(trace2) {
          return function(val) {
            return Lib.coerceHoverinfo({ hoverinfo: val }, { _module: trace2._module }, fullLayout);
          };
        }
        for (var i = 0; i < calcdata.length; i++) {
          var cd = calcdata[i];
          var trace = cd[0].trace;
          if (Registry.traceIs(trace, "pie-like")) continue;
          var fillFn = Registry.traceIs(trace, "2dMap") ? paste : Lib.fillArray;
          fillFn(trace.hoverinfo, cd, "hi", makeCoerceHoverInfo(trace));
          if (trace.hovertemplate) fillFn(trace.hovertemplate, cd, "ht");
          if (!trace.hoverlabel) continue;
          fillFn(trace.hoverlabel.bgcolor, cd, "hbg");
          fillFn(trace.hoverlabel.bordercolor, cd, "hbc");
          fillFn(trace.hoverlabel.font.size, cd, "hts");
          fillFn(trace.hoverlabel.font.color, cd, "htc");
          fillFn(trace.hoverlabel.font.family, cd, "htf");
          fillFn(trace.hoverlabel.font.weight, cd, "htw");
          fillFn(trace.hoverlabel.font.style, cd, "hty");
          fillFn(trace.hoverlabel.font.variant, cd, "htv");
          fillFn(trace.hoverlabel.namelength, cd, "hnl");
          fillFn(trace.hoverlabel.align, cd, "hta");
        }
      };
      function paste(traceAttr, cd, cdAttr, fn) {
        fn = fn || Lib.identity;
        if (Array.isArray(traceAttr)) {
          cd[0][cdAttr] = fn(traceAttr);
        }
      }
    }
  });

  // src/components/fx/click.js
  var require_click = __commonJS({
    "src/components/fx/click.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var hover = require_hover().hover;
      module.exports = function click(gd, evt, subplot) {
        var annotationsDone = Registry.getComponentMethod("annotations", "onClick")(gd, gd._hoverdata);
        if (subplot !== void 0) {
          hover(gd, evt, subplot, true);
        }
        function emitClick() {
          gd.emit("plotly_click", { points: gd._hoverdata, event: evt });
        }
        if (gd._hoverdata && evt && evt.target) {
          if (annotationsDone && annotationsDone.then) {
            annotationsDone.then(emitClick);
          } else emitClick();
          if (evt.stopImmediatePropagation) evt.stopImmediatePropagation();
        }
      };
    }
  });

  // src/components/fx/index.js
  var require_fx = __commonJS({
    "src/components/fx/index.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var dragElement = require_dragelement();
      var helpers = require_helpers2();
      var layoutAttributes = require_layout_attributes();
      var hoverModule = require_hover();
      module.exports = {
        moduleType: "component",
        name: "fx",
        constants: require_constants(),
        schema: {
          layout: layoutAttributes
        },
        attributes: require_attributes(),
        layoutAttributes,
        supplyLayoutGlobalDefaults: require_layout_global_defaults(),
        supplyDefaults: require_defaults4(),
        supplyLayoutDefaults: require_layout_defaults2(),
        calc: require_calc2(),
        getDistanceFunction: helpers.getDistanceFunction,
        getClosest: helpers.getClosest,
        inbox: helpers.inbox,
        quadrature: helpers.quadrature,
        appendArrayPointValue: helpers.appendArrayPointValue,
        castHoverOption,
        castHoverinfo,
        hover: hoverModule.hover,
        unhover: dragElement.unhover,
        loneHover: hoverModule.loneHover,
        loneUnhover,
        click: require_click()
      };
      function loneUnhover(containerOrSelection) {
        var selection = Lib.isD3Selection(containerOrSelection) ? containerOrSelection : d3.select(containerOrSelection);
        selection.selectAll("g.hovertext").remove();
        selection.selectAll(".spikeline").remove();
      }
      function castHoverOption(trace, ptNumber, attr) {
        return Lib.castOption(trace, ptNumber, "hoverlabel." + attr);
      }
      function castHoverinfo(trace, fullLayout, ptNumber) {
        function _coerce(val) {
          return Lib.coerceHoverinfo({ hoverinfo: val }, { _module: trace._module }, fullLayout);
        }
        return Lib.castOption(trace, ptNumber, "hoverinfo", _coerce);
      }
    }
  });

  // src/components/dragelement/helpers.js
  var require_helpers5 = __commonJS({
    "src/components/dragelement/helpers.js"(exports) {
      "use strict";
      exports.selectMode = function(dragmode) {
        return dragmode === "lasso" || dragmode === "select";
      };
      exports.drawMode = function(dragmode) {
        return dragmode === "drawclosedpath" || dragmode === "drawopenpath" || dragmode === "drawline" || dragmode === "drawrect" || dragmode === "drawcircle";
      };
      exports.openMode = function(dragmode) {
        return dragmode === "drawline" || dragmode === "drawopenpath";
      };
      exports.rectMode = function(dragmode) {
        return dragmode === "select" || dragmode === "drawline" || dragmode === "drawrect" || dragmode === "drawcircle";
      };
      exports.freeMode = function(dragmode) {
        return dragmode === "lasso" || dragmode === "drawclosedpath" || dragmode === "drawopenpath";
      };
      exports.selectingOrDrawing = function(dragmode) {
        return exports.freeMode(dragmode) || exports.rectMode(dragmode);
      };
    }
  });

  // src/lib/clear_gl_canvases.js
  var require_clear_gl_canvases = __commonJS({
    "src/lib/clear_gl_canvases.js"(exports, module) {
      "use strict";
      module.exports = function clearGlCanvases(gd) {
        var fullLayout = gd._fullLayout;
        if (fullLayout._glcanvas && fullLayout._glcanvas.size()) {
          fullLayout._glcanvas.each(function(d) {
            if (d.regl) d.regl.clear({ color: true, depth: true });
          });
        }
      };
    }
  });

  // src/fonts/ploticon.js
  var require_ploticon = __commonJS({
    "src/fonts/ploticon.js"(exports, module) {
      "use strict";
      module.exports = {
        undo: {
          width: 857.1,
          height: 1e3,
          path: "m857 350q0-87-34-166t-91-137-137-92-166-34q-96 0-183 41t-147 114q-4 6-4 13t5 11l76 77q6 5 14 5 9-1 13-7 41-53 100-82t126-29q58 0 110 23t92 61 61 91 22 111-22 111-61 91-92 61-110 23q-55 0-105-20t-90-57l77-77q17-16 8-38-10-23-33-23h-250q-15 0-25 11t-11 25v250q0 24 22 33 22 10 39-8l72-72q60 57 137 88t159 31q87 0 166-34t137-92 91-137 34-166z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        home: {
          width: 928.6,
          height: 1e3,
          path: "m786 296v-267q0-15-11-26t-25-10h-214v214h-143v-214h-214q-15 0-25 10t-11 26v267q0 1 0 2t0 2l321 264 321-264q1-1 1-4z m124 39l-34-41q-5-5-12-6h-2q-7 0-12 3l-386 322-386-322q-7-4-13-4-7 2-12 7l-35 41q-4 5-3 13t6 12l401 334q18 15 42 15t43-15l136-114v109q0 8 5 13t13 5h107q8 0 13-5t5-13v-227l122-102q5-5 6-12t-4-13z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        "camera-retro": {
          width: 1e3,
          height: 1e3,
          path: "m518 386q0 8-5 13t-13 5q-37 0-63-27t-26-63q0-8 5-13t13-5 12 5 5 13q0 23 16 38t38 16q8 0 13 5t5 13z m125-73q0-59-42-101t-101-42-101 42-42 101 42 101 101 42 101-42 42-101z m-572-320h858v71h-858v-71z m643 320q0 89-62 152t-152 62-151-62-63-152 63-151 151-63 152 63 62 151z m-571 358h214v72h-214v-72z m-72-107h858v143h-462l-36-71h-360v-72z m929 143v-714q0-30-21-51t-50-21h-858q-29 0-50 21t-21 51v714q0 30 21 51t50 21h858q29 0 50-21t21-51z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        zoombox: {
          width: 1e3,
          height: 1e3,
          path: "m1000-25l-250 251c40 63 63 138 63 218 0 224-182 406-407 406-224 0-406-182-406-406s183-406 407-406c80 0 155 22 218 62l250-250 125 125z m-812 250l0 438 437 0 0-438-437 0z m62 375l313 0 0-312-313 0 0 312z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        pan: {
          width: 1e3,
          height: 1e3,
          path: "m1000 350l-187 188 0-125-250 0 0 250 125 0-188 187-187-187 125 0 0-250-250 0 0 125-188-188 186-187 0 125 252 0 0-250-125 0 187-188 188 188-125 0 0 250 250 0 0-126 187 188z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        zoom_plus: {
          width: 875,
          height: 1e3,
          path: "m1 787l0-875 875 0 0 875-875 0z m687-500l-187 0 0-187-125 0 0 187-188 0 0 125 188 0 0 187 125 0 0-187 187 0 0-125z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        zoom_minus: {
          width: 875,
          height: 1e3,
          path: "m0 788l0-876 875 0 0 876-875 0z m688-500l-500 0 0 125 500 0 0-125z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        autoscale: {
          width: 1e3,
          height: 1e3,
          path: "m250 850l-187 0-63 0 0-62 0-188 63 0 0 188 187 0 0 62z m688 0l-188 0 0-62 188 0 0-188 62 0 0 188 0 62-62 0z m-875-938l0 188-63 0 0-188 0-62 63 0 187 0 0 62-187 0z m875 188l0-188-188 0 0-62 188 0 62 0 0 62 0 188-62 0z m-125 188l-1 0-93-94-156 156 156 156 92-93 2 0 0 250-250 0 0-2 93-92-156-156-156 156 94 92 0 2-250 0 0-250 0 0 93 93 157-156-157-156-93 94 0 0 0-250 250 0 0 0-94 93 156 157 156-157-93-93 0 0 250 0 0 250z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        tooltip_basic: {
          width: 1500,
          height: 1e3,
          path: "m375 725l0 0-375-375 375-374 0-1 1125 0 0 750-1125 0z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        tooltip_compare: {
          width: 1125,
          height: 1e3,
          path: "m187 786l0 2-187-188 188-187 0 0 937 0 0 373-938 0z m0-499l0 1-187-188 188-188 0 0 937 0 0 376-938-1z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        plotlylogo: {
          width: 1542,
          height: 1e3,
          path: "m0-10h182v-140h-182v140z m228 146h183v-286h-183v286z m225 714h182v-1000h-182v1000z m225-285h182v-715h-182v715z m225 142h183v-857h-183v857z m231-428h182v-429h-182v429z m225-291h183v-138h-183v138z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        "z-axis": {
          width: 1e3,
          height: 1e3,
          path: "m833 5l-17 108v41l-130-65 130-66c0 0 0 38 0 39 0-1 36-14 39-25 4-15-6-22-16-30-15-12-39-16-56-20-90-22-187-23-279-23-261 0-341 34-353 59 3 60 228 110 228 110-140-8-351-35-351-116 0-120 293-142 474-142 155 0 477 22 477 142 0 50-74 79-163 96z m-374 94c-58-5-99-21-99-40 0-24 65-43 144-43 79 0 143 19 143 43 0 19-42 34-98 40v216h87l-132 135-133-135h88v-216z m167 515h-136v1c16 16 31 34 46 52l84 109v54h-230v-71h124v-1c-16-17-28-32-44-51l-89-114v-51h245v72z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        "3d_rotate": {
          width: 1e3,
          height: 1e3,
          path: "m922 660c-5 4-9 7-14 11-359 263-580-31-580-31l-102 28 58-400c0 1 1 1 2 2 118 108 351 249 351 249s-62 27-100 42c88 83 222 183 347 122 16-8 30-17 44-27-2 1-4 2-6 4z m36-329c0 0 64 229-88 296-62 27-124 14-175-11 157-78 225-208 249-266 8-19 11-31 11-31 2 5 6 15 11 32-5-13-8-20-8-20z m-775-239c70-31 117-50 198-32-121 80-199 346-199 346l-96-15-58-12c0 0 55-226 155-287z m603 133l-317-139c0 0 4-4 19-14 7-5 24-15 24-15s-177-147-389 4c235-287 536-112 536-112l31-22 100 299-4-1z m-298-153c6-4 14-9 24-15 0 0-17 10-24 15z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        camera: {
          width: 1e3,
          height: 1e3,
          path: "m500 450c-83 0-150-67-150-150 0-83 67-150 150-150 83 0 150 67 150 150 0 83-67 150-150 150z m400 150h-120c-16 0-34 13-39 29l-31 93c-6 15-23 28-40 28h-340c-16 0-34-13-39-28l-31-94c-6-15-23-28-40-28h-120c-55 0-100-45-100-100v-450c0-55 45-100 100-100h800c55 0 100 45 100 100v450c0 55-45 100-100 100z m-400-550c-138 0-250 112-250 250 0 138 112 250 250 250 138 0 250-112 250-250 0-138-112-250-250-250z m365 380c-19 0-35 16-35 35 0 19 16 35 35 35 19 0 35-16 35-35 0-19-16-35-35-35z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        movie: {
          width: 1e3,
          height: 1e3,
          path: "m938 413l-188-125c0 37-17 71-44 94 64 38 107 107 107 187 0 121-98 219-219 219-121 0-219-98-219-219 0-61 25-117 66-156h-115c30 33 49 76 49 125 0 103-84 187-187 187s-188-84-188-187c0-57 26-107 65-141-38-22-65-62-65-109v-250c0-70 56-126 125-126h500c69 0 125 56 125 126l188-126c34 0 62 28 62 63v375c0 35-28 63-62 63z m-750 0c-69 0-125 56-125 125s56 125 125 125 125-56 125-125-56-125-125-125z m406-1c-87 0-157 70-157 157 0 86 70 156 157 156s156-70 156-156-70-157-156-157z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        question: {
          width: 857.1,
          height: 1e3,
          path: "m500 82v107q0 8-5 13t-13 5h-107q-8 0-13-5t-5-13v-107q0-8 5-13t13-5h107q8 0 13 5t5 13z m143 375q0 49-31 91t-77 65-95 23q-136 0-207-119-9-14 4-24l74-55q4-4 10-4 9 0 14 7 30 38 48 51 19 14 48 14 27 0 48-15t21-33q0-21-11-34t-38-25q-35-16-65-48t-29-70v-20q0-8 5-13t13-5h107q8 0 13 5t5 13q0 10 12 27t30 28q18 10 28 16t25 19 25 27 16 34 7 45z m214-107q0-117-57-215t-156-156-215-58-216 58-155 156-58 215 58 215 155 156 216 58 215-58 156-156 57-215z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        disk: {
          width: 857.1,
          height: 1e3,
          path: "m214-7h429v214h-429v-214z m500 0h72v500q0 8-6 21t-11 20l-157 156q-5 6-19 12t-22 5v-232q0-22-15-38t-38-16h-322q-22 0-37 16t-16 38v232h-72v-714h72v232q0 22 16 38t37 16h465q22 0 38-16t15-38v-232z m-214 518v178q0 8-5 13t-13 5h-107q-7 0-13-5t-5-13v-178q0-8 5-13t13-5h107q7 0 13 5t5 13z m357-18v-518q0-22-15-38t-38-16h-750q-23 0-38 16t-16 38v750q0 22 16 38t38 16h517q23 0 50-12t42-26l156-157q16-15 27-42t11-49z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        drawopenpath: {
          width: 70,
          height: 70,
          path: "M33.21,85.65a7.31,7.31,0,0,1-2.59-.48c-8.16-3.11-9.27-19.8-9.88-41.3-.1-3.58-.19-6.68-.35-9-.15-2.1-.67-3.48-1.43-3.79-2.13-.88-7.91,2.32-12,5.86L3,32.38c1.87-1.64,11.55-9.66,18.27-6.9,2.13.87,4.75,3.14,5.17,9,.17,2.43.26,5.59.36,9.25a224.17,224.17,0,0,0,1.5,23.4c1.54,10.76,4,12.22,4.48,12.4.84.32,2.79-.46,5.76-3.59L43,80.07C41.53,81.57,37.68,85.64,33.21,85.65ZM74.81,69a11.34,11.34,0,0,0,6.09-6.72L87.26,44.5,74.72,32,56.9,38.35c-2.37.86-5.57,3.42-6.61,6L38.65,72.14l8.42,8.43ZM55,46.27a7.91,7.91,0,0,1,3.64-3.17l14.8-5.3,8,8L76.11,60.6l-.06.19a6.37,6.37,0,0,1-3,3.43L48.25,74.59,44.62,71Zm16.57,7.82A6.9,6.9,0,1,0,64.64,61,6.91,6.91,0,0,0,71.54,54.09Zm-4.05,0a2.85,2.85,0,1,1-2.85-2.85A2.86,2.86,0,0,1,67.49,54.09Zm-4.13,5.22L60.5,56.45,44.26,72.7l2.86,2.86ZM97.83,35.67,84.14,22l-8.57,8.57L89.26,44.24Zm-13.69-8,8,8-2.85,2.85-8-8Z",
          transform: "matrix(1 0 0 1 -15 -15)"
        },
        drawclosedpath: {
          width: 90,
          height: 90,
          path: "M88.41,21.12a26.56,26.56,0,0,0-36.18,0l-2.07,2-2.07-2a26.57,26.57,0,0,0-36.18,0,23.74,23.74,0,0,0,0,34.8L48,90.12a3.22,3.22,0,0,0,4.42,0l36-34.21a23.73,23.73,0,0,0,0-34.79ZM84,51.24,50.16,83.35,16.35,51.25a17.28,17.28,0,0,1,0-25.47,20,20,0,0,1,27.3,0l4.29,4.07a3.23,3.23,0,0,0,4.44,0l4.29-4.07a20,20,0,0,1,27.3,0,17.27,17.27,0,0,1,0,25.46ZM66.76,47.68h-33v6.91h33ZM53.35,35H46.44V68h6.91Z",
          transform: "matrix(1 0 0 1 -5 -5)"
        },
        lasso: {
          width: 1031,
          height: 1e3,
          path: "m1018 538c-36 207-290 336-568 286-277-48-473-256-436-463 10-57 36-108 76-151-13-66 11-137 68-183 34-28 75-41 114-42l-55-70 0 0c-2-1-3-2-4-3-10-14-8-34 5-45 14-11 34-8 45 4 1 1 2 3 2 5l0 0 113 140c16 11 31 24 45 40 4 3 6 7 8 11 48-3 100 0 151 9 278 48 473 255 436 462z m-624-379c-80 14-149 48-197 96 42 42 109 47 156 9 33-26 47-66 41-105z m-187-74c-19 16-33 37-39 60 50-32 109-55 174-68-42-25-95-24-135 8z m360 75c-34-7-69-9-102-8 8 62-16 128-68 170-73 59-175 54-244-5-9 20-16 40-20 61-28 159 121 317 333 354s407-60 434-217c28-159-121-318-333-355z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        selectbox: {
          width: 1e3,
          height: 1e3,
          path: "m0 850l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m285 0l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m-857-286l0-143 143 0 0 143-143 0z m857 0l0-143 143 0 0 143-143 0z m-857-285l0-143 143 0 0 143-143 0z m857 0l0-143 143 0 0 143-143 0z m-857-286l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m285 0l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        drawline: {
          width: 70,
          height: 70,
          path: "M60.64,62.3a11.29,11.29,0,0,0,6.09-6.72l6.35-17.72L60.54,25.31l-17.82,6.4c-2.36.86-5.57,3.41-6.6,6L24.48,65.5l8.42,8.42ZM40.79,39.63a7.89,7.89,0,0,1,3.65-3.17l14.79-5.31,8,8L61.94,54l-.06.19a6.44,6.44,0,0,1-3,3.43L34.07,68l-3.62-3.63Zm16.57,7.81a6.9,6.9,0,1,0-6.89,6.9A6.9,6.9,0,0,0,57.36,47.44Zm-4,0a2.86,2.86,0,1,1-2.85-2.85A2.86,2.86,0,0,1,53.32,47.44Zm-4.13,5.22L46.33,49.8,30.08,66.05l2.86,2.86ZM83.65,29,70,15.34,61.4,23.9,75.09,37.59ZM70,21.06l8,8-2.84,2.85-8-8ZM87,80.49H10.67V87H87Z",
          transform: "matrix(1 0 0 1 -15 -15)"
        },
        drawrect: {
          width: 80,
          height: 80,
          path: "M78,22V79H21V22H78m9-9H12V88H87V13ZM68,46.22H31V54H68ZM53,32H45.22V69H53Z",
          transform: "matrix(1 0 0 1 -10 -10)"
        },
        drawcircle: {
          width: 80,
          height: 80,
          path: "M50,84.72C26.84,84.72,8,69.28,8,50.3S26.84,15.87,50,15.87,92,31.31,92,50.3,73.16,84.72,50,84.72Zm0-60.59c-18.6,0-33.74,11.74-33.74,26.17S31.4,76.46,50,76.46,83.74,64.72,83.74,50.3,68.6,24.13,50,24.13Zm17.15,22h-34v7.11h34Zm-13.8-13H46.24v34h7.11Z",
          transform: "matrix(1 0 0 1 -10 -10)"
        },
        eraseshape: {
          width: 80,
          height: 80,
          path: "M82.77,78H31.85L6,49.57,31.85,21.14H82.77a8.72,8.72,0,0,1,8.65,8.77V69.24A8.72,8.72,0,0,1,82.77,78ZM35.46,69.84H82.77a.57.57,0,0,0,.49-.6V29.91a.57.57,0,0,0-.49-.61H35.46L17,49.57Zm32.68-34.7-24,24,5,5,24-24Zm-19,.53-5,5,24,24,5-5Z",
          transform: "matrix(1 0 0 1 -10 -10)"
        },
        spikeline: {
          width: 1e3,
          height: 1e3,
          path: "M512 409c0-57-46-104-103-104-57 0-104 47-104 104 0 57 47 103 104 103 57 0 103-46 103-103z m-327-39l92 0 0 92-92 0z m-185 0l92 0 0 92-92 0z m370-186l92 0 0 93-92 0z m0-184l92 0 0 92-92 0z",
          transform: "matrix(1.5 0 0 -1.5 0 850)"
        },
        pencil: {
          width: 1792,
          height: 1792,
          path: "M491 1536l91-91-235-235-91 91v107h128v128h107zm523-928q0-22-22-22-10 0-17 7l-542 542q-7 7-7 17 0 22 22 22 10 0 17-7l542-542q7-7 7-17zm-54-192l416 416-832 832h-416v-416zm683 96q0 53-37 90l-166 166-416-416 166-165q36-38 90-38 53 0 91 38l235 234q37 39 37 91z",
          transform: "matrix(1 0 0 1 0 1)"
        },
        newplotlylogo: {
          name: "newplotlylogo",
          svg: [
            "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 132 132'>",
            " <title>plotly-logomark</title>",
            " <g id='symbol'>",
            "  <rect fill='#000' x='0' y='0' width='132' height='132' rx='18' ry='18'/>",
            "  <circle fill='#9EF' cx='102' cy='30' r='6'/>",
            "  <circle fill='#BAC' cx='78' cy='30' r='6'/>",
            "  <circle fill='#BAC' cx='78' cy='54' r='6'/>",
            "  <circle fill='#D69' cx='54' cy='30' r='6'/>",
            "  <circle fill='#F26' cx='30' cy='30' r='6'/>",
            "  <circle fill='#F26' cx='30' cy='54' r='6'/>",
            "  <path fill='#FFF' d='M30,72a6,6,0,0,0-6,6v24a6,6,0,0,0,12,0V78A6,6,0,0,0,30,72Z'/>",
            "  <path fill='#FFF' d='M78,72a6,6,0,0,0-6,6v24a6,6,0,0,0,12,0V78A6,6,0,0,0,78,72Z'/>",
            "  <path fill='#FFF' d='M54,48a6,6,0,0,0-6,6v48a6,6,0,0,0,12,0V54A6,6,0,0,0,54,48Z'/>",
            "  <path fill='#FFF' d='M102,48a6,6,0,0,0-6,6v48a6,6,0,0,0,12,0V54A6,6,0,0,0,102,48Z'/>",
            " </g>",
            "</svg>"
          ].join("")
        }
      };
    }
  });

  // src/components/shapes/draw_newshape/constants.js
  var require_constants4 = __commonJS({
    "src/components/shapes/draw_newshape/constants.js"(exports, module) {
      "use strict";
      var CIRCLE_SIDES = 32;
      module.exports = {
        CIRCLE_SIDES,
        i000: 0,
        i090: CIRCLE_SIDES / 4,
        i180: CIRCLE_SIDES / 2,
        i270: CIRCLE_SIDES / 4 * 3,
        cos45: Math.cos(Math.PI / 4),
        sin45: Math.sin(Math.PI / 4),
        SQRT2: Math.sqrt(2)
      };
    }
  });

  // src/components/selections/helpers.js
  var require_helpers6 = __commonJS({
    "src/components/selections/helpers.js"(exports, module) {
      "use strict";
      var strTranslate = require_lib().strTranslate;
      function p2r(ax, v) {
        switch (ax.type) {
          case "log":
            return ax.p2d(v);
          case "date":
            return ax.p2r(v, 0, ax.calendar);
          default:
            return ax.p2r(v);
        }
      }
      function r2p(ax, v) {
        switch (ax.type) {
          case "log":
            return ax.d2p(v);
          case "date":
            return ax.r2p(v, 0, ax.calendar);
          default:
            return ax.r2p(v);
        }
      }
      function axValue(ax) {
        var index = ax._id.charAt(0) === "y" ? 1 : 0;
        return function(v) {
          return p2r(ax, v[index]);
        };
      }
      function getTransform(plotinfo) {
        return strTranslate(
          plotinfo.xaxis._offset,
          plotinfo.yaxis._offset
        );
      }
      module.exports = {
        p2r,
        r2p,
        axValue,
        getTransform
      };
    }
  });

  // src/components/shapes/draw_newshape/helpers.js
  var require_helpers7 = __commonJS({
    "src/components/shapes/draw_newshape/helpers.js"(exports) {
      "use strict";
      var parseSvgPath = require_parse_svg_path();
      var constants = require_constants4();
      var CIRCLE_SIDES = constants.CIRCLE_SIDES;
      var SQRT2 = constants.SQRT2;
      var cartesianHelpers = require_helpers6();
      var p2r = cartesianHelpers.p2r;
      var r2p = cartesianHelpers.r2p;
      var iC = [0, 3, 4, 5, 6, 1, 2];
      var iQS = [0, 3, 4, 1, 2];
      exports.writePaths = function(polygons) {
        var nI = polygons.length;
        if (!nI) return "M0,0Z";
        var str = "";
        for (var i = 0; i < nI; i++) {
          var nJ = polygons[i].length;
          for (var j = 0; j < nJ; j++) {
            var w = polygons[i][j][0];
            if (w === "Z") {
              str += "Z";
            } else {
              var nK = polygons[i][j].length;
              for (var k = 0; k < nK; k++) {
                var realK = k;
                if (w === "Q" || w === "S") {
                  realK = iQS[k];
                } else if (w === "C") {
                  realK = iC[k];
                }
                str += polygons[i][j][realK];
                if (k > 0 && k < nK - 1) {
                  str += ",";
                }
              }
            }
          }
        }
        return str;
      };
      exports.readPaths = function(str, gd, plotinfo, isActiveShape) {
        var cmd = parseSvgPath(str);
        var polys = [];
        var n = -1;
        var newPoly = function() {
          n++;
          polys[n] = [];
        };
        var k;
        var x = 0;
        var y = 0;
        var initX;
        var initY;
        var recStart = function() {
          initX = x;
          initY = y;
        };
        recStart();
        for (var i = 0; i < cmd.length; i++) {
          var newPos = [];
          var x1, x2, y1, y2;
          var c = cmd[i][0];
          var w = c;
          switch (c) {
            case "M":
              newPoly();
              x = +cmd[i][1];
              y = +cmd[i][2];
              newPos.push([w, x, y]);
              recStart();
              break;
            case "Q":
            case "S":
              x1 = +cmd[i][1];
              y1 = +cmd[i][2];
              x = +cmd[i][3];
              y = +cmd[i][4];
              newPos.push([w, x, y, x1, y1]);
              break;
            case "C":
              x1 = +cmd[i][1];
              y1 = +cmd[i][2];
              x2 = +cmd[i][3];
              y2 = +cmd[i][4];
              x = +cmd[i][5];
              y = +cmd[i][6];
              newPos.push([w, x, y, x1, y1, x2, y2]);
              break;
            case "T":
            case "L":
              x = +cmd[i][1];
              y = +cmd[i][2];
              newPos.push([w, x, y]);
              break;
            case "H":
              w = "L";
              x = +cmd[i][1];
              newPos.push([w, x, y]);
              break;
            case "V":
              w = "L";
              y = +cmd[i][1];
              newPos.push([w, x, y]);
              break;
            case "A":
              w = "L";
              var rx = +cmd[i][1];
              var ry = +cmd[i][2];
              if (!+cmd[i][4]) {
                rx = -rx;
                ry = -ry;
              }
              var cenX = x - rx;
              var cenY = y;
              for (k = 1; k <= CIRCLE_SIDES / 2; k++) {
                var t = 2 * Math.PI * k / CIRCLE_SIDES;
                newPos.push([
                  w,
                  cenX + rx * Math.cos(t),
                  cenY + ry * Math.sin(t)
                ]);
              }
              break;
            case "Z":
              if (x !== initX || y !== initY) {
                x = initX;
                y = initY;
                newPos.push([w, x, y]);
              }
              break;
          }
          var domain = (plotinfo || {}).domain;
          var size = gd._fullLayout._size;
          var xPixelSized = plotinfo && plotinfo.xsizemode === "pixel";
          var yPixelSized = plotinfo && plotinfo.ysizemode === "pixel";
          var noOffset = isActiveShape === false;
          for (var j = 0; j < newPos.length; j++) {
            for (k = 0; k + 2 < 7; k += 2) {
              var _x = newPos[j][k + 1];
              var _y = newPos[j][k + 2];
              if (_x === void 0 || _y === void 0) continue;
              x = _x;
              y = _y;
              if (plotinfo) {
                if (plotinfo.xaxis && plotinfo.xaxis.p2r) {
                  if (noOffset) _x -= plotinfo.xaxis._offset;
                  if (xPixelSized) {
                    _x = r2p(plotinfo.xaxis, plotinfo.xanchor) + _x;
                  } else {
                    _x = p2r(plotinfo.xaxis, _x);
                  }
                } else {
                  if (noOffset) _x -= size.l;
                  if (domain) _x = domain.x[0] + _x / size.w;
                  else _x = _x / size.w;
                }
                if (plotinfo.yaxis && plotinfo.yaxis.p2r) {
                  if (noOffset) _y -= plotinfo.yaxis._offset;
                  if (yPixelSized) {
                    _y = r2p(plotinfo.yaxis, plotinfo.yanchor) - _y;
                  } else {
                    _y = p2r(plotinfo.yaxis, _y);
                  }
                } else {
                  if (noOffset) _y -= size.t;
                  if (domain) _y = domain.y[1] - _y / size.h;
                  else _y = 1 - _y / size.h;
                }
              }
              newPos[j][k + 1] = _x;
              newPos[j][k + 2] = _y;
            }
            polys[n].push(
              newPos[j].slice()
            );
          }
        }
        return polys;
      };
      function almostEq(a, b) {
        return Math.abs(a - b) <= 1e-6;
      }
      function dist(a, b) {
        var dx = b[1] - a[1];
        var dy = b[2] - a[2];
        return Math.sqrt(
          dx * dx + dy * dy
        );
      }
      exports.pointsOnRectangle = function(cell) {
        var len = cell.length;
        if (len !== 5) return false;
        for (var j = 1; j < 3; j++) {
          var e01 = cell[0][j] - cell[1][j];
          var e32 = cell[3][j] - cell[2][j];
          if (!almostEq(e01, e32)) return false;
          var e03 = cell[0][j] - cell[3][j];
          var e12 = cell[1][j] - cell[2][j];
          if (!almostEq(e03, e12)) return false;
        }
        if (!almostEq(cell[0][1], cell[1][1]) && !almostEq(cell[0][1], cell[3][1])) return false;
        return !!(dist(cell[0], cell[1]) * dist(cell[0], cell[3]));
      };
      exports.pointsOnEllipse = function(cell) {
        var len = cell.length;
        if (len !== CIRCLE_SIDES + 1) return false;
        len = CIRCLE_SIDES;
        for (var i = 0; i < len; i++) {
          var k = (len * 2 - i) % len;
          var k2 = (len / 2 + k) % len;
          var i2 = (len / 2 + i) % len;
          if (!almostEq(
            dist(cell[i], cell[i2]),
            dist(cell[k], cell[k2])
          )) return false;
        }
        return true;
      };
      exports.handleEllipse = function(isEllipse, start, end) {
        if (!isEllipse) return [start, end];
        var pos = exports.ellipseOver({
          x0: start[0],
          y0: start[1],
          x1: end[0],
          y1: end[1]
        });
        var cx = (pos.x1 + pos.x0) / 2;
        var cy = (pos.y1 + pos.y0) / 2;
        var rx = (pos.x1 - pos.x0) / 2;
        var ry = (pos.y1 - pos.y0) / 2;
        if (!rx) rx = ry = ry / SQRT2;
        if (!ry) ry = rx = rx / SQRT2;
        var cell = [];
        for (var i = 0; i < CIRCLE_SIDES; i++) {
          var t = i * 2 * Math.PI / CIRCLE_SIDES;
          cell.push([
            cx + rx * Math.cos(t),
            cy + ry * Math.sin(t)
          ]);
        }
        return cell;
      };
      exports.ellipseOver = function(pos) {
        var x0 = pos.x0;
        var y0 = pos.y0;
        var x1 = pos.x1;
        var y1 = pos.y1;
        var dx = x1 - x0;
        var dy = y1 - y0;
        x0 -= dx;
        y0 -= dy;
        var cx = (x0 + x1) / 2;
        var cy = (y0 + y1) / 2;
        var scale = SQRT2;
        dx *= scale;
        dy *= scale;
        return {
          x0: cx - dx,
          y0: cy - dy,
          x1: cx + dx,
          y1: cy + dy
        };
      };
      exports.fixDatesForPaths = function(polygons, xaxis, yaxis) {
        var xIsDate = xaxis.type === "date";
        var yIsDate = yaxis.type === "date";
        if (!xIsDate && !yIsDate) return polygons;
        for (var i = 0; i < polygons.length; i++) {
          for (var j = 0; j < polygons[i].length; j++) {
            for (var k = 0; k + 2 < polygons[i][j].length; k += 2) {
              if (xIsDate) polygons[i][j][k + 1] = polygons[i][j][k + 1].replace(" ", "_");
              if (yIsDate) polygons[i][j][k + 2] = polygons[i][j][k + 2].replace(" ", "_");
            }
          }
        }
        return polygons;
      };
    }
  });

  // src/components/shapes/draw_newshape/newshapes.js
  var require_newshapes = __commonJS({
    "src/components/shapes/draw_newshape/newshapes.js"(exports, module) {
      "use strict";
      var dragHelpers = require_helpers5();
      var drawMode = dragHelpers.drawMode;
      var openMode = dragHelpers.openMode;
      var constants = require_constants4();
      var i000 = constants.i000;
      var i090 = constants.i090;
      var i180 = constants.i180;
      var i270 = constants.i270;
      var cos45 = constants.cos45;
      var sin45 = constants.sin45;
      var cartesianHelpers = require_helpers6();
      var p2r = cartesianHelpers.p2r;
      var r2p = cartesianHelpers.r2p;
      var handleOutline = require_handle_outline();
      var clearOutline = handleOutline.clearOutline;
      var helpers = require_helpers7();
      var readPaths = helpers.readPaths;
      var writePaths = helpers.writePaths;
      var ellipseOver = helpers.ellipseOver;
      var fixDatesForPaths = helpers.fixDatesForPaths;
      function newShapes(outlines, dragOptions) {
        if (!outlines.length) return;
        var e = outlines[0][0];
        if (!e) return;
        var gd = dragOptions.gd;
        var isActiveShape = dragOptions.isActiveShape;
        var dragmode = dragOptions.dragmode;
        var shapes = (gd.layout || {}).shapes || [];
        if (!drawMode(dragmode) && isActiveShape !== void 0) {
          var id = gd._fullLayout._activeShapeIndex;
          if (id < shapes.length) {
            switch (gd._fullLayout.shapes[id].type) {
              case "rect":
                dragmode = "drawrect";
                break;
              case "circle":
                dragmode = "drawcircle";
                break;
              case "line":
                dragmode = "drawline";
                break;
              case "path":
                var path = shapes[id].path || "";
                if (path[path.length - 1] === "Z") {
                  dragmode = "drawclosedpath";
                } else {
                  dragmode = "drawopenpath";
                }
                break;
            }
          }
        }
        var newShape = createShapeObj(outlines, dragOptions, dragmode);
        clearOutline(gd);
        var editHelpers = dragOptions.editHelpers;
        var modifyItem = (editHelpers || {}).modifyItem;
        var allShapes = [];
        for (var q = 0; q < shapes.length; q++) {
          var beforeEdit = gd._fullLayout.shapes[q];
          allShapes[q] = beforeEdit._input;
          if (isActiveShape !== void 0 && q === gd._fullLayout._activeShapeIndex) {
            var afterEdit = newShape;
            switch (beforeEdit.type) {
              case "line":
              case "rect":
              case "circle":
                modifyItem("x0", afterEdit.x0 - (beforeEdit.x0shift || 0));
                modifyItem("x1", afterEdit.x1 - (beforeEdit.x1shift || 0));
                modifyItem("y0", afterEdit.y0 - (beforeEdit.y0shift || 0));
                modifyItem("y1", afterEdit.y1 - (beforeEdit.y1shift || 0));
                break;
              case "path":
                modifyItem("path", afterEdit.path);
                break;
            }
          }
        }
        if (isActiveShape === void 0) {
          allShapes.push(newShape);
          return allShapes;
        }
        return editHelpers ? editHelpers.getUpdateObj() : {};
      }
      function createShapeObj(outlines, dragOptions, dragmode) {
        var e = outlines[0][0];
        var gd = dragOptions.gd;
        var d = e.getAttribute("d");
        var newStyle = gd._fullLayout.newshape;
        var plotinfo = dragOptions.plotinfo;
        var isActiveShape = dragOptions.isActiveShape;
        var xaxis = plotinfo.xaxis;
        var yaxis = plotinfo.yaxis;
        var xPaper = !!plotinfo.domain || !plotinfo.xaxis;
        var yPaper = !!plotinfo.domain || !plotinfo.yaxis;
        var isOpenMode = openMode(dragmode);
        var polygons = readPaths(d, gd, plotinfo, isActiveShape);
        var newShape = {
          editable: true,
          visible: newStyle.visible,
          name: newStyle.name,
          showlegend: newStyle.showlegend,
          legend: newStyle.legend,
          legendwidth: newStyle.legendwidth,
          legendgroup: newStyle.legendgroup,
          legendgrouptitle: {
            text: newStyle.legendgrouptitle.text,
            font: newStyle.legendgrouptitle.font
          },
          legendrank: newStyle.legendrank,
          label: newStyle.label,
          xref: xPaper ? "paper" : xaxis._id,
          yref: yPaper ? "paper" : yaxis._id,
          layer: newStyle.layer,
          opacity: newStyle.opacity,
          line: {
            color: newStyle.line.color,
            width: newStyle.line.width,
            dash: newStyle.line.dash
          }
        };
        if (!isOpenMode) {
          newShape.fillcolor = newStyle.fillcolor;
          newShape.fillrule = newStyle.fillrule;
        }
        var cell;
        if (polygons.length === 1) cell = polygons[0];
        if (cell && cell.length === 5 && // ensure we only have 4 corners for a rect
        dragmode === "drawrect") {
          newShape.type = "rect";
          newShape.x0 = cell[0][1];
          newShape.y0 = cell[0][2];
          newShape.x1 = cell[2][1];
          newShape.y1 = cell[2][2];
        } else if (cell && dragmode === "drawline") {
          newShape.type = "line";
          newShape.x0 = cell[0][1];
          newShape.y0 = cell[0][2];
          newShape.x1 = cell[1][1];
          newShape.y1 = cell[1][2];
        } else if (cell && dragmode === "drawcircle") {
          newShape.type = "circle";
          var xA = cell[i000][1];
          var xB = cell[i090][1];
          var xC = cell[i180][1];
          var xD = cell[i270][1];
          var yA = cell[i000][2];
          var yB = cell[i090][2];
          var yC = cell[i180][2];
          var yD = cell[i270][2];
          var xDateOrLog = plotinfo.xaxis && (plotinfo.xaxis.type === "date" || plotinfo.xaxis.type === "log");
          var yDateOrLog = plotinfo.yaxis && (plotinfo.yaxis.type === "date" || plotinfo.yaxis.type === "log");
          if (xDateOrLog) {
            xA = r2p(plotinfo.xaxis, xA);
            xB = r2p(plotinfo.xaxis, xB);
            xC = r2p(plotinfo.xaxis, xC);
            xD = r2p(plotinfo.xaxis, xD);
          }
          if (yDateOrLog) {
            yA = r2p(plotinfo.yaxis, yA);
            yB = r2p(plotinfo.yaxis, yB);
            yC = r2p(plotinfo.yaxis, yC);
            yD = r2p(plotinfo.yaxis, yD);
          }
          var x0 = (xB + xD) / 2;
          var y0 = (yA + yC) / 2;
          var rx = (xD - xB + xC - xA) / 2;
          var ry = (yD - yB + yC - yA) / 2;
          var pos = ellipseOver({
            x0,
            y0,
            x1: x0 + rx * cos45,
            y1: y0 + ry * sin45
          });
          if (xDateOrLog) {
            pos.x0 = p2r(plotinfo.xaxis, pos.x0);
            pos.x1 = p2r(plotinfo.xaxis, pos.x1);
          }
          if (yDateOrLog) {
            pos.y0 = p2r(plotinfo.yaxis, pos.y0);
            pos.y1 = p2r(plotinfo.yaxis, pos.y1);
          }
          newShape.x0 = pos.x0;
          newShape.y0 = pos.y0;
          newShape.x1 = pos.x1;
          newShape.y1 = pos.y1;
        } else {
          newShape.type = "path";
          if (xaxis && yaxis) fixDatesForPaths(polygons, xaxis, yaxis);
          newShape.path = writePaths(polygons);
          cell = null;
        }
        return newShape;
      }
      module.exports = {
        newShapes,
        createShapeObj
      };
    }
  });

  // src/components/selections/draw_newselection/newselections.js
  var require_newselections = __commonJS({
    "src/components/selections/draw_newselection/newselections.js"(exports, module) {
      "use strict";
      var dragHelpers = require_helpers5();
      var selectMode = dragHelpers.selectMode;
      var handleOutline = require_handle_outline();
      var clearOutline = handleOutline.clearOutline;
      var helpers = require_helpers7();
      var readPaths = helpers.readPaths;
      var writePaths = helpers.writePaths;
      var fixDatesForPaths = helpers.fixDatesForPaths;
      module.exports = function newSelections(outlines, dragOptions) {
        if (!outlines.length) return;
        var e = outlines[0][0];
        if (!e) return;
        var d = e.getAttribute("d");
        var gd = dragOptions.gd;
        var newStyle = gd._fullLayout.newselection;
        var plotinfo = dragOptions.plotinfo;
        var xaxis = plotinfo.xaxis;
        var yaxis = plotinfo.yaxis;
        var isActiveSelection = dragOptions.isActiveSelection;
        var dragmode = dragOptions.dragmode;
        var selections = (gd.layout || {}).selections || [];
        if (!selectMode(dragmode) && isActiveSelection !== void 0) {
          var id = gd._fullLayout._activeSelectionIndex;
          if (id < selections.length) {
            switch (gd._fullLayout.selections[id].type) {
              case "rect":
                dragmode = "select";
                break;
              case "path":
                dragmode = "lasso";
                break;
            }
          }
        }
        var polygons = readPaths(d, gd, plotinfo, isActiveSelection);
        var newSelection = {
          xref: xaxis._id,
          yref: yaxis._id,
          opacity: newStyle.opacity,
          line: {
            color: newStyle.line.color,
            width: newStyle.line.width,
            dash: newStyle.line.dash
          }
        };
        var cell;
        if (polygons.length === 1) cell = polygons[0];
        if (cell && cell.length === 5 && // ensure we only have 4 corners for a rect
        dragmode === "select") {
          newSelection.type = "rect";
          newSelection.x0 = cell[0][1];
          newSelection.y0 = cell[0][2];
          newSelection.x1 = cell[2][1];
          newSelection.y1 = cell[2][2];
        } else {
          newSelection.type = "path";
          if (xaxis && yaxis) fixDatesForPaths(polygons, xaxis, yaxis);
          newSelection.path = writePaths(polygons);
          cell = null;
        }
        clearOutline(gd);
        var editHelpers = dragOptions.editHelpers;
        var modifyItem = (editHelpers || {}).modifyItem;
        var allSelections = [];
        for (var q = 0; q < selections.length; q++) {
          var beforeEdit = gd._fullLayout.selections[q];
          if (!beforeEdit) {
            allSelections[q] = beforeEdit;
            continue;
          }
          allSelections[q] = beforeEdit._input;
          if (isActiveSelection !== void 0 && q === gd._fullLayout._activeSelectionIndex) {
            var afterEdit = newSelection;
            switch (beforeEdit.type) {
              case "rect":
                modifyItem("x0", afterEdit.x0);
                modifyItem("x1", afterEdit.x1);
                modifyItem("y0", afterEdit.y0);
                modifyItem("y1", afterEdit.y1);
                break;
              case "path":
                modifyItem("path", afterEdit.path);
                break;
            }
          }
        }
        if (isActiveSelection === void 0) {
          allSelections.push(newSelection);
          return allSelections;
        }
        return editHelpers ? editHelpers.getUpdateObj() : {};
      };
    }
  });

  // src/components/shapes/constants.js
  var require_constants5 = __commonJS({
    "src/components/shapes/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        segmentRE: /[MLHVQCTSZ][^MLHVQCTSZ]*/g,
        paramRE: /[^\s,]+/g,
        // which numbers in each path segment are x (or y) values
        // drawn is which param is a drawn point, as opposed to a
        // control point (which doesn't count toward autorange.
        // TODO: this means curved paths could extend beyond the
        // autorange bounds. This is a bit tricky to get right
        // unless we revert to bounding boxes, but perhaps there's
        // a calculation we could do...)
        paramIsX: {
          M: { 0: true, drawn: 0 },
          L: { 0: true, drawn: 0 },
          H: { 0: true, drawn: 0 },
          V: {},
          Q: { 0: true, 2: true, drawn: 2 },
          C: { 0: true, 2: true, 4: true, drawn: 4 },
          T: { 0: true, drawn: 0 },
          S: { 0: true, 2: true, drawn: 2 },
          // A: {0: true, 5: true},
          Z: {}
        },
        paramIsY: {
          M: { 1: true, drawn: 1 },
          L: { 1: true, drawn: 1 },
          H: {},
          V: { 0: true, drawn: 0 },
          Q: { 1: true, 3: true, drawn: 3 },
          C: { 1: true, 3: true, 5: true, drawn: 5 },
          T: { 1: true, drawn: 1 },
          S: { 1: true, 3: true, drawn: 5 },
          // A: {1: true, 6: true},
          Z: {}
        },
        numParams: {
          M: 2,
          L: 2,
          H: 1,
          V: 1,
          Q: 4,
          C: 6,
          T: 2,
          S: 4,
          // A: 7,
          Z: 0
        }
      };
    }
  });

  // src/components/shapes/helpers.js
  var require_helpers8 = __commonJS({
    "src/components/shapes/helpers.js"(exports) {
      "use strict";
      var constants = require_constants5();
      var Lib = require_lib();
      var Axes = require_axes();
      exports.rangeToShapePosition = function(ax) {
        return ax.type === "log" ? ax.r2d : function(v) {
          return v;
        };
      };
      exports.shapePositionToRange = function(ax) {
        return ax.type === "log" ? ax.d2r : function(v) {
          return v;
        };
      };
      exports.decodeDate = function(convertToPx) {
        return function(v) {
          if (v.replace) v = v.replace("_", " ");
          return convertToPx(v);
        };
      };
      exports.encodeDate = function(convertToDate) {
        return function(v) {
          return convertToDate(v).replace(" ", "_");
        };
      };
      exports.extractPathCoords = function(path, paramsToUse, isRaw) {
        var extractedCoordinates = [];
        var segments = path.match(constants.segmentRE);
        segments.forEach(function(segment) {
          var relevantParamIdx = paramsToUse[segment.charAt(0)].drawn;
          if (relevantParamIdx === void 0) return;
          var params = segment.substr(1).match(constants.paramRE);
          if (!params || params.length < relevantParamIdx) return;
          var str = params[relevantParamIdx];
          var pos = isRaw ? str : Lib.cleanNumber(str);
          extractedCoordinates.push(pos);
        });
        return extractedCoordinates;
      };
      exports.getDataToPixel = function(gd, axis, shift, isVertical, refType) {
        var gs = gd._fullLayout._size;
        var dataToPixel;
        if (axis) {
          if (refType === "domain") {
            dataToPixel = function(v) {
              return axis._length * (isVertical ? 1 - v : v) + axis._offset;
            };
          } else {
            var d2r = exports.shapePositionToRange(axis);
            dataToPixel = function(v) {
              var shiftPixels = getPixelShift(axis, shift);
              return axis._offset + axis.r2p(d2r(v, true)) + shiftPixels;
            };
            if (axis.type === "date") dataToPixel = exports.decodeDate(dataToPixel);
          }
        } else if (isVertical) {
          dataToPixel = function(v) {
            return gs.t + gs.h * (1 - v);
          };
        } else {
          dataToPixel = function(v) {
            return gs.l + gs.w * v;
          };
        }
        return dataToPixel;
      };
      exports.getPixelToData = function(gd, axis, isVertical, opt) {
        var gs = gd._fullLayout._size;
        var pixelToData;
        if (axis) {
          if (opt === "domain") {
            pixelToData = function(p) {
              var q = (p - axis._offset) / axis._length;
              return isVertical ? 1 - q : q;
            };
          } else {
            var r2d = exports.rangeToShapePosition(axis);
            pixelToData = function(p) {
              return r2d(axis.p2r(p - axis._offset));
            };
          }
        } else if (isVertical) {
          pixelToData = function(p) {
            return 1 - (p - gs.t) / gs.h;
          };
        } else {
          pixelToData = function(p) {
            return (p - gs.l) / gs.w;
          };
        }
        return pixelToData;
      };
      exports.roundPositionForSharpStrokeRendering = function(pos, strokeWidth) {
        var strokeWidthIsOdd = Math.round(strokeWidth % 2) === 1;
        var posValAsInt = Math.round(pos);
        return strokeWidthIsOdd ? posValAsInt + 0.5 : posValAsInt;
      };
      exports.makeShapesOptionsAndPlotinfo = function(gd, index) {
        var options = gd._fullLayout.shapes[index] || {};
        var plotinfo = gd._fullLayout._plots[options.xref + options.yref];
        var hasPlotinfo = !!plotinfo;
        if (hasPlotinfo) {
          plotinfo._hadPlotinfo = true;
        } else {
          plotinfo = {};
          if (options.xref && options.xref !== "paper") plotinfo.xaxis = gd._fullLayout[options.xref + "axis"];
          if (options.yref && options.yref !== "paper") plotinfo.yaxis = gd._fullLayout[options.yref + "axis"];
        }
        plotinfo.xsizemode = options.xsizemode;
        plotinfo.ysizemode = options.ysizemode;
        plotinfo.xanchor = options.xanchor;
        plotinfo.yanchor = options.yanchor;
        return {
          options,
          plotinfo
        };
      };
      exports.makeSelectionsOptionsAndPlotinfo = function(gd, index) {
        var options = gd._fullLayout.selections[index] || {};
        var plotinfo = gd._fullLayout._plots[options.xref + options.yref];
        var hasPlotinfo = !!plotinfo;
        if (hasPlotinfo) {
          plotinfo._hadPlotinfo = true;
        } else {
          plotinfo = {};
          if (options.xref) plotinfo.xaxis = gd._fullLayout[options.xref + "axis"];
          if (options.yref) plotinfo.yaxis = gd._fullLayout[options.yref + "axis"];
        }
        return {
          options,
          plotinfo
        };
      };
      exports.getPathString = function(gd, options) {
        var type = options.type;
        var xRefType = Axes.getRefType(options.xref);
        var yRefType = Axes.getRefType(options.yref);
        var xa = Axes.getFromId(gd, options.xref);
        var ya = Axes.getFromId(gd, options.yref);
        var gs = gd._fullLayout._size;
        var x2r, x2p, y2r, y2p;
        var xShiftStart = getPixelShift(xa, options.x0shift);
        var xShiftEnd = getPixelShift(xa, options.x1shift);
        var yShiftStart = getPixelShift(ya, options.y0shift);
        var yShiftEnd = getPixelShift(ya, options.y1shift);
        var x0, x1, y0, y1;
        if (xa) {
          if (xRefType === "domain") {
            x2p = function(v) {
              return xa._offset + xa._length * v;
            };
          } else {
            x2r = exports.shapePositionToRange(xa);
            x2p = function(v) {
              return xa._offset + xa.r2p(x2r(v, true));
            };
          }
        } else {
          x2p = function(v) {
            return gs.l + gs.w * v;
          };
        }
        if (ya) {
          if (yRefType === "domain") {
            y2p = function(v) {
              return ya._offset + ya._length * (1 - v);
            };
          } else {
            y2r = exports.shapePositionToRange(ya);
            y2p = function(v) {
              return ya._offset + ya.r2p(y2r(v, true));
            };
          }
        } else {
          y2p = function(v) {
            return gs.t + gs.h * (1 - v);
          };
        }
        if (type === "path") {
          if (xa && xa.type === "date") x2p = exports.decodeDate(x2p);
          if (ya && ya.type === "date") y2p = exports.decodeDate(y2p);
          return convertPath(options, x2p, y2p);
        }
        if (options.xsizemode === "pixel") {
          var xAnchorPos = x2p(options.xanchor);
          x0 = xAnchorPos + options.x0 + xShiftStart;
          x1 = xAnchorPos + options.x1 + xShiftEnd;
        } else {
          x0 = x2p(options.x0) + xShiftStart;
          x1 = x2p(options.x1) + xShiftEnd;
        }
        if (options.ysizemode === "pixel") {
          var yAnchorPos = y2p(options.yanchor);
          y0 = yAnchorPos - options.y0 + yShiftStart;
          y1 = yAnchorPos - options.y1 + yShiftEnd;
        } else {
          y0 = y2p(options.y0) + yShiftStart;
          y1 = y2p(options.y1) + yShiftEnd;
        }
        if (type === "line") return "M" + x0 + "," + y0 + "L" + x1 + "," + y1;
        if (type === "rect") return "M" + x0 + "," + y0 + "H" + x1 + "V" + y1 + "H" + x0 + "Z";
        var cx = (x0 + x1) / 2;
        var cy = (y0 + y1) / 2;
        var rx = Math.abs(cx - x0);
        var ry = Math.abs(cy - y0);
        var rArc = "A" + rx + "," + ry;
        var rightPt = cx + rx + "," + cy;
        var topPt = cx + "," + (cy - ry);
        return "M" + rightPt + rArc + " 0 1,1 " + topPt + rArc + " 0 0,1 " + rightPt + "Z";
      };
      function convertPath(options, x2p, y2p) {
        var pathIn = options.path;
        var xSizemode = options.xsizemode;
        var ySizemode = options.ysizemode;
        var xAnchor = options.xanchor;
        var yAnchor = options.yanchor;
        return pathIn.replace(constants.segmentRE, function(segment) {
          var paramNumber = 0;
          var segmentType = segment.charAt(0);
          var xParams = constants.paramIsX[segmentType];
          var yParams = constants.paramIsY[segmentType];
          var nParams = constants.numParams[segmentType];
          var paramString = segment.substr(1).replace(constants.paramRE, function(param) {
            if (xParams[paramNumber]) {
              if (xSizemode === "pixel") param = x2p(xAnchor) + Number(param);
              else param = x2p(param);
            } else if (yParams[paramNumber]) {
              if (ySizemode === "pixel") param = y2p(yAnchor) - Number(param);
              else param = y2p(param);
            }
            paramNumber++;
            if (paramNumber > nParams) param = "X";
            return param;
          });
          if (paramNumber > nParams) {
            paramString = paramString.replace(/[\s,]*X.*/, "");
            Lib.log("Ignoring extra params in segment " + segment);
          }
          return segmentType + paramString;
        });
      }
      function getPixelShift(axis, shift) {
        shift = shift || 0;
        var shiftPixels = 0;
        if (shift && axis && (axis.type === "category" || axis.type === "multicategory")) {
          shiftPixels = (axis.r2p(1) - axis.r2p(0)) * shift;
        }
        return shiftPixels;
      }
    }
  });

  // src/components/shapes/display_labels.js
  var require_display_labels = __commonJS({
    "src/components/shapes/display_labels.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var svgTextUtils = require_svg_text_utils();
      var Drawing = require_drawing();
      var readPaths = require_helpers7().readPaths;
      var helpers = require_helpers8();
      var getPathString = helpers.getPathString;
      var shapeLabelTexttemplateVars = require_label_texttemplate();
      var FROM_TL = require_alignment().FROM_TL;
      module.exports = function drawLabel(gd, index, options, shapeGroup) {
        shapeGroup.selectAll(".shape-label").remove();
        if (!(options.label.text || options.label.texttemplate)) return;
        var text;
        if (options.label.texttemplate) {
          var templateValues = {};
          if (options.type !== "path") {
            var _xa = Axes.getFromId(gd, options.xref);
            var _ya = Axes.getFromId(gd, options.yref);
            for (var key in shapeLabelTexttemplateVars) {
              var val = shapeLabelTexttemplateVars[key](options, _xa, _ya);
              if (val !== void 0) templateValues[key] = val;
            }
          }
          text = Lib.texttemplateStringForShapes(
            options.label.texttemplate,
            {},
            gd._fullLayout._d3locale,
            templateValues
          );
        } else {
          text = options.label.text;
        }
        var labelGroupAttrs = {
          "data-index": index
        };
        var font = options.label.font;
        var labelTextAttrs = {
          "data-notex": 1
        };
        var labelGroup = shapeGroup.append("g").attr(labelGroupAttrs).classed("shape-label", true);
        var labelText = labelGroup.append("text").attr(labelTextAttrs).classed("shape-label-text", true).text(text);
        var shapex0, shapex1, shapey0, shapey1;
        if (options.path) {
          var d = getPathString(gd, options);
          var polygons = readPaths(d, gd);
          shapex0 = Infinity;
          shapey0 = Infinity;
          shapex1 = -Infinity;
          shapey1 = -Infinity;
          for (var i = 0; i < polygons.length; i++) {
            for (var j = 0; j < polygons[i].length; j++) {
              var p = polygons[i][j];
              for (var k = 1; k < p.length; k += 2) {
                var _x = p[k];
                var _y = p[k + 1];
                shapex0 = Math.min(shapex0, _x);
                shapex1 = Math.max(shapex1, _x);
                shapey0 = Math.min(shapey0, _y);
                shapey1 = Math.max(shapey1, _y);
              }
            }
          }
        } else {
          var xa = Axes.getFromId(gd, options.xref);
          var xShiftStart = options.x0shift;
          var xShiftEnd = options.x1shift;
          var xRefType = Axes.getRefType(options.xref);
          var ya = Axes.getFromId(gd, options.yref);
          var yShiftStart = options.y0shift;
          var yShiftEnd = options.y1shift;
          var yRefType = Axes.getRefType(options.yref);
          var x2p = function(v, shift) {
            var dataToPixel = helpers.getDataToPixel(gd, xa, shift, false, xRefType);
            return dataToPixel(v);
          };
          var y2p = function(v, shift) {
            var dataToPixel = helpers.getDataToPixel(gd, ya, shift, true, yRefType);
            return dataToPixel(v);
          };
          shapex0 = x2p(options.x0, xShiftStart);
          shapex1 = x2p(options.x1, xShiftEnd);
          shapey0 = y2p(options.y0, yShiftStart);
          shapey1 = y2p(options.y1, yShiftEnd);
        }
        var textangle = options.label.textangle;
        if (textangle === "auto") {
          if (options.type === "line") {
            textangle = calcTextAngle(shapex0, shapey0, shapex1, shapey1);
          } else {
            textangle = 0;
          }
        }
        labelText.call(function(s) {
          s.call(Drawing.font, font).attr({});
          svgTextUtils.convertToTspans(s, gd);
          return s;
        });
        var textBB = Drawing.bBox(labelText.node());
        var textPos = calcTextPosition(shapex0, shapey0, shapex1, shapey1, options, textangle, textBB);
        var textx = textPos.textx;
        var texty = textPos.texty;
        var xanchor = textPos.xanchor;
        labelText.attr({
          "text-anchor": {
            left: "start",
            center: "middle",
            right: "end"
          }[xanchor],
          y: texty,
          x: textx,
          transform: "rotate(" + textangle + "," + textx + "," + texty + ")"
        }).call(svgTextUtils.positionText, textx, texty);
      };
      function calcTextAngle(shapex0, shapey0, shapex1, shapey1) {
        var dy, dx;
        dx = Math.abs(shapex1 - shapex0);
        if (shapex1 >= shapex0) {
          dy = shapey0 - shapey1;
        } else {
          dy = shapey1 - shapey0;
        }
        return -180 / Math.PI * Math.atan2(dy, dx);
      }
      function calcTextPosition(shapex0, shapey0, shapex1, shapey1, shapeOptions, actualTextAngle, textBB) {
        var textPosition = shapeOptions.label.textposition;
        var textAngle = shapeOptions.label.textangle;
        var textPadding = shapeOptions.label.padding;
        var shapeType = shapeOptions.type;
        var textAngleRad = Math.PI / 180 * actualTextAngle;
        var sinA = Math.sin(textAngleRad);
        var cosA = Math.cos(textAngleRad);
        var xanchor = shapeOptions.label.xanchor;
        var yanchor = shapeOptions.label.yanchor;
        var textx, texty, paddingX, paddingY;
        if (shapeType === "line") {
          if (textPosition === "start") {
            textx = shapex0;
            texty = shapey0;
          } else if (textPosition === "end") {
            textx = shapex1;
            texty = shapey1;
          } else {
            textx = (shapex0 + shapex1) / 2;
            texty = (shapey0 + shapey1) / 2;
          }
          if (xanchor === "auto") {
            if (textPosition === "start") {
              if (textAngle === "auto") {
                if (shapex1 > shapex0) xanchor = "left";
                else if (shapex1 < shapex0) xanchor = "right";
                else xanchor = "center";
              } else {
                if (shapex1 > shapex0) xanchor = "right";
                else if (shapex1 < shapex0) xanchor = "left";
                else xanchor = "center";
              }
            } else if (textPosition === "end") {
              if (textAngle === "auto") {
                if (shapex1 > shapex0) xanchor = "right";
                else if (shapex1 < shapex0) xanchor = "left";
                else xanchor = "center";
              } else {
                if (shapex1 > shapex0) xanchor = "left";
                else if (shapex1 < shapex0) xanchor = "right";
                else xanchor = "center";
              }
            } else {
              xanchor = "center";
            }
          }
          var paddingConstantsX = { left: 1, center: 0, right: -1 };
          var paddingConstantsY = { bottom: -1, middle: 0, top: 1 };
          if (textAngle === "auto") {
            var paddingDirection = paddingConstantsY[yanchor];
            paddingX = -textPadding * sinA * paddingDirection;
            paddingY = textPadding * cosA * paddingDirection;
          } else {
            var paddingDirectionX = paddingConstantsX[xanchor];
            var paddingDirectionY = paddingConstantsY[yanchor];
            paddingX = textPadding * paddingDirectionX;
            paddingY = textPadding * paddingDirectionY;
          }
          textx = textx + paddingX;
          texty = texty + paddingY;
        } else {
          paddingX = textPadding + 3;
          if (textPosition.indexOf("right") !== -1) {
            textx = Math.max(shapex0, shapex1) - paddingX;
            if (xanchor === "auto") xanchor = "right";
          } else if (textPosition.indexOf("left") !== -1) {
            textx = Math.min(shapex0, shapex1) + paddingX;
            if (xanchor === "auto") xanchor = "left";
          } else {
            textx = (shapex0 + shapex1) / 2;
            if (xanchor === "auto") xanchor = "center";
          }
          if (textPosition.indexOf("top") !== -1) {
            texty = Math.min(shapey0, shapey1);
          } else if (textPosition.indexOf("bottom") !== -1) {
            texty = Math.max(shapey0, shapey1);
          } else {
            texty = (shapey0 + shapey1) / 2;
          }
          paddingY = textPadding;
          if (yanchor === "bottom") {
            texty = texty - paddingY;
          } else if (yanchor === "top") {
            texty = texty + paddingY;
          }
        }
        var shiftFraction = FROM_TL[yanchor];
        var baselineAdjust = shapeOptions.label.font.size;
        var textHeight = textBB.height;
        var xshift = (textHeight * shiftFraction - baselineAdjust) * sinA;
        var yshift = -(textHeight * shiftFraction - baselineAdjust) * cosA;
        return { textx: textx + xshift, texty: texty + yshift, xanchor };
      }
    }
  });

  // src/components/shapes/display_outlines.js
  var require_display_outlines = __commonJS({
    "src/components/shapes/display_outlines.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var dragElement = require_dragelement();
      var dragHelpers = require_helpers5();
      var drawMode = dragHelpers.drawMode;
      var selectMode = dragHelpers.selectMode;
      var Registry = require_registry();
      var Color = require_color();
      var constants = require_constants4();
      var i000 = constants.i000;
      var i090 = constants.i090;
      var i180 = constants.i180;
      var i270 = constants.i270;
      var handleOutline = require_handle_outline();
      var clearOutlineControllers = handleOutline.clearOutlineControllers;
      var helpers = require_helpers7();
      var pointsOnRectangle = helpers.pointsOnRectangle;
      var pointsOnEllipse = helpers.pointsOnEllipse;
      var writePaths = helpers.writePaths;
      var newShapes = require_newshapes().newShapes;
      var createShapeObj = require_newshapes().createShapeObj;
      var newSelections = require_newselections();
      var drawLabel = require_display_labels();
      module.exports = function displayOutlines(polygons, outlines, dragOptions, nCalls) {
        if (!nCalls) nCalls = 0;
        var gd = dragOptions.gd;
        function redraw() {
          displayOutlines(polygons, outlines, dragOptions, nCalls++);
          if (pointsOnEllipse(polygons[0]) || dragOptions.hasText) {
            update({ redrawing: true });
          }
        }
        function update(opts) {
          var updateObject = {};
          if (dragOptions.isActiveShape !== void 0) {
            dragOptions.isActiveShape = false;
            updateObject = newShapes(outlines, dragOptions);
          }
          if (dragOptions.isActiveSelection !== void 0) {
            dragOptions.isActiveSelection = false;
            updateObject = newSelections(outlines, dragOptions);
            gd._fullLayout._reselect = true;
          }
          if (Object.keys(updateObject).length) {
            Registry.call((opts || {}).redrawing ? "relayout" : "_guiRelayout", gd, updateObject);
          }
        }
        var fullLayout = gd._fullLayout;
        var zoomLayer = fullLayout._zoomlayer;
        var dragmode = dragOptions.dragmode;
        var isDrawMode = drawMode(dragmode);
        var isSelectMode = selectMode(dragmode);
        if (isDrawMode || isSelectMode) {
          gd._fullLayout._outlining = true;
        }
        clearOutlineControllers(gd);
        outlines.attr("d", writePaths(polygons));
        var vertexDragOptions;
        var groupDragOptions;
        var indexI;
        var indexJ;
        var copyPolygons;
        if (!nCalls && (dragOptions.isActiveShape || dragOptions.isActiveSelection)) {
          copyPolygons = recordPositions([], polygons);
          var g = zoomLayer.append("g").attr("class", "outline-controllers");
          addVertexControllers(g);
          addGroupControllers();
        }
        if (isDrawMode && dragOptions.hasText) {
          var shapeGroup = zoomLayer.select(".label-temp");
          var shapeOptions = createShapeObj(outlines, dragOptions, dragOptions.dragmode);
          drawLabel(gd, "label-temp", shapeOptions, shapeGroup);
        }
        function startDragVertex(evt) {
          indexI = +evt.srcElement.getAttribute("data-i");
          indexJ = +evt.srcElement.getAttribute("data-j");
          vertexDragOptions[indexI][indexJ].moveFn = moveVertexController;
        }
        function moveVertexController(dx, dy) {
          if (!polygons.length) return;
          var x0 = copyPolygons[indexI][indexJ][1];
          var y0 = copyPolygons[indexI][indexJ][2];
          var cell = polygons[indexI];
          var len = cell.length;
          if (pointsOnRectangle(cell)) {
            var _dx = dx;
            var _dy = dy;
            if (dragOptions.isActiveSelection) {
              var nextPoint = getNextPoint(cell, indexJ);
              if (nextPoint[1] === cell[indexJ][1]) {
                _dy = 0;
              } else {
                _dx = 0;
              }
            }
            for (var q = 0; q < len; q++) {
              if (q === indexJ) continue;
              var pos = cell[q];
              if (pos[1] === cell[indexJ][1]) {
                pos[1] = x0 + _dx;
              }
              if (pos[2] === cell[indexJ][2]) {
                pos[2] = y0 + _dy;
              }
            }
            cell[indexJ][1] = x0 + _dx;
            cell[indexJ][2] = y0 + _dy;
            if (!pointsOnRectangle(cell)) {
              for (var j = 0; j < len; j++) {
                for (var k = 0; k < cell[j].length; k++) {
                  cell[j][k] = copyPolygons[indexI][j][k];
                }
              }
            }
          } else {
            cell[indexJ][1] = x0 + dx;
            cell[indexJ][2] = y0 + dy;
          }
          redraw();
        }
        function endDragVertexController() {
          update();
        }
        function removeVertex() {
          if (!polygons.length) return;
          if (!polygons[indexI]) return;
          if (!polygons[indexI].length) return;
          var newPolygon = [];
          for (var j = 0; j < polygons[indexI].length; j++) {
            if (j !== indexJ) {
              newPolygon.push(
                polygons[indexI][j]
              );
            }
          }
          if (newPolygon.length > 1 && !(newPolygon.length === 2 && newPolygon[1][0] === "Z")) {
            if (indexJ === 0) {
              newPolygon[0][0] = "M";
            }
            polygons[indexI] = newPolygon;
            redraw();
            update();
          }
        }
        function clickVertexController(numClicks, evt) {
          if (numClicks === 2) {
            indexI = +evt.srcElement.getAttribute("data-i");
            indexJ = +evt.srcElement.getAttribute("data-j");
            var cell = polygons[indexI];
            if (!pointsOnRectangle(cell) && !pointsOnEllipse(cell)) {
              removeVertex();
            }
          }
        }
        function addVertexControllers(g2) {
          vertexDragOptions = [];
          for (var i = 0; i < polygons.length; i++) {
            var cell = polygons[i];
            var onRect = pointsOnRectangle(cell);
            var onEllipse = !onRect && pointsOnEllipse(cell);
            vertexDragOptions[i] = [];
            var len = cell.length;
            for (var j = 0; j < len; j++) {
              if (cell[j][0] === "Z") continue;
              if (onEllipse && j !== i000 && j !== i090 && j !== i180 && j !== i270) {
                continue;
              }
              var rectSelection = onRect && dragOptions.isActiveSelection;
              var nextPoint;
              if (rectSelection) nextPoint = getNextPoint(cell, j);
              var x = cell[j][1];
              var y = cell[j][2];
              var vertex = g2.append(rectSelection ? "rect" : "circle").attr("data-i", i).attr("data-j", j).style({
                fill: Color.background,
                stroke: Color.defaultLine,
                "stroke-width": 1,
                "shape-rendering": "crispEdges"
              });
              if (rectSelection) {
                var dx = nextPoint[1] - x;
                var dy = nextPoint[2] - y;
                var width = dy ? 5 : Math.max(Math.min(25, Math.abs(dx) - 5), 5);
                var height = dx ? 5 : Math.max(Math.min(25, Math.abs(dy) - 5), 5);
                vertex.classed(dy ? "cursor-ew-resize" : "cursor-ns-resize", true).attr("width", width).attr("height", height).attr("x", x - width / 2).attr("y", y - height / 2).attr("transform", strTranslate(dx / 2, dy / 2));
              } else {
                vertex.classed("cursor-grab", true).attr("r", 5).attr("cx", x).attr("cy", y);
              }
              vertexDragOptions[i][j] = {
                element: vertex.node(),
                gd,
                prepFn: startDragVertex,
                doneFn: endDragVertexController,
                clickFn: clickVertexController
              };
              dragElement.init(vertexDragOptions[i][j]);
            }
          }
        }
        function moveGroup(dx, dy) {
          if (!polygons.length) return;
          for (var i = 0; i < polygons.length; i++) {
            for (var j = 0; j < polygons[i].length; j++) {
              for (var k = 0; k + 2 < polygons[i][j].length; k += 2) {
                polygons[i][j][k + 1] = copyPolygons[i][j][k + 1] + dx;
                polygons[i][j][k + 2] = copyPolygons[i][j][k + 2] + dy;
              }
            }
          }
        }
        function moveGroupController(dx, dy) {
          moveGroup(dx, dy);
          redraw();
        }
        function startDragGroupController(evt) {
          indexI = +evt.srcElement.getAttribute("data-i");
          if (!indexI) indexI = 0;
          groupDragOptions[indexI].moveFn = moveGroupController;
        }
        function endDragGroupController() {
          update();
        }
        function clickGroupController(numClicks) {
          if (numClicks === 2) {
            eraseActiveSelection(gd);
          }
        }
        function addGroupControllers() {
          groupDragOptions = [];
          if (!polygons.length) return;
          var i = 0;
          groupDragOptions[i] = {
            element: outlines[0][0],
            gd,
            prepFn: startDragGroupController,
            doneFn: endDragGroupController,
            clickFn: clickGroupController
          };
          dragElement.init(groupDragOptions[i]);
        }
      };
      function recordPositions(polygonsOut, polygonsIn) {
        for (var i = 0; i < polygonsIn.length; i++) {
          var cell = polygonsIn[i];
          polygonsOut[i] = [];
          for (var j = 0; j < cell.length; j++) {
            polygonsOut[i][j] = [];
            for (var k = 0; k < cell[j].length; k++) {
              polygonsOut[i][j][k] = cell[j][k];
            }
          }
        }
        return polygonsOut;
      }
      function getNextPoint(cell, j) {
        var x = cell[j][1];
        var y = cell[j][2];
        var len = cell.length;
        var nextJ, nextX, nextY;
        nextJ = (j + 1) % len;
        nextX = cell[nextJ][1];
        nextY = cell[nextJ][2];
        if (nextX === x && nextY === y) {
          nextJ = (j + 2) % len;
          nextX = cell[nextJ][1];
          nextY = cell[nextJ][2];
        }
        return [nextJ, nextX, nextY];
      }
      function eraseActiveSelection(gd) {
        if (!selectMode(gd._fullLayout.dragmode)) return;
        clearOutlineControllers(gd);
        var id = gd._fullLayout._activeSelectionIndex;
        var selections = (gd.layout || {}).selections || [];
        if (id < selections.length) {
          var list = [];
          for (var q = 0; q < selections.length; q++) {
            if (q !== id) {
              list.push(selections[q]);
            }
          }
          delete gd._fullLayout._activeSelectionIndex;
          var erasedSelection = gd._fullLayout.selections[id];
          gd._fullLayout._deselect = {
            xref: erasedSelection.xref,
            yref: erasedSelection.yref
          };
          Registry.call("_guiRelayout", gd, {
            selections: list
          });
        }
      }
    }
  });

  // src/components/shapes/draw.js
  var require_draw2 = __commonJS({
    "src/components/shapes/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Lib = require_lib();
      var Axes = require_axes();
      var readPaths = require_helpers7().readPaths;
      var displayOutlines = require_display_outlines();
      var drawLabel = require_display_labels();
      var clearOutlineControllers = require_handle_outline().clearOutlineControllers;
      var Color = require_color();
      var Drawing = require_drawing();
      var arrayEditor = require_plot_template().arrayEditor;
      var dragElement = require_dragelement();
      var setCursor = require_setcursor();
      var constants = require_constants5();
      var helpers = require_helpers8();
      var getPathString = helpers.getPathString;
      module.exports = {
        draw,
        drawOne,
        eraseActiveShape,
        drawLabel
      };
      function draw(gd) {
        var fullLayout = gd._fullLayout;
        fullLayout._shapeUpperLayer.selectAll("path").remove();
        fullLayout._shapeLowerLayer.selectAll("path").remove();
        fullLayout._shapeUpperLayer.selectAll("text").remove();
        fullLayout._shapeLowerLayer.selectAll("text").remove();
        for (var k in fullLayout._plots) {
          var shapelayer = fullLayout._plots[k].shapelayer;
          if (shapelayer) {
            shapelayer.selectAll("path").remove();
            shapelayer.selectAll("text").remove();
          }
        }
        for (var i = 0; i < fullLayout.shapes.length; i++) {
          if (fullLayout.shapes[i].visible === true) {
            drawOne(gd, i);
          }
        }
      }
      function shouldSkipEdits(gd) {
        return !!gd._fullLayout._outlining;
      }
      function couldHaveActiveShape(gd) {
        return !gd._context.edits.shapePosition;
      }
      function drawOne(gd, index) {
        gd._fullLayout._paperdiv.selectAll('.shapelayer [data-index="' + index + '"]').remove();
        var o = helpers.makeShapesOptionsAndPlotinfo(gd, index);
        var options = o.options;
        var plotinfo = o.plotinfo;
        if (!options._input || options.visible !== true) return;
        if (options.layer === "above") {
          drawShape(gd._fullLayout._shapeUpperLayer);
        } else if (options.xref === "paper" || options.yref === "paper") {
          drawShape(gd._fullLayout._shapeLowerLayer);
        } else if (options.layer === "between") {
          drawShape(plotinfo.shapelayerBetween);
        } else {
          if (plotinfo._hadPlotinfo) {
            var mainPlot = plotinfo.mainplotinfo || plotinfo;
            drawShape(mainPlot.shapelayer);
          } else {
            drawShape(gd._fullLayout._shapeLowerLayer);
          }
        }
        function drawShape(shapeLayer) {
          var d = getPathString(gd, options);
          var attrs = {
            "data-index": index,
            "fill-rule": options.fillrule,
            d
          };
          var opacity = options.opacity;
          var fillColor = options.fillcolor;
          var lineColor = options.line.width ? options.line.color : "rgba(0,0,0,0)";
          var lineWidth = options.line.width;
          var lineDash = options.line.dash;
          if (!lineWidth && options.editable === true) {
            lineWidth = 5;
            lineDash = "solid";
          }
          var isOpen = d[d.length - 1] !== "Z";
          var isActiveShape = couldHaveActiveShape(gd) && options.editable && gd._fullLayout._activeShapeIndex === index;
          if (isActiveShape) {
            fillColor = isOpen ? "rgba(0,0,0,0)" : gd._fullLayout.activeshape.fillcolor;
            opacity = gd._fullLayout.activeshape.opacity;
          }
          var shapeGroup = shapeLayer.append("g").classed("shape-group", true).attr({ "data-index": index });
          var path = shapeGroup.append("path").attr(attrs).style("opacity", opacity).call(Color.stroke, lineColor).call(Color.fill, fillColor).call(Drawing.dashLine, lineDash, lineWidth);
          setClipPath(shapeGroup, gd, options);
          drawLabel(gd, index, options, shapeGroup);
          var editHelpers;
          if (isActiveShape || gd._context.edits.shapePosition) editHelpers = arrayEditor(gd.layout, "shapes", options);
          if (isActiveShape) {
            path.style({
              cursor: "move"
            });
            var dragOptions = {
              element: path.node(),
              plotinfo,
              gd,
              editHelpers,
              hasText: options.label.text || options.label.texttemplate,
              isActiveShape: true
              // i.e. to enable controllers
            };
            var polygons = readPaths(d, gd);
            displayOutlines(polygons, path, dragOptions);
          } else {
            if (gd._context.edits.shapePosition) {
              setupDragElement(gd, path, options, index, shapeLayer, editHelpers);
            } else if (options.editable === true) {
              path.style(
                "pointer-events",
                isOpen || Color.opacity(fillColor) * opacity <= 0.5 ? "stroke" : "all"
              );
            }
          }
          path.node().addEventListener("click", function() {
            return activateShape(gd, path);
          });
        }
      }
      function setClipPath(shapePath, gd, shapeOptions) {
        var clipAxes = (shapeOptions.xref + shapeOptions.yref).replace(/paper/g, "").replace(/[xyz][1-9]* *domain/g, "");
        Drawing.setClipUrl(
          shapePath,
          clipAxes ? "clip" + gd._fullLayout._uid + clipAxes : null,
          gd
        );
      }
      function setupDragElement(gd, shapePath, shapeOptions, index, shapeLayer, editHelpers) {
        var MINWIDTH = 10;
        var MINHEIGHT = 10;
        var xPixelSized = shapeOptions.xsizemode === "pixel";
        var yPixelSized = shapeOptions.ysizemode === "pixel";
        var isLine = shapeOptions.type === "line";
        var isPath = shapeOptions.type === "path";
        var modifyItem = editHelpers.modifyItem;
        var x0, y0, x1, y1, xAnchor, yAnchor;
        var n0, s0, w0, e0, optN, optS, optW, optE;
        var pathIn;
        var shapeGroup = d3.select(shapePath.node().parentNode);
        var xa = Axes.getFromId(gd, shapeOptions.xref);
        var xRefType = Axes.getRefType(shapeOptions.xref);
        var ya = Axes.getFromId(gd, shapeOptions.yref);
        var yRefType = Axes.getRefType(shapeOptions.yref);
        var shiftXStart = shapeOptions.x0shift;
        var shiftXEnd = shapeOptions.x1shift;
        var shiftYStart = shapeOptions.y0shift;
        var shiftYEnd = shapeOptions.y1shift;
        var x2p = function(v, shift) {
          var dataToPixel = helpers.getDataToPixel(gd, xa, shift, false, xRefType);
          return dataToPixel(v);
        };
        var y2p = function(v, shift) {
          var dataToPixel = helpers.getDataToPixel(gd, ya, shift, true, yRefType);
          return dataToPixel(v);
        };
        var p2x = helpers.getPixelToData(gd, xa, false, xRefType);
        var p2y = helpers.getPixelToData(gd, ya, true, yRefType);
        var sensoryElement = obtainSensoryElement();
        var dragOptions = {
          element: sensoryElement.node(),
          gd,
          prepFn: startDrag,
          doneFn: endDrag,
          clickFn: abortDrag
        };
        var dragMode;
        dragElement.init(dragOptions);
        sensoryElement.node().onmousemove = updateDragMode;
        function obtainSensoryElement() {
          return isLine ? createLineDragHandles() : shapePath;
        }
        function createLineDragHandles() {
          var minSensoryWidth = 10;
          var sensoryWidth = Math.max(shapeOptions.line.width, minSensoryWidth);
          var g = shapeLayer.append("g").attr("data-index", index).attr("drag-helper", true);
          g.append("path").attr("d", shapePath.attr("d")).style({
            cursor: "move",
            "stroke-width": sensoryWidth,
            "stroke-opacity": "0"
            // ensure not visible
          });
          var circleStyle = {
            "fill-opacity": "0"
            // ensure not visible
          };
          var circleRadius = Math.max(sensoryWidth / 2, minSensoryWidth);
          g.append("circle").attr({
            "data-line-point": "start-point",
            cx: xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x0 : x2p(shapeOptions.x0, shiftXStart),
            cy: yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y0 : y2p(shapeOptions.y0, shiftYStart),
            r: circleRadius
          }).style(circleStyle).classed("cursor-grab", true);
          g.append("circle").attr({
            "data-line-point": "end-point",
            cx: xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x1 : x2p(shapeOptions.x1, shiftXEnd),
            cy: yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y1 : y2p(shapeOptions.y1, shiftYEnd),
            r: circleRadius
          }).style(circleStyle).classed("cursor-grab", true);
          return g;
        }
        function updateDragMode(evt) {
          if (shouldSkipEdits(gd)) {
            dragMode = null;
            return;
          }
          if (isLine) {
            if (evt.target.tagName === "path") {
              dragMode = "move";
            } else {
              dragMode = evt.target.attributes["data-line-point"].value === "start-point" ? "resize-over-start-point" : "resize-over-end-point";
            }
          } else {
            var dragBBox = dragOptions.element.getBoundingClientRect();
            var w = dragBBox.right - dragBBox.left;
            var h = dragBBox.bottom - dragBBox.top;
            var x = evt.clientX - dragBBox.left;
            var y = evt.clientY - dragBBox.top;
            var cursor = !isPath && w > MINWIDTH && h > MINHEIGHT && !evt.shiftKey ? dragElement.getCursor(x / w, 1 - y / h) : "move";
            setCursor(shapePath, cursor);
            dragMode = cursor.split("-")[0];
          }
        }
        function startDrag(evt) {
          if (shouldSkipEdits(gd)) return;
          if (xPixelSized) {
            xAnchor = x2p(shapeOptions.xanchor);
          }
          if (yPixelSized) {
            yAnchor = y2p(shapeOptions.yanchor);
          }
          if (shapeOptions.type === "path") {
            pathIn = shapeOptions.path;
          } else {
            x0 = xPixelSized ? shapeOptions.x0 : x2p(shapeOptions.x0);
            y0 = yPixelSized ? shapeOptions.y0 : y2p(shapeOptions.y0);
            x1 = xPixelSized ? shapeOptions.x1 : x2p(shapeOptions.x1);
            y1 = yPixelSized ? shapeOptions.y1 : y2p(shapeOptions.y1);
          }
          if (x0 < x1) {
            w0 = x0;
            optW = "x0";
            e0 = x1;
            optE = "x1";
          } else {
            w0 = x1;
            optW = "x1";
            e0 = x0;
            optE = "x0";
          }
          if (!yPixelSized && y0 < y1 || yPixelSized && y0 > y1) {
            n0 = y0;
            optN = "y0";
            s0 = y1;
            optS = "y1";
          } else {
            n0 = y1;
            optN = "y1";
            s0 = y0;
            optS = "y0";
          }
          updateDragMode(evt);
          renderVisualCues(shapeLayer, shapeOptions);
          deactivateClipPathTemporarily(shapePath, shapeOptions, gd);
          dragOptions.moveFn = dragMode === "move" ? moveShape : resizeShape;
          dragOptions.altKey = evt.altKey;
        }
        function endDrag() {
          if (shouldSkipEdits(gd)) return;
          setCursor(shapePath);
          removeVisualCues(shapeLayer);
          setClipPath(shapePath, gd, shapeOptions);
          Registry.call("_guiRelayout", gd, editHelpers.getUpdateObj());
        }
        function abortDrag() {
          if (shouldSkipEdits(gd)) return;
          removeVisualCues(shapeLayer);
        }
        function moveShape(dx, dy) {
          if (shapeOptions.type === "path") {
            var noOp = function(coord) {
              return coord;
            };
            var moveX = noOp;
            var moveY = noOp;
            if (xPixelSized) {
              modifyItem("xanchor", shapeOptions.xanchor = p2x(xAnchor + dx));
            } else {
              moveX = function moveX2(x) {
                return p2x(x2p(x) + dx);
              };
              if (xa && xa.type === "date") moveX = helpers.encodeDate(moveX);
            }
            if (yPixelSized) {
              modifyItem("yanchor", shapeOptions.yanchor = p2y(yAnchor + dy));
            } else {
              moveY = function moveY2(y) {
                return p2y(y2p(y) + dy);
              };
              if (ya && ya.type === "date") moveY = helpers.encodeDate(moveY);
            }
            modifyItem("path", shapeOptions.path = movePath(pathIn, moveX, moveY));
          } else {
            if (xPixelSized) {
              modifyItem("xanchor", shapeOptions.xanchor = p2x(xAnchor + dx));
            } else {
              modifyItem("x0", shapeOptions.x0 = p2x(x0 + dx));
              modifyItem("x1", shapeOptions.x1 = p2x(x1 + dx));
            }
            if (yPixelSized) {
              modifyItem("yanchor", shapeOptions.yanchor = p2y(yAnchor + dy));
            } else {
              modifyItem("y0", shapeOptions.y0 = p2y(y0 + dy));
              modifyItem("y1", shapeOptions.y1 = p2y(y1 + dy));
            }
          }
          shapePath.attr("d", getPathString(gd, shapeOptions));
          renderVisualCues(shapeLayer, shapeOptions);
          drawLabel(gd, index, shapeOptions, shapeGroup);
        }
        function resizeShape(dx, dy) {
          if (isPath) {
            var noOp = function(coord) {
              return coord;
            };
            var moveX = noOp;
            var moveY = noOp;
            if (xPixelSized) {
              modifyItem("xanchor", shapeOptions.xanchor = p2x(xAnchor + dx));
            } else {
              moveX = function moveX2(x) {
                return p2x(x2p(x) + dx);
              };
              if (xa && xa.type === "date") moveX = helpers.encodeDate(moveX);
            }
            if (yPixelSized) {
              modifyItem("yanchor", shapeOptions.yanchor = p2y(yAnchor + dy));
            } else {
              moveY = function moveY2(y) {
                return p2y(y2p(y) + dy);
              };
              if (ya && ya.type === "date") moveY = helpers.encodeDate(moveY);
            }
            modifyItem("path", shapeOptions.path = movePath(pathIn, moveX, moveY));
          } else if (isLine) {
            if (dragMode === "resize-over-start-point") {
              var newX0 = x0 + dx;
              var newY0 = yPixelSized ? y0 - dy : y0 + dy;
              modifyItem("x0", shapeOptions.x0 = xPixelSized ? newX0 : p2x(newX0));
              modifyItem("y0", shapeOptions.y0 = yPixelSized ? newY0 : p2y(newY0));
            } else if (dragMode === "resize-over-end-point") {
              var newX1 = x1 + dx;
              var newY1 = yPixelSized ? y1 - dy : y1 + dy;
              modifyItem("x1", shapeOptions.x1 = xPixelSized ? newX1 : p2x(newX1));
              modifyItem("y1", shapeOptions.y1 = yPixelSized ? newY1 : p2y(newY1));
            }
          } else {
            var has = function(str) {
              return dragMode.indexOf(str) !== -1;
            };
            var hasN = has("n");
            var hasS = has("s");
            var hasW = has("w");
            var hasE = has("e");
            var newN = hasN ? n0 + dy : n0;
            var newS = hasS ? s0 + dy : s0;
            var newW = hasW ? w0 + dx : w0;
            var newE = hasE ? e0 + dx : e0;
            if (yPixelSized) {
              if (hasN) newN = n0 - dy;
              if (hasS) newS = s0 - dy;
            }
            if (!yPixelSized && newS - newN > MINHEIGHT || yPixelSized && newN - newS > MINHEIGHT) {
              modifyItem(optN, shapeOptions[optN] = yPixelSized ? newN : p2y(newN));
              modifyItem(optS, shapeOptions[optS] = yPixelSized ? newS : p2y(newS));
            }
            if (newE - newW > MINWIDTH) {
              modifyItem(optW, shapeOptions[optW] = xPixelSized ? newW : p2x(newW));
              modifyItem(optE, shapeOptions[optE] = xPixelSized ? newE : p2x(newE));
            }
          }
          shapePath.attr("d", getPathString(gd, shapeOptions));
          renderVisualCues(shapeLayer, shapeOptions);
          drawLabel(gd, index, shapeOptions, shapeGroup);
        }
        function renderVisualCues(shapeLayer2, shapeOptions2) {
          if (xPixelSized || yPixelSized) {
            renderAnchor();
          }
          function renderAnchor() {
            var isNotPath = shapeOptions2.type !== "path";
            var visualCues = shapeLayer2.selectAll(".visual-cue").data([0]);
            var strokeWidth = 1;
            visualCues.enter().append("path").attr({
              fill: "#fff",
              "fill-rule": "evenodd",
              stroke: "#000",
              "stroke-width": strokeWidth
            }).classed("visual-cue", true);
            var posX = x2p(
              xPixelSized ? shapeOptions2.xanchor : Lib.midRange(
                isNotPath ? [shapeOptions2.x0, shapeOptions2.x1] : helpers.extractPathCoords(shapeOptions2.path, constants.paramIsX)
              )
            );
            var posY = y2p(
              yPixelSized ? shapeOptions2.yanchor : Lib.midRange(
                isNotPath ? [shapeOptions2.y0, shapeOptions2.y1] : helpers.extractPathCoords(shapeOptions2.path, constants.paramIsY)
              )
            );
            posX = helpers.roundPositionForSharpStrokeRendering(posX, strokeWidth);
            posY = helpers.roundPositionForSharpStrokeRendering(posY, strokeWidth);
            if (xPixelSized && yPixelSized) {
              var crossPath = "M" + (posX - 1 - strokeWidth) + "," + (posY - 1 - strokeWidth) + "h-8v2h8 v8h2v-8 h8v-2h-8 v-8h-2 Z";
              visualCues.attr("d", crossPath);
            } else if (xPixelSized) {
              var vBarPath = "M" + (posX - 1 - strokeWidth) + "," + (posY - 9 - strokeWidth) + "v18 h2 v-18 Z";
              visualCues.attr("d", vBarPath);
            } else {
              var hBarPath = "M" + (posX - 9 - strokeWidth) + "," + (posY - 1 - strokeWidth) + "h18 v2 h-18 Z";
              visualCues.attr("d", hBarPath);
            }
          }
        }
        function removeVisualCues(shapeLayer2) {
          shapeLayer2.selectAll(".visual-cue").remove();
        }
        function deactivateClipPathTemporarily(shapePath2, shapeOptions2, gd2) {
          var xref = shapeOptions2.xref;
          var yref = shapeOptions2.yref;
          var xa2 = Axes.getFromId(gd2, xref);
          var ya2 = Axes.getFromId(gd2, yref);
          var clipAxes = "";
          if (xref !== "paper" && !xa2.autorange) clipAxes += xref;
          if (yref !== "paper" && !ya2.autorange) clipAxes += yref;
          Drawing.setClipUrl(
            shapePath2,
            clipAxes ? "clip" + gd2._fullLayout._uid + clipAxes : null,
            gd2
          );
        }
      }
      function movePath(pathIn, moveX, moveY) {
        return pathIn.replace(constants.segmentRE, function(segment) {
          var paramNumber = 0;
          var segmentType = segment.charAt(0);
          var xParams = constants.paramIsX[segmentType];
          var yParams = constants.paramIsY[segmentType];
          var nParams = constants.numParams[segmentType];
          var paramString = segment.substr(1).replace(constants.paramRE, function(param) {
            if (paramNumber >= nParams) return param;
            if (xParams[paramNumber]) param = moveX(param);
            else if (yParams[paramNumber]) param = moveY(param);
            paramNumber++;
            return param;
          });
          return segmentType + paramString;
        });
      }
      function activateShape(gd, path) {
        if (!couldHaveActiveShape(gd)) return;
        var element = path.node();
        var id = +element.getAttribute("data-index");
        if (id >= 0) {
          if (id === gd._fullLayout._activeShapeIndex) {
            deactivateShape(gd);
            return;
          }
          gd._fullLayout._activeShapeIndex = id;
          gd._fullLayout._deactivateShape = deactivateShape;
          draw(gd);
        }
      }
      function deactivateShape(gd) {
        if (!couldHaveActiveShape(gd)) return;
        var id = gd._fullLayout._activeShapeIndex;
        if (id >= 0) {
          clearOutlineControllers(gd);
          delete gd._fullLayout._activeShapeIndex;
          draw(gd);
        }
      }
      function eraseActiveShape(gd) {
        if (!couldHaveActiveShape(gd)) return;
        clearOutlineControllers(gd);
        var id = gd._fullLayout._activeShapeIndex;
        var shapes = (gd.layout || {}).shapes || [];
        if (id < shapes.length) {
          var list = [];
          for (var q = 0; q < shapes.length; q++) {
            if (q !== id) {
              list.push(shapes[q]);
            }
          }
          delete gd._fullLayout._activeShapeIndex;
          return Registry.call("_guiRelayout", gd, {
            shapes: list
          });
        }
      }
    }
  });

  // src/components/modebar/buttons.js
  var require_buttons = __commonJS({
    "src/components/modebar/buttons.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Plots = require_plots();
      var axisIds = require_axis_ids();
      var Icons = require_ploticon();
      var eraseActiveShape = require_draw2().eraseActiveShape;
      var Lib = require_lib();
      var _ = Lib._;
      var modeBarButtons = module.exports = {};
      modeBarButtons.toImage = {
        name: "toImage",
        title: function(gd) {
          var opts = gd._context.toImageButtonOptions || {};
          var format = opts.format || "png";
          return format === "png" ? _(gd, "Download plot as a png") : (
            // legacy text
            _(gd, "Download plot")
          );
        },
        icon: Icons.camera,
        click: function(gd) {
          var toImageButtonOptions = gd._context.toImageButtonOptions;
          var opts = { format: toImageButtonOptions.format || "png" };
          Lib.notifier(_(gd, "Taking snapshot - this may take a few seconds"), "long");
          ["filename", "width", "height", "scale"].forEach(function(key) {
            if (key in toImageButtonOptions) {
              opts[key] = toImageButtonOptions[key];
            }
          });
          Registry.call("downloadImage", gd, opts).then(function(filename) {
            Lib.notifier(_(gd, "Snapshot succeeded") + " - " + filename, "long");
          }).catch(function() {
            Lib.notifier(_(gd, "Sorry, there was a problem downloading your snapshot!"), "long");
          });
        }
      };
      modeBarButtons.sendDataToCloud = {
        name: "sendDataToCloud",
        title: function(gd) {
          return _(gd, "Edit in Chart Studio");
        },
        icon: Icons.disk,
        click: function(gd) {
          Plots.sendDataToCloud(gd);
        }
      };
      modeBarButtons.editInChartStudio = {
        name: "editInChartStudio",
        title: function(gd) {
          return _(gd, "Edit in Chart Studio");
        },
        icon: Icons.pencil,
        click: function(gd) {
          Plots.sendDataToCloud(gd);
        }
      };
      modeBarButtons.zoom2d = {
        name: "zoom2d",
        _cat: "zoom",
        title: function(gd) {
          return _(gd, "Zoom");
        },
        attr: "dragmode",
        val: "zoom",
        icon: Icons.zoombox,
        click: handleCartesian
      };
      modeBarButtons.pan2d = {
        name: "pan2d",
        _cat: "pan",
        title: function(gd) {
          return _(gd, "Pan");
        },
        attr: "dragmode",
        val: "pan",
        icon: Icons.pan,
        click: handleCartesian
      };
      modeBarButtons.select2d = {
        name: "select2d",
        _cat: "select",
        title: function(gd) {
          return _(gd, "Box Select");
        },
        attr: "dragmode",
        val: "select",
        icon: Icons.selectbox,
        click: handleCartesian
      };
      modeBarButtons.lasso2d = {
        name: "lasso2d",
        _cat: "lasso",
        title: function(gd) {
          return _(gd, "Lasso Select");
        },
        attr: "dragmode",
        val: "lasso",
        icon: Icons.lasso,
        click: handleCartesian
      };
      modeBarButtons.drawclosedpath = {
        name: "drawclosedpath",
        title: function(gd) {
          return _(gd, "Draw closed freeform");
        },
        attr: "dragmode",
        val: "drawclosedpath",
        icon: Icons.drawclosedpath,
        click: handleCartesian
      };
      modeBarButtons.drawopenpath = {
        name: "drawopenpath",
        title: function(gd) {
          return _(gd, "Draw open freeform");
        },
        attr: "dragmode",
        val: "drawopenpath",
        icon: Icons.drawopenpath,
        click: handleCartesian
      };
      modeBarButtons.drawline = {
        name: "drawline",
        title: function(gd) {
          return _(gd, "Draw line");
        },
        attr: "dragmode",
        val: "drawline",
        icon: Icons.drawline,
        click: handleCartesian
      };
      modeBarButtons.drawrect = {
        name: "drawrect",
        title: function(gd) {
          return _(gd, "Draw rectangle");
        },
        attr: "dragmode",
        val: "drawrect",
        icon: Icons.drawrect,
        click: handleCartesian
      };
      modeBarButtons.drawcircle = {
        name: "drawcircle",
        title: function(gd) {
          return _(gd, "Draw circle");
        },
        attr: "dragmode",
        val: "drawcircle",
        icon: Icons.drawcircle,
        click: handleCartesian
      };
      modeBarButtons.eraseshape = {
        name: "eraseshape",
        title: function(gd) {
          return _(gd, "Erase active shape");
        },
        icon: Icons.eraseshape,
        click: eraseActiveShape
      };
      modeBarButtons.zoomIn2d = {
        name: "zoomIn2d",
        _cat: "zoomin",
        title: function(gd) {
          return _(gd, "Zoom in");
        },
        attr: "zoom",
        val: "in",
        icon: Icons.zoom_plus,
        click: handleCartesian
      };
      modeBarButtons.zoomOut2d = {
        name: "zoomOut2d",
        _cat: "zoomout",
        title: function(gd) {
          return _(gd, "Zoom out");
        },
        attr: "zoom",
        val: "out",
        icon: Icons.zoom_minus,
        click: handleCartesian
      };
      modeBarButtons.autoScale2d = {
        name: "autoScale2d",
        _cat: "autoscale",
        title: function(gd) {
          return _(gd, "Autoscale");
        },
        attr: "zoom",
        val: "auto",
        icon: Icons.autoscale,
        click: handleCartesian
      };
      modeBarButtons.resetScale2d = {
        name: "resetScale2d",
        _cat: "resetscale",
        title: function(gd) {
          return _(gd, "Reset axes");
        },
        attr: "zoom",
        val: "reset",
        icon: Icons.home,
        click: handleCartesian
      };
      modeBarButtons.hoverClosestCartesian = {
        name: "hoverClosestCartesian",
        _cat: "hoverclosest",
        title: function(gd) {
          return _(gd, "Show closest data on hover");
        },
        attr: "hovermode",
        val: "closest",
        icon: Icons.tooltip_basic,
        gravity: "ne",
        click: handleCartesian
      };
      modeBarButtons.hoverCompareCartesian = {
        name: "hoverCompareCartesian",
        _cat: "hoverCompare",
        title: function(gd) {
          return _(gd, "Compare data on hover");
        },
        attr: "hovermode",
        val: function(gd) {
          return gd._fullLayout._isHoriz ? "y" : "x";
        },
        icon: Icons.tooltip_compare,
        gravity: "ne",
        click: handleCartesian
      };
      function handleCartesian(gd, ev) {
        var button = ev.currentTarget;
        var astr = button.getAttribute("data-attr");
        var val = button.getAttribute("data-val") || true;
        var fullLayout = gd._fullLayout;
        var aobj = {};
        var axList = axisIds.list(gd, null, true);
        var allSpikesEnabled = fullLayout._cartesianSpikesEnabled;
        var ax, i;
        if (astr === "zoom") {
          var mag = val === "in" ? 0.5 : 2;
          var r0 = (1 + mag) / 2;
          var r1 = (1 - mag) / 2;
          var axName;
          for (i = 0; i < axList.length; i++) {
            ax = axList[i];
            if (!ax.fixedrange) {
              axName = ax._name;
              if (val === "auto") {
                aobj[axName + ".autorange"] = true;
              } else if (val === "reset") {
                if (ax._rangeInitial0 === void 0 && ax._rangeInitial1 === void 0) {
                  aobj[axName + ".autorange"] = true;
                } else if (ax._rangeInitial0 === void 0) {
                  aobj[axName + ".autorange"] = ax._autorangeInitial;
                  aobj[axName + ".range"] = [null, ax._rangeInitial1];
                } else if (ax._rangeInitial1 === void 0) {
                  aobj[axName + ".range"] = [ax._rangeInitial0, null];
                  aobj[axName + ".autorange"] = ax._autorangeInitial;
                } else {
                  aobj[axName + ".range"] = [ax._rangeInitial0, ax._rangeInitial1];
                }
                if (ax._showSpikeInitial !== void 0) {
                  aobj[axName + ".showspikes"] = ax._showSpikeInitial;
                  if (allSpikesEnabled === "on" && !ax._showSpikeInitial) {
                    allSpikesEnabled = "off";
                  }
                }
              } else {
                var rangeNow = [
                  ax.r2l(ax.range[0]),
                  ax.r2l(ax.range[1])
                ];
                var rangeNew = [
                  r0 * rangeNow[0] + r1 * rangeNow[1],
                  r0 * rangeNow[1] + r1 * rangeNow[0]
                ];
                aobj[axName + ".range[0]"] = ax.l2r(rangeNew[0]);
                aobj[axName + ".range[1]"] = ax.l2r(rangeNew[1]);
              }
            }
          }
        } else {
          if (astr === "hovermode" && (val === "x" || val === "y")) {
            val = fullLayout._isHoriz ? "y" : "x";
            button.setAttribute("data-val", val);
          }
          aobj[astr] = val;
        }
        fullLayout._cartesianSpikesEnabled = allSpikesEnabled;
        Registry.call("_guiRelayout", gd, aobj);
      }
      modeBarButtons.zoom3d = {
        name: "zoom3d",
        _cat: "zoom",
        title: function(gd) {
          return _(gd, "Zoom");
        },
        attr: "scene.dragmode",
        val: "zoom",
        icon: Icons.zoombox,
        click: handleDrag3d
      };
      modeBarButtons.pan3d = {
        name: "pan3d",
        _cat: "pan",
        title: function(gd) {
          return _(gd, "Pan");
        },
        attr: "scene.dragmode",
        val: "pan",
        icon: Icons.pan,
        click: handleDrag3d
      };
      modeBarButtons.orbitRotation = {
        name: "orbitRotation",
        title: function(gd) {
          return _(gd, "Orbital rotation");
        },
        attr: "scene.dragmode",
        val: "orbit",
        icon: Icons["3d_rotate"],
        click: handleDrag3d
      };
      modeBarButtons.tableRotation = {
        name: "tableRotation",
        title: function(gd) {
          return _(gd, "Turntable rotation");
        },
        attr: "scene.dragmode",
        val: "turntable",
        icon: Icons["z-axis"],
        click: handleDrag3d
      };
      function handleDrag3d(gd, ev) {
        var button = ev.currentTarget;
        var attr = button.getAttribute("data-attr");
        var val = button.getAttribute("data-val") || true;
        var sceneIds = gd._fullLayout._subplots.gl3d || [];
        var layoutUpdate = {};
        var parts = attr.split(".");
        for (var i = 0; i < sceneIds.length; i++) {
          layoutUpdate[sceneIds[i] + "." + parts[1]] = val;
        }
        var val2d = val === "pan" ? val : "zoom";
        layoutUpdate.dragmode = val2d;
        Registry.call("_guiRelayout", gd, layoutUpdate);
      }
      modeBarButtons.resetCameraDefault3d = {
        name: "resetCameraDefault3d",
        _cat: "resetCameraDefault",
        title: function(gd) {
          return _(gd, "Reset camera to default");
        },
        attr: "resetDefault",
        icon: Icons.home,
        click: handleCamera3d
      };
      modeBarButtons.resetCameraLastSave3d = {
        name: "resetCameraLastSave3d",
        _cat: "resetCameraLastSave",
        title: function(gd) {
          return _(gd, "Reset camera to last save");
        },
        attr: "resetLastSave",
        icon: Icons.movie,
        click: handleCamera3d
      };
      function handleCamera3d(gd, ev) {
        var button = ev.currentTarget;
        var attr = button.getAttribute("data-attr");
        var resetLastSave = attr === "resetLastSave";
        var resetDefault = attr === "resetDefault";
        var fullLayout = gd._fullLayout;
        var sceneIds = fullLayout._subplots.gl3d || [];
        var aobj = {};
        for (var i = 0; i < sceneIds.length; i++) {
          var sceneId = sceneIds[i];
          var camera = sceneId + ".camera";
          var aspectratio = sceneId + ".aspectratio";
          var aspectmode = sceneId + ".aspectmode";
          var scene = fullLayout[sceneId]._scene;
          var didUpdate;
          if (resetLastSave) {
            aobj[camera + ".up"] = scene.viewInitial.up;
            aobj[camera + ".eye"] = scene.viewInitial.eye;
            aobj[camera + ".center"] = scene.viewInitial.center;
            didUpdate = true;
          } else if (resetDefault) {
            aobj[camera + ".up"] = null;
            aobj[camera + ".eye"] = null;
            aobj[camera + ".center"] = null;
            didUpdate = true;
          }
          if (didUpdate) {
            aobj[aspectratio + ".x"] = scene.viewInitial.aspectratio.x;
            aobj[aspectratio + ".y"] = scene.viewInitial.aspectratio.y;
            aobj[aspectratio + ".z"] = scene.viewInitial.aspectratio.z;
            aobj[aspectmode] = scene.viewInitial.aspectmode;
          }
        }
        Registry.call("_guiRelayout", gd, aobj);
      }
      modeBarButtons.hoverClosest3d = {
        name: "hoverClosest3d",
        _cat: "hoverclosest",
        title: function(gd) {
          return _(gd, "Toggle show closest data on hover");
        },
        attr: "hovermode",
        val: null,
        toggle: true,
        icon: Icons.tooltip_basic,
        gravity: "ne",
        click: handleHover3d
      };
      function getNextHover3d(gd, ev) {
        var button = ev.currentTarget;
        var val = button._previousVal;
        var fullLayout = gd._fullLayout;
        var sceneIds = fullLayout._subplots.gl3d || [];
        var axes = ["xaxis", "yaxis", "zaxis"];
        var currentSpikes = {};
        var layoutUpdate = {};
        if (val) {
          layoutUpdate = val;
          button._previousVal = null;
        } else {
          for (var i = 0; i < sceneIds.length; i++) {
            var sceneId = sceneIds[i];
            var sceneLayout = fullLayout[sceneId];
            var hovermodeAStr = sceneId + ".hovermode";
            currentSpikes[hovermodeAStr] = sceneLayout.hovermode;
            layoutUpdate[hovermodeAStr] = false;
            for (var j = 0; j < 3; j++) {
              var axis = axes[j];
              var spikeAStr = sceneId + "." + axis + ".showspikes";
              layoutUpdate[spikeAStr] = false;
              currentSpikes[spikeAStr] = sceneLayout[axis].showspikes;
            }
          }
          button._previousVal = currentSpikes;
        }
        return layoutUpdate;
      }
      function handleHover3d(gd, ev) {
        var layoutUpdate = getNextHover3d(gd, ev);
        Registry.call("_guiRelayout", gd, layoutUpdate);
      }
      modeBarButtons.zoomInGeo = {
        name: "zoomInGeo",
        _cat: "zoomin",
        title: function(gd) {
          return _(gd, "Zoom in");
        },
        attr: "zoom",
        val: "in",
        icon: Icons.zoom_plus,
        click: handleGeo
      };
      modeBarButtons.zoomOutGeo = {
        name: "zoomOutGeo",
        _cat: "zoomout",
        title: function(gd) {
          return _(gd, "Zoom out");
        },
        attr: "zoom",
        val: "out",
        icon: Icons.zoom_minus,
        click: handleGeo
      };
      modeBarButtons.resetGeo = {
        name: "resetGeo",
        _cat: "reset",
        title: function(gd) {
          return _(gd, "Reset");
        },
        attr: "reset",
        val: null,
        icon: Icons.autoscale,
        click: handleGeo
      };
      modeBarButtons.hoverClosestGeo = {
        name: "hoverClosestGeo",
        _cat: "hoverclosest",
        title: function(gd) {
          return _(gd, "Toggle show closest data on hover");
        },
        attr: "hovermode",
        val: null,
        toggle: true,
        icon: Icons.tooltip_basic,
        gravity: "ne",
        click: toggleHover
      };
      function handleGeo(gd, ev) {
        var button = ev.currentTarget;
        var attr = button.getAttribute("data-attr");
        var val = button.getAttribute("data-val") || true;
        var fullLayout = gd._fullLayout;
        var geoIds = fullLayout._subplots.geo || [];
        for (var i = 0; i < geoIds.length; i++) {
          var id = geoIds[i];
          var geoLayout = fullLayout[id];
          if (attr === "zoom") {
            var scale = geoLayout.projection.scale;
            var newScale = val === "in" ? 2 * scale : 0.5 * scale;
            Registry.call("_guiRelayout", gd, id + ".projection.scale", newScale);
          }
        }
        if (attr === "reset") {
          resetView(gd, "geo");
        }
      }
      modeBarButtons.hoverClosestPie = {
        name: "hoverClosestPie",
        _cat: "hoverclosest",
        title: function(gd) {
          return _(gd, "Toggle show closest data on hover");
        },
        attr: "hovermode",
        val: "closest",
        icon: Icons.tooltip_basic,
        gravity: "ne",
        click: toggleHover
      };
      function getNextHover(gd) {
        var fullLayout = gd._fullLayout;
        if (fullLayout.hovermode) return false;
        if (fullLayout._has("cartesian")) {
          return fullLayout._isHoriz ? "y" : "x";
        }
        return "closest";
      }
      function toggleHover(gd) {
        var newHover = getNextHover(gd);
        Registry.call("_guiRelayout", gd, "hovermode", newHover);
      }
      modeBarButtons.resetViewSankey = {
        name: "resetSankeyGroup",
        title: function(gd) {
          return _(gd, "Reset view");
        },
        icon: Icons.home,
        click: function(gd) {
          var aObj = {
            "node.groups": [],
            "node.x": [],
            "node.y": []
          };
          for (var i = 0; i < gd._fullData.length; i++) {
            var viewInitial = gd._fullData[i]._viewInitial;
            aObj["node.groups"].push(viewInitial.node.groups.slice());
            aObj["node.x"].push(viewInitial.node.x.slice());
            aObj["node.y"].push(viewInitial.node.y.slice());
          }
          Registry.call("restyle", gd, aObj);
        }
      };
      modeBarButtons.toggleHover = {
        name: "toggleHover",
        title: function(gd) {
          return _(gd, "Toggle show closest data on hover");
        },
        attr: "hovermode",
        val: null,
        toggle: true,
        icon: Icons.tooltip_basic,
        gravity: "ne",
        click: function(gd, ev) {
          var layoutUpdate = getNextHover3d(gd, ev);
          layoutUpdate.hovermode = getNextHover(gd);
          Registry.call("_guiRelayout", gd, layoutUpdate);
        }
      };
      modeBarButtons.resetViews = {
        name: "resetViews",
        title: function(gd) {
          return _(gd, "Reset views");
        },
        icon: Icons.home,
        click: function(gd, ev) {
          var button = ev.currentTarget;
          button.setAttribute("data-attr", "zoom");
          button.setAttribute("data-val", "reset");
          handleCartesian(gd, ev);
          button.setAttribute("data-attr", "resetLastSave");
          handleCamera3d(gd, ev);
          resetView(gd, "geo");
          resetView(gd, "mapbox");
          resetView(gd, "map");
        }
      };
      modeBarButtons.toggleSpikelines = {
        name: "toggleSpikelines",
        title: function(gd) {
          return _(gd, "Toggle Spike Lines");
        },
        icon: Icons.spikeline,
        attr: "_cartesianSpikesEnabled",
        val: "on",
        click: function(gd) {
          var fullLayout = gd._fullLayout;
          var allSpikesEnabled = fullLayout._cartesianSpikesEnabled;
          fullLayout._cartesianSpikesEnabled = allSpikesEnabled === "on" ? "off" : "on";
          Registry.call("_guiRelayout", gd, setSpikelineVisibility(gd));
        }
      };
      function setSpikelineVisibility(gd) {
        var fullLayout = gd._fullLayout;
        var areSpikesOn = fullLayout._cartesianSpikesEnabled === "on";
        var axList = axisIds.list(gd, null, true);
        var aobj = {};
        for (var i = 0; i < axList.length; i++) {
          var ax = axList[i];
          aobj[ax._name + ".showspikes"] = areSpikesOn ? true : ax._showSpikeInitial;
        }
        return aobj;
      }
      modeBarButtons.resetViewMapbox = {
        name: "resetViewMapbox",
        _cat: "resetView",
        title: function(gd) {
          return _(gd, "Reset view");
        },
        attr: "reset",
        icon: Icons.home,
        click: function(gd) {
          resetView(gd, "mapbox");
        }
      };
      modeBarButtons.resetViewMap = {
        name: "resetViewMap",
        _cat: "resetView",
        title: function(gd) {
          return _(gd, "Reset view");
        },
        attr: "reset",
        icon: Icons.home,
        click: function(gd) {
          resetView(gd, "map");
        }
      };
      modeBarButtons.zoomInMapbox = {
        name: "zoomInMapbox",
        _cat: "zoomin",
        title: function(gd) {
          return _(gd, "Zoom in");
        },
        attr: "zoom",
        val: "in",
        icon: Icons.zoom_plus,
        click: handleMapboxZoom
      };
      modeBarButtons.zoomInMap = {
        name: "zoomInMap",
        _cat: "zoomin",
        title: function(gd) {
          return _(gd, "Zoom in");
        },
        attr: "zoom",
        val: "in",
        icon: Icons.zoom_plus,
        click: handleMapZoom
      };
      modeBarButtons.zoomOutMapbox = {
        name: "zoomOutMapbox",
        _cat: "zoomout",
        title: function(gd) {
          return _(gd, "Zoom out");
        },
        attr: "zoom",
        val: "out",
        icon: Icons.zoom_minus,
        click: handleMapboxZoom
      };
      modeBarButtons.zoomOutMap = {
        name: "zoomOutMap",
        _cat: "zoomout",
        title: function(gd) {
          return _(gd, "Zoom out");
        },
        attr: "zoom",
        val: "out",
        icon: Icons.zoom_minus,
        click: handleMapZoom
      };
      function handleMapboxZoom(gd, ev) {
        _handleMapZoom(gd, ev, "mapbox");
      }
      function handleMapZoom(gd, ev) {
        _handleMapZoom(gd, ev, "map");
      }
      function _handleMapZoom(gd, ev, mapType) {
        var button = ev.currentTarget;
        var val = button.getAttribute("data-val");
        var fullLayout = gd._fullLayout;
        var subplotIds = fullLayout._subplots[mapType] || [];
        var scalar = 1.05;
        var aObj = {};
        for (var i = 0; i < subplotIds.length; i++) {
          var id = subplotIds[i];
          var current = fullLayout[id].zoom;
          var next = val === "in" ? scalar * current : current / scalar;
          aObj[id + ".zoom"] = next;
        }
        Registry.call("_guiRelayout", gd, aObj);
      }
      function resetView(gd, subplotType) {
        var fullLayout = gd._fullLayout;
        var subplotIds = fullLayout._subplots[subplotType] || [];
        var aObj = {};
        for (var i = 0; i < subplotIds.length; i++) {
          var id = subplotIds[i];
          var subplotObj = fullLayout[id]._subplot;
          var viewInitial = subplotObj.viewInitial;
          var viewKeys = Object.keys(viewInitial);
          for (var j = 0; j < viewKeys.length; j++) {
            var key = viewKeys[j];
            aObj[id + "." + key] = viewInitial[key];
          }
        }
        Registry.call("_guiRelayout", gd, aObj);
      }
    }
  });

  // src/components/modebar/constants.js
  var require_constants6 = __commonJS({
    "src/components/modebar/constants.js"(exports, module) {
      "use strict";
      var modeBarButtons = require_buttons();
      var buttonList = Object.keys(modeBarButtons);
      var DRAW_MODES = [
        "drawline",
        "drawopenpath",
        "drawclosedpath",
        "drawcircle",
        "drawrect",
        "eraseshape"
      ];
      var backButtons = [
        "v1hovermode",
        "hoverclosest",
        "hovercompare",
        "togglehover",
        "togglespikelines"
      ].concat(DRAW_MODES);
      var foreButtons = [];
      var addToForeButtons = function(b) {
        if (backButtons.indexOf(b._cat || b.name) !== -1) return;
        var name = b.name;
        var _cat = (b._cat || b.name).toLowerCase();
        if (foreButtons.indexOf(name) === -1) foreButtons.push(name);
        if (foreButtons.indexOf(_cat) === -1) foreButtons.push(_cat);
      };
      buttonList.forEach(function(k) {
        addToForeButtons(modeBarButtons[k]);
      });
      foreButtons.sort();
      module.exports = {
        DRAW_MODES,
        backButtons,
        foreButtons
      };
    }
  });

  // src/components/modebar/attributes.js
  var require_attributes10 = __commonJS({
    "src/components/modebar/attributes.js"(exports, module) {
      "use strict";
      var constants = require_constants6();
      module.exports = {
        editType: "modebar",
        orientation: {
          valType: "enumerated",
          values: ["v", "h"],
          dflt: "h",
          editType: "modebar"
        },
        bgcolor: {
          valType: "color",
          editType: "modebar"
        },
        color: {
          valType: "color",
          editType: "modebar"
        },
        activecolor: {
          valType: "color",
          editType: "modebar"
        },
        uirevision: {
          valType: "any",
          editType: "none"
        },
        add: {
          valType: "string",
          arrayOk: true,
          dflt: "",
          editType: "modebar"
        },
        remove: {
          valType: "string",
          arrayOk: true,
          dflt: "",
          editType: "modebar"
        }
      };
    }
  });

  // src/components/modebar/defaults.js
  var require_defaults5 = __commonJS({
    "src/components/modebar/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Color = require_color();
      var Template = require_plot_template();
      var attributes = require_attributes10();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        var containerIn = layoutIn.modebar || {};
        var containerOut = Template.newContainer(layoutOut, "modebar");
        function coerce(attr, dflt) {
          return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
        }
        coerce("orientation");
        coerce("bgcolor", Color.addOpacity(layoutOut.paper_bgcolor, 0.5));
        var defaultColor = Color.contrast(Color.rgb(layoutOut.modebar.bgcolor));
        coerce("color", Color.addOpacity(defaultColor, 0.3));
        coerce("activecolor", Color.addOpacity(defaultColor, 0.7));
        coerce("uirevision", layoutOut.uirevision);
        coerce("add");
        coerce("remove");
      };
    }
  });

  // src/components/modebar/modebar.js
  var require_modebar = __commonJS({
    "src/components/modebar/modebar.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var Icons = require_ploticon();
      var version = require_version().version;
      var Parser = new DOMParser();
      function ModeBar(opts) {
        this.container = opts.container;
        this.element = document.createElement("div");
        this.update(opts.graphInfo, opts.buttons);
        this.container.appendChild(this.element);
      }
      var proto = ModeBar.prototype;
      proto.update = function(graphInfo, buttons) {
        this.graphInfo = graphInfo;
        var context = this.graphInfo._context;
        var fullLayout = this.graphInfo._fullLayout;
        var modeBarId = "modebar-" + fullLayout._uid;
        this.element.setAttribute("id", modeBarId);
        this._uid = modeBarId;
        this.element.className = "modebar";
        if (context.displayModeBar === "hover") this.element.className += " modebar--hover ease-bg";
        if (fullLayout.modebar.orientation === "v") {
          this.element.className += " vertical";
          buttons = buttons.reverse();
        }
        var style = fullLayout.modebar;
        var groupSelector = "#" + modeBarId + " .modebar-group";
        document.querySelectorAll(groupSelector).forEach(function(group) {
          group.style.backgroundColor = style.bgcolor;
        });
        var needsNewButtons = !this.hasButtons(buttons);
        var needsNewLogo = this.hasLogo !== context.displaylogo;
        var needsNewLocale = this.locale !== context.locale;
        this.locale = context.locale;
        if (needsNewButtons || needsNewLogo || needsNewLocale) {
          this.removeAllButtons();
          this.updateButtons(buttons);
          if (context.watermark || context.displaylogo) {
            var logoGroup = this.getLogo();
            if (context.watermark) {
              logoGroup.className = logoGroup.className + " watermark";
            }
            if (fullLayout.modebar.orientation === "v") {
              this.element.insertBefore(logoGroup, this.element.childNodes[0]);
            } else {
              this.element.appendChild(logoGroup);
            }
            this.hasLogo = true;
          }
        }
        this.updateActiveButton();
        Lib.setStyleOnHover("#" + modeBarId + " .modebar-btn", ".active", ".icon path", "fill: " + style.activecolor, "fill: " + style.color, this.element);
      };
      proto.updateButtons = function(buttons) {
        var _this = this;
        this.buttons = buttons;
        this.buttonElements = [];
        this.buttonsNames = [];
        this.buttons.forEach(function(buttonGroup) {
          var group = _this.createGroup();
          buttonGroup.forEach(function(buttonConfig) {
            var buttonName = buttonConfig.name;
            if (!buttonName) {
              throw new Error("must provide button 'name' in button config");
            }
            if (_this.buttonsNames.indexOf(buttonName) !== -1) {
              throw new Error("button name '" + buttonName + "' is taken");
            }
            _this.buttonsNames.push(buttonName);
            var button = _this.createButton(buttonConfig);
            _this.buttonElements.push(button);
            group.appendChild(button);
          });
          _this.element.appendChild(group);
        });
      };
      proto.createGroup = function() {
        var group = document.createElement("div");
        group.className = "modebar-group";
        var style = this.graphInfo._fullLayout.modebar;
        group.style.backgroundColor = style.bgcolor;
        return group;
      };
      proto.createButton = function(config) {
        var _this = this;
        var button = document.createElement("a");
        button.setAttribute("rel", "tooltip");
        button.className = "modebar-btn";
        var title = config.title;
        if (title === void 0) title = config.name;
        else if (typeof title === "function") title = title(this.graphInfo);
        if (title || title === 0) button.setAttribute("data-title", title);
        if (config.attr !== void 0) button.setAttribute("data-attr", config.attr);
        var val = config.val;
        if (val !== void 0) {
          if (typeof val === "function") val = val(this.graphInfo);
          button.setAttribute("data-val", val);
        }
        var click = config.click;
        if (typeof click !== "function") {
          throw new Error("must provide button 'click' function in button config");
        } else {
          button.addEventListener("click", function(ev) {
            config.click(_this.graphInfo, ev);
            _this.updateActiveButton(ev.currentTarget);
          });
        }
        button.setAttribute("data-toggle", config.toggle || false);
        if (config.toggle) d3.select(button).classed("active", true);
        var icon = config.icon;
        if (typeof icon === "function") {
          button.appendChild(icon());
        } else {
          button.appendChild(this.createIcon(icon || Icons.question));
        }
        button.setAttribute("data-gravity", config.gravity || "n");
        return button;
      };
      proto.createIcon = function(thisIcon) {
        var iconHeight = isNumeric(thisIcon.height) ? Number(thisIcon.height) : thisIcon.ascent - thisIcon.descent;
        var svgNS = "http://www.w3.org/2000/svg";
        var icon;
        if (thisIcon.path) {
          icon = document.createElementNS(svgNS, "svg");
          icon.setAttribute("viewBox", [0, 0, thisIcon.width, iconHeight].join(" "));
          icon.setAttribute("class", "icon");
          var path = document.createElementNS(svgNS, "path");
          path.setAttribute("d", thisIcon.path);
          if (thisIcon.transform) {
            path.setAttribute("transform", thisIcon.transform);
          } else if (thisIcon.ascent !== void 0) {
            path.setAttribute("transform", "matrix(1 0 0 -1 0 " + thisIcon.ascent + ")");
          }
          icon.appendChild(path);
        }
        if (thisIcon.svg) {
          var svgDoc = Parser.parseFromString(thisIcon.svg, "application/xml");
          icon = svgDoc.childNodes[0];
        }
        icon.setAttribute("height", "1em");
        icon.setAttribute("width", "1em");
        return icon;
      };
      proto.updateActiveButton = function(buttonClicked) {
        var fullLayout = this.graphInfo._fullLayout;
        var dataAttrClicked = buttonClicked !== void 0 ? buttonClicked.getAttribute("data-attr") : null;
        this.buttonElements.forEach(function(button) {
          var thisval = button.getAttribute("data-val") || true;
          var dataAttr = button.getAttribute("data-attr");
          var isToggleButton = button.getAttribute("data-toggle") === "true";
          var button3 = d3.select(button);
          var updateButtonStyle = function(button2, isActive2) {
            var style = fullLayout.modebar;
            var childEl = button2.querySelector(".icon path");
            if (childEl) {
              if (isActive2 || button2.matches(":hover")) {
                childEl.style.fill = style.activecolor;
              } else {
                childEl.style.fill = style.color;
              }
            }
          };
          if (isToggleButton) {
            if (dataAttr === dataAttrClicked) {
              var isActive = !button3.classed("active");
              button3.classed("active", isActive);
              updateButtonStyle(button, isActive);
            }
          } else {
            var val = dataAttr === null ? dataAttr : Lib.nestedProperty(fullLayout, dataAttr).get();
            button3.classed("active", val === thisval);
            updateButtonStyle(button, val === thisval);
          }
        });
      };
      proto.hasButtons = function(buttons) {
        var currentButtons = this.buttons;
        if (!currentButtons) return false;
        if (buttons.length !== currentButtons.length) return false;
        for (var i = 0; i < buttons.length; ++i) {
          if (buttons[i].length !== currentButtons[i].length) return false;
          for (var j = 0; j < buttons[i].length; j++) {
            if (buttons[i][j].name !== currentButtons[i][j].name) return false;
          }
        }
        return true;
      };
      function jsVersion(str) {
        return str + " (v" + version + ")";
      }
      proto.getLogo = function() {
        var group = this.createGroup();
        var a = document.createElement("a");
        a.href = "https://plotly.com/";
        a.target = "_blank";
        a.setAttribute("data-title", jsVersion(Lib._(this.graphInfo, "Produced with Plotly.js")));
        a.className = "modebar-btn plotlyjsicon modebar-btn--logo";
        a.appendChild(this.createIcon(Icons.newplotlylogo));
        group.appendChild(a);
        return group;
      };
      proto.removeAllButtons = function() {
        while (this.element.firstChild) {
          this.element.removeChild(this.element.firstChild);
        }
        this.hasLogo = false;
      };
      proto.destroy = function() {
        Lib.removeElement(this.container.querySelector(".modebar"));
      };
      function createModeBar(gd, buttons) {
        var fullLayout = gd._fullLayout;
        var modeBar = new ModeBar({
          graphInfo: gd,
          container: fullLayout._modebardiv.node(),
          buttons
        });
        if (fullLayout._privateplot) {
          d3.select(modeBar.element).append("span").classed("badge-private float--left", true).text("PRIVATE");
        }
        return modeBar;
      }
      module.exports = createModeBar;
    }
  });

  // src/components/modebar/manage.js
  var require_manage = __commonJS({
    "src/components/modebar/manage.js"(exports, module) {
      "use strict";
      var axisIds = require_axis_ids();
      var scatterSubTypes = require_subtypes();
      var Registry = require_registry();
      var isUnifiedHover = require_helpers2().isUnifiedHover;
      var createModeBar = require_modebar();
      var modeBarButtons = require_buttons();
      var DRAW_MODES = require_constants6().DRAW_MODES;
      var extendDeep = require_lib().extendDeep;
      module.exports = function manageModeBar(gd) {
        var fullLayout = gd._fullLayout;
        var context = gd._context;
        var modeBar = fullLayout._modeBar;
        if (!context.displayModeBar && !context.watermark) {
          if (modeBar) {
            modeBar.destroy();
            delete fullLayout._modeBar;
          }
          return;
        }
        if (!Array.isArray(context.modeBarButtonsToRemove)) {
          throw new Error([
            "*modeBarButtonsToRemove* configuration options",
            "must be an array."
          ].join(" "));
        }
        if (!Array.isArray(context.modeBarButtonsToAdd)) {
          throw new Error([
            "*modeBarButtonsToAdd* configuration options",
            "must be an array."
          ].join(" "));
        }
        var customButtons = context.modeBarButtons;
        var buttonGroups;
        if (Array.isArray(customButtons) && customButtons.length) {
          buttonGroups = fillCustomButton(customButtons);
        } else if (!context.displayModeBar && context.watermark) {
          buttonGroups = [];
        } else {
          buttonGroups = getButtonGroups(gd);
        }
        if (modeBar) modeBar.update(gd, buttonGroups);
        else fullLayout._modeBar = createModeBar(gd, buttonGroups);
      };
      function getButtonGroups(gd) {
        var fullLayout = gd._fullLayout;
        var fullData = gd._fullData;
        var context = gd._context;
        function match(name, B) {
          if (typeof B === "string") {
            if (B.toLowerCase() === name.toLowerCase()) return true;
          } else {
            var v0 = B.name;
            var v1 = B._cat || B.name;
            if (v0 === name || v1 === name.toLowerCase()) return true;
          }
          return false;
        }
        var layoutAdd = fullLayout.modebar.add;
        if (typeof layoutAdd === "string") layoutAdd = [layoutAdd];
        var layoutRemove = fullLayout.modebar.remove;
        if (typeof layoutRemove === "string") layoutRemove = [layoutRemove];
        var buttonsToAdd = context.modeBarButtonsToAdd.concat(
          layoutAdd.filter(function(e) {
            for (var i2 = 0; i2 < context.modeBarButtonsToRemove.length; i2++) {
              if (match(e, context.modeBarButtonsToRemove[i2])) return false;
            }
            return true;
          })
        );
        var buttonsToRemove = context.modeBarButtonsToRemove.concat(
          layoutRemove.filter(function(e) {
            for (var i2 = 0; i2 < context.modeBarButtonsToAdd.length; i2++) {
              if (match(e, context.modeBarButtonsToAdd[i2])) return false;
            }
            return true;
          })
        );
        var hasCartesian = fullLayout._has("cartesian");
        var hasGL3D = fullLayout._has("gl3d");
        var hasGeo = fullLayout._has("geo");
        var hasPie = fullLayout._has("pie");
        var hasFunnelarea = fullLayout._has("funnelarea");
        var hasTernary = fullLayout._has("ternary");
        var hasMapbox = fullLayout._has("mapbox");
        var hasMap = fullLayout._has("map");
        var hasPolar = fullLayout._has("polar");
        var hasSmith = fullLayout._has("smith");
        var hasSankey = fullLayout._has("sankey");
        var allAxesFixed = areAllAxesFixed(fullLayout);
        var hasUnifiedHoverLabel = isUnifiedHover(fullLayout.hovermode);
        var groups = [];
        function addGroup(newGroup) {
          if (!newGroup.length) return;
          var out = [];
          for (var i2 = 0; i2 < newGroup.length; i2++) {
            var name = newGroup[i2];
            var B = modeBarButtons[name];
            var v0 = B.name.toLowerCase();
            var v1 = (B._cat || B.name).toLowerCase();
            var found = false;
            for (var q = 0; q < buttonsToRemove.length; q++) {
              var t = buttonsToRemove[q].toLowerCase();
              if (t === v0 || t === v1) {
                found = true;
                break;
              }
            }
            if (found) continue;
            out.push(modeBarButtons[name]);
          }
          groups.push(out);
        }
        var commonGroup = ["toImage"];
        if (context.showEditInChartStudio) commonGroup.push("editInChartStudio");
        else if (context.showSendToCloud) commonGroup.push("sendDataToCloud");
        addGroup(commonGroup);
        var zoomGroup = [];
        var hoverGroup = [];
        var resetGroup = [];
        var dragModeGroup = [];
        if ((hasCartesian || hasPie || hasFunnelarea || hasTernary) + hasGeo + hasGL3D + hasMapbox + hasMap + hasPolar + hasSmith > 1) {
          hoverGroup = ["toggleHover"];
          resetGroup = ["resetViews"];
        } else if (hasGeo) {
          zoomGroup = ["zoomInGeo", "zoomOutGeo"];
          hoverGroup = ["hoverClosestGeo"];
          resetGroup = ["resetGeo"];
        } else if (hasGL3D) {
          hoverGroup = ["hoverClosest3d"];
          resetGroup = ["resetCameraDefault3d", "resetCameraLastSave3d"];
        } else if (hasMapbox) {
          zoomGroup = ["zoomInMapbox", "zoomOutMapbox"];
          hoverGroup = ["toggleHover"];
          resetGroup = ["resetViewMapbox"];
        } else if (hasMap) {
          zoomGroup = ["zoomInMap", "zoomOutMap"];
          hoverGroup = ["toggleHover"];
          resetGroup = ["resetViewMap"];
        } else if (hasPie) {
          hoverGroup = ["hoverClosestPie"];
        } else if (hasSankey) {
          hoverGroup = ["hoverClosestCartesian", "hoverCompareCartesian"];
          resetGroup = ["resetViewSankey"];
        } else {
          hoverGroup = ["toggleHover"];
        }
        if (hasCartesian) {
          hoverGroup.push("toggleSpikelines", "hoverClosestCartesian", "hoverCompareCartesian");
        }
        if (hasNoHover(fullData) || hasUnifiedHoverLabel) {
          hoverGroup = [];
        }
        if (hasCartesian && !allAxesFixed) {
          zoomGroup = ["zoomIn2d", "zoomOut2d", "autoScale2d"];
          if (resetGroup[0] !== "resetViews") resetGroup = ["resetScale2d"];
        }
        if (hasGL3D) {
          dragModeGroup = ["zoom3d", "pan3d", "orbitRotation", "tableRotation"];
        } else if (hasCartesian && !allAxesFixed || hasTernary) {
          dragModeGroup = ["zoom2d", "pan2d"];
        } else if (hasMapbox || hasMap || hasGeo) {
          dragModeGroup = ["pan2d"];
        } else if (hasPolar) {
          dragModeGroup = ["zoom2d"];
        }
        if (isSelectable(fullData)) {
          dragModeGroup.push("select2d", "lasso2d");
        }
        var enabledHoverGroup = [];
        var enableHover = function(a) {
          if (enabledHoverGroup.indexOf(a) !== -1) return;
          if (hoverGroup.indexOf(a) !== -1) {
            enabledHoverGroup.push(a);
          }
        };
        if (Array.isArray(buttonsToAdd)) {
          var newList = [];
          for (var i = 0; i < buttonsToAdd.length; i++) {
            var b = buttonsToAdd[i];
            if (typeof b === "string") {
              b = b.toLowerCase();
              if (DRAW_MODES.indexOf(b) !== -1) {
                if (fullLayout._has("mapbox") || fullLayout._has("map") || // draw shapes in paper coordinate (could be improved in future to support data coordinate, when there is no pitch)
                fullLayout._has("cartesian")) {
                  dragModeGroup.push(b);
                }
              } else if (b === "togglespikelines") {
                enableHover("toggleSpikelines");
              } else if (b === "togglehover") {
                enableHover("toggleHover");
              } else if (b === "hovercompare") {
                enableHover("hoverCompareCartesian");
              } else if (b === "hoverclosest") {
                enableHover("hoverClosestCartesian");
                enableHover("hoverClosestGeo");
                enableHover("hoverClosest3d");
                enableHover("hoverClosestPie");
              } else if (b === "v1hovermode") {
                enableHover("hoverClosestCartesian");
                enableHover("hoverCompareCartesian");
                enableHover("hoverClosestGeo");
                enableHover("hoverClosest3d");
                enableHover("hoverClosestPie");
              }
            } else newList.push(b);
          }
          buttonsToAdd = newList;
        }
        addGroup(dragModeGroup);
        addGroup(zoomGroup.concat(resetGroup));
        addGroup(enabledHoverGroup);
        return appendButtonsToGroups(groups, buttonsToAdd);
      }
      function areAllAxesFixed(fullLayout) {
        var axList = axisIds.list({ _fullLayout: fullLayout }, null, true);
        for (var i = 0; i < axList.length; i++) {
          if (!axList[i].fixedrange) {
            return false;
          }
        }
        return true;
      }
      function isSelectable(fullData) {
        var selectable = false;
        for (var i = 0; i < fullData.length; i++) {
          if (selectable) break;
          var trace = fullData[i];
          if (!trace._module || !trace._module.selectPoints) continue;
          if (Registry.traceIs(trace, "scatter-like")) {
            if (scatterSubTypes.hasMarkers(trace) || scatterSubTypes.hasText(trace)) {
              selectable = true;
            }
          } else if (Registry.traceIs(trace, "box-violin")) {
            if (trace.boxpoints === "all" || trace.points === "all") {
              selectable = true;
            }
          } else {
            selectable = true;
          }
        }
        return selectable;
      }
      function hasNoHover(fullData) {
        for (var i = 0; i < fullData.length; i++) {
          if (!Registry.traceIs(fullData[i], "noHover")) return false;
        }
        return true;
      }
      function appendButtonsToGroups(groups, buttons) {
        if (buttons.length) {
          if (Array.isArray(buttons[0])) {
            for (var i = 0; i < buttons.length; i++) {
              groups.push(buttons[i]);
            }
          } else groups.push(buttons);
        }
        return groups;
      }
      function fillCustomButton(originalModeBarButtons) {
        var customButtons = extendDeep([], originalModeBarButtons);
        for (var i = 0; i < customButtons.length; i++) {
          var buttonGroup = customButtons[i];
          for (var j = 0; j < buttonGroup.length; j++) {
            var button = buttonGroup[j];
            if (typeof button === "string") {
              if (modeBarButtons[button] !== void 0) {
                customButtons[i][j] = modeBarButtons[button];
              } else {
                throw new Error([
                  "*modeBarButtons* configuration options",
                  "invalid button name"
                ].join(" "));
              }
            }
          }
        }
        return customButtons;
      }
    }
  });

  // src/components/modebar/index.js
  var require_modebar2 = __commonJS({
    "src/components/modebar/index.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "component",
        name: "modebar",
        layoutAttributes: require_attributes10(),
        supplyLayoutDefaults: require_defaults5(),
        manage: require_manage()
      };
    }
  });

  // src/plots/cartesian/scale_zoom.js
  var require_scale_zoom = __commonJS({
    "src/plots/cartesian/scale_zoom.js"(exports, module) {
      "use strict";
      var FROM_BL = require_alignment().FROM_BL;
      module.exports = function scaleZoom(ax, factor, centerFraction) {
        if (centerFraction === void 0) {
          centerFraction = FROM_BL[ax.constraintoward || "center"];
        }
        var rangeLinear = [ax.r2l(ax.range[0]), ax.r2l(ax.range[1])];
        var center = rangeLinear[0] + (rangeLinear[1] - rangeLinear[0]) * centerFraction;
        ax.range = ax._input.range = [
          ax.l2r(center + (rangeLinear[0] - center) * factor),
          ax.l2r(center + (rangeLinear[1] - center) * factor)
        ];
        ax.setScale();
      };
    }
  });

  // src/plots/cartesian/constraints.js
  var require_constraints = __commonJS({
    "src/plots/cartesian/constraints.js"(exports) {
      "use strict";
      var Lib = require_lib();
      var autorange = require_autorange();
      var id2name = require_axis_ids().id2name;
      var layoutAttributes = require_layout_attributes4();
      var scaleZoom = require_scale_zoom();
      var setConvert = require_set_convert();
      var ALMOST_EQUAL = require_numerical().ALMOST_EQUAL;
      var FROM_BL = require_alignment().FROM_BL;
      exports.handleDefaults = function(layoutIn, layoutOut, opts) {
        var axIds = opts.axIds;
        var axHasImage = opts.axHasImage;
        var constraintGroups = layoutOut._axisConstraintGroups = [];
        var matchGroups = layoutOut._axisMatchGroups = [];
        var i, group, axId, axName, axIn, axOut, attr, val;
        for (i = 0; i < axIds.length; i++) {
          axName = id2name(axIds[i]);
          axIn = layoutIn[axName];
          axOut = layoutOut[axName];
          handleOneAxDefaults(axIn, axOut, {
            axIds,
            layoutOut,
            hasImage: axHasImage[axName]
          });
        }
        function stash(groups, stashAttr) {
          for (i = 0; i < groups.length; i++) {
            group = groups[i];
            for (axId in group) {
              layoutOut[id2name(axId)][stashAttr] = group;
            }
          }
        }
        stash(matchGroups, "_matchGroup");
        for (i = 0; i < constraintGroups.length; i++) {
          group = constraintGroups[i];
          for (axId in group) {
            axOut = layoutOut[id2name(axId)];
            if (axOut.fixedrange) {
              for (var axId2 in group) {
                var axName2 = id2name(axId2);
                if ((layoutIn[axName2] || {}).fixedrange === false) {
                  Lib.warn(
                    "fixedrange was specified as false for axis " + axName2 + " but was overridden because another axis in its constraint group has fixedrange true"
                  );
                }
                layoutOut[axName2].fixedrange = true;
              }
              break;
            }
          }
        }
        i = 0;
        while (i < constraintGroups.length) {
          group = constraintGroups[i];
          for (axId in group) {
            axOut = layoutOut[id2name(axId)];
            if (axOut._matchGroup && Object.keys(axOut._matchGroup).length === Object.keys(group).length) {
              constraintGroups.splice(i, 1);
              i--;
            }
            break;
          }
          i++;
        }
        stash(constraintGroups, "_constraintGroup");
        var matchAttrs = [
          "constrain",
          "range",
          "autorange",
          "rangemode",
          "rangebreaks",
          "categoryorder",
          "categoryarray"
        ];
        var hasRange = false;
        var hasDayOfWeekBreaks = false;
        function setAttrVal() {
          val = axOut[attr];
          if (attr === "rangebreaks") {
            hasDayOfWeekBreaks = axOut._hasDayOfWeekBreaks;
          }
        }
        for (i = 0; i < matchGroups.length; i++) {
          group = matchGroups[i];
          for (var j = 0; j < matchAttrs.length; j++) {
            attr = matchAttrs[j];
            val = null;
            var baseAx;
            for (axId in group) {
              axName = id2name(axId);
              axIn = layoutIn[axName];
              axOut = layoutOut[axName];
              if (!(attr in axOut)) {
                continue;
              }
              if (!axOut.matches) {
                baseAx = axOut;
                if (attr in axIn) {
                  setAttrVal();
                  break;
                }
              }
              if (val === null && attr in axIn) {
                setAttrVal();
              }
            }
            if (attr === "range" && val && axIn.range && axIn.range.length === 2 && axIn.range[0] !== null && axIn.range[1] !== null) {
              hasRange = true;
            }
            if (attr === "autorange" && val === null && hasRange) {
              val = false;
            }
            if (val === null && attr in baseAx) {
              val = baseAx[attr];
            }
            if (val !== null) {
              for (axId in group) {
                axOut = layoutOut[id2name(axId)];
                axOut[attr] = attr === "range" ? val.slice() : val;
                if (attr === "rangebreaks") {
                  axOut._hasDayOfWeekBreaks = hasDayOfWeekBreaks;
                  setConvert(axOut, layoutOut);
                }
              }
            }
          }
        }
      };
      function handleOneAxDefaults(axIn, axOut, opts) {
        var axIds = opts.axIds;
        var layoutOut = opts.layoutOut;
        var hasImage = opts.hasImage;
        var constraintGroups = layoutOut._axisConstraintGroups;
        var matchGroups = layoutOut._axisMatchGroups;
        var axId = axOut._id;
        var axLetter = axId.charAt(0);
        var splomStash = ((layoutOut._splomAxes || {})[axLetter] || {})[axId] || {};
        var thisID = axOut._id;
        var isX = thisID.charAt(0) === "x";
        axOut._matchGroup = null;
        axOut._constraintGroup = null;
        function coerce(attr, dflt) {
          return Lib.coerce(axIn, axOut, layoutAttributes, attr, dflt);
        }
        coerce("constrain", hasImage ? "domain" : "range");
        Lib.coerce(axIn, axOut, {
          constraintoward: {
            valType: "enumerated",
            values: isX ? ["left", "center", "right"] : ["bottom", "middle", "top"],
            dflt: isX ? "center" : "middle"
          }
        }, "constraintoward");
        var thisType = axOut.type;
        var i, idi;
        var linkableAxes = [];
        for (i = 0; i < axIds.length; i++) {
          idi = axIds[i];
          if (idi === thisID) continue;
          var axi = layoutOut[id2name(idi)];
          if (axi.type === thisType) {
            linkableAxes.push(idi);
          }
        }
        var thisGroup = getConstraintGroup(constraintGroups, thisID);
        if (thisGroup) {
          var linkableAxesNoLoops = [];
          for (i = 0; i < linkableAxes.length; i++) {
            idi = linkableAxes[i];
            if (!thisGroup[idi]) linkableAxesNoLoops.push(idi);
          }
          linkableAxes = linkableAxesNoLoops;
        }
        var canLink = linkableAxes.length;
        var matches, scaleanchor;
        if (canLink && (axIn.matches || splomStash.matches)) {
          matches = Lib.coerce(axIn, axOut, {
            matches: {
              valType: "enumerated",
              values: linkableAxes,
              dflt: linkableAxes.indexOf(splomStash.matches) !== -1 ? splomStash.matches : void 0
            }
          }, "matches");
        }
        var scaleanchorDflt = hasImage && !isX ? axOut.anchor : void 0;
        if (canLink && !matches && (axIn.scaleanchor || scaleanchorDflt)) {
          scaleanchor = Lib.coerce(axIn, axOut, {
            scaleanchor: {
              valType: "enumerated",
              values: linkableAxes.concat([false])
            }
          }, "scaleanchor", scaleanchorDflt);
        }
        if (matches) {
          axOut._matchGroup = updateConstraintGroups(matchGroups, thisID, matches, 1);
          var matchedAx = layoutOut[id2name(matches)];
          var matchRatio = extent(layoutOut, axOut) / extent(layoutOut, matchedAx);
          if (isX !== (matches.charAt(0) === "x")) {
            matchRatio = (isX ? "x" : "y") + matchRatio;
          }
          updateConstraintGroups(constraintGroups, thisID, matches, matchRatio);
        } else if (axIn.matches && axIds.indexOf(axIn.matches) !== -1) {
          Lib.warn("ignored " + axOut._name + '.matches: "' + axIn.matches + '" to avoid an infinite loop');
        }
        if (scaleanchor) {
          var scaleratio = coerce("scaleratio");
          if (!scaleratio) scaleratio = axOut.scaleratio = 1;
          updateConstraintGroups(constraintGroups, thisID, scaleanchor, scaleratio);
        } else if (axIn.scaleanchor && axIds.indexOf(axIn.scaleanchor) !== -1) {
          Lib.warn("ignored " + axOut._name + '.scaleanchor: "' + axIn.scaleanchor + '" to avoid either an infinite loop and possibly inconsistent scaleratios, or because this axis declares a *matches* constraint.');
        }
      }
      function extent(layoutOut, ax) {
        var domain = ax.domain;
        if (!domain) {
          domain = layoutOut[id2name(ax.overlaying)].domain;
        }
        return domain[1] - domain[0];
      }
      function getConstraintGroup(groups, thisID) {
        for (var i = 0; i < groups.length; i++) {
          if (groups[i][thisID]) {
            return groups[i];
          }
        }
        return null;
      }
      function updateConstraintGroups(constraintGroups, thisID, thatID, scaleratio) {
        var i, j, groupi, keyj, thisGroupIndex;
        var thisGroup = getConstraintGroup(constraintGroups, thisID);
        if (thisGroup === null) {
          thisGroup = {};
          thisGroup[thisID] = 1;
          thisGroupIndex = constraintGroups.length;
          constraintGroups.push(thisGroup);
        } else {
          thisGroupIndex = constraintGroups.indexOf(thisGroup);
        }
        var thisGroupKeys = Object.keys(thisGroup);
        for (i = 0; i < constraintGroups.length; i++) {
          groupi = constraintGroups[i];
          if (i !== thisGroupIndex && groupi[thatID]) {
            var baseScale = groupi[thatID];
            for (j = 0; j < thisGroupKeys.length; j++) {
              keyj = thisGroupKeys[j];
              groupi[keyj] = multiplyScales(baseScale, multiplyScales(scaleratio, thisGroup[keyj]));
            }
            constraintGroups.splice(thisGroupIndex, 1);
            return;
          }
        }
        if (scaleratio !== 1) {
          for (j = 0; j < thisGroupKeys.length; j++) {
            var key = thisGroupKeys[j];
            thisGroup[key] = multiplyScales(scaleratio, thisGroup[key]);
          }
        }
        thisGroup[thatID] = 1;
      }
      function multiplyScales(a, b) {
        var aPrefix = "";
        var bPrefix = "";
        var aLen, bLen;
        if (typeof a === "string") {
          aPrefix = a.match(/^[xy]*/)[0];
          aLen = aPrefix.length;
          a = +a.substr(aLen);
        }
        if (typeof b === "string") {
          bPrefix = b.match(/^[xy]*/)[0];
          bLen = bPrefix.length;
          b = +b.substr(bLen);
        }
        var c = a * b;
        if (!aLen && !bLen) {
          return c;
        }
        if (!aLen || !bLen || aPrefix.charAt(0) === bPrefix.charAt(0)) {
          return aPrefix + bPrefix + a * b;
        }
        if (aLen === bLen) {
          return c;
        }
        return (aLen > bLen ? aPrefix.substr(bLen) : bPrefix.substr(aLen)) + c;
      }
      function finalRatios(group, fullLayout) {
        var size = fullLayout._size;
        var yRatio = size.h / size.w;
        var out = {};
        var keys = Object.keys(group);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var val = group[key];
          if (typeof val === "string") {
            var prefix = val.match(/^[xy]*/)[0];
            var pLen = prefix.length;
            val = +val.substr(pLen);
            var mult = prefix.charAt(0) === "y" ? yRatio : 1 / yRatio;
            for (var j = 0; j < pLen; j++) {
              val *= mult;
            }
          }
          out[key] = val;
        }
        return out;
      }
      exports.enforce = function enforce(gd) {
        var fullLayout = gd._fullLayout;
        var constraintGroups = fullLayout._axisConstraintGroups || [];
        var i, j, group, axisID, ax, normScale, mode, factor;
        for (i = 0; i < constraintGroups.length; i++) {
          group = finalRatios(constraintGroups[i], fullLayout);
          var axisIDs = Object.keys(group);
          var minScale = Infinity;
          var maxScale = 0;
          var matchScale = Infinity;
          var normScales = {};
          var axes = {};
          var hasAnyDomainConstraint = false;
          for (j = 0; j < axisIDs.length; j++) {
            axisID = axisIDs[j];
            axes[axisID] = ax = fullLayout[id2name(axisID)];
            if (ax._inputDomain) ax.domain = ax._inputDomain.slice();
            else ax._inputDomain = ax.domain.slice();
            if (!ax._inputRange) ax._inputRange = ax.range.slice();
            ax.setScale();
            normScales[axisID] = normScale = Math.abs(ax._m) / group[axisID];
            minScale = Math.min(minScale, normScale);
            if (ax.constrain === "domain" || !ax._constraintShrinkable) {
              matchScale = Math.min(matchScale, normScale);
            }
            delete ax._constraintShrinkable;
            maxScale = Math.max(maxScale, normScale);
            if (ax.constrain === "domain") hasAnyDomainConstraint = true;
          }
          if (minScale > ALMOST_EQUAL * maxScale && !hasAnyDomainConstraint) continue;
          for (j = 0; j < axisIDs.length; j++) {
            axisID = axisIDs[j];
            normScale = normScales[axisID];
            ax = axes[axisID];
            mode = ax.constrain;
            if (normScale !== matchScale || mode === "domain") {
              factor = normScale / matchScale;
              if (mode === "range") {
                scaleZoom(ax, factor);
              } else {
                var inputDomain = ax._inputDomain;
                var domainShrunk = (ax.domain[1] - ax.domain[0]) / (inputDomain[1] - inputDomain[0]);
                var rangeShrunk = (ax.r2l(ax.range[1]) - ax.r2l(ax.range[0])) / (ax.r2l(ax._inputRange[1]) - ax.r2l(ax._inputRange[0]));
                factor /= domainShrunk;
                if (factor * rangeShrunk < 1) {
                  ax.domain = ax._input.domain = inputDomain.slice();
                  scaleZoom(ax, factor);
                  continue;
                }
                if (rangeShrunk < 1) {
                  ax.range = ax._input.range = ax._inputRange.slice();
                  factor *= rangeShrunk;
                }
                if (ax.autorange) {
                  var rl0 = ax.r2l(ax.range[0]);
                  var rl1 = ax.r2l(ax.range[1]);
                  var rangeCenter = (rl0 + rl1) / 2;
                  var rangeMin = rangeCenter;
                  var rangeMax = rangeCenter;
                  var halfRange = Math.abs(rl1 - rangeCenter);
                  var outerMin = rangeCenter - halfRange * factor * 1.0001;
                  var outerMax = rangeCenter + halfRange * factor * 1.0001;
                  var getPadMin = autorange.makePadFn(fullLayout, ax, 0);
                  var getPadMax = autorange.makePadFn(fullLayout, ax, 1);
                  updateDomain(ax, factor);
                  var m = Math.abs(ax._m);
                  var extremes = autorange.concatExtremes(gd, ax);
                  var minArray = extremes.min;
                  var maxArray = extremes.max;
                  var newVal;
                  var k;
                  for (k = 0; k < minArray.length; k++) {
                    newVal = minArray[k].val - getPadMin(minArray[k]) / m;
                    if (newVal > outerMin && newVal < rangeMin) {
                      rangeMin = newVal;
                    }
                  }
                  for (k = 0; k < maxArray.length; k++) {
                    newVal = maxArray[k].val + getPadMax(maxArray[k]) / m;
                    if (newVal < outerMax && newVal > rangeMax) {
                      rangeMax = newVal;
                    }
                  }
                  var domainExpand = (rangeMax - rangeMin) / (2 * halfRange);
                  factor /= domainExpand;
                  rangeMin = ax.l2r(rangeMin);
                  rangeMax = ax.l2r(rangeMax);
                  ax.range = ax._input.range = rl0 < rl1 ? [rangeMin, rangeMax] : [rangeMax, rangeMin];
                }
                updateDomain(ax, factor);
              }
            }
          }
        }
      };
      exports.getAxisGroup = function getAxisGroup(fullLayout, axId) {
        var matchGroups = fullLayout._axisMatchGroups;
        for (var i = 0; i < matchGroups.length; i++) {
          var group = matchGroups[i];
          if (group[axId]) return "g" + i;
        }
        return axId;
      };
      exports.clean = function clean(gd, ax) {
        if (ax._inputDomain) {
          var isConstrained = false;
          var axId = ax._id;
          var constraintGroups = gd._fullLayout._axisConstraintGroups;
          for (var j = 0; j < constraintGroups.length; j++) {
            if (constraintGroups[j][axId]) {
              isConstrained = true;
              break;
            }
          }
          if (!isConstrained || ax.constrain !== "domain") {
            ax._input.domain = ax.domain = ax._inputDomain;
            delete ax._inputDomain;
          }
        }
      };
      function updateDomain(ax, factor) {
        var inputDomain = ax._inputDomain;
        var centerFraction = FROM_BL[ax.constraintoward];
        var center = inputDomain[0] + (inputDomain[1] - inputDomain[0]) * centerFraction;
        ax.domain = ax._input.domain = [
          center + (inputDomain[0] - center) / factor,
          center + (inputDomain[1] - center) / factor
        ];
        ax.setScale();
      }
    }
  });

  // src/plot_api/subroutines.js
  var require_subroutines = __commonJS({
    "src/plot_api/subroutines.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Plots = require_plots();
      var Lib = require_lib();
      var svgTextUtils = require_svg_text_utils();
      var clearGlCanvases = require_clear_gl_canvases();
      var Color = require_color();
      var Drawing = require_drawing();
      var Titles = require_titles();
      var ModeBar = require_modebar2();
      var Axes = require_axes();
      var alignmentConstants = require_alignment();
      var axisConstraints = require_constraints();
      var enforceAxisConstraints = axisConstraints.enforce;
      var cleanAxisConstraints = axisConstraints.clean;
      var doAutoRange = require_autorange().doAutoRange;
      var SVG_TEXT_ANCHOR_START = "start";
      var SVG_TEXT_ANCHOR_MIDDLE = "middle";
      var SVG_TEXT_ANCHOR_END = "end";
      var zindexSeparator = require_constants2().zindexSeparator;
      exports.layoutStyles = function(gd) {
        return Lib.syncOrAsync([Plots.doAutoMargin, lsInner], gd);
      };
      function overlappingDomain(xDomain, yDomain, domains) {
        for (var i = 0; i < domains.length; i++) {
          var existingX = domains[i][0];
          var existingY = domains[i][1];
          if (existingX[0] >= xDomain[1] || existingX[1] <= xDomain[0]) {
            continue;
          }
          if (existingY[0] < yDomain[1] && existingY[1] > yDomain[0]) {
            return true;
          }
        }
        return false;
      }
      function lsInner(gd) {
        var fullLayout = gd._fullLayout;
        var gs = fullLayout._size;
        var pad = gs.p;
        var axList = Axes.list(gd, "", true);
        var i, subplot, plotinfo, ax, xa, ya;
        fullLayout._paperdiv.style({
          width: gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroWidth && !gd.layout.width ? "100%" : fullLayout.width + "px",
          height: gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroHeight && !gd.layout.height ? "100%" : fullLayout.height + "px"
        }).selectAll(".main-svg").call(Drawing.setSize, fullLayout.width, fullLayout.height);
        gd._context.setBackground(gd, fullLayout.paper_bgcolor);
        exports.drawMainTitle(gd);
        ModeBar.manage(gd);
        if (!fullLayout._has("cartesian")) {
          return Plots.previousPromises(gd);
        }
        function getLinePosition(ax2, counterAx2, side) {
          var lwHalf = ax2._lw / 2;
          if (ax2._id.charAt(0) === "x") {
            if (!counterAx2) return gs.t + gs.h * (1 - (ax2.position || 0)) + lwHalf % 1;
            else if (side === "top") return counterAx2._offset - pad - lwHalf;
            return counterAx2._offset + counterAx2._length + pad + lwHalf;
          }
          if (!counterAx2) return gs.l + gs.w * (ax2.position || 0) + lwHalf % 1;
          else if (side === "right") return counterAx2._offset + counterAx2._length + pad + lwHalf;
          return counterAx2._offset - pad - lwHalf;
        }
        for (i = 0; i < axList.length; i++) {
          ax = axList[i];
          var counterAx = ax._anchorAxis;
          ax._linepositions = {};
          ax._lw = Drawing.crispRound(gd, ax.linewidth, 1);
          ax._mainLinePosition = getLinePosition(ax, counterAx, ax.side);
          ax._mainMirrorPosition = ax.mirror && counterAx ? getLinePosition(
            ax,
            counterAx,
            alignmentConstants.OPPOSITE_SIDE[ax.side]
          ) : null;
        }
        var lowerBackgroundIDs = [];
        var backgroundIds = [];
        var lowerDomains = [];
        var noNeedForBg = Color.opacity(fullLayout.paper_bgcolor) === 1 && Color.opacity(fullLayout.plot_bgcolor) === 1 && fullLayout.paper_bgcolor === fullLayout.plot_bgcolor;
        for (subplot in fullLayout._plots) {
          plotinfo = fullLayout._plots[subplot];
          if (plotinfo.mainplot) {
            if (plotinfo.bg) {
              plotinfo.bg.remove();
            }
            plotinfo.bg = void 0;
          } else {
            var xDomain = plotinfo.xaxis.domain;
            var yDomain = plotinfo.yaxis.domain;
            var plotgroup = plotinfo.plotgroup;
            if (overlappingDomain(xDomain, yDomain, lowerDomains) && subplot.indexOf(zindexSeparator) === -1) {
              var pgNode = plotgroup.node();
              var plotgroupBg = plotinfo.bg = Lib.ensureSingle(plotgroup, "rect", "bg");
              pgNode.insertBefore(plotgroupBg.node(), pgNode.childNodes[0]);
              backgroundIds.push(subplot);
            } else {
              plotgroup.select("rect.bg").remove();
              lowerDomains.push([xDomain, yDomain]);
              if (!noNeedForBg) {
                lowerBackgroundIDs.push(subplot);
                backgroundIds.push(subplot);
              }
            }
          }
        }
        var lowerBackgrounds = fullLayout._bgLayer.selectAll(".bg").data(lowerBackgroundIDs);
        lowerBackgrounds.enter().append("rect").classed("bg", true);
        lowerBackgrounds.exit().remove();
        lowerBackgrounds.each(function(subplot2) {
          fullLayout._plots[subplot2].bg = d3.select(this);
        });
        for (i = 0; i < backgroundIds.length; i++) {
          plotinfo = fullLayout._plots[backgroundIds[i]];
          xa = plotinfo.xaxis;
          ya = plotinfo.yaxis;
          if (plotinfo.bg && xa._offset !== void 0 && ya._offset !== void 0) {
            plotinfo.bg.call(
              Drawing.setRect,
              xa._offset - pad,
              ya._offset - pad,
              xa._length + 2 * pad,
              ya._length + 2 * pad
            ).call(Color.fill, fullLayout.plot_bgcolor).style("stroke-width", 0);
          }
        }
        if (!fullLayout._hasOnlyLargeSploms) {
          for (subplot in fullLayout._plots) {
            plotinfo = fullLayout._plots[subplot];
            xa = plotinfo.xaxis;
            ya = plotinfo.yaxis;
            var clipId = plotinfo.clipId = "clip" + fullLayout._uid + subplot + "plot";
            var plotClip = Lib.ensureSingleById(fullLayout._clips, "clipPath", clipId, function(s) {
              s.classed("plotclip", true).append("rect");
            });
            plotinfo.clipRect = plotClip.select("rect").attr({
              width: xa._length,
              height: ya._length
            });
            Drawing.setTranslate(plotinfo.plot, xa._offset, ya._offset);
            var plotClipId;
            var layerClipId;
            if (plotinfo._hasClipOnAxisFalse) {
              plotClipId = null;
              layerClipId = clipId;
            } else {
              plotClipId = clipId;
              layerClipId = null;
            }
            Drawing.setClipUrl(plotinfo.plot, plotClipId, gd);
            plotinfo.layerClipId = layerClipId;
          }
        }
        var xLinesXLeft, xLinesXRight, xLinesYBottom, xLinesYTop, leftYLineWidth, rightYLineWidth;
        var yLinesYBottom, yLinesYTop, yLinesXLeft, yLinesXRight, connectYBottom, connectYTop;
        var extraSubplot;
        function xLinePath(y) {
          return "M" + xLinesXLeft + "," + y + "H" + xLinesXRight;
        }
        function xLinePathFree(y) {
          return "M" + xa._offset + "," + y + "h" + xa._length;
        }
        function yLinePath(x) {
          return "M" + x + "," + yLinesYTop + "V" + yLinesYBottom;
        }
        function yLinePathFree(x) {
          if (ya._shift !== void 0) {
            x += ya._shift;
          }
          return "M" + x + "," + ya._offset + "v" + ya._length;
        }
        function mainPath(ax2, pathFn, pathFnFree) {
          if (!ax2.showline || subplot !== ax2._mainSubplot) return "";
          if (!ax2._anchorAxis) return pathFnFree(ax2._mainLinePosition);
          var out = pathFn(ax2._mainLinePosition);
          if (ax2.mirror) out += pathFn(ax2._mainMirrorPosition);
          return out;
        }
        for (subplot in fullLayout._plots) {
          plotinfo = fullLayout._plots[subplot];
          xa = plotinfo.xaxis;
          ya = plotinfo.yaxis;
          var xPath = "M0,0";
          if (shouldShowLinesOrTicks(xa, subplot)) {
            leftYLineWidth = findCounterAxisLineWidth(xa, "left", ya, axList);
            xLinesXLeft = xa._offset - (leftYLineWidth ? pad + leftYLineWidth : 0);
            rightYLineWidth = findCounterAxisLineWidth(xa, "right", ya, axList);
            xLinesXRight = xa._offset + xa._length + (rightYLineWidth ? pad + rightYLineWidth : 0);
            xLinesYBottom = getLinePosition(xa, ya, "bottom");
            xLinesYTop = getLinePosition(xa, ya, "top");
            extraSubplot = !xa._anchorAxis || subplot !== xa._mainSubplot;
            if (extraSubplot && (xa.mirror === "allticks" || xa.mirror === "all")) {
              xa._linepositions[subplot] = [xLinesYBottom, xLinesYTop];
            }
            xPath = mainPath(xa, xLinePath, xLinePathFree);
            if (extraSubplot && xa.showline && (xa.mirror === "all" || xa.mirror === "allticks")) {
              xPath += xLinePath(xLinesYBottom) + xLinePath(xLinesYTop);
            }
            plotinfo.xlines.style("stroke-width", xa._lw + "px").call(Color.stroke, xa.showline ? xa.linecolor : "rgba(0,0,0,0)");
          }
          plotinfo.xlines.attr("d", xPath);
          var yPath = "M0,0";
          if (shouldShowLinesOrTicks(ya, subplot)) {
            connectYBottom = findCounterAxisLineWidth(ya, "bottom", xa, axList);
            yLinesYBottom = ya._offset + ya._length + (connectYBottom ? pad : 0);
            connectYTop = findCounterAxisLineWidth(ya, "top", xa, axList);
            yLinesYTop = ya._offset - (connectYTop ? pad : 0);
            yLinesXLeft = getLinePosition(ya, xa, "left");
            yLinesXRight = getLinePosition(ya, xa, "right");
            extraSubplot = !ya._anchorAxis || subplot !== ya._mainSubplot;
            if (extraSubplot && (ya.mirror === "allticks" || ya.mirror === "all")) {
              ya._linepositions[subplot] = [yLinesXLeft, yLinesXRight];
            }
            yPath = mainPath(ya, yLinePath, yLinePathFree);
            if (extraSubplot && ya.showline && (ya.mirror === "all" || ya.mirror === "allticks")) {
              yPath += yLinePath(yLinesXLeft) + yLinePath(yLinesXRight);
            }
            plotinfo.ylines.style("stroke-width", ya._lw + "px").call(Color.stroke, ya.showline ? ya.linecolor : "rgba(0,0,0,0)");
          }
          plotinfo.ylines.attr("d", yPath);
        }
        Axes.makeClipPaths(gd);
        return Plots.previousPromises(gd);
      }
      function shouldShowLinesOrTicks(ax, subplot) {
        return (ax.ticks || ax.showline) && (subplot === ax._mainSubplot || ax.mirror === "all" || ax.mirror === "allticks");
      }
      function shouldShowLineThisSide(ax, side, counterAx) {
        if (!counterAx.showline || !counterAx._lw) return false;
        if (counterAx.mirror === "all" || counterAx.mirror === "allticks") return true;
        var anchorAx = counterAx._anchorAxis;
        if (!anchorAx) return false;
        var sideIndex = alignmentConstants.FROM_BL[side];
        if (counterAx.side === side) {
          return anchorAx.domain[sideIndex] === ax.domain[sideIndex];
        }
        return counterAx.mirror && anchorAx.domain[1 - sideIndex] === ax.domain[1 - sideIndex];
      }
      function findCounterAxisLineWidth(ax, side, counterAx, axList) {
        if (shouldShowLineThisSide(ax, side, counterAx)) {
          return counterAx._lw;
        }
        for (var i = 0; i < axList.length; i++) {
          var axi = axList[i];
          if (axi._mainAxis === counterAx._mainAxis && shouldShowLineThisSide(ax, side, axi)) {
            return axi._lw;
          }
        }
        return 0;
      }
      exports.drawMainTitle = function(gd) {
        var title = gd._fullLayout.title;
        var fullLayout = gd._fullLayout;
        var textAnchor = getMainTitleTextAnchor(fullLayout);
        var dy = getMainTitleDy(fullLayout);
        var y = getMainTitleY(fullLayout, dy);
        var x = getMainTitleX(fullLayout, textAnchor);
        Titles.draw(gd, "gtitle", {
          propContainer: fullLayout,
          propName: "title.text",
          subtitlePropName: "title.subtitle.text",
          placeholder: fullLayout._dfltTitle.plot,
          subtitlePlaceholder: fullLayout._dfltTitle.subtitle,
          attributes: {
            x,
            y,
            "text-anchor": textAnchor,
            dy
          }
        });
        if (title.text && title.automargin) {
          var titleObj = d3.selectAll(".gtitle");
          var titleHeight = Drawing.bBox(d3.selectAll(".g-gtitle").node()).height;
          var pushMargin = needsMarginPush(gd, title, titleHeight);
          if (pushMargin > 0) {
            applyTitleAutoMargin(gd, y, pushMargin, titleHeight);
            titleObj.attr({
              x,
              y,
              "text-anchor": textAnchor,
              dy: getMainTitleDyAdj(title.yanchor)
            }).call(svgTextUtils.positionText, x, y);
            var extraLines = (title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;
            if (extraLines) {
              var delta = alignmentConstants.LINE_SPACING * extraLines + alignmentConstants.MID_SHIFT;
              if (title.y === 0) {
                delta = -delta;
              }
              titleObj.selectAll(".line").each(function() {
                var newDy = +this.getAttribute("dy").slice(0, -2) - delta + "em";
                this.setAttribute("dy", newDy);
              });
            }
            var subtitleObj = d3.selectAll(".gtitle-subtitle");
            if (subtitleObj.node()) {
              var titleBB = titleObj.node().getBBox();
              var titleBottom = titleBB.y + titleBB.height;
              var subtitleY = titleBottom + Titles.SUBTITLE_PADDING_EM * title.subtitle.font.size;
              subtitleObj.attr({
                x,
                y: subtitleY,
                "text-anchor": textAnchor,
                dy: getMainTitleDyAdj(title.yanchor)
              }).call(svgTextUtils.positionText, x, subtitleY);
            }
          }
        }
      };
      function isOutsideContainer(gd, title, position, y, titleHeight) {
        var plotHeight = title.yref === "paper" ? gd._fullLayout._size.h : gd._fullLayout.height;
        var yPosTop = Lib.isTopAnchor(title) ? y : y - titleHeight;
        var yPosRel = position === "b" ? plotHeight - yPosTop : yPosTop;
        if (Lib.isTopAnchor(title) && position === "t" || Lib.isBottomAnchor(title) && position === "b") {
          return false;
        } else {
          return yPosRel < titleHeight;
        }
      }
      function containerPushVal(position, titleY, titleYanchor, height, titleDepth) {
        var push = 0;
        if (titleYanchor === "middle") {
          push += titleDepth / 2;
        }
        if (position === "t") {
          if (titleYanchor === "top") {
            push += titleDepth;
          }
          push += height - titleY * height;
        } else {
          if (titleYanchor === "bottom") {
            push += titleDepth;
          }
          push += titleY * height;
        }
        return push;
      }
      function needsMarginPush(gd, title, titleHeight) {
        var titleY = title.y;
        var titleYanchor = title.yanchor;
        var position = titleY > 0.5 ? "t" : "b";
        var curMargin = gd._fullLayout.margin[position];
        var pushMargin = 0;
        if (title.yref === "paper") {
          pushMargin = titleHeight + title.pad.t + title.pad.b;
        } else if (title.yref === "container") {
          pushMargin = containerPushVal(position, titleY, titleYanchor, gd._fullLayout.height, titleHeight) + title.pad.t + title.pad.b;
        }
        if (pushMargin > curMargin) {
          return pushMargin;
        }
        return 0;
      }
      function applyTitleAutoMargin(gd, y, pushMargin, titleHeight) {
        var titleID = "title.automargin";
        var title = gd._fullLayout.title;
        var position = title.y > 0.5 ? "t" : "b";
        var push = {
          x: title.x,
          y: title.y,
          t: 0,
          b: 0
        };
        var reservedPush = {};
        if (title.yref === "paper" && isOutsideContainer(gd, title, position, y, titleHeight)) {
          push[position] = pushMargin;
        } else if (title.yref === "container") {
          reservedPush[position] = pushMargin;
          gd._fullLayout._reservedMargin[titleID] = reservedPush;
        }
        Plots.allowAutoMargin(gd, titleID);
        Plots.autoMargin(gd, titleID, push);
      }
      function getMainTitleX(fullLayout, textAnchor) {
        var title = fullLayout.title;
        var gs = fullLayout._size;
        var hPadShift = 0;
        if (textAnchor === SVG_TEXT_ANCHOR_START) {
          hPadShift = title.pad.l;
        } else if (textAnchor === SVG_TEXT_ANCHOR_END) {
          hPadShift = -title.pad.r;
        }
        switch (title.xref) {
          case "paper":
            return gs.l + gs.w * title.x + hPadShift;
          case "container":
          default:
            return fullLayout.width * title.x + hPadShift;
        }
      }
      function getMainTitleY(fullLayout, dy) {
        var title = fullLayout.title;
        var gs = fullLayout._size;
        var vPadShift = 0;
        if (dy === "0em" || !dy) {
          vPadShift = -title.pad.b;
        } else if (dy === alignmentConstants.CAP_SHIFT + "em") {
          vPadShift = title.pad.t;
        }
        if (title.y === "auto") {
          return gs.t / 2;
        } else {
          switch (title.yref) {
            case "paper":
              return gs.t + gs.h - gs.h * title.y + vPadShift;
            case "container":
            default:
              return fullLayout.height - fullLayout.height * title.y + vPadShift;
          }
        }
      }
      function getMainTitleDyAdj(yanchor) {
        if (yanchor === "top") {
          return alignmentConstants.CAP_SHIFT + 0.3 + "em";
        } else if (yanchor === "bottom") {
          return "-0.3em";
        } else {
          return alignmentConstants.MID_SHIFT + "em";
        }
      }
      function getMainTitleTextAnchor(fullLayout) {
        var title = fullLayout.title;
        var textAnchor = SVG_TEXT_ANCHOR_MIDDLE;
        if (Lib.isRightAnchor(title)) {
          textAnchor = SVG_TEXT_ANCHOR_END;
        } else if (Lib.isLeftAnchor(title)) {
          textAnchor = SVG_TEXT_ANCHOR_START;
        }
        return textAnchor;
      }
      function getMainTitleDy(fullLayout) {
        var title = fullLayout.title;
        var dy = "0em";
        if (Lib.isTopAnchor(title)) {
          dy = alignmentConstants.CAP_SHIFT + "em";
        } else if (Lib.isMiddleAnchor(title)) {
          dy = alignmentConstants.MID_SHIFT + "em";
        }
        return dy;
      }
      exports.doTraceStyle = function(gd) {
        var calcdata = gd.calcdata;
        var editStyleCalls = [];
        var i;
        for (i = 0; i < calcdata.length; i++) {
          var cd = calcdata[i];
          var cd0 = cd[0] || {};
          var trace = cd0.trace || {};
          var _module = trace._module || {};
          var arraysToCalcdata = _module.arraysToCalcdata;
          if (arraysToCalcdata) arraysToCalcdata(cd, trace);
          var editStyle = _module.editStyle;
          if (editStyle) editStyleCalls.push({ fn: editStyle, cd0 });
        }
        if (editStyleCalls.length) {
          for (i = 0; i < editStyleCalls.length; i++) {
            var edit = editStyleCalls[i];
            edit.fn(gd, edit.cd0);
          }
          clearGlCanvases(gd);
          exports.redrawReglTraces(gd);
        }
        Plots.style(gd);
        Registry.getComponentMethod("legend", "draw")(gd);
        return Plots.previousPromises(gd);
      };
      exports.doColorBars = function(gd) {
        Registry.getComponentMethod("colorbar", "draw")(gd);
        return Plots.previousPromises(gd);
      };
      exports.layoutReplot = function(gd) {
        var layout = gd.layout;
        gd.layout = void 0;
        return Registry.call("_doPlot", gd, "", layout);
      };
      exports.doLegend = function(gd) {
        Registry.getComponentMethod("legend", "draw")(gd);
        return Plots.previousPromises(gd);
      };
      exports.doTicksRelayout = function(gd) {
        Axes.draw(gd, "redraw");
        if (gd._fullLayout._hasOnlyLargeSploms) {
          Registry.subplotsRegistry.splom.updateGrid(gd);
          clearGlCanvases(gd);
          exports.redrawReglTraces(gd);
        }
        exports.drawMainTitle(gd);
        return Plots.previousPromises(gd);
      };
      exports.doModeBar = function(gd) {
        var fullLayout = gd._fullLayout;
        ModeBar.manage(gd);
        for (var i = 0; i < fullLayout._basePlotModules.length; i++) {
          var updateFx = fullLayout._basePlotModules[i].updateFx;
          if (updateFx) updateFx(gd);
        }
        return Plots.previousPromises(gd);
      };
      exports.doCamera = function(gd) {
        var fullLayout = gd._fullLayout;
        var sceneIds = fullLayout._subplots.gl3d;
        for (var i = 0; i < sceneIds.length; i++) {
          var sceneLayout = fullLayout[sceneIds[i]];
          var scene = sceneLayout._scene;
          scene.setViewport(sceneLayout);
        }
      };
      exports.drawData = function(gd) {
        var fullLayout = gd._fullLayout;
        clearGlCanvases(gd);
        var basePlotModules = fullLayout._basePlotModules;
        for (var i = 0; i < basePlotModules.length; i++) {
          basePlotModules[i].plot(gd);
        }
        exports.redrawReglTraces(gd);
        Plots.style(gd);
        Registry.getComponentMethod("selections", "draw")(gd);
        Registry.getComponentMethod("shapes", "draw")(gd);
        Registry.getComponentMethod("annotations", "draw")(gd);
        Registry.getComponentMethod("images", "draw")(gd);
        fullLayout._replotting = false;
        return Plots.previousPromises(gd);
      };
      exports.redrawReglTraces = function(gd) {
        var fullLayout = gd._fullLayout;
        if (fullLayout._has("regl")) {
          var fullData = gd._fullData;
          var cartesianIds = [];
          var polarIds = [];
          var i, sp;
          if (fullLayout._hasOnlyLargeSploms) {
            fullLayout._splomGrid.draw();
          }
          for (i = 0; i < fullData.length; i++) {
            var trace = fullData[i];
            if (trace.visible === true && trace._length !== 0) {
              if (trace.type === "splom") {
                fullLayout._splomScenes[trace.uid].draw();
              } else if (trace.type === "scattergl") {
                Lib.pushUnique(cartesianIds, trace.xaxis + trace.yaxis);
              } else if (trace.type === "scatterpolargl") {
                Lib.pushUnique(polarIds, trace.subplot);
              }
            }
          }
          for (i = 0; i < cartesianIds.length; i++) {
            sp = fullLayout._plots[cartesianIds[i]];
            if (sp._scene) sp._scene.draw();
          }
          for (i = 0; i < polarIds.length; i++) {
            sp = fullLayout[polarIds[i]]._subplot;
            if (sp._scene) sp._scene.draw();
          }
        }
      };
      exports.doAutoRangeAndConstraints = function(gd) {
        var axList = Axes.list(gd, "", true);
        var ax;
        var autoRangeDone = {};
        for (var i = 0; i < axList.length; i++) {
          ax = axList[i];
          if (!autoRangeDone[ax._id]) {
            autoRangeDone[ax._id] = 1;
            cleanAxisConstraints(gd, ax);
            doAutoRange(gd, ax);
            var matchGroup = ax._matchGroup;
            if (matchGroup) {
              for (var id2 in matchGroup) {
                var ax2 = Axes.getFromId(gd, id2);
                doAutoRange(gd, ax2, ax.range);
                autoRangeDone[id2] = 1;
              }
            }
          }
        }
        enforceAxisConstraints(gd);
      };
      exports.finalDraw = function(gd) {
        Registry.getComponentMethod("rangeslider", "draw")(gd);
        Registry.getComponentMethod("rangeselector", "draw")(gd);
      };
      exports.drawMarginPushers = function(gd) {
        Registry.getComponentMethod("legend", "draw")(gd);
        Registry.getComponentMethod("rangeselector", "draw")(gd);
        Registry.getComponentMethod("sliders", "draw")(gd);
        Registry.getComponentMethod("updatemenus", "draw")(gd);
        Registry.getComponentMethod("colorbar", "draw")(gd);
      };
    }
  });

  // src/components/selections/draw.js
  var require_draw3 = __commonJS({
    "src/components/selections/draw.js"(exports, module) {
      "use strict";
      var readPaths = require_helpers7().readPaths;
      var displayOutlines = require_display_outlines();
      var clearOutlineControllers = require_handle_outline().clearOutlineControllers;
      var Color = require_color();
      var Drawing = require_drawing();
      var arrayEditor = require_plot_template().arrayEditor;
      var helpers = require_helpers8();
      var getPathString = helpers.getPathString;
      module.exports = {
        draw,
        drawOne,
        activateLastSelection
      };
      function draw(gd) {
        var fullLayout = gd._fullLayout;
        clearOutlineControllers(gd);
        fullLayout._selectionLayer.selectAll("path").remove();
        for (var k in fullLayout._plots) {
          var selectionLayer = fullLayout._plots[k].selectionLayer;
          if (selectionLayer) selectionLayer.selectAll("path").remove();
        }
        for (var i = 0; i < fullLayout.selections.length; i++) {
          drawOne(gd, i);
        }
      }
      function couldHaveActiveSelection(gd) {
        return gd._context.editSelection;
      }
      function drawOne(gd, index) {
        gd._fullLayout._paperdiv.selectAll('.selectionlayer [data-index="' + index + '"]').remove();
        var o = helpers.makeSelectionsOptionsAndPlotinfo(gd, index);
        var options = o.options;
        var plotinfo = o.plotinfo;
        if (!options._input) return;
        drawSelection(gd._fullLayout._selectionLayer);
        function drawSelection(selectionLayer) {
          var d = getPathString(gd, options);
          var attrs = {
            "data-index": index,
            "fill-rule": "evenodd",
            d
          };
          var opacity = options.opacity;
          var fillColor = "rgba(0,0,0,0)";
          var lineColor = options.line.color || Color.contrast(gd._fullLayout.plot_bgcolor);
          var lineWidth = options.line.width;
          var lineDash = options.line.dash;
          if (!lineWidth) {
            lineWidth = 5;
            lineDash = "solid";
          }
          var isActiveSelection = couldHaveActiveSelection(gd) && gd._fullLayout._activeSelectionIndex === index;
          if (isActiveSelection) {
            fillColor = gd._fullLayout.activeselection.fillcolor;
            opacity = gd._fullLayout.activeselection.opacity;
          }
          var allPaths = [];
          for (var sensory = 1; sensory >= 0; sensory--) {
            var path = selectionLayer.append("path").attr(attrs).style("opacity", sensory ? 0.1 : opacity).call(Color.stroke, lineColor).call(Color.fill, fillColor).call(
              Drawing.dashLine,
              sensory ? "solid" : lineDash,
              sensory ? 4 + lineWidth : lineWidth
            );
            setClipPath(path, gd, options);
            if (isActiveSelection) {
              var editHelpers = arrayEditor(gd.layout, "selections", options);
              path.style({
                cursor: "move"
              });
              var dragOptions = {
                element: path.node(),
                plotinfo,
                gd,
                editHelpers,
                isActiveSelection: true
                // i.e. to enable controllers
              };
              var polygons = readPaths(d, gd);
              displayOutlines(polygons, path, dragOptions);
            } else {
              path.style("pointer-events", sensory ? "all" : "none");
            }
            allPaths[sensory] = path;
          }
          var forePath = allPaths[0];
          var backPath = allPaths[1];
          backPath.node().addEventListener("click", function() {
            return activateSelection(gd, forePath);
          });
        }
      }
      function setClipPath(selectionPath, gd, selectionOptions) {
        var clipAxes = selectionOptions.xref + selectionOptions.yref;
        Drawing.setClipUrl(
          selectionPath,
          "clip" + gd._fullLayout._uid + clipAxes,
          gd
        );
      }
      function activateSelection(gd, path) {
        if (!couldHaveActiveSelection(gd)) return;
        var element = path.node();
        var id = +element.getAttribute("data-index");
        if (id >= 0) {
          if (id === gd._fullLayout._activeSelectionIndex) {
            deactivateSelection(gd);
            return;
          }
          gd._fullLayout._activeSelectionIndex = id;
          gd._fullLayout._deactivateSelection = deactivateSelection;
          draw(gd);
        }
      }
      function activateLastSelection(gd) {
        if (!couldHaveActiveSelection(gd)) return;
        var id = gd._fullLayout.selections.length - 1;
        gd._fullLayout._activeSelectionIndex = id;
        gd._fullLayout._deactivateSelection = deactivateSelection;
        draw(gd);
      }
      function deactivateSelection(gd) {
        if (!couldHaveActiveSelection(gd)) return;
        var id = gd._fullLayout._activeSelectionIndex;
        if (id >= 0) {
          clearOutlineControllers(gd);
          delete gd._fullLayout._activeSelectionIndex;
          draw(gd);
        }
      }
    }
  });

  // node_modules/polybooljs/lib/build-log.js
  var require_build_log = __commonJS({
    "node_modules/polybooljs/lib/build-log.js"(exports, module) {
      function BuildLog() {
        var my;
        var nextSegmentId = 0;
        var curVert = false;
        function push(type, data) {
          my.list.push({
            type,
            data: data ? JSON.parse(JSON.stringify(data)) : void 0
          });
          return my;
        }
        my = {
          list: [],
          segmentId: function() {
            return nextSegmentId++;
          },
          checkIntersection: function(seg1, seg2) {
            return push("check", { seg1, seg2 });
          },
          segmentChop: function(seg, end) {
            push("div_seg", { seg, pt: end });
            return push("chop", { seg, pt: end });
          },
          statusRemove: function(seg) {
            return push("pop_seg", { seg });
          },
          segmentUpdate: function(seg) {
            return push("seg_update", { seg });
          },
          segmentNew: function(seg, primary) {
            return push("new_seg", { seg, primary });
          },
          segmentRemove: function(seg) {
            return push("rem_seg", { seg });
          },
          tempStatus: function(seg, above, below) {
            return push("temp_status", { seg, above, below });
          },
          rewind: function(seg) {
            return push("rewind", { seg });
          },
          status: function(seg, above, below) {
            return push("status", { seg, above, below });
          },
          vert: function(x) {
            if (x === curVert)
              return my;
            curVert = x;
            return push("vert", { x });
          },
          log: function(data) {
            if (typeof data !== "string")
              data = JSON.stringify(data, false, "  ");
            return push("log", { txt: data });
          },
          reset: function() {
            return push("reset");
          },
          selected: function(segs) {
            return push("selected", { segs });
          },
          chainStart: function(seg) {
            return push("chain_start", { seg });
          },
          chainRemoveHead: function(index, pt) {
            return push("chain_rem_head", { index, pt });
          },
          chainRemoveTail: function(index, pt) {
            return push("chain_rem_tail", { index, pt });
          },
          chainNew: function(pt1, pt2) {
            return push("chain_new", { pt1, pt2 });
          },
          chainMatch: function(index) {
            return push("chain_match", { index });
          },
          chainClose: function(index) {
            return push("chain_close", { index });
          },
          chainAddHead: function(index, pt) {
            return push("chain_add_head", { index, pt });
          },
          chainAddTail: function(index, pt) {
            return push("chain_add_tail", { index, pt });
          },
          chainConnect: function(index1, index2) {
            return push("chain_con", { index1, index2 });
          },
          chainReverse: function(index) {
            return push("chain_rev", { index });
          },
          chainJoin: function(index1, index2) {
            return push("chain_join", { index1, index2 });
          },
          done: function() {
            return push("done");
          }
        };
        return my;
      }
      module.exports = BuildLog;
    }
  });

  // node_modules/polybooljs/lib/epsilon.js
  var require_epsilon = __commonJS({
    "node_modules/polybooljs/lib/epsilon.js"(exports, module) {
      function Epsilon(eps) {
        if (typeof eps !== "number")
          eps = 1e-10;
        var my = {
          epsilon: function(v) {
            if (typeof v === "number")
              eps = v;
            return eps;
          },
          pointAboveOrOnLine: function(pt, left, right) {
            var Ax = left[0];
            var Ay = left[1];
            var Bx = right[0];
            var By = right[1];
            var Cx = pt[0];
            var Cy = pt[1];
            return (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax) >= -eps;
          },
          pointBetween: function(p, left, right) {
            var d_py_ly = p[1] - left[1];
            var d_rx_lx = right[0] - left[0];
            var d_px_lx = p[0] - left[0];
            var d_ry_ly = right[1] - left[1];
            var dot = d_px_lx * d_rx_lx + d_py_ly * d_ry_ly;
            if (dot < eps)
              return false;
            var sqlen = d_rx_lx * d_rx_lx + d_ry_ly * d_ry_ly;
            if (dot - sqlen > -eps)
              return false;
            return true;
          },
          pointsSameX: function(p1, p2) {
            return Math.abs(p1[0] - p2[0]) < eps;
          },
          pointsSameY: function(p1, p2) {
            return Math.abs(p1[1] - p2[1]) < eps;
          },
          pointsSame: function(p1, p2) {
            return my.pointsSameX(p1, p2) && my.pointsSameY(p1, p2);
          },
          pointsCompare: function(p1, p2) {
            if (my.pointsSameX(p1, p2))
              return my.pointsSameY(p1, p2) ? 0 : p1[1] < p2[1] ? -1 : 1;
            return p1[0] < p2[0] ? -1 : 1;
          },
          pointsCollinear: function(pt1, pt2, pt3) {
            var dx1 = pt1[0] - pt2[0];
            var dy1 = pt1[1] - pt2[1];
            var dx2 = pt2[0] - pt3[0];
            var dy2 = pt2[1] - pt3[1];
            return Math.abs(dx1 * dy2 - dx2 * dy1) < eps;
          },
          linesIntersect: function(a0, a1, b0, b1) {
            var adx = a1[0] - a0[0];
            var ady = a1[1] - a0[1];
            var bdx = b1[0] - b0[0];
            var bdy = b1[1] - b0[1];
            var axb = adx * bdy - ady * bdx;
            if (Math.abs(axb) < eps)
              return false;
            var dx = a0[0] - b0[0];
            var dy = a0[1] - b0[1];
            var A = (bdx * dy - bdy * dx) / axb;
            var B = (adx * dy - ady * dx) / axb;
            var ret = {
              alongA: 0,
              alongB: 0,
              pt: [
                a0[0] + A * adx,
                a0[1] + A * ady
              ]
            };
            if (A <= -eps)
              ret.alongA = -2;
            else if (A < eps)
              ret.alongA = -1;
            else if (A - 1 <= -eps)
              ret.alongA = 0;
            else if (A - 1 < eps)
              ret.alongA = 1;
            else
              ret.alongA = 2;
            if (B <= -eps)
              ret.alongB = -2;
            else if (B < eps)
              ret.alongB = -1;
            else if (B - 1 <= -eps)
              ret.alongB = 0;
            else if (B - 1 < eps)
              ret.alongB = 1;
            else
              ret.alongB = 2;
            return ret;
          },
          pointInsideRegion: function(pt, region) {
            var x = pt[0];
            var y = pt[1];
            var last_x = region[region.length - 1][0];
            var last_y = region[region.length - 1][1];
            var inside = false;
            for (var i = 0; i < region.length; i++) {
              var curr_x = region[i][0];
              var curr_y = region[i][1];
              if (curr_y - y > eps != last_y - y > eps && (last_x - curr_x) * (y - curr_y) / (last_y - curr_y) + curr_x - x > eps)
                inside = !inside;
              last_x = curr_x;
              last_y = curr_y;
            }
            return inside;
          }
        };
        return my;
      }
      module.exports = Epsilon;
    }
  });

  // node_modules/polybooljs/lib/linked-list.js
  var require_linked_list = __commonJS({
    "node_modules/polybooljs/lib/linked-list.js"(exports, module) {
      var LinkedList = {
        create: function() {
          var my = {
            root: { root: true, next: null },
            exists: function(node) {
              if (node === null || node === my.root)
                return false;
              return true;
            },
            isEmpty: function() {
              return my.root.next === null;
            },
            getHead: function() {
              return my.root.next;
            },
            insertBefore: function(node, check) {
              var last = my.root;
              var here = my.root.next;
              while (here !== null) {
                if (check(here)) {
                  node.prev = here.prev;
                  node.next = here;
                  here.prev.next = node;
                  here.prev = node;
                  return;
                }
                last = here;
                here = here.next;
              }
              last.next = node;
              node.prev = last;
              node.next = null;
            },
            findTransition: function(check) {
              var prev = my.root;
              var here = my.root.next;
              while (here !== null) {
                if (check(here))
                  break;
                prev = here;
                here = here.next;
              }
              return {
                before: prev === my.root ? null : prev,
                after: here,
                insert: function(node) {
                  node.prev = prev;
                  node.next = here;
                  prev.next = node;
                  if (here !== null)
                    here.prev = node;
                  return node;
                }
              };
            }
          };
          return my;
        },
        node: function(data) {
          data.prev = null;
          data.next = null;
          data.remove = function() {
            data.prev.next = data.next;
            if (data.next)
              data.next.prev = data.prev;
            data.prev = null;
            data.next = null;
          };
          return data;
        }
      };
      module.exports = LinkedList;
    }
  });

  // node_modules/polybooljs/lib/intersecter.js
  var require_intersecter = __commonJS({
    "node_modules/polybooljs/lib/intersecter.js"(exports, module) {
      var LinkedList = require_linked_list();
      function Intersecter(selfIntersection, eps, buildLog) {
        function segmentNew(start, end) {
          return {
            id: buildLog ? buildLog.segmentId() : -1,
            start,
            end,
            myFill: {
              above: null,
              // is there fill above us?
              below: null
              // is there fill below us?
            },
            otherFill: null
          };
        }
        function segmentCopy(start, end, seg) {
          return {
            id: buildLog ? buildLog.segmentId() : -1,
            start,
            end,
            myFill: {
              above: seg.myFill.above,
              below: seg.myFill.below
            },
            otherFill: null
          };
        }
        var event_root = LinkedList.create();
        function eventCompare(p1_isStart, p1_1, p1_2, p2_isStart, p2_1, p2_2) {
          var comp = eps.pointsCompare(p1_1, p2_1);
          if (comp !== 0)
            return comp;
          if (eps.pointsSame(p1_2, p2_2))
            return 0;
          if (p1_isStart !== p2_isStart)
            return p1_isStart ? 1 : -1;
          return eps.pointAboveOrOnLine(
            p1_2,
            p2_isStart ? p2_1 : p2_2,
            // order matters
            p2_isStart ? p2_2 : p2_1
          ) ? 1 : -1;
        }
        function eventAdd(ev, other_pt) {
          event_root.insertBefore(ev, function(here) {
            var comp = eventCompare(
              ev.isStart,
              ev.pt,
              other_pt,
              here.isStart,
              here.pt,
              here.other.pt
            );
            return comp < 0;
          });
        }
        function eventAddSegmentStart(seg, primary) {
          var ev_start = LinkedList.node({
            isStart: true,
            pt: seg.start,
            seg,
            primary,
            other: null,
            status: null
          });
          eventAdd(ev_start, seg.end);
          return ev_start;
        }
        function eventAddSegmentEnd(ev_start, seg, primary) {
          var ev_end = LinkedList.node({
            isStart: false,
            pt: seg.end,
            seg,
            primary,
            other: ev_start,
            status: null
          });
          ev_start.other = ev_end;
          eventAdd(ev_end, ev_start.pt);
        }
        function eventAddSegment(seg, primary) {
          var ev_start = eventAddSegmentStart(seg, primary);
          eventAddSegmentEnd(ev_start, seg, primary);
          return ev_start;
        }
        function eventUpdateEnd(ev, end) {
          if (buildLog)
            buildLog.segmentChop(ev.seg, end);
          ev.other.remove();
          ev.seg.end = end;
          ev.other.pt = end;
          eventAdd(ev.other, ev.pt);
        }
        function eventDivide(ev, pt) {
          var ns = segmentCopy(pt, ev.seg.end, ev.seg);
          eventUpdateEnd(ev, pt);
          return eventAddSegment(ns, ev.primary);
        }
        function calculate(primaryPolyInverted, secondaryPolyInverted) {
          var status_root = LinkedList.create();
          function statusCompare(ev1, ev2) {
            var a1 = ev1.seg.start;
            var a2 = ev1.seg.end;
            var b1 = ev2.seg.start;
            var b2 = ev2.seg.end;
            if (eps.pointsCollinear(a1, b1, b2)) {
              if (eps.pointsCollinear(a2, b1, b2))
                return 1;
              return eps.pointAboveOrOnLine(a2, b1, b2) ? 1 : -1;
            }
            return eps.pointAboveOrOnLine(a1, b1, b2) ? 1 : -1;
          }
          function statusFindSurrounding(ev2) {
            return status_root.findTransition(function(here) {
              var comp = statusCompare(ev2, here.ev);
              return comp > 0;
            });
          }
          function checkIntersection(ev1, ev2) {
            var seg1 = ev1.seg;
            var seg2 = ev2.seg;
            var a1 = seg1.start;
            var a2 = seg1.end;
            var b1 = seg2.start;
            var b2 = seg2.end;
            if (buildLog)
              buildLog.checkIntersection(seg1, seg2);
            var i = eps.linesIntersect(a1, a2, b1, b2);
            if (i === false) {
              if (!eps.pointsCollinear(a1, a2, b1))
                return false;
              if (eps.pointsSame(a1, b2) || eps.pointsSame(a2, b1))
                return false;
              var a1_equ_b1 = eps.pointsSame(a1, b1);
              var a2_equ_b2 = eps.pointsSame(a2, b2);
              if (a1_equ_b1 && a2_equ_b2)
                return ev2;
              var a1_between = !a1_equ_b1 && eps.pointBetween(a1, b1, b2);
              var a2_between = !a2_equ_b2 && eps.pointBetween(a2, b1, b2);
              if (a1_equ_b1) {
                if (a2_between) {
                  eventDivide(ev2, a2);
                } else {
                  eventDivide(ev1, b2);
                }
                return ev2;
              } else if (a1_between) {
                if (!a2_equ_b2) {
                  if (a2_between) {
                    eventDivide(ev2, a2);
                  } else {
                    eventDivide(ev1, b2);
                  }
                }
                eventDivide(ev2, a1);
              }
            } else {
              if (i.alongA === 0) {
                if (i.alongB === -1)
                  eventDivide(ev1, b1);
                else if (i.alongB === 0)
                  eventDivide(ev1, i.pt);
                else if (i.alongB === 1)
                  eventDivide(ev1, b2);
              }
              if (i.alongB === 0) {
                if (i.alongA === -1)
                  eventDivide(ev2, a1);
                else if (i.alongA === 0)
                  eventDivide(ev2, i.pt);
                else if (i.alongA === 1)
                  eventDivide(ev2, a2);
              }
            }
            return false;
          }
          var segments = [];
          while (!event_root.isEmpty()) {
            var ev = event_root.getHead();
            if (buildLog)
              buildLog.vert(ev.pt[0]);
            if (ev.isStart) {
              let checkBothIntersections2 = function() {
                if (above) {
                  var eve2 = checkIntersection(ev, above);
                  if (eve2)
                    return eve2;
                }
                if (below)
                  return checkIntersection(ev, below);
                return false;
              };
              var checkBothIntersections = checkBothIntersections2;
              if (buildLog)
                buildLog.segmentNew(ev.seg, ev.primary);
              var surrounding = statusFindSurrounding(ev);
              var above = surrounding.before ? surrounding.before.ev : null;
              var below = surrounding.after ? surrounding.after.ev : null;
              if (buildLog) {
                buildLog.tempStatus(
                  ev.seg,
                  above ? above.seg : false,
                  below ? below.seg : false
                );
              }
              var eve = checkBothIntersections2();
              if (eve) {
                if (selfIntersection) {
                  var toggle;
                  if (ev.seg.myFill.below === null)
                    toggle = true;
                  else
                    toggle = ev.seg.myFill.above !== ev.seg.myFill.below;
                  if (toggle)
                    eve.seg.myFill.above = !eve.seg.myFill.above;
                } else {
                  eve.seg.otherFill = ev.seg.myFill;
                }
                if (buildLog)
                  buildLog.segmentUpdate(eve.seg);
                ev.other.remove();
                ev.remove();
              }
              if (event_root.getHead() !== ev) {
                if (buildLog)
                  buildLog.rewind(ev.seg);
                continue;
              }
              if (selfIntersection) {
                var toggle;
                if (ev.seg.myFill.below === null)
                  toggle = true;
                else
                  toggle = ev.seg.myFill.above !== ev.seg.myFill.below;
                if (!below) {
                  ev.seg.myFill.below = primaryPolyInverted;
                } else {
                  ev.seg.myFill.below = below.seg.myFill.above;
                }
                if (toggle)
                  ev.seg.myFill.above = !ev.seg.myFill.below;
                else
                  ev.seg.myFill.above = ev.seg.myFill.below;
              } else {
                if (ev.seg.otherFill === null) {
                  var inside;
                  if (!below) {
                    inside = ev.primary ? secondaryPolyInverted : primaryPolyInverted;
                  } else {
                    if (ev.primary === below.primary)
                      inside = below.seg.otherFill.above;
                    else
                      inside = below.seg.myFill.above;
                  }
                  ev.seg.otherFill = {
                    above: inside,
                    below: inside
                  };
                }
              }
              if (buildLog) {
                buildLog.status(
                  ev.seg,
                  above ? above.seg : false,
                  below ? below.seg : false
                );
              }
              ev.other.status = surrounding.insert(LinkedList.node({ ev }));
            } else {
              var st = ev.status;
              if (st === null) {
                throw new Error("PolyBool: Zero-length segment detected; your epsilon is probably too small or too large");
              }
              if (status_root.exists(st.prev) && status_root.exists(st.next))
                checkIntersection(st.prev.ev, st.next.ev);
              if (buildLog)
                buildLog.statusRemove(st.ev.seg);
              st.remove();
              if (!ev.primary) {
                var s = ev.seg.myFill;
                ev.seg.myFill = ev.seg.otherFill;
                ev.seg.otherFill = s;
              }
              segments.push(ev.seg);
            }
            event_root.getHead().remove();
          }
          if (buildLog)
            buildLog.done();
          return segments;
        }
        if (!selfIntersection) {
          return {
            calculate: function(segments1, inverted1, segments2, inverted2) {
              segments1.forEach(function(seg) {
                eventAddSegment(segmentCopy(seg.start, seg.end, seg), true);
              });
              segments2.forEach(function(seg) {
                eventAddSegment(segmentCopy(seg.start, seg.end, seg), false);
              });
              return calculate(inverted1, inverted2);
            }
          };
        }
        return {
          addRegion: function(region) {
            var pt1;
            var pt2 = region[region.length - 1];
            for (var i = 0; i < region.length; i++) {
              pt1 = pt2;
              pt2 = region[i];
              var forward = eps.pointsCompare(pt1, pt2);
              if (forward === 0)
                continue;
              eventAddSegment(
                segmentNew(
                  forward < 0 ? pt1 : pt2,
                  forward < 0 ? pt2 : pt1
                ),
                true
              );
            }
          },
          calculate: function(inverted) {
            return calculate(inverted, false);
          }
        };
      }
      module.exports = Intersecter;
    }
  });

  // node_modules/polybooljs/lib/segment-chainer.js
  var require_segment_chainer = __commonJS({
    "node_modules/polybooljs/lib/segment-chainer.js"(exports, module) {
      function SegmentChainer(segments, eps, buildLog) {
        var chains = [];
        var regions = [];
        segments.forEach(function(seg) {
          var pt1 = seg.start;
          var pt2 = seg.end;
          if (eps.pointsSame(pt1, pt2)) {
            console.warn("PolyBool: Warning: Zero-length segment detected; your epsilon is probably too small or too large");
            return;
          }
          if (buildLog)
            buildLog.chainStart(seg);
          var first_match = {
            index: 0,
            matches_head: false,
            matches_pt1: false
          };
          var second_match = {
            index: 0,
            matches_head: false,
            matches_pt1: false
          };
          var next_match = first_match;
          function setMatch(index2, matches_head, matches_pt1) {
            next_match.index = index2;
            next_match.matches_head = matches_head;
            next_match.matches_pt1 = matches_pt1;
            if (next_match === first_match) {
              next_match = second_match;
              return false;
            }
            next_match = null;
            return true;
          }
          for (var i = 0; i < chains.length; i++) {
            var chain = chains[i];
            var head = chain[0];
            var head2 = chain[1];
            var tail = chain[chain.length - 1];
            var tail2 = chain[chain.length - 2];
            if (eps.pointsSame(head, pt1)) {
              if (setMatch(i, true, true))
                break;
            } else if (eps.pointsSame(head, pt2)) {
              if (setMatch(i, true, false))
                break;
            } else if (eps.pointsSame(tail, pt1)) {
              if (setMatch(i, false, true))
                break;
            } else if (eps.pointsSame(tail, pt2)) {
              if (setMatch(i, false, false))
                break;
            }
          }
          if (next_match === first_match) {
            chains.push([pt1, pt2]);
            if (buildLog)
              buildLog.chainNew(pt1, pt2);
            return;
          }
          if (next_match === second_match) {
            if (buildLog)
              buildLog.chainMatch(first_match.index);
            var index = first_match.index;
            var pt = first_match.matches_pt1 ? pt2 : pt1;
            var addToHead = first_match.matches_head;
            var chain = chains[index];
            var grow = addToHead ? chain[0] : chain[chain.length - 1];
            var grow2 = addToHead ? chain[1] : chain[chain.length - 2];
            var oppo = addToHead ? chain[chain.length - 1] : chain[0];
            var oppo2 = addToHead ? chain[chain.length - 2] : chain[1];
            if (eps.pointsCollinear(grow2, grow, pt)) {
              if (addToHead) {
                if (buildLog)
                  buildLog.chainRemoveHead(first_match.index, pt);
                chain.shift();
              } else {
                if (buildLog)
                  buildLog.chainRemoveTail(first_match.index, pt);
                chain.pop();
              }
              grow = grow2;
            }
            if (eps.pointsSame(oppo, pt)) {
              chains.splice(index, 1);
              if (eps.pointsCollinear(oppo2, oppo, grow)) {
                if (addToHead) {
                  if (buildLog)
                    buildLog.chainRemoveTail(first_match.index, grow);
                  chain.pop();
                } else {
                  if (buildLog)
                    buildLog.chainRemoveHead(first_match.index, grow);
                  chain.shift();
                }
              }
              if (buildLog)
                buildLog.chainClose(first_match.index);
              regions.push(chain);
              return;
            }
            if (addToHead) {
              if (buildLog)
                buildLog.chainAddHead(first_match.index, pt);
              chain.unshift(pt);
            } else {
              if (buildLog)
                buildLog.chainAddTail(first_match.index, pt);
              chain.push(pt);
            }
            return;
          }
          function reverseChain(index2) {
            if (buildLog)
              buildLog.chainReverse(index2);
            chains[index2].reverse();
          }
          function appendChain(index1, index2) {
            var chain1 = chains[index1];
            var chain2 = chains[index2];
            var tail3 = chain1[chain1.length - 1];
            var tail22 = chain1[chain1.length - 2];
            var head3 = chain2[0];
            var head22 = chain2[1];
            if (eps.pointsCollinear(tail22, tail3, head3)) {
              if (buildLog)
                buildLog.chainRemoveTail(index1, tail3);
              chain1.pop();
              tail3 = tail22;
            }
            if (eps.pointsCollinear(tail3, head3, head22)) {
              if (buildLog)
                buildLog.chainRemoveHead(index2, head3);
              chain2.shift();
            }
            if (buildLog)
              buildLog.chainJoin(index1, index2);
            chains[index1] = chain1.concat(chain2);
            chains.splice(index2, 1);
          }
          var F = first_match.index;
          var S = second_match.index;
          if (buildLog)
            buildLog.chainConnect(F, S);
          var reverseF = chains[F].length < chains[S].length;
          if (first_match.matches_head) {
            if (second_match.matches_head) {
              if (reverseF) {
                reverseChain(F);
                appendChain(F, S);
              } else {
                reverseChain(S);
                appendChain(S, F);
              }
            } else {
              appendChain(S, F);
            }
          } else {
            if (second_match.matches_head) {
              appendChain(F, S);
            } else {
              if (reverseF) {
                reverseChain(F);
                appendChain(S, F);
              } else {
                reverseChain(S);
                appendChain(F, S);
              }
            }
          }
        });
        return regions;
      }
      module.exports = SegmentChainer;
    }
  });

  // node_modules/polybooljs/lib/segment-selector.js
  var require_segment_selector = __commonJS({
    "node_modules/polybooljs/lib/segment-selector.js"(exports, module) {
      function select(segments, selection, buildLog) {
        var result = [];
        segments.forEach(function(seg) {
          var index = (seg.myFill.above ? 8 : 0) + (seg.myFill.below ? 4 : 0) + (seg.otherFill && seg.otherFill.above ? 2 : 0) + (seg.otherFill && seg.otherFill.below ? 1 : 0);
          if (selection[index] !== 0) {
            result.push({
              id: buildLog ? buildLog.segmentId() : -1,
              start: seg.start,
              end: seg.end,
              myFill: {
                above: selection[index] === 1,
                // 1 if filled above
                below: selection[index] === 2
                // 2 if filled below
              },
              otherFill: null
            });
          }
        });
        if (buildLog)
          buildLog.selected(result);
        return result;
      }
      var SegmentSelector = {
        union: function(segments, buildLog) {
          return select(segments, [
            0,
            2,
            1,
            0,
            2,
            2,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
          ], buildLog);
        },
        intersect: function(segments, buildLog) {
          return select(segments, [
            0,
            0,
            0,
            0,
            0,
            2,
            0,
            2,
            0,
            0,
            1,
            1,
            0,
            2,
            1,
            0
          ], buildLog);
        },
        difference: function(segments, buildLog) {
          return select(segments, [
            0,
            0,
            0,
            0,
            2,
            0,
            2,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            0
          ], buildLog);
        },
        differenceRev: function(segments, buildLog) {
          return select(segments, [
            0,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            2,
            0,
            2,
            0,
            0,
            0,
            0
          ], buildLog);
        },
        xor: function(segments, buildLog) {
          return select(segments, [
            0,
            2,
            1,
            0,
            2,
            0,
            0,
            1,
            1,
            0,
            0,
            2,
            0,
            1,
            2,
            0
          ], buildLog);
        }
      };
      module.exports = SegmentSelector;
    }
  });

  // node_modules/polybooljs/lib/geojson.js
  var require_geojson = __commonJS({
    "node_modules/polybooljs/lib/geojson.js"(exports, module) {
      var GeoJSON = {
        // convert a GeoJSON object to a PolyBool polygon
        toPolygon: function(PolyBool, geojson) {
          function GeoPoly(coords) {
            if (coords.length <= 0)
              return PolyBool.segments({ inverted: false, regions: [] });
            function LineString(ls) {
              var reg = ls.slice(0, ls.length - 1);
              return PolyBool.segments({ inverted: false, regions: [reg] });
            }
            var out2 = LineString(coords[0]);
            for (var i2 = 1; i2 < coords.length; i2++)
              out2 = PolyBool.selectDifference(PolyBool.combine(out2, LineString(coords[i2])));
            return out2;
          }
          if (geojson.type === "Polygon") {
            return PolyBool.polygon(GeoPoly(geojson.coordinates));
          } else if (geojson.type === "MultiPolygon") {
            var out = PolyBool.segments({ inverted: false, regions: [] });
            for (var i = 0; i < geojson.coordinates.length; i++)
              out = PolyBool.selectUnion(PolyBool.combine(out, GeoPoly(geojson.coordinates[i])));
            return PolyBool.polygon(out);
          }
          throw new Error("PolyBool: Cannot convert GeoJSON object to PolyBool polygon");
        },
        // convert a PolyBool polygon to a GeoJSON object
        fromPolygon: function(PolyBool, eps, poly) {
          poly = PolyBool.polygon(PolyBool.segments(poly));
          function regionInsideRegion(r1, r2) {
            return eps.pointInsideRegion([
              (r1[0][0] + r1[1][0]) * 0.5,
              (r1[0][1] + r1[1][1]) * 0.5
            ], r2);
          }
          function newNode(region2) {
            return {
              region: region2,
              children: []
            };
          }
          var roots = newNode(null);
          function addChild(root, region2) {
            for (var i2 = 0; i2 < root.children.length; i2++) {
              var child = root.children[i2];
              if (regionInsideRegion(region2, child.region)) {
                addChild(child, region2);
                return;
              }
            }
            var node = newNode(region2);
            for (var i2 = 0; i2 < root.children.length; i2++) {
              var child = root.children[i2];
              if (regionInsideRegion(child.region, region2)) {
                node.children.push(child);
                root.children.splice(i2, 1);
                i2--;
              }
            }
            root.children.push(node);
          }
          for (var i = 0; i < poly.regions.length; i++) {
            var region = poly.regions[i];
            if (region.length < 3)
              continue;
            addChild(roots, region);
          }
          function forceWinding(region2, clockwise) {
            var winding = 0;
            var last_x = region2[region2.length - 1][0];
            var last_y = region2[region2.length - 1][1];
            var copy = [];
            for (var i2 = 0; i2 < region2.length; i2++) {
              var curr_x = region2[i2][0];
              var curr_y = region2[i2][1];
              copy.push([curr_x, curr_y]);
              winding += curr_y * last_x - curr_x * last_y;
              last_x = curr_x;
              last_y = curr_y;
            }
            var isclockwise = winding < 0;
            if (isclockwise !== clockwise)
              copy.reverse();
            copy.push([copy[0][0], copy[0][1]]);
            return copy;
          }
          var geopolys = [];
          function addExterior(node) {
            var poly2 = [forceWinding(node.region, false)];
            geopolys.push(poly2);
            for (var i2 = 0; i2 < node.children.length; i2++)
              poly2.push(getInterior(node.children[i2]));
          }
          function getInterior(node) {
            for (var i2 = 0; i2 < node.children.length; i2++)
              addExterior(node.children[i2]);
            return forceWinding(node.region, true);
          }
          for (var i = 0; i < roots.children.length; i++)
            addExterior(roots.children[i]);
          if (geopolys.length <= 0)
            return { type: "Polygon", coordinates: [] };
          if (geopolys.length == 1)
            return { type: "Polygon", coordinates: geopolys[0] };
          return {
            // otherwise, use a GeoJSON MultiPolygon
            type: "MultiPolygon",
            coordinates: geopolys
          };
        }
      };
      module.exports = GeoJSON;
    }
  });

  // node_modules/polybooljs/index.js
  var require_polybooljs = __commonJS({
    "node_modules/polybooljs/index.js"(exports, module) {
      var BuildLog = require_build_log();
      var Epsilon = require_epsilon();
      var Intersecter = require_intersecter();
      var SegmentChainer = require_segment_chainer();
      var SegmentSelector = require_segment_selector();
      var GeoJSON = require_geojson();
      var buildLog = false;
      var epsilon = Epsilon();
      var PolyBool;
      PolyBool = {
        // getter/setter for buildLog
        buildLog: function(bl) {
          if (bl === true)
            buildLog = BuildLog();
          else if (bl === false)
            buildLog = false;
          return buildLog === false ? false : buildLog.list;
        },
        // getter/setter for epsilon
        epsilon: function(v) {
          return epsilon.epsilon(v);
        },
        // core API
        segments: function(poly) {
          var i = Intersecter(true, epsilon, buildLog);
          poly.regions.forEach(i.addRegion);
          return {
            segments: i.calculate(poly.inverted),
            inverted: poly.inverted
          };
        },
        combine: function(segments1, segments2) {
          var i3 = Intersecter(false, epsilon, buildLog);
          return {
            combined: i3.calculate(
              segments1.segments,
              segments1.inverted,
              segments2.segments,
              segments2.inverted
            ),
            inverted1: segments1.inverted,
            inverted2: segments2.inverted
          };
        },
        selectUnion: function(combined) {
          return {
            segments: SegmentSelector.union(combined.combined, buildLog),
            inverted: combined.inverted1 || combined.inverted2
          };
        },
        selectIntersect: function(combined) {
          return {
            segments: SegmentSelector.intersect(combined.combined, buildLog),
            inverted: combined.inverted1 && combined.inverted2
          };
        },
        selectDifference: function(combined) {
          return {
            segments: SegmentSelector.difference(combined.combined, buildLog),
            inverted: combined.inverted1 && !combined.inverted2
          };
        },
        selectDifferenceRev: function(combined) {
          return {
            segments: SegmentSelector.differenceRev(combined.combined, buildLog),
            inverted: !combined.inverted1 && combined.inverted2
          };
        },
        selectXor: function(combined) {
          return {
            segments: SegmentSelector.xor(combined.combined, buildLog),
            inverted: combined.inverted1 !== combined.inverted2
          };
        },
        polygon: function(segments) {
          return {
            regions: SegmentChainer(segments.segments, epsilon, buildLog),
            inverted: segments.inverted
          };
        },
        // GeoJSON converters
        polygonFromGeoJSON: function(geojson) {
          return GeoJSON.toPolygon(PolyBool, geojson);
        },
        polygonToGeoJSON: function(poly) {
          return GeoJSON.fromPolygon(PolyBool, epsilon, poly);
        },
        // helper functions for common operations
        union: function(poly1, poly2) {
          return operate(poly1, poly2, PolyBool.selectUnion);
        },
        intersect: function(poly1, poly2) {
          return operate(poly1, poly2, PolyBool.selectIntersect);
        },
        difference: function(poly1, poly2) {
          return operate(poly1, poly2, PolyBool.selectDifference);
        },
        differenceRev: function(poly1, poly2) {
          return operate(poly1, poly2, PolyBool.selectDifferenceRev);
        },
        xor: function(poly1, poly2) {
          return operate(poly1, poly2, PolyBool.selectXor);
        }
      };
      function operate(poly1, poly2, selector) {
        var seg1 = PolyBool.segments(poly1);
        var seg2 = PolyBool.segments(poly2);
        var comb = PolyBool.combine(seg1, seg2);
        var seg3 = selector(comb);
        return PolyBool.polygon(seg3);
      }
      if (typeof window === "object")
        window.PolyBool = PolyBool;
      module.exports = PolyBool;
    }
  });

  // node_modules/point-in-polygon/nested.js
  var require_nested = __commonJS({
    "node_modules/point-in-polygon/nested.js"(exports, module) {
      module.exports = function pointInPolygonNested(point, vs, start, end) {
        var x = point[0], y = point[1];
        var inside = false;
        if (start === void 0) start = 0;
        if (end === void 0) end = vs.length;
        var len = end - start;
        for (var i = 0, j = len - 1; i < len; j = i++) {
          var xi = vs[i + start][0], yi = vs[i + start][1];
          var xj = vs[j + start][0], yj = vs[j + start][1];
          var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
          if (intersect) inside = !inside;
        }
        return inside;
      };
    }
  });

  // src/lib/polygon.js
  var require_polygon = __commonJS({
    "src/lib/polygon.js"(exports, module) {
      "use strict";
      var dot = require_matrix().dot;
      var BADNUM = require_numerical().BADNUM;
      var polygon = module.exports = {};
      polygon.tester = function tester(ptsIn) {
        var pts = ptsIn.slice();
        var xmin = pts[0][0];
        var xmax = xmin;
        var ymin = pts[0][1];
        var ymax = ymin;
        var i;
        if (pts[pts.length - 1][0] !== pts[0][0] || pts[pts.length - 1][1] !== pts[0][1]) {
          pts.push(pts[0]);
        }
        for (i = 1; i < pts.length; i++) {
          xmin = Math.min(xmin, pts[i][0]);
          xmax = Math.max(xmax, pts[i][0]);
          ymin = Math.min(ymin, pts[i][1]);
          ymax = Math.max(ymax, pts[i][1]);
        }
        var isRect = false;
        var rectFirstEdgeTest;
        if (pts.length === 5) {
          if (pts[0][0] === pts[1][0]) {
            if (pts[2][0] === pts[3][0] && pts[0][1] === pts[3][1] && pts[1][1] === pts[2][1]) {
              isRect = true;
              rectFirstEdgeTest = function(pt) {
                return pt[0] === pts[0][0];
              };
            }
          } else if (pts[0][1] === pts[1][1]) {
            if (pts[2][1] === pts[3][1] && pts[0][0] === pts[3][0] && pts[1][0] === pts[2][0]) {
              isRect = true;
              rectFirstEdgeTest = function(pt) {
                return pt[1] === pts[0][1];
              };
            }
          }
        }
        function rectContains(pt, omitFirstEdge) {
          var x = pt[0];
          var y = pt[1];
          if (x === BADNUM || x < xmin || x > xmax || y === BADNUM || y < ymin || y > ymax) {
            return false;
          }
          if (omitFirstEdge && rectFirstEdgeTest(pt)) return false;
          return true;
        }
        function contains(pt, omitFirstEdge) {
          var x = pt[0];
          var y = pt[1];
          if (x === BADNUM || x < xmin || x > xmax || y === BADNUM || y < ymin || y > ymax) {
            return false;
          }
          var imax = pts.length;
          var x1 = pts[0][0];
          var y1 = pts[0][1];
          var crossings = 0;
          var i2;
          var x0;
          var y0;
          var xmini;
          var ycross;
          for (i2 = 1; i2 < imax; i2++) {
            x0 = x1;
            y0 = y1;
            x1 = pts[i2][0];
            y1 = pts[i2][1];
            xmini = Math.min(x0, x1);
            if (x < xmini || x > Math.max(x0, x1) || y > Math.max(y0, y1)) {
              continue;
            } else if (y < Math.min(y0, y1)) {
              if (x !== xmini) crossings++;
            } else {
              if (x1 === x0) ycross = y;
              else ycross = y0 + (x - x0) * (y1 - y0) / (x1 - x0);
              if (y === ycross) {
                if (i2 === 1 && omitFirstEdge) return false;
                return true;
              }
              if (y <= ycross && x !== xmini) crossings++;
            }
          }
          return crossings % 2 === 1;
        }
        var degenerate = true;
        var lastPt = pts[0];
        for (i = 1; i < pts.length; i++) {
          if (lastPt[0] !== pts[i][0] || lastPt[1] !== pts[i][1]) {
            degenerate = false;
            break;
          }
        }
        return {
          xmin,
          xmax,
          ymin,
          ymax,
          pts,
          contains: isRect ? rectContains : contains,
          isRect,
          degenerate
        };
      };
      polygon.isSegmentBent = function isSegmentBent(pts, start, end, tolerance) {
        var startPt = pts[start];
        var segment = [pts[end][0] - startPt[0], pts[end][1] - startPt[1]];
        var segmentSquared = dot(segment, segment);
        var segmentLen = Math.sqrt(segmentSquared);
        var unitPerp = [-segment[1] / segmentLen, segment[0] / segmentLen];
        var i;
        var part;
        var partParallel;
        for (i = start + 1; i < end; i++) {
          part = [pts[i][0] - startPt[0], pts[i][1] - startPt[1]];
          partParallel = dot(part, segment);
          if (partParallel < 0 || partParallel > segmentSquared || Math.abs(dot(part, unitPerp)) > tolerance) return true;
        }
        return false;
      };
      polygon.filter = function filter(pts, tolerance) {
        var ptsFiltered = [pts[0]];
        var doneRawIndex = 0;
        var doneFilteredIndex = 0;
        function addPt(pt) {
          pts.push(pt);
          var prevFilterLen = ptsFiltered.length;
          var iLast = doneRawIndex;
          ptsFiltered.splice(doneFilteredIndex + 1);
          for (var i = iLast + 1; i < pts.length; i++) {
            if (i === pts.length - 1 || polygon.isSegmentBent(pts, iLast, i + 1, tolerance)) {
              ptsFiltered.push(pts[i]);
              if (ptsFiltered.length < prevFilterLen - 2) {
                doneRawIndex = i;
                doneFilteredIndex = ptsFiltered.length - 1;
              }
              iLast = i;
            }
          }
        }
        if (pts.length > 1) {
          var lastPt = pts.pop();
          addPt(lastPt);
        }
        return {
          addPt,
          raw: pts,
          filtered: ptsFiltered
        };
      };
    }
  });

  // src/components/selections/constants.js
  var require_constants7 = __commonJS({
    "src/components/selections/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // max pixels off straight before a lasso select line counts as bent
        BENDPX: 1.5,
        // smallest dimension allowed for a select box
        MINSELECT: 12,
        // throttling limit (ms) for selectPoints calls
        SELECTDELAY: 100,
        // cache ID suffix for throttle
        SELECTID: "-select"
      };
    }
  });

  // src/components/selections/select.js
  var require_select = __commonJS({
    "src/components/selections/select.js"(exports, module) {
      "use strict";
      var polybool = require_polybooljs();
      var pointInPolygon = require_nested();
      var Registry = require_registry();
      var dashStyle = require_drawing().dashStyle;
      var Color = require_color();
      var Fx = require_fx();
      var makeEventData = require_helpers2().makeEventData;
      var dragHelpers = require_helpers5();
      var freeMode = dragHelpers.freeMode;
      var rectMode = dragHelpers.rectMode;
      var drawMode = dragHelpers.drawMode;
      var openMode = dragHelpers.openMode;
      var selectMode = dragHelpers.selectMode;
      var shapeHelpers = require_helpers8();
      var shapeConstants = require_constants5();
      var displayOutlines = require_display_outlines();
      var clearOutline = require_handle_outline().clearOutline;
      var newShapeHelpers = require_helpers7();
      var handleEllipse = newShapeHelpers.handleEllipse;
      var readPaths = newShapeHelpers.readPaths;
      var newShapes = require_newshapes().newShapes;
      var newSelections = require_newselections();
      var activateLastSelection = require_draw3().activateLastSelection;
      var Lib = require_lib();
      var ascending = Lib.sorterAsc;
      var libPolygon = require_polygon();
      var throttle = require_throttle();
      var getFromId = require_axis_ids().getFromId;
      var clearGlCanvases = require_clear_gl_canvases();
      var redrawReglTraces = require_subroutines().redrawReglTraces;
      var constants = require_constants7();
      var MINSELECT = constants.MINSELECT;
      var filteredPolygon = libPolygon.filter;
      var polygonTester = libPolygon.tester;
      var helpers = require_helpers6();
      var p2r = helpers.p2r;
      var axValue = helpers.axValue;
      var getTransform = helpers.getTransform;
      function hasSubplot(dragOptions) {
        return dragOptions.subplot !== void 0;
      }
      function prepSelect(evt, startX, startY, dragOptions, mode) {
        var isCartesian = !hasSubplot(dragOptions);
        var isFreeMode = freeMode(mode);
        var isRectMode = rectMode(mode);
        var isOpenMode = openMode(mode);
        var isDrawMode = drawMode(mode);
        var isSelectMode = selectMode(mode);
        var isLine = mode === "drawline";
        var isEllipse = mode === "drawcircle";
        var isLineOrEllipse = isLine || isEllipse;
        var gd = dragOptions.gd;
        var fullLayout = gd._fullLayout;
        var immediateSelect = isSelectMode && fullLayout.newselection.mode === "immediate" && isCartesian;
        var zoomLayer = fullLayout._zoomlayer;
        var dragBBox = dragOptions.element.getBoundingClientRect();
        var plotinfo = dragOptions.plotinfo;
        var transform = getTransform(plotinfo);
        var x0 = startX - dragBBox.left;
        var y0 = startY - dragBBox.top;
        fullLayout._calcInverseTransform(gd);
        var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);
        x0 = transformedCoords[0];
        y0 = transformedCoords[1];
        var scaleX = fullLayout._invScaleX;
        var scaleY = fullLayout._invScaleY;
        var x1 = x0;
        var y1 = y0;
        var path0 = "M" + x0 + "," + y0;
        var xAxis = dragOptions.xaxes[0];
        var yAxis = dragOptions.yaxes[0];
        var pw = xAxis._length;
        var ph = yAxis._length;
        var subtract = evt.altKey && !(drawMode(mode) && isOpenMode);
        var filterPoly, selectionTesters, mergedPolygons, currentPolygon;
        var i, searchInfo, eventData;
        coerceSelectionsCache(evt, gd, dragOptions);
        if (isFreeMode) {
          filterPoly = filteredPolygon([[x0, y0]], constants.BENDPX);
        }
        var outlines = zoomLayer.selectAll("path.select-outline-" + plotinfo.id).data([1]);
        var newStyle = isDrawMode ? fullLayout.newshape : fullLayout.newselection;
        if (isDrawMode) {
          dragOptions.hasText = newStyle.label.text || newStyle.label.texttemplate;
        }
        var fillC = isDrawMode && !isOpenMode ? newStyle.fillcolor : "rgba(0,0,0,0)";
        var strokeC = newStyle.line.color || (isCartesian ? Color.contrast(gd._fullLayout.plot_bgcolor) : "#7f7f7f");
        outlines.enter().append("path").attr("class", "select-outline select-outline-" + plotinfo.id).style({
          opacity: isDrawMode ? newStyle.opacity / 2 : 1,
          "stroke-dasharray": dashStyle(newStyle.line.dash, newStyle.line.width),
          "stroke-width": newStyle.line.width + "px",
          "shape-rendering": "crispEdges"
        }).call(Color.stroke, strokeC).call(Color.fill, fillC).attr("fill-rule", "evenodd").classed("cursor-move", isDrawMode ? true : false).attr("transform", transform).attr("d", path0 + "Z");
        var corners = zoomLayer.append("path").attr("class", "zoombox-corners").style({
          fill: Color.background,
          stroke: Color.defaultLine,
          "stroke-width": 1
        }).attr("transform", transform).attr("d", "M0,0Z");
        if (isDrawMode && dragOptions.hasText) {
          var shapeGroup = zoomLayer.select(".label-temp");
          if (shapeGroup.empty()) {
            shapeGroup = zoomLayer.append("g").classed("label-temp", true).classed("select-outline", true).style({ opacity: 0.8 });
          }
        }
        var throttleID = fullLayout._uid + constants.SELECTID;
        var selection = [];
        var searchTraces = determineSearchTraces(
          gd,
          dragOptions.xaxes,
          dragOptions.yaxes,
          dragOptions.subplot
        );
        if (immediateSelect && !evt.shiftKey) {
          dragOptions._clearSubplotSelections = function() {
            if (!isCartesian) return;
            var xRef = xAxis._id;
            var yRef = yAxis._id;
            deselectSubplot(gd, xRef, yRef, searchTraces);
            var selections = (gd.layout || {}).selections || [];
            var list = [];
            var selectionErased = false;
            for (var q = 0; q < selections.length; q++) {
              var s = fullLayout.selections[q];
              if (!s || s.xref !== xRef || s.yref !== yRef) {
                list.push(selections[q]);
              } else {
                selectionErased = true;
              }
            }
            if (selectionErased) {
              gd._fullLayout._noEmitSelectedAtStart = true;
              Registry.call("_guiRelayout", gd, {
                selections: list
              });
            }
          };
        }
        var fillRangeItems = getFillRangeItems(dragOptions);
        dragOptions.moveFn = function(dx0, dy0) {
          if (dragOptions._clearSubplotSelections) {
            dragOptions._clearSubplotSelections();
            dragOptions._clearSubplotSelections = void 0;
          }
          x1 = Math.max(0, Math.min(pw, scaleX * dx0 + x0));
          y1 = Math.max(0, Math.min(ph, scaleY * dy0 + y0));
          var dx = Math.abs(x1 - x0);
          var dy = Math.abs(y1 - y0);
          if (isRectMode) {
            var direction;
            var start, end;
            if (isSelectMode) {
              var q = fullLayout.selectdirection;
              if (q === "any") {
                if (dy < Math.min(dx * 0.6, MINSELECT)) {
                  direction = "h";
                } else if (dx < Math.min(dy * 0.6, MINSELECT)) {
                  direction = "v";
                } else {
                  direction = "d";
                }
              } else {
                direction = q;
              }
              switch (direction) {
                case "h":
                  start = isEllipse ? ph / 2 : 0;
                  end = ph;
                  break;
                case "v":
                  start = isEllipse ? pw / 2 : 0;
                  end = pw;
                  break;
              }
            }
            if (isDrawMode) {
              switch (fullLayout.newshape.drawdirection) {
                case "vertical":
                  direction = "h";
                  start = isEllipse ? ph / 2 : 0;
                  end = ph;
                  break;
                case "horizontal":
                  direction = "v";
                  start = isEllipse ? pw / 2 : 0;
                  end = pw;
                  break;
                case "ortho":
                  if (dx < dy) {
                    direction = "h";
                    start = y0;
                    end = y1;
                  } else {
                    direction = "v";
                    start = x0;
                    end = x1;
                  }
                  break;
                default:
                  direction = "d";
              }
            }
            if (direction === "h") {
              currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x1, start], [x1, end]) : (
                // using x1 instead of x0 allows adjusting the line while drawing
                [[x0, start], [x0, end], [x1, end], [x1, start]]
              );
              currentPolygon.xmin = isLineOrEllipse ? x1 : Math.min(x0, x1);
              currentPolygon.xmax = isLineOrEllipse ? x1 : Math.max(x0, x1);
              currentPolygon.ymin = Math.min(start, end);
              currentPolygon.ymax = Math.max(start, end);
              corners.attr("d", "M" + currentPolygon.xmin + "," + (y0 - MINSELECT) + "h-4v" + 2 * MINSELECT + "h4ZM" + (currentPolygon.xmax - 1) + "," + (y0 - MINSELECT) + "h4v" + 2 * MINSELECT + "h-4Z");
            } else if (direction === "v") {
              currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [start, y1], [end, y1]) : (
                // using y1 instead of y0 allows adjusting the line while drawing
                [[start, y0], [start, y1], [end, y1], [end, y0]]
              );
              currentPolygon.xmin = Math.min(start, end);
              currentPolygon.xmax = Math.max(start, end);
              currentPolygon.ymin = isLineOrEllipse ? y1 : Math.min(y0, y1);
              currentPolygon.ymax = isLineOrEllipse ? y1 : Math.max(y0, y1);
              corners.attr("d", "M" + (x0 - MINSELECT) + "," + currentPolygon.ymin + "v-4h" + 2 * MINSELECT + "v4ZM" + (x0 - MINSELECT) + "," + (currentPolygon.ymax - 1) + "v4h" + 2 * MINSELECT + "v-4Z");
            } else if (direction === "d") {
              currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x0, y0], [x1, y1]) : [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];
              currentPolygon.xmin = Math.min(x0, x1);
              currentPolygon.xmax = Math.max(x0, x1);
              currentPolygon.ymin = Math.min(y0, y1);
              currentPolygon.ymax = Math.max(y0, y1);
              corners.attr("d", "M0,0Z");
            }
          } else if (isFreeMode) {
            filterPoly.addPt([x1, y1]);
            currentPolygon = filterPoly.filtered;
          }
          if (dragOptions.selectionDefs && dragOptions.selectionDefs.length) {
            mergedPolygons = mergePolygons(dragOptions.mergedPolygons, currentPolygon, subtract);
            currentPolygon.subtract = subtract;
            selectionTesters = multiTester(dragOptions.selectionDefs.concat([currentPolygon]));
          } else {
            mergedPolygons = [currentPolygon];
            selectionTesters = polygonTester(currentPolygon);
          }
          displayOutlines(convertPoly(mergedPolygons, isOpenMode), outlines, dragOptions);
          if (isSelectMode) {
            var _res = reselect(gd, false);
            var extraPoints = _res.eventData ? _res.eventData.points.slice() : [];
            _res = reselect(gd, false, selectionTesters, searchTraces, dragOptions);
            selectionTesters = _res.selectionTesters;
            eventData = _res.eventData;
            var poly;
            if (filterPoly) {
              poly = filterPoly.filtered;
            } else {
              poly = castMultiPolygon(mergedPolygons);
            }
            throttle.throttle(
              throttleID,
              constants.SELECTDELAY,
              function() {
                selection = _doSelect(selectionTesters, searchTraces);
                var newPoints = selection.slice();
                for (var w = 0; w < extraPoints.length; w++) {
                  var p = extraPoints[w];
                  var found = false;
                  for (var u = 0; u < newPoints.length; u++) {
                    if (newPoints[u].curveNumber === p.curveNumber && newPoints[u].pointNumber === p.pointNumber) {
                      found = true;
                      break;
                    }
                  }
                  if (!found) newPoints.push(p);
                }
                if (newPoints.length) {
                  if (!eventData) eventData = {};
                  eventData.points = newPoints;
                }
                fillRangeItems(eventData, poly);
                emitSelecting(gd, eventData);
              }
            );
          }
        };
        dragOptions.clickFn = function(numClicks, evt2) {
          corners.remove();
          if (gd._fullLayout._activeShapeIndex >= 0) {
            gd._fullLayout._deactivateShape(gd);
            return;
          }
          if (isDrawMode) return;
          var clickmode = fullLayout.clickmode;
          throttle.done(throttleID).then(function() {
            throttle.clear(throttleID);
            if (numClicks === 2) {
              outlines.remove();
              for (i = 0; i < searchTraces.length; i++) {
                searchInfo = searchTraces[i];
                searchInfo._module.selectPoints(searchInfo, false);
              }
              updateSelectedState(gd, searchTraces);
              clearSelectionsCache(dragOptions);
              emitDeselect(gd);
              if (searchTraces.length) {
                var clickedXaxis = searchTraces[0].xaxis;
                var clickedYaxis = searchTraces[0].yaxis;
                if (clickedXaxis && clickedYaxis) {
                  var subSelections = [];
                  var allSelections = gd._fullLayout.selections;
                  for (var k = 0; k < allSelections.length; k++) {
                    var s = allSelections[k];
                    if (!s) continue;
                    if (s.xref !== clickedXaxis._id || s.yref !== clickedYaxis._id) {
                      subSelections.push(s);
                    }
                  }
                  if (subSelections.length < allSelections.length) {
                    gd._fullLayout._noEmitSelectedAtStart = true;
                    Registry.call("_guiRelayout", gd, {
                      selections: subSelections
                    });
                  }
                }
              }
            } else {
              if (clickmode.indexOf("select") > -1) {
                selectOnClick(
                  evt2,
                  gd,
                  dragOptions.xaxes,
                  dragOptions.yaxes,
                  dragOptions.subplot,
                  dragOptions,
                  outlines
                );
              }
              if (clickmode === "event") {
                emitSelected(gd, void 0);
              }
            }
            Fx.click(gd, evt2, plotinfo.id);
          }).catch(Lib.error);
        };
        dragOptions.doneFn = function() {
          corners.remove();
          throttle.done(throttleID).then(function() {
            throttle.clear(throttleID);
            if (!immediateSelect && currentPolygon && dragOptions.selectionDefs) {
              currentPolygon.subtract = subtract;
              dragOptions.selectionDefs.push(currentPolygon);
              dragOptions.mergedPolygons.length = 0;
              [].push.apply(dragOptions.mergedPolygons, mergedPolygons);
            }
            if (immediateSelect || isDrawMode) {
              clearSelectionsCache(dragOptions, immediateSelect);
            }
            if (dragOptions.doneFnCompleted) {
              dragOptions.doneFnCompleted(selection);
            }
            if (isSelectMode) {
              emitSelected(gd, eventData);
            }
          }).catch(Lib.error);
        };
      }
      function selectOnClick(evt, gd, xAxes, yAxes, subplot, dragOptions, polygonOutlines) {
        var hoverData = gd._hoverdata;
        var fullLayout = gd._fullLayout;
        var clickmode = fullLayout.clickmode;
        var sendEvents = clickmode.indexOf("event") > -1;
        var selection = [];
        var searchTraces, searchInfo, currentSelectionDef, selectionTesters, traceSelection;
        var thisTracesSelection, pointOrBinSelected, subtract, eventData, i;
        if (isHoverDataSet(hoverData)) {
          coerceSelectionsCache(evt, gd, dragOptions);
          searchTraces = determineSearchTraces(gd, xAxes, yAxes, subplot);
          var clickedPtInfo = extractClickedPtInfo(hoverData, searchTraces);
          var isBinnedTrace = clickedPtInfo.pointNumbers.length > 0;
          if (isBinnedTrace ? isOnlyThisBinSelected(searchTraces, clickedPtInfo) : isOnlyOnePointSelected(searchTraces) && (pointOrBinSelected = isPointOrBinSelected(clickedPtInfo))) {
            if (polygonOutlines) polygonOutlines.remove();
            for (i = 0; i < searchTraces.length; i++) {
              searchInfo = searchTraces[i];
              searchInfo._module.selectPoints(searchInfo, false);
            }
            updateSelectedState(gd, searchTraces);
            clearSelectionsCache(dragOptions);
            if (sendEvents) {
              emitDeselect(gd);
            }
          } else {
            subtract = evt.shiftKey && (pointOrBinSelected !== void 0 ? pointOrBinSelected : isPointOrBinSelected(clickedPtInfo));
            currentSelectionDef = newPointSelectionDef(clickedPtInfo.pointNumber, clickedPtInfo.searchInfo, subtract);
            var allSelectionDefs = dragOptions.selectionDefs.concat([currentSelectionDef]);
            selectionTesters = multiTester(allSelectionDefs, selectionTesters);
            for (i = 0; i < searchTraces.length; i++) {
              traceSelection = searchTraces[i]._module.selectPoints(searchTraces[i], selectionTesters);
              thisTracesSelection = fillSelectionItem(traceSelection, searchTraces[i]);
              if (selection.length) {
                for (var j = 0; j < thisTracesSelection.length; j++) {
                  selection.push(thisTracesSelection[j]);
                }
              } else selection = thisTracesSelection;
            }
            eventData = { points: selection };
            updateSelectedState(gd, searchTraces, eventData);
            if (currentSelectionDef && dragOptions) {
              dragOptions.selectionDefs.push(currentSelectionDef);
            }
            if (polygonOutlines) {
              var polygons = dragOptions.mergedPolygons;
              var isOpenMode = openMode(dragOptions.dragmode);
              displayOutlines(convertPoly(polygons, isOpenMode), polygonOutlines, dragOptions);
            }
            if (sendEvents) {
              emitSelected(gd, eventData);
            }
          }
        }
      }
      function newPointSelectionDef(pointNumber, searchInfo, subtract) {
        return {
          pointNumber,
          searchInfo,
          subtract: !!subtract
        };
      }
      function isPointSelectionDef(o) {
        return "pointNumber" in o && "searchInfo" in o;
      }
      function newPointNumTester(pointSelectionDef) {
        return {
          xmin: 0,
          xmax: 0,
          ymin: 0,
          ymax: 0,
          pts: [],
          contains: function(pt, omitFirstEdge, pointNumber, searchInfo) {
            var idxWantedTrace = pointSelectionDef.searchInfo.cd[0].trace.index;
            var idxActualTrace = searchInfo.cd[0].trace.index;
            return idxActualTrace === idxWantedTrace && pointNumber === pointSelectionDef.pointNumber;
          },
          isRect: false,
          degenerate: false,
          subtract: !!pointSelectionDef.subtract
        };
      }
      function multiTester(list) {
        if (!list.length) return;
        var testers = [];
        var xmin = isPointSelectionDef(list[0]) ? 0 : list[0][0][0];
        var xmax = xmin;
        var ymin = isPointSelectionDef(list[0]) ? 0 : list[0][0][1];
        var ymax = ymin;
        for (var i = 0; i < list.length; i++) {
          if (isPointSelectionDef(list[i])) {
            testers.push(newPointNumTester(list[i]));
          } else {
            var tester = polygonTester(list[i]);
            tester.subtract = !!list[i].subtract;
            testers.push(tester);
            xmin = Math.min(xmin, tester.xmin);
            xmax = Math.max(xmax, tester.xmax);
            ymin = Math.min(ymin, tester.ymin);
            ymax = Math.max(ymax, tester.ymax);
          }
        }
        function contains(pt, arg, pointNumber, searchInfo) {
          var contained = false;
          for (var i2 = 0; i2 < testers.length; i2++) {
            if (testers[i2].contains(pt, arg, pointNumber, searchInfo)) {
              contained = !testers[i2].subtract;
            }
          }
          return contained;
        }
        return {
          xmin,
          xmax,
          ymin,
          ymax,
          pts: [],
          contains,
          isRect: false,
          degenerate: false
        };
      }
      function coerceSelectionsCache(evt, gd, dragOptions) {
        var fullLayout = gd._fullLayout;
        var plotinfo = dragOptions.plotinfo;
        var dragmode = dragOptions.dragmode;
        var selectingOnSameSubplot = fullLayout._lastSelectedSubplot && fullLayout._lastSelectedSubplot === plotinfo.id;
        var hasModifierKey = (evt.shiftKey || evt.altKey) && !(drawMode(dragmode) && openMode(dragmode));
        if (selectingOnSameSubplot && hasModifierKey && plotinfo.selection && plotinfo.selection.selectionDefs && !dragOptions.selectionDefs) {
          dragOptions.selectionDefs = plotinfo.selection.selectionDefs;
          dragOptions.mergedPolygons = plotinfo.selection.mergedPolygons;
        } else if (!hasModifierKey || !plotinfo.selection) {
          clearSelectionsCache(dragOptions);
        }
        if (!selectingOnSameSubplot) {
          clearOutline(gd);
          fullLayout._lastSelectedSubplot = plotinfo.id;
        }
      }
      function hasActiveShape(gd) {
        return gd._fullLayout._activeShapeIndex >= 0;
      }
      function hasActiveSelection(gd) {
        return gd._fullLayout._activeSelectionIndex >= 0;
      }
      function clearSelectionsCache(dragOptions, immediateSelect) {
        var dragmode = dragOptions.dragmode;
        var plotinfo = dragOptions.plotinfo;
        var gd = dragOptions.gd;
        if (hasActiveShape(gd)) {
          gd._fullLayout._deactivateShape(gd);
        }
        if (hasActiveSelection(gd)) {
          gd._fullLayout._deactivateSelection(gd);
        }
        var fullLayout = gd._fullLayout;
        var zoomLayer = fullLayout._zoomlayer;
        var isDrawMode = drawMode(dragmode);
        var isSelectMode = selectMode(dragmode);
        if (isDrawMode || isSelectMode) {
          var outlines = zoomLayer.selectAll(".select-outline-" + plotinfo.id);
          if (outlines && gd._fullLayout._outlining) {
            var shapes;
            if (isDrawMode) {
              shapes = newShapes(outlines, dragOptions);
            }
            if (shapes) {
              Registry.call("_guiRelayout", gd, {
                shapes
              });
            }
            var selections;
            if (isSelectMode && !hasSubplot(dragOptions)) {
              selections = newSelections(outlines, dragOptions);
            }
            if (selections) {
              gd._fullLayout._noEmitSelectedAtStart = true;
              Registry.call("_guiRelayout", gd, {
                selections
              }).then(function() {
                if (immediateSelect) {
                  activateLastSelection(gd);
                }
              });
            }
            gd._fullLayout._outlining = false;
          }
        }
        plotinfo.selection = {};
        plotinfo.selection.selectionDefs = dragOptions.selectionDefs = [];
        plotinfo.selection.mergedPolygons = dragOptions.mergedPolygons = [];
      }
      function getAxId(ax) {
        return ax._id;
      }
      function determineSearchTraces(gd, xAxes, yAxes, subplot) {
        if (!gd.calcdata) return [];
        var searchTraces = [];
        var xAxisIds = xAxes.map(getAxId);
        var yAxisIds = yAxes.map(getAxId);
        var cd, trace, i;
        for (i = 0; i < gd.calcdata.length; i++) {
          cd = gd.calcdata[i];
          trace = cd[0].trace;
          if (trace.visible !== true || !trace._module || !trace._module.selectPoints) continue;
          if (hasSubplot({ subplot }) && (trace.subplot === subplot || trace.geo === subplot)) {
            searchTraces.push(createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]));
          } else if (trace.type === "splom") {
            if (trace._xaxes[xAxisIds[0]] && trace._yaxes[yAxisIds[0]]) {
              var info = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);
              info.scene = gd._fullLayout._splomScenes[trace.uid];
              searchTraces.push(info);
            }
          } else if (trace.type === "sankey") {
            var sankeyInfo = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);
            searchTraces.push(sankeyInfo);
          } else {
            if (xAxisIds.indexOf(trace.xaxis) === -1 && (!trace._xA || !trace._xA.overlaying)) continue;
            if (yAxisIds.indexOf(trace.yaxis) === -1 && (!trace._yA || !trace._yA.overlaying)) continue;
            searchTraces.push(createSearchInfo(
              trace._module,
              cd,
              getFromId(gd, trace.xaxis),
              getFromId(gd, trace.yaxis)
            ));
          }
        }
        return searchTraces;
      }
      function createSearchInfo(module2, calcData, xaxis, yaxis) {
        return {
          _module: module2,
          cd: calcData,
          xaxis,
          yaxis
        };
      }
      function isHoverDataSet(hoverData) {
        return hoverData && Array.isArray(hoverData) && hoverData[0].hoverOnBox !== true;
      }
      function extractClickedPtInfo(hoverData, searchTraces) {
        var hoverDatum = hoverData[0];
        var pointNumber = -1;
        var pointNumbers = [];
        var searchInfo, i;
        for (i = 0; i < searchTraces.length; i++) {
          searchInfo = searchTraces[i];
          if (hoverDatum.fullData.index === searchInfo.cd[0].trace.index) {
            if (hoverDatum.hoverOnBox === true) {
              break;
            }
            if (hoverDatum.pointNumber !== void 0) {
              pointNumber = hoverDatum.pointNumber;
            } else if (hoverDatum.binNumber !== void 0) {
              pointNumber = hoverDatum.binNumber;
              pointNumbers = hoverDatum.pointNumbers;
            }
            break;
          }
        }
        return {
          pointNumber,
          pointNumbers,
          searchInfo
        };
      }
      function isPointOrBinSelected(clickedPtInfo) {
        var trace = clickedPtInfo.searchInfo.cd[0].trace;
        var ptNum = clickedPtInfo.pointNumber;
        var ptNums = clickedPtInfo.pointNumbers;
        var ptNumsSet = ptNums.length > 0;
        var ptNumToTest = ptNumsSet ? ptNums[0] : ptNum;
        return trace.selectedpoints ? trace.selectedpoints.indexOf(ptNumToTest) > -1 : false;
      }
      function isOnlyThisBinSelected(searchTraces, clickedPtInfo) {
        var tracesWithSelectedPts = [];
        var searchInfo, trace, isSameTrace, i;
        for (i = 0; i < searchTraces.length; i++) {
          searchInfo = searchTraces[i];
          if (searchInfo.cd[0].trace.selectedpoints && searchInfo.cd[0].trace.selectedpoints.length > 0) {
            tracesWithSelectedPts.push(searchInfo);
          }
        }
        if (tracesWithSelectedPts.length === 1) {
          isSameTrace = tracesWithSelectedPts[0] === clickedPtInfo.searchInfo;
          if (isSameTrace) {
            trace = clickedPtInfo.searchInfo.cd[0].trace;
            if (trace.selectedpoints.length === clickedPtInfo.pointNumbers.length) {
              for (i = 0; i < clickedPtInfo.pointNumbers.length; i++) {
                if (trace.selectedpoints.indexOf(clickedPtInfo.pointNumbers[i]) < 0) {
                  return false;
                }
              }
              return true;
            }
          }
        }
        return false;
      }
      function isOnlyOnePointSelected(searchTraces) {
        var len = 0;
        var searchInfo, trace, i;
        for (i = 0; i < searchTraces.length; i++) {
          searchInfo = searchTraces[i];
          trace = searchInfo.cd[0].trace;
          if (trace.selectedpoints) {
            if (trace.selectedpoints.length > 1) return false;
            len += trace.selectedpoints.length;
            if (len > 1) return false;
          }
        }
        return len === 1;
      }
      function updateSelectedState(gd, searchTraces, eventData) {
        var i;
        for (i = 0; i < searchTraces.length; i++) {
          var fullInputTrace = searchTraces[i].cd[0].trace._fullInput;
          var tracePreGUI = gd._fullLayout._tracePreGUI[fullInputTrace.uid] || {};
          if (tracePreGUI.selectedpoints === void 0) {
            tracePreGUI.selectedpoints = fullInputTrace._input.selectedpoints || null;
          }
        }
        var trace;
        if (eventData) {
          var pts = eventData.points || [];
          for (i = 0; i < searchTraces.length; i++) {
            trace = searchTraces[i].cd[0].trace;
            trace._input.selectedpoints = trace._fullInput.selectedpoints = [];
            if (trace._fullInput !== trace) trace.selectedpoints = [];
          }
          for (var k = 0; k < pts.length; k++) {
            var pt = pts[k];
            var data = pt.data;
            var fullData = pt.fullData;
            var pointIndex = pt.pointIndex;
            var pointIndices = pt.pointIndices;
            if (pointIndices) {
              [].push.apply(data.selectedpoints, pointIndices);
              if (trace._fullInput !== trace) {
                [].push.apply(fullData.selectedpoints, pointIndices);
              }
            } else {
              data.selectedpoints.push(pointIndex);
              if (trace._fullInput !== trace) {
                fullData.selectedpoints.push(pointIndex);
              }
            }
          }
        } else {
          for (i = 0; i < searchTraces.length; i++) {
            trace = searchTraces[i].cd[0].trace;
            delete trace.selectedpoints;
            delete trace._input.selectedpoints;
            if (trace._fullInput !== trace) {
              delete trace._fullInput.selectedpoints;
            }
          }
        }
        updateReglSelectedState(gd, searchTraces);
      }
      function updateReglSelectedState(gd, searchTraces) {
        var hasRegl = false;
        for (var i = 0; i < searchTraces.length; i++) {
          var searchInfo = searchTraces[i];
          var cd = searchInfo.cd;
          if (Registry.traceIs(cd[0].trace, "regl")) {
            hasRegl = true;
          }
          var _module = searchInfo._module;
          var fn = _module.styleOnSelect || _module.style;
          if (fn) {
            fn(gd, cd, cd[0].node3);
            if (cd[0].nodeRangePlot3) fn(gd, cd, cd[0].nodeRangePlot3);
          }
        }
        if (hasRegl) {
          clearGlCanvases(gd);
          redrawReglTraces(gd);
        }
      }
      function mergePolygons(list, poly, subtract) {
        var fn = subtract ? polybool.difference : polybool.union;
        var res = fn({
          regions: list
        }, {
          regions: [poly]
        });
        var allPolygons = res.regions.reverse();
        for (var i = 0; i < allPolygons.length; i++) {
          var polygon = allPolygons[i];
          polygon.subtract = getSubtract(polygon, allPolygons.slice(0, i));
        }
        return allPolygons;
      }
      function fillSelectionItem(selection, searchInfo) {
        if (Array.isArray(selection)) {
          var cd = searchInfo.cd;
          var trace = searchInfo.cd[0].trace;
          for (var i = 0; i < selection.length; i++) {
            selection[i] = makeEventData(selection[i], trace, cd);
          }
        }
        return selection;
      }
      function convertPoly(polygonsIn, isOpenMode) {
        var polygonsOut = [];
        for (var i = 0; i < polygonsIn.length; i++) {
          polygonsOut[i] = [];
          for (var j = 0; j < polygonsIn[i].length; j++) {
            polygonsOut[i][j] = [];
            polygonsOut[i][j][0] = j ? "L" : "M";
            for (var k = 0; k < polygonsIn[i][j].length; k++) {
              polygonsOut[i][j].push(
                polygonsIn[i][j][k]
              );
            }
          }
          if (!isOpenMode) {
            polygonsOut[i].push([
              "Z",
              polygonsOut[i][0][1],
              // initial x
              polygonsOut[i][0][2]
              // initial y
            ]);
          }
        }
        return polygonsOut;
      }
      function _doSelect(selectionTesters, searchTraces) {
        var allSelections = [];
        var thisSelection;
        var traceSelections = [];
        var traceSelection;
        for (var i = 0; i < searchTraces.length; i++) {
          var searchInfo = searchTraces[i];
          traceSelection = searchInfo._module.selectPoints(searchInfo, selectionTesters);
          traceSelections.push(traceSelection);
          thisSelection = fillSelectionItem(traceSelection, searchInfo);
          allSelections = allSelections.concat(thisSelection);
        }
        return allSelections;
      }
      function reselect(gd, mayEmitSelected, selectionTesters, searchTraces, dragOptions) {
        var hadSearchTraces = !!searchTraces;
        var plotinfo, xRef, yRef;
        if (dragOptions) {
          plotinfo = dragOptions.plotinfo;
          xRef = dragOptions.xaxes[0]._id;
          yRef = dragOptions.yaxes[0]._id;
        }
        var allSelections = [];
        var allSearchTraces = [];
        var layoutPolygons = getLayoutPolygons(gd);
        var fullLayout = gd._fullLayout;
        if (plotinfo) {
          var zoomLayer = fullLayout._zoomlayer;
          var mode = fullLayout.dragmode;
          var isDrawMode = drawMode(mode);
          var isSelectMode = selectMode(mode);
          if (isDrawMode || isSelectMode) {
            var xaxis = getFromId(gd, xRef, "x");
            var yaxis = getFromId(gd, yRef, "y");
            if (xaxis && yaxis) {
              var outlines = zoomLayer.selectAll(".select-outline-" + plotinfo.id);
              if (outlines && gd._fullLayout._outlining) {
                if (outlines.length) {
                  var e = outlines[0][0];
                  var d = e.getAttribute("d");
                  var outlinePolys = readPaths(d, gd, plotinfo);
                  var draftPolygons = [];
                  for (var u = 0; u < outlinePolys.length; u++) {
                    var p = outlinePolys[u];
                    var polygon = [];
                    for (var t = 0; t < p.length; t++) {
                      polygon.push([
                        convert(xaxis, p[t][1]),
                        convert(yaxis, p[t][2])
                      ]);
                    }
                    polygon.xref = xRef;
                    polygon.yref = yRef;
                    polygon.subtract = getSubtract(polygon, draftPolygons);
                    draftPolygons.push(polygon);
                  }
                  layoutPolygons = layoutPolygons.concat(draftPolygons);
                }
              }
            }
          }
        }
        var subplots = xRef && yRef ? [xRef + yRef] : fullLayout._subplots.cartesian;
        epmtySplomSelectionBatch(gd);
        var seenSplom = {};
        for (var i = 0; i < subplots.length; i++) {
          var subplot = subplots[i];
          var yAt = subplot.indexOf("y");
          var _xRef = subplot.slice(0, yAt);
          var _yRef = subplot.slice(yAt);
          var _selectionTesters = xRef && yRef ? selectionTesters : void 0;
          _selectionTesters = addTester(layoutPolygons, _xRef, _yRef, _selectionTesters);
          if (_selectionTesters) {
            var _searchTraces = searchTraces;
            if (!hadSearchTraces) {
              var _xA = getFromId(gd, _xRef, "x");
              var _yA = getFromId(gd, _yRef, "y");
              _searchTraces = determineSearchTraces(
                gd,
                [_xA],
                [_yA],
                subplot
              );
              for (var w = 0; w < _searchTraces.length; w++) {
                var s = _searchTraces[w];
                var cd0 = s.cd[0];
                var trace = cd0.trace;
                if (s._module.name === "scattergl" && !cd0.t.xpx) {
                  var x = trace.x;
                  var y = trace.y;
                  var len = trace._length;
                  cd0.t.xpx = [];
                  cd0.t.ypx = [];
                  for (var j = 0; j < len; j++) {
                    cd0.t.xpx[j] = _xA.c2p(x[j]);
                    cd0.t.ypx[j] = _yA.c2p(y[j]);
                  }
                }
                if (s._module.name === "splom") {
                  if (!seenSplom[trace.uid]) {
                    seenSplom[trace.uid] = true;
                  }
                }
              }
            }
            var selection = _doSelect(_selectionTesters, _searchTraces);
            allSelections = allSelections.concat(selection);
            allSearchTraces = allSearchTraces.concat(_searchTraces);
          }
        }
        var eventData = { points: allSelections };
        updateSelectedState(gd, allSearchTraces, eventData);
        var clickmode = fullLayout.clickmode;
        var sendEvents = clickmode.indexOf("event") > -1 && mayEmitSelected;
        if (!plotinfo && // get called from plot_api & plots
        mayEmitSelected) {
          var activePolygons = getLayoutPolygons(gd, true);
          if (activePolygons.length) {
            var xref = activePolygons[0].xref;
            var yref = activePolygons[0].yref;
            if (xref && yref) {
              var poly = castMultiPolygon(activePolygons);
              var fillRangeItems = makeFillRangeItems([
                getFromId(gd, xref, "x"),
                getFromId(gd, yref, "y")
              ]);
              fillRangeItems(eventData, poly);
            }
          }
          if (gd._fullLayout._noEmitSelectedAtStart) {
            gd._fullLayout._noEmitSelectedAtStart = false;
          } else {
            if (sendEvents) emitSelected(gd, eventData);
          }
          fullLayout._reselect = false;
        }
        if (!plotinfo && // get called from plot_api & plots
        fullLayout._deselect) {
          var deselect = fullLayout._deselect;
          xRef = deselect.xref;
          yRef = deselect.yref;
          if (!subplotSelected(xRef, yRef, allSearchTraces)) {
            deselectSubplot(gd, xRef, yRef, searchTraces);
          }
          if (sendEvents) {
            if (eventData.points.length) {
              emitSelected(gd, eventData);
            } else {
              emitDeselect(gd);
            }
          }
          fullLayout._deselect = false;
        }
        return {
          eventData,
          selectionTesters
        };
      }
      function epmtySplomSelectionBatch(gd) {
        var cd = gd.calcdata;
        if (!cd) return;
        for (var i = 0; i < cd.length; i++) {
          var cd0 = cd[i][0];
          var trace = cd0.trace;
          var splomScenes = gd._fullLayout._splomScenes;
          if (splomScenes) {
            var scene = splomScenes[trace.uid];
            if (scene) {
              scene.selectBatch = [];
            }
          }
        }
      }
      function subplotSelected(xRef, yRef, searchTraces) {
        for (var i = 0; i < searchTraces.length; i++) {
          var s = searchTraces[i];
          if (s.xaxis && s.xaxis._id === xRef && (s.yaxis && s.yaxis._id === yRef)) {
            return true;
          }
        }
        return false;
      }
      function deselectSubplot(gd, xRef, yRef, searchTraces) {
        searchTraces = determineSearchTraces(
          gd,
          [getFromId(gd, xRef, "x")],
          [getFromId(gd, yRef, "y")],
          xRef + yRef
        );
        for (var k = 0; k < searchTraces.length; k++) {
          var searchInfo = searchTraces[k];
          searchInfo._module.selectPoints(searchInfo, false);
        }
        updateSelectedState(gd, searchTraces);
      }
      function addTester(layoutPolygons, xRef, yRef, selectionTesters) {
        var mergedPolygons;
        for (var i = 0; i < layoutPolygons.length; i++) {
          var currentPolygon = layoutPolygons[i];
          if (xRef !== currentPolygon.xref || yRef !== currentPolygon.yref) continue;
          if (mergedPolygons) {
            var subtract = !!currentPolygon.subtract;
            mergedPolygons = mergePolygons(mergedPolygons, currentPolygon, subtract);
            selectionTesters = multiTester(mergedPolygons);
          } else {
            mergedPolygons = [currentPolygon];
            selectionTesters = polygonTester(currentPolygon);
          }
        }
        return selectionTesters;
      }
      function getLayoutPolygons(gd, onlyActiveOnes) {
        var allPolygons = [];
        var fullLayout = gd._fullLayout;
        var allSelections = fullLayout.selections;
        var len = allSelections.length;
        for (var i = 0; i < len; i++) {
          if (onlyActiveOnes && i !== fullLayout._activeSelectionIndex) continue;
          var selection = allSelections[i];
          if (!selection) continue;
          var xref = selection.xref;
          var yref = selection.yref;
          var xaxis = getFromId(gd, xref, "x");
          var yaxis = getFromId(gd, yref, "y");
          var xmin, xmax, ymin, ymax;
          var polygon;
          if (selection.type === "rect") {
            polygon = [];
            var x0 = convert(xaxis, selection.x0);
            var x1 = convert(xaxis, selection.x1);
            var y0 = convert(yaxis, selection.y0);
            var y1 = convert(yaxis, selection.y1);
            polygon = [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];
            xmin = Math.min(x0, x1);
            xmax = Math.max(x0, x1);
            ymin = Math.min(y0, y1);
            ymax = Math.max(y0, y1);
            polygon.xmin = xmin;
            polygon.xmax = xmax;
            polygon.ymin = ymin;
            polygon.ymax = ymax;
            polygon.xref = xref;
            polygon.yref = yref;
            polygon.subtract = false;
            polygon.isRect = true;
            allPolygons.push(polygon);
          } else if (selection.type === "path") {
            var segments = selection.path.split("Z");
            var multiPolygons = [];
            for (var j = 0; j < segments.length; j++) {
              var path = segments[j];
              if (!path) continue;
              path += "Z";
              var allX = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsX, "raw");
              var allY = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsY, "raw");
              xmin = Infinity;
              xmax = -Infinity;
              ymin = Infinity;
              ymax = -Infinity;
              polygon = [];
              for (var k = 0; k < allX.length; k++) {
                var x = convert(xaxis, allX[k]);
                var y = convert(yaxis, allY[k]);
                polygon.push([x, y]);
                xmin = Math.min(x, xmin);
                xmax = Math.max(x, xmax);
                ymin = Math.min(y, ymin);
                ymax = Math.max(y, ymax);
              }
              polygon.xmin = xmin;
              polygon.xmax = xmax;
              polygon.ymin = ymin;
              polygon.ymax = ymax;
              polygon.xref = xref;
              polygon.yref = yref;
              polygon.subtract = getSubtract(polygon, multiPolygons);
              multiPolygons.push(polygon);
              allPolygons.push(polygon);
            }
          }
        }
        return allPolygons;
      }
      function getSubtract(polygon, previousPolygons) {
        var subtract = false;
        for (var i = 0; i < previousPolygons.length; i++) {
          var previousPolygon = previousPolygons[i];
          for (var k = 0; k < polygon.length; k++) {
            if (pointInPolygon(polygon[k], previousPolygon)) {
              subtract = !subtract;
              break;
            }
          }
        }
        return subtract;
      }
      function convert(ax, d) {
        if (ax.type === "date") d = d.replace("_", " ");
        return ax.type === "log" ? ax.c2p(d) : ax.r2p(d, null, ax.calendar);
      }
      function castMultiPolygon(allPolygons) {
        var len = allPolygons.length;
        var p = [];
        for (var i = 0; i < len; i++) {
          var polygon = allPolygons[i];
          p = p.concat(polygon);
          p = p.concat([polygon[0]]);
        }
        return computeRectAndRanges(p);
      }
      function computeRectAndRanges(poly) {
        poly.isRect = poly.length === 5 && poly[0][0] === poly[4][0] && poly[0][1] === poly[4][1] && (poly[0][0] === poly[1][0] && poly[2][0] === poly[3][0] && poly[0][1] === poly[3][1] && poly[1][1] === poly[2][1]) || poly[0][1] === poly[1][1] && poly[2][1] === poly[3][1] && poly[0][0] === poly[3][0] && poly[1][0] === poly[2][0];
        if (poly.isRect) {
          poly.xmin = Math.min(poly[0][0], poly[2][0]);
          poly.xmax = Math.max(poly[0][0], poly[2][0]);
          poly.ymin = Math.min(poly[0][1], poly[2][1]);
          poly.ymax = Math.max(poly[0][1], poly[2][1]);
        }
        return poly;
      }
      function makeFillRangeItems(allAxes) {
        return function(eventData, poly) {
          var range;
          var lassoPoints;
          for (var i = 0; i < allAxes.length; i++) {
            var ax = allAxes[i];
            var id = ax._id;
            var axLetter = id.charAt(0);
            if (poly.isRect) {
              if (!range) range = {};
              var min = poly[axLetter + "min"];
              var max = poly[axLetter + "max"];
              if (min !== void 0 && max !== void 0) {
                range[id] = [
                  p2r(ax, min),
                  p2r(ax, max)
                ].sort(ascending);
              }
            } else {
              if (!lassoPoints) lassoPoints = {};
              lassoPoints[id] = poly.map(axValue(ax));
            }
          }
          if (range) {
            eventData.range = range;
          }
          if (lassoPoints) {
            eventData.lassoPoints = lassoPoints;
          }
        };
      }
      function getFillRangeItems(dragOptions) {
        var plotinfo = dragOptions.plotinfo;
        return plotinfo.fillRangeItems || // allow subplots (i.e. geo, mapbox, map, sankey) to override fillRangeItems routine
        makeFillRangeItems(dragOptions.xaxes.concat(dragOptions.yaxes));
      }
      function emitSelecting(gd, eventData) {
        gd.emit("plotly_selecting", eventData);
      }
      function emitSelected(gd, eventData) {
        if (eventData) {
          eventData.selections = (gd.layout || {}).selections || [];
        }
        gd.emit("plotly_selected", eventData);
      }
      function emitDeselect(gd) {
        gd.emit("plotly_deselect", null);
      }
      module.exports = {
        reselect,
        prepSelect,
        clearOutline,
        clearSelectionsCache,
        selectOnClick
      };
    }
  });

  // src/components/annotations/arrow_paths.js
  var require_arrow_paths = __commonJS({
    "src/components/annotations/arrow_paths.js"(exports, module) {
      "use strict";
      module.exports = [
        // no arrow
        {
          path: "",
          backoff: 0
        },
        // wide with flat back
        {
          path: "M-2.4,-3V3L0.6,0Z",
          backoff: 0.6
        },
        // narrower with flat back
        {
          path: "M-3.7,-2.5V2.5L1.3,0Z",
          backoff: 1.3
        },
        // barbed
        {
          path: "M-4.45,-3L-1.65,-0.2V0.2L-4.45,3L1.55,0Z",
          backoff: 1.55
        },
        // wide line-drawn
        {
          path: "M-2.2,-2.2L-0.2,-0.2V0.2L-2.2,2.2L-1.4,3L1.6,0L-1.4,-3Z",
          backoff: 1.6
        },
        // narrower line-drawn
        {
          path: "M-4.4,-2.1L-0.6,-0.2V0.2L-4.4,2.1L-4,3L2,0L-4,-3Z",
          backoff: 2
        },
        // circle
        {
          path: "M2,0A2,2 0 1,1 0,-2A2,2 0 0,1 2,0Z",
          backoff: 0,
          noRotate: true
        },
        // square
        {
          path: "M2,2V-2H-2V2Z",
          backoff: 0,
          noRotate: true
        }
      ];
    }
  });

  // src/constants/axis_placeable_objects.js
  var require_axis_placeable_objects = __commonJS({
    "src/constants/axis_placeable_objects.js"(exports, module) {
      "use strict";
      module.exports = {
        axisRefDescription: function(axisname, lower, upper) {
          return [
            "If set to a",
            axisname,
            "axis id (e.g. *" + axisname + "* or",
            "*" + axisname + "2*), the `" + axisname + "` position refers to a",
            axisname,
            "coordinate. If set to *paper*, the `" + axisname + "`",
            "position refers to the distance from the",
            lower,
            "of the plotting",
            "area in normalized coordinates where *0* (*1*) corresponds to the",
            lower,
            "(" + upper + "). If set to a",
            axisname,
            "axis ID followed by",
            "*domain* (separated by a space), the position behaves like for",
            "*paper*, but refers to the distance in fractions of the domain",
            "length from the",
            lower,
            "of the domain of that axis: e.g.,",
            "*" + axisname + "2 domain* refers to the domain of the second",
            axisname,
            " axis and a",
            axisname,
            "position of 0.5 refers to the",
            "point between the",
            lower,
            "and the",
            upper,
            "of the domain of the",
            "second",
            axisname,
            "axis."
          ].join(" ");
        }
      };
    }
  });

  // src/components/annotations/attributes.js
  var require_attributes11 = __commonJS({
    "src/components/annotations/attributes.js"(exports, module) {
      "use strict";
      var ARROWPATHS = require_arrow_paths();
      var fontAttrs = require_font_attributes();
      var cartesianConstants = require_constants2();
      var templatedArray = require_plot_template().templatedArray;
      var axisPlaceableObjs = require_axis_placeable_objects();
      module.exports = templatedArray("annotation", {
        visible: {
          valType: "boolean",
          dflt: true,
          editType: "calc+arraydraw"
        },
        text: {
          valType: "string",
          editType: "calc+arraydraw"
        },
        textangle: {
          valType: "angle",
          dflt: 0,
          editType: "calc+arraydraw"
        },
        font: fontAttrs({
          editType: "calc+arraydraw",
          colorEditType: "arraydraw"
        }),
        width: {
          valType: "number",
          min: 1,
          dflt: null,
          editType: "calc+arraydraw"
        },
        height: {
          valType: "number",
          min: 1,
          dflt: null,
          editType: "calc+arraydraw"
        },
        opacity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 1,
          editType: "arraydraw"
        },
        align: {
          valType: "enumerated",
          values: ["left", "center", "right"],
          dflt: "center",
          editType: "arraydraw"
        },
        valign: {
          valType: "enumerated",
          values: ["top", "middle", "bottom"],
          dflt: "middle",
          editType: "arraydraw"
        },
        bgcolor: {
          valType: "color",
          dflt: "rgba(0,0,0,0)",
          editType: "arraydraw"
        },
        bordercolor: {
          valType: "color",
          dflt: "rgba(0,0,0,0)",
          editType: "arraydraw"
        },
        borderpad: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "calc+arraydraw"
        },
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "calc+arraydraw"
        },
        // arrow
        showarrow: {
          valType: "boolean",
          dflt: true,
          editType: "calc+arraydraw"
        },
        arrowcolor: {
          valType: "color",
          editType: "arraydraw"
        },
        arrowhead: {
          valType: "integer",
          min: 0,
          max: ARROWPATHS.length,
          dflt: 1,
          editType: "arraydraw"
        },
        startarrowhead: {
          valType: "integer",
          min: 0,
          max: ARROWPATHS.length,
          dflt: 1,
          editType: "arraydraw"
        },
        arrowside: {
          valType: "flaglist",
          flags: ["end", "start"],
          extras: ["none"],
          dflt: "end",
          editType: "arraydraw"
        },
        arrowsize: {
          valType: "number",
          min: 0.3,
          dflt: 1,
          editType: "calc+arraydraw"
        },
        startarrowsize: {
          valType: "number",
          min: 0.3,
          dflt: 1,
          editType: "calc+arraydraw"
        },
        arrowwidth: {
          valType: "number",
          min: 0.1,
          editType: "calc+arraydraw"
        },
        standoff: {
          valType: "number",
          min: 0,
          dflt: 0,
          editType: "calc+arraydraw"
        },
        startstandoff: {
          valType: "number",
          min: 0,
          dflt: 0,
          editType: "calc+arraydraw"
        },
        ax: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        ay: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        axref: {
          valType: "enumerated",
          dflt: "pixel",
          values: [
            "pixel",
            cartesianConstants.idRegex.x.toString()
          ],
          editType: "calc"
        },
        ayref: {
          valType: "enumerated",
          dflt: "pixel",
          values: [
            "pixel",
            cartesianConstants.idRegex.y.toString()
          ],
          editType: "calc"
        },
        // positioning
        xref: {
          valType: "enumerated",
          values: [
            "paper",
            cartesianConstants.idRegex.x.toString()
          ],
          editType: "calc"
        },
        x: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        xanchor: {
          valType: "enumerated",
          values: ["auto", "left", "center", "right"],
          dflt: "auto",
          editType: "calc+arraydraw"
        },
        xshift: {
          valType: "number",
          dflt: 0,
          editType: "calc+arraydraw"
        },
        yref: {
          valType: "enumerated",
          values: [
            "paper",
            cartesianConstants.idRegex.y.toString()
          ],
          editType: "calc"
        },
        y: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        yanchor: {
          valType: "enumerated",
          values: ["auto", "top", "middle", "bottom"],
          dflt: "auto",
          editType: "calc+arraydraw"
        },
        yshift: {
          valType: "number",
          dflt: 0,
          editType: "calc+arraydraw"
        },
        clicktoshow: {
          valType: "enumerated",
          values: [false, "onoff", "onout"],
          dflt: false,
          editType: "arraydraw"
        },
        xclick: {
          valType: "any",
          editType: "arraydraw"
        },
        yclick: {
          valType: "any",
          editType: "arraydraw"
        },
        hovertext: {
          valType: "string",
          editType: "arraydraw"
        },
        hoverlabel: {
          bgcolor: {
            valType: "color",
            editType: "arraydraw"
          },
          bordercolor: {
            valType: "color",
            editType: "arraydraw"
          },
          font: fontAttrs({
            editType: "arraydraw"
          }),
          editType: "arraydraw"
        },
        captureevents: {
          valType: "boolean",
          editType: "arraydraw"
        },
        editType: "calc"
      });
    }
  });

  // src/traces/scatter/constants.js
  var require_constants8 = __commonJS({
    "src/traces/scatter/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        PTS_LINESONLY: 20,
        // fixed parameters of clustering and clipping algorithms
        // fraction of clustering tolerance "so close we don't even consider it a new point"
        minTolerance: 0.2,
        // how fast does clustering tolerance increase as you get away from the visible region
        toleranceGrowth: 10,
        // number of viewport sizes away from the visible region
        // at which we clip all lines to the perimeter
        maxScreensAway: 20,
        eventDataKeys: []
      };
    }
  });

  // src/traces/scatter/fillcolor_attribute.js
  var require_fillcolor_attribute = __commonJS({
    "src/traces/scatter/fillcolor_attribute.js"(exports, module) {
      "use strict";
      module.exports = function makeFillcolorAttr(hasFillgradient) {
        return {
          valType: "color",
          editType: "style",
          anim: true
        };
      };
    }
  });

  // src/traces/scatter/attributes.js
  var require_attributes12 = __commonJS({
    "src/traces/scatter/attributes.js"(exports, module) {
      "use strict";
      var axisHoverFormat = require_axis_format_attributes().axisHoverFormat;
      var texttemplateAttrs = require_template_attributes().texttemplateAttrs;
      var hovertemplateAttrs = require_template_attributes().hovertemplateAttrs;
      var colorScaleAttrs = require_attributes8();
      var fontAttrs = require_font_attributes();
      var dash = require_attributes4().dash;
      var pattern = require_attributes4().pattern;
      var Drawing = require_drawing();
      var constants = require_constants8();
      var extendFlat = require_extend().extendFlat;
      var makeFillcolorAttr = require_fillcolor_attribute();
      function axisPeriod(axis) {
        return {
          valType: "any",
          dflt: 0,
          editType: "calc"
        };
      }
      function axisPeriod0(axis) {
        return {
          valType: "any",
          editType: "calc"
        };
      }
      function axisPeriodAlignment(axis) {
        return {
          valType: "enumerated",
          values: [
            "start",
            "middle",
            "end"
          ],
          dflt: "middle",
          editType: "calc"
        };
      }
      module.exports = {
        x: {
          valType: "data_array",
          editType: "calc+clearAxisTypes",
          anim: true
        },
        x0: {
          valType: "any",
          dflt: 0,
          editType: "calc+clearAxisTypes",
          anim: true
        },
        dx: {
          valType: "number",
          dflt: 1,
          editType: "calc",
          anim: true
        },
        y: {
          valType: "data_array",
          editType: "calc+clearAxisTypes",
          anim: true
        },
        y0: {
          valType: "any",
          dflt: 0,
          editType: "calc+clearAxisTypes",
          anim: true
        },
        dy: {
          valType: "number",
          dflt: 1,
          editType: "calc",
          anim: true
        },
        xperiod: axisPeriod("x"),
        yperiod: axisPeriod("y"),
        xperiod0: axisPeriod0("x0"),
        yperiod0: axisPeriod0("y0"),
        xperiodalignment: axisPeriodAlignment("x"),
        yperiodalignment: axisPeriodAlignment("y"),
        xhoverformat: axisHoverFormat("x"),
        yhoverformat: axisHoverFormat("y"),
        offsetgroup: {
          valType: "string",
          dflt: "",
          editType: "calc"
        },
        alignmentgroup: {
          valType: "string",
          dflt: "",
          editType: "calc"
        },
        stackgroup: {
          valType: "string",
          dflt: "",
          editType: "calc"
        },
        orientation: {
          valType: "enumerated",
          values: ["v", "h"],
          editType: "calc"
        },
        groupnorm: {
          valType: "enumerated",
          values: ["", "fraction", "percent"],
          dflt: "",
          editType: "calc"
        },
        stackgaps: {
          valType: "enumerated",
          values: ["infer zero", "interpolate"],
          dflt: "infer zero",
          editType: "calc"
        },
        text: {
          valType: "string",
          dflt: "",
          arrayOk: true,
          editType: "calc"
        },
        texttemplate: texttemplateAttrs({}, {}),
        hovertext: {
          valType: "string",
          dflt: "",
          arrayOk: true,
          editType: "style"
        },
        mode: {
          valType: "flaglist",
          flags: ["lines", "markers", "text"],
          extras: ["none"],
          editType: "calc"
        },
        hoveron: {
          valType: "flaglist",
          flags: ["points", "fills"],
          editType: "style"
        },
        hovertemplate: hovertemplateAttrs({}, {
          keys: constants.eventDataKeys
        }),
        line: {
          color: {
            valType: "color",
            editType: "style",
            anim: true
          },
          width: {
            valType: "number",
            min: 0,
            dflt: 2,
            editType: "style",
            anim: true
          },
          shape: {
            valType: "enumerated",
            values: ["linear", "spline", "hv", "vh", "hvh", "vhv"],
            dflt: "linear",
            editType: "plot"
          },
          smoothing: {
            valType: "number",
            min: 0,
            max: 1.3,
            dflt: 1,
            editType: "plot"
          },
          dash: extendFlat({}, dash, { editType: "style" }),
          backoff: {
            // we want to have a similar option for the start of the line
            valType: "number",
            min: 0,
            dflt: "auto",
            arrayOk: true,
            editType: "plot"
          },
          simplify: {
            valType: "boolean",
            dflt: true,
            editType: "plot"
          },
          editType: "plot"
        },
        connectgaps: {
          valType: "boolean",
          dflt: false,
          editType: "calc"
        },
        cliponaxis: {
          valType: "boolean",
          dflt: true,
          editType: "plot"
        },
        fill: {
          valType: "enumerated",
          values: ["none", "tozeroy", "tozerox", "tonexty", "tonextx", "toself", "tonext"],
          editType: "calc"
        },
        fillcolor: makeFillcolorAttr(true),
        fillgradient: extendFlat({
          type: {
            valType: "enumerated",
            values: ["radial", "horizontal", "vertical", "none"],
            dflt: "none",
            editType: "calc"
          },
          start: {
            valType: "number",
            editType: "calc"
          },
          stop: {
            valType: "number",
            editType: "calc"
          },
          colorscale: {
            valType: "colorscale",
            editType: "style"
          },
          editType: "calc"
        }),
        fillpattern: pattern,
        marker: extendFlat(
          {
            symbol: {
              valType: "enumerated",
              values: Drawing.symbolList,
              dflt: "circle",
              arrayOk: true,
              editType: "style"
            },
            opacity: {
              valType: "number",
              min: 0,
              max: 1,
              arrayOk: true,
              editType: "style",
              anim: true
            },
            angle: {
              valType: "angle",
              dflt: 0,
              arrayOk: true,
              editType: "plot",
              anim: false
              // TODO: possibly set to true in future
            },
            angleref: {
              valType: "enumerated",
              values: ["previous", "up"],
              dflt: "up",
              editType: "plot",
              anim: false
            },
            standoff: {
              valType: "number",
              min: 0,
              dflt: 0,
              arrayOk: true,
              editType: "plot",
              anim: true
            },
            size: {
              valType: "number",
              min: 0,
              dflt: 6,
              arrayOk: true,
              editType: "calc",
              anim: true
            },
            maxdisplayed: {
              valType: "number",
              min: 0,
              dflt: 0,
              editType: "plot"
            },
            sizeref: {
              valType: "number",
              dflt: 1,
              editType: "calc"
            },
            sizemin: {
              valType: "number",
              min: 0,
              dflt: 0,
              editType: "calc"
            },
            sizemode: {
              valType: "enumerated",
              values: ["diameter", "area"],
              dflt: "diameter",
              editType: "calc"
            },
            line: extendFlat(
              {
                width: {
                  valType: "number",
                  min: 0,
                  arrayOk: true,
                  editType: "style",
                  anim: true
                },
                editType: "calc"
              },
              colorScaleAttrs("marker.line", { anim: true })
            ),
            gradient: {
              type: {
                valType: "enumerated",
                values: ["radial", "horizontal", "vertical", "none"],
                arrayOk: true,
                dflt: "none",
                editType: "calc"
              },
              color: {
                valType: "color",
                arrayOk: true,
                editType: "calc"
              },
              editType: "calc"
            },
            editType: "calc"
          },
          colorScaleAttrs("marker", { anim: true })
        ),
        selected: {
          marker: {
            opacity: {
              valType: "number",
              min: 0,
              max: 1,
              editType: "style"
            },
            color: {
              valType: "color",
              editType: "style"
            },
            size: {
              valType: "number",
              min: 0,
              editType: "style"
            },
            editType: "style"
          },
          textfont: {
            color: {
              valType: "color",
              editType: "style"
            },
            editType: "style"
          },
          editType: "style"
        },
        unselected: {
          marker: {
            opacity: {
              valType: "number",
              min: 0,
              max: 1,
              editType: "style"
            },
            color: {
              valType: "color",
              editType: "style"
            },
            size: {
              valType: "number",
              min: 0,
              editType: "style"
            },
            editType: "style"
          },
          textfont: {
            color: {
              valType: "color",
              editType: "style"
            },
            editType: "style"
          },
          editType: "style"
        },
        textposition: {
          valType: "enumerated",
          values: [
            "top left",
            "top center",
            "top right",
            "middle left",
            "middle center",
            "middle right",
            "bottom left",
            "bottom center",
            "bottom right"
          ],
          dflt: "middle center",
          arrayOk: true,
          editType: "calc"
        },
        textfont: fontAttrs({
          editType: "calc",
          colorEditType: "style",
          arrayOk: true
        }),
        zorder: {
          valType: "integer",
          dflt: 0,
          editType: "plot"
        }
      };
    }
  });

  // src/components/selections/attributes.js
  var require_attributes13 = __commonJS({
    "src/components/selections/attributes.js"(exports, module) {
      "use strict";
      var annAttrs = require_attributes11();
      var scatterLineAttrs = require_attributes12().line;
      var dash = require_attributes4().dash;
      var extendFlat = require_extend().extendFlat;
      var overrideAll = require_edit_types().overrideAll;
      var templatedArray = require_plot_template().templatedArray;
      var axisPlaceableObjs = require_axis_placeable_objects();
      module.exports = overrideAll(templatedArray("selection", {
        type: {
          valType: "enumerated",
          values: ["rect", "path"]
        },
        xref: extendFlat({}, annAttrs.xref, {}),
        yref: extendFlat({}, annAttrs.yref, {}),
        x0: {
          valType: "any"
        },
        x1: {
          valType: "any"
        },
        y0: {
          valType: "any"
        },
        y1: {
          valType: "any"
        },
        path: {
          valType: "string",
          editType: "arraydraw"
        },
        opacity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 0.7,
          editType: "arraydraw"
        },
        line: {
          color: scatterLineAttrs.color,
          width: extendFlat({}, scatterLineAttrs.width, {
            min: 1,
            dflt: 1
          }),
          dash: extendFlat({}, dash, {
            dflt: "dot"
          })
        }
      }), "arraydraw", "from-root");
    }
  });

  // src/components/selections/defaults.js
  var require_defaults6 = __commonJS({
    "src/components/selections/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes13();
      var helpers = require_helpers8();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        handleArrayContainerDefaults(layoutIn, layoutOut, {
          name: "selections",
          handleItemDefaults: handleSelectionDefaults
        });
        var selections = layoutOut.selections;
        for (var i = 0; i < selections.length; i++) {
          var selection = selections[i];
          if (!selection) continue;
          if (selection.path === void 0) {
            if (selection.x0 === void 0 || selection.x1 === void 0 || selection.y0 === void 0 || selection.y1 === void 0) {
              layoutOut.selections[i] = null;
            }
          }
        }
      };
      function handleSelectionDefaults(selectionIn, selectionOut, fullLayout) {
        function coerce(attr, dflt) {
          return Lib.coerce(selectionIn, selectionOut, attributes, attr, dflt);
        }
        var path = coerce("path");
        var dfltType = path ? "path" : "rect";
        var selectionType = coerce("type", dfltType);
        var noPath = selectionType !== "path";
        if (noPath) delete selectionOut.path;
        coerce("opacity");
        coerce("line.color");
        coerce("line.width");
        coerce("line.dash");
        var axLetters = ["x", "y"];
        for (var i = 0; i < 2; i++) {
          var axLetter = axLetters[i];
          var gdMock = { _fullLayout: fullLayout };
          var ax;
          var pos2r;
          var r2pos;
          var axRef = Axes.coerceRef(selectionIn, selectionOut, gdMock, axLetter);
          ax = Axes.getFromId(gdMock, axRef);
          ax._selectionIndices.push(selectionOut._index);
          r2pos = helpers.rangeToShapePosition(ax);
          pos2r = helpers.shapePositionToRange(ax);
          if (noPath) {
            var attr0 = axLetter + "0";
            var attr1 = axLetter + "1";
            var in0 = selectionIn[attr0];
            var in1 = selectionIn[attr1];
            selectionIn[attr0] = pos2r(selectionIn[attr0], true);
            selectionIn[attr1] = pos2r(selectionIn[attr1], true);
            Axes.coercePosition(selectionOut, gdMock, coerce, axRef, attr0);
            Axes.coercePosition(selectionOut, gdMock, coerce, axRef, attr1);
            var p0 = selectionOut[attr0];
            var p1 = selectionOut[attr1];
            if (p0 !== void 0 && p1 !== void 0) {
              selectionOut[attr0] = r2pos(p0);
              selectionOut[attr1] = r2pos(p1);
              selectionIn[attr0] = in0;
              selectionIn[attr1] = in1;
            }
          }
        }
        if (noPath) {
          Lib.noneOrAll(selectionIn, selectionOut, ["x0", "x1", "y0", "y1"]);
        }
      }
    }
  });

  // src/components/selections/draw_newselection/defaults.js
  var require_defaults7 = __commonJS({
    "src/components/selections/draw_newselection/defaults.js"(exports, module) {
      "use strict";
      module.exports = function supplyDrawNewSelectionDefaults(layoutIn, layoutOut, coerce) {
        coerce("newselection.mode");
        var newselectionLineWidth = coerce("newselection.line.width");
        if (newselectionLineWidth) {
          coerce("newselection.line.color");
          coerce("newselection.line.dash");
        }
        coerce("activeselection.fillcolor");
        coerce("activeselection.opacity");
      };
    }
  });

  // src/plots/cartesian/include_components.js
  var require_include_components = __commonJS({
    "src/plots/cartesian/include_components.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var axisIds = require_axis_ids();
      module.exports = function makeIncludeComponents(containerArrayName) {
        return function includeComponents(layoutIn, layoutOut) {
          var array = layoutIn[containerArrayName];
          if (!Array.isArray(array)) return;
          var Cartesian = Registry.subplotsRegistry.cartesian;
          var idRegex = Cartesian.idRegex;
          var subplots = layoutOut._subplots;
          var xaList = subplots.xaxis;
          var yaList = subplots.yaxis;
          var cartesianList = subplots.cartesian;
          var hasCartesian = layoutOut._has("cartesian");
          for (var i = 0; i < array.length; i++) {
            var itemi = array[i];
            if (!Lib.isPlainObject(itemi)) continue;
            var xref = axisIds.cleanId(itemi.xref, "x", false);
            var yref = axisIds.cleanId(itemi.yref, "y", false);
            var hasXref = idRegex.x.test(xref);
            var hasYref = idRegex.y.test(yref);
            if (hasXref || hasYref) {
              if (!hasCartesian) Lib.pushUnique(layoutOut._basePlotModules, Cartesian);
              var newAxis = false;
              if (hasXref && xaList.indexOf(xref) === -1) {
                xaList.push(xref);
                newAxis = true;
              }
              if (hasYref && yaList.indexOf(yref) === -1) {
                yaList.push(yref);
                newAxis = true;
              }
              if (newAxis && hasXref && hasYref) {
                cartesianList.push(xref + yref);
              }
            }
          }
        };
      };
    }
  });

  // src/components/selections/index.js
  var require_selections = __commonJS({
    "src/components/selections/index.js"(exports, module) {
      "use strict";
      var drawModule = require_draw3();
      var select = require_select();
      module.exports = {
        moduleType: "component",
        name: "selections",
        layoutAttributes: require_attributes13(),
        supplyLayoutDefaults: require_defaults6(),
        supplyDrawNewSelectionDefaults: require_defaults7(),
        includeBasePlot: require_include_components()("selections"),
        draw: drawModule.draw,
        drawOne: drawModule.drawOne,
        reselect: select.reselect,
        prepSelect: select.prepSelect,
        clearOutline: select.clearOutline,
        clearSelectionsCache: select.clearSelectionsCache,
        selectOnClick: select.selectOnClick
      };
    }
  });

  // src/plots/cartesian/dragbox.js
  var require_dragbox = __commonJS({
    "src/plots/cartesian/dragbox.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var numberFormat = Lib.numberFormat;
      var tinycolor = require_tinycolor();
      var supportsPassive = require_has_passive_events();
      var Registry = require_registry();
      var strTranslate = Lib.strTranslate;
      var svgTextUtils = require_svg_text_utils();
      var Color = require_color();
      var Drawing = require_drawing();
      var Fx = require_fx();
      var Axes = require_axes();
      var setCursor = require_setcursor();
      var dragElement = require_dragelement();
      var helpers = require_helpers5();
      var selectingOrDrawing = helpers.selectingOrDrawing;
      var freeMode = helpers.freeMode;
      var FROM_TL = require_alignment().FROM_TL;
      var clearGlCanvases = require_clear_gl_canvases();
      var redrawReglTraces = require_subroutines().redrawReglTraces;
      var Plots = require_plots();
      var getFromId = require_axis_ids().getFromId;
      var prepSelect = require_selections().prepSelect;
      var clearOutline = require_selections().clearOutline;
      var selectOnClick = require_selections().selectOnClick;
      var scaleZoom = require_scale_zoom();
      var constants = require_constants2();
      var MINDRAG = constants.MINDRAG;
      var MINZOOM = constants.MINZOOM;
      var SHOWZOOMOUTTIP = true;
      function makeDragBox(gd, plotinfo, x, y, w, h, ns, ew) {
        var zoomlayer = gd._fullLayout._zoomlayer;
        var isMainDrag = ns + ew === "nsew";
        var singleEnd = (ns + ew).length === 1;
        var xa0, ya0;
        var xaHash, yaHash;
        var xaxes, yaxes;
        var xs, ys;
        var pw, ph;
        var links;
        var matches;
        var xActive, yActive;
        var allFixedRanges;
        var editX, editY;
        var hasScatterGl, hasSplom, hasSVG;
        var updates;
        var scaleX;
        var scaleY;
        x += plotinfo.yaxis._shift;
        function recomputeAxisLists() {
          xa0 = plotinfo.xaxis;
          ya0 = plotinfo.yaxis;
          pw = xa0._length;
          ph = ya0._length;
          xs = xa0._offset;
          ys = ya0._offset;
          xaHash = {};
          xaHash[xa0._id] = xa0;
          yaHash = {};
          yaHash[ya0._id] = ya0;
          if (ns && ew) {
            var overlays = plotinfo.overlays;
            for (var i = 0; i < overlays.length; i++) {
              var xa = overlays[i].xaxis;
              xaHash[xa._id] = xa;
              var ya = overlays[i].yaxis;
              yaHash[ya._id] = ya;
            }
          }
          xaxes = hashValues(xaHash);
          yaxes = hashValues(yaHash);
          xActive = isDirectionActive(xaxes, ew);
          yActive = isDirectionActive(yaxes, ns);
          allFixedRanges = !yActive && !xActive;
          matches = calcLinks(gd, gd._fullLayout._axisMatchGroups, xaHash, yaHash);
          links = calcLinks(gd, gd._fullLayout._axisConstraintGroups, xaHash, yaHash, matches);
          var spConstrained = links.isSubplotConstrained || matches.isSubplotConstrained;
          editX = ew || spConstrained;
          editY = ns || spConstrained;
          var fullLayout = gd._fullLayout;
          hasScatterGl = fullLayout._has("scattergl");
          hasSplom = fullLayout._has("splom");
          hasSVG = fullLayout._has("svg");
        }
        recomputeAxisLists();
        var cursor = getDragCursor(yActive + xActive, gd._fullLayout.dragmode, isMainDrag);
        var dragger = makeRectDragger(plotinfo, ns + ew + "drag", cursor, x, y, w, h);
        if (allFixedRanges && !isMainDrag) {
          dragger.onmousedown = null;
          dragger.style.pointerEvents = "none";
          return dragger;
        }
        var dragOptions = {
          element: dragger,
          gd,
          plotinfo
        };
        dragOptions.prepFn = function(e, startX, startY) {
          var dragModePrev = dragOptions.dragmode;
          var dragModeNow = gd._fullLayout.dragmode;
          if (dragModeNow !== dragModePrev) {
            dragOptions.dragmode = dragModeNow;
          }
          recomputeAxisLists();
          scaleX = gd._fullLayout._invScaleX;
          scaleY = gd._fullLayout._invScaleY;
          if (!allFixedRanges) {
            if (isMainDrag) {
              if (e.shiftKey) {
                if (dragModeNow === "pan") dragModeNow = "zoom";
                else if (!selectingOrDrawing(dragModeNow)) dragModeNow = "pan";
              } else if (e.ctrlKey) {
                dragModeNow = "pan";
              }
            } else {
              dragModeNow = "pan";
            }
          }
          if (freeMode(dragModeNow)) dragOptions.minDrag = 1;
          else dragOptions.minDrag = void 0;
          if (selectingOrDrawing(dragModeNow)) {
            dragOptions.xaxes = xaxes;
            dragOptions.yaxes = yaxes;
            prepSelect(e, startX, startY, dragOptions, dragModeNow);
          } else {
            dragOptions.clickFn = clickFn;
            if (selectingOrDrawing(dragModePrev)) {
              clearAndResetSelect();
            }
            if (!allFixedRanges) {
              if (dragModeNow === "zoom") {
                dragOptions.moveFn = zoomMove;
                dragOptions.doneFn = zoomDone;
                dragOptions.minDrag = 1;
                zoomPrep(e, startX, startY);
              } else if (dragModeNow === "pan") {
                dragOptions.moveFn = plotDrag;
                dragOptions.doneFn = dragTail;
              }
            }
          }
          gd._fullLayout._redrag = function() {
            var dragDataNow = gd._dragdata;
            if (dragDataNow && dragDataNow.element === dragger) {
              var dragModeNow2 = gd._fullLayout.dragmode;
              if (!selectingOrDrawing(dragModeNow2)) {
                recomputeAxisLists();
                updateSubplots([0, 0, pw, ph]);
                dragOptions.moveFn(dragDataNow.dx, dragDataNow.dy);
              }
            }
          };
        };
        function clearAndResetSelect() {
          dragOptions.plotinfo.selection = false;
          clearOutline(gd);
        }
        function clickFn(numClicks, evt) {
          var gd2 = dragOptions.gd;
          if (gd2._fullLayout._activeShapeIndex >= 0) {
            gd2._fullLayout._deactivateShape(gd2);
            return;
          }
          var clickmode = gd2._fullLayout.clickmode;
          removeZoombox(gd2);
          if (numClicks === 2 && !singleEnd) doubleClick();
          if (isMainDrag) {
            if (clickmode.indexOf("select") > -1) {
              selectOnClick(evt, gd2, xaxes, yaxes, plotinfo.id, dragOptions);
            }
            if (clickmode.indexOf("event") > -1) {
              Fx.click(gd2, evt, plotinfo.id);
            }
          } else if (numClicks === 1 && singleEnd) {
            var ax = ns ? ya0 : xa0;
            var end = ns === "s" || ew === "w" ? 0 : 1;
            var attrStr = ax._name + ".range[" + end + "]";
            var initialText = getEndText(ax, end);
            var hAlign = "left";
            var vAlign = "middle";
            if (ax.fixedrange) return;
            if (ns) {
              vAlign = ns === "n" ? "top" : "bottom";
              if (ax.side === "right") hAlign = "right";
            } else if (ew === "e") hAlign = "right";
            if (gd2._context.showAxisRangeEntryBoxes) {
              d3.select(dragger).call(svgTextUtils.makeEditable, {
                gd: gd2,
                immediate: true,
                background: gd2._fullLayout.paper_bgcolor,
                text: String(initialText),
                fill: ax.tickfont ? ax.tickfont.color : "#444",
                horizontalAlign: hAlign,
                verticalAlign: vAlign
              }).on("edit", function(text) {
                var v = ax.d2r(text);
                if (v !== void 0) {
                  Registry.call("_guiRelayout", gd2, attrStr, v);
                }
              });
            }
          }
        }
        dragElement.init(dragOptions);
        var x0, y0;
        var box;
        var lum;
        var path0;
        var dimmed;
        var zoomMode;
        var zb;
        var corners;
        var zoomDragged;
        function zoomPrep(e, startX, startY) {
          var dragBBox = dragger.getBoundingClientRect();
          x0 = startX - dragBBox.left;
          y0 = startY - dragBBox.top;
          gd._fullLayout._calcInverseTransform(gd);
          var transformedCoords = Lib.apply3DTransform(gd._fullLayout._invTransform)(x0, y0);
          x0 = transformedCoords[0];
          y0 = transformedCoords[1];
          box = { l: x0, r: x0, w: 0, t: y0, b: y0, h: 0 };
          lum = gd._hmpixcount ? gd._hmlumcount / gd._hmpixcount : tinycolor(gd._fullLayout.plot_bgcolor).getLuminance();
          path0 = "M0,0H" + pw + "V" + ph + "H0V0";
          dimmed = false;
          zoomMode = "xy";
          zoomDragged = false;
          zb = makeZoombox(zoomlayer, lum, xs, ys, path0);
          corners = makeCorners(zoomlayer, xs, ys);
        }
        function zoomMove(dx0, dy0) {
          if (gd._transitioningWithDuration) {
            return false;
          }
          var x1 = Math.max(0, Math.min(pw, scaleX * dx0 + x0));
          var y1 = Math.max(0, Math.min(ph, scaleY * dy0 + y0));
          var dx = Math.abs(x1 - x0);
          var dy = Math.abs(y1 - y0);
          box.l = Math.min(x0, x1);
          box.r = Math.max(x0, x1);
          box.t = Math.min(y0, y1);
          box.b = Math.max(y0, y1);
          function noZoom() {
            zoomMode = "";
            box.r = box.l;
            box.t = box.b;
            corners.attr("d", "M0,0Z");
          }
          if (links.isSubplotConstrained) {
            if (dx > MINZOOM || dy > MINZOOM) {
              zoomMode = "xy";
              if (dx / pw > dy / ph) {
                dy = dx * ph / pw;
                if (y0 > y1) box.t = y0 - dy;
                else box.b = y0 + dy;
              } else {
                dx = dy * pw / ph;
                if (x0 > x1) box.l = x0 - dx;
                else box.r = x0 + dx;
              }
              corners.attr("d", xyCorners(box));
            } else {
              noZoom();
            }
          } else if (matches.isSubplotConstrained) {
            if (dx > MINZOOM || dy > MINZOOM) {
              zoomMode = "xy";
              var r0 = Math.min(box.l / pw, (ph - box.b) / ph);
              var r1 = Math.max(box.r / pw, (ph - box.t) / ph);
              box.l = r0 * pw;
              box.r = r1 * pw;
              box.b = (1 - r0) * ph;
              box.t = (1 - r1) * ph;
              corners.attr("d", xyCorners(box));
            } else {
              noZoom();
            }
          } else if (!yActive || dy < Math.min(Math.max(dx * 0.6, MINDRAG), MINZOOM)) {
            if (dx < MINDRAG || !xActive) {
              noZoom();
            } else {
              box.t = 0;
              box.b = ph;
              zoomMode = "x";
              corners.attr("d", xCorners(box, y0));
            }
          } else if (!xActive || dx < Math.min(dy * 0.6, MINZOOM)) {
            box.l = 0;
            box.r = pw;
            zoomMode = "y";
            corners.attr("d", yCorners(box, x0));
          } else {
            zoomMode = "xy";
            corners.attr("d", xyCorners(box));
          }
          box.w = box.r - box.l;
          box.h = box.b - box.t;
          if (zoomMode) zoomDragged = true;
          gd._dragged = zoomDragged;
          updateZoombox(zb, corners, box, path0, dimmed, lum);
          computeZoomUpdates();
          gd.emit("plotly_relayouting", updates);
          dimmed = true;
        }
        function computeZoomUpdates() {
          updates = {};
          if (zoomMode === "xy" || zoomMode === "x") {
            zoomAxRanges(xaxes, box.l / pw, box.r / pw, updates, links.xaxes);
            updateMatchedAxRange("x", updates);
          }
          if (zoomMode === "xy" || zoomMode === "y") {
            zoomAxRanges(yaxes, (ph - box.b) / ph, (ph - box.t) / ph, updates, links.yaxes);
            updateMatchedAxRange("y", updates);
          }
        }
        function zoomDone() {
          computeZoomUpdates();
          removeZoombox(gd);
          dragTail();
          showDoubleClickNotifier(gd);
        }
        var scrollViewBox = [0, 0, pw, ph];
        var redrawTimer = null;
        var REDRAWDELAY = constants.REDRAWDELAY;
        var mainplot = plotinfo.mainplot ? gd._fullLayout._plots[plotinfo.mainplot] : plotinfo;
        function zoomWheel(e) {
          if (!gd._context._scrollZoom.cartesian && !gd._fullLayout._enablescrollzoom) {
            return;
          }
          clearAndResetSelect();
          if (gd._transitioningWithDuration) {
            e.preventDefault();
            e.stopPropagation();
            return;
          }
          recomputeAxisLists();
          clearTimeout(redrawTimer);
          var wheelDelta = -e.deltaY;
          if (!isFinite(wheelDelta)) wheelDelta = e.wheelDelta / 10;
          if (!isFinite(wheelDelta)) {
            Lib.log("Did not find wheel motion attributes: ", e);
            return;
          }
          var zoom = Math.exp(-Math.min(Math.max(wheelDelta, -20), 20) / 200);
          var gbb = mainplot.draglayer.select(".nsewdrag").node().getBoundingClientRect();
          var xfrac = (e.clientX - gbb.left) / gbb.width;
          var yfrac = (gbb.bottom - e.clientY) / gbb.height;
          var i;
          function zoomWheelOneAxis(ax, centerFraction, zoom2) {
            if (ax.fixedrange) return;
            var axRange = Lib.simpleMap(ax.range, ax.r2l);
            var v0 = axRange[0] + (axRange[1] - axRange[0]) * centerFraction;
            function doZoom(v) {
              return ax.l2r(v0 + (v - v0) * zoom2);
            }
            ax.range = axRange.map(doZoom);
          }
          if (editX) {
            if (!ew) xfrac = 0.5;
            for (i = 0; i < xaxes.length; i++) {
              zoomWheelOneAxis(xaxes[i], xfrac, zoom);
            }
            updateMatchedAxRange("x");
            scrollViewBox[2] *= zoom;
            scrollViewBox[0] += scrollViewBox[2] * xfrac * (1 / zoom - 1);
          }
          if (editY) {
            if (!ns) yfrac = 0.5;
            for (i = 0; i < yaxes.length; i++) {
              zoomWheelOneAxis(yaxes[i], yfrac, zoom);
            }
            updateMatchedAxRange("y");
            scrollViewBox[3] *= zoom;
            scrollViewBox[1] += scrollViewBox[3] * (1 - yfrac) * (1 / zoom - 1);
          }
          updateSubplots(scrollViewBox);
          ticksAndAnnotations();
          gd.emit("plotly_relayouting", updates);
          redrawTimer = setTimeout(function() {
            if (!gd._fullLayout) return;
            scrollViewBox = [0, 0, pw, ph];
            dragTail();
          }, REDRAWDELAY);
          e.preventDefault();
          return;
        }
        if (ns.length * ew.length !== 1) {
          attachWheelEventHandler(dragger, zoomWheel);
        }
        function plotDrag(dx, dy) {
          dx = dx * scaleX;
          dy = dy * scaleY;
          if (gd._transitioningWithDuration) {
            return;
          }
          gd._fullLayout._replotting = true;
          if (xActive === "ew" || yActive === "ns") {
            var spDx = xActive ? -dx : 0;
            var spDy = yActive ? -dy : 0;
            if (matches.isSubplotConstrained) {
              if (xActive && yActive) {
                var frac = (dx / pw - dy / ph) / 2;
                dx = frac * pw;
                dy = -frac * ph;
                spDx = -dx;
                spDy = -dy;
              }
              if (yActive) {
                spDx = -spDy * pw / ph;
              } else {
                spDy = -spDx * ph / pw;
              }
            }
            if (xActive) {
              dragAxList(xaxes, dx);
              updateMatchedAxRange("x");
            }
            if (yActive) {
              dragAxList(yaxes, dy);
              updateMatchedAxRange("y");
            }
            updateSubplots([spDx, spDy, pw, ph]);
            ticksAndAnnotations();
            gd.emit("plotly_relayouting", updates);
            return;
          }
          function dz(axArray, end, d) {
            var otherEnd = 1 - end;
            var movedAx;
            var newLinearizedEnd;
            for (var i2 = 0; i2 < axArray.length; i2++) {
              var axi = axArray[i2];
              if (axi.fixedrange) continue;
              movedAx = axi;
              newLinearizedEnd = axi._rl[otherEnd] + (axi._rl[end] - axi._rl[otherEnd]) / dZoom(d / axi._length);
              var newEnd = axi.l2r(newLinearizedEnd);
              if (newEnd !== false && newEnd !== void 0) axi.range[end] = newEnd;
            }
            return movedAx._length * (movedAx._rl[end] - newLinearizedEnd) / (movedAx._rl[end] - movedAx._rl[otherEnd]);
          }
          var dxySign = xActive === "w" === (yActive === "n") ? 1 : -1;
          if (xActive && yActive && (links.isSubplotConstrained || matches.isSubplotConstrained)) {
            var dxyFraction = (dx / pw + dxySign * dy / ph) / 2;
            dx = dxyFraction * pw;
            dy = dxySign * dxyFraction * ph;
          }
          var xStart, yStart;
          if (xActive === "w") dx = dz(xaxes, 0, dx);
          else if (xActive === "e") dx = dz(xaxes, 1, -dx);
          else if (!xActive) dx = 0;
          if (yActive === "n") dy = dz(yaxes, 1, dy);
          else if (yActive === "s") dy = dz(yaxes, 0, -dy);
          else if (!yActive) dy = 0;
          xStart = xActive === "w" ? dx : 0;
          yStart = yActive === "n" ? dy : 0;
          if (links.isSubplotConstrained && !matches.isSubplotConstrained || // NW or SE on matching axes - create a symmetric zoom
          matches.isSubplotConstrained && xActive && yActive && dxySign > 0) {
            var i;
            if (matches.isSubplotConstrained || !xActive && yActive.length === 1) {
              for (i = 0; i < xaxes.length; i++) {
                xaxes[i].range = xaxes[i]._r.slice();
                scaleZoom(xaxes[i], 1 - dy / ph);
              }
              dx = dy * pw / ph;
              xStart = dx / 2;
            }
            if (matches.isSubplotConstrained || !yActive && xActive.length === 1) {
              for (i = 0; i < yaxes.length; i++) {
                yaxes[i].range = yaxes[i]._r.slice();
                scaleZoom(yaxes[i], 1 - dx / pw);
              }
              dy = dx * ph / pw;
              yStart = dy / 2;
            }
          }
          if (!matches.isSubplotConstrained || !yActive) {
            updateMatchedAxRange("x");
          }
          if (!matches.isSubplotConstrained || !xActive) {
            updateMatchedAxRange("y");
          }
          var xSize = pw - dx;
          var ySize = ph - dy;
          if (matches.isSubplotConstrained && !(xActive && yActive)) {
            if (xActive) {
              yStart = xStart ? 0 : dx * ph / pw;
              ySize = xSize * ph / pw;
            } else {
              xStart = yStart ? 0 : dy * pw / ph;
              xSize = ySize * pw / ph;
            }
          }
          updateSubplots([xStart, yStart, xSize, ySize]);
          ticksAndAnnotations();
          gd.emit("plotly_relayouting", updates);
        }
        function updateMatchedAxRange(axLetter, out) {
          var matchedAxes = matches.isSubplotConstrained ? { x: yaxes, y: xaxes }[axLetter] : matches[axLetter + "axes"];
          var constrainedAxes = matches.isSubplotConstrained ? { x: xaxes, y: yaxes }[axLetter] : [];
          for (var i = 0; i < matchedAxes.length; i++) {
            var ax = matchedAxes[i];
            var axId = ax._id;
            var axId2 = matches.xLinks[axId] || matches.yLinks[axId];
            var ax2 = constrainedAxes[0] || xaHash[axId2] || yaHash[axId2];
            if (ax2) {
              if (out) {
                out[ax._name + ".range[0]"] = out[ax2._name + ".range[0]"];
                out[ax._name + ".range[1]"] = out[ax2._name + ".range[1]"];
              } else {
                ax.range = ax2.range.slice();
              }
            }
          }
        }
        function ticksAndAnnotations() {
          var activeAxIds = [];
          var i;
          function pushActiveAxIds(axList) {
            for (i = 0; i < axList.length; i++) {
              if (!axList[i].fixedrange) activeAxIds.push(axList[i]._id);
            }
          }
          function pushActiveAxIdsSynced(axList, axisType) {
            for (i = 0; i < axList.length; i++) {
              var axListI = axList[i];
              var axListIType = axListI[axisType];
              if (!axListI.fixedrange && axListIType.tickmode === "sync") activeAxIds.push(axListIType._id);
            }
          }
          if (editX) {
            pushActiveAxIds(xaxes);
            pushActiveAxIds(links.xaxes);
            pushActiveAxIds(matches.xaxes);
            pushActiveAxIdsSynced(plotinfo.overlays, "xaxis");
          }
          if (editY) {
            pushActiveAxIds(yaxes);
            pushActiveAxIds(links.yaxes);
            pushActiveAxIds(matches.yaxes);
            pushActiveAxIdsSynced(plotinfo.overlays, "yaxis");
          }
          updates = {};
          for (i = 0; i < activeAxIds.length; i++) {
            var axId = activeAxIds[i];
            var ax = getFromId(gd, axId);
            Axes.drawOne(gd, ax, { skipTitle: true });
            updates[ax._name + ".range[0]"] = ax.range[0];
            updates[ax._name + ".range[1]"] = ax.range[1];
          }
          Axes.redrawComponents(gd, activeAxIds);
        }
        function doubleClick() {
          if (gd._transitioningWithDuration) return;
          var doubleClickConfig = gd._context.doubleClick;
          var axList = [];
          if (xActive) axList = axList.concat(xaxes);
          if (yActive) axList = axList.concat(yaxes);
          if (matches.xaxes) axList = axList.concat(matches.xaxes);
          if (matches.yaxes) axList = axList.concat(matches.yaxes);
          var attrs = {};
          var ax, i;
          if (doubleClickConfig === "reset+autosize") {
            doubleClickConfig = "autosize";
            for (i = 0; i < axList.length; i++) {
              ax = axList[i];
              var r0 = ax._rangeInitial0;
              var r1 = ax._rangeInitial1;
              var hasRangeInitial = r0 !== void 0 || r1 !== void 0;
              if (hasRangeInitial && (r0 !== void 0 && r0 !== ax.range[0] || r1 !== void 0 && r1 !== ax.range[1]) || !hasRangeInitial && ax.autorange !== true) {
                doubleClickConfig = "reset";
                break;
              }
            }
          }
          if (doubleClickConfig === "autosize") {
            for (i = 0; i < axList.length; i++) {
              ax = axList[i];
              if (!ax.fixedrange) attrs[ax._name + ".autorange"] = true;
            }
          } else if (doubleClickConfig === "reset") {
            if (xActive || links.isSubplotConstrained) axList = axList.concat(links.xaxes);
            if (yActive && !links.isSubplotConstrained) axList = axList.concat(links.yaxes);
            if (links.isSubplotConstrained) {
              if (!xActive) axList = axList.concat(xaxes);
              else if (!yActive) axList = axList.concat(yaxes);
            }
            for (i = 0; i < axList.length; i++) {
              ax = axList[i];
              if (!ax.fixedrange) {
                var axName = ax._name;
                var autorangeInitial = ax._autorangeInitial;
                if (ax._rangeInitial0 === void 0 && ax._rangeInitial1 === void 0) {
                  attrs[axName + ".autorange"] = true;
                } else if (ax._rangeInitial0 === void 0) {
                  attrs[axName + ".autorange"] = autorangeInitial;
                  attrs[axName + ".range"] = [null, ax._rangeInitial1];
                } else if (ax._rangeInitial1 === void 0) {
                  attrs[axName + ".range"] = [ax._rangeInitial0, null];
                  attrs[axName + ".autorange"] = autorangeInitial;
                } else {
                  attrs[axName + ".range"] = [ax._rangeInitial0, ax._rangeInitial1];
                }
              }
            }
          }
          gd.emit("plotly_doubleclick", null);
          Registry.call("_guiRelayout", gd, attrs);
        }
        function dragTail() {
          updateSubplots([0, 0, pw, ph]);
          Lib.syncOrAsync([
            Plots.previousPromises,
            function() {
              gd._fullLayout._replotting = false;
              Registry.call("_guiRelayout", gd, updates);
            }
          ], gd);
        }
        function updateSubplots(viewBox) {
          var fullLayout = gd._fullLayout;
          var plotinfos = fullLayout._plots;
          var subplots = fullLayout._subplots.cartesian;
          var i, sp, xa, ya;
          if (hasSplom) {
            Registry.subplotsRegistry.splom.drag(gd);
          }
          if (hasScatterGl) {
            for (i = 0; i < subplots.length; i++) {
              sp = plotinfos[subplots[i]];
              xa = sp.xaxis;
              ya = sp.yaxis;
              if (sp._scene) {
                if (xa.limitRange) xa.limitRange();
                if (ya.limitRange) ya.limitRange();
                var xrng = Lib.simpleMap(xa.range, xa.r2l);
                var yrng = Lib.simpleMap(ya.range, ya.r2l);
                sp._scene.update({ range: [xrng[0], yrng[0], xrng[1], yrng[1]] });
              }
            }
          }
          if (hasSplom || hasScatterGl) {
            clearGlCanvases(gd);
            redrawReglTraces(gd);
          }
          if (hasSVG) {
            var xScaleFactor = viewBox[2] / xa0._length;
            var yScaleFactor = viewBox[3] / ya0._length;
            for (i = 0; i < subplots.length; i++) {
              sp = plotinfos[subplots[i]];
              xa = sp.xaxis;
              ya = sp.yaxis;
              var editX2 = (editX || matches.isSubplotConstrained) && !xa.fixedrange && xaHash[xa._id];
              var editY2 = (editY || matches.isSubplotConstrained) && !ya.fixedrange && yaHash[ya._id];
              var xScaleFactor2, yScaleFactor2;
              var clipDx, clipDy;
              if (editX2) {
                xScaleFactor2 = xScaleFactor;
                clipDx = ew || matches.isSubplotConstrained ? viewBox[0] : getShift(xa, xScaleFactor2);
              } else if (matches.xaHash[xa._id]) {
                xScaleFactor2 = xScaleFactor;
                clipDx = viewBox[0] * xa._length / xa0._length;
              } else if (matches.yaHash[xa._id]) {
                xScaleFactor2 = yScaleFactor;
                clipDx = yActive === "ns" ? -viewBox[1] * xa._length / ya0._length : getShift(xa, xScaleFactor2, { n: "top", s: "bottom" }[yActive]);
              } else {
                xScaleFactor2 = getLinkedScaleFactor(xa, xScaleFactor, yScaleFactor);
                clipDx = scaleAndGetShift(xa, xScaleFactor2);
              }
              if (xScaleFactor2 > 1 && (xa.maxallowed !== void 0 && editX === (xa.range[0] < xa.range[1] ? "e" : "w") || xa.minallowed !== void 0 && editX === (xa.range[0] < xa.range[1] ? "w" : "e"))) {
                xScaleFactor2 = 1;
                clipDx = 0;
              }
              if (editY2) {
                yScaleFactor2 = yScaleFactor;
                clipDy = ns || matches.isSubplotConstrained ? viewBox[1] : getShift(ya, yScaleFactor2);
              } else if (matches.yaHash[ya._id]) {
                yScaleFactor2 = yScaleFactor;
                clipDy = viewBox[1] * ya._length / ya0._length;
              } else if (matches.xaHash[ya._id]) {
                yScaleFactor2 = xScaleFactor;
                clipDy = xActive === "ew" ? -viewBox[0] * ya._length / xa0._length : getShift(ya, yScaleFactor2, { e: "right", w: "left" }[xActive]);
              } else {
                yScaleFactor2 = getLinkedScaleFactor(ya, xScaleFactor, yScaleFactor);
                clipDy = scaleAndGetShift(ya, yScaleFactor2);
              }
              if (yScaleFactor2 > 1 && (ya.maxallowed !== void 0 && editY === (ya.range[0] < ya.range[1] ? "n" : "s") || ya.minallowed !== void 0 && editY === (ya.range[0] < ya.range[1] ? "s" : "n"))) {
                yScaleFactor2 = 1;
                clipDy = 0;
              }
              if (!xScaleFactor2 && !yScaleFactor2) {
                continue;
              }
              if (!xScaleFactor2) xScaleFactor2 = 1;
              if (!yScaleFactor2) yScaleFactor2 = 1;
              var plotDx = xa._offset - clipDx / xScaleFactor2;
              var plotDy = ya._offset - clipDy / yScaleFactor2;
              sp.clipRect.call(Drawing.setTranslate, clipDx, clipDy).call(Drawing.setScale, xScaleFactor2, yScaleFactor2);
              sp.plot.call(Drawing.setTranslate, plotDx, plotDy).call(Drawing.setScale, 1 / xScaleFactor2, 1 / yScaleFactor2);
              if (xScaleFactor2 !== sp.xScaleFactor || yScaleFactor2 !== sp.yScaleFactor) {
                Drawing.setPointGroupScale(sp.zoomScalePts, xScaleFactor2, yScaleFactor2);
                Drawing.setTextPointsScale(sp.zoomScaleTxt, xScaleFactor2, yScaleFactor2);
              }
              Drawing.hideOutsideRangePoints(sp.clipOnAxisFalseTraces, sp);
              sp.xScaleFactor = xScaleFactor2;
              sp.yScaleFactor = yScaleFactor2;
            }
          }
        }
        function getLinkedScaleFactor(ax, xScaleFactor, yScaleFactor) {
          if (ax.fixedrange) return 0;
          if (editX && links.xaHash[ax._id]) {
            return xScaleFactor;
          }
          if (editY && (links.isSubplotConstrained ? links.xaHash : links.yaHash)[ax._id]) {
            return yScaleFactor;
          }
          return 0;
        }
        function scaleAndGetShift(ax, scaleFactor) {
          if (scaleFactor) {
            ax.range = ax._r.slice();
            scaleZoom(ax, scaleFactor);
            return getShift(ax, scaleFactor);
          }
          return 0;
        }
        function getShift(ax, scaleFactor, from) {
          return ax._length * (1 - scaleFactor) * FROM_TL[from || ax.constraintoward || "middle"];
        }
        return dragger;
      }
      function makeDragger(plotinfo, nodeName, dragClass, cursor) {
        var dragger3 = Lib.ensureSingle(plotinfo.draglayer, nodeName, dragClass, function(s) {
          s.classed("drag", true).style({ fill: "transparent", "stroke-width": 0 }).attr("data-subplot", plotinfo.id);
        });
        dragger3.call(setCursor, cursor);
        return dragger3.node();
      }
      function makeRectDragger(plotinfo, dragClass, cursor, x, y, w, h) {
        var dragger = makeDragger(plotinfo, "rect", dragClass, cursor);
        d3.select(dragger).call(Drawing.setRect, x, y, w, h);
        return dragger;
      }
      function isDirectionActive(axList, activeVal) {
        for (var i = 0; i < axList.length; i++) {
          if (!axList[i].fixedrange) return activeVal;
        }
        return "";
      }
      function getEndText(ax, end) {
        var initialVal = ax.range[end];
        var diff = Math.abs(initialVal - ax.range[1 - end]);
        var dig;
        if (ax.type === "date") {
          return initialVal;
        } else if (ax.type === "log") {
          dig = Math.ceil(Math.max(0, -Math.log(diff) / Math.LN10)) + 3;
          return numberFormat("." + dig + "g")(Math.pow(10, initialVal));
        } else {
          dig = Math.floor(Math.log(Math.abs(initialVal)) / Math.LN10) - Math.floor(Math.log(diff) / Math.LN10) + 4;
          return numberFormat("." + String(dig) + "g")(initialVal);
        }
      }
      function zoomAxRanges(axList, r0Fraction, r1Fraction, updates, linkedAxes) {
        for (var i = 0; i < axList.length; i++) {
          var axi = axList[i];
          if (axi.fixedrange) continue;
          if (axi.rangebreaks) {
            var isY = axi._id.charAt(0) === "y";
            var r0F = isY ? 1 - r0Fraction : r0Fraction;
            var r1F = isY ? 1 - r1Fraction : r1Fraction;
            updates[axi._name + ".range[0]"] = axi.l2r(axi.p2l(r0F * axi._length));
            updates[axi._name + ".range[1]"] = axi.l2r(axi.p2l(r1F * axi._length));
          } else {
            var axRangeLinear0 = axi._rl[0];
            var axRangeLinearSpan = axi._rl[1] - axRangeLinear0;
            updates[axi._name + ".range[0]"] = axi.l2r(axRangeLinear0 + axRangeLinearSpan * r0Fraction);
            updates[axi._name + ".range[1]"] = axi.l2r(axRangeLinear0 + axRangeLinearSpan * r1Fraction);
          }
        }
        if (linkedAxes && linkedAxes.length) {
          var linkedR0Fraction = (r0Fraction + (1 - r1Fraction)) / 2;
          zoomAxRanges(linkedAxes, linkedR0Fraction, 1 - linkedR0Fraction, updates, []);
        }
      }
      function dragAxList(axList, pix) {
        for (var i = 0; i < axList.length; i++) {
          var axi = axList[i];
          if (!axi.fixedrange) {
            if (axi.rangebreaks) {
              var p0 = 0;
              var p1 = axi._length;
              var d0 = axi.p2l(p0 + pix) - axi.p2l(p0);
              var d1 = axi.p2l(p1 + pix) - axi.p2l(p1);
              var delta = (d0 + d1) / 2;
              axi.range = [
                axi.l2r(axi._rl[0] - delta),
                axi.l2r(axi._rl[1] - delta)
              ];
            } else {
              axi.range = [
                axi.l2r(axi._rl[0] - pix / axi._m),
                axi.l2r(axi._rl[1] - pix / axi._m)
              ];
            }
            if (axi.limitRange) axi.limitRange();
          }
        }
      }
      function dZoom(d) {
        return 1 - (d >= 0 ? Math.min(d, 0.9) : 1 / (1 / Math.max(d, -0.3) + 3.222));
      }
      function getDragCursor(nsew, dragmode, isMainDrag) {
        if (!nsew) return "pointer";
        if (nsew === "nsew") {
          if (isMainDrag) return "";
          if (dragmode === "pan") return "move";
          return "crosshair";
        }
        return nsew.toLowerCase() + "-resize";
      }
      function makeZoombox(zoomlayer, lum, xs, ys, path0) {
        return zoomlayer.append("path").attr("class", "zoombox").style({
          fill: lum > 0.2 ? "rgba(0,0,0,0)" : "rgba(255,255,255,0)",
          "stroke-width": 0
        }).attr("transform", strTranslate(xs, ys)).attr("d", path0 + "Z");
      }
      function makeCorners(zoomlayer, xs, ys) {
        return zoomlayer.append("path").attr("class", "zoombox-corners").style({
          fill: Color.background,
          stroke: Color.defaultLine,
          "stroke-width": 1,
          opacity: 0
        }).attr("transform", strTranslate(xs, ys)).attr("d", "M0,0Z");
      }
      function updateZoombox(zb, corners, box, path0, dimmed, lum) {
        zb.attr(
          "d",
          path0 + "M" + box.l + "," + box.t + "v" + box.h + "h" + box.w + "v-" + box.h + "h-" + box.w + "Z"
        );
        transitionZoombox(zb, corners, dimmed, lum);
      }
      function transitionZoombox(zb, corners, dimmed, lum) {
        if (!dimmed) {
          zb.transition().style("fill", lum > 0.2 ? "rgba(0,0,0,0.4)" : "rgba(255,255,255,0.3)").duration(200);
          corners.transition().style("opacity", 1).duration(200);
        }
      }
      function removeZoombox(gd) {
        d3.select(gd).selectAll(".zoombox,.js-zoombox-backdrop,.js-zoombox-menu,.zoombox-corners").remove();
      }
      function showDoubleClickNotifier(gd) {
        if (SHOWZOOMOUTTIP && gd.data && gd._context.showTips) {
          Lib.notifier(Lib._(gd, "Double-click to zoom back out"), "long");
          SHOWZOOMOUTTIP = false;
        }
      }
      function xCorners(box, y0) {
        return "M" + (box.l - 0.5) + "," + (y0 - MINZOOM - 0.5) + "h-3v" + (2 * MINZOOM + 1) + "h3ZM" + (box.r + 0.5) + "," + (y0 - MINZOOM - 0.5) + "h3v" + (2 * MINZOOM + 1) + "h-3Z";
      }
      function yCorners(box, x0) {
        return "M" + (x0 - MINZOOM - 0.5) + "," + (box.t - 0.5) + "v-3h" + (2 * MINZOOM + 1) + "v3ZM" + (x0 - MINZOOM - 0.5) + "," + (box.b + 0.5) + "v3h" + (2 * MINZOOM + 1) + "v-3Z";
      }
      function xyCorners(box) {
        var clen = Math.floor(Math.min(box.b - box.t, box.r - box.l, MINZOOM) / 2);
        return "M" + (box.l - 3.5) + "," + (box.t - 0.5 + clen) + "h3v" + -clen + "h" + clen + "v-3h-" + (clen + 3) + "ZM" + (box.r + 3.5) + "," + (box.t - 0.5 + clen) + "h-3v" + -clen + "h" + -clen + "v-3h" + (clen + 3) + "ZM" + (box.r + 3.5) + "," + (box.b + 0.5 - clen) + "h-3v" + clen + "h" + -clen + "v3h" + (clen + 3) + "ZM" + (box.l - 3.5) + "," + (box.b + 0.5 - clen) + "h3v" + clen + "h" + clen + "v3h-" + (clen + 3) + "Z";
      }
      function calcLinks(gd, groups, xaHash, yaHash, exclude) {
        var isSubplotConstrained = false;
        var xLinks = {};
        var yLinks = {};
        var xID, yID, xLinkID, yLinkID;
        var xExclude = (exclude || {}).xaHash;
        var yExclude = (exclude || {}).yaHash;
        for (var i = 0; i < groups.length; i++) {
          var group = groups[i];
          for (xID in xaHash) {
            if (group[xID]) {
              for (xLinkID in group) {
                if (!(exclude && (xExclude[xLinkID] || yExclude[xLinkID])) && !(xLinkID.charAt(0) === "x" ? xaHash : yaHash)[xLinkID]) {
                  xLinks[xLinkID] = xID;
                }
              }
              for (yID in yaHash) {
                if (!(exclude && (xExclude[yID] || yExclude[yID])) && group[yID]) {
                  isSubplotConstrained = true;
                }
              }
            }
          }
          for (yID in yaHash) {
            if (group[yID]) {
              for (yLinkID in group) {
                if (!(exclude && (xExclude[yLinkID] || yExclude[yLinkID])) && !(yLinkID.charAt(0) === "x" ? xaHash : yaHash)[yLinkID]) {
                  yLinks[yLinkID] = yID;
                }
              }
            }
          }
        }
        if (isSubplotConstrained) {
          Lib.extendFlat(xLinks, yLinks);
          yLinks = {};
        }
        var xaHashLinked = {};
        var xaxesLinked = [];
        for (xLinkID in xLinks) {
          var xa = getFromId(gd, xLinkID);
          xaxesLinked.push(xa);
          xaHashLinked[xa._id] = xa;
        }
        var yaHashLinked = {};
        var yaxesLinked = [];
        for (yLinkID in yLinks) {
          var ya = getFromId(gd, yLinkID);
          yaxesLinked.push(ya);
          yaHashLinked[ya._id] = ya;
        }
        return {
          xaHash: xaHashLinked,
          yaHash: yaHashLinked,
          xaxes: xaxesLinked,
          yaxes: yaxesLinked,
          xLinks,
          yLinks,
          isSubplotConstrained
        };
      }
      function attachWheelEventHandler(element, handler) {
        if (!supportsPassive) {
          if (element.onwheel !== void 0) element.onwheel = handler;
          else if (element.onmousewheel !== void 0) element.onmousewheel = handler;
          else if (!element.isAddedWheelEvent) {
            element.isAddedWheelEvent = true;
            element.addEventListener("wheel", handler, { passive: false });
          }
        } else {
          var wheelEventName = element.onwheel !== void 0 ? "wheel" : "mousewheel";
          if (element._onwheel) {
            element.removeEventListener(wheelEventName, element._onwheel);
          }
          element._onwheel = handler;
          element.addEventListener(wheelEventName, handler, { passive: false });
        }
      }
      function hashValues(hash) {
        var out = [];
        for (var k in hash) out.push(hash[k]);
        return out;
      }
      module.exports = {
        makeDragBox,
        makeDragger,
        makeRectDragger,
        makeZoombox,
        makeCorners,
        updateZoombox,
        xyCorners,
        transitionZoombox,
        removeZoombox,
        showDoubleClickNotifier,
        attachWheelEventHandler
      };
    }
  });

  // src/plots/cartesian/graph_interact.js
  var require_graph_interact = __commonJS({
    "src/plots/cartesian/graph_interact.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var Fx = require_fx();
      var dragElement = require_dragelement();
      var setCursor = require_setcursor();
      var makeDragBox = require_dragbox().makeDragBox;
      var DRAGGERSIZE = require_constants2().DRAGGERSIZE;
      exports.initInteractions = function initInteractions(gd) {
        var fullLayout = gd._fullLayout;
        if (gd._context.staticPlot) {
          d3.select(gd).selectAll(".drag").remove();
          return;
        }
        if (!fullLayout._has("cartesian") && !fullLayout._has("splom")) return;
        var subplots = Object.keys(fullLayout._plots || {}).sort(function(a, b) {
          if ((fullLayout._plots[a].mainplot && true) === (fullLayout._plots[b].mainplot && true)) {
            var aParts = a.split("y");
            var bParts = b.split("y");
            return aParts[0] === bParts[0] ? Number(aParts[1] || 1) - Number(bParts[1] || 1) : Number(aParts[0] || 1) - Number(bParts[0] || 1);
          }
          return fullLayout._plots[a].mainplot ? 1 : -1;
        });
        subplots.forEach(function(subplot) {
          var plotinfo = fullLayout._plots[subplot];
          var xa = plotinfo.xaxis;
          var ya = plotinfo.yaxis;
          if (!plotinfo.mainplot) {
            var maindrag = makeDragBox(
              gd,
              plotinfo,
              xa._offset,
              ya._offset,
              xa._length,
              ya._length,
              "ns",
              "ew"
            );
            maindrag.onmousemove = function(evt) {
              gd._fullLayout._rehover = function() {
                if (gd._fullLayout._hoversubplot === subplot && gd._fullLayout._plots[subplot]) {
                  Fx.hover(gd, evt, subplot);
                }
              };
              Fx.hover(gd, evt, subplot);
              gd._fullLayout._lasthover = maindrag;
              gd._fullLayout._hoversubplot = subplot;
            };
            maindrag.onmouseout = function(evt) {
              if (gd._dragging) return;
              gd._fullLayout._hoversubplot = null;
              dragElement.unhover(gd, evt);
            };
            if (gd._context.showAxisDragHandles) {
              makeDragBox(
                gd,
                plotinfo,
                xa._offset - DRAGGERSIZE,
                ya._offset - DRAGGERSIZE,
                DRAGGERSIZE,
                DRAGGERSIZE,
                "n",
                "w"
              );
              makeDragBox(
                gd,
                plotinfo,
                xa._offset + xa._length,
                ya._offset - DRAGGERSIZE,
                DRAGGERSIZE,
                DRAGGERSIZE,
                "n",
                "e"
              );
              makeDragBox(
                gd,
                plotinfo,
                xa._offset - DRAGGERSIZE,
                ya._offset + ya._length,
                DRAGGERSIZE,
                DRAGGERSIZE,
                "s",
                "w"
              );
              makeDragBox(
                gd,
                plotinfo,
                xa._offset + xa._length,
                ya._offset + ya._length,
                DRAGGERSIZE,
                DRAGGERSIZE,
                "s",
                "e"
              );
            }
          }
          if (gd._context.showAxisDragHandles) {
            if (subplot === xa._mainSubplot) {
              var y0 = xa._mainLinePosition;
              if (xa.side === "top") y0 -= DRAGGERSIZE;
              makeDragBox(
                gd,
                plotinfo,
                xa._offset + xa._length * 0.1,
                y0,
                xa._length * 0.8,
                DRAGGERSIZE,
                "",
                "ew"
              );
              makeDragBox(
                gd,
                plotinfo,
                xa._offset,
                y0,
                xa._length * 0.1,
                DRAGGERSIZE,
                "",
                "w"
              );
              makeDragBox(
                gd,
                plotinfo,
                xa._offset + xa._length * 0.9,
                y0,
                xa._length * 0.1,
                DRAGGERSIZE,
                "",
                "e"
              );
            }
            if (subplot === ya._mainSubplot) {
              var x0 = ya._mainLinePosition;
              if (ya.side !== "right") x0 -= DRAGGERSIZE;
              makeDragBox(
                gd,
                plotinfo,
                x0,
                ya._offset + ya._length * 0.1,
                DRAGGERSIZE,
                ya._length * 0.8,
                "ns",
                ""
              );
              makeDragBox(
                gd,
                plotinfo,
                x0,
                ya._offset + ya._length * 0.9,
                DRAGGERSIZE,
                ya._length * 0.1,
                "s",
                ""
              );
              makeDragBox(
                gd,
                plotinfo,
                x0,
                ya._offset,
                DRAGGERSIZE,
                ya._length * 0.1,
                "n",
                ""
              );
            }
          }
        });
        var hoverLayer = fullLayout._hoverlayer.node();
        hoverLayer.onmousemove = function(evt) {
          evt.target = gd._fullLayout._lasthover;
          Fx.hover(gd, evt, fullLayout._hoversubplot);
        };
        hoverLayer.onclick = function(evt) {
          evt.target = gd._fullLayout._lasthover;
          Fx.click(gd, evt);
        };
        hoverLayer.onmousedown = function(evt) {
          gd._fullLayout._lasthover.onmousedown(evt);
        };
        exports.updateFx(gd);
      };
      exports.updateFx = function(gd) {
        var fullLayout = gd._fullLayout;
        var cursor = fullLayout.dragmode === "pan" ? "move" : "crosshair";
        setCursor(fullLayout._draggers, cursor);
      };
    }
  });

  // src/plot_api/container_array_match.js
  var require_container_array_match = __commonJS({
    "src/plot_api/container_array_match.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      module.exports = function containerArrayMatch(astr) {
        var rootContainers = Registry.layoutArrayContainers;
        var regexpContainers = Registry.layoutArrayRegexes;
        var rootPart = astr.split("[")[0];
        var arrayStr;
        var match;
        for (var i = 0; i < regexpContainers.length; i++) {
          match = astr.match(regexpContainers[i]);
          if (match && match.index === 0) {
            arrayStr = match[0];
            break;
          }
        }
        if (!arrayStr) arrayStr = rootContainers[rootContainers.indexOf(rootPart)];
        if (!arrayStr) return false;
        var tail = astr.substr(arrayStr.length);
        if (!tail) return { array: arrayStr, index: "", property: "" };
        match = tail.match(/^\[(0|[1-9][0-9]*)\](\.(.+))?$/);
        if (!match) return false;
        return { array: arrayStr, index: Number(match[1]), property: match[3] || "" };
      };
    }
  });

  // src/plot_api/manage_arrays.js
  var require_manage_arrays = __commonJS({
    "src/plot_api/manage_arrays.js"(exports) {
      "use strict";
      var isPlainObject = require_is_plain_object();
      var noop = require_noop();
      var Loggers = require_loggers();
      var sorterAsc = require_search().sorterAsc;
      var Registry = require_registry();
      exports.containerArrayMatch = require_container_array_match();
      var isAddVal = exports.isAddVal = function isAddVal2(val) {
        return val === "add" || isPlainObject(val);
      };
      var isRemoveVal = exports.isRemoveVal = function isRemoveVal2(val) {
        return val === null || val === "remove";
      };
      exports.applyContainerArrayChanges = function applyContainerArrayChanges(gd, np, edits, flags, _nestedProperty) {
        var componentType = np.astr;
        var supplyComponentDefaults = Registry.getComponentMethod(componentType, "supplyLayoutDefaults");
        var draw = Registry.getComponentMethod(componentType, "draw");
        var drawOne = Registry.getComponentMethod(componentType, "drawOne");
        var replotLater = flags.replot || flags.recalc || supplyComponentDefaults === noop || draw === noop;
        var layout = gd.layout;
        var fullLayout = gd._fullLayout;
        if (edits[""]) {
          if (Object.keys(edits).length > 1) {
            Loggers.warn(
              "Full array edits are incompatible with other edits",
              componentType
            );
          }
          var fullVal = edits[""][""];
          if (isRemoveVal(fullVal)) np.set(null);
          else if (Array.isArray(fullVal)) np.set(fullVal);
          else {
            Loggers.warn("Unrecognized full array edit value", componentType, fullVal);
            return true;
          }
          if (replotLater) return false;
          supplyComponentDefaults(layout, fullLayout);
          draw(gd);
          return true;
        }
        var componentNums = Object.keys(edits).map(Number).sort(sorterAsc);
        var componentArrayIn = np.get();
        var componentArray = componentArrayIn || [];
        var componentArrayFull = _nestedProperty(fullLayout, componentType).get();
        var deletes = [];
        var firstIndexChange = -1;
        var maxIndex = componentArray.length;
        var i;
        var j;
        var componentNum;
        var objEdits;
        var objKeys;
        var objVal;
        var adding, prefix;
        for (i = 0; i < componentNums.length; i++) {
          componentNum = componentNums[i];
          objEdits = edits[componentNum];
          objKeys = Object.keys(objEdits);
          objVal = objEdits[""], adding = isAddVal(objVal);
          if (componentNum < 0 || componentNum > componentArray.length - (adding ? 0 : 1)) {
            Loggers.warn("index out of range", componentType, componentNum);
            continue;
          }
          if (objVal !== void 0) {
            if (objKeys.length > 1) {
              Loggers.warn(
                "Insertion & removal are incompatible with edits to the same index.",
                componentType,
                componentNum
              );
            }
            if (isRemoveVal(objVal)) {
              deletes.push(componentNum);
            } else if (adding) {
              if (objVal === "add") objVal = {};
              componentArray.splice(componentNum, 0, objVal);
              if (componentArrayFull) componentArrayFull.splice(componentNum, 0, {});
            } else {
              Loggers.warn(
                "Unrecognized full object edit value",
                componentType,
                componentNum,
                objVal
              );
            }
            if (firstIndexChange === -1) firstIndexChange = componentNum;
          } else {
            for (j = 0; j < objKeys.length; j++) {
              prefix = componentType + "[" + componentNum + "].";
              _nestedProperty(componentArray[componentNum], objKeys[j], prefix).set(objEdits[objKeys[j]]);
            }
          }
        }
        for (i = deletes.length - 1; i >= 0; i--) {
          componentArray.splice(deletes[i], 1);
          if (componentArrayFull) componentArrayFull.splice(deletes[i], 1);
        }
        if (!componentArray.length) np.set(null);
        else if (!componentArrayIn) np.set(componentArray);
        if (replotLater) return false;
        supplyComponentDefaults(layout, fullLayout);
        if (drawOne !== noop) {
          var indicesToDraw;
          if (firstIndexChange === -1) {
            indicesToDraw = componentNums;
          } else {
            maxIndex = Math.max(componentArray.length, maxIndex);
            indicesToDraw = [];
            for (i = 0; i < componentNums.length; i++) {
              componentNum = componentNums[i];
              if (componentNum >= firstIndexChange) break;
              indicesToDraw.push(componentNum);
            }
            for (i = firstIndexChange; i < maxIndex; i++) {
              indicesToDraw.push(i);
            }
          }
          for (i = 0; i < indicesToDraw.length; i++) {
            drawOne(gd, indicesToDraw[i]);
          }
        } else draw(gd);
        return true;
      };
    }
  });

  // src/plot_api/helpers.js
  var require_helpers9 = __commonJS({
    "src/plot_api/helpers.js"(exports) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var m4FromQuat = require_fromQuat();
      var Registry = require_registry();
      var Lib = require_lib();
      var Plots = require_plots();
      var AxisIds = require_axis_ids();
      var Color = require_color();
      var cleanId = AxisIds.cleanId;
      var getFromTrace = AxisIds.getFromTrace;
      var traceIs = Registry.traceIs;
      exports.clearPromiseQueue = function(gd) {
        if (Array.isArray(gd._promises) && gd._promises.length > 0) {
          Lib.log("Clearing previous rejected promises from queue.");
        }
        gd._promises = [];
      };
      exports.cleanLayout = function(layout) {
        var i, j;
        if (!layout) layout = {};
        if (layout.xaxis1) {
          if (!layout.xaxis) layout.xaxis = layout.xaxis1;
          delete layout.xaxis1;
        }
        if (layout.yaxis1) {
          if (!layout.yaxis) layout.yaxis = layout.yaxis1;
          delete layout.yaxis1;
        }
        if (layout.scene1) {
          if (!layout.scene) layout.scene = layout.scene1;
          delete layout.scene1;
        }
        var axisAttrRegex = (Plots.subplotsRegistry.cartesian || {}).attrRegex;
        var polarAttrRegex = (Plots.subplotsRegistry.polar || {}).attrRegex;
        var ternaryAttrRegex = (Plots.subplotsRegistry.ternary || {}).attrRegex;
        var sceneAttrRegex = (Plots.subplotsRegistry.gl3d || {}).attrRegex;
        var keys = Object.keys(layout);
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (axisAttrRegex && axisAttrRegex.test(key)) {
            var ax = layout[key];
            if (ax.anchor && ax.anchor !== "free") {
              ax.anchor = cleanId(ax.anchor);
            }
            if (ax.overlaying) ax.overlaying = cleanId(ax.overlaying);
            if (!ax.type) {
              if (ax.isdate) ax.type = "date";
              else if (ax.islog) ax.type = "log";
              else if (ax.isdate === false && ax.islog === false) ax.type = "linear";
            }
            if (ax.autorange === "withzero" || ax.autorange === "tozero") {
              ax.autorange = true;
              ax.rangemode = "tozero";
            }
            if (ax.insiderange) delete ax.range;
            delete ax.islog;
            delete ax.isdate;
            delete ax.categories;
            if (emptyContainer(ax, "domain")) delete ax.domain;
          }
        }
        var annotationsLen = Array.isArray(layout.annotations) ? layout.annotations.length : 0;
        for (i = 0; i < annotationsLen; i++) {
          var ann = layout.annotations[i];
          if (!Lib.isPlainObject(ann)) continue;
          cleanAxRef(ann, "xref");
          cleanAxRef(ann, "yref");
        }
        var shapesLen = Array.isArray(layout.shapes) ? layout.shapes.length : 0;
        for (i = 0; i < shapesLen; i++) {
          var shape = layout.shapes[i];
          if (!Lib.isPlainObject(shape)) continue;
          cleanAxRef(shape, "xref");
          cleanAxRef(shape, "yref");
        }
        var imagesLen = Array.isArray(layout.images) ? layout.images.length : 0;
        for (i = 0; i < imagesLen; i++) {
          var image = layout.images[i];
          if (!Lib.isPlainObject(image)) continue;
          cleanAxRef(image, "xref");
          cleanAxRef(image, "yref");
        }
        var legend = layout.legend;
        if (legend) {
          if (legend.x > 3) {
            legend.x = 1.02;
            legend.xanchor = "left";
          } else if (legend.x < -2) {
            legend.x = -0.02;
            legend.xanchor = "right";
          }
          if (legend.y > 3) {
            legend.y = 1.02;
            legend.yanchor = "bottom";
          } else if (legend.y < -2) {
            legend.y = -0.02;
            legend.yanchor = "top";
          }
        }
        if (layout.dragmode === "rotate") layout.dragmode = "orbit";
        Color.clean(layout);
        if (layout.template && layout.template.layout) {
          exports.cleanLayout(layout.template.layout);
        }
        return layout;
      };
      function cleanAxRef(container, attr) {
        var valIn = container[attr];
        var axLetter = attr.charAt(0);
        if (valIn && valIn !== "paper") {
          container[attr] = cleanId(valIn, axLetter, true);
        }
      }
      exports.cleanData = function(data) {
        for (var tracei = 0; tracei < data.length; tracei++) {
          var trace = data[tracei];
          var i;
          if (trace.type === "histogramy" && "xbins" in trace && !("ybins" in trace)) {
            trace.ybins = trace.xbins;
            delete trace.xbins;
          }
          if (trace.type === "histogramy") exports.swapXYData(trace);
          if (trace.type === "histogramx" || trace.type === "histogramy") {
            trace.type = "histogram";
          }
          if ("scl" in trace && !("colorscale" in trace)) {
            trace.colorscale = trace.scl;
            delete trace.scl;
          }
          if ("reversescl" in trace && !("reversescale" in trace)) {
            trace.reversescale = trace.reversescl;
            delete trace.reversescl;
          }
          if (trace.xaxis) trace.xaxis = cleanId(trace.xaxis, "x");
          if (trace.yaxis) trace.yaxis = cleanId(trace.yaxis, "y");
          if (traceIs(trace, "gl3d") && trace.scene) {
            trace.scene = Plots.subplotsRegistry.gl3d.cleanId(trace.scene);
          }
          if (!traceIs(trace, "pie-like") && !traceIs(trace, "bar-like")) {
            if (Array.isArray(trace.textposition)) {
              for (i = 0; i < trace.textposition.length; i++) {
                trace.textposition[i] = cleanTextPosition(trace.textposition[i]);
              }
            } else if (trace.textposition) {
              trace.textposition = cleanTextPosition(trace.textposition);
            }
          }
          var _module = Registry.getModule(trace);
          if (_module && _module.colorbar) {
            var containerName = _module.colorbar.container;
            var container = containerName ? trace[containerName] : trace;
            if (container && container.colorscale) {
              if (container.colorscale === "YIGnBu") container.colorscale = "YlGnBu";
              if (container.colorscale === "YIOrRd") container.colorscale = "YlOrRd";
            }
          }
          if (trace.type === "surface" && Lib.isPlainObject(trace.contours)) {
            var dims = ["x", "y", "z"];
            for (i = 0; i < dims.length; i++) {
              var opts = trace.contours[dims[i]];
              if (!Lib.isPlainObject(opts)) continue;
              if (opts.highlightColor) {
                opts.highlightcolor = opts.highlightColor;
                delete opts.highlightColor;
              }
              if (opts.highlightWidth) {
                opts.highlightwidth = opts.highlightWidth;
                delete opts.highlightWidth;
              }
            }
          }
          if (trace.type === "candlestick" || trace.type === "ohlc") {
            var increasingShowlegend = (trace.increasing || {}).showlegend !== false;
            var decreasingShowlegend = (trace.decreasing || {}).showlegend !== false;
            var increasingName = cleanFinanceDir(trace.increasing);
            var decreasingName = cleanFinanceDir(trace.decreasing);
            if (increasingName !== false && decreasingName !== false) {
              var newName = commonPrefix(
                increasingName,
                decreasingName,
                increasingShowlegend,
                decreasingShowlegend
              );
              if (newName) trace.name = newName;
            } else if ((increasingName || decreasingName) && !trace.name) {
              trace.name = increasingName || decreasingName;
            }
          }
          if (emptyContainer(trace, "line")) delete trace.line;
          if ("marker" in trace) {
            if (emptyContainer(trace.marker, "line")) delete trace.marker.line;
            if (emptyContainer(trace, "marker")) delete trace.marker;
          }
          Color.clean(trace);
          if (trace.autobinx) {
            delete trace.autobinx;
            delete trace.xbins;
          }
          if (trace.autobiny) {
            delete trace.autobiny;
            delete trace.ybins;
          }
        }
      };
      function cleanFinanceDir(dirContainer) {
        if (!Lib.isPlainObject(dirContainer)) return false;
        var dirName = dirContainer.name;
        delete dirContainer.name;
        delete dirContainer.showlegend;
        return (typeof dirName === "string" || typeof dirName === "number") && String(dirName);
      }
      function commonPrefix(name1, name2, show1, show2) {
        if (show1 && !show2) return name1;
        if (show2 && !show1) return name2;
        if (!name1.trim()) return name2;
        if (!name2.trim()) return name1;
        var minLen = Math.min(name1.length, name2.length);
        var i;
        for (i = 0; i < minLen; i++) {
          if (name1.charAt(i) !== name2.charAt(i)) break;
        }
        var out = name1.substr(0, i);
        return out.trim();
      }
      function cleanTextPosition(textposition) {
        var posY = "middle";
        var posX = "center";
        if (typeof textposition === "string") {
          if (textposition.indexOf("top") !== -1) posY = "top";
          else if (textposition.indexOf("bottom") !== -1) posY = "bottom";
          if (textposition.indexOf("left") !== -1) posX = "left";
          else if (textposition.indexOf("right") !== -1) posX = "right";
        }
        return posY + " " + posX;
      }
      function emptyContainer(outer, innerStr) {
        return innerStr in outer && typeof outer[innerStr] === "object" && Object.keys(outer[innerStr]).length === 0;
      }
      exports.swapXYData = function(trace) {
        var i;
        Lib.swapAttrs(trace, ["?", "?0", "d?", "?bins", "nbins?", "autobin?", "?src", "error_?"]);
        if (Array.isArray(trace.z) && Array.isArray(trace.z[0])) {
          if (trace.transpose) delete trace.transpose;
          else trace.transpose = true;
        }
        if (trace.error_x && trace.error_y) {
          var errorY = trace.error_y;
          var copyYstyle = "copy_ystyle" in errorY ? errorY.copy_ystyle : !(errorY.color || errorY.thickness || errorY.width);
          Lib.swapAttrs(trace, ["error_?.copy_ystyle"]);
          if (copyYstyle) {
            Lib.swapAttrs(trace, ["error_?.color", "error_?.thickness", "error_?.width"]);
          }
        }
        if (typeof trace.hoverinfo === "string") {
          var hoverInfoParts = trace.hoverinfo.split("+");
          for (i = 0; i < hoverInfoParts.length; i++) {
            if (hoverInfoParts[i] === "x") hoverInfoParts[i] = "y";
            else if (hoverInfoParts[i] === "y") hoverInfoParts[i] = "x";
          }
          trace.hoverinfo = hoverInfoParts.join("+");
        }
      };
      exports.coerceTraceIndices = function(gd, traceIndices) {
        if (isNumeric(traceIndices)) {
          return [traceIndices];
        } else if (!Array.isArray(traceIndices) || !traceIndices.length) {
          return gd.data.map(function(_, i2) {
            return i2;
          });
        } else if (Array.isArray(traceIndices)) {
          var traceIndicesOut = [];
          for (var i = 0; i < traceIndices.length; i++) {
            if (Lib.isIndex(traceIndices[i], gd.data.length)) {
              traceIndicesOut.push(traceIndices[i]);
            } else {
              Lib.warn("trace index (", traceIndices[i], ") is not a number or is out of bounds");
            }
          }
          return traceIndicesOut;
        }
        return traceIndices;
      };
      exports.manageArrayContainers = function(np, newVal, undoit) {
        var obj = np.obj;
        var parts = np.parts;
        var pLength = parts.length;
        var pLast = parts[pLength - 1];
        var pLastIsNumber = isNumeric(pLast);
        if (pLastIsNumber && newVal === null) {
          var contPath = parts.slice(0, pLength - 1).join(".");
          var cont = Lib.nestedProperty(obj, contPath).get();
          cont.splice(pLast, 1);
        } else if (pLastIsNumber && np.get() === void 0) {
          if (np.get() === void 0) undoit[np.astr] = null;
          np.set(newVal);
        } else {
          np.set(newVal);
        }
      };
      var ATTR_TAIL_RE = /(\.[^\[\]\.]+|\[[^\[\]\.]+\])$/;
      function getParent(attr) {
        var tail = attr.search(ATTR_TAIL_RE);
        if (tail > 0) return attr.substr(0, tail);
      }
      exports.hasParent = function(aobj, attr) {
        var attrParent = getParent(attr);
        while (attrParent) {
          if (attrParent in aobj) return true;
          attrParent = getParent(attrParent);
        }
        return false;
      };
      var axLetters = ["x", "y", "z"];
      exports.clearAxisTypes = function(gd, traces, layoutUpdate) {
        for (var i = 0; i < traces.length; i++) {
          var trace = gd._fullData[i];
          for (var j = 0; j < 3; j++) {
            var ax = getFromTrace(gd, trace, axLetters[j]);
            if (ax && ax.type !== "log") {
              var axAttr = ax._name;
              var sceneName = ax._id.substr(1);
              if (sceneName.substr(0, 5) === "scene") {
                if (layoutUpdate[sceneName] !== void 0) continue;
                axAttr = sceneName + "." + axAttr;
              }
              var typeAttr = axAttr + ".type";
              if (layoutUpdate[axAttr] === void 0 && layoutUpdate[typeAttr] === void 0) {
                Lib.nestedProperty(gd.layout, typeAttr).set(null);
              }
            }
          }
        }
      };
    }
  });

  // src/plot_api/plot_api.js
  var require_plot_api = __commonJS({
    "src/plot_api/plot_api.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var hasHover = require_has_hover();
      var Lib = require_lib();
      var nestedProperty = Lib.nestedProperty;
      var Events = require_events2();
      var Queue = require_queue();
      var Registry = require_registry();
      var PlotSchema = require_plot_schema();
      var Plots = require_plots();
      var Axes = require_axes();
      var handleRangeDefaults = require_range_defaults();
      var cartesianLayoutAttributes = require_layout_attributes4();
      var Drawing = require_drawing();
      var Color = require_color();
      var initInteractions = require_graph_interact().initInteractions;
      var xmlnsNamespaces = require_xmlns_namespaces();
      var clearOutline = require_selections().clearOutline;
      var dfltConfig = require_plot_config().dfltConfig;
      var manageArrays = require_manage_arrays();
      var helpers = require_helpers9();
      var subroutines = require_subroutines();
      var editTypes = require_edit_types();
      var AX_NAME_PATTERN = require_constants2().AX_NAME_PATTERN;
      var numericNameWarningCount = 0;
      var numericNameWarningCountLimit = 5;
      function _doPlot(gd, data, layout, config) {
        var frames;
        gd = Lib.getGraphDiv(gd);
        Events.init(gd);
        if (Lib.isPlainObject(data)) {
          var obj = data;
          data = obj.data;
          layout = obj.layout;
          config = obj.config;
          frames = obj.frames;
        }
        var okToPlot = Events.triggerHandler(gd, "plotly_beforeplot", [data, layout, config]);
        if (okToPlot === false) return Promise.reject();
        if (!data && !layout && !Lib.isPlotDiv(gd)) {
          Lib.warn("Calling _doPlot as if redrawing but this container doesn't yet have a plot.", gd);
        }
        function addFrames2() {
          if (frames) {
            return exports.addFrames(gd, frames);
          }
        }
        setPlotContext(gd, config);
        if (!layout) layout = {};
        d3.select(gd).classed("js-plotly-plot", true);
        Drawing.makeTester();
        if (!Array.isArray(gd._promises)) gd._promises = [];
        var graphWasEmpty = (gd.data || []).length === 0 && Array.isArray(data);
        if (Array.isArray(data)) {
          helpers.cleanData(data);
          if (graphWasEmpty) gd.data = data;
          else gd.data.push.apply(gd.data, data);
          gd.empty = false;
        }
        if (!gd.layout || graphWasEmpty) {
          gd.layout = helpers.cleanLayout(layout);
        }
        Plots.supplyDefaults(gd);
        var fullLayout = gd._fullLayout;
        var hasCartesian = fullLayout._has("cartesian");
        fullLayout._replotting = true;
        if (graphWasEmpty || fullLayout._shouldCreateBgLayer) {
          makePlotFramework(gd);
          if (fullLayout._shouldCreateBgLayer) {
            delete fullLayout._shouldCreateBgLayer;
          }
        }
        Drawing.initGradients(gd);
        Drawing.initPatterns(gd);
        if (graphWasEmpty) Axes.saveShowSpikeInitial(gd);
        var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;
        if (recalc) Plots.doCalcdata(gd);
        for (var i = 0; i < gd.calcdata.length; i++) {
          gd.calcdata[i][0].trace = gd._fullData[i];
        }
        if (gd._context.responsive) {
          if (!gd._responsiveChartHandler) {
            gd._responsiveChartHandler = function() {
              if (!Lib.isHidden(gd)) Plots.resize(gd);
            };
            window.addEventListener("resize", gd._responsiveChartHandler);
          }
        } else {
          Lib.clearResponsive(gd);
        }
        var oldMargins = Lib.extendFlat({}, fullLayout._size);
        var drawFrameworkCalls = 0;
        function drawFramework() {
          var basePlotModules = fullLayout._basePlotModules;
          for (var i2 = 0; i2 < basePlotModules.length; i2++) {
            if (basePlotModules[i2].drawFramework) {
              basePlotModules[i2].drawFramework(gd);
            }
          }
          if (!fullLayout._glcanvas && fullLayout._has("gl")) {
            fullLayout._glcanvas = fullLayout._glcontainer.selectAll(".gl-canvas").data([{
              key: "contextLayer",
              context: true,
              pick: false
            }, {
              key: "focusLayer",
              context: false,
              pick: false
            }, {
              key: "pickLayer",
              context: false,
              pick: true
            }], function(d) {
              return d.key;
            });
            fullLayout._glcanvas.enter().append("canvas").attr("class", function(d) {
              return "gl-canvas gl-canvas-" + d.key.replace("Layer", "");
            }).style({
              position: "absolute",
              top: 0,
              left: 0,
              overflow: "visible",
              "pointer-events": "none"
            });
          }
          var plotGlPixelRatio = gd._context.plotGlPixelRatio;
          if (fullLayout._glcanvas) {
            fullLayout._glcanvas.attr("width", fullLayout.width * plotGlPixelRatio).attr("height", fullLayout.height * plotGlPixelRatio).style("width", fullLayout.width + "px").style("height", fullLayout.height + "px");
            var regl = fullLayout._glcanvas.data()[0].regl;
            if (regl) {
              if (Math.floor(fullLayout.width * plotGlPixelRatio) !== regl._gl.drawingBufferWidth || Math.floor(fullLayout.height * plotGlPixelRatio) !== regl._gl.drawingBufferHeight) {
                var msg = "WebGL context buffer and canvas dimensions do not match due to browser/WebGL bug.";
                if (drawFrameworkCalls) {
                  Lib.error(msg);
                } else {
                  Lib.log(msg + " Clearing graph and plotting again.");
                  Plots.cleanPlot([], {}, gd._fullData, fullLayout);
                  Plots.supplyDefaults(gd);
                  fullLayout = gd._fullLayout;
                  Plots.doCalcdata(gd);
                  drawFrameworkCalls++;
                  return drawFramework();
                }
              }
            }
          }
          if (fullLayout.modebar.orientation === "h") {
            fullLayout._modebardiv.style("height", null).style("width", "100%");
          } else {
            fullLayout._modebardiv.style("width", null).style("height", fullLayout.height + "px");
          }
          return Plots.previousPromises(gd);
        }
        function marginPushers() {
          Plots.clearAutoMarginIds(gd);
          subroutines.drawMarginPushers(gd);
          Axes.allowAutoMargin(gd);
          if (gd._fullLayout.title.text && gd._fullLayout.title.automargin) Plots.allowAutoMargin(gd, "title.automargin");
          if (fullLayout._has("pie")) {
            var fullData = gd._fullData;
            for (var i2 = 0; i2 < fullData.length; i2++) {
              var trace = fullData[i2];
              if (trace.type === "pie" && trace.automargin) {
                Plots.allowAutoMargin(gd, "pie." + trace.uid + ".automargin");
              }
            }
          }
          Plots.doAutoMargin(gd);
          return Plots.previousPromises(gd);
        }
        function marginPushersAgain() {
          if (!Plots.didMarginChange(oldMargins, fullLayout._size)) return;
          return Lib.syncOrAsync([
            marginPushers,
            subroutines.layoutStyles
          ], gd);
        }
        function positionAndAutorange() {
          if (!recalc) {
            doAutoRangeAndConstraints();
            return;
          }
          return Lib.syncOrAsync([
            Registry.getComponentMethod("shapes", "calcAutorange"),
            Registry.getComponentMethod("annotations", "calcAutorange"),
            doAutoRangeAndConstraints
          ], gd);
        }
        function doAutoRangeAndConstraints() {
          if (gd._transitioning) return;
          subroutines.doAutoRangeAndConstraints(gd);
          if (graphWasEmpty) Axes.saveRangeInitial(gd);
          Registry.getComponentMethod("rangeslider", "calcAutorange")(gd);
        }
        function drawAxes() {
          return Axes.draw(gd, graphWasEmpty ? "" : "redraw");
        }
        var seq = [
          Plots.previousPromises,
          addFrames2,
          drawFramework,
          marginPushers,
          marginPushersAgain
        ];
        if (hasCartesian) seq.push(positionAndAutorange);
        seq.push(subroutines.layoutStyles);
        if (hasCartesian) {
          seq.push(
            drawAxes,
            function insideTickLabelsAutorange(gd2) {
              var insideTickLabelsUpdaterange = gd2._fullLayout._insideTickLabelsUpdaterange;
              if (insideTickLabelsUpdaterange) {
                gd2._fullLayout._insideTickLabelsUpdaterange = void 0;
                return relayout(gd2, insideTickLabelsUpdaterange).then(function() {
                  Axes.saveRangeInitial(gd2, true);
                });
              }
            }
          );
        }
        seq.push(
          subroutines.drawData,
          subroutines.finalDraw,
          initInteractions,
          Plots.addLinks,
          Plots.rehover,
          Plots.redrag,
          Plots.reselect,
          // TODO: doAutoMargin is only needed here for axis automargin, which
          // happens outside of marginPushers where all the other automargins are
          // calculated. Would be much better to separate margin calculations from
          // component drawing - see https://github.com/plotly/plotly.js/issues/2704
          Plots.doAutoMargin,
          Plots.previousPromises
        );
        var plotDone = Lib.syncOrAsync(seq, gd);
        if (!plotDone || !plotDone.then) plotDone = Promise.resolve();
        return plotDone.then(function() {
          emitAfterPlot(gd);
          return gd;
        });
      }
      function emitAfterPlot(gd) {
        var fullLayout = gd._fullLayout;
        if (fullLayout._redrawFromAutoMarginCount) {
          fullLayout._redrawFromAutoMarginCount--;
        } else {
          gd.emit("plotly_afterplot");
        }
      }
      function setPlotConfig(obj) {
        return Lib.extendFlat(dfltConfig, obj);
      }
      function setBackground(gd, bgColor) {
        try {
          gd._fullLayout._paper.style("background", bgColor);
        } catch (e) {
          Lib.error(e);
        }
      }
      function opaqueSetBackground(gd, bgColor) {
        var blend = Color.combine(bgColor, "white");
        setBackground(gd, blend);
      }
      function setPlotContext(gd, config) {
        if (!gd._context) {
          gd._context = Lib.extendDeep({}, dfltConfig);
          var base = d3.select("base");
          gd._context._baseUrl = base.size() && base.attr("href") ? window.location.href.split("#")[0] : "";
        }
        var context = gd._context;
        var i, keys, key;
        if (config) {
          keys = Object.keys(config);
          for (i = 0; i < keys.length; i++) {
            key = keys[i];
            if (key === "editable" || key === "edits") continue;
            if (key in context) {
              if (key === "setBackground" && config[key] === "opaque") {
                context[key] = opaqueSetBackground;
              } else {
                context[key] = config[key];
              }
            }
          }
          var editable = config.editable;
          if (editable !== void 0) {
            context.editable = editable;
            keys = Object.keys(context.edits);
            for (i = 0; i < keys.length; i++) {
              context.edits[keys[i]] = editable;
            }
          }
          if (config.edits) {
            keys = Object.keys(config.edits);
            for (i = 0; i < keys.length; i++) {
              key = keys[i];
              if (key in context.edits) {
                context.edits[key] = config.edits[key];
              }
            }
          }
          context._exportedPlot = config._exportedPlot;
        }
        if (context.staticPlot) {
          context.editable = false;
          context.edits = {};
          context.autosizable = false;
          context.scrollZoom = false;
          context.doubleClick = false;
          context.showTips = false;
          context.showLink = false;
          context.displayModeBar = false;
        }
        if (context.displayModeBar === "hover" && !hasHover) {
          context.displayModeBar = true;
        }
        if (context.setBackground === "transparent" || typeof context.setBackground !== "function") {
          context.setBackground = setBackground;
        }
        context._hasZeroHeight = context._hasZeroHeight || gd.clientHeight === 0;
        context._hasZeroWidth = context._hasZeroWidth || gd.clientWidth === 0;
        var szIn = context.scrollZoom;
        var szOut = context._scrollZoom = {};
        if (szIn === true) {
          szOut.cartesian = 1;
          szOut.gl3d = 1;
          szOut.geo = 1;
          szOut.mapbox = 1;
          szOut.map = 1;
        } else if (typeof szIn === "string") {
          var parts = szIn.split("+");
          for (i = 0; i < parts.length; i++) {
            szOut[parts[i]] = 1;
          }
        } else if (szIn !== false) {
          szOut.gl3d = 1;
          szOut.geo = 1;
          szOut.mapbox = 1;
          szOut.map = 1;
        }
      }
      function redraw(gd) {
        gd = Lib.getGraphDiv(gd);
        if (!Lib.isPlotDiv(gd)) {
          throw new Error("This element is not a Plotly plot: " + gd);
        }
        helpers.cleanData(gd.data);
        helpers.cleanLayout(gd.layout);
        gd.calcdata = void 0;
        return exports._doPlot(gd).then(function() {
          gd.emit("plotly_redraw");
          return gd;
        });
      }
      function newPlot(gd, data, layout, config) {
        gd = Lib.getGraphDiv(gd);
        Plots.cleanPlot([], {}, gd._fullData || [], gd._fullLayout || {});
        Plots.purge(gd);
        return exports._doPlot(gd, data, layout, config);
      }
      function positivifyIndices(indices, maxIndex) {
        var parentLength = maxIndex + 1;
        var positiveIndices = [];
        var i;
        var index;
        for (i = 0; i < indices.length; i++) {
          index = indices[i];
          if (index < 0) {
            positiveIndices.push(parentLength + index);
          } else {
            positiveIndices.push(index);
          }
        }
        return positiveIndices;
      }
      function assertIndexArray(gd, indices, arrayName) {
        var i, index;
        for (i = 0; i < indices.length; i++) {
          index = indices[i];
          if (index !== parseInt(index, 10)) {
            throw new Error("all values in " + arrayName + " must be integers");
          }
          if (index >= gd.data.length || index < -gd.data.length) {
            throw new Error(arrayName + " must be valid indices for gd.data.");
          }
          if (indices.indexOf(index, i + 1) > -1 || index >= 0 && indices.indexOf(-gd.data.length + index) > -1 || index < 0 && indices.indexOf(gd.data.length + index) > -1) {
            throw new Error("each index in " + arrayName + " must be unique.");
          }
        }
      }
      function checkMoveTracesArgs(gd, currentIndices, newIndices) {
        if (!Array.isArray(gd.data)) {
          throw new Error("gd.data must be an array.");
        }
        if (typeof currentIndices === "undefined") {
          throw new Error("currentIndices is a required argument.");
        } else if (!Array.isArray(currentIndices)) {
          currentIndices = [currentIndices];
        }
        assertIndexArray(gd, currentIndices, "currentIndices");
        if (typeof newIndices !== "undefined" && !Array.isArray(newIndices)) {
          newIndices = [newIndices];
        }
        if (typeof newIndices !== "undefined") {
          assertIndexArray(gd, newIndices, "newIndices");
        }
        if (typeof newIndices !== "undefined" && currentIndices.length !== newIndices.length) {
          throw new Error("current and new indices must be of equal length.");
        }
      }
      function checkAddTracesArgs(gd, traces, newIndices) {
        var i, value;
        if (!Array.isArray(gd.data)) {
          throw new Error("gd.data must be an array.");
        }
        if (typeof traces === "undefined") {
          throw new Error("traces must be defined.");
        }
        if (!Array.isArray(traces)) {
          traces = [traces];
        }
        for (i = 0; i < traces.length; i++) {
          value = traces[i];
          if (typeof value !== "object" || (Array.isArray(value) || value === null)) {
            throw new Error("all values in traces array must be non-array objects");
          }
        }
        if (typeof newIndices !== "undefined" && !Array.isArray(newIndices)) {
          newIndices = [newIndices];
        }
        if (typeof newIndices !== "undefined" && newIndices.length !== traces.length) {
          throw new Error(
            "if indices is specified, traces.length must equal indices.length"
          );
        }
      }
      function assertExtendTracesArgs(gd, update2, indices, maxPoints) {
        var maxPointsIsObject = Lib.isPlainObject(maxPoints);
        if (!Array.isArray(gd.data)) {
          throw new Error("gd.data must be an array");
        }
        if (!Lib.isPlainObject(update2)) {
          throw new Error("update must be a key:value object");
        }
        if (typeof indices === "undefined") {
          throw new Error("indices must be an integer or array of integers");
        }
        assertIndexArray(gd, indices, "indices");
        for (var key in update2) {
          if (!Array.isArray(update2[key]) || update2[key].length !== indices.length) {
            throw new Error("attribute " + key + " must be an array of length equal to indices array length");
          }
          if (maxPointsIsObject && (!(key in maxPoints) || !Array.isArray(maxPoints[key]) || maxPoints[key].length !== update2[key].length)) {
            throw new Error("when maxPoints is set as a key:value object it must contain a 1:1 corrispondence with the keys and number of traces in the update object");
          }
        }
      }
      function getExtendProperties(gd, update2, indices, maxPoints) {
        var maxPointsIsObject = Lib.isPlainObject(maxPoints);
        var updateProps = [];
        var trace, target, prop, insert, maxp;
        if (!Array.isArray(indices)) indices = [indices];
        indices = positivifyIndices(indices, gd.data.length - 1);
        for (var key in update2) {
          for (var j = 0; j < indices.length; j++) {
            trace = gd.data[indices[j]];
            prop = nestedProperty(trace, key);
            target = prop.get();
            insert = update2[key][j];
            if (!Lib.isArrayOrTypedArray(insert)) {
              throw new Error("attribute: " + key + " index: " + j + " must be an array");
            }
            if (!Lib.isArrayOrTypedArray(target)) {
              throw new Error("cannot extend missing or non-array attribute: " + key);
            }
            if (target.constructor !== insert.constructor) {
              throw new Error("cannot extend array with an array of a different type: " + key);
            }
            maxp = maxPointsIsObject ? maxPoints[key][j] : maxPoints;
            if (!isNumeric(maxp)) maxp = -1;
            updateProps.push({
              prop,
              target,
              insert,
              maxp: Math.floor(maxp)
            });
          }
        }
        return updateProps;
      }
      function spliceTraces(gd, update2, indices, maxPoints, updateArray) {
        assertExtendTracesArgs(gd, update2, indices, maxPoints);
        var updateProps = getExtendProperties(gd, update2, indices, maxPoints);
        var undoUpdate = {};
        var undoPoints = {};
        for (var i = 0; i < updateProps.length; i++) {
          var prop = updateProps[i].prop;
          var maxp = updateProps[i].maxp;
          var out = updateArray(updateProps[i].target, updateProps[i].insert, maxp);
          prop.set(out[0]);
          if (!Array.isArray(undoUpdate[prop.astr])) undoUpdate[prop.astr] = [];
          undoUpdate[prop.astr].push(out[1]);
          if (!Array.isArray(undoPoints[prop.astr])) undoPoints[prop.astr] = [];
          undoPoints[prop.astr].push(updateProps[i].target.length);
        }
        return { update: undoUpdate, maxPoints: undoPoints };
      }
      function concatTypedArray(arr0, arr1) {
        var arr2 = new arr0.constructor(arr0.length + arr1.length);
        arr2.set(arr0);
        arr2.set(arr1, arr0.length);
        return arr2;
      }
      function extendTraces(gd, update2, indices, maxPoints) {
        gd = Lib.getGraphDiv(gd);
        function updateArray(target, insert, maxp) {
          var newArray, remainder;
          if (Lib.isTypedArray(target)) {
            if (maxp < 0) {
              var none = new target.constructor(0);
              var both = concatTypedArray(target, insert);
              if (maxp < 0) {
                newArray = both;
                remainder = none;
              } else {
                newArray = none;
                remainder = both;
              }
            } else {
              newArray = new target.constructor(maxp);
              remainder = new target.constructor(target.length + insert.length - maxp);
              if (maxp === insert.length) {
                newArray.set(insert);
                remainder.set(target);
              } else if (maxp < insert.length) {
                var numberOfItemsFromInsert = insert.length - maxp;
                newArray.set(insert.subarray(numberOfItemsFromInsert));
                remainder.set(target);
                remainder.set(insert.subarray(0, numberOfItemsFromInsert), target.length);
              } else {
                var numberOfItemsFromTarget = maxp - insert.length;
                var targetBegin = target.length - numberOfItemsFromTarget;
                newArray.set(target.subarray(targetBegin));
                newArray.set(insert, numberOfItemsFromTarget);
                remainder.set(target.subarray(0, targetBegin));
              }
            }
          } else {
            newArray = target.concat(insert);
            remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(0, newArray.length - maxp) : [];
          }
          return [newArray, remainder];
        }
        var undo = spliceTraces(gd, update2, indices, maxPoints, updateArray);
        var promise = exports.redraw(gd);
        var undoArgs = [gd, undo.update, indices, undo.maxPoints];
        Queue.add(gd, exports.prependTraces, undoArgs, extendTraces, arguments);
        return promise;
      }
      function prependTraces(gd, update2, indices, maxPoints) {
        gd = Lib.getGraphDiv(gd);
        function updateArray(target, insert, maxp) {
          var newArray, remainder;
          if (Lib.isTypedArray(target)) {
            if (maxp <= 0) {
              var none = new target.constructor(0);
              var both = concatTypedArray(insert, target);
              if (maxp < 0) {
                newArray = both;
                remainder = none;
              } else {
                newArray = none;
                remainder = both;
              }
            } else {
              newArray = new target.constructor(maxp);
              remainder = new target.constructor(target.length + insert.length - maxp);
              if (maxp === insert.length) {
                newArray.set(insert);
                remainder.set(target);
              } else if (maxp < insert.length) {
                var numberOfItemsFromInsert = insert.length - maxp;
                newArray.set(insert.subarray(0, numberOfItemsFromInsert));
                remainder.set(insert.subarray(numberOfItemsFromInsert));
                remainder.set(target, numberOfItemsFromInsert);
              } else {
                var numberOfItemsFromTarget = maxp - insert.length;
                newArray.set(insert);
                newArray.set(target.subarray(0, numberOfItemsFromTarget), insert.length);
                remainder.set(target.subarray(numberOfItemsFromTarget));
              }
            }
          } else {
            newArray = insert.concat(target);
            remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(maxp, newArray.length) : [];
          }
          return [newArray, remainder];
        }
        var undo = spliceTraces(gd, update2, indices, maxPoints, updateArray);
        var promise = exports.redraw(gd);
        var undoArgs = [gd, undo.update, indices, undo.maxPoints];
        Queue.add(gd, exports.extendTraces, undoArgs, prependTraces, arguments);
        return promise;
      }
      function addTraces(gd, traces, newIndices) {
        gd = Lib.getGraphDiv(gd);
        var currentIndices = [];
        var undoFunc = exports.deleteTraces;
        var redoFunc = addTraces;
        var undoArgs = [gd, currentIndices];
        var redoArgs = [gd, traces];
        var i;
        var promise;
        checkAddTracesArgs(gd, traces, newIndices);
        if (!Array.isArray(traces)) {
          traces = [traces];
        }
        traces = traces.map(function(trace) {
          return Lib.extendFlat({}, trace);
        });
        helpers.cleanData(traces);
        for (i = 0; i < traces.length; i++) {
          gd.data.push(traces[i]);
        }
        for (i = 0; i < traces.length; i++) {
          currentIndices.push(-traces.length + i);
        }
        if (typeof newIndices === "undefined") {
          promise = exports.redraw(gd);
          Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
          return promise;
        }
        if (!Array.isArray(newIndices)) {
          newIndices = [newIndices];
        }
        try {
          checkMoveTracesArgs(gd, currentIndices, newIndices);
        } catch (error) {
          gd.data.splice(gd.data.length - traces.length, traces.length);
          throw error;
        }
        Queue.startSequence(gd);
        Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
        promise = exports.moveTraces(gd, currentIndices, newIndices);
        Queue.stopSequence(gd);
        return promise;
      }
      function deleteTraces(gd, indices) {
        gd = Lib.getGraphDiv(gd);
        var traces = [];
        var undoFunc = exports.addTraces;
        var redoFunc = deleteTraces;
        var undoArgs = [gd, traces, indices];
        var redoArgs = [gd, indices];
        var i;
        var deletedTrace;
        if (typeof indices === "undefined") {
          throw new Error("indices must be an integer or array of integers.");
        } else if (!Array.isArray(indices)) {
          indices = [indices];
        }
        assertIndexArray(gd, indices, "indices");
        indices = positivifyIndices(indices, gd.data.length - 1);
        indices.sort(Lib.sorterDes);
        for (i = 0; i < indices.length; i += 1) {
          deletedTrace = gd.data.splice(indices[i], 1)[0];
          traces.push(deletedTrace);
        }
        var promise = exports.redraw(gd);
        Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
        return promise;
      }
      function moveTraces(gd, currentIndices, newIndices) {
        gd = Lib.getGraphDiv(gd);
        var newData = [];
        var movingTraceMap = [];
        var undoFunc = moveTraces;
        var redoFunc = moveTraces;
        var undoArgs = [gd, newIndices, currentIndices];
        var redoArgs = [gd, currentIndices, newIndices];
        var i;
        checkMoveTracesArgs(gd, currentIndices, newIndices);
        currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices];
        if (typeof newIndices === "undefined") {
          newIndices = [];
          for (i = 0; i < currentIndices.length; i++) {
            newIndices.push(-currentIndices.length + i);
          }
        }
        newIndices = Array.isArray(newIndices) ? newIndices : [newIndices];
        currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);
        newIndices = positivifyIndices(newIndices, gd.data.length - 1);
        for (i = 0; i < gd.data.length; i++) {
          if (currentIndices.indexOf(i) === -1) {
            newData.push(gd.data[i]);
          }
        }
        for (i = 0; i < currentIndices.length; i++) {
          movingTraceMap.push({ newIndex: newIndices[i], trace: gd.data[currentIndices[i]] });
        }
        movingTraceMap.sort(function(a, b) {
          return a.newIndex - b.newIndex;
        });
        for (i = 0; i < movingTraceMap.length; i += 1) {
          newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);
        }
        gd.data = newData;
        var promise = exports.redraw(gd);
        Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
        return promise;
      }
      function restyle(gd, astr, val, _traces) {
        gd = Lib.getGraphDiv(gd);
        helpers.clearPromiseQueue(gd);
        var aobj = {};
        if (typeof astr === "string") aobj[astr] = val;
        else if (Lib.isPlainObject(astr)) {
          aobj = Lib.extendFlat({}, astr);
          if (_traces === void 0) _traces = val;
        } else {
          Lib.warn("Restyle fail.", astr, val, _traces);
          return Promise.reject();
        }
        if (Object.keys(aobj).length) gd.changed = true;
        var traces = helpers.coerceTraceIndices(gd, _traces);
        var specs = _restyle(gd, aobj, traces);
        var flags = specs.flags;
        if (flags.calc) gd.calcdata = void 0;
        if (flags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, {});
        var seq = [];
        if (flags.fullReplot) {
          seq.push(exports._doPlot);
        } else {
          seq.push(Plots.previousPromises);
          Plots.supplyDefaults(gd);
          if (flags.markerSize) {
            Plots.doCalcdata(gd);
            addAxRangeSequence(seq);
          }
          if (flags.style) seq.push(subroutines.doTraceStyle);
          if (flags.colorbars) seq.push(subroutines.doColorBars);
          seq.push(emitAfterPlot);
        }
        seq.push(
          Plots.rehover,
          Plots.redrag,
          Plots.reselect
        );
        Queue.add(
          gd,
          restyle,
          [gd, specs.undoit, specs.traces],
          restyle,
          [gd, specs.redoit, specs.traces]
        );
        var plotDone = Lib.syncOrAsync(seq, gd);
        if (!plotDone || !plotDone.then) plotDone = Promise.resolve();
        return plotDone.then(function() {
          gd.emit("plotly_restyle", specs.eventData);
          return gd;
        });
      }
      function undefinedToNull(val) {
        if (val === void 0) return null;
        return val;
      }
      function makeNP(preGUI, guiEditFlag) {
        if (!guiEditFlag) return nestedProperty;
        return function(container, attr, prefix) {
          var np = nestedProperty(container, attr);
          var npSet = np.set;
          np.set = function(val) {
            var fullAttr = (prefix || "") + attr;
            storeCurrent(fullAttr, np.get(), val, preGUI);
            npSet(val);
          };
          return np;
        };
      }
      function storeCurrent(attr, val, newVal, preGUI) {
        if (Array.isArray(val) || Array.isArray(newVal)) {
          var arrayVal = Array.isArray(val) ? val : [];
          var arrayNew = Array.isArray(newVal) ? newVal : [];
          var maxLen = Math.max(arrayVal.length, arrayNew.length);
          for (var i = 0; i < maxLen; i++) {
            storeCurrent(attr + "[" + i + "]", arrayVal[i], arrayNew[i], preGUI);
          }
        } else if (Lib.isPlainObject(val) || Lib.isPlainObject(newVal)) {
          var objVal = Lib.isPlainObject(val) ? val : {};
          var objNew = Lib.isPlainObject(newVal) ? newVal : {};
          var objBoth = Lib.extendFlat({}, objVal, objNew);
          for (var key in objBoth) {
            storeCurrent(attr + "." + key, objVal[key], objNew[key], preGUI);
          }
        } else if (preGUI[attr] === void 0) {
          preGUI[attr] = undefinedToNull(val);
        }
      }
      function _storeDirectGUIEdit(container, preGUI, edits) {
        for (var attr in edits) {
          var np = nestedProperty(container, attr);
          storeCurrent(attr, np.get(), edits[attr], preGUI);
        }
      }
      function _restyle(gd, aobj, traces) {
        var fullLayout = gd._fullLayout;
        var fullData = gd._fullData;
        var data = gd.data;
        var guiEditFlag = fullLayout._guiEditing;
        var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);
        var eventData = Lib.extendDeepAll({}, aobj);
        var i;
        var flags = editTypes.traceFlags();
        var redoit = {};
        var undoit = {};
        var axlist;
        function a0() {
          return traces.map(function() {
            return void 0;
          });
        }
        function addToAxlist(axid) {
          var axName = Axes.id2name(axid);
          if (axlist.indexOf(axName) === -1) axlist.push(axName);
        }
        function autorangeAttr(axName) {
          return "LAYOUT" + axName + ".autorange";
        }
        function rangeAttr(axName) {
          return "LAYOUT" + axName + ".range";
        }
        function getFullTrace(traceIndex) {
          for (var j = traceIndex; j < fullData.length; j++) {
            if (fullData[j]._input === data[traceIndex]) return fullData[j];
          }
        }
        function doextra(attr, val, i2) {
          if (Array.isArray(attr)) {
            attr.forEach(function(a) {
              doextra(a, val, i2);
            });
            return;
          }
          if (attr in aobj || helpers.hasParent(aobj, attr)) return;
          var extraparam;
          if (attr.substr(0, 6) === "LAYOUT") {
            extraparam = layoutNP(gd.layout, attr.replace("LAYOUT", ""));
          } else {
            var tracei = traces[i2];
            var preGUI2 = fullLayout._tracePreGUI[getFullTrace(tracei)._fullInput.uid];
            extraparam = makeNP(preGUI2, guiEditFlag)(data[tracei], attr);
          }
          if (!(attr in undoit)) {
            undoit[attr] = a0();
          }
          if (undoit[attr][i2] === void 0) {
            undoit[attr][i2] = undefinedToNull(extraparam.get());
          }
          if (val !== void 0) {
            extraparam.set(val);
          }
        }
        function allBins(binAttr) {
          return function(j) {
            return fullData[j][binAttr];
          };
        }
        function arrayBins(binAttr) {
          return function(vij, j) {
            return vij === false ? fullData[traces[j]][binAttr] : null;
          };
        }
        for (var ai in aobj) {
          if (helpers.hasParent(aobj, ai)) {
            throw new Error("cannot set " + ai + " and a parent attribute simultaneously");
          }
          var vi = aobj[ai];
          var cont;
          var contFull;
          var param;
          var oldVal;
          var newVal;
          var valObject;
          if (ai === "autobinx" || ai === "autobiny") {
            ai = ai.charAt(ai.length - 1) + "bins";
            if (Array.isArray(vi)) vi = vi.map(arrayBins(ai));
            else if (vi === false) vi = traces.map(allBins(ai));
            else vi = null;
          }
          redoit[ai] = vi;
          if (ai.substr(0, 6) === "LAYOUT") {
            param = layoutNP(gd.layout, ai.replace("LAYOUT", ""));
            undoit[ai] = [undefinedToNull(param.get())];
            param.set(Array.isArray(vi) ? vi[0] : vi);
            flags.calc = true;
            continue;
          }
          undoit[ai] = a0();
          for (i = 0; i < traces.length; i++) {
            cont = data[traces[i]];
            contFull = getFullTrace(traces[i]);
            var preGUI = fullLayout._tracePreGUI[contFull._fullInput.uid];
            param = makeNP(preGUI, guiEditFlag)(cont, ai);
            oldVal = param.get();
            newVal = Array.isArray(vi) ? vi[i % vi.length] : vi;
            if (newVal === void 0) continue;
            var finalPart = param.parts[param.parts.length - 1];
            var prefix = ai.substr(0, ai.length - finalPart.length - 1);
            var prefixDot = prefix ? prefix + "." : "";
            var innerContFull = prefix ? nestedProperty(contFull, prefix).get() : contFull;
            valObject = PlotSchema.getTraceValObject(contFull, param.parts);
            if (valObject && valObject.impliedEdits && newVal !== null) {
              for (var impliedKey in valObject.impliedEdits) {
                doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey], i);
              }
            } else if ((finalPart === "thicknessmode" || finalPart === "lenmode") && oldVal !== newVal && (newVal === "fraction" || newVal === "pixels") && innerContFull) {
              var gs = fullLayout._size;
              var orient = innerContFull.orient;
              var topOrBottom = orient === "top" || orient === "bottom";
              if (finalPart === "thicknessmode") {
                var thicknorm = topOrBottom ? gs.h : gs.w;
                doextra(prefixDot + "thickness", innerContFull.thickness * (newVal === "fraction" ? 1 / thicknorm : thicknorm), i);
              } else {
                var lennorm = topOrBottom ? gs.w : gs.h;
                doextra(prefixDot + "len", innerContFull.len * (newVal === "fraction" ? 1 / lennorm : lennorm), i);
              }
            } else if (ai === "type" && (newVal === "pie" !== (oldVal === "pie") || newVal === "funnelarea" !== (oldVal === "funnelarea"))) {
              var labelsTo = "x";
              var valuesTo = "y";
              if ((newVal === "bar" || oldVal === "bar") && cont.orientation === "h") {
                labelsTo = "y";
                valuesTo = "x";
              }
              Lib.swapAttrs(cont, ["?", "?src"], "labels", labelsTo);
              Lib.swapAttrs(cont, ["d?", "?0"], "label", labelsTo);
              Lib.swapAttrs(cont, ["?", "?src"], "values", valuesTo);
              if (oldVal === "pie" || oldVal === "funnelarea") {
                nestedProperty(cont, "marker.color").set(nestedProperty(cont, "marker.colors").get());
                fullLayout._pielayer.selectAll("g.trace").remove();
              } else if (Registry.traceIs(cont, "cartesian")) {
                nestedProperty(cont, "marker.colors").set(nestedProperty(cont, "marker.color").get());
              }
            }
            undoit[ai][i] = undefinedToNull(oldVal);
            var swapAttrs = [
              "swapxy",
              "swapxyaxes",
              "orientation",
              "orientationaxes"
            ];
            if (swapAttrs.indexOf(ai) !== -1) {
              if (ai === "orientation") {
                param.set(newVal);
                var defaultOrientation = cont.x && !cont.y ? "h" : "v";
                if ((param.get() || defaultOrientation) === contFull.orientation) {
                  continue;
                }
              } else if (ai === "orientationaxes") {
                cont.orientation = { v: "h", h: "v" }[contFull.orientation];
              }
              helpers.swapXYData(cont);
              flags.calc = flags.clearAxisTypes = true;
            } else if (Plots.dataArrayContainers.indexOf(param.parts[0]) !== -1) {
              helpers.manageArrayContainers(param, newVal, undoit);
              flags.calc = true;
            } else {
              if (valObject) {
                if (valObject.arrayOk && !Registry.traceIs(contFull, "regl") && (Lib.isArrayOrTypedArray(newVal) || Lib.isArrayOrTypedArray(oldVal))) {
                  flags.calc = true;
                } else editTypes.update(flags, valObject);
              } else {
                flags.calc = true;
              }
              param.set(newVal);
            }
          }
          if (["swapxyaxes", "orientationaxes"].indexOf(ai) !== -1) {
            Axes.swap(gd, traces);
          }
          if (ai === "orientationaxes") {
            var hovermode = nestedProperty(gd.layout, "hovermode");
            var h = hovermode.get();
            if (h === "x") {
              hovermode.set("y");
            } else if (h === "y") {
              hovermode.set("x");
            } else if (h === "x unified") {
              hovermode.set("y unified");
            } else if (h === "y unified") {
              hovermode.set("x unified");
            }
          }
          if (["orientation", "type"].indexOf(ai) !== -1) {
            axlist = [];
            for (i = 0; i < traces.length; i++) {
              var trace = data[traces[i]];
              if (Registry.traceIs(trace, "cartesian")) {
                addToAxlist(trace.xaxis || "x");
                addToAxlist(trace.yaxis || "y");
              }
            }
            doextra(axlist.map(autorangeAttr), true, 0);
            doextra(axlist.map(rangeAttr), [0, 1], 0);
          }
        }
        if (flags.calc || flags.plot) {
          flags.fullReplot = true;
        }
        return {
          flags,
          undoit,
          redoit,
          traces,
          eventData: Lib.extendDeepNoArrays([], [eventData, traces])
        };
      }
      function relayout(gd, astr, val) {
        gd = Lib.getGraphDiv(gd);
        helpers.clearPromiseQueue(gd);
        var aobj = {};
        if (typeof astr === "string") {
          aobj[astr] = val;
        } else if (Lib.isPlainObject(astr)) {
          aobj = Lib.extendFlat({}, astr);
        } else {
          Lib.warn("Relayout fail.", astr, val);
          return Promise.reject();
        }
        if (Object.keys(aobj).length) gd.changed = true;
        var specs = _relayout(gd, aobj);
        var flags = specs.flags;
        if (flags.calc) gd.calcdata = void 0;
        var seq = [Plots.previousPromises];
        if (flags.layoutReplot) {
          seq.push(subroutines.layoutReplot);
        } else if (Object.keys(aobj).length) {
          axRangeSupplyDefaultsByPass(gd, flags, specs) || Plots.supplyDefaults(gd);
          if (flags.legend) seq.push(subroutines.doLegend);
          if (flags.layoutstyle) seq.push(subroutines.layoutStyles);
          if (flags.axrange) addAxRangeSequence(seq, specs.rangesAltered);
          if (flags.ticks) seq.push(subroutines.doTicksRelayout);
          if (flags.modebar) seq.push(subroutines.doModeBar);
          if (flags.camera) seq.push(subroutines.doCamera);
          if (flags.colorbars) seq.push(subroutines.doColorBars);
          seq.push(emitAfterPlot);
        }
        seq.push(
          Plots.rehover,
          Plots.redrag,
          Plots.reselect
        );
        Queue.add(
          gd,
          relayout,
          [gd, specs.undoit],
          relayout,
          [gd, specs.redoit]
        );
        var plotDone = Lib.syncOrAsync(seq, gd);
        if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);
        return plotDone.then(function() {
          gd.emit("plotly_relayout", specs.eventData);
          return gd;
        });
      }
      function axRangeSupplyDefaultsByPass(gd, flags, specs) {
        var fullLayout = gd._fullLayout;
        if (!flags.axrange) return false;
        for (var k in flags) {
          if (k !== "axrange" && flags[k]) return false;
        }
        var axIn, axOut;
        var coerce = function(attr, dflt) {
          return Lib.coerce(axIn, axOut, cartesianLayoutAttributes, attr, dflt);
        };
        var options = {};
        for (var axId in specs.rangesAltered) {
          var axName = Axes.id2name(axId);
          axIn = gd.layout[axName];
          axOut = fullLayout[axName];
          handleRangeDefaults(axIn, axOut, coerce, options);
          if (axOut._matchGroup) {
            for (var axId2 in axOut._matchGroup) {
              if (axId2 !== axId) {
                var ax2 = fullLayout[Axes.id2name(axId2)];
                ax2.autorange = axOut.autorange;
                ax2.range = axOut.range.slice();
                ax2._input.range = axOut.range.slice();
              }
            }
          }
        }
        return true;
      }
      function addAxRangeSequence(seq, rangesAltered) {
        var drawAxes = rangesAltered ? function(gd) {
          var axIds = [];
          var skipTitle = true;
          for (var id in rangesAltered) {
            var ax = Axes.getFromId(gd, id);
            axIds.push(id);
            if ((ax.ticklabelposition || "").indexOf("inside") !== -1) {
              if (ax._anchorAxis) {
                axIds.push(ax._anchorAxis._id);
              }
            }
            if (ax._matchGroup) {
              for (var id2 in ax._matchGroup) {
                if (!rangesAltered[id2]) {
                  axIds.push(id2);
                }
              }
            }
          }
          return Axes.draw(gd, axIds, { skipTitle });
        } : function(gd) {
          return Axes.draw(gd, "redraw");
        };
        seq.push(
          clearOutline,
          subroutines.doAutoRangeAndConstraints,
          drawAxes,
          subroutines.drawData,
          subroutines.finalDraw
        );
      }
      var AX_RANGE_RE = /^[xyz]axis[0-9]*\.range(\[[0|1]\])?$/;
      var AX_AUTORANGE_RE = /^[xyz]axis[0-9]*\.autorange$/;
      var AX_DOMAIN_RE = /^[xyz]axis[0-9]*\.domain(\[[0|1]\])?$/;
      function _relayout(gd, aobj) {
        var layout = gd.layout;
        var fullLayout = gd._fullLayout;
        var guiEditFlag = fullLayout._guiEditing;
        var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);
        var keys = Object.keys(aobj);
        var axes = Axes.list(gd);
        var eventData = Lib.extendDeepAll({}, aobj);
        var arrayEdits = {};
        var arrayStr, i, j;
        keys = Object.keys(aobj);
        for (i = 0; i < keys.length; i++) {
          if (keys[i].indexOf("allaxes") === 0) {
            for (j = 0; j < axes.length; j++) {
              var scene = axes[j]._id.substr(1);
              var axisAttr = scene.indexOf("scene") !== -1 ? scene + "." : "";
              var newkey = keys[i].replace("allaxes", axisAttr + axes[j]._name);
              if (!aobj[newkey]) aobj[newkey] = aobj[keys[i]];
            }
            delete aobj[keys[i]];
          }
        }
        var flags = editTypes.layoutFlags();
        var redoit = {};
        var undoit = {};
        function doextra(attr, val) {
          if (Array.isArray(attr)) {
            attr.forEach(function(a) {
              doextra(a, val);
            });
            return;
          }
          if (attr in aobj || helpers.hasParent(aobj, attr)) return;
          var p2 = layoutNP(layout, attr);
          if (!(attr in undoit)) {
            undoit[attr] = undefinedToNull(p2.get());
          }
          if (val !== void 0) p2.set(val);
        }
        var rangesAltered = {};
        var ax;
        function recordAlteredAxis(pleafPlus2) {
          var axId2 = Axes.name2id(pleafPlus2.split(".")[0]);
          rangesAltered[axId2] = 1;
          return axId2;
        }
        for (var ai in aobj) {
          if (helpers.hasParent(aobj, ai)) {
            throw new Error("cannot set " + ai + " and a parent attribute simultaneously");
          }
          var p = layoutNP(layout, ai);
          var vi = aobj[ai];
          var plen = p.parts.length;
          var pend = plen - 1;
          while (pend > 0 && typeof p.parts[pend] !== "string") pend--;
          var pleaf = p.parts[pend];
          var pleafPlus = p.parts[pend - 1] + "." + pleaf;
          var ptrunk = p.parts.slice(0, pend).join(".");
          var parentIn = nestedProperty(gd.layout, ptrunk).get();
          var parentFull = nestedProperty(fullLayout, ptrunk).get();
          var vOld = p.get();
          if (vi === void 0) continue;
          redoit[ai] = vi;
          undoit[ai] = pleaf === "reverse" ? vi : undefinedToNull(vOld);
          var valObject = PlotSchema.getLayoutValObject(fullLayout, p.parts);
          if (valObject && valObject.impliedEdits && vi !== null) {
            for (var impliedKey in valObject.impliedEdits) {
              doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey]);
            }
          }
          if (["width", "height"].indexOf(ai) !== -1) {
            if (vi) {
              doextra("autosize", null);
              var oppositeAttr = ai === "height" ? "width" : "height";
              doextra(oppositeAttr, fullLayout[oppositeAttr]);
            } else {
              fullLayout[ai] = gd._initialAutoSize[ai];
            }
          } else if (ai === "autosize") {
            doextra("width", vi ? null : fullLayout.width);
            doextra("height", vi ? null : fullLayout.height);
          } else if (pleafPlus.match(AX_RANGE_RE)) {
            recordAlteredAxis(pleafPlus);
            nestedProperty(fullLayout, ptrunk + "._inputRange").set(null);
          } else if (pleafPlus.match(AX_AUTORANGE_RE)) {
            recordAlteredAxis(pleafPlus);
            nestedProperty(fullLayout, ptrunk + "._inputRange").set(null);
            var axFull = nestedProperty(fullLayout, ptrunk).get();
            if (axFull._inputDomain) {
              axFull._input.domain = axFull._inputDomain.slice();
            }
          } else if (pleafPlus.match(AX_DOMAIN_RE)) {
            nestedProperty(fullLayout, ptrunk + "._inputDomain").set(null);
          }
          if (pleaf === "type") {
            ax = parentIn;
            var toLog = parentFull.type === "linear" && vi === "log";
            var fromLog = parentFull.type === "log" && vi === "linear";
            if (toLog || fromLog) {
              if (!ax || !ax.range) {
                doextra(ptrunk + ".autorange", true);
              } else if (!parentFull.autorange) {
                var r0 = ax.range[0];
                var r1 = ax.range[1];
                if (toLog) {
                  if (r0 <= 0 && r1 <= 0) {
                    doextra(ptrunk + ".autorange", true);
                  }
                  if (r0 <= 0) r0 = r1 / 1e6;
                  else if (r1 <= 0) r1 = r0 / 1e6;
                  doextra(ptrunk + ".range[0]", Math.log(r0) / Math.LN10);
                  doextra(ptrunk + ".range[1]", Math.log(r1) / Math.LN10);
                } else {
                  doextra(ptrunk + ".range[0]", Math.pow(10, r0));
                  doextra(ptrunk + ".range[1]", Math.pow(10, r1));
                }
              } else if (toLog) {
                ax.range = ax.range[1] > ax.range[0] ? [1, 2] : [2, 1];
              }
              if (Array.isArray(fullLayout._subplots.polar) && fullLayout._subplots.polar.length && fullLayout[p.parts[0]] && p.parts[1] === "radialaxis") {
                delete fullLayout[p.parts[0]]._subplot.viewInitial["radialaxis.range"];
              }
              Registry.getComponentMethod("annotations", "convertCoords")(gd, parentFull, vi, doextra);
              Registry.getComponentMethod("images", "convertCoords")(gd, parentFull, vi, doextra);
            } else {
              doextra(ptrunk + ".autorange", true);
              doextra(ptrunk + ".range", null);
            }
            nestedProperty(fullLayout, ptrunk + "._inputRange").set(null);
          } else if (pleaf.match(AX_NAME_PATTERN)) {
            var fullProp = nestedProperty(fullLayout, ai).get();
            var newType = (vi || {}).type;
            if (!newType || newType === "-") newType = "linear";
            Registry.getComponentMethod("annotations", "convertCoords")(gd, fullProp, newType, doextra);
            Registry.getComponentMethod("images", "convertCoords")(gd, fullProp, newType, doextra);
          }
          var containerArrayMatch = manageArrays.containerArrayMatch(ai);
          if (containerArrayMatch) {
            arrayStr = containerArrayMatch.array;
            i = containerArrayMatch.index;
            var propStr = containerArrayMatch.property;
            var updateValObject = valObject || { editType: "calc" };
            if (i !== "" && propStr === "") {
              if (manageArrays.isAddVal(vi)) {
                undoit[ai] = null;
              } else if (manageArrays.isRemoveVal(vi)) {
                undoit[ai] = (nestedProperty(layout, arrayStr).get() || [])[i];
              } else {
                Lib.warn("unrecognized full object value", aobj);
              }
            }
            editTypes.update(flags, updateValObject);
            if (!arrayEdits[arrayStr]) arrayEdits[arrayStr] = {};
            var objEdits = arrayEdits[arrayStr][i];
            if (!objEdits) objEdits = arrayEdits[arrayStr][i] = {};
            objEdits[propStr] = vi;
            delete aobj[ai];
          } else if (pleaf === "reverse") {
            if (parentIn.range) parentIn.range.reverse();
            else {
              doextra(ptrunk + ".autorange", true);
              parentIn.range = [1, 0];
            }
            if (parentFull.autorange) flags.calc = true;
            else flags.plot = true;
          } else {
            if (ai === "dragmode" && (vi === false && vOld !== false || vi !== false && vOld === false)) {
              flags.plot = true;
            } else if (fullLayout._has("scatter-like") && fullLayout._has("regl") && (ai === "dragmode" && (vi === "lasso" || vi === "select") && !(vOld === "lasso" || vOld === "select"))) {
              flags.plot = true;
            } else if (valObject) editTypes.update(flags, valObject);
            else flags.calc = true;
            p.set(vi);
          }
        }
        for (arrayStr in arrayEdits) {
          var finished = manageArrays.applyContainerArrayChanges(
            gd,
            layoutNP(layout, arrayStr),
            arrayEdits[arrayStr],
            flags,
            layoutNP
          );
          if (!finished) flags.plot = true;
        }
        for (var axId in rangesAltered) {
          ax = Axes.getFromId(gd, axId);
          var group = ax && ax._constraintGroup;
          if (group) {
            flags.calc = true;
            for (var groupAxId in group) {
              if (!rangesAltered[groupAxId]) {
                Axes.getFromId(gd, groupAxId)._constraintShrinkable = true;
              }
            }
          }
        }
        if (updateAutosize(gd) || aobj.height || aobj.width) flags.plot = true;
        var shapes = fullLayout.shapes;
        for (i = 0; i < shapes.length; i++) {
          if (shapes[i].showlegend) {
            flags.calc = true;
            break;
          }
        }
        if (flags.plot || flags.calc) {
          flags.layoutReplot = true;
        }
        return {
          flags,
          rangesAltered,
          undoit,
          redoit,
          eventData
        };
      }
      function updateAutosize(gd) {
        var fullLayout = gd._fullLayout;
        var oldWidth = fullLayout.width;
        var oldHeight = fullLayout.height;
        if (gd.layout.autosize) Plots.plotAutoSize(gd, gd.layout, fullLayout);
        return fullLayout.width !== oldWidth || fullLayout.height !== oldHeight;
      }
      function update(gd, traceUpdate, layoutUpdate, _traces) {
        gd = Lib.getGraphDiv(gd);
        helpers.clearPromiseQueue(gd);
        if (!Lib.isPlainObject(traceUpdate)) traceUpdate = {};
        if (!Lib.isPlainObject(layoutUpdate)) layoutUpdate = {};
        if (Object.keys(traceUpdate).length) gd.changed = true;
        if (Object.keys(layoutUpdate).length) gd.changed = true;
        var traces = helpers.coerceTraceIndices(gd, _traces);
        var restyleSpecs = _restyle(gd, Lib.extendFlat({}, traceUpdate), traces);
        var restyleFlags = restyleSpecs.flags;
        var relayoutSpecs = _relayout(gd, Lib.extendFlat({}, layoutUpdate));
        var relayoutFlags = relayoutSpecs.flags;
        if (restyleFlags.calc || relayoutFlags.calc) gd.calcdata = void 0;
        if (restyleFlags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, layoutUpdate);
        var seq = [];
        if (relayoutFlags.layoutReplot) {
          seq.push(subroutines.layoutReplot);
        } else if (restyleFlags.fullReplot) {
          seq.push(exports._doPlot);
        } else {
          seq.push(Plots.previousPromises);
          axRangeSupplyDefaultsByPass(gd, relayoutFlags, relayoutSpecs) || Plots.supplyDefaults(gd);
          if (restyleFlags.style) seq.push(subroutines.doTraceStyle);
          if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);
          if (relayoutFlags.legend) seq.push(subroutines.doLegend);
          if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);
          if (relayoutFlags.axrange) addAxRangeSequence(seq, relayoutSpecs.rangesAltered);
          if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);
          if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);
          if (relayoutFlags.camera) seq.push(subroutines.doCamera);
          seq.push(emitAfterPlot);
        }
        seq.push(
          Plots.rehover,
          Plots.redrag,
          Plots.reselect
        );
        Queue.add(
          gd,
          update,
          [gd, restyleSpecs.undoit, relayoutSpecs.undoit, restyleSpecs.traces],
          update,
          [gd, restyleSpecs.redoit, relayoutSpecs.redoit, restyleSpecs.traces]
        );
        var plotDone = Lib.syncOrAsync(seq, gd);
        if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);
        return plotDone.then(function() {
          gd.emit("plotly_update", {
            data: restyleSpecs.eventData,
            layout: relayoutSpecs.eventData
          });
          return gd;
        });
      }
      function guiEdit(func) {
        return function wrappedEdit(gd) {
          gd._fullLayout._guiEditing = true;
          var p = func.apply(null, arguments);
          gd._fullLayout._guiEditing = false;
          return p;
        };
      }
      var layoutUIControlPatterns = [
        { pattern: /^hiddenlabels/, attr: "legend.uirevision" },
        { pattern: /^((x|y)axis\d*)\.((auto)?range|title\.text)/ },
        // showspikes and modes include those nested inside scenes
        { pattern: /axis\d*\.showspikes$/, attr: "modebar.uirevision" },
        { pattern: /(hover|drag)mode$/, attr: "modebar.uirevision" },
        { pattern: /^(scene\d*)\.camera/ },
        { pattern: /^(geo\d*)\.(projection|center|fitbounds)/ },
        { pattern: /^(ternary\d*\.[abc]axis)\.(min|title\.text)$/ },
        { pattern: /^(polar\d*\.radialaxis)\.((auto)?range|angle|title\.text)/ },
        { pattern: /^(polar\d*\.angularaxis)\.rotation/ },
        { pattern: /^(mapbox\d*)\.(center|zoom|bearing|pitch)/ },
        { pattern: /^(map\d*)\.(center|zoom|bearing|pitch)/ },
        { pattern: /^legend\.(x|y)$/, attr: "editrevision" },
        { pattern: /^(shapes|annotations)/, attr: "editrevision" },
        { pattern: /^title\.text$/, attr: "editrevision" }
      ];
      var traceUIControlPatterns = [
        { pattern: /^selectedpoints$/, attr: "selectionrevision" },
        // "visible" includes trace.transforms[i].styles[j].value.visible
        { pattern: /(^|value\.)visible$/, attr: "legend.uirevision" },
        { pattern: /^dimensions\[\d+\]\.constraintrange/ },
        { pattern: /^node\.(x|y|groups)/ },
        // for Sankey nodes
        { pattern: /^level$/ },
        // for Sunburst, Treemap and Icicle traces
        // below this you must be in editable: true mode
        // TODO: I still put name and title with `trace.uirevision`
        // reasonable or should these be `editrevision`?
        // Also applies to axis titles up in the layout section
        // "name" also includes transform.styles
        { pattern: /(^|value\.)name$/ },
        // including nested colorbar attributes (ie marker.colorbar)
        { pattern: /colorbar\.title\.text$/ },
        { pattern: /colorbar\.(x|y)$/, attr: "editrevision" }
      ];
      function findUIPattern(key, patternSpecs) {
        for (var i = 0; i < patternSpecs.length; i++) {
          var spec = patternSpecs[i];
          var match = key.match(spec.pattern);
          if (match) {
            var head = match[1] || "";
            return { head, tail: key.substr(head.length + 1), attr: spec.attr };
          }
        }
      }
      function getNewRev(revAttr, container) {
        var newRev = nestedProperty(container, revAttr).get();
        if (newRev !== void 0) return newRev;
        var parts = revAttr.split(".");
        parts.pop();
        while (parts.length > 1) {
          parts.pop();
          newRev = nestedProperty(container, parts.join(".") + ".uirevision").get();
          if (newRev !== void 0) return newRev;
        }
        return container.uirevision;
      }
      function getFullTraceIndexFromUid(uid, fullData) {
        for (var i = 0; i < fullData.length; i++) {
          if (fullData[i]._fullInput.uid === uid) return i;
        }
        return -1;
      }
      function getTraceIndexFromUid(uid, data, tracei) {
        for (var i = 0; i < data.length; i++) {
          if (data[i].uid === uid) return i;
        }
        return !data[tracei] || data[tracei].uid ? -1 : tracei;
      }
      function valsMatch(v1, v2) {
        var v1IsObj = Lib.isPlainObject(v1);
        var v1IsArray = Array.isArray(v1);
        if (v1IsObj || v1IsArray) {
          return (v1IsObj && Lib.isPlainObject(v2) || v1IsArray && Array.isArray(v2)) && JSON.stringify(v1) === JSON.stringify(v2);
        }
        return v1 === v2;
      }
      function applyUIRevisions(data, layout, oldFullData, oldFullLayout) {
        var layoutPreGUI = oldFullLayout._preGUI;
        var key, revAttr, oldRev, newRev, match, preGUIVal, newNP, newVal, head, tail;
        var bothInheritAutorange = [];
        var newAutorangeIn = {};
        var newRangeAccepted = {};
        for (key in layoutPreGUI) {
          match = findUIPattern(key, layoutUIControlPatterns);
          if (match) {
            head = match.head;
            tail = match.tail;
            revAttr = match.attr || head + ".uirevision";
            oldRev = nestedProperty(oldFullLayout, revAttr).get();
            newRev = oldRev && getNewRev(revAttr, layout);
            if (newRev && newRev === oldRev) {
              preGUIVal = layoutPreGUI[key];
              if (preGUIVal === null) preGUIVal = void 0;
              newNP = nestedProperty(layout, key);
              newVal = newNP.get();
              if (valsMatch(newVal, preGUIVal)) {
                if (newVal === void 0 && tail === "autorange") {
                  bothInheritAutorange.push(head);
                }
                newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));
                continue;
              } else if (tail === "autorange" || tail.substr(0, 6) === "range[") {
                var pre0 = layoutPreGUI[head + ".range[0]"];
                var pre1 = layoutPreGUI[head + ".range[1]"];
                var preAuto = layoutPreGUI[head + ".autorange"];
                if (preAuto || preAuto === null && pre0 === null && pre1 === null) {
                  if (!(head in newAutorangeIn)) {
                    var newContainer = nestedProperty(layout, head).get();
                    newAutorangeIn[head] = newContainer && (newContainer.autorange || newContainer.autorange !== false && (!newContainer.range || newContainer.range.length !== 2));
                  }
                  if (newAutorangeIn[head]) {
                    newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));
                    continue;
                  }
                }
              }
            }
          } else {
            Lib.warn("unrecognized GUI edit: " + key);
          }
          delete layoutPreGUI[key];
          if (match && match.tail.substr(0, 6) === "range[") {
            newRangeAccepted[match.head] = 1;
          }
        }
        for (var i = 0; i < bothInheritAutorange.length; i++) {
          var axAttr = bothInheritAutorange[i];
          if (newRangeAccepted[axAttr]) {
            var newAx = nestedProperty(layout, axAttr).get();
            if (newAx) delete newAx.autorange;
          }
        }
        var allTracePreGUI = oldFullLayout._tracePreGUI;
        for (var uid in allTracePreGUI) {
          var tracePreGUI = allTracePreGUI[uid];
          var newTrace = null;
          var fullInput;
          for (key in tracePreGUI) {
            if (!newTrace) {
              var fulli = getFullTraceIndexFromUid(uid, oldFullData);
              if (fulli < 0) {
                delete allTracePreGUI[uid];
                break;
              }
              var fullTrace = oldFullData[fulli];
              fullInput = fullTrace._fullInput;
              var newTracei = getTraceIndexFromUid(uid, data, fullInput.index);
              if (newTracei < 0) {
                delete allTracePreGUI[uid];
                break;
              }
              newTrace = data[newTracei];
            }
            match = findUIPattern(key, traceUIControlPatterns);
            if (match) {
              if (match.attr) {
                oldRev = nestedProperty(oldFullLayout, match.attr).get();
                newRev = oldRev && getNewRev(match.attr, layout);
              } else {
                oldRev = fullInput.uirevision;
                newRev = newTrace.uirevision;
                if (newRev === void 0) newRev = layout.uirevision;
              }
              if (newRev && newRev === oldRev) {
                preGUIVal = tracePreGUI[key];
                if (preGUIVal === null) preGUIVal = void 0;
                newNP = nestedProperty(newTrace, key);
                newVal = newNP.get();
                if (valsMatch(newVal, preGUIVal)) {
                  newNP.set(undefinedToNull(nestedProperty(fullInput, key).get()));
                  continue;
                }
              }
            } else {
              Lib.warn("unrecognized GUI edit: " + key + " in trace uid " + uid);
            }
            delete tracePreGUI[key];
          }
        }
      }
      function react(gd, data, layout, config) {
        var frames, plotDone;
        function addFrames2() {
          return exports.addFrames(gd, frames);
        }
        gd = Lib.getGraphDiv(gd);
        helpers.clearPromiseQueue(gd);
        var oldFullData = gd._fullData;
        var oldFullLayout = gd._fullLayout;
        if (!Lib.isPlotDiv(gd) || !oldFullData || !oldFullLayout) {
          plotDone = exports.newPlot(gd, data, layout, config);
        } else {
          if (Lib.isPlainObject(data)) {
            var obj = data;
            data = obj.data;
            layout = obj.layout;
            config = obj.config;
            frames = obj.frames;
          }
          var configChanged = false;
          if (config) {
            var oldConfig = Lib.extendDeep({}, gd._context);
            gd._context = void 0;
            setPlotContext(gd, config);
            configChanged = diffConfig(oldConfig, gd._context);
          }
          gd.data = data || [];
          helpers.cleanData(gd.data);
          gd.layout = layout || {};
          helpers.cleanLayout(gd.layout);
          applyUIRevisions(gd.data, gd.layout, oldFullData, oldFullLayout);
          Plots.supplyDefaults(gd, { skipUpdateCalc: true });
          var newFullData = gd._fullData;
          var newFullLayout = gd._fullLayout;
          var immutable = newFullLayout.datarevision === void 0;
          var transition = newFullLayout.transition;
          var relayoutFlags = diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition);
          var newDataRevision = relayoutFlags.newDataRevision;
          var restyleFlags = diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision);
          if (updateAutosize(gd)) relayoutFlags.layoutReplot = true;
          if (restyleFlags.calc || relayoutFlags.calc) {
            gd.calcdata = void 0;
            var allNames = Object.getOwnPropertyNames(newFullLayout);
            for (var q = 0; q < allNames.length; q++) {
              var name = allNames[q];
              var start = name.substring(0, 5);
              if (start === "xaxis" || start === "yaxis") {
                var emptyCategories = newFullLayout[name]._emptyCategories;
                if (emptyCategories) emptyCategories();
              }
            }
          } else {
            Plots.supplyDefaultsUpdateCalc(gd.calcdata, newFullData);
          }
          var seq = [];
          if (frames) {
            gd._transitionData = {};
            Plots.createTransitionData(gd);
            seq.push(addFrames2);
          }
          if (newFullLayout.transition && !configChanged && (restyleFlags.anim || relayoutFlags.anim)) {
            if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);
            Plots.doCalcdata(gd);
            subroutines.doAutoRangeAndConstraints(gd);
            seq.push(function() {
              return Plots.transitionFromReact(gd, restyleFlags, relayoutFlags, oldFullLayout);
            });
          } else if (restyleFlags.fullReplot || relayoutFlags.layoutReplot || configChanged) {
            gd._fullLayout._skipDefaults = true;
            seq.push(exports._doPlot);
          } else {
            for (var componentType in relayoutFlags.arrays) {
              var indices = relayoutFlags.arrays[componentType];
              if (indices.length) {
                var drawOne = Registry.getComponentMethod(componentType, "drawOne");
                if (drawOne !== Lib.noop) {
                  for (var i = 0; i < indices.length; i++) {
                    drawOne(gd, indices[i]);
                  }
                } else {
                  var draw = Registry.getComponentMethod(componentType, "draw");
                  if (draw === Lib.noop) {
                    throw new Error("cannot draw components: " + componentType);
                  }
                  draw(gd);
                }
              }
            }
            seq.push(Plots.previousPromises);
            if (restyleFlags.style) seq.push(subroutines.doTraceStyle);
            if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);
            if (relayoutFlags.legend) seq.push(subroutines.doLegend);
            if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);
            if (relayoutFlags.axrange) addAxRangeSequence(seq);
            if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);
            if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);
            if (relayoutFlags.camera) seq.push(subroutines.doCamera);
            seq.push(emitAfterPlot);
          }
          seq.push(
            Plots.rehover,
            Plots.redrag,
            Plots.reselect
          );
          plotDone = Lib.syncOrAsync(seq, gd);
          if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);
        }
        return plotDone.then(function() {
          gd.emit("plotly_react", {
            data,
            layout
          });
          return gd;
        });
      }
      function diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision) {
        var sameTraceLength = oldFullData.length === newFullData.length;
        if (!transition && !sameTraceLength) {
          return {
            fullReplot: true,
            calc: true
          };
        }
        var flags = editTypes.traceFlags();
        flags.arrays = {};
        flags.nChanges = 0;
        flags.nChangesAnim = 0;
        var i, trace;
        function getTraceValObject(parts) {
          var out = PlotSchema.getTraceValObject(trace, parts);
          if (!trace._module.animatable && out.anim) {
            out.anim = false;
          }
          return out;
        }
        var diffOpts = {
          getValObject: getTraceValObject,
          flags,
          immutable,
          transition,
          newDataRevision,
          gd
        };
        var seenUIDs = {};
        for (i = 0; i < oldFullData.length; i++) {
          if (newFullData[i]) {
            trace = newFullData[i]._fullInput;
            if (seenUIDs[trace.uid]) continue;
            seenUIDs[trace.uid] = 1;
            getDiffFlags(oldFullData[i]._fullInput, trace, [], diffOpts);
          }
        }
        if (flags.calc || flags.plot) {
          flags.fullReplot = true;
        }
        if (transition && flags.nChanges && flags.nChangesAnim) {
          flags.anim = flags.nChanges === flags.nChangesAnim && sameTraceLength ? "all" : "some";
        }
        return flags;
      }
      function diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition) {
        var flags = editTypes.layoutFlags();
        flags.arrays = {};
        flags.rangesAltered = {};
        flags.nChanges = 0;
        flags.nChangesAnim = 0;
        function getLayoutValObject(parts) {
          return PlotSchema.getLayoutValObject(newFullLayout, parts);
        }
        for (var key in newFullLayout) {
          if (!key.startsWith("xaxis") && !key.startsWith("yaxis")) {
            continue;
          }
          if (!oldFullLayout[key]) {
            continue;
          }
          var newDomain = newFullLayout[key].domain;
          var oldDomain = oldFullLayout[key].domain;
          var oldInputDomain = oldFullLayout[key]._inputDomain;
          if (oldFullLayout[key]._inputDomain) {
            if (newDomain[0] === oldInputDomain[0] && newDomain[1] === oldInputDomain[1]) {
              newFullLayout[key].domain = oldFullLayout[key].domain;
            } else if (newDomain[0] !== oldDomain[0] || newDomain[1] !== oldDomain[1]) {
              newFullLayout[key]._inputDomain = null;
            }
          }
        }
        var diffOpts = {
          getValObject: getLayoutValObject,
          flags,
          immutable,
          transition,
          gd
        };
        getDiffFlags(oldFullLayout, newFullLayout, [], diffOpts);
        if (flags.plot || flags.calc) {
          flags.layoutReplot = true;
        }
        if (transition && flags.nChanges && flags.nChangesAnim) {
          flags.anim = flags.nChanges === flags.nChangesAnim ? "all" : "some";
        }
        return flags;
      }
      function getDiffFlags(oldContainer, newContainer, outerparts, opts) {
        var valObject, key, astr;
        var getValObject = opts.getValObject;
        var flags = opts.flags;
        var immutable = opts.immutable;
        var inArray = opts.inArray;
        var arrayIndex = opts.arrayIndex;
        function changed() {
          var editType = valObject.editType;
          if (inArray && editType.indexOf("arraydraw") !== -1) {
            Lib.pushUnique(flags.arrays[inArray], arrayIndex);
            return;
          }
          editTypes.update(flags, valObject);
          if (editType !== "none") {
            flags.nChanges++;
          }
          if (opts.transition && valObject.anim) {
            flags.nChangesAnim++;
          }
          if (AX_RANGE_RE.test(astr) || AX_AUTORANGE_RE.test(astr)) {
            flags.rangesAltered[outerparts[0]] = 1;
          }
          if (key === "datarevision") {
            flags.newDataRevision = 1;
          }
        }
        function valObjectCanBeDataArray(valObject2) {
          return valObject2.valType === "data_array" || valObject2.arrayOk;
        }
        for (key in oldContainer) {
          if (flags.calc && !opts.transition) return;
          var oldVal = oldContainer[key];
          var newVal = newContainer[key];
          var parts = outerparts.concat(key);
          astr = parts.join(".");
          if (key.charAt(0) === "_" || typeof oldVal === "function" || oldVal === newVal) continue;
          if ((key === "tick0" || key === "dtick") && outerparts[0] !== "geo") {
            var tickMode = newContainer.tickmode;
            if (tickMode === "auto" || tickMode === "array" || !tickMode) continue;
          }
          if (key === "range" && newContainer.autorange) continue;
          if ((key === "zmin" || key === "zmax") && newContainer.type === "contourcarpet") continue;
          valObject = getValObject(parts);
          if (!valObject) continue;
          if (valObject._compareAsJSON && JSON.stringify(oldVal) === JSON.stringify(newVal)) continue;
          var valType = valObject.valType;
          var i;
          var canBeDataArray = valObjectCanBeDataArray(valObject);
          var wasArray = Array.isArray(oldVal);
          var nowArray = Array.isArray(newVal);
          if (wasArray && nowArray) {
            var inputKey = "_input_" + key;
            var oldValIn = oldContainer[inputKey];
            var newValIn = newContainer[inputKey];
            if (Array.isArray(oldValIn) && oldValIn === newValIn) continue;
          }
          if (newVal === void 0) {
            if (canBeDataArray && wasArray) flags.calc = true;
            else changed();
          } else if (valObject._isLinkedToArray) {
            var arrayEditIndices = [];
            var extraIndices = false;
            if (!inArray) flags.arrays[key] = arrayEditIndices;
            var minLen = Math.min(oldVal.length, newVal.length);
            var maxLen = Math.max(oldVal.length, newVal.length);
            if (minLen !== maxLen) {
              if (valObject.editType === "arraydraw") {
                extraIndices = true;
              } else {
                changed();
                continue;
              }
            }
            for (i = 0; i < minLen; i++) {
              getDiffFlags(
                oldVal[i],
                newVal[i],
                parts.concat(i),
                // add array indices, but not if we're already in an array
                Lib.extendFlat({ inArray: key, arrayIndex: i }, opts)
              );
            }
            if (extraIndices) {
              for (i = minLen; i < maxLen; i++) {
                arrayEditIndices.push(i);
              }
            }
          } else if (!valType && Lib.isPlainObject(oldVal)) {
            getDiffFlags(oldVal, newVal, parts, opts);
          } else if (canBeDataArray) {
            if (wasArray && nowArray) {
              if (immutable) {
                flags.calc = true;
              }
              if (immutable || opts.newDataRevision) {
                changed();
              }
            } else if (wasArray !== nowArray) {
              flags.calc = true;
            } else changed();
          } else if (wasArray && nowArray) {
            if (oldVal.length !== newVal.length || String(oldVal) !== String(newVal)) {
              changed();
            }
          } else {
            changed();
          }
        }
        for (key in newContainer) {
          if (!(key in oldContainer || key.charAt(0) === "_" || typeof newContainer[key] === "function")) {
            valObject = getValObject(outerparts.concat(key));
            if (valObjectCanBeDataArray(valObject) && Array.isArray(newContainer[key])) {
              flags.calc = true;
              return;
            } else changed();
          }
        }
      }
      function diffConfig(oldConfig, newConfig) {
        var key;
        for (key in oldConfig) {
          if (key.charAt(0) === "_") continue;
          var oldVal = oldConfig[key];
          var newVal = newConfig[key];
          if (oldVal !== newVal) {
            if (Lib.isPlainObject(oldVal) && Lib.isPlainObject(newVal)) {
              if (diffConfig(oldVal, newVal)) {
                return true;
              }
            } else if (Array.isArray(oldVal) && Array.isArray(newVal)) {
              if (oldVal.length !== newVal.length) {
                return true;
              }
              for (var i = 0; i < oldVal.length; i++) {
                if (oldVal[i] !== newVal[i]) {
                  if (Lib.isPlainObject(oldVal[i]) && Lib.isPlainObject(newVal[i])) {
                    if (diffConfig(oldVal[i], newVal[i])) {
                      return true;
                    }
                  } else {
                    return true;
                  }
                }
              }
            } else {
              return true;
            }
          }
        }
      }
      function animate(gd, frameOrGroupNameOrFrameList, animationOpts) {
        gd = Lib.getGraphDiv(gd);
        if (!Lib.isPlotDiv(gd)) {
          throw new Error(
            "This element is not a Plotly plot: " + gd + ". It's likely that you've failed to create a plot before animating it. For more details, see https://plotly.com/javascript/animations/"
          );
        }
        var trans = gd._transitionData;
        if (!trans._frameQueue) {
          trans._frameQueue = [];
        }
        animationOpts = Plots.supplyAnimationDefaults(animationOpts);
        var transitionOpts = animationOpts.transition;
        var frameOpts = animationOpts.frame;
        if (trans._frameWaitingCnt === void 0) {
          trans._frameWaitingCnt = 0;
        }
        function getTransitionOpts(i) {
          if (Array.isArray(transitionOpts)) {
            if (i >= transitionOpts.length) {
              return transitionOpts[0];
            } else {
              return transitionOpts[i];
            }
          } else {
            return transitionOpts;
          }
        }
        function getFrameOpts(i) {
          if (Array.isArray(frameOpts)) {
            if (i >= frameOpts.length) {
              return frameOpts[0];
            } else {
              return frameOpts[i];
            }
          } else {
            return frameOpts;
          }
        }
        function callbackOnNthTime(cb, n) {
          var cnt = 0;
          return function() {
            if (cb && ++cnt === n) {
              return cb();
            }
          };
        }
        return new Promise(function(resolve, reject) {
          function discardExistingFrames() {
            if (trans._frameQueue.length === 0) {
              return;
            }
            while (trans._frameQueue.length) {
              var next = trans._frameQueue.pop();
              if (next.onInterrupt) {
                next.onInterrupt();
              }
            }
            gd.emit("plotly_animationinterrupted", []);
          }
          function queueFrames(frameList2) {
            if (frameList2.length === 0) return;
            for (var i2 = 0; i2 < frameList2.length; i2++) {
              var computedFrame;
              if (frameList2[i2].type === "byname") {
                computedFrame = Plots.computeFrame(gd, frameList2[i2].name);
              } else {
                computedFrame = frameList2[i2].data;
              }
              var frameOpts2 = getFrameOpts(i2);
              var transitionOpts2 = getTransitionOpts(i2);
              transitionOpts2.duration = Math.min(transitionOpts2.duration, frameOpts2.duration);
              var nextFrame2 = {
                frame: computedFrame,
                name: frameList2[i2].name,
                frameOpts: frameOpts2,
                transitionOpts: transitionOpts2
              };
              if (i2 === frameList2.length - 1) {
                nextFrame2.onComplete = callbackOnNthTime(resolve, 2);
                nextFrame2.onInterrupt = reject;
              }
              trans._frameQueue.push(nextFrame2);
            }
            if (animationOpts.mode === "immediate") {
              trans._lastFrameAt = -Infinity;
            }
            if (!trans._animationRaf) {
              beginAnimationLoop();
            }
          }
          function stopAnimationLoop() {
            gd.emit("plotly_animated");
            window.cancelAnimationFrame(trans._animationRaf);
            trans._animationRaf = null;
          }
          function nextFrame() {
            if (trans._currentFrame && trans._currentFrame.onComplete) {
              trans._currentFrame.onComplete();
            }
            var newFrame = trans._currentFrame = trans._frameQueue.shift();
            if (newFrame) {
              var stringName = newFrame.name ? newFrame.name.toString() : null;
              gd._fullLayout._currentFrame = stringName;
              trans._lastFrameAt = Date.now();
              trans._timeToNext = newFrame.frameOpts.duration;
              Plots.transition(
                gd,
                newFrame.frame.data,
                newFrame.frame.layout,
                helpers.coerceTraceIndices(gd, newFrame.frame.traces),
                newFrame.frameOpts,
                newFrame.transitionOpts
              ).then(function() {
                if (newFrame.onComplete) {
                  newFrame.onComplete();
                }
              });
              gd.emit("plotly_animatingframe", {
                name: stringName,
                frame: newFrame.frame,
                animation: {
                  frame: newFrame.frameOpts,
                  transition: newFrame.transitionOpts
                }
              });
            } else {
              stopAnimationLoop();
            }
          }
          function beginAnimationLoop() {
            gd.emit("plotly_animating");
            trans._lastFrameAt = -Infinity;
            trans._timeToNext = 0;
            trans._runningTransitions = 0;
            trans._currentFrame = null;
            var doFrame = function() {
              trans._animationRaf = window.requestAnimationFrame(doFrame);
              if (Date.now() - trans._lastFrameAt > trans._timeToNext) {
                nextFrame();
              }
            };
            doFrame();
          }
          var configCounter = 0;
          function setTransitionConfig(frame2) {
            if (Array.isArray(transitionOpts)) {
              if (configCounter >= transitionOpts.length) {
                frame2.transitionOpts = transitionOpts[configCounter];
              } else {
                frame2.transitionOpts = transitionOpts[0];
              }
            } else {
              frame2.transitionOpts = transitionOpts;
            }
            configCounter++;
            return frame2;
          }
          var i, frame;
          var frameList = [];
          var allFrames = frameOrGroupNameOrFrameList === void 0 || frameOrGroupNameOrFrameList === null;
          var isFrameArray = Array.isArray(frameOrGroupNameOrFrameList);
          var isSingleFrame = !allFrames && !isFrameArray && Lib.isPlainObject(frameOrGroupNameOrFrameList);
          if (isSingleFrame) {
            frameList.push({
              type: "object",
              data: setTransitionConfig(Lib.extendFlat({}, frameOrGroupNameOrFrameList))
            });
          } else if (allFrames || ["string", "number"].indexOf(typeof frameOrGroupNameOrFrameList) !== -1) {
            for (i = 0; i < trans._frames.length; i++) {
              frame = trans._frames[i];
              if (!frame) continue;
              if (allFrames || String(frame.group) === String(frameOrGroupNameOrFrameList)) {
                frameList.push({
                  type: "byname",
                  name: String(frame.name),
                  data: setTransitionConfig({ name: frame.name })
                });
              }
            }
          } else if (isFrameArray) {
            for (i = 0; i < frameOrGroupNameOrFrameList.length; i++) {
              var frameOrName = frameOrGroupNameOrFrameList[i];
              if (["number", "string"].indexOf(typeof frameOrName) !== -1) {
                frameOrName = String(frameOrName);
                frameList.push({
                  type: "byname",
                  name: frameOrName,
                  data: setTransitionConfig({ name: frameOrName })
                });
              } else if (Lib.isPlainObject(frameOrName)) {
                frameList.push({
                  type: "object",
                  data: setTransitionConfig(Lib.extendFlat({}, frameOrName))
                });
              }
            }
          }
          for (i = 0; i < frameList.length; i++) {
            frame = frameList[i];
            if (frame.type === "byname" && !trans._frameHash[frame.data.name]) {
              Lib.warn('animate failure: frame not found: "' + frame.data.name + '"');
              reject();
              return;
            }
          }
          if (["next", "immediate"].indexOf(animationOpts.mode) !== -1) {
            discardExistingFrames();
          }
          if (animationOpts.direction === "reverse") {
            frameList.reverse();
          }
          var currentFrame = gd._fullLayout._currentFrame;
          if (currentFrame && animationOpts.fromcurrent) {
            var idx = -1;
            for (i = 0; i < frameList.length; i++) {
              frame = frameList[i];
              if (frame.type === "byname" && frame.name === currentFrame) {
                idx = i;
                break;
              }
            }
            if (idx > 0 && idx < frameList.length - 1) {
              var filteredFrameList = [];
              for (i = 0; i < frameList.length; i++) {
                frame = frameList[i];
                if (frameList[i].type !== "byname" || i > idx) {
                  filteredFrameList.push(frame);
                }
              }
              frameList = filteredFrameList;
            }
          }
          if (frameList.length > 0) {
            queueFrames(frameList);
          } else {
            gd.emit("plotly_animated");
            resolve();
          }
        });
      }
      function addFrames(gd, frameList, indices) {
        gd = Lib.getGraphDiv(gd);
        if (frameList === null || frameList === void 0) {
          return Promise.resolve();
        }
        if (!Lib.isPlotDiv(gd)) {
          throw new Error(
            "This element is not a Plotly plot: " + gd + ". It's likely that you've failed to create a plot before adding frames. For more details, see https://plotly.com/javascript/animations/"
          );
        }
        var i, frame, j, idx;
        var _frames = gd._transitionData._frames;
        var _frameHash = gd._transitionData._frameHash;
        if (!Array.isArray(frameList)) {
          throw new Error("addFrames failure: frameList must be an Array of frame definitions" + frameList);
        }
        var bigIndex = _frames.length + frameList.length * 2;
        var insertions = [];
        var _frameHashLocal = {};
        for (i = frameList.length - 1; i >= 0; i--) {
          if (!Lib.isPlainObject(frameList[i])) continue;
          var lookupName = frameList[i].name;
          var name = (_frameHash[lookupName] || _frameHashLocal[lookupName] || {}).name;
          var newName = frameList[i].name;
          var collisionPresent = _frameHash[name] || _frameHashLocal[name];
          if (name && newName && typeof newName === "number" && collisionPresent && numericNameWarningCount < numericNameWarningCountLimit) {
            numericNameWarningCount++;
            Lib.warn('addFrames: overwriting frame "' + (_frameHash[name] || _frameHashLocal[name]).name + '" with a frame whose name of type "number" also equates to "' + name + '". This is valid but may potentially lead to unexpected behavior since all plotly.js frame names are stored internally as strings.');
            if (numericNameWarningCount === numericNameWarningCountLimit) {
              Lib.warn("addFrames: This API call has yielded too many of these warnings. For the rest of this call, further warnings about numeric frame names will be suppressed.");
            }
          }
          _frameHashLocal[lookupName] = { name: lookupName };
          insertions.push({
            frame: Plots.supplyFrameDefaults(frameList[i]),
            index: indices && indices[i] !== void 0 && indices[i] !== null ? indices[i] : bigIndex + i
          });
        }
        insertions.sort(function(a, b) {
          if (a.index > b.index) return -1;
          if (a.index < b.index) return 1;
          return 0;
        });
        var ops = [];
        var revops = [];
        var frameCount = _frames.length;
        for (i = insertions.length - 1; i >= 0; i--) {
          frame = insertions[i].frame;
          if (typeof frame.name === "number") {
            Lib.warn("Warning: addFrames accepts frames with numeric names, but the numbers areimplicitly cast to strings");
          }
          if (!frame.name) {
            while (_frameHash[frame.name = "frame " + gd._transitionData._counter++]) ;
          }
          if (_frameHash[frame.name]) {
            for (j = 0; j < _frames.length; j++) {
              if ((_frames[j] || {}).name === frame.name) break;
            }
            ops.push({ type: "replace", index: j, value: frame });
            revops.unshift({ type: "replace", index: j, value: _frames[j] });
          } else {
            idx = Math.max(0, Math.min(insertions[i].index, frameCount));
            ops.push({ type: "insert", index: idx, value: frame });
            revops.unshift({ type: "delete", index: idx });
            frameCount++;
          }
        }
        var undoFunc = Plots.modifyFrames;
        var redoFunc = Plots.modifyFrames;
        var undoArgs = [gd, revops];
        var redoArgs = [gd, ops];
        if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
        return Plots.modifyFrames(gd, ops);
      }
      function deleteFrames(gd, frameList) {
        gd = Lib.getGraphDiv(gd);
        if (!Lib.isPlotDiv(gd)) {
          throw new Error("This element is not a Plotly plot: " + gd);
        }
        var i, idx;
        var _frames = gd._transitionData._frames;
        var ops = [];
        var revops = [];
        if (!frameList) {
          frameList = [];
          for (i = 0; i < _frames.length; i++) {
            frameList.push(i);
          }
        }
        frameList = frameList.slice();
        frameList.sort();
        for (i = frameList.length - 1; i >= 0; i--) {
          idx = frameList[i];
          ops.push({ type: "delete", index: idx });
          revops.unshift({ type: "insert", index: idx, value: _frames[idx] });
        }
        var undoFunc = Plots.modifyFrames;
        var redoFunc = Plots.modifyFrames;
        var undoArgs = [gd, revops];
        var redoArgs = [gd, ops];
        if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
        return Plots.modifyFrames(gd, ops);
      }
      function purge(gd) {
        gd = Lib.getGraphDiv(gd);
        var fullLayout = gd._fullLayout || {};
        var fullData = gd._fullData || [];
        Plots.cleanPlot([], {}, fullData, fullLayout);
        Plots.purge(gd);
        Events.purge(gd);
        if (fullLayout._container) fullLayout._container.remove();
        delete gd._context;
        return gd;
      }
      function calcInverseTransform(gd) {
        var fullLayout = gd._fullLayout;
        var newBBox = gd.getBoundingClientRect();
        if (Lib.equalDomRects(newBBox, fullLayout._lastBBox)) return;
        var m = fullLayout._invTransform = Lib.inverseTransformMatrix(Lib.getFullTransformMatrix(gd));
        fullLayout._invScaleX = Math.sqrt(m[0][0] * m[0][0] + m[0][1] * m[0][1] + m[0][2] * m[0][2]);
        fullLayout._invScaleY = Math.sqrt(m[1][0] * m[1][0] + m[1][1] * m[1][1] + m[1][2] * m[1][2]);
        fullLayout._lastBBox = newBBox;
      }
      function makePlotFramework(gd) {
        var gd3 = d3.select(gd);
        var fullLayout = gd._fullLayout;
        fullLayout._calcInverseTransform = calcInverseTransform;
        fullLayout._calcInverseTransform(gd);
        fullLayout._container = gd3.selectAll(".plot-container").data([0]);
        fullLayout._container.enter().insert("div", ":first-child").classed("plot-container", true).classed("plotly", true).style({
          width: "100%",
          height: "100%"
        });
        fullLayout._paperdiv = fullLayout._container.selectAll(".svg-container").data([0]);
        fullLayout._paperdiv.enter().append("div").classed("user-select-none", true).classed("svg-container", true).style("position", "relative");
        fullLayout._glcontainer = fullLayout._paperdiv.selectAll(".gl-container").data([{}]);
        fullLayout._glcontainer.enter().append("div").classed("gl-container", true);
        fullLayout._paperdiv.selectAll(".main-svg").remove();
        fullLayout._paperdiv.select(".modebar-container").remove();
        fullLayout._paper = fullLayout._paperdiv.insert("svg", ":first-child").classed("main-svg", true);
        fullLayout._toppaper = fullLayout._paperdiv.append("svg").classed("main-svg", true);
        fullLayout._modebardiv = fullLayout._paperdiv.append("div");
        delete fullLayout._modeBar;
        fullLayout._hoverpaper = fullLayout._paperdiv.append("svg").classed("main-svg", true);
        if (!fullLayout._uid) {
          var otherUids = {};
          d3.selectAll("defs").each(function() {
            if (this.id) otherUids[this.id.split("-")[1]] = 1;
          });
          fullLayout._uid = Lib.randstr(otherUids);
        }
        fullLayout._paperdiv.selectAll(".main-svg").attr(xmlnsNamespaces.svgAttrs);
        fullLayout._defs = fullLayout._paper.append("defs").attr("id", "defs-" + fullLayout._uid);
        fullLayout._clips = fullLayout._defs.append("g").classed("clips", true);
        fullLayout._topdefs = fullLayout._toppaper.append("defs").attr("id", "topdefs-" + fullLayout._uid);
        fullLayout._topclips = fullLayout._topdefs.append("g").classed("clips", true);
        fullLayout._bgLayer = fullLayout._paper.append("g").classed("bglayer", true);
        fullLayout._draggers = fullLayout._paper.append("g").classed("draglayer", true);
        var layerBelow = fullLayout._paper.append("g").classed("layer-below", true);
        fullLayout._imageLowerLayer = layerBelow.append("g").classed("imagelayer", true);
        fullLayout._shapeLowerLayer = layerBelow.append("g").classed("shapelayer", true);
        fullLayout._cartesianlayer = fullLayout._paper.append("g").classed("cartesianlayer", true);
        fullLayout._polarlayer = fullLayout._paper.append("g").classed("polarlayer", true);
        fullLayout._smithlayer = fullLayout._paper.append("g").classed("smithlayer", true);
        fullLayout._ternarylayer = fullLayout._paper.append("g").classed("ternarylayer", true);
        fullLayout._geolayer = fullLayout._paper.append("g").classed("geolayer", true);
        fullLayout._funnelarealayer = fullLayout._paper.append("g").classed("funnelarealayer", true);
        fullLayout._pielayer = fullLayout._paper.append("g").classed("pielayer", true);
        fullLayout._iciclelayer = fullLayout._paper.append("g").classed("iciclelayer", true);
        fullLayout._treemaplayer = fullLayout._paper.append("g").classed("treemaplayer", true);
        fullLayout._sunburstlayer = fullLayout._paper.append("g").classed("sunburstlayer", true);
        fullLayout._indicatorlayer = fullLayout._toppaper.append("g").classed("indicatorlayer", true);
        fullLayout._glimages = fullLayout._paper.append("g").classed("glimages", true);
        var layerAbove = fullLayout._toppaper.append("g").classed("layer-above", true);
        fullLayout._imageUpperLayer = layerAbove.append("g").classed("imagelayer", true);
        fullLayout._shapeUpperLayer = layerAbove.append("g").classed("shapelayer", true);
        fullLayout._selectionLayer = fullLayout._toppaper.append("g").classed("selectionlayer", true);
        fullLayout._infolayer = fullLayout._toppaper.append("g").classed("infolayer", true);
        fullLayout._menulayer = fullLayout._toppaper.append("g").classed("menulayer", true);
        fullLayout._zoomlayer = fullLayout._toppaper.append("g").classed("zoomlayer", true);
        fullLayout._hoverlayer = fullLayout._hoverpaper.append("g").classed("hoverlayer", true);
        fullLayout._modebardiv.classed("modebar-container", true).style("position", "absolute").style("top", "0px").style("right", "0px");
        gd.emit("plotly_framework");
      }
      exports.animate = animate;
      exports.addFrames = addFrames;
      exports.deleteFrames = deleteFrames;
      exports.addTraces = addTraces;
      exports.deleteTraces = deleteTraces;
      exports.extendTraces = extendTraces;
      exports.moveTraces = moveTraces;
      exports.prependTraces = prependTraces;
      exports.newPlot = newPlot;
      exports._doPlot = _doPlot;
      exports.purge = purge;
      exports.react = react;
      exports.redraw = redraw;
      exports.relayout = relayout;
      exports.restyle = restyle;
      exports.setPlotConfig = setPlotConfig;
      exports.update = update;
      exports._guiRelayout = guiEdit(relayout);
      exports._guiRestyle = guiEdit(restyle);
      exports._guiUpdate = guiEdit(update);
      exports._storeDirectGUIEdit = _storeDirectGUIEdit;
    }
  });

  // src/snapshot/helpers.js
  var require_helpers10 = __commonJS({
    "src/snapshot/helpers.js"(exports) {
      "use strict";
      var Registry = require_registry();
      exports.getDelay = function(fullLayout) {
        if (!fullLayout._has) return 0;
        return fullLayout._has("gl3d") || fullLayout._has("mapbox") || fullLayout._has("map") ? 500 : 0;
      };
      exports.getRedrawFunc = function(gd) {
        return function() {
          Registry.getComponentMethod("colorbar", "draw")(gd);
        };
      };
      exports.encodeSVG = function(svg) {
        return "data:image/svg+xml," + encodeURIComponent(svg);
      };
      exports.encodeJSON = function(json) {
        return "data:application/json," + encodeURIComponent(json);
      };
      var DOM_URL = window.URL || window.webkitURL;
      exports.createObjectURL = function(blob) {
        return DOM_URL.createObjectURL(blob);
      };
      exports.revokeObjectURL = function(url) {
        return DOM_URL.revokeObjectURL(url);
      };
      exports.createBlob = function(url, format) {
        if (format === "svg") {
          return new window.Blob([url], { type: "image/svg+xml;charset=utf-8" });
        } else if (format === "full-json") {
          return new window.Blob([url], { type: "application/json;charset=utf-8" });
        } else {
          var binary = fixBinary(window.atob(url));
          return new window.Blob([binary], { type: "image/" + format });
        }
      };
      exports.octetStream = function(s) {
        document.location.href = "data:application/octet-stream" + s;
      };
      function fixBinary(b) {
        var len = b.length;
        var buf = new ArrayBuffer(len);
        var arr = new Uint8Array(buf);
        for (var i = 0; i < len; i++) {
          arr[i] = b.charCodeAt(i);
        }
        return buf;
      }
      exports.IMAGE_URL_PREFIX = /^data:image\/\w+;base64,/;
    }
  });

  // src/snapshot/tosvg.js
  var require_tosvg = __commonJS({
    "src/snapshot/tosvg.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var Drawing = require_drawing();
      var Color = require_color();
      var xmlnsNamespaces = require_xmlns_namespaces();
      var DOUBLEQUOTE_REGEX = /"/g;
      var DUMMY_SUB = "TOBESTRIPPED";
      var DUMMY_REGEX = new RegExp('("' + DUMMY_SUB + ")|(" + DUMMY_SUB + '")', "g");
      function htmlEntityDecode(s) {
        var hiddenDiv = d3.select("body").append("div").style({ display: "none" }).html("");
        var replaced = s.replace(/(&[^;]*;)/gi, function(d) {
          if (d === "&lt;") {
            return "&#60;";
          }
          if (d === "&rt;") {
            return "&#62;";
          }
          if (d.indexOf("<") !== -1 || d.indexOf(">") !== -1) {
            return "";
          }
          return hiddenDiv.html(d).text();
        });
        hiddenDiv.remove();
        return replaced;
      }
      function xmlEntityEncode(str) {
        return str.replace(/&(?!\w+;|\#[0-9]+;| \#x[0-9A-F]+;)/g, "&amp;");
      }
      module.exports = function toSVG(gd, format, scale) {
        var fullLayout = gd._fullLayout;
        var svg = fullLayout._paper;
        var toppaper = fullLayout._toppaper;
        var width = fullLayout.width;
        var height = fullLayout.height;
        var i;
        svg.insert("rect", ":first-child").call(Drawing.setRect, 0, 0, width, height).call(Color.fill, fullLayout.paper_bgcolor);
        var basePlotModules = fullLayout._basePlotModules || [];
        for (i = 0; i < basePlotModules.length; i++) {
          var _module = basePlotModules[i];
          if (_module.toSVG) _module.toSVG(gd);
        }
        if (toppaper) {
          var nodes = toppaper.node().childNodes;
          var topGroups = Array.prototype.slice.call(nodes);
          for (i = 0; i < topGroups.length; i++) {
            var topGroup = topGroups[i];
            if (topGroup.childNodes.length) svg.node().appendChild(topGroup);
          }
        }
        if (fullLayout._draggers) {
          fullLayout._draggers.remove();
        }
        svg.node().style.background = "";
        svg.selectAll("text").attr({ "data-unformatted": null, "data-math": null }).each(function() {
          var txt = d3.select(this);
          if (this.style.visibility === "hidden" || this.style.display === "none") {
            txt.remove();
            return;
          } else {
            txt.style({ visibility: null, display: null });
          }
          var ff = this.style.fontFamily;
          if (ff && ff.indexOf('"') !== -1) {
            txt.style("font-family", ff.replace(DOUBLEQUOTE_REGEX, DUMMY_SUB));
          }
          var fw = this.style.fontWeight;
          if (fw && (fw === "normal" || fw === "400")) {
            txt.style("font-weight", void 0);
          }
          var fs = this.style.fontStyle;
          if (fs && fs === "normal") {
            txt.style("font-style", void 0);
          }
          var fv = this.style.fontVariant;
          if (fv && fv === "normal") {
            txt.style("font-variant", void 0);
          }
        });
        svg.selectAll(".gradient_filled,.pattern_filled").each(function() {
          var pt = d3.select(this);
          var fill = this.style.fill;
          if (fill && fill.indexOf("url(") !== -1) {
            pt.style("fill", fill.replace(DOUBLEQUOTE_REGEX, DUMMY_SUB));
          }
          var stroke = this.style.stroke;
          if (stroke && stroke.indexOf("url(") !== -1) {
            pt.style("stroke", stroke.replace(DOUBLEQUOTE_REGEX, DUMMY_SUB));
          }
        });
        if (format === "pdf" || format === "eps") {
          svg.selectAll("#MathJax_SVG_glyphs path").attr("stroke-width", 0);
        }
        if (format === "svg" && scale) {
          svg.attr("width", scale * width);
          svg.attr("height", scale * height);
          svg.attr("viewBox", "0 0 " + width + " " + height);
        }
        var s = new window.XMLSerializer().serializeToString(svg.node());
        s = htmlEntityDecode(s);
        s = xmlEntityEncode(s);
        s = s.replace(DUMMY_REGEX, "'");
        return s;
      };
    }
  });

  // src/snapshot/svgtoimg.js
  var require_svgtoimg = __commonJS({
    "src/snapshot/svgtoimg.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var EventEmitter = require_events().EventEmitter;
      var helpers = require_helpers10();
      function svgToImg(opts) {
        var ev = opts.emitter || new EventEmitter();
        var promise = new Promise(function(resolve, reject) {
          var Image2 = window.Image;
          var svg = opts.svg;
          var format = opts.format || "png";
          var canvas = opts.canvas;
          var scale = opts.scale || 1;
          var w0 = opts.width || 300;
          var h0 = opts.height || 150;
          var w1 = scale * w0;
          var h1 = scale * h0;
          var ctx = canvas.getContext("2d", { willReadFrequently: true });
          var img = new Image2();
          var svgBlob, url;
          if (format === "svg" || Lib.isSafari()) {
            url = helpers.encodeSVG(svg);
          } else {
            svgBlob = helpers.createBlob(svg, "svg");
            url = helpers.createObjectURL(svgBlob);
          }
          canvas.width = w1;
          canvas.height = h1;
          img.onload = function() {
            var imgData;
            svgBlob = null;
            helpers.revokeObjectURL(url);
            if (format !== "svg") {
              ctx.drawImage(img, 0, 0, w1, h1);
            }
            switch (format) {
              case "jpeg":
                imgData = canvas.toDataURL("image/jpeg");
                break;
              case "png":
                imgData = canvas.toDataURL("image/png");
                break;
              case "webp":
                imgData = canvas.toDataURL("image/webp");
                break;
              case "svg":
                imgData = url;
                break;
              default:
                var errorMsg = "Image format is not jpeg, png, svg or webp.";
                reject(new Error(errorMsg));
                if (!opts.promise) {
                  return ev.emit("error", errorMsg);
                }
            }
            resolve(imgData);
            if (!opts.promise) {
              ev.emit("success", imgData);
            }
          };
          img.onerror = function(err) {
            svgBlob = null;
            helpers.revokeObjectURL(url);
            reject(err);
            if (!opts.promise) {
              return ev.emit("error", err);
            }
          };
          img.src = url;
        });
        if (opts.promise) {
          return promise;
        }
        return ev;
      }
      module.exports = svgToImg;
    }
  });

  // src/plot_api/to_image.js
  var require_to_image = __commonJS({
    "src/plot_api/to_image.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var plotApi = require_plot_api();
      var plots = require_plots();
      var Lib = require_lib();
      var helpers = require_helpers10();
      var toSVG = require_tosvg();
      var svgToImg = require_svgtoimg();
      var version = require_version().version;
      var attrs = {
        format: {
          valType: "enumerated",
          values: ["png", "jpeg", "webp", "svg", "full-json"],
          dflt: "png"
        },
        width: {
          valType: "number",
          min: 1
        },
        height: {
          valType: "number",
          min: 1
        },
        scale: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        setBackground: {
          valType: "any",
          dflt: false
        },
        imageDataOnly: {
          valType: "boolean",
          dflt: false
        }
      };
      function toImage(gd, opts) {
        opts = opts || {};
        var data;
        var layout;
        var config;
        var fullLayout;
        if (Lib.isPlainObject(gd)) {
          data = gd.data || [];
          layout = gd.layout || {};
          config = gd.config || {};
          fullLayout = {};
        } else {
          gd = Lib.getGraphDiv(gd);
          data = Lib.extendDeep([], gd.data);
          layout = Lib.extendDeep({}, gd.layout);
          config = gd._context;
          fullLayout = gd._fullLayout || {};
        }
        function isImpliedOrValid(attr) {
          return !(attr in opts) || Lib.validate(opts[attr], attrs[attr]);
        }
        if (!isImpliedOrValid("width") && opts.width !== null || !isImpliedOrValid("height") && opts.height !== null) {
          throw new Error("Height and width should be pixel values.");
        }
        if (!isImpliedOrValid("format")) {
          throw new Error("Export format is not " + Lib.join2(attrs.format.values, ", ", " or ") + ".");
        }
        var fullOpts = {};
        function coerce(attr, dflt) {
          return Lib.coerce(opts, fullOpts, attrs, attr, dflt);
        }
        var format = coerce("format");
        var width = coerce("width");
        var height = coerce("height");
        var scale = coerce("scale");
        var setBackground = coerce("setBackground");
        var imageDataOnly = coerce("imageDataOnly");
        var clonedGd = document.createElement("div");
        clonedGd.style.position = "absolute";
        clonedGd.style.left = "-5000px";
        document.body.appendChild(clonedGd);
        var layoutImage = Lib.extendFlat({}, layout);
        if (width) {
          layoutImage.width = width;
        } else if (opts.width === null && isNumeric(fullLayout.width)) {
          layoutImage.width = fullLayout.width;
        }
        if (height) {
          layoutImage.height = height;
        } else if (opts.height === null && isNumeric(fullLayout.height)) {
          layoutImage.height = fullLayout.height;
        }
        var configImage = Lib.extendFlat({}, config, {
          _exportedPlot: true,
          staticPlot: true,
          setBackground
        });
        var redrawFunc = helpers.getRedrawFunc(clonedGd);
        function wait() {
          return new Promise(function(resolve) {
            setTimeout(resolve, helpers.getDelay(clonedGd._fullLayout));
          });
        }
        function convert() {
          return new Promise(function(resolve, reject) {
            var svg = toSVG(clonedGd, format, scale);
            var width2 = clonedGd._fullLayout.width;
            var height2 = clonedGd._fullLayout.height;
            function cleanup() {
              plotApi.purge(clonedGd);
              document.body.removeChild(clonedGd);
            }
            if (format === "full-json") {
              var json = plots.graphJson(clonedGd, false, "keepdata", "object", true, true);
              json.version = version;
              json = JSON.stringify(json);
              cleanup();
              if (imageDataOnly) {
                return resolve(json);
              } else {
                return resolve(helpers.encodeJSON(json));
              }
            }
            cleanup();
            if (format === "svg") {
              if (imageDataOnly) {
                return resolve(svg);
              } else {
                return resolve(helpers.encodeSVG(svg));
              }
            }
            var canvas = document.createElement("canvas");
            canvas.id = Lib.randstr();
            svgToImg({
              format,
              width: width2,
              height: height2,
              scale,
              canvas,
              svg,
              // ask svgToImg to return a Promise
              //  rather than EventEmitter
              //  leave EventEmitter for backward
              //  compatibility
              promise: true
            }).then(resolve).catch(reject);
          });
        }
        function urlToImageData(url) {
          if (imageDataOnly) {
            return url.replace(helpers.IMAGE_URL_PREFIX, "");
          } else {
            return url;
          }
        }
        return new Promise(function(resolve, reject) {
          plotApi.newPlot(clonedGd, data, layoutImage, configImage).then(redrawFunc).then(wait).then(convert).then(function(url) {
            resolve(urlToImageData(url));
          }).catch(function(err) {
            reject(err);
          });
        });
      }
      module.exports = toImage;
    }
  });

  // src/plot_api/validate.js
  var require_validate = __commonJS({
    "src/plot_api/validate.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Plots = require_plots();
      var PlotSchema = require_plot_schema();
      var dfltConfig = require_plot_config().dfltConfig;
      var isPlainObject = Lib.isPlainObject;
      var isArray = Array.isArray;
      var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
      module.exports = function validate(data, layout) {
        if (data === void 0) data = [];
        if (layout === void 0) layout = {};
        var schema = PlotSchema.get();
        var errorList = [];
        var gd = { _context: Lib.extendFlat({}, dfltConfig) };
        var dataIn, layoutIn;
        if (isArray(data)) {
          gd.data = Lib.extendDeep([], data);
          dataIn = data;
        } else {
          gd.data = [];
          dataIn = [];
          errorList.push(format("array", "data"));
        }
        if (isPlainObject(layout)) {
          gd.layout = Lib.extendDeep({}, layout);
          layoutIn = layout;
        } else {
          gd.layout = {};
          layoutIn = {};
          if (arguments.length > 1) {
            errorList.push(format("object", "layout"));
          }
        }
        Plots.supplyDefaults(gd);
        var dataOut = gd._fullData;
        var len = dataIn.length;
        for (var i = 0; i < len; i++) {
          var traceIn = dataIn[i];
          var base = ["data", i];
          if (!isPlainObject(traceIn)) {
            errorList.push(format("object", base));
            continue;
          }
          var traceOut = dataOut[i];
          var traceType = traceOut.type;
          var traceSchema = schema.traces[traceType].attributes;
          traceSchema.type = {
            valType: "enumerated",
            values: [traceType]
          };
          if (traceOut.visible === false && traceIn.visible !== false) {
            errorList.push(format("invisible", base));
          }
          crawl(traceIn, traceOut, traceSchema, errorList, base);
        }
        var layoutOut = gd._fullLayout;
        var layoutSchema = fillLayoutSchema(schema, dataOut);
        crawl(layoutIn, layoutOut, layoutSchema, errorList, "layout");
        return errorList.length === 0 ? void 0 : errorList;
      };
      function crawl(objIn, objOut, schema, list, base, path) {
        path = path || [];
        var keys = Object.keys(objIn);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var p = path.slice();
          p.push(k);
          var valIn = objIn[k];
          var valOut = objOut[k];
          var nestedSchema = getNestedSchema(schema, k);
          var nestedValType = (nestedSchema || {}).valType;
          var isInfoArray = nestedValType === "info_array";
          var isColorscale = nestedValType === "colorscale";
          var items = (nestedSchema || {}).items;
          if (!isInSchema(schema, k)) {
            list.push(format("schema", base, p));
          } else if (isPlainObject(valIn) && isPlainObject(valOut) && nestedValType !== "any") {
            crawl(valIn, valOut, nestedSchema, list, base, p);
          } else if (isInfoArray && isArray(valIn)) {
            if (valIn.length > valOut.length) {
              list.push(format("unused", base, p.concat(valOut.length)));
            }
            var len = valOut.length;
            var arrayItems = Array.isArray(items);
            if (arrayItems) len = Math.min(len, items.length);
            var m, n, item, valInPart, valOutPart;
            if (nestedSchema.dimensions === 2) {
              for (n = 0; n < len; n++) {
                if (isArray(valIn[n])) {
                  if (valIn[n].length > valOut[n].length) {
                    list.push(format("unused", base, p.concat(n, valOut[n].length)));
                  }
                  var len2 = valOut[n].length;
                  for (m = 0; m < (arrayItems ? Math.min(len2, items[n].length) : len2); m++) {
                    item = arrayItems ? items[n][m] : items;
                    valInPart = valIn[n][m];
                    valOutPart = valOut[n][m];
                    if (!Lib.validate(valInPart, item)) {
                      list.push(format("value", base, p.concat(n, m), valInPart));
                    } else if (valOutPart !== valInPart && valOutPart !== +valInPart) {
                      list.push(format("dynamic", base, p.concat(n, m), valInPart, valOutPart));
                    }
                  }
                } else {
                  list.push(format("array", base, p.concat(n), valIn[n]));
                }
              }
            } else {
              for (n = 0; n < len; n++) {
                item = arrayItems ? items[n] : items;
                valInPart = valIn[n];
                valOutPart = valOut[n];
                if (!Lib.validate(valInPart, item)) {
                  list.push(format("value", base, p.concat(n), valInPart));
                } else if (valOutPart !== valInPart && valOutPart !== +valInPart) {
                  list.push(format("dynamic", base, p.concat(n), valInPart, valOutPart));
                }
              }
            }
          } else if (nestedSchema.items && !isInfoArray && isArray(valIn)) {
            var _nestedSchema = items[Object.keys(items)[0]];
            var indexList = [];
            var j, _p;
            for (j = 0; j < valOut.length; j++) {
              var _index = valOut[j]._index || j;
              _p = p.slice();
              _p.push(_index);
              if (isPlainObject(valIn[_index]) && isPlainObject(valOut[j])) {
                indexList.push(_index);
                var valInj = valIn[_index];
                var valOutj = valOut[j];
                if (isPlainObject(valInj) && valInj.visible !== false && valOutj.visible === false) {
                  list.push(format("invisible", base, _p));
                } else crawl(valInj, valOutj, _nestedSchema, list, base, _p);
              }
            }
            for (j = 0; j < valIn.length; j++) {
              _p = p.slice();
              _p.push(j);
              if (!isPlainObject(valIn[j])) {
                list.push(format("object", base, _p, valIn[j]));
              } else if (indexList.indexOf(j) === -1) {
                list.push(format("unused", base, _p));
              }
            }
          } else if (!isPlainObject(valIn) && isPlainObject(valOut)) {
            list.push(format("object", base, p, valIn));
          } else if (!isArrayOrTypedArray(valIn) && isArrayOrTypedArray(valOut) && !isInfoArray && !isColorscale) {
            list.push(format("array", base, p, valIn));
          } else if (!(k in objOut)) {
            list.push(format("unused", base, p, valIn));
          } else if (!Lib.validate(valIn, nestedSchema)) {
            list.push(format("value", base, p, valIn));
          } else if (nestedSchema.valType === "enumerated" && (nestedSchema.coerceNumber && valIn !== +valOut || valIn !== valOut)) {
            list.push(format("dynamic", base, p, valIn, valOut));
          }
        }
        return list;
      }
      function fillLayoutSchema(schema, dataOut) {
        var layoutSchema = schema.layout.layoutAttributes;
        for (var i = 0; i < dataOut.length; i++) {
          var traceOut = dataOut[i];
          var traceSchema = schema.traces[traceOut.type];
          var traceLayoutAttr = traceSchema.layoutAttributes;
          if (traceLayoutAttr) {
            if (traceOut.subplot) {
              Lib.extendFlat(layoutSchema[traceSchema.attributes.subplot.dflt], traceLayoutAttr);
            } else {
              Lib.extendFlat(layoutSchema, traceLayoutAttr);
            }
          }
        }
        return layoutSchema;
      }
      var code2msgFunc = {
        object: function(base, astr) {
          var prefix;
          if (base === "layout" && astr === "") prefix = "The layout argument";
          else if (base[0] === "data" && astr === "") {
            prefix = "Trace " + base[1] + " in the data argument";
          } else prefix = inBase(base) + "key " + astr;
          return prefix + " must be linked to an object container";
        },
        array: function(base, astr) {
          var prefix;
          if (base === "data") prefix = "The data argument";
          else prefix = inBase(base) + "key " + astr;
          return prefix + " must be linked to an array container";
        },
        schema: function(base, astr) {
          return inBase(base) + "key " + astr + " is not part of the schema";
        },
        unused: function(base, astr, valIn) {
          var target = isPlainObject(valIn) ? "container" : "key";
          return inBase(base) + target + " " + astr + " did not get coerced";
        },
        dynamic: function(base, astr, valIn, valOut) {
          return [
            inBase(base) + "key",
            astr,
            "(set to '" + valIn + "')",
            "got reset to",
            "'" + valOut + "'",
            "during defaults."
          ].join(" ");
        },
        invisible: function(base, astr) {
          return (astr ? inBase(base) + "item " + astr : "Trace " + base[1]) + " got defaulted to be not visible";
        },
        value: function(base, astr, valIn) {
          return [
            inBase(base) + "key " + astr,
            "is set to an invalid value (" + valIn + ")"
          ].join(" ");
        }
      };
      function inBase(base) {
        if (isArray(base)) return "In data trace " + base[1] + ", ";
        return "In " + base + ", ";
      }
      function format(code, base, path, valIn, valOut) {
        path = path || "";
        var container, trace;
        if (isArray(base)) {
          container = base[0];
          trace = base[1];
        } else {
          container = base;
          trace = null;
        }
        var astr = convertPathToAttributeString(path);
        var msg = code2msgFunc[code](base, astr, valIn, valOut);
        Lib.log(msg);
        return {
          code,
          container,
          trace,
          path,
          astr,
          msg
        };
      }
      function isInSchema(schema, key) {
        var parts = splitKey(key);
        var keyMinusId = parts.keyMinusId;
        var id = parts.id;
        if (keyMinusId in schema && schema[keyMinusId]._isSubplotObj && id) {
          return true;
        }
        return key in schema;
      }
      function getNestedSchema(schema, key) {
        if (key in schema) return schema[key];
        var parts = splitKey(key);
        return schema[parts.keyMinusId];
      }
      var idRegex = Lib.counterRegex("([a-z]+)");
      function splitKey(key) {
        var idMatch = key.match(idRegex);
        return {
          keyMinusId: idMatch && idMatch[1],
          id: idMatch && idMatch[2]
        };
      }
      function convertPathToAttributeString(path) {
        if (!isArray(path)) return String(path);
        var astr = "";
        for (var i = 0; i < path.length; i++) {
          var p = path[i];
          if (typeof p === "number") {
            astr = astr.substr(0, astr.length - 1) + "[" + p + "]";
          } else {
            astr += p;
          }
          if (i < path.length - 1) astr += ".";
        }
        return astr;
      }
    }
  });

  // src/snapshot/filesaver.js
  var require_filesaver = __commonJS({
    "src/snapshot/filesaver.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var helpers = require_helpers10();
      function fileSaver(url, name, format) {
        var saveLink = document.createElement("a");
        var canUseSaveLink = "download" in saveLink;
        var promise = new Promise(function(resolve, reject) {
          var blob;
          var objectUrl;
          if (canUseSaveLink) {
            blob = helpers.createBlob(url, format);
            objectUrl = helpers.createObjectURL(blob);
            saveLink.href = objectUrl;
            saveLink.download = name;
            document.body.appendChild(saveLink);
            saveLink.click();
            document.body.removeChild(saveLink);
            helpers.revokeObjectURL(objectUrl);
            blob = null;
            return resolve(name);
          }
          if (Lib.isSafari()) {
            var prefix = format === "svg" ? "," : ";base64,";
            helpers.octetStream(prefix + encodeURIComponent(url));
            return resolve(name);
          }
          reject(new Error("download error"));
        });
        return promise;
      }
      module.exports = fileSaver;
    }
  });

  // src/snapshot/download.js
  var require_download = __commonJS({
    "src/snapshot/download.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var toImage = require_to_image();
      var fileSaver = require_filesaver();
      var helpers = require_helpers10();
      function downloadImage(gd, opts) {
        var _gd;
        if (!Lib.isPlainObject(gd)) _gd = Lib.getGraphDiv(gd);
        opts = opts || {};
        opts.format = opts.format || "png";
        opts.width = opts.width || null;
        opts.height = opts.height || null;
        opts.imageDataOnly = true;
        return new Promise(function(resolve, reject) {
          if (_gd && _gd._snapshotInProgress) {
            reject(new Error("Snapshotting already in progress."));
          }
          if (_gd) _gd._snapshotInProgress = true;
          var promise = toImage(gd, opts);
          var filename = opts.filename || gd.fn || "newplot";
          filename += "." + opts.format.replace("-", ".");
          promise.then(function(result) {
            if (_gd) _gd._snapshotInProgress = false;
            return fileSaver(result, filename, opts.format);
          }).then(function(name) {
            resolve(name);
          }).catch(function(err) {
            if (_gd) _gd._snapshotInProgress = false;
            reject(err);
          });
        });
      }
      module.exports = downloadImage;
    }
  });

  // src/plot_api/template_api.js
  var require_template_api = __commonJS({
    "src/plot_api/template_api.js"(exports) {
      "use strict";
      var Lib = require_lib();
      var isPlainObject = Lib.isPlainObject;
      var PlotSchema = require_plot_schema();
      var Plots = require_plots();
      var plotAttributes = require_attributes2();
      var Template = require_plot_template();
      var dfltConfig = require_plot_config().dfltConfig;
      exports.makeTemplate = function(figure) {
        figure = Lib.isPlainObject(figure) ? figure : Lib.getGraphDiv(figure);
        figure = Lib.extendDeep({ _context: dfltConfig }, { data: figure.data, layout: figure.layout });
        Plots.supplyDefaults(figure);
        var data = figure.data || [];
        var layout = figure.layout || {};
        layout._basePlotModules = figure._fullLayout._basePlotModules;
        layout._modules = figure._fullLayout._modules;
        var template = {
          data: {},
          layout: {}
        };
        data.forEach(function(trace) {
          var traceTemplate = {};
          walkStyleKeys(trace, traceTemplate, getTraceInfo.bind(null, trace));
          var traceType2 = Lib.coerce(trace, {}, plotAttributes, "type");
          var typeTemplates2 = template.data[traceType2];
          if (!typeTemplates2) typeTemplates2 = template.data[traceType2] = [];
          typeTemplates2.push(traceTemplate);
        });
        walkStyleKeys(layout, template.layout, getLayoutInfo.bind(null, layout));
        delete template.layout.template;
        var oldTemplate = layout.template;
        if (isPlainObject(oldTemplate)) {
          var oldLayoutTemplate = oldTemplate.layout;
          var i, traceType, oldTypeTemplates, oldTypeLen, typeTemplates, typeLen;
          if (isPlainObject(oldLayoutTemplate)) {
            mergeTemplates(oldLayoutTemplate, template.layout);
          }
          var oldDataTemplate = oldTemplate.data;
          if (isPlainObject(oldDataTemplate)) {
            for (traceType in template.data) {
              oldTypeTemplates = oldDataTemplate[traceType];
              if (Array.isArray(oldTypeTemplates)) {
                typeTemplates = template.data[traceType];
                typeLen = typeTemplates.length;
                oldTypeLen = oldTypeTemplates.length;
                for (i = 0; i < typeLen; i++) {
                  mergeTemplates(oldTypeTemplates[i % oldTypeLen], typeTemplates[i]);
                }
                for (i = typeLen; i < oldTypeLen; i++) {
                  typeTemplates.push(Lib.extendDeep({}, oldTypeTemplates[i]));
                }
              }
            }
            for (traceType in oldDataTemplate) {
              if (!(traceType in template.data)) {
                template.data[traceType] = Lib.extendDeep([], oldDataTemplate[traceType]);
              }
            }
          }
        }
        return template;
      };
      function mergeTemplates(oldTemplate, newTemplate) {
        oldTemplate = Lib.extendDeep({}, oldTemplate);
        var oldKeys = Object.keys(oldTemplate).sort();
        var i, j;
        function mergeOne(oldVal2, newVal, key3) {
          if (isPlainObject(newVal) && isPlainObject(oldVal2)) {
            mergeTemplates(oldVal2, newVal);
          } else if (Array.isArray(newVal) && Array.isArray(oldVal2)) {
            var templater = Template.arrayTemplater({ _template: oldTemplate }, key3);
            for (j = 0; j < newVal.length; j++) {
              var item = newVal[j];
              var oldItem = templater.newItem(item)._template;
              if (oldItem) mergeTemplates(oldItem, item);
            }
            var defaultItems = templater.defaultItems();
            for (j = 0; j < defaultItems.length; j++) newVal.push(defaultItems[j]._template);
            for (j = 0; j < newVal.length; j++) delete newVal[j].templateitemname;
          }
        }
        for (i = 0; i < oldKeys.length; i++) {
          var key = oldKeys[i];
          var oldVal = oldTemplate[key];
          if (key in newTemplate) {
            mergeOne(oldVal, newTemplate[key], key);
          } else newTemplate[key] = oldVal;
          if (getBaseKey(key) === key) {
            for (var key2 in newTemplate) {
              var baseKey2 = getBaseKey(key2);
              if (key2 !== baseKey2 && baseKey2 === key && !(key2 in oldTemplate)) {
                mergeOne(oldVal, newTemplate[key2], key);
              }
            }
          }
        }
      }
      function getBaseKey(key) {
        return key.replace(/[0-9]+$/, "");
      }
      function walkStyleKeys(parent, templateOut, getAttributeInfo, path, basePath) {
        var pathAttr = basePath && getAttributeInfo(basePath);
        for (var key in parent) {
          var child = parent[key];
          var nextPath = getNextPath(parent, key, path);
          var nextBasePath = getNextPath(parent, key, basePath);
          var attr = getAttributeInfo(nextBasePath);
          if (!attr) {
            var baseKey = getBaseKey(key);
            if (baseKey !== key) {
              nextBasePath = getNextPath(parent, baseKey, basePath);
              attr = getAttributeInfo(nextBasePath);
            }
          }
          if (pathAttr && pathAttr === attr) continue;
          if (!attr || attr._noTemplating || attr.valType === "data_array" || attr.arrayOk && Array.isArray(child)) {
            continue;
          }
          if (!attr.valType && isPlainObject(child)) {
            walkStyleKeys(child, templateOut, getAttributeInfo, nextPath, nextBasePath);
          } else if (attr._isLinkedToArray && Array.isArray(child)) {
            var dfltDone = false;
            var namedIndex = 0;
            var usedNames = {};
            for (var i = 0; i < child.length; i++) {
              var item = child[i];
              if (isPlainObject(item)) {
                var name = item.name;
                if (name) {
                  if (!usedNames[name]) {
                    walkStyleKeys(
                      item,
                      templateOut,
                      getAttributeInfo,
                      getNextPath(child, namedIndex, nextPath),
                      getNextPath(child, namedIndex, nextBasePath)
                    );
                    namedIndex++;
                    usedNames[name] = 1;
                  }
                } else if (!dfltDone) {
                  var dfltKey = Template.arrayDefaultKey(key);
                  var dfltPath = getNextPath(parent, dfltKey, path);
                  var pathInArray = getNextPath(child, namedIndex, nextPath);
                  walkStyleKeys(
                    item,
                    templateOut,
                    getAttributeInfo,
                    pathInArray,
                    getNextPath(child, namedIndex, nextBasePath)
                  );
                  var itemPropInArray = Lib.nestedProperty(templateOut, pathInArray);
                  var dfltProp = Lib.nestedProperty(templateOut, dfltPath);
                  dfltProp.set(itemPropInArray.get());
                  itemPropInArray.set(null);
                  dfltDone = true;
                }
              }
            }
          } else {
            var templateProp = Lib.nestedProperty(templateOut, nextPath);
            templateProp.set(child);
          }
        }
      }
      function getLayoutInfo(layout, path) {
        return PlotSchema.getLayoutValObject(
          layout,
          Lib.nestedProperty({}, path).parts
        );
      }
      function getTraceInfo(trace, path) {
        return PlotSchema.getTraceValObject(
          trace,
          Lib.nestedProperty({}, path).parts
        );
      }
      function getNextPath(parent, key, path) {
        var nextPath;
        if (!path) nextPath = key;
        else if (Array.isArray(parent)) nextPath = path + "[" + key + "]";
        else nextPath = path + "." + key;
        return nextPath;
      }
      exports.validateTemplate = function(figureIn, template) {
        var figure = Lib.extendDeep({}, {
          _context: dfltConfig,
          data: figureIn.data,
          layout: figureIn.layout
        });
        var layout = figure.layout || {};
        if (!isPlainObject(template)) template = layout.template || {};
        var layoutTemplate = template.layout;
        var dataTemplate = template.data;
        var errorList = [];
        figure.layout = layout;
        figure.layout.template = template;
        Plots.supplyDefaults(figure);
        var fullLayout = figure._fullLayout;
        var fullData = figure._fullData;
        var layoutPaths = {};
        function crawlLayoutForContainers(obj, paths) {
          for (var key in obj) {
            if (key.charAt(0) !== "_" && isPlainObject(obj[key])) {
              var baseKey = getBaseKey(key);
              var nextPaths = [];
              var i2;
              for (i2 = 0; i2 < paths.length; i2++) {
                nextPaths.push(getNextPath(obj, key, paths[i2]));
                if (baseKey !== key) nextPaths.push(getNextPath(obj, baseKey, paths[i2]));
              }
              for (i2 = 0; i2 < nextPaths.length; i2++) {
                layoutPaths[nextPaths[i2]] = 1;
              }
              crawlLayoutForContainers(obj[key], nextPaths);
            }
          }
        }
        function crawlLayoutTemplateForContainers(obj, path) {
          for (var key in obj) {
            if (key.indexOf("defaults") === -1 && isPlainObject(obj[key])) {
              var nextPath = getNextPath(obj, key, path);
              if (layoutPaths[nextPath]) {
                crawlLayoutTemplateForContainers(obj[key], nextPath);
              } else {
                errorList.push({ code: "unused", path: nextPath });
              }
            }
          }
        }
        if (!isPlainObject(layoutTemplate)) {
          errorList.push({ code: "layout" });
        } else {
          crawlLayoutForContainers(fullLayout, ["layout"]);
          crawlLayoutTemplateForContainers(layoutTemplate, "layout");
        }
        if (!isPlainObject(dataTemplate)) {
          errorList.push({ code: "data" });
        } else {
          var typeCount = {};
          var traceType;
          for (var i = 0; i < fullData.length; i++) {
            var fullTrace = fullData[i];
            traceType = fullTrace.type;
            typeCount[traceType] = (typeCount[traceType] || 0) + 1;
            if (!fullTrace._fullInput._template) {
              errorList.push({
                code: "missing",
                index: fullTrace.index,
                traceType
              });
            }
          }
          for (traceType in dataTemplate) {
            var templateCount = dataTemplate[traceType].length;
            var dataCount = typeCount[traceType] || 0;
            if (templateCount > dataCount) {
              errorList.push({
                code: "unused",
                traceType,
                templateCount,
                dataCount
              });
            } else if (dataCount > templateCount) {
              errorList.push({
                code: "reused",
                traceType,
                templateCount,
                dataCount
              });
            }
          }
        }
        function crawlForMissingTemplates(obj, path) {
          for (var key in obj) {
            if (key.charAt(0) === "_") continue;
            var val = obj[key];
            var nextPath = getNextPath(obj, key, path);
            if (isPlainObject(val)) {
              if (Array.isArray(obj) && val._template === false && val.templateitemname) {
                errorList.push({
                  code: "missing",
                  path: nextPath,
                  templateitemname: val.templateitemname
                });
              }
              crawlForMissingTemplates(val, nextPath);
            } else if (Array.isArray(val) && hasPlainObject(val)) {
              crawlForMissingTemplates(val, nextPath);
            }
          }
        }
        crawlForMissingTemplates({ data: fullData, layout: fullLayout }, "");
        if (errorList.length) return errorList.map(format);
      };
      function hasPlainObject(arr) {
        for (var i = 0; i < arr.length; i++) {
          if (isPlainObject(arr[i])) return true;
        }
      }
      function format(opts) {
        var msg;
        switch (opts.code) {
          case "data":
            msg = "The template has no key data.";
            break;
          case "layout":
            msg = "The template has no key layout.";
            break;
          case "missing":
            if (opts.path) {
              msg = "There are no templates for item " + opts.path + " with name " + opts.templateitemname;
            } else {
              msg = "There are no templates for trace " + opts.index + ", of type " + opts.traceType + ".";
            }
            break;
          case "unused":
            if (opts.path) {
              msg = "The template item at " + opts.path + " was not used in constructing the plot.";
            } else if (opts.dataCount) {
              msg = "Some of the templates of type " + opts.traceType + " were not used. The template has " + opts.templateCount + " traces, the data only has " + opts.dataCount + " of this type.";
            } else {
              msg = "The template has " + opts.templateCount + " traces of type " + opts.traceType + " but there are none in the data.";
            }
            break;
          case "reused":
            msg = "Some of the templates of type " + opts.traceType + " were used more than once. The template has " + opts.templateCount + " traces, the data has " + opts.dataCount + " of this type.";
            break;
        }
        opts.msg = msg;
        return opts;
      }
    }
  });

  // src/plot_api/index.js
  var require_plot_api2 = __commonJS({
    "src/plot_api/index.js"(exports) {
      "use strict";
      var main = require_plot_api();
      exports._doPlot = main._doPlot;
      exports.newPlot = main.newPlot;
      exports.restyle = main.restyle;
      exports.relayout = main.relayout;
      exports.redraw = main.redraw;
      exports.update = main.update;
      exports._guiRestyle = main._guiRestyle;
      exports._guiRelayout = main._guiRelayout;
      exports._guiUpdate = main._guiUpdate;
      exports._storeDirectGUIEdit = main._storeDirectGUIEdit;
      exports.react = main.react;
      exports.extendTraces = main.extendTraces;
      exports.prependTraces = main.prependTraces;
      exports.addTraces = main.addTraces;
      exports.deleteTraces = main.deleteTraces;
      exports.moveTraces = main.moveTraces;
      exports.purge = main.purge;
      exports.addFrames = main.addFrames;
      exports.deleteFrames = main.deleteFrames;
      exports.animate = main.animate;
      exports.setPlotConfig = main.setPlotConfig;
      var getGraphDiv = require_dom().getGraphDiv;
      var eraseActiveShape = require_draw2().eraseActiveShape;
      exports.deleteActiveShape = function(gd) {
        return eraseActiveShape(getGraphDiv(gd));
      };
      exports.toImage = require_to_image();
      exports.validate = require_validate();
      exports.downloadImage = require_download();
      var templateApi = require_template_api();
      exports.makeTemplate = templateApi.makeTemplate;
      exports.validateTemplate = templateApi.validateTemplate;
    }
  });

  // src/traces/scatter/xy_defaults.js
  var require_xy_defaults = __commonJS({
    "src/traces/scatter/xy_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Registry = require_registry();
      module.exports = function handleXYDefaults(traceIn, traceOut, layout, coerce) {
        var x = coerce("x");
        var y = coerce("y");
        var len;
        var handleCalendarDefaults = Registry.getComponentMethod("calendars", "handleTraceDefaults");
        handleCalendarDefaults(traceIn, traceOut, ["x", "y"], layout);
        if (x) {
          var xlen = Lib.minRowLength(x);
          if (y) {
            len = Math.min(xlen, Lib.minRowLength(y));
          } else {
            len = xlen;
            coerce("y0");
            coerce("dy");
          }
        } else {
          if (!y) return 0;
          len = Lib.minRowLength(y);
          coerce("x0");
          coerce("dx");
        }
        traceOut._length = len;
        return len;
      };
    }
  });

  // src/traces/scatter/period_defaults.js
  var require_period_defaults = __commonJS({
    "src/traces/scatter/period_defaults.js"(exports, module) {
      "use strict";
      var dateTick0 = require_lib().dateTick0;
      var numConstants = require_numerical();
      var ONEWEEK = numConstants.ONEWEEK;
      function getPeriod0Dflt(period, calendar) {
        if (period % ONEWEEK === 0) {
          return dateTick0(calendar, 1);
        }
        return dateTick0(calendar, 0);
      }
      module.exports = function handlePeriodDefaults(traceIn, traceOut, layout, coerce, opts) {
        if (!opts) {
          opts = {
            x: true,
            y: true
          };
        }
        if (opts.x) {
          var xperiod = coerce("xperiod");
          if (xperiod) {
            coerce("xperiod0", getPeriod0Dflt(xperiod, traceOut.xcalendar));
            coerce("xperiodalignment");
          }
        }
        if (opts.y) {
          var yperiod = coerce("yperiod");
          if (yperiod) {
            coerce("yperiod0", getPeriod0Dflt(yperiod, traceOut.ycalendar));
            coerce("yperiodalignment");
          }
        }
      };
    }
  });

  // src/traces/scatter/stack_defaults.js
  var require_stack_defaults = __commonJS({
    "src/traces/scatter/stack_defaults.js"(exports, module) {
      "use strict";
      var perStackAttrs = ["orientation", "groupnorm", "stackgaps"];
      module.exports = function handleStackDefaults(traceIn, traceOut, layout, coerce) {
        var stackOpts = layout._scatterStackOpts;
        var stackGroup = coerce("stackgroup");
        if (stackGroup) {
          var subplot = traceOut.xaxis + traceOut.yaxis;
          var subplotStackOpts = stackOpts[subplot];
          if (!subplotStackOpts) subplotStackOpts = stackOpts[subplot] = {};
          var groupOpts = subplotStackOpts[stackGroup];
          var firstTrace = false;
          if (groupOpts) {
            groupOpts.traces.push(traceOut);
          } else {
            groupOpts = subplotStackOpts[stackGroup] = {
              // keep track of trace indices for use during stacking calculations
              // this will be filled in during `calc` and used during `crossTraceCalc`
              // so it's OK if we don't recreate it during a non-calc edit
              traceIndices: [],
              // Hold on to the whole set of prior traces
              // First one is most important, so we can clear defaults
              // there if we find explicit values only in later traces.
              // We're only going to *use* the values stored in groupOpts,
              // but for the editor and validate we want things self-consistent
              // The full set of traces is used only to fix `fill` default if
              // we find `orientation: 'h'` beyond the first trace
              traces: [traceOut]
            };
            firstTrace = true;
          }
          var dflts = {
            orientation: traceOut.x && !traceOut.y ? "h" : "v"
          };
          for (var i = 0; i < perStackAttrs.length; i++) {
            var attr = perStackAttrs[i];
            var attrFound = attr + "Found";
            if (!groupOpts[attrFound]) {
              var traceHasAttr = traceIn[attr] !== void 0;
              var isOrientation = attr === "orientation";
              if (traceHasAttr || firstTrace) {
                groupOpts[attr] = coerce(attr, dflts[attr]);
                if (isOrientation) {
                  groupOpts.fillDflt = groupOpts[attr] === "h" ? "tonextx" : "tonexty";
                }
                if (traceHasAttr) {
                  groupOpts[attrFound] = true;
                  if (!firstTrace) {
                    delete groupOpts.traces[0][attr];
                    if (isOrientation) {
                      for (var j = 0; j < groupOpts.traces.length - 1; j++) {
                        var trace2 = groupOpts.traces[j];
                        if (trace2._input.fill !== trace2.fill) {
                          trace2.fill = groupOpts.fillDflt;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          return groupOpts;
        }
      };
    }
  });

  // src/traces/scatter/marker_defaults.js
  var require_marker_defaults = __commonJS({
    "src/traces/scatter/marker_defaults.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var hasColorscale = require_helpers().hasColorscale;
      var colorscaleDefaults = require_defaults2();
      var subTypes = require_subtypes();
      module.exports = function markerDefaults(traceIn, traceOut, defaultColor, layout, coerce, opts) {
        var isBubble = subTypes.isBubble(traceIn);
        var lineColor = (traceIn.line || {}).color;
        var defaultMLC;
        opts = opts || {};
        if (lineColor) defaultColor = lineColor;
        coerce("marker.symbol");
        coerce("marker.opacity", isBubble ? 0.7 : 1);
        coerce("marker.size");
        if (!opts.noAngle) {
          coerce("marker.angle");
          if (!opts.noAngleRef) {
            coerce("marker.angleref");
          }
          if (!opts.noStandOff) {
            coerce("marker.standoff");
          }
        }
        coerce("marker.color", defaultColor);
        if (hasColorscale(traceIn, "marker")) {
          colorscaleDefaults(traceIn, traceOut, layout, coerce, { prefix: "marker.", cLetter: "c" });
        }
        if (!opts.noSelect) {
          coerce("selected.marker.color");
          coerce("unselected.marker.color");
          coerce("selected.marker.size");
          coerce("unselected.marker.size");
        }
        if (!opts.noLine) {
          if (lineColor && !Array.isArray(lineColor) && traceOut.marker.color !== lineColor) {
            defaultMLC = lineColor;
          } else if (isBubble) defaultMLC = Color.background;
          else defaultMLC = Color.defaultLine;
          coerce("marker.line.color", defaultMLC);
          if (hasColorscale(traceIn, "marker.line")) {
            colorscaleDefaults(traceIn, traceOut, layout, coerce, { prefix: "marker.line.", cLetter: "c" });
          }
          coerce("marker.line.width", isBubble ? 1 : 0);
        }
        if (isBubble) {
          coerce("marker.sizeref");
          coerce("marker.sizemin");
          coerce("marker.sizemode");
        }
        if (opts.gradient) {
          var gradientType = coerce("marker.gradient.type");
          if (gradientType !== "none") {
            coerce("marker.gradient.color");
          }
        }
      };
    }
  });

  // src/traces/scatter/line_defaults.js
  var require_line_defaults = __commonJS({
    "src/traces/scatter/line_defaults.js"(exports, module) {
      "use strict";
      var isArrayOrTypedArray = require_lib().isArrayOrTypedArray;
      var hasColorscale = require_helpers().hasColorscale;
      var colorscaleDefaults = require_defaults2();
      module.exports = function lineDefaults(traceIn, traceOut, defaultColor, layout, coerce, opts) {
        if (!opts) opts = {};
        var markerColor = (traceIn.marker || {}).color;
        if (markerColor && markerColor._inputArray) markerColor = markerColor._inputArray;
        coerce("line.color", defaultColor);
        if (hasColorscale(traceIn, "line")) {
          colorscaleDefaults(traceIn, traceOut, layout, coerce, { prefix: "line.", cLetter: "c" });
        } else {
          var lineColorDflt = (isArrayOrTypedArray(markerColor) ? false : markerColor) || defaultColor;
          coerce("line.color", lineColorDflt);
        }
        coerce("line.width");
        if (!opts.noDash) coerce("line.dash");
        if (opts.backoff) coerce("line.backoff");
      };
    }
  });

  // src/traces/scatter/line_shape_defaults.js
  var require_line_shape_defaults = __commonJS({
    "src/traces/scatter/line_shape_defaults.js"(exports, module) {
      "use strict";
      module.exports = function handleLineShapeDefaults(traceIn, traceOut, coerce) {
        var shape = coerce("line.shape");
        if (shape === "spline") coerce("line.smoothing");
      };
    }
  });

  // src/traces/scatter/text_defaults.js
  var require_text_defaults = __commonJS({
    "src/traces/scatter/text_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function(traceIn, traceOut, layout, coerce, opts) {
        opts = opts || {};
        coerce("textposition");
        Lib.coerceFont(coerce, "textfont", opts.font || layout.font, opts);
        if (!opts.noSelect) {
          coerce("selected.textfont.color");
          coerce("unselected.textfont.color");
        }
      };
    }
  });

  // src/traces/scatter/fillcolor_defaults.js
  var require_fillcolor_defaults = __commonJS({
    "src/traces/scatter/fillcolor_defaults.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var isArrayOrTypedArray = require_lib().isArrayOrTypedArray;
      function averageColors(colorscale) {
        var color = Color.interpolate(colorscale[0][1], colorscale[1][1], 0.5);
        for (var i = 2; i < colorscale.length; i++) {
          var averageColorI = Color.interpolate(colorscale[i - 1][1], colorscale[i][1], 0.5);
          color = Color.interpolate(color, averageColorI, colorscale[i - 1][0] / colorscale[i][0]);
        }
        return color;
      }
      module.exports = function fillColorDefaults(traceIn, traceOut, defaultColor, coerce, opts) {
        if (!opts) opts = {};
        var inheritColorFromMarker = false;
        if (traceOut.marker) {
          var markerColor = traceOut.marker.color;
          var markerLineColor = (traceOut.marker.line || {}).color;
          if (markerColor && !isArrayOrTypedArray(markerColor)) {
            inheritColorFromMarker = markerColor;
          } else if (markerLineColor && !isArrayOrTypedArray(markerLineColor)) {
            inheritColorFromMarker = markerLineColor;
          }
        }
        var averageGradientColor;
        if (opts.moduleHasFillgradient) {
          var gradientOrientation = coerce("fillgradient.type");
          if (gradientOrientation !== "none") {
            coerce("fillgradient.start");
            coerce("fillgradient.stop");
            var gradientColorscale = coerce("fillgradient.colorscale");
            if (gradientColorscale) {
              averageGradientColor = averageColors(gradientColorscale);
            }
          }
        }
        coerce("fillcolor", Color.addOpacity(
          (traceOut.line || {}).color || inheritColorFromMarker || averageGradientColor || defaultColor,
          0.5
        ));
      };
    }
  });

  // src/traces/scatter/defaults.js
  var require_defaults8 = __commonJS({
    "src/traces/scatter/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Registry = require_registry();
      var attributes = require_attributes12();
      var constants = require_constants8();
      var subTypes = require_subtypes();
      var handleXYDefaults = require_xy_defaults();
      var handlePeriodDefaults = require_period_defaults();
      var handleStackDefaults = require_stack_defaults();
      var handleMarkerDefaults = require_marker_defaults();
      var handleLineDefaults = require_line_defaults();
      var handleLineShapeDefaults = require_line_shape_defaults();
      var handleTextDefaults = require_text_defaults();
      var handleFillColorDefaults = require_fillcolor_defaults();
      var coercePattern = require_lib().coercePattern;
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        var len = handleXYDefaults(traceIn, traceOut, layout, coerce);
        if (!len) traceOut.visible = false;
        if (!traceOut.visible) return;
        handlePeriodDefaults(traceIn, traceOut, layout, coerce);
        coerce("xhoverformat");
        coerce("yhoverformat");
        coerce("zorder");
        var stackGroupOpts = handleStackDefaults(traceIn, traceOut, layout, coerce);
        if (layout.scattermode === "group" && traceOut.orientation === void 0) {
          coerce("orientation", "v");
        }
        var defaultMode = !stackGroupOpts && len < constants.PTS_LINESONLY ? "lines+markers" : "lines";
        coerce("text");
        coerce("hovertext");
        coerce("mode", defaultMode);
        if (subTypes.hasMarkers(traceOut)) {
          handleMarkerDefaults(traceIn, traceOut, defaultColor, layout, coerce, { gradient: true });
        }
        if (subTypes.hasLines(traceOut)) {
          handleLineDefaults(traceIn, traceOut, defaultColor, layout, coerce, { backoff: true });
          handleLineShapeDefaults(traceIn, traceOut, coerce);
          coerce("connectgaps");
          coerce("line.simplify");
        }
        if (subTypes.hasText(traceOut)) {
          coerce("texttemplate");
          handleTextDefaults(traceIn, traceOut, layout, coerce);
        }
        var dfltHoverOn = [];
        if (subTypes.hasMarkers(traceOut) || subTypes.hasText(traceOut)) {
          coerce("cliponaxis");
          coerce("marker.maxdisplayed");
          dfltHoverOn.push("points");
        }
        coerce("fill", stackGroupOpts ? stackGroupOpts.fillDflt : "none");
        if (traceOut.fill !== "none") {
          handleFillColorDefaults(traceIn, traceOut, defaultColor, coerce, {
            moduleHasFillgradient: true
          });
          if (!subTypes.hasLines(traceOut)) handleLineShapeDefaults(traceIn, traceOut, coerce);
          coercePattern(coerce, "fillpattern", traceOut.fillcolor, false);
        }
        var lineColor = (traceOut.line || {}).color;
        var markerColor = (traceOut.marker || {}).color;
        if (traceOut.fill === "tonext" || traceOut.fill === "toself") {
          dfltHoverOn.push("fills");
        }
        coerce("hoveron", dfltHoverOn.join("+") || "points");
        if (traceOut.hoveron !== "fills") coerce("hovertemplate");
        var errorBarsSupplyDefaults = Registry.getComponentMethod("errorbars", "supplyDefaults");
        errorBarsSupplyDefaults(traceIn, traceOut, lineColor || markerColor || defaultColor, { axis: "y" });
        errorBarsSupplyDefaults(traceIn, traceOut, lineColor || markerColor || defaultColor, { axis: "x", inherit: "y" });
        Lib.coerceSelectionMarkerOpacity(traceOut, coerce);
      };
    }
  });

  // src/traces/scatter/grouping_defaults.js
  var require_grouping_defaults = __commonJS({
    "src/traces/scatter/grouping_defaults.js"(exports, module) {
      "use strict";
      var getAxisGroup = require_constraints().getAxisGroup;
      module.exports = function handleGroupingDefaults(traceIn, traceOut, fullLayout, coerce, barmode) {
        var orientation = traceOut.orientation;
        var posAxId = traceOut[{ v: "x", h: "y" }[orientation] + "axis"];
        var groupId = getAxisGroup(fullLayout, posAxId) + orientation;
        var alignmentOpts = fullLayout._alignmentOpts || {};
        var alignmentgroup = coerce("alignmentgroup");
        var alignmentGroups = alignmentOpts[groupId];
        if (!alignmentGroups) alignmentGroups = alignmentOpts[groupId] = {};
        var alignmentGroupOpts = alignmentGroups[alignmentgroup];
        if (alignmentGroupOpts) {
          alignmentGroupOpts.traces.push(traceOut);
        } else {
          alignmentGroupOpts = alignmentGroups[alignmentgroup] = {
            traces: [traceOut],
            alignmentIndex: Object.keys(alignmentGroups).length,
            offsetGroups: {}
          };
        }
        var offsetgroup = coerce("offsetgroup") || "";
        var offsetGroups = alignmentGroupOpts.offsetGroups;
        var offsetGroupOpts = offsetGroups[offsetgroup];
        traceOut._offsetIndex = 0;
        if (barmode !== "group" || offsetgroup) {
          if (!offsetGroupOpts) {
            offsetGroupOpts = offsetGroups[offsetgroup] = {
              offsetIndex: Object.keys(offsetGroups).length
            };
          }
          traceOut._offsetIndex = offsetGroupOpts.offsetIndex;
        }
      };
    }
  });

  // src/traces/scatter/cross_trace_defaults.js
  var require_cross_trace_defaults2 = __commonJS({
    "src/traces/scatter/cross_trace_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleGroupingDefaults = require_grouping_defaults();
      var attributes = require_attributes12();
      module.exports = function crossTraceDefaults(fullData, fullLayout) {
        var traceIn, traceOut, i;
        var scattermode = fullLayout.scattermode;
        function coerce(attr) {
          return Lib.coerce(traceOut._input, traceOut, attributes, attr);
        }
        if (fullLayout.scattermode === "group") {
          for (i = 0; i < fullData.length; i++) {
            traceOut = fullData[i];
            if (traceOut.type === "scatter") {
              traceIn = traceOut._input;
              handleGroupingDefaults(traceIn, traceOut, fullLayout, coerce, scattermode);
            }
          }
        }
        for (i = 0; i < fullData.length; i++) {
          var tracei = fullData[i];
          if (tracei.type !== "scatter") continue;
          var filli = tracei.fill;
          if (filli === "none" || filli === "toself") continue;
          tracei.opacity = void 0;
          if (filli === "tonexty" || filli === "tonextx") {
            for (var j = i - 1; j >= 0; j--) {
              var tracej = fullData[j];
              if (tracej.type === "scatter" && tracej.xaxis === tracei.xaxis && tracej.yaxis === tracei.yaxis) {
                tracej.opacity = void 0;
                break;
              }
            }
          }
        }
      };
    }
  });

  // src/traces/scatter/layout_defaults.js
  var require_layout_defaults3 = __commonJS({
    "src/traces/scatter/layout_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var layoutAttributes = require_layout_attributes3();
      module.exports = function(layoutIn, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
        }
        var groupBarmode = layoutOut.barmode === "group";
        if (layoutOut.scattermode === "group") {
          coerce("scattergap", groupBarmode ? layoutOut.bargap : 0.2);
        }
      };
    }
  });

  // src/plots/cartesian/align_period.js
  var require_align_period = __commonJS({
    "src/plots/cartesian/align_period.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var dateTime2ms = Lib.dateTime2ms;
      var incrementMonth = Lib.incrementMonth;
      var constants = require_numerical();
      var ONEAVGMONTH = constants.ONEAVGMONTH;
      module.exports = function alignPeriod(trace, ax, axLetter, vals) {
        if (ax.type !== "date") return { vals };
        var alignment = trace[axLetter + "periodalignment"];
        if (!alignment) return { vals };
        var period = trace[axLetter + "period"];
        var mPeriod;
        if (isNumeric(period)) {
          period = +period;
          if (period <= 0) return { vals };
        } else if (typeof period === "string" && period.charAt(0) === "M") {
          var n = +period.substring(1);
          if (n > 0 && Math.round(n) === n) {
            mPeriod = n;
          } else return { vals };
        }
        var calendar = ax.calendar;
        var isStart = "start" === alignment;
        var isEnd = "end" === alignment;
        var period0 = trace[axLetter + "period0"];
        var base = dateTime2ms(period0, calendar) || 0;
        var newVals = [];
        var starts = [];
        var ends = [];
        var len = vals.length;
        for (var i = 0; i < len; i++) {
          var v = vals[i];
          var nEstimated, startTime, endTime;
          if (mPeriod) {
            nEstimated = Math.round((v - base) / (mPeriod * ONEAVGMONTH));
            endTime = incrementMonth(base, mPeriod * nEstimated, calendar);
            while (endTime > v) {
              endTime = incrementMonth(endTime, -mPeriod, calendar);
            }
            while (endTime <= v) {
              endTime = incrementMonth(endTime, mPeriod, calendar);
            }
            startTime = incrementMonth(endTime, -mPeriod, calendar);
          } else {
            nEstimated = Math.round((v - base) / period);
            endTime = base + nEstimated * period;
            while (endTime > v) {
              endTime -= period;
            }
            while (endTime <= v) {
              endTime += period;
            }
            startTime = endTime - period;
          }
          newVals[i] = isStart ? startTime : isEnd ? endTime : (startTime + endTime) / 2;
          starts[i] = startTime;
          ends[i] = endTime;
        }
        return {
          vals: newVals,
          starts,
          ends
        };
      };
    }
  });

  // src/traces/scatter/colorscale_calc.js
  var require_colorscale_calc = __commonJS({
    "src/traces/scatter/colorscale_calc.js"(exports, module) {
      "use strict";
      var hasColorscale = require_helpers().hasColorscale;
      var calcColorscale = require_calc();
      var subTypes = require_subtypes();
      module.exports = function calcMarkerColorscale(gd, trace) {
        if (subTypes.hasLines(trace) && hasColorscale(trace, "line")) {
          calcColorscale(gd, trace, {
            vals: trace.line.color,
            containerStr: "line",
            cLetter: "c"
          });
        }
        if (subTypes.hasMarkers(trace)) {
          if (hasColorscale(trace, "marker")) {
            calcColorscale(gd, trace, {
              vals: trace.marker.color,
              containerStr: "marker",
              cLetter: "c"
            });
          }
          if (hasColorscale(trace, "marker.line")) {
            calcColorscale(gd, trace, {
              vals: trace.marker.line.color,
              containerStr: "marker.line",
              cLetter: "c"
            });
          }
        }
      };
    }
  });

  // src/traces/scatter/arrays_to_calcdata.js
  var require_arrays_to_calcdata = __commonJS({
    "src/traces/scatter/arrays_to_calcdata.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function arraysToCalcdata(cd, trace) {
        for (var i = 0; i < cd.length; i++) cd[i].i = i;
        Lib.mergeArray(trace.text, cd, "tx");
        Lib.mergeArray(trace.texttemplate, cd, "txt");
        Lib.mergeArray(trace.hovertext, cd, "htx");
        Lib.mergeArray(trace.customdata, cd, "data");
        Lib.mergeArray(trace.textposition, cd, "tp");
        if (trace.textfont) {
          Lib.mergeArrayCastPositive(trace.textfont.size, cd, "ts");
          Lib.mergeArray(trace.textfont.color, cd, "tc");
          Lib.mergeArray(trace.textfont.family, cd, "tf");
          Lib.mergeArray(trace.textfont.weight, cd, "tw");
          Lib.mergeArray(trace.textfont.style, cd, "ty");
          Lib.mergeArray(trace.textfont.variant, cd, "tv");
          Lib.mergeArray(trace.textfont.textcase, cd, "tC");
          Lib.mergeArray(trace.textfont.lineposition, cd, "tE");
          Lib.mergeArray(trace.textfont.shadow, cd, "tS");
        }
        var marker = trace.marker;
        if (marker) {
          Lib.mergeArrayCastPositive(marker.size, cd, "ms");
          Lib.mergeArrayCastPositive(marker.opacity, cd, "mo");
          Lib.mergeArray(marker.symbol, cd, "mx");
          Lib.mergeArray(marker.angle, cd, "ma");
          Lib.mergeArray(marker.standoff, cd, "mf");
          Lib.mergeArray(marker.color, cd, "mc");
          var markerLine = marker.line;
          if (marker.line) {
            Lib.mergeArray(markerLine.color, cd, "mlc");
            Lib.mergeArrayCastPositive(markerLine.width, cd, "mlw");
          }
          var markerGradient = marker.gradient;
          if (markerGradient && markerGradient.type !== "none") {
            Lib.mergeArray(markerGradient.type, cd, "mgt");
            Lib.mergeArray(markerGradient.color, cd, "mgc");
          }
        }
      };
    }
  });

  // src/traces/scatter/calc_selection.js
  var require_calc_selection = __commonJS({
    "src/traces/scatter/calc_selection.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function calcSelection(cd, trace) {
        if (Lib.isArrayOrTypedArray(trace.selectedpoints)) {
          Lib.tagSelected(cd, trace);
        }
      };
    }
  });

  // src/traces/scatter/calc.js
  var require_calc3 = __commonJS({
    "src/traces/scatter/calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var Axes = require_axes();
      var alignPeriod = require_align_period();
      var BADNUM = require_numerical().BADNUM;
      var subTypes = require_subtypes();
      var calcColorscale = require_colorscale_calc();
      var arraysToCalcdata = require_arrays_to_calcdata();
      var calcSelection = require_calc_selection();
      function calc(gd, trace) {
        var fullLayout = gd._fullLayout;
        var xa = trace._xA = Axes.getFromId(gd, trace.xaxis || "x", "x");
        var ya = trace._yA = Axes.getFromId(gd, trace.yaxis || "y", "y");
        var origX = xa.makeCalcdata(trace, "x");
        var origY = ya.makeCalcdata(trace, "y");
        var xObj = alignPeriod(trace, xa, "x", origX);
        var yObj = alignPeriod(trace, ya, "y", origY);
        var x = xObj.vals;
        var y = yObj.vals;
        var serieslen = trace._length;
        var cd = new Array(serieslen);
        var ids = trace.ids;
        var stackGroupOpts = getStackOpts(trace, fullLayout, xa, ya);
        var interpolateGaps = false;
        var isV, i, j, k, interpolate, vali;
        setFirstScatter(fullLayout, trace);
        var xAttr = "x";
        var yAttr = "y";
        var posAttr;
        if (stackGroupOpts) {
          Lib.pushUnique(stackGroupOpts.traceIndices, trace.index);
          isV = stackGroupOpts.orientation === "v";
          if (isV) {
            yAttr = "s";
            posAttr = "x";
          } else {
            xAttr = "s";
            posAttr = "y";
          }
          interpolate = stackGroupOpts.stackgaps === "interpolate";
        } else {
          var ppad = calcMarkerSize(trace, serieslen);
          calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);
        }
        var hasPeriodX = !!trace.xperiodalignment;
        var hasPeriodY = !!trace.yperiodalignment;
        for (i = 0; i < serieslen; i++) {
          var cdi = cd[i] = {};
          var xValid = isNumeric(x[i]);
          var yValid = isNumeric(y[i]);
          if (xValid && yValid) {
            cdi[xAttr] = x[i];
            cdi[yAttr] = y[i];
            if (hasPeriodX) {
              cdi.orig_x = origX[i];
              cdi.xEnd = xObj.ends[i];
              cdi.xStart = xObj.starts[i];
            }
            if (hasPeriodY) {
              cdi.orig_y = origY[i];
              cdi.yEnd = yObj.ends[i];
              cdi.yStart = yObj.starts[i];
            }
          } else if (stackGroupOpts && (isV ? xValid : yValid)) {
            cdi[posAttr] = isV ? x[i] : y[i];
            cdi.gap = true;
            if (interpolate) {
              cdi.s = BADNUM;
              interpolateGaps = true;
            } else {
              cdi.s = 0;
            }
          } else {
            cdi[xAttr] = cdi[yAttr] = BADNUM;
          }
          if (ids) {
            cdi.id = String(ids[i]);
          }
        }
        arraysToCalcdata(cd, trace);
        calcColorscale(gd, trace);
        calcSelection(cd, trace);
        if (stackGroupOpts) {
          i = 0;
          while (i < cd.length) {
            if (cd[i][posAttr] === BADNUM) {
              cd.splice(i, 1);
            } else i++;
          }
          Lib.sort(cd, function(a, b) {
            return a[posAttr] - b[posAttr] || a.i - b.i;
          });
          if (interpolateGaps) {
            i = 0;
            while (i < cd.length - 1 && cd[i].gap) {
              i++;
            }
            vali = cd[i].s;
            if (!vali) vali = cd[i].s = 0;
            for (j = 0; j < i; j++) {
              cd[j].s = vali;
            }
            k = cd.length - 1;
            while (k > i && cd[k].gap) {
              k--;
            }
            vali = cd[k].s;
            for (j = cd.length - 1; j > k; j--) {
              cd[j].s = vali;
            }
            while (i < k) {
              i++;
              if (cd[i].gap) {
                j = i + 1;
                while (cd[j].gap) {
                  j++;
                }
                var pos0 = cd[i - 1][posAttr];
                var size0 = cd[i - 1].s;
                var m = (cd[j].s - size0) / (cd[j][posAttr] - pos0);
                while (i < j) {
                  cd[i].s = size0 + (cd[i][posAttr] - pos0) * m;
                  i++;
                }
              }
            }
          }
        }
        return cd;
      }
      function calcAxisExpansion(gd, trace, xa, ya, x, y, ppad) {
        var serieslen = trace._length;
        var fullLayout = gd._fullLayout;
        var xId = xa._id;
        var yId = ya._id;
        var firstScatter = fullLayout._firstScatter[firstScatterGroup(trace)] === trace.uid;
        var stackOrientation = (getStackOpts(trace, fullLayout, xa, ya) || {}).orientation;
        var fill = trace.fill;
        xa._minDtick = 0;
        ya._minDtick = 0;
        var xOptions = { padded: true };
        var yOptions = { padded: true };
        if (ppad) {
          xOptions.ppad = yOptions.ppad = ppad;
        }
        var openEnded = serieslen < 2 || x[0] !== x[serieslen - 1] || y[0] !== y[serieslen - 1];
        if (openEnded && (fill === "tozerox" || fill === "tonextx" && (firstScatter || stackOrientation === "h"))) {
          xOptions.tozero = true;
        } else if (!(trace.error_y || {}).visible && // if no error bars, markers or text, or fill to y=0 remove x padding
        (fill === "tonexty" || fill === "tozeroy" || !subTypes.hasMarkers(trace) && !subTypes.hasText(trace))) {
          xOptions.padded = false;
          xOptions.ppad = 0;
        }
        if (openEnded && (fill === "tozeroy" || fill === "tonexty" && (firstScatter || stackOrientation === "v"))) {
          yOptions.tozero = true;
        } else if (fill === "tonextx" || fill === "tozerox") {
          yOptions.padded = false;
        }
        if (xId) trace._extremes[xId] = Axes.findExtremes(xa, x, xOptions);
        if (yId) trace._extremes[yId] = Axes.findExtremes(ya, y, yOptions);
      }
      function calcMarkerSize(trace, serieslen) {
        if (!subTypes.hasMarkers(trace)) return;
        var marker = trace.marker;
        var sizeref = 1.6 * (trace.marker.sizeref || 1);
        var markerTrans;
        if (trace.marker.sizemode === "area") {
          markerTrans = function(v) {
            return Math.max(Math.sqrt((v || 0) / sizeref), 3);
          };
        } else {
          markerTrans = function(v) {
            return Math.max((v || 0) / sizeref, 3);
          };
        }
        if (Lib.isArrayOrTypedArray(marker.size)) {
          var ax = { type: "linear" };
          Axes.setConvert(ax);
          var s = ax.makeCalcdata(trace.marker, "size");
          var sizeOut = new Array(serieslen);
          for (var i = 0; i < serieslen; i++) {
            sizeOut[i] = markerTrans(s[i]);
          }
          return sizeOut;
        } else {
          return markerTrans(marker.size);
        }
      }
      function setFirstScatter(fullLayout, trace) {
        var group = firstScatterGroup(trace);
        var firstScatter = fullLayout._firstScatter;
        if (!firstScatter[group]) firstScatter[group] = trace.uid;
      }
      function firstScatterGroup(trace) {
        var stackGroup = trace.stackgroup;
        return trace.xaxis + trace.yaxis + trace.type + (stackGroup ? "-" + stackGroup : "");
      }
      function getStackOpts(trace, fullLayout, xa, ya) {
        var stackGroup = trace.stackgroup;
        if (!stackGroup) return;
        var stackOpts = fullLayout._scatterStackOpts[xa._id + ya._id][stackGroup];
        var stackAx = stackOpts.orientation === "v" ? ya : xa;
        if (stackAx.type === "linear" || stackAx.type === "log") return stackOpts;
      }
      module.exports = {
        calc,
        calcMarkerSize,
        calcAxisExpansion,
        setFirstScatter,
        getStackOpts
      };
    }
  });

  // src/traces/bar/sieve.js
  var require_sieve = __commonJS({
    "src/traces/bar/sieve.js"(exports, module) {
      "use strict";
      module.exports = Sieve;
      var distinctVals = require_lib().distinctVals;
      function Sieve(traces, opts) {
        this.traces = traces;
        this.sepNegVal = opts.sepNegVal;
        this.overlapNoMerge = opts.overlapNoMerge;
        var width1 = Infinity;
        var axLetter = opts.posAxis._id.charAt(0);
        var positions = [];
        for (var i = 0; i < traces.length; i++) {
          var trace = traces[i];
          for (var j = 0; j < trace.length; j++) {
            var bar = trace[j];
            var pos = bar.p;
            if (pos === void 0) {
              pos = bar[axLetter];
            }
            if (pos !== void 0) positions.push(pos);
          }
          if (trace[0] && trace[0].width1) {
            width1 = Math.min(trace[0].width1, width1);
          }
        }
        this.positions = positions;
        var dv = distinctVals(positions);
        this.distinctPositions = dv.vals;
        if (dv.vals.length === 1 && width1 !== Infinity) this.minDiff = width1;
        else this.minDiff = Math.min(dv.minDiff, width1);
        var type = (opts.posAxis || {}).type;
        if (type === "category" || type === "multicategory") {
          this.minDiff = 1;
        }
        this.binWidth = this.minDiff;
        this.bins = {};
      }
      Sieve.prototype.put = function put(position, group, value) {
        var label = this.getLabel(position, group, value);
        var oldValue = this.bins[label] || 0;
        this.bins[label] = oldValue + value;
        return oldValue;
      };
      Sieve.prototype.get = function get(position, group, value) {
        var label = this.getLabel(position, group, value);
        return this.bins[label] || 0;
      };
      Sieve.prototype.getLabel = function getLabel(position, group, value) {
        var prefix = value < 0 && this.sepNegVal ? "v" : "^";
        var label = this.overlapNoMerge ? position : Math.round(position / this.binWidth);
        return prefix + label + "g" + group;
      };
    }
  });

  // src/traces/bar/cross_trace_calc.js
  var require_cross_trace_calc = __commonJS({
    "src/traces/bar/cross_trace_calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var isArrayOrTypedArray = require_lib().isArrayOrTypedArray;
      var BADNUM = require_numerical().BADNUM;
      var Registry = require_registry();
      var Axes = require_axes();
      var getAxisGroup = require_constraints().getAxisGroup;
      var Sieve = require_sieve();
      function crossTraceCalc(gd, plotinfo) {
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var fullLayout = gd._fullLayout;
        var fullTraces = gd._fullData;
        var calcTraces = gd.calcdata;
        var calcTracesHorz = [];
        var calcTracesVert = [];
        for (var i = 0; i < fullTraces.length; i++) {
          var fullTrace = fullTraces[i];
          if (fullTrace.visible === true && Registry.traceIs(fullTrace, "bar") && fullTrace.xaxis === xa._id && fullTrace.yaxis === ya._id) {
            if (fullTrace.orientation === "h") {
              calcTracesHorz.push(calcTraces[i]);
            } else {
              calcTracesVert.push(calcTraces[i]);
            }
            if (fullTrace._computePh) {
              var cd = gd.calcdata[i];
              for (var j = 0; j < cd.length; j++) {
                if (typeof cd[j].ph0 === "function") cd[j].ph0 = cd[j].ph0();
                if (typeof cd[j].ph1 === "function") cd[j].ph1 = cd[j].ph1();
              }
            }
          }
        }
        var opts = {
          xCat: xa.type === "category" || xa.type === "multicategory",
          yCat: ya.type === "category" || ya.type === "multicategory",
          mode: fullLayout.barmode,
          norm: fullLayout.barnorm,
          gap: fullLayout.bargap,
          groupgap: fullLayout.bargroupgap
        };
        setGroupPositions(gd, xa, ya, calcTracesVert, opts);
        setGroupPositions(gd, ya, xa, calcTracesHorz, opts);
      }
      function setGroupPositions(gd, pa, sa, calcTraces, opts) {
        if (!calcTraces.length) return;
        var excluded;
        var included;
        var i, calcTrace, fullTrace;
        initBase(sa, calcTraces);
        switch (opts.mode) {
          case "overlay":
            setGroupPositionsInOverlayMode(gd, pa, sa, calcTraces, opts);
            break;
          case "group":
            excluded = [];
            included = [];
            for (i = 0; i < calcTraces.length; i++) {
              calcTrace = calcTraces[i];
              fullTrace = calcTrace[0].trace;
              if (fullTrace.offset === void 0) included.push(calcTrace);
              else excluded.push(calcTrace);
            }
            if (included.length) {
              setGroupPositionsInGroupMode(gd, pa, sa, included, opts);
            }
            if (excluded.length) {
              setGroupPositionsInOverlayMode(gd, pa, sa, excluded, opts);
            }
            break;
          case "stack":
          case "relative":
            excluded = [];
            included = [];
            for (i = 0; i < calcTraces.length; i++) {
              calcTrace = calcTraces[i];
              fullTrace = calcTrace[0].trace;
              if (fullTrace.base === void 0) included.push(calcTrace);
              else excluded.push(calcTrace);
            }
            standardizeCornerradius(included);
            if (included.length) {
              setGroupPositionsInStackOrRelativeMode(gd, pa, sa, included, opts);
            }
            if (excluded.length) {
              setGroupPositionsInOverlayMode(gd, pa, sa, excluded, opts);
            }
            break;
        }
        setCornerradius(calcTraces);
        collectExtents(calcTraces, pa);
      }
      function setCornerradius(calcTraces) {
        var i, calcTrace, fullTrace, t, cr, crValue, crForm;
        for (i = 0; i < calcTraces.length; i++) {
          calcTrace = calcTraces[i];
          fullTrace = calcTrace[0].trace;
          t = calcTrace[0].t;
          if (t.cornerradiusvalue === void 0) {
            cr = fullTrace.marker ? fullTrace.marker.cornerradius : void 0;
            if (cr !== void 0) {
              crValue = isNumeric(cr) ? +cr : +cr.slice(0, -1);
              crForm = isNumeric(cr) ? "px" : "%";
              t.cornerradiusvalue = crValue;
              t.cornerradiusform = crForm;
            }
          }
        }
      }
      function standardizeCornerradius(calcTraces) {
        if (calcTraces.length < 2) return;
        var i, calcTrace, fullTrace, t;
        var cr, crValue, crForm;
        for (i = 0; i < calcTraces.length; i++) {
          calcTrace = calcTraces[i];
          fullTrace = calcTrace[0].trace;
          cr = fullTrace.marker ? fullTrace.marker.cornerradius : void 0;
          if (cr !== void 0) break;
        }
        if (cr !== void 0) {
          crValue = isNumeric(cr) ? +cr : +cr.slice(0, -1);
          crForm = isNumeric(cr) ? "px" : "%";
          for (i = 0; i < calcTraces.length; i++) {
            calcTrace = calcTraces[i];
            t = calcTrace[0].t;
            t.cornerradiusvalue = crValue;
            t.cornerradiusform = crForm;
          }
        }
      }
      function initBase(sa, calcTraces) {
        var i, j;
        for (i = 0; i < calcTraces.length; i++) {
          var cd = calcTraces[i];
          var trace = cd[0].trace;
          var base = trace.type === "funnel" ? trace._base : trace.base;
          var b;
          var scalendar = trace.orientation === "h" ? trace.xcalendar : trace.ycalendar;
          var d2c = sa.type === "category" || sa.type === "multicategory" ? function() {
            return null;
          } : sa.d2c;
          if (isArrayOrTypedArray(base)) {
            for (j = 0; j < Math.min(base.length, cd.length); j++) {
              b = d2c(base[j], 0, scalendar);
              if (isNumeric(b)) {
                cd[j].b = +b;
                cd[j].hasB = 1;
              } else cd[j].b = 0;
            }
            for (; j < cd.length; j++) {
              cd[j].b = 0;
            }
          } else {
            b = d2c(base, 0, scalendar);
            var hasBase = isNumeric(b);
            b = hasBase ? b : 0;
            for (j = 0; j < cd.length; j++) {
              cd[j].b = b;
              if (hasBase) cd[j].hasB = 1;
            }
          }
        }
      }
      function setGroupPositionsInOverlayMode(gd, pa, sa, calcTraces, opts) {
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var sieve = new Sieve([calcTrace], {
            posAxis: pa,
            sepNegVal: false,
            overlapNoMerge: !opts.norm
          });
          setOffsetAndWidth(gd, pa, sieve, opts);
          if (opts.norm) {
            sieveBars(sieve);
            normalizeBars(sa, sieve, opts);
          } else {
            setBaseAndTop(sa, sieve);
          }
        }
      }
      function setGroupPositionsInGroupMode(gd, pa, sa, calcTraces, opts) {
        var sieve = new Sieve(calcTraces, {
          posAxis: pa,
          sepNegVal: false,
          overlapNoMerge: !opts.norm
        });
        setOffsetAndWidth(gd, pa, sieve, opts);
        unhideBarsWithinTrace(sieve, pa);
        if (opts.norm) {
          sieveBars(sieve);
          normalizeBars(sa, sieve, opts);
        } else {
          setBaseAndTop(sa, sieve);
        }
      }
      function setGroupPositionsInStackOrRelativeMode(gd, pa, sa, calcTraces, opts) {
        var sieve = new Sieve(calcTraces, {
          posAxis: pa,
          sepNegVal: opts.mode === "relative",
          overlapNoMerge: !(opts.norm || opts.mode === "stack" || opts.mode === "relative")
        });
        setOffsetAndWidth(gd, pa, sieve, opts);
        stackBars(sa, sieve, opts);
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var offsetIndex = calcTrace[0].t.offsetindex;
          for (var j = 0; j < calcTrace.length; j++) {
            var bar = calcTrace[j];
            if (bar.s !== BADNUM) {
              var isOutmostBar = bar.b + bar.s === sieve.get(bar.p, offsetIndex, bar.s);
              if (isOutmostBar) bar._outmost = true;
            }
          }
        }
        if (opts.norm) normalizeBars(sa, sieve, opts);
      }
      function setOffsetAndWidth(gd, pa, sieve, opts) {
        var fullLayout = gd._fullLayout;
        var positions = sieve.positions;
        var distinctPositions = sieve.distinctPositions;
        var minDiff = sieve.minDiff;
        var calcTraces = sieve.traces;
        var nTraces = calcTraces.length;
        var overlap = positions.length !== distinctPositions.length;
        var barGroupWidth = minDiff * (1 - opts.gap);
        var barWidthPlusGap;
        var barWidth;
        var offsetFromCenter;
        var alignmentGroups;
        if (pa._id === "angularaxis") {
          barWidthPlusGap = barGroupWidth;
          barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));
          offsetFromCenter = -barWidth / 2;
        } else {
          var groupId = getAxisGroup(fullLayout, pa._id) + calcTraces[0][0].trace.orientation;
          alignmentGroups = fullLayout._alignmentOpts[groupId] || {};
        }
        for (var i = 0; i < nTraces; i++) {
          var calcTrace = calcTraces[i];
          var trace = calcTrace[0].trace;
          if (pa._id !== "angularaxis") {
            var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};
            var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;
            if (nOffsetGroups) {
              barWidthPlusGap = barGroupWidth / nOffsetGroups;
            } else {
              barWidthPlusGap = overlap ? barGroupWidth / nTraces : barGroupWidth;
            }
            barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));
            if (nOffsetGroups) {
              offsetFromCenter = ((2 * trace._offsetIndex + 1 - nOffsetGroups) * barWidthPlusGap - barWidth) / 2;
            } else {
              offsetFromCenter = overlap ? ((2 * i + 1 - nTraces) * barWidthPlusGap - barWidth) / 2 : -barWidth / 2;
            }
          }
          var t = calcTrace[0].t;
          t.barwidth = barWidth;
          t.offsetindex = trace._offsetIndex || 0;
          t.poffset = offsetFromCenter;
          t.bargroupwidth = barGroupWidth;
          t.bardelta = minDiff;
        }
        sieve.binWidth = calcTraces[0][0].t.barwidth / 100;
        applyAttributes(sieve);
        setBarCenterAndWidth(pa, sieve);
        if (pa._id === "angularaxis") {
          updatePositionAxis(pa, sieve);
        } else {
          updatePositionAxis(pa, sieve, overlap);
        }
      }
      function applyAttributes(sieve) {
        var calcTraces = sieve.traces;
        var i, j;
        for (i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var calcTrace0 = calcTrace[0];
          var fullTrace = calcTrace0.trace;
          var t = calcTrace0.t;
          var offset = fullTrace._offset || fullTrace.offset;
          var initialPoffset = t.poffset;
          var newPoffset;
          if (isArrayOrTypedArray(offset)) {
            newPoffset = Array.prototype.slice.call(offset, 0, calcTrace.length);
            for (j = 0; j < newPoffset.length; j++) {
              if (!isNumeric(newPoffset[j])) {
                newPoffset[j] = initialPoffset;
              }
            }
            for (j = newPoffset.length; j < calcTrace.length; j++) {
              newPoffset.push(initialPoffset);
            }
            t.poffset = newPoffset;
          } else if (offset !== void 0) {
            t.poffset = offset;
          }
          var width = fullTrace._width || fullTrace.width;
          var initialBarwidth = t.barwidth;
          if (isArrayOrTypedArray(width)) {
            var newBarwidth = Array.prototype.slice.call(width, 0, calcTrace.length);
            for (j = 0; j < newBarwidth.length; j++) {
              if (!isNumeric(newBarwidth[j])) newBarwidth[j] = initialBarwidth;
            }
            for (j = newBarwidth.length; j < calcTrace.length; j++) {
              newBarwidth.push(initialBarwidth);
            }
            t.barwidth = newBarwidth;
            if (offset === void 0) {
              newPoffset = [];
              for (j = 0; j < calcTrace.length; j++) {
                newPoffset.push(
                  initialPoffset + (initialBarwidth - newBarwidth[j]) / 2
                );
              }
              t.poffset = newPoffset;
            }
          } else if (width !== void 0) {
            t.barwidth = width;
            if (offset === void 0) {
              t.poffset = initialPoffset + (initialBarwidth - width) / 2;
            }
          }
        }
      }
      function setBarCenterAndWidth(pa, sieve) {
        var calcTraces = sieve.traces;
        var pLetter = getAxisLetter(pa);
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var t = calcTrace[0].t;
          var poffset = t.poffset;
          var poffsetIsArray = isArrayOrTypedArray(poffset);
          var barwidth = t.barwidth;
          var barwidthIsArray = isArrayOrTypedArray(barwidth);
          for (var j = 0; j < calcTrace.length; j++) {
            var calcBar = calcTrace[j];
            var width = calcBar.w = barwidthIsArray ? barwidth[j] : barwidth;
            if (calcBar.p === void 0) {
              calcBar.p = calcBar[pLetter];
              calcBar["orig_" + pLetter] = calcBar[pLetter];
            }
            var delta = (poffsetIsArray ? poffset[j] : poffset) + width / 2;
            calcBar[pLetter] = calcBar.p + delta;
          }
        }
      }
      function updatePositionAxis(pa, sieve, allowMinDtick) {
        var calcTraces = sieve.traces;
        var minDiff = sieve.minDiff;
        var vpad = minDiff / 2;
        Axes.minDtick(pa, sieve.minDiff, sieve.distinctPositions[0], allowMinDtick);
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var calcTrace0 = calcTrace[0];
          var fullTrace = calcTrace0.trace;
          var pts = [];
          var bar, l, r, j;
          for (j = 0; j < calcTrace.length; j++) {
            bar = calcTrace[j];
            l = bar.p - vpad;
            r = bar.p + vpad;
            pts.push(l, r);
          }
          if (fullTrace.width || fullTrace.offset) {
            var t = calcTrace0.t;
            var poffset = t.poffset;
            var barwidth = t.barwidth;
            var poffsetIsArray = isArrayOrTypedArray(poffset);
            var barwidthIsArray = isArrayOrTypedArray(barwidth);
            for (j = 0; j < calcTrace.length; j++) {
              bar = calcTrace[j];
              var calcBarOffset = poffsetIsArray ? poffset[j] : poffset;
              var calcBarWidth = barwidthIsArray ? barwidth[j] : barwidth;
              l = bar.p + calcBarOffset;
              r = l + calcBarWidth;
              pts.push(l, r);
            }
          }
          fullTrace._extremes[pa._id] = Axes.findExtremes(pa, pts, { padded: false });
        }
      }
      function setBaseAndTop(sa, sieve) {
        var calcTraces = sieve.traces;
        var sLetter = getAxisLetter(sa);
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var fullTrace = calcTrace[0].trace;
          var isScatter = fullTrace.type === "scatter";
          var isVertical = fullTrace.orientation === "v";
          var pts = [];
          var tozero = false;
          for (var j = 0; j < calcTrace.length; j++) {
            var bar = calcTrace[j];
            var base = isScatter ? 0 : bar.b;
            var top = isScatter ? isVertical ? bar.y : bar.x : base + bar.s;
            bar[sLetter] = top;
            pts.push(top);
            if (bar.hasB) pts.push(base);
            if (!bar.hasB || !bar.b) {
              tozero = true;
            }
          }
          fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {
            tozero,
            padded: true
          });
        }
      }
      function stackBars(sa, sieve, opts) {
        var sLetter = getAxisLetter(sa);
        var calcTraces = sieve.traces;
        var calcTrace;
        var fullTrace;
        var isFunnel;
        var i, j;
        var bar;
        var offsetIndex;
        for (i = 0; i < calcTraces.length; i++) {
          calcTrace = calcTraces[i];
          fullTrace = calcTrace[0].trace;
          if (fullTrace.type === "funnel") {
            offsetIndex = calcTrace[0].t.offsetindex;
            for (j = 0; j < calcTrace.length; j++) {
              bar = calcTrace[j];
              if (bar.s !== BADNUM) {
                sieve.put(bar.p, offsetIndex, -0.5 * bar.s);
              }
            }
          }
        }
        for (i = 0; i < calcTraces.length; i++) {
          calcTrace = calcTraces[i];
          fullTrace = calcTrace[0].trace;
          isFunnel = fullTrace.type === "funnel";
          offsetIndex = fullTrace.type === "barpolar" ? 0 : calcTrace[0].t.offsetindex;
          var pts = [];
          for (j = 0; j < calcTrace.length; j++) {
            bar = calcTrace[j];
            if (bar.s !== BADNUM) {
              var value;
              if (isFunnel) {
                value = bar.s;
              } else {
                value = bar.s + bar.b;
              }
              var base = sieve.put(bar.p, offsetIndex, value);
              var top = base + value;
              bar.b = base;
              bar[sLetter] = top;
              if (!opts.norm) {
                pts.push(top);
                if (bar.hasB) {
                  pts.push(base);
                }
              }
            }
          }
          if (!opts.norm) {
            fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {
              // N.B. we don't stack base with 'base',
              // so set tozero:true always!
              tozero: true,
              padded: true
            });
          }
        }
      }
      function sieveBars(sieve) {
        var calcTraces = sieve.traces;
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var offsetIndex = calcTrace[0].t.offsetindex;
          for (var j = 0; j < calcTrace.length; j++) {
            var bar = calcTrace[j];
            if (bar.s !== BADNUM) {
              sieve.put(bar.p, offsetIndex, bar.b + bar.s);
            }
          }
        }
      }
      function unhideBarsWithinTrace(sieve, pa) {
        var calcTraces = sieve.traces;
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var fullTrace = calcTrace[0].trace;
          var offsetIndex = calcTrace[0].t.offsetindex;
          if (fullTrace.base === void 0) {
            var inTraceSieve = new Sieve([calcTrace], {
              posAxis: pa,
              sepNegVal: true,
              overlapNoMerge: true
            });
            for (var j = 0; j < calcTrace.length; j++) {
              var bar = calcTrace[j];
              if (bar.p !== BADNUM) {
                var base = inTraceSieve.put(bar.p, offsetIndex, bar.b + bar.s);
                if (base) bar.b = base;
              }
            }
          }
        }
      }
      function normalizeBars(sa, sieve, opts) {
        var calcTraces = sieve.traces;
        var sLetter = getAxisLetter(sa);
        var sTop = opts.norm === "fraction" ? 1 : 100;
        var sTiny = sTop / 1e9;
        var sMin = sa.l2c(sa.c2l(0));
        var sMax = opts.mode === "stack" ? sTop : sMin;
        function needsPadding(v) {
          return isNumeric(sa.c2l(v)) && (v < sMin - sTiny || v > sMax + sTiny || !isNumeric(sMin));
        }
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var offsetIndex = calcTrace[0].t.offsetindex;
          var fullTrace = calcTrace[0].trace;
          var pts = [];
          var tozero = false;
          var padded = false;
          for (var j = 0; j < calcTrace.length; j++) {
            var bar = calcTrace[j];
            if (bar.s !== BADNUM) {
              var scale = Math.abs(sTop / sieve.get(bar.p, offsetIndex, bar.s));
              bar.b *= scale;
              bar.s *= scale;
              var base = bar.b;
              var top = base + bar.s;
              bar[sLetter] = top;
              pts.push(top);
              padded = padded || needsPadding(top);
              if (bar.hasB) {
                pts.push(base);
                padded = padded || needsPadding(base);
              }
              if (!bar.hasB || !bar.b) {
                tozero = true;
              }
            }
          }
          fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {
            tozero,
            padded
          });
        }
      }
      function setHelperValuesForRoundedCorners(calcTraces, sMinByPos, sMaxByPos, pa) {
        var pLetter = getAxisLetter(pa);
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          for (var j = 0; j < calcTrace.length; j++) {
            var bar = calcTrace[j];
            var pos = bar[pLetter];
            bar._sMin = sMinByPos[pos];
            bar._sMax = sMaxByPos[pos];
          }
        }
      }
      function collectExtents(calcTraces, pa) {
        var pLetter = getAxisLetter(pa);
        var extents = {};
        var i, j, cd;
        var pMin = Infinity;
        var pMax = -Infinity;
        for (i = 0; i < calcTraces.length; i++) {
          cd = calcTraces[i];
          for (j = 0; j < cd.length; j++) {
            var p = cd[j].p;
            if (isNumeric(p)) {
              pMin = Math.min(pMin, p);
              pMax = Math.max(pMax, p);
            }
          }
        }
        var roundFactor = 1e4 / (pMax - pMin);
        var round = extents.round = function(p2) {
          return String(Math.round(roundFactor * (p2 - pMin)));
        };
        var sMinByPos = {};
        var sMaxByPos = {};
        var anyTraceHasCornerradius = calcTraces.some(function(x) {
          var trace = x[0].trace;
          return "marker" in trace && trace.marker.cornerradius;
        });
        for (i = 0; i < calcTraces.length; i++) {
          cd = calcTraces[i];
          cd[0].t.extents = extents;
          var poffset = cd[0].t.poffset;
          var poffsetIsArray = isArrayOrTypedArray(poffset);
          for (j = 0; j < cd.length; j++) {
            var di = cd[j];
            var p0 = di[pLetter] - di.w / 2;
            if (isNumeric(p0)) {
              var p1 = di[pLetter] + di.w / 2;
              var pVal = round(di.p);
              if (extents[pVal]) {
                extents[pVal] = [Math.min(p0, extents[pVal][0]), Math.max(p1, extents[pVal][1])];
              } else {
                extents[pVal] = [p0, p1];
              }
            }
            di.p0 = di.p + (poffsetIsArray ? poffset[j] : poffset);
            di.p1 = di.p0 + di.w;
            di.s0 = di.b;
            di.s1 = di.s0 + di.s;
            if (anyTraceHasCornerradius) {
              var sMin = Math.min(di.s0, di.s1) || 0;
              var sMax = Math.max(di.s0, di.s1) || 0;
              var pos = di[pLetter];
              sMinByPos[pos] = pos in sMinByPos ? Math.min(sMinByPos[pos], sMin) : sMin;
              sMaxByPos[pos] = pos in sMaxByPos ? Math.max(sMaxByPos[pos], sMax) : sMax;
            }
          }
        }
        if (anyTraceHasCornerradius) {
          setHelperValuesForRoundedCorners(calcTraces, sMinByPos, sMaxByPos, pa);
        }
      }
      function getAxisLetter(ax) {
        return ax._id.charAt(0);
      }
      module.exports = {
        crossTraceCalc,
        setGroupPositions
      };
    }
  });

  // src/traces/scatter/cross_trace_calc.js
  var require_cross_trace_calc2 = __commonJS({
    "src/traces/scatter/cross_trace_calc.js"(exports, module) {
      "use strict";
      var calc = require_calc3();
      var setGroupPositions = require_cross_trace_calc().setGroupPositions;
      function groupCrossTraceCalc(gd, plotinfo) {
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var fullLayout = gd._fullLayout;
        var fullTraces = gd._fullData;
        var calcTraces = gd.calcdata;
        var calcTracesHorz = [];
        var calcTracesVert = [];
        for (var i = 0; i < fullTraces.length; i++) {
          var fullTrace = fullTraces[i];
          if (fullTrace.visible === true && fullTrace.type === "scatter" && fullTrace.xaxis === xa._id && fullTrace.yaxis === ya._id) {
            if (fullTrace.orientation === "h") {
              calcTracesHorz.push(calcTraces[i]);
            } else if (fullTrace.orientation === "v") {
              calcTracesVert.push(calcTraces[i]);
            }
          }
        }
        var opts = {
          mode: fullLayout.scattermode,
          gap: fullLayout.scattergap
        };
        setGroupPositions(gd, xa, ya, calcTracesVert, opts);
        setGroupPositions(gd, ya, xa, calcTracesHorz, opts);
      }
      module.exports = function crossTraceCalc(gd, plotinfo) {
        if (gd._fullLayout.scattermode === "group") {
          groupCrossTraceCalc(gd, plotinfo);
        }
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var subplot = xa._id + ya._id;
        var subplotStackOpts = gd._fullLayout._scatterStackOpts[subplot];
        if (!subplotStackOpts) return;
        var calcTraces = gd.calcdata;
        var i, j, k, i2, cd, cd0, posj, sumj, norm;
        var groupOpts, interpolate, groupnorm, posAttr, valAttr;
        var hasAnyBlanks;
        for (var stackGroup in subplotStackOpts) {
          groupOpts = subplotStackOpts[stackGroup];
          var indices = groupOpts.traceIndices;
          if (!indices.length) continue;
          interpolate = groupOpts.stackgaps === "interpolate";
          groupnorm = groupOpts.groupnorm;
          if (groupOpts.orientation === "v") {
            posAttr = "x";
            valAttr = "y";
          } else {
            posAttr = "y";
            valAttr = "x";
          }
          hasAnyBlanks = new Array(indices.length);
          for (i = 0; i < hasAnyBlanks.length; i++) {
            hasAnyBlanks[i] = false;
          }
          cd0 = calcTraces[indices[0]];
          var allPositions = new Array(cd0.length);
          for (i = 0; i < cd0.length; i++) {
            allPositions[i] = cd0[i][posAttr];
          }
          for (i = 1; i < indices.length; i++) {
            cd = calcTraces[indices[i]];
            for (j = k = 0; j < cd.length; j++) {
              posj = cd[j][posAttr];
              for (; posj > allPositions[k] && k < allPositions.length; k++) {
                insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);
                j++;
              }
              if (posj !== allPositions[k]) {
                for (i2 = 0; i2 < i; i2++) {
                  insertBlank(calcTraces[indices[i2]], k, posj, i2, hasAnyBlanks, interpolate, posAttr);
                }
                allPositions.splice(k, 0, posj);
              }
              k++;
            }
            for (; k < allPositions.length; k++) {
              insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);
              j++;
            }
          }
          var serieslen = allPositions.length;
          for (j = 0; j < cd0.length; j++) {
            sumj = cd0[j][valAttr] = cd0[j].s;
            for (i = 1; i < indices.length; i++) {
              cd = calcTraces[indices[i]];
              cd[0].trace._rawLength = cd[0].trace._length;
              cd[0].trace._length = serieslen;
              sumj += cd[j].s;
              cd[j][valAttr] = sumj;
            }
            if (groupnorm) {
              norm = (groupnorm === "fraction" ? sumj : sumj / 100) || 1;
              for (i = 0; i < indices.length; i++) {
                var cdj = calcTraces[indices[i]][j];
                cdj[valAttr] /= norm;
                cdj.sNorm = cdj.s / norm;
              }
            }
          }
          for (i = 0; i < indices.length; i++) {
            cd = calcTraces[indices[i]];
            var trace = cd[0].trace;
            var ppad = calc.calcMarkerSize(trace, trace._rawLength);
            var arrayPad = Array.isArray(ppad);
            if (ppad && hasAnyBlanks[i] || arrayPad) {
              var ppadRaw = ppad;
              ppad = new Array(serieslen);
              for (j = 0; j < serieslen; j++) {
                ppad[j] = cd[j].gap ? 0 : arrayPad ? ppadRaw[cd[j].i] : ppadRaw;
              }
            }
            var x = new Array(serieslen);
            var y = new Array(serieslen);
            for (j = 0; j < serieslen; j++) {
              x[j] = cd[j].x;
              y[j] = cd[j].y;
            }
            calc.calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);
            cd[0].t.orientation = groupOpts.orientation;
          }
        }
      };
      function insertBlank(calcTrace, index, position, traceIndex, hasAnyBlanks, interpolate, posAttr) {
        hasAnyBlanks[traceIndex] = true;
        var newEntry = {
          i: null,
          gap: true,
          s: 0
        };
        newEntry[posAttr] = position;
        calcTrace.splice(index, 0, newEntry);
        if (index && position === calcTrace[index - 1][posAttr]) {
          var prevEntry = calcTrace[index - 1];
          newEntry.s = prevEntry.s;
          newEntry.i = prevEntry.i;
          newEntry.gap = prevEntry.gap;
        } else if (interpolate) {
          newEntry.s = getInterp(calcTrace, index, position, posAttr);
        }
        if (!index) {
          calcTrace[0].t = calcTrace[1].t;
          calcTrace[0].trace = calcTrace[1].trace;
          delete calcTrace[1].t;
          delete calcTrace[1].trace;
        }
      }
      function getInterp(calcTrace, index, position, posAttr) {
        var pt0 = calcTrace[index - 1];
        var pt1 = calcTrace[index + 1];
        if (!pt1) return pt0.s;
        if (!pt0) return pt1.s;
        return pt0.s + (pt1.s - pt0.s) * (position - pt0[posAttr]) / (pt1[posAttr] - pt0[posAttr]);
      }
    }
  });

  // src/traces/scatter/line_points.js
  var require_line_points = __commonJS({
    "src/traces/scatter/line_points.js"(exports, module) {
      "use strict";
      var Drawing = require_drawing();
      var numConstants = require_numerical();
      var BADNUM = numConstants.BADNUM;
      var LOG_CLIP = numConstants.LOG_CLIP;
      var LOG_CLIP_PLUS = LOG_CLIP + 0.5;
      var LOG_CLIP_MINUS = LOG_CLIP - 0.5;
      var Lib = require_lib();
      var segmentsIntersect = Lib.segmentsIntersect;
      var constrain = Lib.constrain;
      var constants = require_constants8();
      module.exports = function linePoints(d, opts) {
        var trace = opts.trace || {};
        var xa = opts.xaxis;
        var ya = opts.yaxis;
        var xLog = xa.type === "log";
        var yLog = ya.type === "log";
        var xLen = xa._length;
        var yLen = ya._length;
        var backoff = opts.backoff;
        var marker = trace.marker;
        var connectGaps = opts.connectGaps;
        var baseTolerance = opts.baseTolerance;
        var shape = opts.shape;
        var linear = shape === "linear";
        var fill = trace.fill && trace.fill !== "none";
        var segments = [];
        var minTolerance = constants.minTolerance;
        var len = d.length;
        var pts = new Array(len);
        var pti = 0;
        var i;
        var clusterStartPt, clusterEndPt, clusterHighPt, clusterLowPt;
        var thisPt;
        var clusterHighFirst;
        var clusterUnitVector;
        var thisVector;
        var clusterRefDist, clusterHighVal, clusterLowVal, thisVal;
        var clusterMinDeviation, clusterMaxDeviation, thisDeviation;
        function getPt(index) {
          var di = d[index];
          if (!di) return false;
          var x = opts.linearized ? xa.l2p(di.x) : xa.c2p(di.x);
          var y = opts.linearized ? ya.l2p(di.y) : ya.c2p(di.y);
          if (x === BADNUM) {
            if (xLog) x = xa.c2p(di.x, true);
            if (x === BADNUM) return false;
            if (yLog && y === BADNUM) {
              x *= Math.abs(xa._m * yLen * (xa._m > 0 ? LOG_CLIP_PLUS : LOG_CLIP_MINUS) / (ya._m * xLen * (ya._m > 0 ? LOG_CLIP_PLUS : LOG_CLIP_MINUS)));
            }
            x *= 1e3;
          }
          if (y === BADNUM) {
            if (yLog) y = ya.c2p(di.y, true);
            if (y === BADNUM) return false;
            y *= 1e3;
          }
          return [x, y];
        }
        function crossesViewport(xFrac0, yFrac0, xFrac1, yFrac1) {
          var dx = xFrac1 - xFrac0;
          var dy = yFrac1 - yFrac0;
          var dx0 = 0.5 - xFrac0;
          var dy0 = 0.5 - yFrac0;
          var norm2 = dx * dx + dy * dy;
          var dot = dx * dx0 + dy * dy0;
          if (dot > 0 && dot < norm2) {
            var cross = dx0 * dy - dy0 * dx;
            if (cross * cross < norm2) return true;
          }
        }
        var latestXFrac, latestYFrac;
        function getTolerance(pt, nextPt2) {
          var xFrac = pt[0] / xLen;
          var yFrac = pt[1] / yLen;
          var offScreenFraction = Math.max(0, -xFrac, xFrac - 1, -yFrac, yFrac - 1);
          if (offScreenFraction && latestXFrac !== void 0 && crossesViewport(xFrac, yFrac, latestXFrac, latestYFrac)) {
            offScreenFraction = 0;
          }
          if (offScreenFraction && nextPt2 && crossesViewport(xFrac, yFrac, nextPt2[0] / xLen, nextPt2[1] / yLen)) {
            offScreenFraction = 0;
          }
          return (1 + constants.toleranceGrowth * offScreenFraction) * baseTolerance;
        }
        function ptDist(pt1, pt2) {
          var dx = pt1[0] - pt2[0];
          var dy = pt1[1] - pt2[1];
          return Math.sqrt(dx * dx + dy * dy);
        }
        var maxScreensAway = constants.maxScreensAway;
        var xEdge0 = -xLen * maxScreensAway;
        var xEdge1 = xLen * (1 + maxScreensAway);
        var yEdge0 = -yLen * maxScreensAway;
        var yEdge1 = yLen * (1 + maxScreensAway);
        var edges = [
          [xEdge0, yEdge0, xEdge1, yEdge0],
          [xEdge1, yEdge0, xEdge1, yEdge1],
          [xEdge1, yEdge1, xEdge0, yEdge1],
          [xEdge0, yEdge1, xEdge0, yEdge0]
        ];
        var xEdge, yEdge, lastXEdge, lastYEdge, lastFarPt, edgePt;
        function getLinearEdgeIntersections(pt1, pt2) {
          var out = [];
          var ptCount = 0;
          for (var i2 = 0; i2 < 4; i2++) {
            var edge = edges[i2];
            var ptInt = segmentsIntersect(
              pt1[0],
              pt1[1],
              pt2[0],
              pt2[1],
              edge[0],
              edge[1],
              edge[2],
              edge[3]
            );
            if (ptInt && (!ptCount || Math.abs(ptInt.x - out[0][0]) > 1 || Math.abs(ptInt.y - out[0][1]) > 1)) {
              ptInt = [ptInt.x, ptInt.y];
              if (ptCount && ptDist(ptInt, pt1) < ptDist(out[0], pt1)) out.unshift(ptInt);
              else out.push(ptInt);
              ptCount++;
            }
          }
          return out;
        }
        function onlyConstrainedPoint(pt) {
          if (pt[0] < xEdge0 || pt[0] > xEdge1 || pt[1] < yEdge0 || pt[1] > yEdge1) {
            return [constrain(pt[0], xEdge0, xEdge1), constrain(pt[1], yEdge0, yEdge1)];
          }
        }
        function sameEdge(pt1, pt2) {
          if (pt1[0] === pt2[0] && (pt1[0] === xEdge0 || pt1[0] === xEdge1)) return true;
          if (pt1[1] === pt2[1] && (pt1[1] === yEdge0 || pt1[1] === yEdge1)) return true;
        }
        function getHVEdgeIntersections(pt1, pt2) {
          var out = [];
          var ptInt1 = onlyConstrainedPoint(pt1);
          var ptInt2 = onlyConstrainedPoint(pt2);
          if (ptInt1 && ptInt2 && sameEdge(ptInt1, ptInt2)) return out;
          if (ptInt1) out.push(ptInt1);
          if (ptInt2) out.push(ptInt2);
          return out;
        }
        function getABAEdgeIntersections(dim, limit0, limit1) {
          return function(pt1, pt2) {
            var ptInt1 = onlyConstrainedPoint(pt1);
            var ptInt2 = onlyConstrainedPoint(pt2);
            var out = [];
            if (ptInt1 && ptInt2 && sameEdge(ptInt1, ptInt2)) return out;
            if (ptInt1) out.push(ptInt1);
            if (ptInt2) out.push(ptInt2);
            var midShift = 2 * Lib.constrain((pt1[dim] + pt2[dim]) / 2, limit0, limit1) - ((ptInt1 || pt1)[dim] + (ptInt2 || pt2)[dim]);
            if (midShift) {
              var ptToAlter;
              if (ptInt1 && ptInt2) {
                ptToAlter = midShift > 0 === ptInt1[dim] > ptInt2[dim] ? ptInt1 : ptInt2;
              } else ptToAlter = ptInt1 || ptInt2;
              ptToAlter[dim] += midShift;
            }
            return out;
          };
        }
        var getEdgeIntersections;
        if (shape === "linear" || shape === "spline") {
          getEdgeIntersections = getLinearEdgeIntersections;
        } else if (shape === "hv" || shape === "vh") {
          getEdgeIntersections = getHVEdgeIntersections;
        } else if (shape === "hvh") getEdgeIntersections = getABAEdgeIntersections(0, xEdge0, xEdge1);
        else if (shape === "vhv") getEdgeIntersections = getABAEdgeIntersections(1, yEdge0, yEdge1);
        function getClosestCorner(pt1, pt2) {
          var dx = pt2[0] - pt1[0];
          var m = (pt2[1] - pt1[1]) / dx;
          var b = (pt1[1] * pt2[0] - pt2[1] * pt1[0]) / dx;
          if (b > 0) return [m > 0 ? xEdge0 : xEdge1, yEdge1];
          else return [m > 0 ? xEdge1 : xEdge0, yEdge0];
        }
        function updateEdge(pt) {
          var x = pt[0];
          var y = pt[1];
          var xSame = x === pts[pti - 1][0];
          var ySame = y === pts[pti - 1][1];
          if (xSame && ySame) return;
          if (pti > 1) {
            var xSame2 = x === pts[pti - 2][0];
            var ySame2 = y === pts[pti - 2][1];
            if (xSame && (x === xEdge0 || x === xEdge1) && xSame2) {
              if (ySame2) pti--;
              else pts[pti - 1] = pt;
            } else if (ySame && (y === yEdge0 || y === yEdge1) && ySame2) {
              if (xSame2) pti--;
              else pts[pti - 1] = pt;
            } else pts[pti++] = pt;
          } else pts[pti++] = pt;
        }
        function updateEdgesForReentry(pt) {
          if (pts[pti - 1][0] !== pt[0] && pts[pti - 1][1] !== pt[1]) {
            updateEdge([lastXEdge, lastYEdge]);
          }
          updateEdge(pt);
          lastFarPt = null;
          lastXEdge = lastYEdge = 0;
        }
        var arrayMarker = Lib.isArrayOrTypedArray(marker);
        function addPt(pt) {
          if (pt && backoff) {
            pt.i = i;
            pt.d = d;
            pt.trace = trace;
            pt.marker = arrayMarker ? marker[pt.i] : marker;
            pt.backoff = backoff;
          }
          latestXFrac = pt[0] / xLen;
          latestYFrac = pt[1] / yLen;
          xEdge = pt[0] < xEdge0 ? xEdge0 : pt[0] > xEdge1 ? xEdge1 : 0;
          yEdge = pt[1] < yEdge0 ? yEdge0 : pt[1] > yEdge1 ? yEdge1 : 0;
          if (xEdge || yEdge) {
            if (!pti) {
              pts[pti++] = [xEdge || pt[0], yEdge || pt[1]];
            } else if (lastFarPt) {
              var intersections = getEdgeIntersections(lastFarPt, pt);
              if (intersections.length > 1) {
                updateEdgesForReentry(intersections[0]);
                pts[pti++] = intersections[1];
              }
            } else {
              edgePt = getEdgeIntersections(pts[pti - 1], pt)[0];
              pts[pti++] = edgePt;
            }
            var lastPt = pts[pti - 1];
            if (xEdge && yEdge && (lastPt[0] !== xEdge || lastPt[1] !== yEdge)) {
              if (lastFarPt) {
                if (lastXEdge !== xEdge && lastYEdge !== yEdge) {
                  if (lastXEdge && lastYEdge) {
                    updateEdge(getClosestCorner(lastFarPt, pt));
                  } else {
                    updateEdge([lastXEdge || xEdge, lastYEdge || yEdge]);
                  }
                } else if (lastXEdge && lastYEdge) {
                  updateEdge([lastXEdge, lastYEdge]);
                }
              }
              updateEdge([xEdge, yEdge]);
            } else if (lastXEdge - xEdge && lastYEdge - yEdge) {
              updateEdge([xEdge || lastXEdge, yEdge || lastYEdge]);
            }
            lastFarPt = pt;
            lastXEdge = xEdge;
            lastYEdge = yEdge;
          } else {
            if (lastFarPt) {
              updateEdgesForReentry(getEdgeIntersections(lastFarPt, pt)[0]);
            }
            pts[pti++] = pt;
          }
        }
        for (i = 0; i < len; i++) {
          clusterStartPt = getPt(i);
          if (!clusterStartPt) continue;
          pti = 0;
          lastFarPt = null;
          addPt(clusterStartPt);
          for (i++; i < len; i++) {
            clusterHighPt = getPt(i);
            if (!clusterHighPt) {
              if (connectGaps) continue;
              else break;
            }
            if (!linear || !opts.simplify) {
              addPt(clusterHighPt);
              continue;
            }
            var nextPt = getPt(i + 1);
            clusterRefDist = ptDist(clusterHighPt, clusterStartPt);
            if (!(fill && (pti === 0 || pti === len - 1)) && clusterRefDist < getTolerance(clusterHighPt, nextPt) * minTolerance) continue;
            clusterUnitVector = [
              (clusterHighPt[0] - clusterStartPt[0]) / clusterRefDist,
              (clusterHighPt[1] - clusterStartPt[1]) / clusterRefDist
            ];
            clusterLowPt = clusterStartPt;
            clusterHighVal = clusterRefDist;
            clusterLowVal = clusterMinDeviation = clusterMaxDeviation = 0;
            clusterHighFirst = false;
            clusterEndPt = clusterHighPt;
            for (i++; i < d.length; i++) {
              thisPt = nextPt;
              nextPt = getPt(i + 1);
              if (!thisPt) {
                if (connectGaps) continue;
                else break;
              }
              thisVector = [
                thisPt[0] - clusterStartPt[0],
                thisPt[1] - clusterStartPt[1]
              ];
              thisDeviation = thisVector[0] * clusterUnitVector[1] - thisVector[1] * clusterUnitVector[0];
              clusterMinDeviation = Math.min(clusterMinDeviation, thisDeviation);
              clusterMaxDeviation = Math.max(clusterMaxDeviation, thisDeviation);
              if (clusterMaxDeviation - clusterMinDeviation > getTolerance(thisPt, nextPt)) break;
              clusterEndPt = thisPt;
              thisVal = thisVector[0] * clusterUnitVector[0] + thisVector[1] * clusterUnitVector[1];
              if (thisVal > clusterHighVal) {
                clusterHighVal = thisVal;
                clusterHighPt = thisPt;
                clusterHighFirst = false;
              } else if (thisVal < clusterLowVal) {
                clusterLowVal = thisVal;
                clusterLowPt = thisPt;
                clusterHighFirst = true;
              }
            }
            if (clusterHighFirst) {
              addPt(clusterHighPt);
              if (clusterEndPt !== clusterLowPt) addPt(clusterLowPt);
            } else {
              if (clusterLowPt !== clusterStartPt) addPt(clusterLowPt);
              if (clusterEndPt !== clusterHighPt) addPt(clusterHighPt);
            }
            addPt(clusterEndPt);
            if (i >= d.length || !thisPt) break;
            addPt(thisPt);
            clusterStartPt = thisPt;
          }
          if (lastFarPt) updateEdge([lastXEdge || lastFarPt[0], lastYEdge || lastFarPt[1]]);
          segments.push(pts.slice(0, pti));
        }
        var lastShapeChar = shape.slice(shape.length - 1);
        if (backoff && lastShapeChar !== "h" && lastShapeChar !== "v") {
          var trimmed = false;
          var n = -1;
          var newSegments = [];
          for (var j = 0; j < segments.length; j++) {
            for (var k = 0; k < segments[j].length - 1; k++) {
              var start = segments[j][k];
              var end = segments[j][k + 1];
              var xy = Drawing.applyBackoff(end, start);
              if (xy[0] !== end[0] || xy[1] !== end[1]) {
                trimmed = true;
              }
              if (!newSegments[n + 1]) {
                n++;
                newSegments[n] = [
                  start,
                  [xy[0], xy[1]]
                ];
              }
            }
          }
          return trimmed ? newSegments : segments;
        }
        return segments;
      };
    }
  });

  // src/traces/scatter/link_traces.js
  var require_link_traces = __commonJS({
    "src/traces/scatter/link_traces.js"(exports, module) {
      "use strict";
      var LINKEDFILLS = { tonextx: 1, tonexty: 1, tonext: 1 };
      module.exports = function linkTraces(gd, plotinfo, cdscatter) {
        var trace, i, group, prevtrace, groupIndex;
        var groupIndices = {};
        var needsSort = false;
        var prevGroupIndex = -1;
        var nextGroupIndex = 0;
        var prevUnstackedGroupIndex = -1;
        for (i = 0; i < cdscatter.length; i++) {
          trace = cdscatter[i][0].trace;
          group = trace.stackgroup || "";
          if (group) {
            if (group in groupIndices) {
              groupIndex = groupIndices[group];
            } else {
              groupIndex = groupIndices[group] = nextGroupIndex;
              nextGroupIndex++;
            }
          } else if (trace.fill in LINKEDFILLS && prevUnstackedGroupIndex >= 0) {
            groupIndex = prevUnstackedGroupIndex;
          } else {
            groupIndex = prevUnstackedGroupIndex = nextGroupIndex;
            nextGroupIndex++;
          }
          if (groupIndex < prevGroupIndex) needsSort = true;
          trace._groupIndex = prevGroupIndex = groupIndex;
        }
        var cdscatterSorted = cdscatter.slice();
        if (needsSort) {
          cdscatterSorted.sort(function(a, b) {
            var traceA = a[0].trace;
            var traceB = b[0].trace;
            return traceA._groupIndex - traceB._groupIndex || traceA.index - traceB.index;
          });
        }
        var prevtraces = {};
        for (i = 0; i < cdscatterSorted.length; i++) {
          trace = cdscatterSorted[i][0].trace;
          group = trace.stackgroup || "";
          if (trace.visible === true) {
            trace._nexttrace = null;
            if (trace.fill in LINKEDFILLS) {
              prevtrace = prevtraces[group];
              trace._prevtrace = prevtrace || null;
              if (prevtrace) {
                prevtrace._nexttrace = trace;
              }
            }
            trace._ownfill = trace.fill && (trace.fill.substr(0, 6) === "tozero" || trace.fill === "toself" || trace.fill.substr(0, 2) === "to" && !trace._prevtrace);
            prevtraces[group] = trace;
          } else {
            trace._prevtrace = trace._nexttrace = trace._ownfill = null;
          }
        }
        return cdscatterSorted;
      };
    }
  });

  // src/traces/scatter/plot.js
  var require_plot = __commonJS({
    "src/traces/scatter/plot.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Lib = require_lib();
      var ensureSingle = Lib.ensureSingle;
      var identity = Lib.identity;
      var Drawing = require_drawing();
      var subTypes = require_subtypes();
      var linePoints = require_line_points();
      var linkTraces = require_link_traces();
      var polygonTester = require_polygon().tester;
      module.exports = function plot(gd, plotinfo, cdscatter, scatterLayer, transitionOpts, makeOnCompleteCallback) {
        var join, onComplete;
        var isFullReplot = !transitionOpts;
        var hasTransition = !!transitionOpts && transitionOpts.duration > 0;
        var cdscatterSorted = linkTraces(gd, plotinfo, cdscatter);
        join = scatterLayer.selectAll("g.trace").data(cdscatterSorted, function(d) {
          return d[0].trace.uid;
        });
        join.enter().append("g").attr("class", function(d) {
          return "trace scatter trace" + d[0].trace.uid;
        }).style("stroke-miterlimit", 2);
        join.order();
        createFills(gd, join, plotinfo);
        if (hasTransition) {
          if (makeOnCompleteCallback) {
            onComplete = makeOnCompleteCallback();
          }
          var transition = d3.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each("end", function() {
            onComplete && onComplete();
          }).each("interrupt", function() {
            onComplete && onComplete();
          });
          transition.each(function() {
            scatterLayer.selectAll("g.trace").each(function(d, i) {
              plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);
            });
          });
        } else {
          join.each(function(d, i) {
            plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);
          });
        }
        if (isFullReplot) {
          join.exit().remove();
        }
        scatterLayer.selectAll("path:not([d])").remove();
      };
      function createFills(gd, traceJoin, plotinfo) {
        traceJoin.each(function(d) {
          var fills = ensureSingle(d3.select(this), "g", "fills");
          Drawing.setClipUrl(fills, plotinfo.layerClipId, gd);
          var trace = d[0].trace;
          var fillData = [];
          if (trace._ownfill) fillData.push("_ownFill");
          if (trace._nexttrace) fillData.push("_nextFill");
          var fillJoin = fills.selectAll("g").data(fillData, identity);
          fillJoin.enter().append("g");
          fillJoin.exit().each(function(d2) {
            trace[d2] = null;
          }).remove();
          fillJoin.order().each(function(d2) {
            trace[d2] = ensureSingle(d3.select(this), "path", "js-fill");
          });
        });
      }
      function plotOne(gd, idx, plotinfo, cdscatter, cdscatterAll, element, transitionOpts) {
        var isStatic = gd._context.staticPlot;
        var i;
        selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll);
        var hasTransition = !!transitionOpts && transitionOpts.duration > 0;
        function transition(selection) {
          return hasTransition ? selection.transition() : selection;
        }
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var trace = cdscatter[0].trace;
        var line = trace.line;
        var tr = d3.select(element);
        var errorBarGroup = ensureSingle(tr, "g", "errorbars");
        var lines = ensureSingle(tr, "g", "lines");
        var points = ensureSingle(tr, "g", "points");
        var text = ensureSingle(tr, "g", "text");
        Registry.getComponentMethod("errorbars", "plot")(gd, errorBarGroup, plotinfo, transitionOpts);
        if (trace.visible !== true) return;
        transition(tr).style("opacity", trace.opacity);
        var ownFillEl3, tonext;
        var ownFillDir = trace.fill.charAt(trace.fill.length - 1);
        if (ownFillDir !== "x" && ownFillDir !== "y") ownFillDir = "";
        var fillAxisIndex, fillAxisZero;
        if (ownFillDir === "y") {
          fillAxisIndex = 1;
          fillAxisZero = ya.c2p(0, true);
        } else if (ownFillDir === "x") {
          fillAxisIndex = 0;
          fillAxisZero = xa.c2p(0, true);
        }
        cdscatter[0][plotinfo.isRangePlot ? "nodeRangePlot3" : "node3"] = tr;
        var prevRevpath = "";
        var prevPolygons = [];
        var prevtrace = trace._prevtrace;
        var prevFillsegments = null;
        var prevFillElement = null;
        if (prevtrace) {
          prevRevpath = prevtrace._prevRevpath || "";
          tonext = prevtrace._nextFill;
          prevPolygons = prevtrace._ownPolygons;
          prevFillsegments = prevtrace._fillsegments;
          prevFillElement = prevtrace._fillElement;
        }
        var thispath;
        var thisrevpath;
        var fullpath = "";
        var revpath = "";
        var pathfn, revpathbase, revpathfn;
        var pt0, lastSegment, pt1;
        var thisPolygons = [];
        trace._polygons = [];
        var fillsegments = [];
        var segments = [];
        var makeUpdate = Lib.noop;
        ownFillEl3 = trace._ownFill;
        if (subTypes.hasLines(trace) || trace.fill !== "none") {
          if (tonext) {
            tonext.datum(cdscatter);
          }
          if (["hv", "vh", "hvh", "vhv"].indexOf(line.shape) !== -1) {
            pathfn = Drawing.steps(line.shape);
            revpathbase = Drawing.steps(
              line.shape.split("").reverse().join("")
            );
          } else if (line.shape === "spline") {
            pathfn = revpathbase = function(pts2) {
              var pLast = pts2[pts2.length - 1];
              if (pts2.length > 1 && pts2[0][0] === pLast[0] && pts2[0][1] === pLast[1]) {
                return Drawing.smoothclosed(pts2.slice(1), line.smoothing);
              } else {
                return Drawing.smoothopen(pts2, line.smoothing);
              }
            };
          } else {
            pathfn = revpathbase = function(pts2) {
              return "M" + pts2.join("L");
            };
          }
          revpathfn = function(pts2) {
            return revpathbase(pts2.reverse());
          };
          segments = linePoints(cdscatter, {
            xaxis: xa,
            yaxis: ya,
            trace,
            connectGaps: trace.connectgaps,
            baseTolerance: Math.max(line.width || 1, 3) / 4,
            shape: line.shape,
            backoff: line.backoff,
            simplify: line.simplify,
            fill: trace.fill
          });
          fillsegments = new Array(segments.length);
          var fillsegmentCount = 0;
          for (i = 0; i < segments.length; i++) {
            var curpoints;
            var pts = segments[i];
            if (!curpoints || !ownFillDir) {
              curpoints = pts.slice();
              fillsegments[fillsegmentCount] = curpoints;
              fillsegmentCount++;
            } else {
              curpoints.push.apply(curpoints, pts);
            }
          }
          trace._fillElement = null;
          trace._fillExclusionElement = prevFillElement;
          trace._fillsegments = fillsegments.slice(0, fillsegmentCount);
          fillsegments = trace._fillsegments;
          if (segments.length) {
            pt0 = segments[0][0].slice();
            lastSegment = segments[segments.length - 1];
            pt1 = lastSegment[lastSegment.length - 1].slice();
          }
          makeUpdate = function(isEnter) {
            return function(pts2) {
              thispath = pathfn(pts2);
              thisrevpath = revpathfn(pts2);
              if (!fullpath) {
                fullpath = thispath;
                revpath = thisrevpath;
              } else if (ownFillDir) {
                fullpath += "L" + thispath.substr(1);
                revpath = thisrevpath + ("L" + revpath.substr(1));
              } else {
                fullpath += "Z" + thispath;
                revpath = thisrevpath + "Z" + revpath;
              }
              if (subTypes.hasLines(trace)) {
                var el = d3.select(this);
                el.datum(cdscatter);
                if (isEnter) {
                  transition(el.style("opacity", 0).attr("d", thispath).call(Drawing.lineGroupStyle)).style("opacity", 1);
                } else {
                  var sel = transition(el);
                  sel.attr("d", thispath);
                  Drawing.singleLineStyle(cdscatter, sel);
                }
              }
            };
          };
        }
        var lineJoin = lines.selectAll(".js-line").data(segments);
        transition(lineJoin.exit()).style("opacity", 0).remove();
        lineJoin.each(makeUpdate(false));
        lineJoin.enter().append("path").classed("js-line", true).style("vector-effect", isStatic ? "none" : "non-scaling-stroke").call(Drawing.lineGroupStyle).each(makeUpdate(true));
        Drawing.setClipUrl(lineJoin, plotinfo.layerClipId, gd);
        function clearFill(selection) {
          transition(selection).attr("d", "M0,0Z");
        }
        var makeSelfPolygons = function() {
          var polygons = new Array(fillsegments.length);
          for (i = 0; i < fillsegments.length; i++) {
            polygons[i] = polygonTester(fillsegments[i]);
          }
          return polygons;
        };
        var makePolygonsToPrevious = function(prevFillsegments2) {
          var polygons, i2;
          if (!prevFillsegments2 || prevFillsegments2.length === 0) {
            polygons = new Array(fillsegments.length);
            for (i2 = 0; i2 < fillsegments.length; i2++) {
              var pt02 = fillsegments[i2][0].slice();
              var pt12 = fillsegments[i2][fillsegments[i2].length - 1].slice();
              pt02[fillAxisIndex] = pt12[fillAxisIndex] = fillAxisZero;
              var zeropoints = [pt12, pt02];
              var polypoints = zeropoints.concat(fillsegments[i2]);
              polygons[i2] = polygonTester(polypoints);
            }
          } else {
            polygons = new Array(prevFillsegments2.length - 1 + fillsegments.length);
            for (i2 = 0; i2 < prevFillsegments2.length - 1; i2++) {
              polygons[i2] = polygonTester(prevFillsegments2[i2]);
            }
            var reversedPrevFillsegment = prevFillsegments2[prevFillsegments2.length - 1].slice();
            reversedPrevFillsegment.reverse();
            for (i2 = 0; i2 < fillsegments.length; i2++) {
              polygons[prevFillsegments2.length - 1 + i2] = polygonTester(fillsegments[i2].concat(reversedPrevFillsegment));
            }
          }
          return polygons;
        };
        if (segments.length) {
          if (ownFillEl3) {
            ownFillEl3.datum(cdscatter);
            if (pt0 && pt1) {
              if (ownFillDir) {
                pt0[fillAxisIndex] = pt1[fillAxisIndex] = fillAxisZero;
                transition(ownFillEl3).attr("d", "M" + pt1 + "L" + pt0 + "L" + fullpath.substr(1)).call(Drawing.singleFillStyle, gd);
                thisPolygons = makePolygonsToPrevious(null);
              } else {
                transition(ownFillEl3).attr("d", fullpath + "Z").call(Drawing.singleFillStyle, gd);
                thisPolygons = makeSelfPolygons();
              }
            }
            trace._polygons = thisPolygons;
            trace._fillElement = ownFillEl3;
          } else if (tonext) {
            if (trace.fill.substr(0, 6) === "tonext" && fullpath && prevRevpath) {
              if (trace.fill === "tonext") {
                transition(tonext).attr("d", fullpath + "Z" + prevRevpath + "Z").call(Drawing.singleFillStyle, gd);
                thisPolygons = makeSelfPolygons();
                trace._polygons = thisPolygons.concat(prevPolygons);
              } else {
                transition(tonext).attr("d", fullpath + "L" + prevRevpath.substr(1) + "Z").call(Drawing.singleFillStyle, gd);
                thisPolygons = makePolygonsToPrevious(prevFillsegments);
                trace._polygons = thisPolygons;
              }
              trace._fillElement = tonext;
            } else {
              clearFill(tonext);
            }
          }
          trace._prevRevpath = revpath;
        } else {
          if (ownFillEl3) clearFill(ownFillEl3);
          else if (tonext) clearFill(tonext);
          trace._prevRevpath = null;
        }
        trace._ownPolygons = thisPolygons;
        function visFilter(d) {
          return d.filter(function(v) {
            return !v.gap && v.vis;
          });
        }
        function visFilterWithGaps(d) {
          return d.filter(function(v) {
            return v.vis;
          });
        }
        function gapFilter(d) {
          return d.filter(function(v) {
            return !v.gap;
          });
        }
        function keyFunc(d) {
          return d.id;
        }
        function getKeyFunc(trace2) {
          if (trace2.ids) {
            return keyFunc;
          }
        }
        function hideFilter() {
          return false;
        }
        function makePoints(points2, text2, cdscatter2) {
          var join, selection, hasNode;
          var trace2 = cdscatter2[0].trace;
          var showMarkers = subTypes.hasMarkers(trace2);
          var showText = subTypes.hasText(trace2);
          var keyFunc2 = getKeyFunc(trace2);
          var markerFilter = hideFilter;
          var textFilter = hideFilter;
          if (showMarkers || showText) {
            var showFilter = identity;
            var stackGroup = trace2.stackgroup;
            var isInferZero = stackGroup && gd._fullLayout._scatterStackOpts[xa._id + ya._id][stackGroup].stackgaps === "infer zero";
            if (trace2.marker.maxdisplayed || trace2._needsCull) {
              showFilter = isInferZero ? visFilterWithGaps : visFilter;
            } else if (stackGroup && !isInferZero) {
              showFilter = gapFilter;
            }
            if (showMarkers) markerFilter = showFilter;
            if (showText) textFilter = showFilter;
          }
          selection = points2.selectAll("path.point");
          join = selection.data(markerFilter, keyFunc2);
          var enter = join.enter().append("path").classed("point", true);
          if (hasTransition) {
            enter.call(Drawing.pointStyle, trace2, gd).call(Drawing.translatePoints, xa, ya).style("opacity", 0).transition().style("opacity", 1);
          }
          join.order();
          var styleFns;
          if (showMarkers) {
            styleFns = Drawing.makePointStyleFns(trace2);
          }
          join.each(function(d) {
            var el = d3.select(this);
            var sel = transition(el);
            hasNode = Drawing.translatePoint(d, sel, xa, ya);
            if (hasNode) {
              Drawing.singlePointStyle(d, sel, trace2, styleFns, gd);
              if (plotinfo.layerClipId) {
                Drawing.hideOutsideRangePoint(d, sel, xa, ya, trace2.xcalendar, trace2.ycalendar);
              }
              if (trace2.customdata) {
                el.classed("plotly-customdata", d.data !== null && d.data !== void 0);
              }
            } else {
              sel.remove();
            }
          });
          if (hasTransition) {
            join.exit().transition().style("opacity", 0).remove();
          } else {
            join.exit().remove();
          }
          selection = text2.selectAll("g");
          join = selection.data(textFilter, keyFunc2);
          join.enter().append("g").classed("textpoint", true).append("text");
          join.order();
          join.each(function(d) {
            var g = d3.select(this);
            var sel = transition(g.select("text"));
            hasNode = Drawing.translatePoint(d, sel, xa, ya);
            if (hasNode) {
              if (plotinfo.layerClipId) {
                Drawing.hideOutsideRangePoint(d, g, xa, ya, trace2.xcalendar, trace2.ycalendar);
              }
            } else {
              g.remove();
            }
          });
          join.selectAll("text").call(Drawing.textPointStyle, trace2, gd).each(function(d) {
            var x = xa.c2p(d.x);
            var y = ya.c2p(d.y);
            d3.select(this).selectAll("tspan.line").each(function() {
              transition(d3.select(this)).attr({ x, y });
            });
          });
          join.exit().remove();
        }
        points.datum(cdscatter);
        text.datum(cdscatter);
        makePoints(points, text, cdscatter);
        var hasClipOnAxisFalse = trace.cliponaxis === false;
        var clipUrl = hasClipOnAxisFalse ? null : plotinfo.layerClipId;
        Drawing.setClipUrl(points, clipUrl, gd);
        Drawing.setClipUrl(text, clipUrl, gd);
      }
      function selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll) {
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var xr = d3.extent(Lib.simpleMap(xa.range, xa.r2c));
        var yr = d3.extent(Lib.simpleMap(ya.range, ya.r2c));
        var trace = cdscatter[0].trace;
        if (!subTypes.hasMarkers(trace)) return;
        var mnum = trace.marker.maxdisplayed;
        if (mnum === 0) return;
        var cd = cdscatter.filter(function(v) {
          return v.x >= xr[0] && v.x <= xr[1] && v.y >= yr[0] && v.y <= yr[1];
        });
        var inc = Math.ceil(cd.length / mnum);
        var tnum = 0;
        cdscatterAll.forEach(function(cdj, j) {
          var tracei = cdj[0].trace;
          if (subTypes.hasMarkers(tracei) && tracei.marker.maxdisplayed > 0 && j < idx) {
            tnum++;
          }
        });
        var i0 = Math.round(tnum * inc / 3 + Math.floor(tnum / 3) * inc / 7.1);
        cdscatter.forEach(function(v) {
          delete v.vis;
        });
        cd.forEach(function(v, i) {
          if (Math.round((i + i0) % inc) === 0) v.vis = true;
        });
      }
    }
  });

  // src/traces/scatter/marker_colorbar.js
  var require_marker_colorbar = __commonJS({
    "src/traces/scatter/marker_colorbar.js"(exports, module) {
      "use strict";
      module.exports = {
        container: "marker",
        min: "cmin",
        max: "cmax"
      };
    }
  });

  // src/traces/scatter/format_labels.js
  var require_format_labels = __commonJS({
    "src/traces/scatter/format_labels.js"(exports, module) {
      "use strict";
      var Axes = require_axes();
      module.exports = function formatLabels(cdi, trace, fullLayout) {
        var labels = {};
        var mockGd = { _fullLayout: fullLayout };
        var xa = Axes.getFromTrace(mockGd, trace, "x");
        var ya = Axes.getFromTrace(mockGd, trace, "y");
        var x = cdi.orig_x;
        if (x === void 0) x = cdi.x;
        var y = cdi.orig_y;
        if (y === void 0) y = cdi.y;
        labels.xLabel = Axes.tickText(xa, xa.c2l(x), true).text;
        labels.yLabel = Axes.tickText(ya, ya.c2l(y), true).text;
        return labels;
      };
    }
  });

  // src/traces/scatter/style.js
  var require_style2 = __commonJS({
    "src/traces/scatter/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Drawing = require_drawing();
      var Registry = require_registry();
      function style(gd) {
        var s = d3.select(gd).selectAll("g.trace.scatter");
        s.style("opacity", function(d) {
          return d[0].trace.opacity;
        });
        s.selectAll("g.points").each(function(d) {
          var sel = d3.select(this);
          var trace = d.trace || d[0].trace;
          stylePoints(sel, trace, gd);
        });
        s.selectAll("g.text").each(function(d) {
          var sel = d3.select(this);
          var trace = d.trace || d[0].trace;
          styleText(sel, trace, gd);
        });
        s.selectAll("g.trace path.js-line").call(Drawing.lineGroupStyle);
        s.selectAll("g.trace path.js-fill").call(Drawing.fillGroupStyle, gd, false);
        Registry.getComponentMethod("errorbars", "style")(s);
      }
      function stylePoints(sel, trace, gd) {
        Drawing.pointStyle(sel.selectAll("path.point"), trace, gd);
      }
      function styleText(sel, trace, gd) {
        Drawing.textPointStyle(sel.selectAll("text"), trace, gd);
      }
      function styleOnSelect(gd, cd, sel) {
        var trace = cd[0].trace;
        if (trace.selectedpoints) {
          Drawing.selectedPointStyle(sel.selectAll("path.point"), trace);
          Drawing.selectedTextStyle(sel.selectAll("text"), trace);
        } else {
          stylePoints(sel, trace, gd);
          styleText(sel, trace, gd);
        }
      }
      module.exports = {
        style,
        stylePoints,
        styleText,
        styleOnSelect
      };
    }
  });

  // src/traces/scatter/get_trace_color.js
  var require_get_trace_color = __commonJS({
    "src/traces/scatter/get_trace_color.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var subtypes = require_subtypes();
      module.exports = function getTraceColor(trace, di) {
        var lc, tc;
        if (trace.mode === "lines") {
          lc = trace.line.color;
          return lc && Color.opacity(lc) ? lc : trace.fillcolor;
        } else if (trace.mode === "none") {
          return trace.fill ? trace.fillcolor : "";
        } else {
          var mc = di.mcc || (trace.marker || {}).color;
          var mlc = di.mlcc || ((trace.marker || {}).line || {}).color;
          tc = mc && Color.opacity(mc) ? mc : mlc && Color.opacity(mlc) && (di.mlw || ((trace.marker || {}).line || {}).width) ? mlc : "";
          if (tc) {
            if (Color.opacity(tc) < 0.3) {
              return Color.addOpacity(tc, 0.3);
            } else return tc;
          } else {
            lc = (trace.line || {}).color;
            return lc && Color.opacity(lc) && subtypes.hasLines(trace) && trace.line.width ? lc : trace.fillcolor;
          }
        }
      };
    }
  });

  // src/traces/scatter/hover.js
  var require_hover2 = __commonJS({
    "src/traces/scatter/hover.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Fx = require_fx();
      var Registry = require_registry();
      var getTraceColor = require_get_trace_color();
      var Color = require_color();
      var fillText = Lib.fillText;
      module.exports = function hoverPoints(pointData, xval, yval, hovermode) {
        var cd = pointData.cd;
        var trace = cd[0].trace;
        var xa = pointData.xa;
        var ya = pointData.ya;
        var xpx = xa.c2p(xval);
        var ypx = ya.c2p(yval);
        var pt = [xpx, ypx];
        var hoveron = trace.hoveron || "";
        var minRad = trace.mode.indexOf("markers") !== -1 ? 3 : 0.5;
        var xPeriod = !!trace.xperiodalignment;
        var yPeriod = !!trace.yperiodalignment;
        if (hoveron.indexOf("points") !== -1) {
          var dx = function(di2) {
            if (xPeriod) {
              var x0 = xa.c2p(di2.xStart);
              var x1 = xa.c2p(di2.xEnd);
              return xpx >= Math.min(x0, x1) && xpx <= Math.max(x0, x1) ? 0 : Infinity;
            }
            var rad2 = Math.max(3, di2.mrc || 0);
            var kink = 1 - 1 / rad2;
            var dxRaw = Math.abs(xa.c2p(di2.x) - xpx);
            return dxRaw < rad2 ? kink * dxRaw / rad2 : dxRaw - rad2 + kink;
          };
          var dy = function(di2) {
            if (yPeriod) {
              var y0 = ya.c2p(di2.yStart);
              var y1 = ya.c2p(di2.yEnd);
              return ypx >= Math.min(y0, y1) && ypx <= Math.max(y0, y1) ? 0 : Infinity;
            }
            var rad2 = Math.max(3, di2.mrc || 0);
            var kink = 1 - 1 / rad2;
            var dyRaw = Math.abs(ya.c2p(di2.y) - ypx);
            return dyRaw < rad2 ? kink * dyRaw / rad2 : dyRaw - rad2 + kink;
          };
          var dxy = function(di2) {
            var rad2 = Math.max(minRad, di2.mrc || 0);
            var dx2 = xa.c2p(di2.x) - xpx;
            var dy2 = ya.c2p(di2.y) - ypx;
            return Math.max(Math.sqrt(dx2 * dx2 + dy2 * dy2) - rad2, 1 - minRad / rad2);
          };
          var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);
          Fx.getClosest(cd, distfn, pointData);
          if (pointData.index !== false) {
            var di = cd[pointData.index];
            var xc = xa.c2p(di.x, true);
            var yc = ya.c2p(di.y, true);
            var rad = di.mrc || 1;
            pointData.index = di.i;
            var orientation = cd[0].t.orientation;
            var sizeVal = orientation && (di.sNorm || di.s);
            var xLabelVal = orientation === "h" ? sizeVal : di.orig_x !== void 0 ? di.orig_x : di.x;
            var yLabelVal = orientation === "v" ? sizeVal : di.orig_y !== void 0 ? di.orig_y : di.y;
            Lib.extendFlat(pointData, {
              color: getTraceColor(trace, di),
              x0: xc - rad,
              x1: xc + rad,
              xLabelVal,
              y0: yc - rad,
              y1: yc + rad,
              yLabelVal,
              spikeDistance: dxy(di),
              hovertemplate: trace.hovertemplate
            });
            fillText(di, trace, pointData);
            Registry.getComponentMethod("errorbars", "hoverInfo")(di, trace, pointData);
            return [pointData];
          }
        }
        function isHoverPointInFillElement(el) {
          if (!el) {
            return false;
          }
          var svgElement = el.node();
          try {
            var domPoint = new DOMPoint(pt[0], pt[1]);
            return svgElement.isPointInFill(domPoint);
          } catch (TypeError2) {
            var svgPoint = svgElement.ownerSVGElement.createSVGPoint();
            svgPoint.x = pt[0];
            svgPoint.y = pt[1];
            return svgElement.isPointInFill(svgPoint);
          }
        }
        function getHoverLabelPosition(polygons) {
          var i;
          var polygonsIn = [];
          var xmin = Infinity;
          var xmax = -Infinity;
          var ymin = Infinity;
          var ymax = -Infinity;
          var yPos;
          for (i = 0; i < polygons.length; i++) {
            var polygon = polygons[i];
            if (polygon.contains(pt)) {
              polygonsIn.push(polygon);
              ymin = Math.min(ymin, polygon.ymin);
              ymax = Math.max(ymax, polygon.ymax);
            }
          }
          if (polygonsIn.length === 0) {
            return null;
          }
          ymin = Math.max(ymin, 0);
          ymax = Math.min(ymax, ya._length);
          yPos = (ymin + ymax) / 2;
          var j, pts, xAtYPos, x0, x1, y0, y1;
          for (i = 0; i < polygonsIn.length; i++) {
            pts = polygonsIn[i].pts;
            for (j = 1; j < pts.length; j++) {
              y0 = pts[j - 1][1];
              y1 = pts[j][1];
              if (y0 > yPos !== y1 >= yPos) {
                x0 = pts[j - 1][0];
                x1 = pts[j][0];
                if (y1 - y0) {
                  xAtYPos = x0 + (x1 - x0) * (yPos - y0) / (y1 - y0);
                  xmin = Math.min(xmin, xAtYPos);
                  xmax = Math.max(xmax, xAtYPos);
                }
              }
            }
          }
          xmin = Math.max(xmin, 0);
          xmax = Math.min(xmax, xa._length);
          return {
            x0: xmin,
            x1: xmax,
            y0: yPos,
            y1: yPos
          };
        }
        if (hoveron.indexOf("fills") !== -1 && trace._fillElement) {
          var inside = isHoverPointInFillElement(trace._fillElement) && !isHoverPointInFillElement(trace._fillExclusionElement);
          if (inside) {
            var hoverLabelCoords = getHoverLabelPosition(trace._polygons);
            if (hoverLabelCoords === null) {
              hoverLabelCoords = {
                x0: pt[0],
                x1: pt[0],
                y0: pt[1],
                y1: pt[1]
              };
            }
            var color = Color.defaultLine;
            if (Color.opacity(trace.fillcolor)) color = trace.fillcolor;
            else if (Color.opacity((trace.line || {}).color)) {
              color = trace.line.color;
            }
            Lib.extendFlat(pointData, {
              // never let a 2D override 1D type as closest point
              // also: no spikeDistance, it's not allowed for fills
              distance: pointData.maxHoverDistance,
              x0: hoverLabelCoords.x0,
              x1: hoverLabelCoords.x1,
              y0: hoverLabelCoords.y0,
              y1: hoverLabelCoords.y1,
              color,
              hovertemplate: false
            });
            delete pointData.index;
            if (trace.text && !Lib.isArrayOrTypedArray(trace.text)) {
              pointData.text = String(trace.text);
            } else pointData.text = trace.name;
            return [pointData];
          }
        }
      };
    }
  });

  // src/traces/scatter/select.js
  var require_select2 = __commonJS({
    "src/traces/scatter/select.js"(exports, module) {
      "use strict";
      var subtypes = require_subtypes();
      module.exports = function selectPoints(searchInfo, selectionTester) {
        var cd = searchInfo.cd;
        var xa = searchInfo.xaxis;
        var ya = searchInfo.yaxis;
        var selection = [];
        var trace = cd[0].trace;
        var i;
        var di;
        var x;
        var y;
        var hasOnlyLines = !subtypes.hasMarkers(trace) && !subtypes.hasText(trace);
        if (hasOnlyLines) return [];
        if (selectionTester === false) {
          for (i = 0; i < cd.length; i++) {
            cd[i].selected = 0;
          }
        } else {
          for (i = 0; i < cd.length; i++) {
            di = cd[i];
            x = xa.c2p(di.x);
            y = ya.c2p(di.y);
            if (di.i !== null && selectionTester.contains([x, y], false, i, searchInfo)) {
              selection.push({
                pointNumber: di.i,
                x: xa.c2d(di.x),
                y: ya.c2d(di.y)
              });
              di.selected = 1;
            } else {
              di.selected = 0;
            }
          }
        }
        return selection;
      };
    }
  });

  // src/plots/cartesian/attributes.js
  var require_attributes14 = __commonJS({
    "src/plots/cartesian/attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        xaxis: {
          valType: "subplotid",
          dflt: "x",
          editType: "calc+clearAxisTypes"
        },
        yaxis: {
          valType: "subplotid",
          dflt: "y",
          editType: "calc+clearAxisTypes"
        }
      };
    }
  });

  // src/plots/cartesian/type_defaults.js
  var require_type_defaults = __commonJS({
    "src/plots/cartesian/type_defaults.js"(exports, module) {
      "use strict";
      var traceIs = require_registry().traceIs;
      var autoType = require_axis_autotype();
      module.exports = function handleTypeDefaults(containerIn, containerOut, coerce, options) {
        coerce("autotypenumbers", options.autotypenumbersDflt);
        var axType = coerce("type", (options.splomStash || {}).type);
        if (axType === "-") {
          setAutoType(containerOut, options.data);
          if (containerOut.type === "-") {
            containerOut.type = "linear";
          } else {
            containerIn.type = containerOut.type;
          }
        }
      };
      function setAutoType(ax, data) {
        if (ax.type !== "-") return;
        var id = ax._id;
        var axLetter = id.charAt(0);
        var i;
        if (id.indexOf("scene") !== -1) id = axLetter;
        var d0 = getFirstNonEmptyTrace(data, id, axLetter);
        if (!d0) return;
        if (d0.type === "histogram" && axLetter === { v: "y", h: "x" }[d0.orientation || "v"]) {
          ax.type = "linear";
          return;
        }
        var calAttr = axLetter + "calendar";
        var calendar = d0[calAttr];
        var opts = { noMultiCategory: !traceIs(d0, "cartesian") || traceIs(d0, "noMultiCategory") };
        if (d0.type === "box" && d0._hasPreCompStats && axLetter === { h: "x", v: "y" }[d0.orientation || "v"]) {
          opts.noMultiCategory = true;
        }
        opts.autotypenumbers = ax.autotypenumbers;
        if (isBoxWithoutPositionCoords(d0, axLetter)) {
          var posLetter = getBoxPosLetter(d0);
          var boxPositions = [];
          for (i = 0; i < data.length; i++) {
            var trace = data[i];
            if (!traceIs(trace, "box-violin") || (trace[axLetter + "axis"] || axLetter) !== id) continue;
            if (trace[posLetter] !== void 0) boxPositions.push(trace[posLetter][0]);
            else if (trace.name !== void 0) boxPositions.push(trace.name);
            else boxPositions.push("text");
            if (trace[calAttr] !== calendar) calendar = void 0;
          }
          ax.type = autoType(boxPositions, calendar, opts);
        } else if (d0.type === "splom") {
          var dimensions = d0.dimensions;
          var dim = dimensions[d0._axesDim[id]];
          if (dim.visible) ax.type = autoType(dim.values, calendar, opts);
        } else {
          ax.type = autoType(d0[axLetter] || [d0[axLetter + "0"]], calendar, opts);
        }
      }
      function getFirstNonEmptyTrace(data, id, axLetter) {
        for (var i = 0; i < data.length; i++) {
          var trace = data[i];
          if (trace.type === "splom" && trace._length > 0 && (trace["_" + axLetter + "axes"] || {})[id]) {
            return trace;
          }
          if ((trace[axLetter + "axis"] || axLetter) === id) {
            if (isBoxWithoutPositionCoords(trace, axLetter)) {
              return trace;
            } else if ((trace[axLetter] || []).length || trace[axLetter + "0"]) {
              return trace;
            }
          }
        }
      }
      function getBoxPosLetter(trace) {
        return { v: "x", h: "y" }[trace.orientation || "v"];
      }
      function isBoxWithoutPositionCoords(trace, axLetter) {
        var posLetter = getBoxPosLetter(trace);
        var isBox = traceIs(trace, "box-violin");
        var isCandlestick = traceIs(trace._fullInput || {}, "candlestick");
        return isBox && !isCandlestick && axLetter === posLetter && trace[posLetter] === void 0 && trace[posLetter + "0"] === void 0;
      }
    }
  });

  // src/plots/cartesian/category_order_defaults.js
  var require_category_order_defaults = __commonJS({
    "src/plots/cartesian/category_order_defaults.js"(exports, module) {
      "use strict";
      var isTypedArraySpec = require_array().isTypedArraySpec;
      function findCategories(ax, opts) {
        var dataAttr = opts.dataAttr || ax._id.charAt(0);
        var lookup = {};
        var axData;
        var i, j;
        if (opts.axData) {
          axData = opts.axData;
        } else {
          axData = [];
          for (i = 0; i < opts.data.length; i++) {
            var trace = opts.data[i];
            if (trace[dataAttr + "axis"] === ax._id) {
              axData.push(trace);
            }
          }
        }
        for (i = 0; i < axData.length; i++) {
          var vals = axData[i][dataAttr];
          for (j = 0; j < vals.length; j++) {
            var v = vals[j];
            if (v !== null && v !== void 0) {
              lookup[v] = 1;
            }
          }
        }
        return Object.keys(lookup);
      }
      module.exports = function handleCategoryOrderDefaults(containerIn, containerOut, coerce, opts) {
        if (containerOut.type !== "category") return;
        var arrayIn = containerIn.categoryarray;
        var isValidArray = Array.isArray(arrayIn) && arrayIn.length > 0 || isTypedArraySpec(arrayIn);
        var orderDefault;
        if (isValidArray) orderDefault = "array";
        var order = coerce("categoryorder", orderDefault);
        var array;
        if (order === "array") {
          array = coerce("categoryarray");
        }
        if (!isValidArray && order === "array") {
          order = containerOut.categoryorder = "trace";
        }
        if (order === "trace") {
          containerOut._initialCategories = [];
        } else if (order === "array") {
          containerOut._initialCategories = array.slice();
        } else {
          array = findCategories(containerOut, opts).sort();
          if (order === "category ascending") {
            containerOut._initialCategories = array;
          } else if (order === "category descending") {
            containerOut._initialCategories = array.reverse();
          }
        }
      };
    }
  });

  // src/plots/cartesian/line_grid_defaults.js
  var require_line_grid_defaults = __commonJS({
    "src/plots/cartesian/line_grid_defaults.js"(exports, module) {
      "use strict";
      var colorMix = require_tinycolor().mix;
      var colorAttrs = require_attributes3();
      var Lib = require_lib();
      module.exports = function handleLineGridDefaults(containerIn, containerOut, coerce, opts) {
        opts = opts || {};
        var dfltColor = opts.dfltColor;
        function coerce2(attr, dflt) {
          return Lib.coerce2(containerIn, containerOut, opts.attributes, attr, dflt);
        }
        var lineColor = coerce2("linecolor", dfltColor);
        var lineWidth = coerce2("linewidth");
        var showLine = coerce("showline", opts.showLine || !!lineColor || !!lineWidth);
        if (!showLine) {
          delete containerOut.linecolor;
          delete containerOut.linewidth;
        }
        var gridColorDflt = colorMix(dfltColor, opts.bgColor, opts.blend || colorAttrs.lightFraction).toRgbString();
        var gridColor = coerce2("gridcolor", gridColorDflt);
        var gridWidth = coerce2("gridwidth");
        var gridDash = coerce2("griddash");
        var showGridLines = coerce(
          "showgrid",
          opts.showGrid || !!gridColor || !!gridWidth || !!gridDash
        );
        if (!showGridLines) {
          delete containerOut.gridcolor;
          delete containerOut.gridwidth;
          delete containerOut.griddash;
        }
        if (opts.hasMinor) {
          var minorGridColorDflt = colorMix(containerOut.gridcolor, opts.bgColor, 67).toRgbString();
          var minorGridColor = coerce2("minor.gridcolor", minorGridColorDflt);
          var minorGridWidth = coerce2("minor.gridwidth", containerOut.gridwidth || 1);
          var minorGridDash = coerce2("minor.griddash", containerOut.griddash || "solid");
          var minorShowGridLines = coerce(
            "minor.showgrid",
            !!minorGridColor || !!minorGridWidth || !!minorGridDash
          );
          if (!minorShowGridLines) {
            delete containerOut.minor.gridcolor;
            delete containerOut.minor.gridwidth;
            delete containerOut.minor.griddash;
          }
        }
        if (!opts.noZeroLine) {
          var zeroLineColor = coerce2("zerolinecolor", dfltColor);
          var zeroLineWidth = coerce2("zerolinewidth");
          var showZeroLine = coerce("zeroline", opts.showGrid || !!zeroLineColor || !!zeroLineWidth);
          if (!showZeroLine) {
            delete containerOut.zerolinecolor;
            delete containerOut.zerolinewidth;
          }
        }
      };
    }
  });

  // src/plots/cartesian/axis_defaults.js
  var require_axis_defaults = __commonJS({
    "src/plots/cartesian/axis_defaults.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Registry = require_registry();
      var Lib = require_lib();
      var Template = require_plot_template();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var layoutAttributes = require_layout_attributes4();
      var handleTickValueDefaults = require_tick_value_defaults();
      var handleTickMarkDefaults = require_tick_mark_defaults();
      var handleTickLabelDefaults = require_tick_label_defaults();
      var handlePrefixSuffixDefaults = require_prefix_suffix_defaults();
      var handleCategoryOrderDefaults = require_category_order_defaults();
      var handleLineGridDefaults = require_line_grid_defaults();
      var handleRangeDefaults = require_range_defaults();
      var setConvert = require_set_convert();
      var DAY_OF_WEEK = require_constants2().WEEKDAY_PATTERN;
      var HOUR = require_constants2().HOUR_PATTERN;
      module.exports = function handleAxisDefaults(containerIn, containerOut, coerce, options, layoutOut) {
        var letter = options.letter;
        var font = options.font || {};
        var splomStash = options.splomStash || {};
        var visible = coerce("visible", !options.visibleDflt);
        var axTemplate = containerOut._template || {};
        var axType = containerOut.type || axTemplate.type || "-";
        var ticklabelmode;
        if (axType === "date") {
          var handleCalendarDefaults = Registry.getComponentMethod("calendars", "handleDefaults");
          handleCalendarDefaults(containerIn, containerOut, "calendar", options.calendar);
          if (!options.noTicklabelmode) {
            ticklabelmode = coerce("ticklabelmode");
          }
        }
        if (!options.noTicklabelindex && (axType === "date" || axType === "linear")) {
          coerce("ticklabelindex");
        }
        var ticklabelposition = "";
        if (!options.noTicklabelposition || axType === "multicategory") {
          ticklabelposition = Lib.coerce(containerIn, containerOut, {
            ticklabelposition: {
              valType: "enumerated",
              dflt: "outside",
              values: ticklabelmode === "period" ? ["outside", "inside"] : letter === "x" ? [
                "outside",
                "inside",
                "outside left",
                "inside left",
                "outside right",
                "inside right"
              ] : [
                "outside",
                "inside",
                "outside top",
                "inside top",
                "outside bottom",
                "inside bottom"
              ]
            }
          }, "ticklabelposition");
        }
        if (!options.noTicklabeloverflow) {
          coerce(
            "ticklabeloverflow",
            ticklabelposition.indexOf("inside") !== -1 ? "hide past domain" : axType === "category" || axType === "multicategory" ? "allow" : "hide past div"
          );
        }
        setConvert(containerOut, layoutOut);
        handleRangeDefaults(containerIn, containerOut, coerce, options);
        handleCategoryOrderDefaults(containerIn, containerOut, coerce, options);
        if (axType !== "category" && !options.noHover) coerce("hoverformat");
        var dfltColor = coerce("color");
        var dfltFontColor = dfltColor !== layoutAttributes.color.dflt ? dfltColor : font.color;
        var dfltTitle = splomStash.label || layoutOut._dfltTitle[letter];
        handlePrefixSuffixDefaults(containerIn, containerOut, coerce, axType, options);
        if (!visible) return containerOut;
        coerce("title.text", dfltTitle);
        Lib.coerceFont(coerce, "title.font", font, { overrideDflt: {
          size: Lib.bigFont(font.size),
          color: dfltFontColor
        } });
        handleTickValueDefaults(containerIn, containerOut, coerce, axType);
        var hasMinor = options.hasMinor;
        if (hasMinor) {
          Template.newContainer(containerOut, "minor");
          handleTickValueDefaults(containerIn, containerOut, coerce, axType, { isMinor: true });
        }
        handleTickLabelDefaults(containerIn, containerOut, coerce, axType, options);
        handleTickMarkDefaults(containerIn, containerOut, coerce, options);
        if (hasMinor) {
          var keepIsMinor = options.isMinor;
          options.isMinor = true;
          handleTickMarkDefaults(containerIn, containerOut, coerce, options);
          options.isMinor = keepIsMinor;
        }
        handleLineGridDefaults(containerIn, containerOut, coerce, {
          dfltColor,
          bgColor: options.bgColor,
          showGrid: options.showGrid,
          hasMinor,
          attributes: layoutAttributes
        });
        if (hasMinor && !containerOut.minor.ticks && !containerOut.minor.showgrid) {
          delete containerOut.minor;
        }
        if (containerOut.showline || containerOut.ticks) coerce("mirror");
        var isMultiCategory = axType === "multicategory";
        if (!options.noTickson && (axType === "category" || isMultiCategory) && (containerOut.ticks || containerOut.showgrid)) {
          var ticksonDflt;
          if (isMultiCategory) ticksonDflt = "boundaries";
          var tickson = coerce("tickson", ticksonDflt);
          if (tickson === "boundaries") {
            delete containerOut.ticklabelposition;
          }
        }
        if (isMultiCategory) {
          var showDividers = coerce("showdividers");
          if (showDividers) {
            coerce("dividercolor");
            coerce("dividerwidth");
          }
        }
        if (axType === "date") {
          handleArrayContainerDefaults(containerIn, containerOut, {
            name: "rangebreaks",
            inclusionAttr: "enabled",
            handleItemDefaults: rangebreaksDefaults
          });
          if (!containerOut.rangebreaks.length) {
            delete containerOut.rangebreaks;
          } else {
            for (var k = 0; k < containerOut.rangebreaks.length; k++) {
              if (containerOut.rangebreaks[k].pattern === DAY_OF_WEEK) {
                containerOut._hasDayOfWeekBreaks = true;
                break;
              }
            }
            setConvert(containerOut, layoutOut);
            if (layoutOut._has("scattergl") || layoutOut._has("splom")) {
              for (var i = 0; i < options.data.length; i++) {
                var trace = options.data[i];
                if (trace.type === "scattergl" || trace.type === "splom") {
                  trace.visible = false;
                  Lib.warn(trace.type + " traces do not work on axes with rangebreaks. Setting trace " + trace.index + " to `visible: false`.");
                }
              }
            }
          }
        }
        return containerOut;
      };
      function rangebreaksDefaults(itemIn, itemOut, containerOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(itemIn, itemOut, layoutAttributes.rangebreaks, attr, dflt);
        }
        var enabled = coerce("enabled");
        if (enabled) {
          var bnds = coerce("bounds");
          if (bnds && bnds.length >= 2) {
            var dfltPattern = "";
            var i, q;
            if (bnds.length === 2) {
              for (i = 0; i < 2; i++) {
                q = indexOfDay(bnds[i]);
                if (q) {
                  dfltPattern = DAY_OF_WEEK;
                  break;
                }
              }
            }
            var pattern = coerce("pattern", dfltPattern);
            if (pattern === DAY_OF_WEEK) {
              for (i = 0; i < 2; i++) {
                q = indexOfDay(bnds[i]);
                if (q) {
                  itemOut.bounds[i] = bnds[i] = q - 1;
                }
              }
            }
            if (pattern) {
              for (i = 0; i < 2; i++) {
                q = bnds[i];
                switch (pattern) {
                  case DAY_OF_WEEK:
                    if (!isNumeric(q)) {
                      itemOut.enabled = false;
                      return;
                    }
                    q = +q;
                    if (q !== Math.floor(q) || // don't accept fractional days for mow
                    q < 0 || q >= 7) {
                      itemOut.enabled = false;
                      return;
                    }
                    itemOut.bounds[i] = bnds[i] = q;
                    break;
                  case HOUR:
                    if (!isNumeric(q)) {
                      itemOut.enabled = false;
                      return;
                    }
                    q = +q;
                    if (q < 0 || q > 24) {
                      itemOut.enabled = false;
                      return;
                    }
                    itemOut.bounds[i] = bnds[i] = q;
                    break;
                }
              }
            }
            if (containerOut.autorange === false) {
              var rng = containerOut.range;
              if (rng[0] < rng[1]) {
                if (bnds[0] < rng[0] && bnds[1] > rng[1]) {
                  itemOut.enabled = false;
                  return;
                }
              } else if (bnds[0] > rng[0] && bnds[1] < rng[1]) {
                itemOut.enabled = false;
                return;
              }
            }
          } else {
            var values = coerce("values");
            if (values && values.length) {
              coerce("dvalue");
            } else {
              itemOut.enabled = false;
              return;
            }
          }
        }
      }
      var dayStrToNum = {
        sun: 1,
        mon: 2,
        tue: 3,
        wed: 4,
        thu: 5,
        fri: 6,
        sat: 7
      };
      function indexOfDay(v) {
        if (typeof v !== "string") return;
        return dayStrToNum[v.substr(0, 3).toLowerCase()];
      }
    }
  });

  // src/plots/cartesian/position_defaults.js
  var require_position_defaults = __commonJS({
    "src/plots/cartesian/position_defaults.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      module.exports = function handlePositionDefaults(containerIn, containerOut, coerce, options) {
        var counterAxes = options.counterAxes || [];
        var overlayableAxes = options.overlayableAxes || [];
        var letter = options.letter;
        var grid = options.grid;
        var overlayingDomain = options.overlayingDomain;
        var dfltAnchor, dfltDomain, dfltSide, dfltPosition, dfltShift, dfltAutomargin;
        if (grid) {
          dfltDomain = grid._domains[letter][grid._axisMap[containerOut._id]];
          dfltAnchor = grid._anchors[containerOut._id];
          if (dfltDomain) {
            dfltSide = grid[letter + "side"].split(" ")[0];
            dfltPosition = grid.domain[letter][dfltSide === "right" || dfltSide === "top" ? 1 : 0];
          }
        }
        dfltDomain = dfltDomain || [0, 1];
        dfltAnchor = dfltAnchor || (isNumeric(containerIn.position) ? "free" : counterAxes[0] || "free");
        dfltSide = dfltSide || (letter === "x" ? "bottom" : "left");
        dfltPosition = dfltPosition || 0;
        dfltShift = 0;
        dfltAutomargin = false;
        var anchor = Lib.coerce(containerIn, containerOut, {
          anchor: {
            valType: "enumerated",
            values: ["free"].concat(counterAxes),
            dflt: dfltAnchor
          }
        }, "anchor");
        var side = Lib.coerce(containerIn, containerOut, {
          side: {
            valType: "enumerated",
            values: letter === "x" ? ["bottom", "top"] : ["left", "right"],
            dflt: dfltSide
          }
        }, "side");
        if (anchor === "free") {
          if (letter === "y") {
            var autoshift = coerce("autoshift");
            if (autoshift) {
              dfltPosition = side === "left" ? overlayingDomain[0] : overlayingDomain[1];
              dfltAutomargin = containerOut.automargin ? containerOut.automargin : true;
              dfltShift = side === "left" ? -3 : 3;
            }
            coerce("shift", dfltShift);
          }
          coerce("position", dfltPosition);
        }
        coerce("automargin", dfltAutomargin);
        var overlaying = false;
        if (overlayableAxes.length) {
          overlaying = Lib.coerce(containerIn, containerOut, {
            overlaying: {
              valType: "enumerated",
              values: [false].concat(overlayableAxes),
              dflt: false
            }
          }, "overlaying");
        }
        if (!overlaying) {
          var domain = coerce("domain", dfltDomain);
          if (domain[0] > domain[1] - 1 / 4096) containerOut.domain = dfltDomain;
          Lib.noneOrAll(containerIn.domain, containerOut.domain, dfltDomain);
          if (containerOut.tickmode === "sync") {
            containerOut.tickmode = "auto";
          }
        }
        coerce("layer");
        return containerOut;
      };
    }
  });

  // src/plots/cartesian/layout_defaults.js
  var require_layout_defaults4 = __commonJS({
    "src/plots/cartesian/layout_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Color = require_color();
      var isUnifiedHover = require_helpers2().isUnifiedHover;
      var handleHoverModeDefaults = require_hovermode_defaults();
      var Template = require_plot_template();
      var basePlotLayoutAttributes = require_layout_attributes2();
      var layoutAttributes = require_layout_attributes4();
      var handleTypeDefaults = require_type_defaults();
      var handleAxisDefaults = require_axis_defaults();
      var constraints = require_constraints();
      var handlePositionDefaults = require_position_defaults();
      var axisIds = require_axis_ids();
      var id2name = axisIds.id2name;
      var name2id = axisIds.name2id;
      var AX_ID_PATTERN = require_constants2().AX_ID_PATTERN;
      var Registry = require_registry();
      var traceIs = Registry.traceIs;
      var getComponentMethod = Registry.getComponentMethod;
      function appendList(cont, k, item) {
        if (Array.isArray(cont[k])) cont[k].push(item);
        else cont[k] = [item];
      }
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {
        var autotypenumbersDflt = layoutOut.autotypenumbers;
        var ax2traces = {};
        var xaMayHide = {};
        var yaMayHide = {};
        var xaMustDisplay = {};
        var yaMustDisplay = {};
        var yaMustNotReverse = {};
        var yaMayReverse = {};
        var axHasImage = {};
        var outerTicks = {};
        var noGrids = {};
        var i, j;
        for (i = 0; i < fullData.length; i++) {
          var trace = fullData[i];
          if (!traceIs(trace, "cartesian")) continue;
          var xaName;
          if (trace.xaxis) {
            xaName = id2name(trace.xaxis);
            appendList(ax2traces, xaName, trace);
          } else if (trace.xaxes) {
            for (j = 0; j < trace.xaxes.length; j++) {
              appendList(ax2traces, id2name(trace.xaxes[j]), trace);
            }
          }
          var yaName;
          if (trace.yaxis) {
            yaName = id2name(trace.yaxis);
            appendList(ax2traces, yaName, trace);
          } else if (trace.yaxes) {
            for (j = 0; j < trace.yaxes.length; j++) {
              appendList(ax2traces, id2name(trace.yaxes[j]), trace);
            }
          }
          if (trace.type === "funnel") {
            if (trace.orientation === "h") {
              if (xaName) xaMayHide[xaName] = true;
              if (yaName) yaMayReverse[yaName] = true;
            } else {
              if (yaName) yaMayHide[yaName] = true;
            }
          } else if (trace.type === "image") {
            if (yaName) axHasImage[yaName] = true;
            if (xaName) axHasImage[xaName] = true;
          } else {
            if (yaName) {
              yaMustDisplay[yaName] = true;
              yaMustNotReverse[yaName] = true;
            }
            if (!traceIs(trace, "carpet") || trace.type === "carpet" && !trace._cheater) {
              if (xaName) xaMustDisplay[xaName] = true;
            }
          }
          if (trace.type === "carpet" && trace._cheater) {
            if (xaName) xaMayHide[xaName] = true;
          }
          if (traceIs(trace, "2dMap")) {
            outerTicks[xaName] = true;
            outerTicks[yaName] = true;
          }
          if (traceIs(trace, "oriented")) {
            var positionAxis = trace.orientation === "h" ? yaName : xaName;
            noGrids[positionAxis] = true;
          }
        }
        var subplots = layoutOut._subplots;
        var xIds = subplots.xaxis;
        var yIds = subplots.yaxis;
        var xNames = Lib.simpleMap(xIds, id2name);
        var yNames = Lib.simpleMap(yIds, id2name);
        var axNames = xNames.concat(yNames);
        var plotBgColor = Color.background;
        if (xIds.length && yIds.length) {
          plotBgColor = Lib.coerce(layoutIn, layoutOut, basePlotLayoutAttributes, "plot_bgcolor");
        }
        var bgColor = Color.combine(plotBgColor, layoutOut.paper_bgcolor);
        var axName;
        var axId;
        var axLetter;
        var axLayoutIn;
        var axLayoutOut;
        function newAxLayoutOut() {
          var traces = ax2traces[axName] || [];
          axLayoutOut._traceIndices = traces.map(function(t) {
            return t.index;
          });
          axLayoutOut._annIndices = [];
          axLayoutOut._shapeIndices = [];
          axLayoutOut._selectionIndices = [];
          axLayoutOut._imgIndices = [];
          axLayoutOut._subplotsWith = [];
          axLayoutOut._counterAxes = [];
          axLayoutOut._name = axLayoutOut._attr = axName;
          axLayoutOut._id = axId;
        }
        function coerce(attr, dflt) {
          return Lib.coerce(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);
        }
        function coerce2(attr, dflt) {
          return Lib.coerce2(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);
        }
        function getCounterAxes(axLetter2) {
          return axLetter2 === "x" ? yIds : xIds;
        }
        function getOverlayableAxes(axLetter2, axName2) {
          var list = axLetter2 === "x" ? xNames : yNames;
          var out = [];
          for (var j2 = 0; j2 < list.length; j2++) {
            var axName22 = list[j2];
            if (axName22 !== axName2 && !(layoutIn[axName22] || {}).overlaying) {
              out.push(name2id(axName22));
            }
          }
          return out;
        }
        var counterAxes = { x: getCounterAxes("x"), y: getCounterAxes("y") };
        var allAxisIds = counterAxes.x.concat(counterAxes.y);
        var missingMatchedAxisIdsLookup = {};
        var missingMatchedAxisIds = [];
        function addMissingMatchedAxis() {
          var matchesIn = axLayoutIn.matches;
          if (AX_ID_PATTERN.test(matchesIn) && allAxisIds.indexOf(matchesIn) === -1) {
            missingMatchedAxisIdsLookup[matchesIn] = axLayoutIn.type;
            missingMatchedAxisIds = Object.keys(missingMatchedAxisIdsLookup);
          }
        }
        var hovermode = handleHoverModeDefaults(layoutIn, layoutOut);
        var unifiedHover = isUnifiedHover(hovermode);
        for (i = 0; i < axNames.length; i++) {
          axName = axNames[i];
          axId = name2id(axName);
          axLetter = axName.charAt(0);
          if (!Lib.isPlainObject(layoutIn[axName])) {
            layoutIn[axName] = {};
          }
          axLayoutIn = layoutIn[axName];
          axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + "axis");
          newAxLayoutOut();
          var visibleDflt = axLetter === "x" && !xaMustDisplay[axName] && xaMayHide[axName] || axLetter === "y" && !yaMustDisplay[axName] && yaMayHide[axName];
          var reverseDflt = axLetter === "y" && (!yaMustNotReverse[axName] && yaMayReverse[axName] || axHasImage[axName]);
          var defaultOptions = {
            hasMinor: true,
            letter: axLetter,
            font: layoutOut.font,
            outerTicks: outerTicks[axName],
            showGrid: !noGrids[axName],
            data: ax2traces[axName] || [],
            bgColor,
            calendar: layoutOut.calendar,
            automargin: true,
            visibleDflt,
            reverseDflt,
            autotypenumbersDflt,
            splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId],
            noAutotickangles: axLetter === "y"
          };
          coerce("uirevision", layoutOut.uirevision);
          handleTypeDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions);
          handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions, layoutOut);
          var unifiedSpike = unifiedHover && axLetter === hovermode.charAt(0);
          var spikecolor = coerce2("spikecolor", unifiedHover ? axLayoutOut.color : void 0);
          var spikethickness = coerce2("spikethickness", unifiedHover ? 1.5 : void 0);
          var spikedash = coerce2("spikedash", unifiedHover ? "dot" : void 0);
          var spikemode = coerce2("spikemode", unifiedHover ? "across" : void 0);
          var spikesnap = coerce2("spikesnap");
          var showSpikes = coerce("showspikes", !!unifiedSpike || !!spikecolor || !!spikethickness || !!spikedash || !!spikemode || !!spikesnap);
          if (!showSpikes) {
            delete axLayoutOut.spikecolor;
            delete axLayoutOut.spikethickness;
            delete axLayoutOut.spikedash;
            delete axLayoutOut.spikemode;
            delete axLayoutOut.spikesnap;
          }
          var overlayingAxis = id2name(axLayoutIn.overlaying);
          var overlayingAnchorDomain = [0, 1];
          if (layoutOut[overlayingAxis] !== void 0) {
            var overlayingAnchor = id2name(layoutOut[overlayingAxis].anchor);
            if (layoutOut[overlayingAnchor] !== void 0) {
              overlayingAnchorDomain = layoutOut[overlayingAnchor].domain;
            }
          }
          handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {
            letter: axLetter,
            counterAxes: counterAxes[axLetter],
            overlayableAxes: getOverlayableAxes(axLetter, axName),
            grid: layoutOut.grid,
            overlayingDomain: overlayingAnchorDomain
          });
          coerce("title.standoff");
          addMissingMatchedAxis();
          axLayoutOut._input = axLayoutIn;
        }
        i = 0;
        while (i < missingMatchedAxisIds.length) {
          axId = missingMatchedAxisIds[i++];
          axName = id2name(axId);
          axLetter = axName.charAt(0);
          if (!Lib.isPlainObject(layoutIn[axName])) {
            layoutIn[axName] = {};
          }
          axLayoutIn = layoutIn[axName];
          axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + "axis");
          newAxLayoutOut();
          var defaultOptions2 = {
            letter: axLetter,
            font: layoutOut.font,
            outerTicks: outerTicks[axName],
            showGrid: !noGrids[axName],
            data: [],
            bgColor,
            calendar: layoutOut.calendar,
            automargin: true,
            visibleDflt: false,
            reverseDflt: false,
            autotypenumbersDflt,
            splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId]
          };
          coerce("uirevision", layoutOut.uirevision);
          axLayoutOut.type = missingMatchedAxisIdsLookup[axId] || "linear";
          handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions2, layoutOut);
          handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {
            letter: axLetter,
            counterAxes: counterAxes[axLetter],
            overlayableAxes: getOverlayableAxes(axLetter, axName),
            grid: layoutOut.grid
          });
          coerce("fixedrange");
          addMissingMatchedAxis();
          axLayoutOut._input = axLayoutIn;
        }
        var rangeSliderDefaults = getComponentMethod("rangeslider", "handleDefaults");
        var rangeSelectorDefaults = getComponentMethod("rangeselector", "handleDefaults");
        for (i = 0; i < xNames.length; i++) {
          axName = xNames[i];
          axLayoutIn = layoutIn[axName];
          axLayoutOut = layoutOut[axName];
          rangeSliderDefaults(layoutIn, layoutOut, axName);
          if (axLayoutOut.type === "date") {
            rangeSelectorDefaults(
              axLayoutIn,
              axLayoutOut,
              layoutOut,
              yNames,
              axLayoutOut.calendar
            );
          }
          coerce("fixedrange");
        }
        for (i = 0; i < yNames.length; i++) {
          axName = yNames[i];
          axLayoutIn = layoutIn[axName];
          axLayoutOut = layoutOut[axName];
          var anchoredAxis = layoutOut[id2name(axLayoutOut.anchor)];
          var fixedRangeDflt = getComponentMethod("rangeslider", "isVisible")(anchoredAxis);
          coerce("fixedrange", fixedRangeDflt);
        }
        constraints.handleDefaults(layoutIn, layoutOut, {
          axIds: allAxisIds.concat(missingMatchedAxisIds).sort(axisIds.idSort),
          axHasImage
        });
      };
    }
  });

  // src/plots/cartesian/transition_axes.js
  var require_transition_axes = __commonJS({
    "src/plots/cartesian/transition_axes.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Lib = require_lib();
      var Drawing = require_drawing();
      var Axes = require_axes();
      module.exports = function transitionAxes(gd, edits, transitionOpts, makeOnCompleteCallback) {
        var fullLayout = gd._fullLayout;
        if (edits.length === 0) {
          Axes.redrawComponents(gd);
          return;
        }
        function unsetSubplotTransform(subplot) {
          var xa = subplot.xaxis;
          var ya = subplot.yaxis;
          fullLayout._defs.select("#" + subplot.clipId + "> rect").call(Drawing.setTranslate, 0, 0).call(Drawing.setScale, 1, 1);
          subplot.plot.call(Drawing.setTranslate, xa._offset, ya._offset).call(Drawing.setScale, 1, 1);
          var traceGroups = subplot.plot.selectAll(".scatterlayer .trace");
          traceGroups.selectAll(".point").call(Drawing.setPointGroupScale, 1, 1);
          traceGroups.selectAll(".textpoint").call(Drawing.setTextPointsScale, 1, 1);
          traceGroups.call(Drawing.hideOutsideRangePoints, subplot);
        }
        function updateSubplot(edit, progress) {
          var plotinfo = edit.plotinfo;
          var xa = plotinfo.xaxis;
          var ya = plotinfo.yaxis;
          var xlen = xa._length;
          var ylen = ya._length;
          var editX = !!edit.xr1;
          var editY = !!edit.yr1;
          var viewBox = [];
          if (editX) {
            var xr0 = Lib.simpleMap(edit.xr0, xa.r2l);
            var xr1 = Lib.simpleMap(edit.xr1, xa.r2l);
            var dx0 = xr0[1] - xr0[0];
            var dx1 = xr1[1] - xr1[0];
            viewBox[0] = (xr0[0] * (1 - progress) + progress * xr1[0] - xr0[0]) / (xr0[1] - xr0[0]) * xlen;
            viewBox[2] = xlen * (1 - progress + progress * dx1 / dx0);
            xa.range[0] = xa.l2r(xr0[0] * (1 - progress) + progress * xr1[0]);
            xa.range[1] = xa.l2r(xr0[1] * (1 - progress) + progress * xr1[1]);
          } else {
            viewBox[0] = 0;
            viewBox[2] = xlen;
          }
          if (editY) {
            var yr0 = Lib.simpleMap(edit.yr0, ya.r2l);
            var yr1 = Lib.simpleMap(edit.yr1, ya.r2l);
            var dy0 = yr0[1] - yr0[0];
            var dy1 = yr1[1] - yr1[0];
            viewBox[1] = (yr0[1] * (1 - progress) + progress * yr1[1] - yr0[1]) / (yr0[0] - yr0[1]) * ylen;
            viewBox[3] = ylen * (1 - progress + progress * dy1 / dy0);
            ya.range[0] = xa.l2r(yr0[0] * (1 - progress) + progress * yr1[0]);
            ya.range[1] = ya.l2r(yr0[1] * (1 - progress) + progress * yr1[1]);
          } else {
            viewBox[1] = 0;
            viewBox[3] = ylen;
          }
          Axes.drawOne(gd, xa, { skipTitle: true });
          Axes.drawOne(gd, ya, { skipTitle: true });
          Axes.redrawComponents(gd, [xa._id, ya._id]);
          var xScaleFactor = editX ? xlen / viewBox[2] : 1;
          var yScaleFactor = editY ? ylen / viewBox[3] : 1;
          var clipDx = editX ? viewBox[0] : 0;
          var clipDy = editY ? viewBox[1] : 0;
          var fracDx = editX ? viewBox[0] / viewBox[2] * xlen : 0;
          var fracDy = editY ? viewBox[1] / viewBox[3] * ylen : 0;
          var plotDx = xa._offset - fracDx;
          var plotDy = ya._offset - fracDy;
          plotinfo.clipRect.call(Drawing.setTranslate, clipDx, clipDy).call(Drawing.setScale, 1 / xScaleFactor, 1 / yScaleFactor);
          plotinfo.plot.call(Drawing.setTranslate, plotDx, plotDy).call(Drawing.setScale, xScaleFactor, yScaleFactor);
          Drawing.setPointGroupScale(plotinfo.zoomScalePts, 1 / xScaleFactor, 1 / yScaleFactor);
          Drawing.setTextPointsScale(plotinfo.zoomScaleTxt, 1 / xScaleFactor, 1 / yScaleFactor);
        }
        var onComplete;
        if (makeOnCompleteCallback) {
          onComplete = makeOnCompleteCallback();
        }
        function transitionComplete() {
          var aobj = {};
          for (var i = 0; i < edits.length; i++) {
            var edit = edits[i];
            var xa = edit.plotinfo.xaxis;
            var ya = edit.plotinfo.yaxis;
            if (edit.xr1) aobj[xa._name + ".range"] = edit.xr1.slice();
            if (edit.yr1) aobj[ya._name + ".range"] = edit.yr1.slice();
          }
          onComplete && onComplete();
          return Registry.call("relayout", gd, aobj).then(function() {
            for (var i2 = 0; i2 < edits.length; i2++) {
              unsetSubplotTransform(edits[i2].plotinfo);
            }
          });
        }
        function transitionInterrupt() {
          var aobj = {};
          for (var i = 0; i < edits.length; i++) {
            var edit = edits[i];
            var xa = edit.plotinfo.xaxis;
            var ya = edit.plotinfo.yaxis;
            if (edit.xr0) aobj[xa._name + ".range"] = edit.xr0.slice();
            if (edit.yr0) aobj[ya._name + ".range"] = edit.yr0.slice();
          }
          return Registry.call("relayout", gd, aobj).then(function() {
            for (var i2 = 0; i2 < edits.length; i2++) {
              unsetSubplotTransform(edits[i2].plotinfo);
            }
          });
        }
        var t1, t2, raf;
        var easeFn = d3.ease(transitionOpts.easing);
        gd._transitionData._interruptCallbacks.push(function() {
          window.cancelAnimationFrame(raf);
          raf = null;
          return transitionInterrupt();
        });
        function doFrame() {
          t2 = Date.now();
          var tInterp = Math.min(1, (t2 - t1) / transitionOpts.duration);
          var progress = easeFn(tInterp);
          for (var i = 0; i < edits.length; i++) {
            updateSubplot(edits[i], progress);
          }
          if (t2 - t1 > transitionOpts.duration) {
            transitionComplete();
            raf = window.cancelAnimationFrame(doFrame);
          } else {
            raf = window.requestAnimationFrame(doFrame);
          }
        }
        t1 = Date.now();
        raf = window.requestAnimationFrame(doFrame);
        return Promise.resolve();
      };
    }
  });

  // src/plots/cartesian/index.js
  var require_cartesian = __commonJS({
    "src/plots/cartesian/index.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Lib = require_lib();
      var Plots = require_plots();
      var Drawing = require_drawing();
      var getModuleCalcData = require_get_data().getModuleCalcData;
      var axisIds = require_axis_ids();
      var constants = require_constants2();
      var xmlnsNamespaces = require_xmlns_namespaces();
      var ensureSingle = Lib.ensureSingle;
      function ensureSingleAndAddDatum(parent, nodeType, className) {
        return Lib.ensureSingle(parent, nodeType, className, function(s) {
          s.datum(className);
        });
      }
      var zindexSeparator = constants.zindexSeparator;
      exports.name = "cartesian";
      exports.attr = ["xaxis", "yaxis"];
      exports.idRoot = ["x", "y"];
      exports.idRegex = constants.idRegex;
      exports.attrRegex = constants.attrRegex;
      exports.attributes = require_attributes14();
      exports.layoutAttributes = require_layout_attributes4();
      exports.supplyLayoutDefaults = require_layout_defaults4();
      exports.transitionAxes = require_transition_axes();
      exports.finalizeSubplots = function(layoutIn, layoutOut) {
        var subplots = layoutOut._subplots;
        var xList = subplots.xaxis;
        var yList = subplots.yaxis;
        var spSVG = subplots.cartesian;
        var spAll = spSVG;
        var allX = {};
        var allY = {};
        var i, xi, yi;
        for (i = 0; i < spAll.length; i++) {
          var parts = spAll[i].split("y");
          allX[parts[0]] = 1;
          allY["y" + parts[1]] = 1;
        }
        for (i = 0; i < xList.length; i++) {
          xi = xList[i];
          if (!allX[xi]) {
            yi = (layoutIn[axisIds.id2name(xi)] || {}).anchor;
            if (!constants.idRegex.y.test(yi)) yi = "y";
            spSVG.push(xi + yi);
            spAll.push(xi + yi);
            if (!allY[yi]) {
              allY[yi] = 1;
              Lib.pushUnique(yList, yi);
            }
          }
        }
        for (i = 0; i < yList.length; i++) {
          yi = yList[i];
          if (!allY[yi]) {
            xi = (layoutIn[axisIds.id2name(yi)] || {}).anchor;
            if (!constants.idRegex.x.test(xi)) xi = "x";
            spSVG.push(xi + yi);
            spAll.push(xi + yi);
            if (!allX[xi]) {
              allX[xi] = 1;
              Lib.pushUnique(xList, xi);
            }
          }
        }
        if (!spAll.length) {
          xi = "";
          yi = "";
          for (var ki in layoutIn) {
            if (constants.attrRegex.test(ki)) {
              var axLetter = ki.charAt(0);
              if (axLetter === "x") {
                if (!xi || +ki.substr(5) < +xi.substr(5)) {
                  xi = ki;
                }
              } else if (!yi || +ki.substr(5) < +yi.substr(5)) {
                yi = ki;
              }
            }
          }
          xi = xi ? axisIds.name2id(xi) : "x";
          yi = yi ? axisIds.name2id(yi) : "y";
          xList.push(xi);
          yList.push(yi);
          spSVG.push(xi + yi);
        }
      };
      exports.plot = function(gd, traces, transitionOpts, makeOnCompleteCallback) {
        var fullLayout = gd._fullLayout;
        var subplots = fullLayout._subplots.cartesian;
        var calcdata = gd.calcdata;
        var i;
        if (!Array.isArray(traces)) {
          traces = [];
          for (i = 0; i < calcdata.length; i++) traces.push(i);
        }
        var zindices = fullLayout._zindices;
        for (var z = 0; z < zindices.length; z++) {
          var zorder = zindices[z];
          for (i = 0; i < subplots.length; i++) {
            var subplot = subplots[i];
            var subplotInfo = fullLayout._plots[subplot];
            if (z > 0) {
              var idWithZ = subplotInfo.id;
              if (idWithZ.indexOf(zindexSeparator) !== -1) continue;
              idWithZ += zindexSeparator + (z + 1);
              subplotInfo = Lib.extendFlat({}, subplotInfo, {
                id: idWithZ,
                plot: fullLayout._cartesianlayer.selectAll(".subplot").select("." + idWithZ)
              });
            }
            var cdSubplot = [];
            var pcd;
            for (var j = 0; j < calcdata.length; j++) {
              var cd = calcdata[j];
              var trace = cd[0].trace;
              if (zorder !== (trace.zorder || 0)) continue;
              if (trace.xaxis + trace.yaxis === subplot) {
                if (traces.indexOf(trace.index) !== -1 || trace.carpet) {
                  if (pcd && pcd[0].trace.xaxis + pcd[0].trace.yaxis === subplot && ["tonextx", "tonexty", "tonext"].indexOf(trace.fill) !== -1 && cdSubplot.indexOf(pcd) === -1) {
                    cdSubplot.push(pcd);
                  }
                  cdSubplot.push(cd);
                }
                pcd = cd;
              }
            }
            plotOne(gd, subplotInfo, cdSubplot, transitionOpts, makeOnCompleteCallback);
          }
        }
      };
      function plotOne(gd, plotinfo, cdSubplot, transitionOpts, makeOnCompleteCallback) {
        var traceLayerClasses = constants.traceLayerClasses;
        var fullLayout = gd._fullLayout;
        var zindices = fullLayout._zindices;
        var modules = fullLayout._modules;
        var _module, cdModuleAndOthers, cdModule;
        var layerData = [];
        var zoomScaleQueryParts = [];
        for (var z = 0; z < zindices.length; z++) {
          var zorder = zindices[z];
          for (var i = 0; i < modules.length; i++) {
            _module = modules[i];
            var name = _module.name;
            var categories = Registry.modules[name].categories;
            if (categories.svg) {
              var classBaseName = _module.layerName || name + "layer";
              var className = classBaseName + (z ? Number(z) + 1 : "");
              var plotMethod = _module.plot;
              cdModuleAndOthers = getModuleCalcData(cdSubplot, plotMethod, zorder);
              cdModule = cdModuleAndOthers[0];
              cdSubplot = cdModuleAndOthers[1];
              if (cdModule.length) {
                layerData.push({
                  i: traceLayerClasses.indexOf(classBaseName),
                  zindex: z,
                  className,
                  plotMethod,
                  cdModule
                });
              }
              if (categories.zoomScale) {
                zoomScaleQueryParts.push("." + className);
              }
            }
          }
        }
        layerData.sort(function(a, b) {
          return (a.zindex || 0) - (b.zindex || 0) || a.i - b.i;
        });
        var layers = plotinfo.plot.selectAll("g.mlayer").data(layerData, function(d) {
          return d.className;
        });
        layers.enter().append("g").attr("class", function(d) {
          return d.className;
        }).classed("mlayer", true).classed("rangeplot", plotinfo.isRangePlot);
        layers.exit().remove();
        layers.order();
        layers.each(function(d) {
          var sel = d3.select(this);
          var className2 = d.className;
          d.plotMethod(
            gd,
            plotinfo,
            d.cdModule,
            sel,
            transitionOpts,
            makeOnCompleteCallback
          );
          if (constants.clipOnAxisFalseQuery.indexOf("." + className2) === -1) {
            Drawing.setClipUrl(sel, plotinfo.layerClipId, gd);
          }
        });
        if (fullLayout._has("scattergl")) {
          _module = Registry.getModule("scattergl");
          cdModule = getModuleCalcData(cdSubplot, _module)[0];
          _module.plot(gd, plotinfo, cdModule);
        }
        if (!gd._context.staticPlot) {
          if (plotinfo._hasClipOnAxisFalse) {
            plotinfo.clipOnAxisFalseTraces = plotinfo.plot.selectAll(constants.clipOnAxisFalseQuery.join(",")).selectAll(".trace");
          }
          if (zoomScaleQueryParts.length) {
            var traces = plotinfo.plot.selectAll(zoomScaleQueryParts.join(",")).selectAll(".trace");
            plotinfo.zoomScalePts = traces.selectAll("path.point");
            plotinfo.zoomScaleTxt = traces.selectAll(".textpoint");
          }
        }
      }
      exports.clean = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {
        var oldPlots = oldFullLayout._plots || {};
        var newPlots = newFullLayout._plots || {};
        var oldSubplotList = oldFullLayout._subplots || {};
        var plotinfo;
        var i, k;
        if (oldFullLayout._hasOnlyLargeSploms && !newFullLayout._hasOnlyLargeSploms) {
          for (k in oldPlots) {
            plotinfo = oldPlots[k];
            if (plotinfo.plotgroup) plotinfo.plotgroup.remove();
          }
        }
        var hadGl = oldFullLayout._has && oldFullLayout._has("gl");
        var hasGl = newFullLayout._has && newFullLayout._has("gl");
        if (hadGl && !hasGl) {
          for (k in oldPlots) {
            plotinfo = oldPlots[k];
            if (plotinfo._scene) plotinfo._scene.destroy();
          }
        }
        if (oldSubplotList.xaxis && oldSubplotList.yaxis) {
          var oldAxIDs = axisIds.listIds({ _fullLayout: oldFullLayout });
          for (i = 0; i < oldAxIDs.length; i++) {
            var oldAxId = oldAxIDs[i];
            if (!newFullLayout[axisIds.id2name(oldAxId)]) {
              oldFullLayout._infolayer.selectAll(".g-" + oldAxId + "title").remove();
            }
          }
        }
        var hadCartesian = oldFullLayout._has && oldFullLayout._has("cartesian");
        var hasCartesian = newFullLayout._has && newFullLayout._has("cartesian");
        if (hadCartesian && !hasCartesian) {
          purgeSubplotLayers(oldFullLayout._cartesianlayer.selectAll(".subplot"), oldFullLayout);
          oldFullLayout._defs.selectAll(".axesclip").remove();
          delete oldFullLayout._axisConstraintGroups;
          delete oldFullLayout._axisMatchGroups;
        } else if (oldSubplotList.cartesian) {
          for (i = 0; i < oldSubplotList.cartesian.length; i++) {
            var oldSubplotId = oldSubplotList.cartesian[i];
            if (oldSubplotId.indexOf(zindexSeparator) !== -1) continue;
            if (!newPlots[oldSubplotId]) {
              var selector = "." + oldSubplotId + ",." + oldSubplotId + "-x,." + oldSubplotId + "-y";
              oldFullLayout._cartesianlayer.selectAll(selector).remove();
              removeSubplotExtras(oldSubplotId, oldFullLayout);
            }
          }
        }
      };
      exports.drawFramework = function(gd) {
        var fullLayout = gd._fullLayout;
        var calcdata = gd.calcdata;
        var i;
        var traceZorderGroups = {};
        for (i = 0; i < calcdata.length; i++) {
          var cdi = calcdata[i][0];
          var trace = cdi.trace;
          var zi = trace.zorder || 0;
          if (!traceZorderGroups[zi]) traceZorderGroups[zi] = [];
          traceZorderGroups[zi].push(cdi);
        }
        var zindices = Object.keys(traceZorderGroups).map(Number).sort(Lib.sorterAsc);
        if (!zindices.length) zindices = [0];
        fullLayout._zindices = zindices;
        var initialSubplotData = makeSubplotData(gd);
        var len = initialSubplotData.length;
        var subplotData = [];
        for (i = 0; i < len; i++) {
          subplotData[i] = initialSubplotData[i].slice();
        }
        for (var z = 1; z < zindices.length; z++) {
          var newSubplotData = [];
          for (i = 0; i < len; i++) {
            newSubplotData[i] = initialSubplotData[i].slice();
            newSubplotData[i][0] += zindexSeparator + (z + 1);
          }
          subplotData = subplotData.concat(newSubplotData);
        }
        var subplotLayers = fullLayout._cartesianlayer.selectAll(".subplot").data(subplotData, String);
        subplotLayers.enter().append("g").attr("class", function(d) {
          return "subplot " + d[0];
        });
        subplotLayers.order();
        subplotLayers.exit().call(purgeSubplotLayers, fullLayout);
        subplotLayers.each(function(d) {
          var id = d[0];
          var posZ = id.indexOf(zindexSeparator);
          var hasZ = posZ !== -1;
          var idWithoutZ = hasZ ? id.slice(0, posZ) : id;
          var plotinfo = fullLayout._plots[id];
          if (!plotinfo) {
            plotinfo = Lib.extendFlat({}, fullLayout._plots[idWithoutZ]);
            if (plotinfo) {
              plotinfo.id = id;
              fullLayout._plots[id] = plotinfo;
              fullLayout._subplots.cartesian.push(id);
            }
          }
          if (plotinfo) {
            plotinfo.plotgroup = d3.select(this);
            makeSubplotLayer(gd, plotinfo);
            if (!hasZ) {
              plotinfo.draglayer = ensureSingle(fullLayout._draggers, "g", id);
            }
          }
        });
      };
      exports.rangePlot = function(gd, plotinfo, cdSubplot) {
        makeSubplotLayer(gd, plotinfo);
        plotOne(gd, plotinfo, cdSubplot);
        Plots.style(gd);
      };
      function makeSubplotData(gd) {
        var fullLayout = gd._fullLayout;
        var numZ = fullLayout._zindices.length;
        var ids = fullLayout._subplots.cartesian;
        var len = ids.length;
        var i, j, id, plotinfo, xa, ya;
        var regulars = [];
        var overlays = [];
        for (i = 0; i < len; i++) {
          id = ids[i];
          plotinfo = fullLayout._plots[id];
          xa = plotinfo.xaxis;
          ya = plotinfo.yaxis;
          var xa2 = xa._mainAxis;
          var ya2 = ya._mainAxis;
          var mainplot = xa2._id + ya2._id;
          var mainplotinfo = fullLayout._plots[mainplot];
          plotinfo.overlays = [];
          if (mainplot !== id && mainplotinfo) {
            plotinfo.mainplot = mainplot;
            plotinfo.mainplotinfo = mainplotinfo;
            overlays.push(id);
          } else {
            plotinfo.mainplot = void 0;
            plotinfo.mainplotinfo = void 0;
            regulars.push(id);
          }
        }
        for (i = 0; i < overlays.length; i++) {
          id = overlays[i];
          plotinfo = fullLayout._plots[id];
          plotinfo.mainplotinfo.overlays.push(plotinfo);
        }
        var subplotIds = regulars.concat(overlays);
        var subplotData = [];
        for (i = 0; i < len; i++) {
          id = subplotIds[i];
          plotinfo = fullLayout._plots[id];
          xa = plotinfo.xaxis;
          ya = plotinfo.yaxis;
          var d = [];
          for (var z = 1; z <= numZ; z++) {
            var zStr = "";
            if (z > 1) zStr += zindexSeparator + z;
            d.push(id + zStr);
            for (j = 0; j < plotinfo.overlays.length; j++) {
              d.push(plotinfo.overlays[j].id + zStr);
            }
          }
          d = d.concat([
            xa.layer,
            ya.layer,
            xa.overlaying || "",
            ya.overlaying || ""
          ]);
          subplotData.push(d);
        }
        return subplotData;
      }
      function makeSubplotLayer(gd, plotinfo) {
        var fullLayout = gd._fullLayout;
        var plotgroup = plotinfo.plotgroup;
        var id = plotinfo.id;
        var posZ = id.indexOf(zindexSeparator);
        var hasZ = posZ !== -1;
        var xLayer = constants.layerValue2layerClass[plotinfo.xaxis.layer];
        var yLayer = constants.layerValue2layerClass[plotinfo.yaxis.layer];
        var hasOnlyLargeSploms = fullLayout._hasOnlyLargeSploms;
        var hasMultipleZ = fullLayout._zindices.length > 1;
        var mainplotinfo = plotinfo.mainplotinfo;
        if (!plotinfo.mainplot || hasMultipleZ) {
          if (hasOnlyLargeSploms) {
            plotinfo.xlines = ensureSingle(plotgroup, "path", "xlines-above");
            plotinfo.ylines = ensureSingle(plotgroup, "path", "ylines-above");
            plotinfo.xaxislayer = ensureSingle(plotgroup, "g", "xaxislayer-above");
            plotinfo.yaxislayer = ensureSingle(plotgroup, "g", "yaxislayer-above");
          } else {
            if (!hasZ) {
              var backLayer = ensureSingle(plotgroup, "g", "layer-subplot");
              plotinfo.shapelayer = ensureSingle(backLayer, "g", "shapelayer");
              plotinfo.imagelayer = ensureSingle(backLayer, "g", "imagelayer");
              if (mainplotinfo && hasMultipleZ) {
                plotinfo.minorGridlayer = mainplotinfo.minorGridlayer;
                plotinfo.gridlayer = mainplotinfo.gridlayer;
                plotinfo.zerolinelayer = mainplotinfo.zerolinelayer;
              } else {
                plotinfo.minorGridlayer = ensureSingle(plotgroup, "g", "minor-gridlayer");
                plotinfo.gridlayer = ensureSingle(plotgroup, "g", "gridlayer");
                plotinfo.zerolinelayer = ensureSingle(plotgroup, "g", "zerolinelayer");
              }
              var betweenLayer = ensureSingle(plotgroup, "g", "layer-between");
              plotinfo.shapelayerBetween = ensureSingle(betweenLayer, "g", "shapelayer");
              plotinfo.imagelayerBetween = ensureSingle(betweenLayer, "g", "imagelayer");
              ensureSingle(plotgroup, "path", "xlines-below");
              ensureSingle(plotgroup, "path", "ylines-below");
              plotinfo.overlinesBelow = ensureSingle(plotgroup, "g", "overlines-below");
              ensureSingle(plotgroup, "g", "xaxislayer-below");
              ensureSingle(plotgroup, "g", "yaxislayer-below");
              plotinfo.overaxesBelow = ensureSingle(plotgroup, "g", "overaxes-below");
            }
            plotinfo.overplot = ensureSingle(plotgroup, "g", "overplot");
            plotinfo.plot = ensureSingle(plotinfo.overplot, "g", id);
            if (!hasZ) {
              plotinfo.xlines = ensureSingle(plotgroup, "path", "xlines-above");
              plotinfo.ylines = ensureSingle(plotgroup, "path", "ylines-above");
              plotinfo.overlinesAbove = ensureSingle(plotgroup, "g", "overlines-above");
              ensureSingle(plotgroup, "g", "xaxislayer-above");
              ensureSingle(plotgroup, "g", "yaxislayer-above");
              plotinfo.overaxesAbove = ensureSingle(plotgroup, "g", "overaxes-above");
              plotinfo.xlines = plotgroup.select(".xlines-" + xLayer);
              plotinfo.ylines = plotgroup.select(".ylines-" + yLayer);
              plotinfo.xaxislayer = plotgroup.select(".xaxislayer-" + xLayer);
              plotinfo.yaxislayer = plotgroup.select(".yaxislayer-" + yLayer);
            }
          }
        } else {
          var mainplotgroup = mainplotinfo.plotgroup;
          var xId = id + "-x";
          var yId = id + "-y";
          plotinfo.minorGridlayer = mainplotinfo.minorGridlayer;
          plotinfo.gridlayer = mainplotinfo.gridlayer;
          plotinfo.zerolinelayer = mainplotinfo.zerolinelayer;
          ensureSingle(mainplotinfo.overlinesBelow, "path", xId);
          ensureSingle(mainplotinfo.overlinesBelow, "path", yId);
          ensureSingle(mainplotinfo.overaxesBelow, "g", xId);
          ensureSingle(mainplotinfo.overaxesBelow, "g", yId);
          plotinfo.plot = ensureSingle(mainplotinfo.overplot, "g", id);
          ensureSingle(mainplotinfo.overlinesAbove, "path", xId);
          ensureSingle(mainplotinfo.overlinesAbove, "path", yId);
          ensureSingle(mainplotinfo.overaxesAbove, "g", xId);
          ensureSingle(mainplotinfo.overaxesAbove, "g", yId);
          plotinfo.xlines = mainplotgroup.select(".overlines-" + xLayer).select("." + xId);
          plotinfo.ylines = mainplotgroup.select(".overlines-" + yLayer).select("." + yId);
          plotinfo.xaxislayer = mainplotgroup.select(".overaxes-" + xLayer).select("." + xId);
          plotinfo.yaxislayer = mainplotgroup.select(".overaxes-" + yLayer).select("." + yId);
        }
        if (!hasZ) {
          if (!hasOnlyLargeSploms) {
            ensureSingleAndAddDatum(plotinfo.minorGridlayer, "g", plotinfo.xaxis._id);
            ensureSingleAndAddDatum(plotinfo.minorGridlayer, "g", plotinfo.yaxis._id);
            plotinfo.minorGridlayer.selectAll("g").map(function(d) {
              return d[0];
            }).sort(axisIds.idSort);
            ensureSingleAndAddDatum(plotinfo.gridlayer, "g", plotinfo.xaxis._id);
            ensureSingleAndAddDatum(plotinfo.gridlayer, "g", plotinfo.yaxis._id);
            plotinfo.gridlayer.selectAll("g").map(function(d) {
              return d[0];
            }).sort(axisIds.idSort);
          }
          plotinfo.xlines.style("fill", "none").classed("crisp", true);
          plotinfo.ylines.style("fill", "none").classed("crisp", true);
        }
      }
      function purgeSubplotLayers(layers, fullLayout) {
        if (!layers) return;
        var overlayIdsToRemove = {};
        layers.each(function(d) {
          var id = d[0];
          var plotgroup = d3.select(this);
          plotgroup.remove();
          removeSubplotExtras(id, fullLayout);
          overlayIdsToRemove[id] = true;
        });
        for (var k in fullLayout._plots) {
          var subplotInfo = fullLayout._plots[k];
          var overlays = subplotInfo.overlays || [];
          for (var j = 0; j < overlays.length; j++) {
            var overlayInfo = overlays[j];
            if (overlayIdsToRemove[overlayInfo.id]) {
              overlayInfo.plot.selectAll(".trace").remove();
            }
          }
        }
      }
      function removeSubplotExtras(subplotId, fullLayout) {
        fullLayout._draggers.selectAll("g." + subplotId).remove();
        fullLayout._defs.select("#clip" + fullLayout._uid + subplotId + "plot").remove();
      }
      exports.toSVG = function(gd) {
        var imageRoot = gd._fullLayout._glimages;
        var root = d3.select(gd).selectAll(".svg-container");
        var canvases = root.filter(function(d, i) {
          return i === root.size() - 1;
        }).selectAll(".gl-canvas-context, .gl-canvas-focus");
        function canvasToImage() {
          var canvas = this;
          var imageData = canvas.toDataURL("image/png");
          var image = imageRoot.append("svg:image");
          image.attr({
            xmlns: xmlnsNamespaces.svg,
            "xlink:href": imageData,
            preserveAspectRatio: "none",
            x: 0,
            y: 0,
            width: canvas.style.width,
            height: canvas.style.height
          });
        }
        canvases.each(canvasToImage);
      };
      exports.updateFx = require_graph_interact().updateFx;
    }
  });

  // src/traces/scatter/index.js
  var require_scatter = __commonJS({
    "src/traces/scatter/index.js"(exports, module) {
      "use strict";
      var subtypes = require_subtypes();
      module.exports = {
        hasLines: subtypes.hasLines,
        hasMarkers: subtypes.hasMarkers,
        hasText: subtypes.hasText,
        isBubble: subtypes.isBubble,
        attributes: require_attributes12(),
        layoutAttributes: require_layout_attributes3(),
        supplyDefaults: require_defaults8(),
        crossTraceDefaults: require_cross_trace_defaults2(),
        supplyLayoutDefaults: require_layout_defaults3(),
        calc: require_calc3().calc,
        crossTraceCalc: require_cross_trace_calc2(),
        arraysToCalcdata: require_arrays_to_calcdata(),
        plot: require_plot(),
        colorbar: require_marker_colorbar(),
        formatLabels: require_format_labels(),
        style: require_style2().style,
        styleOnSelect: require_style2().styleOnSelect,
        hoverPoints: require_hover2(),
        selectPoints: require_select2(),
        animatable: true,
        moduleType: "trace",
        name: "scatter",
        basePlotModule: require_cartesian(),
        categories: [
          "cartesian",
          "svg",
          "symbols",
          "errorBarsOK",
          "showLegend",
          "scatter-like",
          "zoomScale"
        ],
        meta: {}
      };
    }
  });

  // src/components/annotations/draw_arrow_head.js
  var require_draw_arrow_head = __commonJS({
    "src/components/annotations/draw_arrow_head.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Color = require_color();
      var ARROWPATHS = require_arrow_paths();
      var Lib = require_lib();
      var strScale = Lib.strScale;
      var strRotate = Lib.strRotate;
      var strTranslate = Lib.strTranslate;
      module.exports = function drawArrowHead(el3, ends, options) {
        var el = el3.node();
        var headStyle = ARROWPATHS[options.arrowhead || 0];
        var startHeadStyle = ARROWPATHS[options.startarrowhead || 0];
        var scale = (options.arrowwidth || 1) * (options.arrowsize || 1);
        var startScale = (options.arrowwidth || 1) * (options.startarrowsize || 1);
        var doStart = ends.indexOf("start") >= 0;
        var doEnd = ends.indexOf("end") >= 0;
        var backOff = headStyle.backoff * scale + options.standoff;
        var startBackOff = startHeadStyle.backoff * startScale + options.startstandoff;
        var start, end, startRot, endRot;
        if (el.nodeName === "line") {
          start = { x: +el3.attr("x1"), y: +el3.attr("y1") };
          end = { x: +el3.attr("x2"), y: +el3.attr("y2") };
          var dx = start.x - end.x;
          var dy = start.y - end.y;
          startRot = Math.atan2(dy, dx);
          endRot = startRot + Math.PI;
          if (backOff && startBackOff) {
            if (backOff + startBackOff > Math.sqrt(dx * dx + dy * dy)) {
              hideLine();
              return;
            }
          }
          if (backOff) {
            if (backOff * backOff > dx * dx + dy * dy) {
              hideLine();
              return;
            }
            var backOffX = backOff * Math.cos(startRot);
            var backOffY = backOff * Math.sin(startRot);
            end.x += backOffX;
            end.y += backOffY;
            el3.attr({ x2: end.x, y2: end.y });
          }
          if (startBackOff) {
            if (startBackOff * startBackOff > dx * dx + dy * dy) {
              hideLine();
              return;
            }
            var startBackOffX = startBackOff * Math.cos(startRot);
            var startbackOffY = startBackOff * Math.sin(startRot);
            start.x -= startBackOffX;
            start.y -= startbackOffY;
            el3.attr({ x1: start.x, y1: start.y });
          }
        } else if (el.nodeName === "path") {
          var pathlen = el.getTotalLength();
          var dashArray = "";
          if (pathlen < backOff + startBackOff) {
            hideLine();
            return;
          }
          var start0 = el.getPointAtLength(0);
          var dstart = el.getPointAtLength(0.1);
          startRot = Math.atan2(start0.y - dstart.y, start0.x - dstart.x);
          start = el.getPointAtLength(Math.min(startBackOff, pathlen));
          dashArray = "0px," + startBackOff + "px,";
          var end0 = el.getPointAtLength(pathlen);
          var dend = el.getPointAtLength(pathlen - 0.1);
          endRot = Math.atan2(end0.y - dend.y, end0.x - dend.x);
          end = el.getPointAtLength(Math.max(0, pathlen - backOff));
          var shortening = dashArray ? startBackOff + backOff : backOff;
          dashArray += pathlen - shortening + "px," + pathlen + "px";
          el3.style("stroke-dasharray", dashArray);
        }
        function hideLine() {
          el3.style("stroke-dasharray", "0px,100px");
        }
        function drawhead(arrowHeadStyle, p, rot, arrowScale) {
          if (!arrowHeadStyle.path) return;
          if (arrowHeadStyle.noRotate) rot = 0;
          d3.select(el.parentNode).append("path").attr({
            class: el3.attr("class"),
            d: arrowHeadStyle.path,
            transform: strTranslate(p.x, p.y) + strRotate(rot * 180 / Math.PI) + strScale(arrowScale)
          }).style({
            fill: Color.rgb(options.arrowcolor),
            "stroke-width": 0
          });
        }
        if (doStart) drawhead(startHeadStyle, start, startRot, startScale);
        if (doEnd) drawhead(headStyle, end, endRot, scale);
      };
    }
  });

  // src/components/annotations/draw.js
  var require_draw4 = __commonJS({
    "src/components/annotations/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Plots = require_plots();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var Axes = require_axes();
      var Color = require_color();
      var Drawing = require_drawing();
      var Fx = require_fx();
      var svgTextUtils = require_svg_text_utils();
      var setCursor = require_setcursor();
      var dragElement = require_dragelement();
      var arrayEditor = require_plot_template().arrayEditor;
      var drawArrowHead = require_draw_arrow_head();
      module.exports = {
        draw,
        drawOne,
        drawRaw
      };
      function draw(gd) {
        var fullLayout = gd._fullLayout;
        fullLayout._infolayer.selectAll(".annotation").remove();
        for (var i = 0; i < fullLayout.annotations.length; i++) {
          if (fullLayout.annotations[i].visible) {
            drawOne(gd, i);
          }
        }
        return Plots.previousPromises(gd);
      }
      function drawOne(gd, index) {
        var fullLayout = gd._fullLayout;
        var options = fullLayout.annotations[index] || {};
        var xa = Axes.getFromId(gd, options.xref);
        var ya = Axes.getFromId(gd, options.yref);
        if (xa) xa.setScale();
        if (ya) ya.setScale();
        drawRaw(gd, options, index, false, xa, ya);
      }
      function shiftPosition(axa, dAx, axLetter, gs, options) {
        var optAx = options[axLetter];
        var axRef = options[axLetter + "ref"];
        var vertical = axLetter.indexOf("y") !== -1;
        var axDomainRef = Axes.getRefType(axRef) === "domain";
        var gsDim = vertical ? gs.h : gs.w;
        if (axa) {
          if (axDomainRef) {
            return optAx + (vertical ? -dAx : dAx) / axa._length;
          } else {
            return axa.p2r(axa.r2p(optAx) + dAx);
          }
        } else {
          return optAx + (vertical ? -dAx : dAx) / gsDim;
        }
      }
      function drawRaw(gd, options, index, subplotId, xa, ya) {
        var fullLayout = gd._fullLayout;
        var gs = gd._fullLayout._size;
        var edits = gd._context.edits;
        var className, containerStr;
        if (subplotId) {
          className = "annotation-" + subplotId;
          containerStr = subplotId + ".annotations";
        } else {
          className = "annotation";
          containerStr = "annotations";
        }
        var editHelpers = arrayEditor(gd.layout, containerStr, options);
        var modifyBase = editHelpers.modifyBase;
        var modifyItem = editHelpers.modifyItem;
        var getUpdateObj = editHelpers.getUpdateObj;
        fullLayout._infolayer.selectAll("." + className + '[data-index="' + index + '"]').remove();
        var annClipID = "clip" + fullLayout._uid + "_ann" + index;
        if (!options._input || options.visible === false) {
          d3.selectAll("#" + annClipID).remove();
          return;
        }
        var annPosPx = { x: {}, y: {} };
        var textangle = +options.textangle || 0;
        var annGroup = fullLayout._infolayer.append("g").classed(className, true).attr("data-index", String(index)).style("opacity", options.opacity);
        var annTextGroup = annGroup.append("g").classed("annotation-text-g", true);
        var editTextPosition = edits[options.showarrow ? "annotationTail" : "annotationPosition"];
        var textEvents = options.captureevents || edits.annotationText || editTextPosition;
        function makeEventData(initialEvent) {
          var eventData = {
            index,
            annotation: options._input,
            fullAnnotation: options,
            event: initialEvent
          };
          if (subplotId) {
            eventData.subplotId = subplotId;
          }
          return eventData;
        }
        var annTextGroupInner = annTextGroup.append("g").style("pointer-events", textEvents ? "all" : null).call(setCursor, "pointer").on("click", function() {
          gd._dragging = false;
          gd.emit("plotly_clickannotation", makeEventData(d3.event));
        });
        if (options.hovertext) {
          annTextGroupInner.on("mouseover", function() {
            var hoverOptions = options.hoverlabel;
            var hoverFont = hoverOptions.font;
            var bBox = this.getBoundingClientRect();
            var bBoxRef = gd.getBoundingClientRect();
            Fx.loneHover({
              x0: bBox.left - bBoxRef.left,
              x1: bBox.right - bBoxRef.left,
              y: (bBox.top + bBox.bottom) / 2 - bBoxRef.top,
              text: options.hovertext,
              color: hoverOptions.bgcolor,
              borderColor: hoverOptions.bordercolor,
              fontFamily: hoverFont.family,
              fontSize: hoverFont.size,
              fontColor: hoverFont.color,
              fontWeight: hoverFont.weight,
              fontStyle: hoverFont.style,
              fontVariant: hoverFont.variant,
              fontShadow: hoverFont.fontShadow,
              fontLineposition: hoverFont.fontLineposition,
              fontTextcase: hoverFont.fontTextcase
            }, {
              container: fullLayout._hoverlayer.node(),
              outerContainer: fullLayout._paper.node(),
              gd
            });
          }).on("mouseout", function() {
            Fx.loneUnhover(fullLayout._hoverlayer.node());
          });
        }
        var borderwidth = options.borderwidth;
        var borderpad = options.borderpad;
        var borderfull = borderwidth + borderpad;
        var annTextBG = annTextGroupInner.append("rect").attr("class", "bg").style("stroke-width", borderwidth + "px").call(Color.stroke, options.bordercolor).call(Color.fill, options.bgcolor);
        var isSizeConstrained = options.width || options.height;
        var annTextClip = fullLayout._topclips.selectAll("#" + annClipID).data(isSizeConstrained ? [0] : []);
        annTextClip.enter().append("clipPath").classed("annclip", true).attr("id", annClipID).append("rect");
        annTextClip.exit().remove();
        var font = options.font;
        var text = fullLayout._meta ? Lib.templateString(options.text, fullLayout._meta) : options.text;
        var annText = annTextGroupInner.append("text").classed("annotation-text", true).text(text);
        function textLayout(s) {
          s.call(Drawing.font, font).attr({
            "text-anchor": {
              left: "start",
              right: "end"
            }[options.align] || "middle"
          });
          svgTextUtils.convertToTspans(s, gd, drawGraphicalElements);
          return s;
        }
        function drawGraphicalElements() {
          var anchor3 = annText.selectAll("a");
          if (anchor3.size() === 1 && anchor3.text() === annText.text()) {
            var wholeLink = annTextGroupInner.insert("a", ":first-child").attr({
              "xlink:xlink:href": anchor3.attr("xlink:href"),
              "xlink:xlink:show": anchor3.attr("xlink:show")
            }).style({ cursor: "pointer" });
            wholeLink.node().appendChild(annTextBG.node());
          }
          var mathjaxGroup = annTextGroupInner.select(".annotation-text-math-group");
          var hasMathjax = !mathjaxGroup.empty();
          var anntextBB = Drawing.bBox(
            (hasMathjax ? mathjaxGroup : annText).node()
          );
          var textWidth = anntextBB.width;
          var textHeight = anntextBB.height;
          var annWidth = options.width || textWidth;
          var annHeight = options.height || textHeight;
          var outerWidth = Math.round(annWidth + 2 * borderfull);
          var outerHeight = Math.round(annHeight + 2 * borderfull);
          function shiftFraction(v, anchor2) {
            if (anchor2 === "auto") {
              if (v < 1 / 3) anchor2 = "left";
              else if (v > 2 / 3) anchor2 = "right";
              else anchor2 = "center";
            }
            return {
              center: 0,
              middle: 0,
              left: 0.5,
              bottom: -0.5,
              right: -0.5,
              top: 0.5
            }[anchor2];
          }
          var annotationIsOffscreen = false;
          var letters = ["x", "y"];
          for (var i = 0; i < letters.length; i++) {
            var axLetter = letters[i];
            var axRef = options[axLetter + "ref"] || axLetter;
            var tailRef = options["a" + axLetter + "ref"];
            var ax = { x: xa, y: ya }[axLetter];
            var dimAngle = (textangle + (axLetter === "x" ? 0 : -90)) * Math.PI / 180;
            var annSizeFromWidth = outerWidth * Math.cos(dimAngle);
            var annSizeFromHeight = outerHeight * Math.sin(dimAngle);
            var annSize = Math.abs(annSizeFromWidth) + Math.abs(annSizeFromHeight);
            var anchor = options[axLetter + "anchor"];
            var overallShift = options[axLetter + "shift"] * (axLetter === "x" ? 1 : -1);
            var posPx = annPosPx[axLetter];
            var basePx;
            var textPadShift;
            var alignPosition;
            var autoAlignFraction;
            var textShift;
            var axRefType = Axes.getRefType(axRef);
            if (ax && axRefType !== "domain") {
              var posFraction = ax.r2fraction(options[axLetter]);
              if (posFraction < 0 || posFraction > 1) {
                if (tailRef === axRef) {
                  posFraction = ax.r2fraction(options["a" + axLetter]);
                  if (posFraction < 0 || posFraction > 1) {
                    annotationIsOffscreen = true;
                  }
                } else {
                  annotationIsOffscreen = true;
                }
              }
              basePx = ax._offset + ax.r2p(options[axLetter]);
              autoAlignFraction = 0.5;
            } else {
              var axRefTypeEqDomain = axRefType === "domain";
              if (axLetter === "x") {
                alignPosition = options[axLetter];
                basePx = axRefTypeEqDomain ? ax._offset + ax._length * alignPosition : basePx = gs.l + gs.w * alignPosition;
              } else {
                alignPosition = 1 - options[axLetter];
                basePx = axRefTypeEqDomain ? ax._offset + ax._length * alignPosition : basePx = gs.t + gs.h * alignPosition;
              }
              autoAlignFraction = options.showarrow ? 0.5 : alignPosition;
            }
            if (options.showarrow) {
              posPx.head = basePx;
              var arrowLength = options["a" + axLetter];
              textShift = annSizeFromWidth * shiftFraction(0.5, options.xanchor) - annSizeFromHeight * shiftFraction(0.5, options.yanchor);
              if (tailRef === axRef) {
                var tailRefType = Axes.getRefType(tailRef);
                if (tailRefType === "domain") {
                  if (axLetter === "y") {
                    arrowLength = 1 - arrowLength;
                  }
                  posPx.tail = ax._offset + ax._length * arrowLength;
                } else if (tailRefType === "paper") {
                  if (axLetter === "y") {
                    arrowLength = 1 - arrowLength;
                    posPx.tail = gs.t + gs.h * arrowLength;
                  } else {
                    posPx.tail = gs.l + gs.w * arrowLength;
                  }
                } else {
                  posPx.tail = ax._offset + ax.r2p(arrowLength);
                }
                textPadShift = textShift;
              } else {
                posPx.tail = basePx + arrowLength;
                textPadShift = textShift + arrowLength;
              }
              posPx.text = posPx.tail + textShift;
              var maxPx = fullLayout[axLetter === "x" ? "width" : "height"];
              if (axRef === "paper") {
                posPx.head = Lib.constrain(posPx.head, 1, maxPx - 1);
              }
              if (tailRef === "pixel") {
                var shiftPlus = -Math.max(posPx.tail - 3, posPx.text);
                var shiftMinus = Math.min(posPx.tail + 3, posPx.text) - maxPx;
                if (shiftPlus > 0) {
                  posPx.tail += shiftPlus;
                  posPx.text += shiftPlus;
                } else if (shiftMinus > 0) {
                  posPx.tail -= shiftMinus;
                  posPx.text -= shiftMinus;
                }
              }
              posPx.tail += overallShift;
              posPx.head += overallShift;
            } else {
              textShift = annSize * shiftFraction(autoAlignFraction, anchor);
              textPadShift = textShift;
              posPx.text = basePx + textShift;
            }
            posPx.text += overallShift;
            textShift += overallShift;
            textPadShift += overallShift;
            options["_" + axLetter + "padplus"] = annSize / 2 + textPadShift;
            options["_" + axLetter + "padminus"] = annSize / 2 - textPadShift;
            options["_" + axLetter + "size"] = annSize;
            options["_" + axLetter + "shift"] = textShift;
          }
          if (annotationIsOffscreen) {
            annTextGroupInner.remove();
            return;
          }
          var xShift = 0;
          var yShift = 0;
          if (options.align !== "left") {
            xShift = (annWidth - textWidth) * (options.align === "center" ? 0.5 : 1);
          }
          if (options.valign !== "top") {
            yShift = (annHeight - textHeight) * (options.valign === "middle" ? 0.5 : 1);
          }
          if (hasMathjax) {
            mathjaxGroup.select("svg").attr({
              x: borderfull + xShift - 1,
              y: borderfull + yShift
            }).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);
          } else {
            var texty = borderfull + yShift - anntextBB.top;
            var textx = borderfull + xShift - anntextBB.left;
            annText.call(svgTextUtils.positionText, textx, texty).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);
          }
          annTextClip.select("rect").call(
            Drawing.setRect,
            borderfull,
            borderfull,
            annWidth,
            annHeight
          );
          annTextBG.call(
            Drawing.setRect,
            borderwidth / 2,
            borderwidth / 2,
            outerWidth - borderwidth,
            outerHeight - borderwidth
          );
          annTextGroupInner.call(
            Drawing.setTranslate,
            Math.round(annPosPx.x.text - outerWidth / 2),
            Math.round(annPosPx.y.text - outerHeight / 2)
          );
          annTextGroup.attr({ transform: "rotate(" + textangle + "," + annPosPx.x.text + "," + annPosPx.y.text + ")" });
          var drawArrow = function(dx, dy) {
            annGroup.selectAll(".annotation-arrow-g").remove();
            var headX = annPosPx.x.head;
            var headY = annPosPx.y.head;
            var tailX = annPosPx.x.tail + dx;
            var tailY = annPosPx.y.tail + dy;
            var textX = annPosPx.x.text + dx;
            var textY = annPosPx.y.text + dy;
            var transform = Lib.rotationXYMatrix(textangle, textX, textY);
            var applyTransform = Lib.apply2DTransform(transform);
            var applyTransform2 = Lib.apply2DTransform2(transform);
            var width = +annTextBG.attr("width");
            var height = +annTextBG.attr("height");
            var xLeft = textX - 0.5 * width;
            var xRight = xLeft + width;
            var yTop = textY - 0.5 * height;
            var yBottom = yTop + height;
            var edges = [
              [xLeft, yTop, xLeft, yBottom],
              [xLeft, yBottom, xRight, yBottom],
              [xRight, yBottom, xRight, yTop],
              [xRight, yTop, xLeft, yTop]
            ].map(applyTransform2);
            if (edges.reduce(function(a, x) {
              return a ^ !!Lib.segmentsIntersect(
                headX,
                headY,
                headX + 1e6,
                headY + 1e6,
                x[0],
                x[1],
                x[2],
                x[3]
              );
            }, false)) {
              return;
            }
            edges.forEach(function(x) {
              var p = Lib.segmentsIntersect(
                tailX,
                tailY,
                headX,
                headY,
                x[0],
                x[1],
                x[2],
                x[3]
              );
              if (p) {
                tailX = p.x;
                tailY = p.y;
              }
            });
            var strokewidth = options.arrowwidth;
            var arrowColor = options.arrowcolor;
            var arrowSide = options.arrowside;
            var arrowGroup = annGroup.append("g").style({ opacity: Color.opacity(arrowColor) }).classed("annotation-arrow-g", true);
            var arrow = arrowGroup.append("path").attr("d", "M" + tailX + "," + tailY + "L" + headX + "," + headY).style("stroke-width", strokewidth + "px").call(Color.stroke, Color.rgb(arrowColor));
            drawArrowHead(arrow, arrowSide, options);
            if (edits.annotationPosition && arrow.node().parentNode && !subplotId) {
              var arrowDragHeadX = headX;
              var arrowDragHeadY = headY;
              if (options.standoff) {
                var arrowLength2 = Math.sqrt(Math.pow(headX - tailX, 2) + Math.pow(headY - tailY, 2));
                arrowDragHeadX += options.standoff * (tailX - headX) / arrowLength2;
                arrowDragHeadY += options.standoff * (tailY - headY) / arrowLength2;
              }
              var arrowDrag = arrowGroup.append("path").classed("annotation-arrow", true).classed("anndrag", true).classed("cursor-move", true).attr({
                d: "M3,3H-3V-3H3ZM0,0L" + (tailX - arrowDragHeadX) + "," + (tailY - arrowDragHeadY),
                transform: strTranslate(arrowDragHeadX, arrowDragHeadY)
              }).style("stroke-width", strokewidth + 6 + "px").call(Color.stroke, "rgba(0,0,0,0)").call(Color.fill, "rgba(0,0,0,0)");
              var annx0, anny0;
              dragElement.init({
                element: arrowDrag.node(),
                gd,
                prepFn: function() {
                  var pos = Drawing.getTranslate(annTextGroupInner);
                  annx0 = pos.x;
                  anny0 = pos.y;
                  if (xa && xa.autorange) {
                    modifyBase(xa._name + ".autorange", true);
                  }
                  if (ya && ya.autorange) {
                    modifyBase(ya._name + ".autorange", true);
                  }
                },
                moveFn: function(dx2, dy2) {
                  var annxy0 = applyTransform(annx0, anny0);
                  var xcenter = annxy0[0] + dx2;
                  var ycenter = annxy0[1] + dy2;
                  annTextGroupInner.call(Drawing.setTranslate, xcenter, ycenter);
                  modifyItem(
                    "x",
                    shiftPosition(xa, dx2, "x", gs, options)
                  );
                  modifyItem(
                    "y",
                    shiftPosition(ya, dy2, "y", gs, options)
                  );
                  if (options.axref === options.xref) {
                    modifyItem("ax", shiftPosition(xa, dx2, "ax", gs, options));
                  }
                  if (options.ayref === options.yref) {
                    modifyItem("ay", shiftPosition(ya, dy2, "ay", gs, options));
                  }
                  arrowGroup.attr("transform", strTranslate(dx2, dy2));
                  annTextGroup.attr({
                    transform: "rotate(" + textangle + "," + xcenter + "," + ycenter + ")"
                  });
                },
                doneFn: function() {
                  Registry.call("_guiRelayout", gd, getUpdateObj());
                  var notesBox = document.querySelector(".js-notes-box-panel");
                  if (notesBox) notesBox.redraw(notesBox.selectedObj);
                }
              });
            }
          };
          if (options.showarrow) drawArrow(0, 0);
          if (editTextPosition) {
            var baseTextTransform;
            dragElement.init({
              element: annTextGroupInner.node(),
              gd,
              prepFn: function() {
                baseTextTransform = annTextGroup.attr("transform");
              },
              moveFn: function(dx, dy) {
                var csr = "pointer";
                if (options.showarrow) {
                  if (options.axref === options.xref) {
                    modifyItem("ax", shiftPosition(xa, dx, "ax", gs, options));
                  } else {
                    modifyItem("ax", options.ax + dx);
                  }
                  if (options.ayref === options.yref) {
                    modifyItem("ay", shiftPosition(ya, dy, "ay", gs.w, options));
                  } else {
                    modifyItem("ay", options.ay + dy);
                  }
                  drawArrow(dx, dy);
                } else if (!subplotId) {
                  var xUpdate, yUpdate;
                  if (xa) {
                    xUpdate = shiftPosition(xa, dx, "x", gs, options);
                  } else {
                    var widthFraction = options._xsize / gs.w;
                    var xLeft = options.x + (options._xshift - options.xshift) / gs.w - widthFraction / 2;
                    xUpdate = dragElement.align(
                      xLeft + dx / gs.w,
                      widthFraction,
                      0,
                      1,
                      options.xanchor
                    );
                  }
                  if (ya) {
                    yUpdate = shiftPosition(ya, dy, "y", gs, options);
                  } else {
                    var heightFraction = options._ysize / gs.h;
                    var yBottom = options.y - (options._yshift + options.yshift) / gs.h - heightFraction / 2;
                    yUpdate = dragElement.align(
                      yBottom - dy / gs.h,
                      heightFraction,
                      0,
                      1,
                      options.yanchor
                    );
                  }
                  modifyItem("x", xUpdate);
                  modifyItem("y", yUpdate);
                  if (!xa || !ya) {
                    csr = dragElement.getCursor(
                      xa ? 0.5 : xUpdate,
                      ya ? 0.5 : yUpdate,
                      options.xanchor,
                      options.yanchor
                    );
                  }
                } else return;
                annTextGroup.attr({
                  transform: strTranslate(dx, dy) + baseTextTransform
                });
                setCursor(annTextGroupInner, csr);
              },
              clickFn: function(_, initialEvent) {
                if (options.captureevents) {
                  gd.emit("plotly_clickannotation", makeEventData(initialEvent));
                }
              },
              doneFn: function() {
                setCursor(annTextGroupInner);
                Registry.call("_guiRelayout", gd, getUpdateObj());
                var notesBox = document.querySelector(".js-notes-box-panel");
                if (notesBox) notesBox.redraw(notesBox.selectedObj);
              }
            });
          }
        }
        if (edits.annotationText) {
          annText.call(svgTextUtils.makeEditable, { delegate: annTextGroupInner, gd }).call(textLayout).on("edit", function(_text) {
            options.text = _text;
            this.call(textLayout);
            modifyItem("text", _text);
            if (xa && xa.autorange) {
              modifyBase(xa._name + ".autorange", true);
            }
            if (ya && ya.autorange) {
              modifyBase(ya._name + ".autorange", true);
            }
            Registry.call("_guiRelayout", gd, getUpdateObj());
          });
        } else annText.call(textLayout);
      }
    }
  });

  // src/components/annotations/click.js
  var require_click2 = __commonJS({
    "src/components/annotations/click.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Registry = require_registry();
      var arrayEditor = require_plot_template().arrayEditor;
      module.exports = {
        hasClickToShow,
        onClick
      };
      function hasClickToShow(gd, hoverData) {
        var sets = getToggleSets(gd, hoverData);
        return sets.on.length > 0 || sets.explicitOff.length > 0;
      }
      function onClick(gd, hoverData) {
        var toggleSets = getToggleSets(gd, hoverData);
        var onSet = toggleSets.on;
        var offSet = toggleSets.off.concat(toggleSets.explicitOff);
        var update = {};
        var annotationsOut = gd._fullLayout.annotations;
        var i, editHelpers;
        if (!(onSet.length || offSet.length)) return;
        for (i = 0; i < onSet.length; i++) {
          editHelpers = arrayEditor(gd.layout, "annotations", annotationsOut[onSet[i]]);
          editHelpers.modifyItem("visible", true);
          Lib.extendFlat(update, editHelpers.getUpdateObj());
        }
        for (i = 0; i < offSet.length; i++) {
          editHelpers = arrayEditor(gd.layout, "annotations", annotationsOut[offSet[i]]);
          editHelpers.modifyItem("visible", false);
          Lib.extendFlat(update, editHelpers.getUpdateObj());
        }
        return Registry.call("update", gd, {}, update);
      }
      function getToggleSets(gd, hoverData) {
        var annotations = gd._fullLayout.annotations;
        var onSet = [];
        var offSet = [];
        var explicitOffSet = [];
        var hoverLen = (hoverData || []).length;
        var i, j, anni, showMode, pointj, xa, ya, toggleType;
        for (i = 0; i < annotations.length; i++) {
          anni = annotations[i];
          showMode = anni.clicktoshow;
          if (showMode) {
            for (j = 0; j < hoverLen; j++) {
              pointj = hoverData[j];
              xa = pointj.xaxis;
              ya = pointj.yaxis;
              if (xa._id === anni.xref && ya._id === anni.yref && xa.d2r(pointj.x) === clickData2r(anni._xclick, xa) && ya.d2r(pointj.y) === clickData2r(anni._yclick, ya)) {
                if (anni.visible) {
                  if (showMode === "onout") toggleType = offSet;
                  else toggleType = explicitOffSet;
                } else {
                  toggleType = onSet;
                }
                toggleType.push(i);
                break;
              }
            }
            if (j === hoverLen) {
              if (anni.visible && showMode === "onout") offSet.push(i);
            }
          }
        }
        return { on: onSet, off: offSet, explicitOff: explicitOffSet };
      }
      function clickData2r(d, ax) {
        return ax.type === "log" ? ax.l2r(d) : ax.d2r(d);
      }
    }
  });

  // src/components/annotations/common_defaults.js
  var require_common_defaults = __commonJS({
    "src/components/annotations/common_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Color = require_color();
      module.exports = function handleAnnotationCommonDefaults(annIn, annOut, fullLayout, coerce) {
        coerce("opacity");
        var bgColor = coerce("bgcolor");
        var borderColor = coerce("bordercolor");
        var borderOpacity = Color.opacity(borderColor);
        coerce("borderpad");
        var borderWidth = coerce("borderwidth");
        var showArrow = coerce("showarrow");
        coerce("text", showArrow ? " " : fullLayout._dfltTitle.annotation);
        coerce("textangle");
        Lib.coerceFont(coerce, "font", fullLayout.font);
        coerce("width");
        coerce("align");
        var h = coerce("height");
        if (h) coerce("valign");
        if (showArrow) {
          var arrowside = coerce("arrowside");
          var arrowhead;
          var arrowsize;
          if (arrowside.indexOf("end") !== -1) {
            arrowhead = coerce("arrowhead");
            arrowsize = coerce("arrowsize");
          }
          if (arrowside.indexOf("start") !== -1) {
            coerce("startarrowhead", arrowhead);
            coerce("startarrowsize", arrowsize);
          }
          coerce("arrowcolor", borderOpacity ? annOut.bordercolor : Color.defaultLine);
          coerce("arrowwidth", (borderOpacity && borderWidth || 1) * 2);
          coerce("standoff");
          coerce("startstandoff");
        }
        var hoverText = coerce("hovertext");
        var globalHoverLabel = fullLayout.hoverlabel || {};
        if (hoverText) {
          var hoverBG = coerce(
            "hoverlabel.bgcolor",
            globalHoverLabel.bgcolor || (Color.opacity(bgColor) ? Color.rgb(bgColor) : Color.defaultLine)
          );
          var hoverBorder = coerce(
            "hoverlabel.bordercolor",
            globalHoverLabel.bordercolor || Color.contrast(hoverBG)
          );
          var fontDflt = Lib.extendFlat({}, globalHoverLabel.font);
          if (!fontDflt.color) {
            fontDflt.color = hoverBorder;
          }
          Lib.coerceFont(coerce, "hoverlabel.font", fontDflt);
        }
        coerce("captureevents", !!hoverText);
      };
    }
  });

  // src/components/annotations/defaults.js
  var require_defaults9 = __commonJS({
    "src/components/annotations/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var handleAnnotationCommonDefaults = require_common_defaults();
      var attributes = require_attributes11();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        handleArrayContainerDefaults(layoutIn, layoutOut, {
          name: "annotations",
          handleItemDefaults: handleAnnotationDefaults
        });
      };
      function handleAnnotationDefaults(annIn, annOut, fullLayout) {
        function coerce(attr, dflt) {
          return Lib.coerce(annIn, annOut, attributes, attr, dflt);
        }
        var visible = coerce("visible");
        var clickToShow = coerce("clicktoshow");
        if (!(visible || clickToShow)) return;
        handleAnnotationCommonDefaults(annIn, annOut, fullLayout, coerce);
        var showArrow = annOut.showarrow;
        var axLetters = ["x", "y"];
        var arrowPosDflt = [-10, -30];
        var gdMock = { _fullLayout: fullLayout };
        for (var i = 0; i < 2; i++) {
          var axLetter = axLetters[i];
          var axRef = Axes.coerceRef(annIn, annOut, gdMock, axLetter, "", "paper");
          if (axRef !== "paper") {
            var ax = Axes.getFromId(gdMock, axRef);
            ax._annIndices.push(annOut._index);
          }
          Axes.coercePosition(annOut, gdMock, coerce, axRef, axLetter, 0.5);
          if (showArrow) {
            var arrowPosAttr = "a" + axLetter;
            var aaxRef = Axes.coerceRef(
              annIn,
              annOut,
              gdMock,
              arrowPosAttr,
              "pixel",
              ["pixel", "paper"]
            );
            if (aaxRef !== "pixel" && aaxRef !== axRef) {
              aaxRef = annOut[arrowPosAttr] = "pixel";
            }
            var aDflt = aaxRef === "pixel" ? arrowPosDflt[i] : 0.4;
            Axes.coercePosition(annOut, gdMock, coerce, aaxRef, arrowPosAttr, aDflt);
          }
          coerce(axLetter + "anchor");
          coerce(axLetter + "shift");
        }
        Lib.noneOrAll(annIn, annOut, ["x", "y"]);
        if (showArrow) {
          Lib.noneOrAll(annIn, annOut, ["ax", "ay"]);
        }
        if (clickToShow) {
          var xClick = coerce("xclick");
          var yClick = coerce("yclick");
          annOut._xclick = xClick === void 0 ? annOut.x : Axes.cleanPosition(xClick, gdMock, annOut.xref);
          annOut._yclick = yClick === void 0 ? annOut.y : Axes.cleanPosition(yClick, gdMock, annOut.yref);
        }
      }
    }
  });

  // src/components/annotations/calc_autorange.js
  var require_calc_autorange = __commonJS({
    "src/components/annotations/calc_autorange.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var draw = require_draw4().draw;
      module.exports = function calcAutorange(gd) {
        var fullLayout = gd._fullLayout;
        var annotationList = Lib.filterVisible(fullLayout.annotations);
        if (annotationList.length && gd._fullData.length) {
          return Lib.syncOrAsync([draw, annAutorange], gd);
        }
      };
      function annAutorange(gd) {
        var fullLayout = gd._fullLayout;
        Lib.filterVisible(fullLayout.annotations).forEach(function(ann) {
          var xa = Axes.getFromId(gd, ann.xref);
          var ya = Axes.getFromId(gd, ann.yref);
          var xRefType = Axes.getRefType(ann.xref);
          var yRefType = Axes.getRefType(ann.yref);
          ann._extremes = {};
          if (xRefType === "range") calcAxisExpansion(ann, xa);
          if (yRefType === "range") calcAxisExpansion(ann, ya);
        });
      }
      function calcAxisExpansion(ann, ax) {
        var axId = ax._id;
        var letter = axId.charAt(0);
        var pos = ann[letter];
        var apos = ann["a" + letter];
        var ref = ann[letter + "ref"];
        var aref = ann["a" + letter + "ref"];
        var padplus = ann["_" + letter + "padplus"];
        var padminus = ann["_" + letter + "padminus"];
        var shift = { x: 1, y: -1 }[letter] * ann[letter + "shift"];
        var headSize = 3 * ann.arrowsize * ann.arrowwidth || 0;
        var headPlus = headSize + shift;
        var headMinus = headSize - shift;
        var startHeadSize = 3 * ann.startarrowsize * ann.arrowwidth || 0;
        var startHeadPlus = startHeadSize + shift;
        var startHeadMinus = startHeadSize - shift;
        var extremes;
        if (aref === ref) {
          var extremeArrowHead = Axes.findExtremes(ax, [ax.r2c(pos)], {
            ppadplus: headPlus,
            ppadminus: headMinus
          });
          var extremeText = Axes.findExtremes(ax, [ax.r2c(apos)], {
            ppadplus: Math.max(padplus, startHeadPlus),
            ppadminus: Math.max(padminus, startHeadMinus)
          });
          extremes = {
            min: [extremeArrowHead.min[0], extremeText.min[0]],
            max: [extremeArrowHead.max[0], extremeText.max[0]]
          };
        } else {
          startHeadPlus = apos ? startHeadPlus + apos : startHeadPlus;
          startHeadMinus = apos ? startHeadMinus - apos : startHeadMinus;
          extremes = Axes.findExtremes(ax, [ax.r2c(pos)], {
            ppadplus: Math.max(padplus, headPlus, startHeadPlus),
            ppadminus: Math.max(padminus, headMinus, startHeadMinus)
          });
        }
        ann._extremes[axId] = extremes;
      }
    }
  });

  // src/components/annotations/convert_coords.js
  var require_convert_coords = __commonJS({
    "src/components/annotations/convert_coords.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var toLogRange = require_to_log_range();
      module.exports = function convertCoords(gd, ax, newType, doExtra) {
        ax = ax || {};
        var toLog = newType === "log" && ax.type === "linear";
        var fromLog = newType === "linear" && ax.type === "log";
        if (!(toLog || fromLog)) return;
        var annotations = gd._fullLayout.annotations;
        var axLetter = ax._id.charAt(0);
        var ann;
        var attrPrefix;
        function convert(attr) {
          var currentVal = ann[attr];
          var newVal = null;
          if (toLog) newVal = toLogRange(currentVal, ax.range);
          else newVal = Math.pow(10, currentVal);
          if (!isNumeric(newVal)) newVal = null;
          doExtra(attrPrefix + attr, newVal);
        }
        for (var i = 0; i < annotations.length; i++) {
          ann = annotations[i];
          attrPrefix = "annotations[" + i + "].";
          if (ann[axLetter + "ref"] === ax._id) convert(axLetter);
          if (ann["a" + axLetter + "ref"] === ax._id) convert("a" + axLetter);
        }
      };
    }
  });

  // src/components/annotations/index.js
  var require_annotations = __commonJS({
    "src/components/annotations/index.js"(exports, module) {
      "use strict";
      var drawModule = require_draw4();
      var clickModule = require_click2();
      module.exports = {
        moduleType: "component",
        name: "annotations",
        layoutAttributes: require_attributes11(),
        supplyLayoutDefaults: require_defaults9(),
        includeBasePlot: require_include_components()("annotations"),
        calcAutorange: require_calc_autorange(),
        draw: drawModule.draw,
        drawOne: drawModule.drawOne,
        drawRaw: drawModule.drawRaw,
        hasClickToShow: clickModule.hasClickToShow,
        onClick: clickModule.onClick,
        convertCoords: require_convert_coords()
      };
    }
  });

  // src/components/annotations3d/attributes.js
  var require_attributes15 = __commonJS({
    "src/components/annotations3d/attributes.js"(exports, module) {
      "use strict";
      var annAttrs = require_attributes11();
      var overrideAll = require_edit_types().overrideAll;
      var templatedArray = require_plot_template().templatedArray;
      module.exports = overrideAll(templatedArray("annotation", {
        visible: annAttrs.visible,
        x: {
          valType: "any"
        },
        y: {
          valType: "any"
        },
        z: {
          valType: "any"
        },
        ax: {
          valType: "number"
        },
        ay: {
          valType: "number"
        },
        xanchor: annAttrs.xanchor,
        xshift: annAttrs.xshift,
        yanchor: annAttrs.yanchor,
        yshift: annAttrs.yshift,
        text: annAttrs.text,
        textangle: annAttrs.textangle,
        font: annAttrs.font,
        width: annAttrs.width,
        height: annAttrs.height,
        opacity: annAttrs.opacity,
        align: annAttrs.align,
        valign: annAttrs.valign,
        bgcolor: annAttrs.bgcolor,
        bordercolor: annAttrs.bordercolor,
        borderpad: annAttrs.borderpad,
        borderwidth: annAttrs.borderwidth,
        showarrow: annAttrs.showarrow,
        arrowcolor: annAttrs.arrowcolor,
        arrowhead: annAttrs.arrowhead,
        startarrowhead: annAttrs.startarrowhead,
        arrowside: annAttrs.arrowside,
        arrowsize: annAttrs.arrowsize,
        startarrowsize: annAttrs.startarrowsize,
        arrowwidth: annAttrs.arrowwidth,
        standoff: annAttrs.standoff,
        startstandoff: annAttrs.startstandoff,
        hovertext: annAttrs.hovertext,
        hoverlabel: annAttrs.hoverlabel,
        captureevents: annAttrs.captureevents
        // maybes later?
        // clicktoshow: annAttrs.clicktoshow,
        // xclick: annAttrs.xclick,
        // yclick: annAttrs.yclick,
        // not needed!
        // axref: 'pixel'
        // ayref: 'pixel'
        // xref: 'x'
        // yref: 'y
        // zref: 'z'
      }), "calc", "from-root");
    }
  });

  // src/components/annotations3d/defaults.js
  var require_defaults10 = __commonJS({
    "src/components/annotations3d/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var handleAnnotationCommonDefaults = require_common_defaults();
      var attributes = require_attributes15();
      module.exports = function handleDefaults(sceneLayoutIn, sceneLayoutOut, opts) {
        handleArrayContainerDefaults(sceneLayoutIn, sceneLayoutOut, {
          name: "annotations",
          handleItemDefaults: handleAnnotationDefaults,
          fullLayout: opts.fullLayout
        });
      };
      function handleAnnotationDefaults(annIn, annOut, sceneLayout, opts) {
        function coerce(attr, dflt) {
          return Lib.coerce(annIn, annOut, attributes, attr, dflt);
        }
        function coercePosition(axLetter) {
          var axName = axLetter + "axis";
          var gdMock = { _fullLayout: {} };
          gdMock._fullLayout[axName] = sceneLayout[axName];
          return Axes.coercePosition(annOut, gdMock, coerce, axLetter, axLetter, 0.5);
        }
        var visible = coerce("visible");
        if (!visible) return;
        handleAnnotationCommonDefaults(annIn, annOut, opts.fullLayout, coerce);
        coercePosition("x");
        coercePosition("y");
        coercePosition("z");
        Lib.noneOrAll(annIn, annOut, ["x", "y", "z"]);
        annOut.xref = "x";
        annOut.yref = "y";
        annOut.zref = "z";
        coerce("xanchor");
        coerce("yanchor");
        coerce("xshift");
        coerce("yshift");
        if (annOut.showarrow) {
          annOut.axref = "pixel";
          annOut.ayref = "pixel";
          coerce("ax", -10);
          coerce("ay", -30);
          Lib.noneOrAll(annIn, annOut, ["ax", "ay"]);
        }
      }
    }
  });

  // src/components/annotations3d/convert.js
  var require_convert = __commonJS({
    "src/components/annotations3d/convert.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      module.exports = function convert(scene) {
        var fullSceneLayout = scene.fullSceneLayout;
        var anns = fullSceneLayout.annotations;
        for (var i = 0; i < anns.length; i++) {
          mockAnnAxes(anns[i], scene);
        }
        scene.fullLayout._infolayer.selectAll(".annotation-" + scene.id).remove();
      };
      function mockAnnAxes(ann, scene) {
        var fullSceneLayout = scene.fullSceneLayout;
        var domain = fullSceneLayout.domain;
        var size = scene.fullLayout._size;
        var base = {
          // this gets fill in on render
          pdata: null,
          // to get setConvert to not execute cleanly
          type: "linear",
          // don't try to update them on `editable: true`
          autorange: false,
          // set infinite range so that annotation draw routine
          // does not try to remove 'outside-range' annotations,
          // this case is handled in the render loop
          range: [-Infinity, Infinity]
        };
        ann._xa = {};
        Lib.extendFlat(ann._xa, base);
        Axes.setConvert(ann._xa);
        ann._xa._offset = size.l + domain.x[0] * size.w;
        ann._xa.l2p = function() {
          return 0.5 * (1 + ann._pdata[0] / ann._pdata[3]) * size.w * (domain.x[1] - domain.x[0]);
        };
        ann._ya = {};
        Lib.extendFlat(ann._ya, base);
        Axes.setConvert(ann._ya);
        ann._ya._offset = size.t + (1 - domain.y[1]) * size.h;
        ann._ya.l2p = function() {
          return 0.5 * (1 - ann._pdata[1] / ann._pdata[3]) * size.h * (domain.y[1] - domain.y[0]);
        };
      }
    }
  });

  // src/plots/gl3d/project.js
  var require_project = __commonJS({
    "src/plots/gl3d/project.js"(exports, module) {
      "use strict";
      function xformMatrix(m, v) {
        var out = [0, 0, 0, 0];
        var i, j;
        for (i = 0; i < 4; ++i) {
          for (j = 0; j < 4; ++j) {
            out[j] += m[4 * i + j] * v[i];
          }
        }
        return out;
      }
      function project(camera, v) {
        var p = xformMatrix(
          camera.projection,
          xformMatrix(
            camera.view,
            xformMatrix(camera.model, [v[0], v[1], v[2], 1])
          )
        );
        return p;
      }
      module.exports = project;
    }
  });

  // src/components/annotations3d/draw.js
  var require_draw5 = __commonJS({
    "src/components/annotations3d/draw.js"(exports, module) {
      "use strict";
      var drawRaw = require_draw4().drawRaw;
      var project = require_project();
      var axLetters = ["x", "y", "z"];
      module.exports = function draw(scene) {
        var fullSceneLayout = scene.fullSceneLayout;
        var dataScale = scene.dataScale;
        var anns = fullSceneLayout.annotations;
        for (var i = 0; i < anns.length; i++) {
          var ann = anns[i];
          var annotationIsOffscreen = false;
          for (var j = 0; j < 3; j++) {
            var axLetter = axLetters[j];
            var pos = ann[axLetter];
            var ax = fullSceneLayout[axLetter + "axis"];
            var posFraction = ax.r2fraction(pos);
            if (posFraction < 0 || posFraction > 1) {
              annotationIsOffscreen = true;
              break;
            }
          }
          if (annotationIsOffscreen) {
            scene.fullLayout._infolayer.select(".annotation-" + scene.id + '[data-index="' + i + '"]').remove();
          } else {
            ann._pdata = project(scene.glplot.cameraParams, [
              fullSceneLayout.xaxis.r2l(ann.x) * dataScale[0],
              fullSceneLayout.yaxis.r2l(ann.y) * dataScale[1],
              fullSceneLayout.zaxis.r2l(ann.z) * dataScale[2]
            ]);
            drawRaw(scene.graphDiv, ann, i, scene.id, ann._xa, ann._ya);
          }
        }
      };
    }
  });

  // src/components/annotations3d/index.js
  var require_annotations3d = __commonJS({
    "src/components/annotations3d/index.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      module.exports = {
        moduleType: "component",
        name: "annotations3d",
        schema: {
          subplots: {
            scene: { annotations: require_attributes15() }
          }
        },
        layoutAttributes: require_attributes15(),
        handleDefaults: require_defaults10(),
        includeBasePlot: includeGL3D,
        convert: require_convert(),
        draw: require_draw5()
      };
      function includeGL3D(layoutIn, layoutOut) {
        var GL3D = Registry.subplotsRegistry.gl3d;
        if (!GL3D) return;
        var attrRegex = GL3D.attrRegex;
        var keys = Object.keys(layoutIn);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          if (attrRegex.test(k) && (layoutIn[k].annotations || []).length) {
            Lib.pushUnique(layoutOut._basePlotModules, GL3D);
            Lib.pushUnique(layoutOut._subplots.gl3d, k);
          }
        }
      }
    }
  });

  // src/components/shapes/attributes.js
  var require_attributes16 = __commonJS({
    "src/components/shapes/attributes.js"(exports, module) {
      "use strict";
      var annAttrs = require_attributes11();
      var fontAttrs = require_font_attributes();
      var scatterLineAttrs = require_attributes12().line;
      var dash = require_attributes4().dash;
      var extendFlat = require_extend().extendFlat;
      var templatedArray = require_plot_template().templatedArray;
      var axisPlaceableObjs = require_axis_placeable_objects();
      var basePlotAttributes = require_attributes2();
      var shapeTexttemplateAttrs = require_template_attributes().shapeTexttemplateAttrs;
      var shapeLabelTexttemplateVars = require_label_texttemplate();
      module.exports = templatedArray("shape", {
        visible: extendFlat({}, basePlotAttributes.visible, {
          editType: "calc+arraydraw"
        }),
        showlegend: {
          valType: "boolean",
          dflt: false,
          editType: "calc+arraydraw"
        },
        legend: extendFlat({}, basePlotAttributes.legend, {
          editType: "calc+arraydraw"
        }),
        legendgroup: extendFlat({}, basePlotAttributes.legendgroup, {
          editType: "calc+arraydraw"
        }),
        legendgrouptitle: {
          text: extendFlat({}, basePlotAttributes.legendgrouptitle.text, {
            editType: "calc+arraydraw"
          }),
          font: fontAttrs({
            editType: "calc+arraydraw"
          }),
          editType: "calc+arraydraw"
        },
        legendrank: extendFlat({}, basePlotAttributes.legendrank, {
          editType: "calc+arraydraw"
        }),
        legendwidth: extendFlat({}, basePlotAttributes.legendwidth, {
          editType: "calc+arraydraw"
        }),
        type: {
          valType: "enumerated",
          values: ["circle", "rect", "path", "line"],
          editType: "calc+arraydraw"
        },
        layer: {
          valType: "enumerated",
          values: ["below", "above", "between"],
          dflt: "above",
          editType: "arraydraw"
        },
        xref: extendFlat({}, annAttrs.xref, {}),
        xsizemode: {
          valType: "enumerated",
          values: ["scaled", "pixel"],
          dflt: "scaled",
          editType: "calc+arraydraw"
        },
        xanchor: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        x0: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        x1: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        x0shift: {
          valType: "number",
          dflt: 0,
          min: -1,
          max: 1,
          editType: "calc"
        },
        x1shift: {
          valType: "number",
          dflt: 0,
          min: -1,
          max: 1,
          editType: "calc"
        },
        yref: extendFlat({}, annAttrs.yref, {}),
        ysizemode: {
          valType: "enumerated",
          values: ["scaled", "pixel"],
          dflt: "scaled",
          editType: "calc+arraydraw"
        },
        yanchor: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        y0: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        y1: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        y0shift: {
          valType: "number",
          dflt: 0,
          min: -1,
          max: 1,
          editType: "calc"
        },
        y1shift: {
          valType: "number",
          dflt: 0,
          min: -1,
          max: 1,
          editType: "calc"
        },
        path: {
          valType: "string",
          editType: "calc+arraydraw"
        },
        opacity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 1,
          editType: "arraydraw"
        },
        line: {
          color: extendFlat({}, scatterLineAttrs.color, { editType: "arraydraw" }),
          width: extendFlat({}, scatterLineAttrs.width, { editType: "calc+arraydraw" }),
          dash: extendFlat({}, dash, { editType: "arraydraw" }),
          editType: "calc+arraydraw"
        },
        fillcolor: {
          valType: "color",
          dflt: "rgba(0,0,0,0)",
          editType: "arraydraw"
        },
        fillrule: {
          valType: "enumerated",
          values: ["evenodd", "nonzero"],
          dflt: "evenodd",
          editType: "arraydraw"
        },
        editable: {
          valType: "boolean",
          dflt: false,
          editType: "calc+arraydraw"
        },
        label: {
          text: {
            valType: "string",
            dflt: "",
            editType: "arraydraw"
          },
          texttemplate: shapeTexttemplateAttrs({}, { keys: Object.keys(shapeLabelTexttemplateVars) }),
          font: fontAttrs({
            editType: "calc+arraydraw",
            colorEditType: "arraydraw"
          }),
          textposition: {
            valType: "enumerated",
            values: [
              "top left",
              "top center",
              "top right",
              "middle left",
              "middle center",
              "middle right",
              "bottom left",
              "bottom center",
              "bottom right",
              "start",
              "middle",
              "end"
            ],
            editType: "arraydraw"
          },
          textangle: {
            valType: "angle",
            dflt: "auto",
            editType: "calc+arraydraw"
          },
          xanchor: {
            valType: "enumerated",
            values: ["auto", "left", "center", "right"],
            dflt: "auto",
            editType: "calc+arraydraw"
          },
          yanchor: {
            valType: "enumerated",
            values: ["top", "middle", "bottom"],
            editType: "calc+arraydraw"
          },
          padding: {
            valType: "number",
            dflt: 3,
            min: 0,
            editType: "arraydraw"
          },
          editType: "arraydraw"
        },
        editType: "arraydraw"
      });
    }
  });

  // src/components/shapes/defaults.js
  var require_defaults11 = __commonJS({
    "src/components/shapes/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes16();
      var helpers = require_helpers8();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        handleArrayContainerDefaults(layoutIn, layoutOut, {
          name: "shapes",
          handleItemDefaults: handleShapeDefaults
        });
      };
      function dfltLabelYanchor(isLine, labelTextPosition) {
        return isLine ? "bottom" : labelTextPosition.indexOf("top") !== -1 ? "top" : labelTextPosition.indexOf("bottom") !== -1 ? "bottom" : "middle";
      }
      function handleShapeDefaults(shapeIn, shapeOut, fullLayout) {
        function coerce(attr, dflt) {
          return Lib.coerce(shapeIn, shapeOut, attributes, attr, dflt);
        }
        shapeOut._isShape = true;
        var visible = coerce("visible");
        if (!visible) return;
        var showlegend = coerce("showlegend");
        if (showlegend) {
          coerce("legend");
          coerce("legendwidth");
          coerce("legendgroup");
          coerce("legendgrouptitle.text");
          Lib.coerceFont(coerce, "legendgrouptitle.font");
          coerce("legendrank");
        }
        var path = coerce("path");
        var dfltType = path ? "path" : "rect";
        var shapeType = coerce("type", dfltType);
        var noPath = shapeType !== "path";
        if (noPath) delete shapeOut.path;
        coerce("editable");
        coerce("layer");
        coerce("opacity");
        coerce("fillcolor");
        coerce("fillrule");
        var lineWidth = coerce("line.width");
        if (lineWidth) {
          coerce("line.color");
          coerce("line.dash");
        }
        var xSizeMode = coerce("xsizemode");
        var ySizeMode = coerce("ysizemode");
        var axLetters = ["x", "y"];
        for (var i = 0; i < 2; i++) {
          var axLetter = axLetters[i];
          var attrAnchor = axLetter + "anchor";
          var sizeMode = axLetter === "x" ? xSizeMode : ySizeMode;
          var gdMock = { _fullLayout: fullLayout };
          var ax;
          var pos2r;
          var r2pos;
          var axRef = Axes.coerceRef(
            shapeIn,
            shapeOut,
            gdMock,
            axLetter,
            void 0,
            "paper"
          );
          var axRefType = Axes.getRefType(axRef);
          if (axRefType === "range") {
            ax = Axes.getFromId(gdMock, axRef);
            ax._shapeIndices.push(shapeOut._index);
            r2pos = helpers.rangeToShapePosition(ax);
            pos2r = helpers.shapePositionToRange(ax);
            if (ax.type === "category" || ax.type === "multicategory") {
              coerce(axLetter + "0shift");
              coerce(axLetter + "1shift");
            }
          } else {
            pos2r = r2pos = Lib.identity;
          }
          if (noPath) {
            var dflt0 = 0.25;
            var dflt1 = 0.75;
            var attr0 = axLetter + "0";
            var attr1 = axLetter + "1";
            var in0 = shapeIn[attr0];
            var in1 = shapeIn[attr1];
            shapeIn[attr0] = pos2r(shapeIn[attr0], true);
            shapeIn[attr1] = pos2r(shapeIn[attr1], true);
            if (sizeMode === "pixel") {
              coerce(attr0, 0);
              coerce(attr1, 10);
            } else {
              Axes.coercePosition(shapeOut, gdMock, coerce, axRef, attr0, dflt0);
              Axes.coercePosition(shapeOut, gdMock, coerce, axRef, attr1, dflt1);
            }
            shapeOut[attr0] = r2pos(shapeOut[attr0]);
            shapeOut[attr1] = r2pos(shapeOut[attr1]);
            shapeIn[attr0] = in0;
            shapeIn[attr1] = in1;
          }
          if (sizeMode === "pixel") {
            var inAnchor = shapeIn[attrAnchor];
            shapeIn[attrAnchor] = pos2r(shapeIn[attrAnchor], true);
            Axes.coercePosition(shapeOut, gdMock, coerce, axRef, attrAnchor, 0.25);
            shapeOut[attrAnchor] = r2pos(shapeOut[attrAnchor]);
            shapeIn[attrAnchor] = inAnchor;
          }
        }
        if (noPath) {
          Lib.noneOrAll(shapeIn, shapeOut, ["x0", "x1", "y0", "y1"]);
        }
        var isLine = shapeType === "line";
        var labelTextTemplate, labelText;
        if (noPath) {
          labelTextTemplate = coerce("label.texttemplate");
        }
        if (!labelTextTemplate) {
          labelText = coerce("label.text");
        }
        if (labelText || labelTextTemplate) {
          coerce("label.textangle");
          var labelTextPosition = coerce("label.textposition", isLine ? "middle" : "middle center");
          coerce("label.xanchor");
          coerce("label.yanchor", dfltLabelYanchor(isLine, labelTextPosition));
          coerce("label.padding");
          Lib.coerceFont(coerce, "label.font", fullLayout.font);
        }
      }
    }
  });

  // src/components/shapes/draw_newshape/defaults.js
  var require_defaults12 = __commonJS({
    "src/components/shapes/draw_newshape/defaults.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var Lib = require_lib();
      function dfltLabelYanchor(isLine, labelTextPosition) {
        return isLine ? "bottom" : labelTextPosition.indexOf("top") !== -1 ? "top" : labelTextPosition.indexOf("bottom") !== -1 ? "bottom" : "middle";
      }
      module.exports = function supplyDrawNewShapeDefaults(layoutIn, layoutOut, coerce) {
        coerce("newshape.visible");
        coerce("newshape.name");
        coerce("newshape.showlegend");
        coerce("newshape.legend");
        coerce("newshape.legendwidth");
        coerce("newshape.legendgroup");
        coerce("newshape.legendgrouptitle.text");
        Lib.coerceFont(coerce, "newshape.legendgrouptitle.font");
        coerce("newshape.legendrank");
        coerce("newshape.drawdirection");
        coerce("newshape.layer");
        coerce("newshape.fillcolor");
        coerce("newshape.fillrule");
        coerce("newshape.opacity");
        var newshapeLineWidth = coerce("newshape.line.width");
        if (newshapeLineWidth) {
          var bgcolor = (layoutIn || {}).plot_bgcolor || "#FFF";
          coerce("newshape.line.color", Color.contrast(bgcolor));
          coerce("newshape.line.dash");
        }
        var isLine = layoutIn.dragmode === "drawline";
        var labelText = coerce("newshape.label.text");
        var labelTextTemplate = coerce("newshape.label.texttemplate");
        if (labelText || labelTextTemplate) {
          coerce("newshape.label.textangle");
          var labelTextPosition = coerce("newshape.label.textposition", isLine ? "middle" : "middle center");
          coerce("newshape.label.xanchor");
          coerce("newshape.label.yanchor", dfltLabelYanchor(isLine, labelTextPosition));
          coerce("newshape.label.padding");
          Lib.coerceFont(coerce, "newshape.label.font", layoutOut.font);
        }
        coerce("activeshape.fillcolor");
        coerce("activeshape.opacity");
      };
    }
  });

  // src/components/shapes/calc_autorange.js
  var require_calc_autorange2 = __commonJS({
    "src/components/shapes/calc_autorange.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var constants = require_constants5();
      var helpers = require_helpers8();
      module.exports = function calcAutorange(gd) {
        var fullLayout = gd._fullLayout;
        var shapeList = Lib.filterVisible(fullLayout.shapes);
        if (!shapeList.length || !gd._fullData.length) return;
        for (var i = 0; i < shapeList.length; i++) {
          var shape = shapeList[i];
          shape._extremes = {};
          var ax;
          var bounds;
          var xRefType = Axes.getRefType(shape.xref);
          var yRefType = Axes.getRefType(shape.yref);
          if (shape.xref !== "paper" && xRefType !== "domain") {
            ax = Axes.getFromId(gd, shape.xref);
            bounds = shapeBounds(ax, shape, constants.paramIsX);
            if (bounds) {
              shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcXPaddingOptions(shape));
            }
          }
          if (shape.yref !== "paper" && yRefType !== "domain") {
            ax = Axes.getFromId(gd, shape.yref);
            bounds = shapeBounds(ax, shape, constants.paramIsY);
            if (bounds) {
              shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcYPaddingOptions(shape));
            }
          }
        }
      };
      function calcXPaddingOptions(shape) {
        return calcPaddingOptions(shape.line.width, shape.xsizemode, shape.x0, shape.x1, shape.path, false);
      }
      function calcYPaddingOptions(shape) {
        return calcPaddingOptions(shape.line.width, shape.ysizemode, shape.y0, shape.y1, shape.path, true);
      }
      function calcPaddingOptions(lineWidth, sizeMode, v0, v1, path, isYAxis) {
        var ppad = lineWidth / 2;
        var axisDirectionReverted = isYAxis;
        if (sizeMode === "pixel") {
          var coords = path ? helpers.extractPathCoords(path, isYAxis ? constants.paramIsY : constants.paramIsX) : [v0, v1];
          var maxValue = Lib.aggNums(Math.max, null, coords);
          var minValue = Lib.aggNums(Math.min, null, coords);
          var beforePad = minValue < 0 ? Math.abs(minValue) + ppad : ppad;
          var afterPad = maxValue > 0 ? maxValue + ppad : ppad;
          return {
            ppad,
            ppadplus: axisDirectionReverted ? beforePad : afterPad,
            ppadminus: axisDirectionReverted ? afterPad : beforePad
          };
        } else {
          return { ppad };
        }
      }
      function shapeBounds(ax, shape, paramsToUse) {
        var dim = ax._id.charAt(0) === "x" ? "x" : "y";
        var isCategory = ax.type === "category" || ax.type === "multicategory";
        var v0;
        var v1;
        var shiftStart = 0;
        var shiftEnd = 0;
        var convertVal = isCategory ? ax.r2c : ax.d2c;
        var isSizeModeScale = shape[dim + "sizemode"] === "scaled";
        if (isSizeModeScale) {
          v0 = shape[dim + "0"];
          v1 = shape[dim + "1"];
          if (isCategory) {
            shiftStart = shape[dim + "0shift"];
            shiftEnd = shape[dim + "1shift"];
          }
        } else {
          v0 = shape[dim + "anchor"];
          v1 = shape[dim + "anchor"];
        }
        if (v0 !== void 0) return [convertVal(v0) + shiftStart, convertVal(v1) + shiftEnd];
        if (!shape.path) return;
        var min = Infinity;
        var max = -Infinity;
        var segments = shape.path.match(constants.segmentRE);
        var i;
        var segment;
        var drawnParam;
        var params;
        var val;
        if (ax.type === "date") convertVal = helpers.decodeDate(convertVal);
        for (i = 0; i < segments.length; i++) {
          segment = segments[i];
          drawnParam = paramsToUse[segment.charAt(0)].drawn;
          if (drawnParam === void 0) continue;
          params = segments[i].substr(1).match(constants.paramRE);
          if (!params || params.length < drawnParam) continue;
          val = convertVal(params[drawnParam]);
          if (val < min) min = val;
          if (val > max) max = val;
        }
        if (max >= min) return [min, max];
      }
    }
  });

  // src/components/shapes/index.js
  var require_shapes = __commonJS({
    "src/components/shapes/index.js"(exports, module) {
      "use strict";
      var drawModule = require_draw2();
      module.exports = {
        moduleType: "component",
        name: "shapes",
        layoutAttributes: require_attributes16(),
        supplyLayoutDefaults: require_defaults11(),
        supplyDrawNewShapeDefaults: require_defaults12(),
        includeBasePlot: require_include_components()("shapes"),
        calcAutorange: require_calc_autorange2(),
        draw: drawModule.draw,
        drawOne: drawModule.drawOne
      };
    }
  });

  // src/components/images/attributes.js
  var require_attributes17 = __commonJS({
    "src/components/images/attributes.js"(exports, module) {
      "use strict";
      var cartesianConstants = require_constants2();
      var templatedArray = require_plot_template().templatedArray;
      var axisPlaceableObjs = require_axis_placeable_objects();
      module.exports = templatedArray("image", {
        visible: {
          valType: "boolean",
          dflt: true,
          editType: "arraydraw"
        },
        source: {
          valType: "string",
          editType: "arraydraw"
        },
        layer: {
          valType: "enumerated",
          values: ["below", "above"],
          dflt: "above",
          editType: "arraydraw"
        },
        sizex: {
          valType: "number",
          dflt: 0,
          editType: "arraydraw"
        },
        sizey: {
          valType: "number",
          dflt: 0,
          editType: "arraydraw"
        },
        sizing: {
          valType: "enumerated",
          values: ["fill", "contain", "stretch"],
          dflt: "contain",
          editType: "arraydraw"
        },
        opacity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 1,
          editType: "arraydraw"
        },
        x: {
          valType: "any",
          dflt: 0,
          editType: "arraydraw"
        },
        y: {
          valType: "any",
          dflt: 0,
          editType: "arraydraw"
        },
        xanchor: {
          valType: "enumerated",
          values: ["left", "center", "right"],
          dflt: "left",
          editType: "arraydraw"
        },
        yanchor: {
          valType: "enumerated",
          values: ["top", "middle", "bottom"],
          dflt: "top",
          editType: "arraydraw"
        },
        xref: {
          valType: "enumerated",
          values: [
            "paper",
            cartesianConstants.idRegex.x.toString()
          ],
          dflt: "paper",
          editType: "arraydraw"
        },
        yref: {
          valType: "enumerated",
          values: [
            "paper",
            cartesianConstants.idRegex.y.toString()
          ],
          dflt: "paper",
          editType: "arraydraw"
        },
        editType: "arraydraw"
      });
    }
  });

  // src/components/images/defaults.js
  var require_defaults13 = __commonJS({
    "src/components/images/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes17();
      var name = "images";
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        var opts = {
          name,
          handleItemDefaults: imageDefaults
        };
        handleArrayContainerDefaults(layoutIn, layoutOut, opts);
      };
      function imageDefaults(imageIn, imageOut, fullLayout) {
        function coerce(attr, dflt) {
          return Lib.coerce(imageIn, imageOut, attributes, attr, dflt);
        }
        var source = coerce("source");
        var visible = coerce("visible", !!source);
        if (!visible) return imageOut;
        coerce("layer");
        coerce("xanchor");
        coerce("yanchor");
        coerce("sizex");
        coerce("sizey");
        coerce("sizing");
        coerce("opacity");
        var gdMock = { _fullLayout: fullLayout };
        var axLetters = ["x", "y"];
        for (var i = 0; i < 2; i++) {
          var axLetter = axLetters[i];
          var axRef = Axes.coerceRef(imageIn, imageOut, gdMock, axLetter, "paper", void 0);
          if (axRef !== "paper") {
            var ax = Axes.getFromId(gdMock, axRef);
            ax._imgIndices.push(imageOut._index);
          }
          Axes.coercePosition(imageOut, gdMock, coerce, axRef, axLetter, 0);
        }
        return imageOut;
      }
    }
  });

  // src/components/images/draw.js
  var require_draw6 = __commonJS({
    "src/components/images/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Drawing = require_drawing();
      var Axes = require_axes();
      var axisIds = require_axis_ids();
      var xmlnsNamespaces = require_xmlns_namespaces();
      module.exports = function draw(gd) {
        var fullLayout = gd._fullLayout;
        var imageDataAbove = [];
        var imageDataSubplot = {};
        var imageDataBelow = [];
        var subplot;
        var i;
        for (i = 0; i < fullLayout.images.length; i++) {
          var img = fullLayout.images[i];
          if (img.visible) {
            if (img.layer === "below" && img.xref !== "paper" && img.yref !== "paper") {
              subplot = axisIds.ref2id(img.xref) + axisIds.ref2id(img.yref);
              var plotinfo = fullLayout._plots[subplot];
              if (!plotinfo) {
                imageDataBelow.push(img);
                continue;
              }
              if (plotinfo.mainplot) {
                subplot = plotinfo.mainplot.id;
              }
              if (!imageDataSubplot[subplot]) {
                imageDataSubplot[subplot] = [];
              }
              imageDataSubplot[subplot].push(img);
            } else if (img.layer === "above") {
              imageDataAbove.push(img);
            } else {
              imageDataBelow.push(img);
            }
          }
        }
        var anchors = {
          x: {
            left: { sizing: "xMin", offset: 0 },
            center: { sizing: "xMid", offset: -1 / 2 },
            right: { sizing: "xMax", offset: -1 }
          },
          y: {
            top: { sizing: "YMin", offset: 0 },
            middle: { sizing: "YMid", offset: -1 / 2 },
            bottom: { sizing: "YMax", offset: -1 }
          }
        };
        function setImage(d) {
          var thisImage = d3.select(this);
          if (this._imgSrc === d.source) {
            return;
          }
          thisImage.attr("xmlns", xmlnsNamespaces.svg);
          if (!gd._context.staticPlot || d.source && d.source.slice(0, 5) === "data:") {
            thisImage.attr("xlink:href", d.source);
            this._imgSrc = d.source;
          } else {
            var imagePromise = new Promise(function(resolve) {
              var img2 = new Image();
              this.img = img2;
              img2.setAttribute("crossOrigin", "anonymous");
              img2.onerror = errorHandler;
              img2.onload = function() {
                var canvas = document.createElement("canvas");
                canvas.width = this.width;
                canvas.height = this.height;
                var ctx = canvas.getContext("2d", { willReadFrequently: true });
                ctx.drawImage(this, 0, 0);
                var dataURL = canvas.toDataURL("image/png");
                thisImage.attr("xlink:href", dataURL);
                resolve();
              };
              thisImage.on("error", errorHandler);
              img2.src = d.source;
              this._imgSrc = d.source;
              function errorHandler() {
                thisImage.remove();
                resolve();
              }
            }.bind(this));
            gd._promises.push(imagePromise);
          }
        }
        function applyAttributes(d) {
          var thisImage = d3.select(this);
          var xa = Axes.getFromId(gd, d.xref);
          var ya = Axes.getFromId(gd, d.yref);
          var xIsDomain = Axes.getRefType(d.xref) === "domain";
          var yIsDomain = Axes.getRefType(d.yref) === "domain";
          var size = fullLayout._size;
          var width, height;
          if (xa !== void 0) {
            width = typeof d.xref === "string" && xIsDomain ? xa._length * d.sizex : Math.abs(xa.l2p(d.sizex) - xa.l2p(0));
          } else {
            width = d.sizex * size.w;
          }
          if (ya !== void 0) {
            height = typeof d.yref === "string" && yIsDomain ? ya._length * d.sizey : Math.abs(ya.l2p(d.sizey) - ya.l2p(0));
          } else {
            height = d.sizey * size.h;
          }
          var xOffset = width * anchors.x[d.xanchor].offset;
          var yOffset = height * anchors.y[d.yanchor].offset;
          var sizing = anchors.x[d.xanchor].sizing + anchors.y[d.yanchor].sizing;
          var xPos, yPos;
          if (xa !== void 0) {
            xPos = typeof d.xref === "string" && xIsDomain ? xa._length * d.x + xa._offset : xa.r2p(d.x) + xa._offset;
          } else {
            xPos = d.x * size.w + size.l;
          }
          xPos += xOffset;
          if (ya !== void 0) {
            yPos = typeof d.yref === "string" && yIsDomain ? (
              // consistent with "paper" yref value, where positive values
              // move up the page
              ya._length * (1 - d.y) + ya._offset
            ) : ya.r2p(d.y) + ya._offset;
          } else {
            yPos = size.h - d.y * size.h + size.t;
          }
          yPos += yOffset;
          switch (d.sizing) {
            case "fill":
              sizing += " slice";
              break;
            case "stretch":
              sizing = "none";
              break;
          }
          thisImage.attr({
            x: xPos,
            y: yPos,
            width,
            height,
            preserveAspectRatio: sizing,
            opacity: d.opacity
          });
          var xId = xa && Axes.getRefType(d.xref) !== "domain" ? xa._id : "";
          var yId = ya && Axes.getRefType(d.yref) !== "domain" ? ya._id : "";
          var clipAxes = xId + yId;
          Drawing.setClipUrl(
            thisImage,
            clipAxes ? "clip" + fullLayout._uid + clipAxes : null,
            gd
          );
        }
        function imgDataFunc(d) {
          return [d.xref, d.x, d.sizex, d.yref, d.y, d.sizey].join("_");
        }
        function imgSort(a, b) {
          return a._index - b._index;
        }
        var imagesBelow = fullLayout._imageLowerLayer.selectAll("image").data(imageDataBelow, imgDataFunc);
        var imagesAbove = fullLayout._imageUpperLayer.selectAll("image").data(imageDataAbove, imgDataFunc);
        imagesBelow.enter().append("image");
        imagesAbove.enter().append("image");
        imagesBelow.exit().remove();
        imagesAbove.exit().remove();
        imagesBelow.each(function(d) {
          setImage.bind(this)(d);
          applyAttributes.bind(this)(d);
        });
        imagesAbove.each(function(d) {
          setImage.bind(this)(d);
          applyAttributes.bind(this)(d);
        });
        imagesBelow.sort(imgSort);
        imagesAbove.sort(imgSort);
        var allSubplots = Object.keys(fullLayout._plots);
        for (i = 0; i < allSubplots.length; i++) {
          subplot = allSubplots[i];
          var subplotObj = fullLayout._plots[subplot];
          if (!subplotObj.imagelayer) continue;
          var imagesOnSubplot = subplotObj.imagelayer.selectAll("image").data(imageDataSubplot[subplot] || [], imgDataFunc);
          imagesOnSubplot.enter().append("image");
          imagesOnSubplot.exit().remove();
          imagesOnSubplot.each(function(d) {
            setImage.bind(this)(d);
            applyAttributes.bind(this)(d);
          });
          imagesOnSubplot.sort(imgSort);
        }
      };
    }
  });

  // src/components/images/convert_coords.js
  var require_convert_coords2 = __commonJS({
    "src/components/images/convert_coords.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var toLogRange = require_to_log_range();
      module.exports = function convertCoords(gd, ax, newType, doExtra) {
        ax = ax || {};
        var toLog = newType === "log" && ax.type === "linear";
        var fromLog = newType === "linear" && ax.type === "log";
        if (!(toLog || fromLog)) return;
        var images = gd._fullLayout.images;
        var axLetter = ax._id.charAt(0);
        var image;
        var attrPrefix;
        for (var i = 0; i < images.length; i++) {
          image = images[i];
          attrPrefix = "images[" + i + "].";
          if (image[axLetter + "ref"] === ax._id) {
            var currentPos = image[axLetter];
            var currentSize = image["size" + axLetter];
            var newPos = null;
            var newSize = null;
            if (toLog) {
              newPos = toLogRange(currentPos, ax.range);
              var dx = currentSize / Math.pow(10, newPos) / 2;
              newSize = 2 * Math.log(dx + Math.sqrt(1 + dx * dx)) / Math.LN10;
            } else {
              newPos = Math.pow(10, currentPos);
              newSize = newPos * (Math.pow(10, currentSize / 2) - Math.pow(10, -currentSize / 2));
            }
            if (!isNumeric(newPos)) {
              newPos = null;
              newSize = null;
            } else if (!isNumeric(newSize)) newSize = null;
            doExtra(attrPrefix + axLetter, newPos);
            doExtra(attrPrefix + "size" + axLetter, newSize);
          }
        }
      };
    }
  });

  // src/components/images/index.js
  var require_images = __commonJS({
    "src/components/images/index.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "component",
        name: "images",
        layoutAttributes: require_attributes17(),
        supplyLayoutDefaults: require_defaults13(),
        includeBasePlot: require_include_components()("images"),
        draw: require_draw6(),
        convertCoords: require_convert_coords2()
      };
    }
  });

  // src/components/updatemenus/constants.js
  var require_constants9 = __commonJS({
    "src/components/updatemenus/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // layout attribute name
        name: "updatemenus",
        // class names
        containerClassName: "updatemenu-container",
        headerGroupClassName: "updatemenu-header-group",
        headerClassName: "updatemenu-header",
        headerArrowClassName: "updatemenu-header-arrow",
        dropdownButtonGroupClassName: "updatemenu-dropdown-button-group",
        dropdownButtonClassName: "updatemenu-dropdown-button",
        buttonClassName: "updatemenu-button",
        itemRectClassName: "updatemenu-item-rect",
        itemTextClassName: "updatemenu-item-text",
        // DOM attribute name in button group keeping track
        // of active update menu
        menuIndexAttrName: "updatemenu-active-index",
        // id root pass to Plots.autoMargin
        autoMarginIdRoot: "updatemenu-",
        // options when 'active: -1'
        blankHeaderOpts: { label: "  " },
        // min item width / height
        minWidth: 30,
        minHeight: 30,
        // padding around item text
        textPadX: 24,
        arrowPadX: 16,
        // item rect radii
        rx: 2,
        ry: 2,
        // item  text x offset off left edge
        textOffsetX: 12,
        // item  text y offset (w.r.t. middle)
        textOffsetY: 3,
        // arrow offset off right edge
        arrowOffsetX: 4,
        // gap between header and buttons
        gapButtonHeader: 5,
        // gap between between buttons
        gapButton: 2,
        // color given to active buttons
        activeColor: "#F4FAFF",
        // color given to hovered buttons
        hoverColor: "#F4FAFF",
        // symbol for menu open arrow
        arrowSymbol: {
          left: "\u25C4",
          right: "\u25BA",
          up: "\u25B2",
          down: "\u25BC"
        }
      };
    }
  });

  // src/components/updatemenus/attributes.js
  var require_attributes18 = __commonJS({
    "src/components/updatemenus/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var colorAttrs = require_attributes3();
      var extendFlat = require_extend().extendFlat;
      var overrideAll = require_edit_types().overrideAll;
      var padAttrs = require_pad_attributes();
      var templatedArray = require_plot_template().templatedArray;
      var buttonsAttrs = templatedArray("button", {
        visible: {
          valType: "boolean"
        },
        method: {
          valType: "enumerated",
          values: ["restyle", "relayout", "animate", "update", "skip"],
          dflt: "restyle"
        },
        args: {
          valType: "info_array",
          freeLength: true,
          items: [
            { valType: "any" },
            { valType: "any" },
            { valType: "any" }
          ]
        },
        args2: {
          valType: "info_array",
          freeLength: true,
          items: [
            { valType: "any" },
            { valType: "any" },
            { valType: "any" }
          ]
        },
        label: {
          valType: "string",
          dflt: ""
        },
        execute: {
          valType: "boolean",
          dflt: true
        }
      });
      module.exports = overrideAll(templatedArray("updatemenu", {
        _arrayAttrRegexps: [/^updatemenus\[(0|[1-9][0-9]+)\]\.buttons/],
        visible: {
          valType: "boolean"
        },
        type: {
          valType: "enumerated",
          values: ["dropdown", "buttons"],
          dflt: "dropdown"
        },
        direction: {
          valType: "enumerated",
          values: ["left", "right", "up", "down"],
          dflt: "down"
        },
        active: {
          valType: "integer",
          min: -1,
          dflt: 0
        },
        showactive: {
          valType: "boolean",
          dflt: true
        },
        buttons: buttonsAttrs,
        x: {
          valType: "number",
          min: -2,
          max: 3,
          dflt: -0.05
        },
        xanchor: {
          valType: "enumerated",
          values: ["auto", "left", "center", "right"],
          dflt: "right"
        },
        y: {
          valType: "number",
          min: -2,
          max: 3,
          dflt: 1
        },
        yanchor: {
          valType: "enumerated",
          values: ["auto", "top", "middle", "bottom"],
          dflt: "top"
        },
        pad: extendFlat(padAttrs({ editType: "arraydraw" }), {}),
        font: fontAttrs({}),
        bgcolor: {
          valType: "color"
        },
        bordercolor: {
          valType: "color",
          dflt: colorAttrs.borderLine
        },
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "arraydraw"
        }
      }), "arraydraw", "from-root");
    }
  });

  // src/components/updatemenus/defaults.js
  var require_defaults14 = __commonJS({
    "src/components/updatemenus/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes18();
      var constants = require_constants9();
      var name = constants.name;
      var buttonAttrs = attributes.buttons;
      module.exports = function updateMenusDefaults(layoutIn, layoutOut) {
        var opts = {
          name,
          handleItemDefaults: menuDefaults
        };
        handleArrayContainerDefaults(layoutIn, layoutOut, opts);
      };
      function menuDefaults(menuIn, menuOut, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(menuIn, menuOut, attributes, attr, dflt);
        }
        var buttons = handleArrayContainerDefaults(menuIn, menuOut, {
          name: "buttons",
          handleItemDefaults: buttonDefaults
        });
        var visible = coerce("visible", buttons.length > 0);
        if (!visible) return;
        coerce("active");
        coerce("direction");
        coerce("type");
        coerce("showactive");
        coerce("x");
        coerce("y");
        Lib.noneOrAll(menuIn, menuOut, ["x", "y"]);
        coerce("xanchor");
        coerce("yanchor");
        coerce("pad.t");
        coerce("pad.r");
        coerce("pad.b");
        coerce("pad.l");
        Lib.coerceFont(coerce, "font", layoutOut.font);
        coerce("bgcolor", layoutOut.paper_bgcolor);
        coerce("bordercolor");
        coerce("borderwidth");
      }
      function buttonDefaults(buttonIn, buttonOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(buttonIn, buttonOut, buttonAttrs, attr, dflt);
        }
        var visible = coerce(
          "visible",
          buttonIn.method === "skip" || Array.isArray(buttonIn.args)
        );
        if (visible) {
          coerce("method");
          coerce("args");
          coerce("args2");
          coerce("label");
          coerce("execute");
        }
      }
    }
  });

  // src/components/updatemenus/scrollbox.js
  var require_scrollbox = __commonJS({
    "src/components/updatemenus/scrollbox.js"(exports, module) {
      "use strict";
      module.exports = ScrollBox;
      var d3 = require_d3();
      var Color = require_color();
      var Drawing = require_drawing();
      var Lib = require_lib();
      function ScrollBox(gd, container, id) {
        this.gd = gd;
        this.container = container;
        this.id = id;
        this.position = null;
        this.translateX = null;
        this.translateY = null;
        this.hbar = null;
        this.vbar = null;
        this.bg = this.container.selectAll("rect.scrollbox-bg").data([0]);
        this.bg.exit().on(".drag", null).on("wheel", null).remove();
        this.bg.enter().append("rect").classed("scrollbox-bg", true).style("pointer-events", "all").attr({
          opacity: 0,
          x: 0,
          y: 0,
          width: 0,
          height: 0
        });
      }
      ScrollBox.barWidth = 2;
      ScrollBox.barLength = 20;
      ScrollBox.barRadius = 2;
      ScrollBox.barPad = 1;
      ScrollBox.barColor = "#808BA4";
      ScrollBox.prototype.enable = function enable(position, translateX, translateY) {
        var fullLayout = this.gd._fullLayout;
        var fullWidth = fullLayout.width;
        var fullHeight = fullLayout.height;
        this.position = position;
        var l = this.position.l;
        var w = this.position.w;
        var t = this.position.t;
        var h = this.position.h;
        var direction = this.position.direction;
        var isDown = direction === "down";
        var isLeft = direction === "left";
        var isRight = direction === "right";
        var isUp = direction === "up";
        var boxW = w;
        var boxH = h;
        var boxL, boxR;
        var boxT, boxB;
        if (!isDown && !isLeft && !isRight && !isUp) {
          this.position.direction = "down";
          isDown = true;
        }
        var isVertical = isDown || isUp;
        if (isVertical) {
          boxL = l;
          boxR = boxL + boxW;
          if (isDown) {
            boxT = t;
            boxB = Math.min(boxT + boxH, fullHeight);
            boxH = boxB - boxT;
          } else {
            boxB = t + boxH;
            boxT = Math.max(boxB - boxH, 0);
            boxH = boxB - boxT;
          }
        } else {
          boxT = t;
          boxB = boxT + boxH;
          if (isLeft) {
            boxR = l + boxW;
            boxL = Math.max(boxR - boxW, 0);
            boxW = boxR - boxL;
          } else {
            boxL = l;
            boxR = Math.min(boxL + boxW, fullWidth);
            boxW = boxR - boxL;
          }
        }
        this._box = {
          l: boxL,
          t: boxT,
          w: boxW,
          h: boxH
        };
        var needsHorizontalScrollBar = w > boxW;
        var hbarW = ScrollBox.barLength + 2 * ScrollBox.barPad;
        var hbarH = ScrollBox.barWidth + 2 * ScrollBox.barPad;
        var hbarL = l;
        var hbarT = t + h;
        if (hbarT + hbarH > fullHeight) hbarT = fullHeight - hbarH;
        var hbar = this.container.selectAll("rect.scrollbar-horizontal").data(
          needsHorizontalScrollBar ? [0] : []
        );
        hbar.exit().on(".drag", null).remove();
        hbar.enter().append("rect").classed("scrollbar-horizontal", true).call(Color.fill, ScrollBox.barColor);
        if (needsHorizontalScrollBar) {
          this.hbar = hbar.attr({
            rx: ScrollBox.barRadius,
            ry: ScrollBox.barRadius,
            x: hbarL,
            y: hbarT,
            width: hbarW,
            height: hbarH
          });
          this._hbarXMin = hbarL + hbarW / 2;
          this._hbarTranslateMax = boxW - hbarW;
        } else {
          delete this.hbar;
          delete this._hbarXMin;
          delete this._hbarTranslateMax;
        }
        var needsVerticalScrollBar = h > boxH;
        var vbarW = ScrollBox.barWidth + 2 * ScrollBox.barPad;
        var vbarH = ScrollBox.barLength + 2 * ScrollBox.barPad;
        var vbarL = l + w;
        var vbarT = t;
        if (vbarL + vbarW > fullWidth) vbarL = fullWidth - vbarW;
        var vbar = this.container.selectAll("rect.scrollbar-vertical").data(
          needsVerticalScrollBar ? [0] : []
        );
        vbar.exit().on(".drag", null).remove();
        vbar.enter().append("rect").classed("scrollbar-vertical", true).call(Color.fill, ScrollBox.barColor);
        if (needsVerticalScrollBar) {
          this.vbar = vbar.attr({
            rx: ScrollBox.barRadius,
            ry: ScrollBox.barRadius,
            x: vbarL,
            y: vbarT,
            width: vbarW,
            height: vbarH
          });
          this._vbarYMin = vbarT + vbarH / 2;
          this._vbarTranslateMax = boxH - vbarH;
        } else {
          delete this.vbar;
          delete this._vbarYMin;
          delete this._vbarTranslateMax;
        }
        var clipId = this.id;
        var clipL = boxL - 0.5;
        var clipR = needsVerticalScrollBar ? boxR + vbarW + 0.5 : boxR + 0.5;
        var clipT = boxT - 0.5;
        var clipB = needsHorizontalScrollBar ? boxB + hbarH + 0.5 : boxB + 0.5;
        var clipPath = fullLayout._topdefs.selectAll("#" + clipId).data(needsHorizontalScrollBar || needsVerticalScrollBar ? [0] : []);
        clipPath.exit().remove();
        clipPath.enter().append("clipPath").attr("id", clipId).append("rect");
        if (needsHorizontalScrollBar || needsVerticalScrollBar) {
          this._clipRect = clipPath.select("rect").attr({
            x: Math.floor(clipL),
            y: Math.floor(clipT),
            width: Math.ceil(clipR) - Math.floor(clipL),
            height: Math.ceil(clipB) - Math.floor(clipT)
          });
          this.container.call(Drawing.setClipUrl, clipId, this.gd);
          this.bg.attr({
            x: l,
            y: t,
            width: w,
            height: h
          });
        } else {
          this.bg.attr({
            width: 0,
            height: 0
          });
          this.container.on("wheel", null).on(".drag", null).call(Drawing.setClipUrl, null);
          delete this._clipRect;
        }
        if (needsHorizontalScrollBar || needsVerticalScrollBar) {
          var onBoxDrag = d3.behavior.drag().on("dragstart", function() {
            d3.event.sourceEvent.preventDefault();
          }).on("drag", this._onBoxDrag.bind(this));
          this.container.on("wheel", null).on("wheel", this._onBoxWheel.bind(this)).on(".drag", null).call(onBoxDrag);
          var onBarDrag = d3.behavior.drag().on("dragstart", function() {
            d3.event.sourceEvent.preventDefault();
            d3.event.sourceEvent.stopPropagation();
          }).on("drag", this._onBarDrag.bind(this));
          if (needsHorizontalScrollBar) {
            this.hbar.on(".drag", null).call(onBarDrag);
          }
          if (needsVerticalScrollBar) {
            this.vbar.on(".drag", null).call(onBarDrag);
          }
        }
        this.setTranslate(translateX, translateY);
      };
      ScrollBox.prototype.disable = function disable() {
        if (this.hbar || this.vbar) {
          this.bg.attr({
            width: 0,
            height: 0
          });
          this.container.on("wheel", null).on(".drag", null).call(Drawing.setClipUrl, null);
          delete this._clipRect;
        }
        if (this.hbar) {
          this.hbar.on(".drag", null);
          this.hbar.remove();
          delete this.hbar;
          delete this._hbarXMin;
          delete this._hbarTranslateMax;
        }
        if (this.vbar) {
          this.vbar.on(".drag", null);
          this.vbar.remove();
          delete this.vbar;
          delete this._vbarYMin;
          delete this._vbarTranslateMax;
        }
      };
      ScrollBox.prototype._onBoxDrag = function _onBoxDrag() {
        var translateX = this.translateX;
        var translateY = this.translateY;
        if (this.hbar) {
          translateX -= d3.event.dx;
        }
        if (this.vbar) {
          translateY -= d3.event.dy;
        }
        this.setTranslate(translateX, translateY);
      };
      ScrollBox.prototype._onBoxWheel = function _onBoxWheel() {
        var translateX = this.translateX;
        var translateY = this.translateY;
        if (this.hbar) {
          translateX += d3.event.deltaY;
        }
        if (this.vbar) {
          translateY += d3.event.deltaY;
        }
        this.setTranslate(translateX, translateY);
      };
      ScrollBox.prototype._onBarDrag = function _onBarDrag() {
        var translateX = this.translateX;
        var translateY = this.translateY;
        if (this.hbar) {
          var xMin = translateX + this._hbarXMin;
          var xMax = xMin + this._hbarTranslateMax;
          var x = Lib.constrain(d3.event.x, xMin, xMax);
          var xf = (x - xMin) / (xMax - xMin);
          var translateXMax = this.position.w - this._box.w;
          translateX = xf * translateXMax;
        }
        if (this.vbar) {
          var yMin = translateY + this._vbarYMin;
          var yMax = yMin + this._vbarTranslateMax;
          var y = Lib.constrain(d3.event.y, yMin, yMax);
          var yf = (y - yMin) / (yMax - yMin);
          var translateYMax = this.position.h - this._box.h;
          translateY = yf * translateYMax;
        }
        this.setTranslate(translateX, translateY);
      };
      ScrollBox.prototype.setTranslate = function setTranslate(translateX, translateY) {
        var translateXMax = this.position.w - this._box.w;
        var translateYMax = this.position.h - this._box.h;
        translateX = Lib.constrain(translateX || 0, 0, translateXMax);
        translateY = Lib.constrain(translateY || 0, 0, translateYMax);
        this.translateX = translateX;
        this.translateY = translateY;
        this.container.call(
          Drawing.setTranslate,
          this._box.l - this.position.l - translateX,
          this._box.t - this.position.t - translateY
        );
        if (this._clipRect) {
          this._clipRect.attr({
            x: Math.floor(this.position.l + translateX - 0.5),
            y: Math.floor(this.position.t + translateY - 0.5)
          });
        }
        if (this.hbar) {
          var xf = translateX / translateXMax;
          this.hbar.call(
            Drawing.setTranslate,
            translateX + xf * this._hbarTranslateMax,
            translateY
          );
        }
        if (this.vbar) {
          var yf = translateY / translateYMax;
          this.vbar.call(
            Drawing.setTranslate,
            translateX,
            translateY + yf * this._vbarTranslateMax
          );
        }
      };
    }
  });

  // src/components/updatemenus/draw.js
  var require_draw7 = __commonJS({
    "src/components/updatemenus/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Plots = require_plots();
      var Color = require_color();
      var Drawing = require_drawing();
      var Lib = require_lib();
      var svgTextUtils = require_svg_text_utils();
      var arrayEditor = require_plot_template().arrayEditor;
      var LINE_SPACING = require_alignment().LINE_SPACING;
      var constants = require_constants9();
      var ScrollBox = require_scrollbox();
      module.exports = function draw(gd) {
        var fullLayout = gd._fullLayout;
        var menuData = Lib.filterVisible(fullLayout[constants.name]);
        function clearAutoMargin(menuOpts2) {
          Plots.autoMargin(gd, autoMarginId(menuOpts2));
        }
        var menus = fullLayout._menulayer.selectAll("g." + constants.containerClassName).data(menuData.length > 0 ? [0] : []);
        menus.enter().append("g").classed(constants.containerClassName, true).style("cursor", "pointer");
        menus.exit().each(function() {
          d3.select(this).selectAll("g." + constants.headerGroupClassName).each(clearAutoMargin);
        }).remove();
        if (menuData.length === 0) return;
        var headerGroups = menus.selectAll("g." + constants.headerGroupClassName).data(menuData, keyFunction);
        headerGroups.enter().append("g").classed(constants.headerGroupClassName, true);
        var gButton = Lib.ensureSingle(menus, "g", constants.dropdownButtonGroupClassName, function(s) {
          s.style("pointer-events", "all");
        });
        for (var i = 0; i < menuData.length; i++) {
          var menuOpts = menuData[i];
          findDimensions(gd, menuOpts);
        }
        var scrollBoxId = "updatemenus" + fullLayout._uid;
        var scrollBox = new ScrollBox(gd, gButton, scrollBoxId);
        if (headerGroups.enter().size()) {
          gButton.node().parentNode.appendChild(gButton.node());
          gButton.call(removeAllButtons);
        }
        headerGroups.exit().each(function(menuOpts2) {
          gButton.call(removeAllButtons);
          clearAutoMargin(menuOpts2);
        }).remove();
        headerGroups.each(function(menuOpts2) {
          var gHeader = d3.select(this);
          var _gButton = menuOpts2.type === "dropdown" ? gButton : null;
          Plots.manageCommandObserver(gd, menuOpts2, menuOpts2.buttons, function(data) {
            setActive(gd, menuOpts2, menuOpts2.buttons[data.index], gHeader, _gButton, scrollBox, data.index, true);
          });
          if (menuOpts2.type === "dropdown") {
            drawHeader(gd, gHeader, gButton, scrollBox, menuOpts2);
            if (isActive(gButton, menuOpts2)) {
              drawButtons(gd, gHeader, gButton, scrollBox, menuOpts2);
            }
          } else {
            drawButtons(gd, gHeader, null, null, menuOpts2);
          }
        });
      };
      function keyFunction(menuOpts) {
        return menuOpts._index;
      }
      function isFolded(gButton) {
        return +gButton.attr(constants.menuIndexAttrName) === -1;
      }
      function isActive(gButton, menuOpts) {
        return +gButton.attr(constants.menuIndexAttrName) === menuOpts._index;
      }
      function setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, buttonIndex, isSilentUpdate) {
        menuOpts.active = buttonIndex;
        arrayEditor(gd.layout, constants.name, menuOpts).applyUpdate("active", buttonIndex);
        if (menuOpts.type === "buttons") {
          drawButtons(gd, gHeader, null, null, menuOpts);
        } else if (menuOpts.type === "dropdown") {
          gButton.attr(constants.menuIndexAttrName, "-1");
          drawHeader(gd, gHeader, gButton, scrollBox, menuOpts);
          if (!isSilentUpdate) {
            drawButtons(gd, gHeader, gButton, scrollBox, menuOpts);
          }
        }
      }
      function drawHeader(gd, gHeader, gButton, scrollBox, menuOpts) {
        var header = Lib.ensureSingle(gHeader, "g", constants.headerClassName, function(s) {
          s.style("pointer-events", "all");
        });
        var dims = menuOpts._dims;
        var active = menuOpts.active;
        var headerOpts = menuOpts.buttons[active] || constants.blankHeaderOpts;
        var posOpts = { y: menuOpts.pad.t, yPad: 0, x: menuOpts.pad.l, xPad: 0, index: 0 };
        var positionOverrides = {
          width: dims.headerWidth,
          height: dims.headerHeight
        };
        header.call(drawItem, menuOpts, headerOpts, gd).call(setItemPosition, menuOpts, posOpts, positionOverrides);
        var arrow = Lib.ensureSingle(gHeader, "text", constants.headerArrowClassName, function(s) {
          s.attr("text-anchor", "end").call(Drawing.font, menuOpts.font).text(constants.arrowSymbol[menuOpts.direction]);
        });
        arrow.attr({
          x: dims.headerWidth - constants.arrowOffsetX + menuOpts.pad.l,
          y: dims.headerHeight / 2 + constants.textOffsetY + menuOpts.pad.t
        });
        header.on("click", function() {
          gButton.call(
            removeAllButtons,
            String(isActive(gButton, menuOpts) ? -1 : menuOpts._index)
          );
          drawButtons(gd, gHeader, gButton, scrollBox, menuOpts);
        });
        header.on("mouseover", function() {
          header.call(styleOnMouseOver);
        });
        header.on("mouseout", function() {
          header.call(styleOnMouseOut, menuOpts);
        });
        Drawing.setTranslate(gHeader, dims.lx, dims.ly);
      }
      function drawButtons(gd, gHeader, gButton, scrollBox, menuOpts) {
        if (!gButton) {
          gButton = gHeader;
          gButton.attr("pointer-events", "all");
        }
        var buttonData = !isFolded(gButton) || menuOpts.type === "buttons" ? menuOpts.buttons : [];
        var klass = menuOpts.type === "dropdown" ? constants.dropdownButtonClassName : constants.buttonClassName;
        var buttons = gButton.selectAll("g." + klass).data(Lib.filterVisible(buttonData));
        var enter = buttons.enter().append("g").classed(klass, true);
        var exit = buttons.exit();
        if (menuOpts.type === "dropdown") {
          enter.attr("opacity", "0").transition().attr("opacity", "1");
          exit.transition().attr("opacity", "0").remove();
        } else {
          exit.remove();
        }
        var x0 = 0;
        var y0 = 0;
        var dims = menuOpts._dims;
        var isVertical = ["up", "down"].indexOf(menuOpts.direction) !== -1;
        if (menuOpts.type === "dropdown") {
          if (isVertical) {
            y0 = dims.headerHeight + constants.gapButtonHeader;
          } else {
            x0 = dims.headerWidth + constants.gapButtonHeader;
          }
        }
        if (menuOpts.type === "dropdown" && menuOpts.direction === "up") {
          y0 = -constants.gapButtonHeader + constants.gapButton - dims.openHeight;
        }
        if (menuOpts.type === "dropdown" && menuOpts.direction === "left") {
          x0 = -constants.gapButtonHeader + constants.gapButton - dims.openWidth;
        }
        var posOpts = {
          x: dims.lx + x0 + menuOpts.pad.l,
          y: dims.ly + y0 + menuOpts.pad.t,
          yPad: constants.gapButton,
          xPad: constants.gapButton,
          index: 0
        };
        var scrollBoxPosition = {
          l: posOpts.x + menuOpts.borderwidth,
          t: posOpts.y + menuOpts.borderwidth
        };
        buttons.each(function(buttonOpts, buttonIndex) {
          var button = d3.select(this);
          button.call(drawItem, menuOpts, buttonOpts, gd).call(setItemPosition, menuOpts, posOpts);
          button.on("click", function() {
            if (d3.event.defaultPrevented) return;
            if (buttonOpts.execute) {
              if (buttonOpts.args2 && menuOpts.active === buttonIndex) {
                setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, -1);
                Plots.executeAPICommand(gd, buttonOpts.method, buttonOpts.args2);
              } else {
                setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, buttonIndex);
                Plots.executeAPICommand(gd, buttonOpts.method, buttonOpts.args);
              }
            }
            gd.emit("plotly_buttonclicked", { menu: menuOpts, button: buttonOpts, active: menuOpts.active });
          });
          button.on("mouseover", function() {
            button.call(styleOnMouseOver);
          });
          button.on("mouseout", function() {
            button.call(styleOnMouseOut, menuOpts);
            buttons.call(styleButtons, menuOpts);
          });
        });
        buttons.call(styleButtons, menuOpts);
        if (isVertical) {
          scrollBoxPosition.w = Math.max(dims.openWidth, dims.headerWidth);
          scrollBoxPosition.h = posOpts.y - scrollBoxPosition.t;
        } else {
          scrollBoxPosition.w = posOpts.x - scrollBoxPosition.l;
          scrollBoxPosition.h = Math.max(dims.openHeight, dims.headerHeight);
        }
        scrollBoxPosition.direction = menuOpts.direction;
        if (scrollBox) {
          if (buttons.size()) {
            drawScrollBox(gd, gHeader, gButton, scrollBox, menuOpts, scrollBoxPosition);
          } else {
            hideScrollBox(scrollBox);
          }
        }
      }
      function drawScrollBox(gd, gHeader, gButton, scrollBox, menuOpts, position) {
        var direction = menuOpts.direction;
        var isVertical = direction === "up" || direction === "down";
        var dims = menuOpts._dims;
        var active = menuOpts.active;
        var translateX, translateY;
        var i;
        if (isVertical) {
          translateY = 0;
          for (i = 0; i < active; i++) {
            translateY += dims.heights[i] + constants.gapButton;
          }
        } else {
          translateX = 0;
          for (i = 0; i < active; i++) {
            translateX += dims.widths[i] + constants.gapButton;
          }
        }
        scrollBox.enable(position, translateX, translateY);
        if (scrollBox.hbar) {
          scrollBox.hbar.attr("opacity", "0").transition().attr("opacity", "1");
        }
        if (scrollBox.vbar) {
          scrollBox.vbar.attr("opacity", "0").transition().attr("opacity", "1");
        }
      }
      function hideScrollBox(scrollBox) {
        var hasHBar = !!scrollBox.hbar;
        var hasVBar = !!scrollBox.vbar;
        if (hasHBar) {
          scrollBox.hbar.transition().attr("opacity", "0").each("end", function() {
            hasHBar = false;
            if (!hasVBar) scrollBox.disable();
          });
        }
        if (hasVBar) {
          scrollBox.vbar.transition().attr("opacity", "0").each("end", function() {
            hasVBar = false;
            if (!hasHBar) scrollBox.disable();
          });
        }
      }
      function drawItem(item, menuOpts, itemOpts, gd) {
        item.call(drawItemRect, menuOpts).call(drawItemText, menuOpts, itemOpts, gd);
      }
      function drawItemRect(item, menuOpts) {
        var rect = Lib.ensureSingle(item, "rect", constants.itemRectClassName, function(s) {
          s.attr({
            rx: constants.rx,
            ry: constants.ry,
            "shape-rendering": "crispEdges"
          });
        });
        rect.call(Color.stroke, menuOpts.bordercolor).call(Color.fill, menuOpts.bgcolor).style("stroke-width", menuOpts.borderwidth + "px");
      }
      function drawItemText(item, menuOpts, itemOpts, gd) {
        var text = Lib.ensureSingle(item, "text", constants.itemTextClassName, function(s) {
          s.attr({
            "text-anchor": "start",
            "data-notex": 1
          });
        });
        var tx = itemOpts.label;
        var _meta = gd._fullLayout._meta;
        if (_meta) tx = Lib.templateString(tx, _meta);
        text.call(Drawing.font, menuOpts.font).text(tx).call(svgTextUtils.convertToTspans, gd);
      }
      function styleButtons(buttons, menuOpts) {
        var active = menuOpts.active;
        buttons.each(function(buttonOpts, i) {
          var button = d3.select(this);
          if (i === active && menuOpts.showactive) {
            button.select("rect." + constants.itemRectClassName).call(Color.fill, constants.activeColor);
          }
        });
      }
      function styleOnMouseOver(item) {
        item.select("rect." + constants.itemRectClassName).call(Color.fill, constants.hoverColor);
      }
      function styleOnMouseOut(item, menuOpts) {
        item.select("rect." + constants.itemRectClassName).call(Color.fill, menuOpts.bgcolor);
      }
      function findDimensions(gd, menuOpts) {
        var dims = menuOpts._dims = {
          width1: 0,
          height1: 0,
          heights: [],
          widths: [],
          totalWidth: 0,
          totalHeight: 0,
          openWidth: 0,
          openHeight: 0,
          lx: 0,
          ly: 0
        };
        var fakeButtons = Drawing.tester.selectAll("g." + constants.dropdownButtonClassName).data(Lib.filterVisible(menuOpts.buttons));
        fakeButtons.enter().append("g").classed(constants.dropdownButtonClassName, true);
        var isVertical = ["up", "down"].indexOf(menuOpts.direction) !== -1;
        fakeButtons.each(function(buttonOpts, i) {
          var button = d3.select(this);
          button.call(drawItem, menuOpts, buttonOpts, gd);
          var text = button.select("." + constants.itemTextClassName);
          var tWidth = text.node() && Drawing.bBox(text.node()).width;
          var wEff = Math.max(tWidth + constants.textPadX, constants.minWidth);
          var tHeight = menuOpts.font.size * LINE_SPACING;
          var tLines = svgTextUtils.lineCount(text);
          var hEff = Math.max(tHeight * tLines, constants.minHeight) + constants.textOffsetY;
          hEff = Math.ceil(hEff);
          wEff = Math.ceil(wEff);
          dims.widths[i] = wEff;
          dims.heights[i] = hEff;
          dims.height1 = Math.max(dims.height1, hEff);
          dims.width1 = Math.max(dims.width1, wEff);
          if (isVertical) {
            dims.totalWidth = Math.max(dims.totalWidth, wEff);
            dims.openWidth = dims.totalWidth;
            dims.totalHeight += hEff + constants.gapButton;
            dims.openHeight += hEff + constants.gapButton;
          } else {
            dims.totalWidth += wEff + constants.gapButton;
            dims.openWidth += wEff + constants.gapButton;
            dims.totalHeight = Math.max(dims.totalHeight, hEff);
            dims.openHeight = dims.totalHeight;
          }
        });
        if (isVertical) {
          dims.totalHeight -= constants.gapButton;
        } else {
          dims.totalWidth -= constants.gapButton;
        }
        dims.headerWidth = dims.width1 + constants.arrowPadX;
        dims.headerHeight = dims.height1;
        if (menuOpts.type === "dropdown") {
          if (isVertical) {
            dims.width1 += constants.arrowPadX;
            dims.totalHeight = dims.height1;
          } else {
            dims.totalWidth = dims.width1;
          }
          dims.totalWidth += constants.arrowPadX;
        }
        fakeButtons.remove();
        var paddedWidth = dims.totalWidth + menuOpts.pad.l + menuOpts.pad.r;
        var paddedHeight = dims.totalHeight + menuOpts.pad.t + menuOpts.pad.b;
        var graphSize = gd._fullLayout._size;
        dims.lx = graphSize.l + graphSize.w * menuOpts.x;
        dims.ly = graphSize.t + graphSize.h * (1 - menuOpts.y);
        var xanchor = "left";
        if (Lib.isRightAnchor(menuOpts)) {
          dims.lx -= paddedWidth;
          xanchor = "right";
        }
        if (Lib.isCenterAnchor(menuOpts)) {
          dims.lx -= paddedWidth / 2;
          xanchor = "center";
        }
        var yanchor = "top";
        if (Lib.isBottomAnchor(menuOpts)) {
          dims.ly -= paddedHeight;
          yanchor = "bottom";
        }
        if (Lib.isMiddleAnchor(menuOpts)) {
          dims.ly -= paddedHeight / 2;
          yanchor = "middle";
        }
        dims.totalWidth = Math.ceil(dims.totalWidth);
        dims.totalHeight = Math.ceil(dims.totalHeight);
        dims.lx = Math.round(dims.lx);
        dims.ly = Math.round(dims.ly);
        Plots.autoMargin(gd, autoMarginId(menuOpts), {
          x: menuOpts.x,
          y: menuOpts.y,
          l: paddedWidth * ({ right: 1, center: 0.5 }[xanchor] || 0),
          r: paddedWidth * ({ left: 1, center: 0.5 }[xanchor] || 0),
          b: paddedHeight * ({ top: 1, middle: 0.5 }[yanchor] || 0),
          t: paddedHeight * ({ bottom: 1, middle: 0.5 }[yanchor] || 0)
        });
      }
      function autoMarginId(menuOpts) {
        return constants.autoMarginIdRoot + menuOpts._index;
      }
      function setItemPosition(item, menuOpts, posOpts, overrideOpts) {
        overrideOpts = overrideOpts || {};
        var rect = item.select("." + constants.itemRectClassName);
        var text = item.select("." + constants.itemTextClassName);
        var borderWidth = menuOpts.borderwidth;
        var index = posOpts.index;
        var dims = menuOpts._dims;
        Drawing.setTranslate(item, borderWidth + posOpts.x, borderWidth + posOpts.y);
        var isVertical = ["up", "down"].indexOf(menuOpts.direction) !== -1;
        var finalHeight = overrideOpts.height || (isVertical ? dims.heights[index] : dims.height1);
        rect.attr({
          x: 0,
          y: 0,
          width: overrideOpts.width || (isVertical ? dims.width1 : dims.widths[index]),
          height: finalHeight
        });
        var tHeight = menuOpts.font.size * LINE_SPACING;
        var tLines = svgTextUtils.lineCount(text);
        var spanOffset = (tLines - 1) * tHeight / 2;
        svgTextUtils.positionText(
          text,
          constants.textOffsetX,
          finalHeight / 2 - spanOffset + constants.textOffsetY
        );
        if (isVertical) {
          posOpts.y += dims.heights[index] + posOpts.yPad;
        } else {
          posOpts.x += dims.widths[index] + posOpts.xPad;
        }
        posOpts.index++;
      }
      function removeAllButtons(gButton, newMenuIndexAttr) {
        gButton.attr(constants.menuIndexAttrName, newMenuIndexAttr || "-1").selectAll("g." + constants.dropdownButtonClassName).remove();
      }
    }
  });

  // src/components/updatemenus/index.js
  var require_updatemenus = __commonJS({
    "src/components/updatemenus/index.js"(exports, module) {
      "use strict";
      var constants = require_constants9();
      module.exports = {
        moduleType: "component",
        name: constants.name,
        layoutAttributes: require_attributes18(),
        supplyLayoutDefaults: require_defaults14(),
        draw: require_draw7()
      };
    }
  });

  // src/components/sliders/constants.js
  var require_constants10 = __commonJS({
    "src/components/sliders/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // layout attribute name
        name: "sliders",
        // class names
        containerClassName: "slider-container",
        groupClassName: "slider-group",
        inputAreaClass: "slider-input-area",
        railRectClass: "slider-rail-rect",
        railTouchRectClass: "slider-rail-touch-rect",
        gripRectClass: "slider-grip-rect",
        tickRectClass: "slider-tick-rect",
        inputProxyClass: "slider-input-proxy",
        labelsClass: "slider-labels",
        labelGroupClass: "slider-label-group",
        labelClass: "slider-label",
        currentValueClass: "slider-current-value",
        railHeight: 5,
        // DOM attribute name in button group keeping track
        // of active update menu
        menuIndexAttrName: "slider-active-index",
        // id root pass to Plots.autoMargin
        autoMarginIdRoot: "slider-",
        // min item width / height
        minWidth: 30,
        minHeight: 30,
        // padding around item text
        textPadX: 40,
        // arrow offset off right edge
        arrowOffsetX: 4,
        railRadius: 2,
        railWidth: 5,
        railBorder: 4,
        railBorderWidth: 1,
        railBorderColor: "#bec8d9",
        railBgColor: "#f8fafc",
        // The distance of the rail from the edge of the touchable area
        // Slightly less than the step inset because of the curved edges
        // of the rail
        railInset: 8,
        // The distance from the extremal tick marks to the edge of the
        // touchable area. This is basically the same as the grip radius,
        // but for other styles it wouldn't really need to be.
        stepInset: 10,
        gripRadius: 10,
        gripWidth: 20,
        gripHeight: 20,
        gripBorder: 20,
        gripBorderWidth: 1,
        gripBorderColor: "#bec8d9",
        gripBgColor: "#f6f8fa",
        gripBgActiveColor: "#dbdde0",
        labelPadding: 8,
        labelOffset: 0,
        tickWidth: 1,
        tickColor: "#333",
        tickOffset: 25,
        tickLength: 7,
        minorTickOffset: 25,
        minorTickColor: "#333",
        minorTickLength: 4,
        // Extra space below the current value label:
        currentValuePadding: 8,
        currentValueInset: 0
      };
    }
  });

  // src/components/sliders/attributes.js
  var require_attributes19 = __commonJS({
    "src/components/sliders/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var padAttrs = require_pad_attributes();
      var extendDeepAll = require_extend().extendDeepAll;
      var overrideAll = require_edit_types().overrideAll;
      var animationAttrs = require_animation_attributes();
      var templatedArray = require_plot_template().templatedArray;
      var constants = require_constants10();
      var stepsAttrs = templatedArray("step", {
        visible: {
          valType: "boolean",
          dflt: true
        },
        method: {
          valType: "enumerated",
          values: ["restyle", "relayout", "animate", "update", "skip"],
          dflt: "restyle"
        },
        args: {
          valType: "info_array",
          freeLength: true,
          items: [
            { valType: "any" },
            { valType: "any" },
            { valType: "any" }
          ]
        },
        label: {
          valType: "string"
        },
        value: {
          valType: "string"
        },
        execute: {
          valType: "boolean",
          dflt: true
        }
      });
      module.exports = overrideAll(templatedArray("slider", {
        visible: {
          valType: "boolean",
          dflt: true
        },
        active: {
          valType: "number",
          min: 0,
          dflt: 0
        },
        steps: stepsAttrs,
        lenmode: {
          valType: "enumerated",
          values: ["fraction", "pixels"],
          dflt: "fraction"
        },
        len: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        x: {
          valType: "number",
          min: -2,
          max: 3,
          dflt: 0
        },
        pad: extendDeepAll(padAttrs({ editType: "arraydraw" }), {}, { t: { dflt: 20 } }),
        xanchor: {
          valType: "enumerated",
          values: ["auto", "left", "center", "right"],
          dflt: "left"
        },
        y: {
          valType: "number",
          min: -2,
          max: 3,
          dflt: 0
        },
        yanchor: {
          valType: "enumerated",
          values: ["auto", "top", "middle", "bottom"],
          dflt: "top"
        },
        transition: {
          duration: {
            valType: "number",
            min: 0,
            dflt: 150
          },
          easing: {
            valType: "enumerated",
            values: animationAttrs.transition.easing.values,
            dflt: "cubic-in-out"
          }
        },
        currentvalue: {
          visible: {
            valType: "boolean",
            dflt: true
          },
          xanchor: {
            valType: "enumerated",
            values: ["left", "center", "right"],
            dflt: "left"
          },
          offset: {
            valType: "number",
            dflt: 10
          },
          prefix: {
            valType: "string"
          },
          suffix: {
            valType: "string"
          },
          font: fontAttrs({})
        },
        font: fontAttrs({}),
        activebgcolor: {
          valType: "color",
          dflt: constants.gripBgActiveColor
        },
        bgcolor: {
          valType: "color",
          dflt: constants.railBgColor
        },
        bordercolor: {
          valType: "color",
          dflt: constants.railBorderColor
        },
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: constants.railBorderWidth
        },
        ticklen: {
          valType: "number",
          min: 0,
          dflt: constants.tickLength
        },
        tickcolor: {
          valType: "color",
          dflt: constants.tickColor
        },
        tickwidth: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        minorticklen: {
          valType: "number",
          min: 0,
          dflt: constants.minorTickLength
        }
      }), "arraydraw", "from-root");
    }
  });

  // src/components/sliders/defaults.js
  var require_defaults15 = __commonJS({
    "src/components/sliders/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes19();
      var constants = require_constants10();
      var name = constants.name;
      var stepAttrs = attributes.steps;
      module.exports = function slidersDefaults(layoutIn, layoutOut) {
        handleArrayContainerDefaults(layoutIn, layoutOut, {
          name,
          handleItemDefaults: sliderDefaults
        });
      };
      function sliderDefaults(sliderIn, sliderOut, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(sliderIn, sliderOut, attributes, attr, dflt);
        }
        var steps = handleArrayContainerDefaults(sliderIn, sliderOut, {
          name: "steps",
          handleItemDefaults: stepDefaults
        });
        var stepCount = 0;
        for (var i = 0; i < steps.length; i++) {
          if (steps[i].visible) stepCount++;
        }
        var visible;
        if (stepCount < 2) visible = sliderOut.visible = false;
        else visible = coerce("visible");
        if (!visible) return;
        sliderOut._stepCount = stepCount;
        var visSteps = sliderOut._visibleSteps = Lib.filterVisible(steps);
        var active = coerce("active");
        if (!(steps[active] || {}).visible) sliderOut.active = visSteps[0]._index;
        coerce("x");
        coerce("y");
        Lib.noneOrAll(sliderIn, sliderOut, ["x", "y"]);
        coerce("xanchor");
        coerce("yanchor");
        coerce("len");
        coerce("lenmode");
        coerce("pad.t");
        coerce("pad.r");
        coerce("pad.b");
        coerce("pad.l");
        Lib.coerceFont(coerce, "font", layoutOut.font);
        var currentValueIsVisible = coerce("currentvalue.visible");
        if (currentValueIsVisible) {
          coerce("currentvalue.xanchor");
          coerce("currentvalue.prefix");
          coerce("currentvalue.suffix");
          coerce("currentvalue.offset");
          Lib.coerceFont(coerce, "currentvalue.font", sliderOut.font);
        }
        coerce("transition.duration");
        coerce("transition.easing");
        coerce("bgcolor");
        coerce("activebgcolor");
        coerce("bordercolor");
        coerce("borderwidth");
        coerce("ticklen");
        coerce("tickwidth");
        coerce("tickcolor");
        coerce("minorticklen");
      }
      function stepDefaults(valueIn, valueOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(valueIn, valueOut, stepAttrs, attr, dflt);
        }
        var visible;
        if (valueIn.method !== "skip" && !Array.isArray(valueIn.args)) {
          visible = valueOut.visible = false;
        } else visible = coerce("visible");
        if (visible) {
          coerce("method");
          coerce("args");
          var label = coerce("label", "step-" + valueOut._index);
          coerce("value", label);
          coerce("execute");
        }
      }
    }
  });

  // src/components/sliders/draw.js
  var require_draw8 = __commonJS({
    "src/components/sliders/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Plots = require_plots();
      var Color = require_color();
      var Drawing = require_drawing();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var svgTextUtils = require_svg_text_utils();
      var arrayEditor = require_plot_template().arrayEditor;
      var constants = require_constants10();
      var alignmentConstants = require_alignment();
      var LINE_SPACING = alignmentConstants.LINE_SPACING;
      var FROM_TL = alignmentConstants.FROM_TL;
      var FROM_BR = alignmentConstants.FROM_BR;
      module.exports = function draw(gd) {
        var staticPlot = gd._context.staticPlot;
        var fullLayout = gd._fullLayout;
        var sliderData = makeSliderData(fullLayout, gd);
        var sliders = fullLayout._infolayer.selectAll("g." + constants.containerClassName).data(sliderData.length > 0 ? [0] : []);
        sliders.enter().append("g").classed(constants.containerClassName, true).style("cursor", staticPlot ? null : "ew-resize");
        function clearSlider(sliderOpts2) {
          if (sliderOpts2._commandObserver) {
            sliderOpts2._commandObserver.remove();
            delete sliderOpts2._commandObserver;
          }
          Plots.autoMargin(gd, autoMarginId(sliderOpts2));
        }
        sliders.exit().each(function() {
          d3.select(this).selectAll("g." + constants.groupClassName).each(clearSlider);
        }).remove();
        if (sliderData.length === 0) return;
        var sliderGroups = sliders.selectAll("g." + constants.groupClassName).data(sliderData, keyFunction);
        sliderGroups.enter().append("g").classed(constants.groupClassName, true);
        sliderGroups.exit().each(clearSlider).remove();
        for (var i = 0; i < sliderData.length; i++) {
          var sliderOpts = sliderData[i];
          findDimensions(gd, sliderOpts);
        }
        sliderGroups.each(function(sliderOpts2) {
          var gSlider = d3.select(this);
          computeLabelSteps(sliderOpts2);
          Plots.manageCommandObserver(gd, sliderOpts2, sliderOpts2._visibleSteps, function(data) {
            var opts = gSlider.data()[0];
            if (opts.active === data.index) return;
            if (opts._dragging) return;
            setActive(gd, gSlider, opts, data.index, false, true);
          });
          drawSlider(gd, d3.select(this), sliderOpts2);
        });
      };
      function autoMarginId(sliderOpts) {
        return constants.autoMarginIdRoot + sliderOpts._index;
      }
      function makeSliderData(fullLayout, gd) {
        var contOpts = fullLayout[constants.name];
        var sliderData = [];
        for (var i = 0; i < contOpts.length; i++) {
          var item = contOpts[i];
          if (!item.visible) continue;
          item._gd = gd;
          sliderData.push(item);
        }
        return sliderData;
      }
      function keyFunction(opts) {
        return opts._index;
      }
      function findDimensions(gd, sliderOpts) {
        var sliderLabels = Drawing.tester.selectAll("g." + constants.labelGroupClass).data(sliderOpts._visibleSteps);
        sliderLabels.enter().append("g").classed(constants.labelGroupClass, true);
        var maxLabelWidth = 0;
        var labelHeight = 0;
        sliderLabels.each(function(stepOpts) {
          var labelGroup = d3.select(this);
          var text = drawLabel(labelGroup, { step: stepOpts }, sliderOpts);
          var textNode = text.node();
          if (textNode) {
            var bBox = Drawing.bBox(textNode);
            labelHeight = Math.max(labelHeight, bBox.height);
            maxLabelWidth = Math.max(maxLabelWidth, bBox.width);
          }
        });
        sliderLabels.remove();
        var dims = sliderOpts._dims = {};
        dims.inputAreaWidth = Math.max(
          constants.railWidth,
          constants.gripHeight
        );
        var graphSize = gd._fullLayout._size;
        dims.lx = graphSize.l + graphSize.w * sliderOpts.x;
        dims.ly = graphSize.t + graphSize.h * (1 - sliderOpts.y);
        if (sliderOpts.lenmode === "fraction") {
          dims.outerLength = Math.round(graphSize.w * sliderOpts.len);
        } else {
          dims.outerLength = sliderOpts.len;
        }
        dims.inputAreaStart = 0;
        dims.inputAreaLength = Math.round(dims.outerLength - sliderOpts.pad.l - sliderOpts.pad.r);
        var textableInputLength = dims.inputAreaLength - 2 * constants.stepInset;
        var availableSpacePerLabel = textableInputLength / (sliderOpts._stepCount - 1);
        var computedSpacePerLabel = maxLabelWidth + constants.labelPadding;
        dims.labelStride = Math.max(1, Math.ceil(computedSpacePerLabel / availableSpacePerLabel));
        dims.labelHeight = labelHeight;
        dims.currentValueMaxWidth = 0;
        dims.currentValueHeight = 0;
        dims.currentValueTotalHeight = 0;
        dims.currentValueMaxLines = 1;
        if (sliderOpts.currentvalue.visible) {
          var dummyGroup = Drawing.tester.append("g");
          sliderLabels.each(function(stepOpts) {
            var curValPrefix = drawCurrentValue(dummyGroup, sliderOpts, stepOpts.label);
            var curValSize = curValPrefix.node() && Drawing.bBox(curValPrefix.node()) || { width: 0, height: 0 };
            var lines = svgTextUtils.lineCount(curValPrefix);
            dims.currentValueMaxWidth = Math.max(dims.currentValueMaxWidth, Math.ceil(curValSize.width));
            dims.currentValueHeight = Math.max(dims.currentValueHeight, Math.ceil(curValSize.height));
            dims.currentValueMaxLines = Math.max(dims.currentValueMaxLines, lines);
          });
          dims.currentValueTotalHeight = dims.currentValueHeight + sliderOpts.currentvalue.offset;
          dummyGroup.remove();
        }
        dims.height = dims.currentValueTotalHeight + constants.tickOffset + sliderOpts.ticklen + constants.labelOffset + dims.labelHeight + sliderOpts.pad.t + sliderOpts.pad.b;
        var xanchor = "left";
        if (Lib.isRightAnchor(sliderOpts)) {
          dims.lx -= dims.outerLength;
          xanchor = "right";
        }
        if (Lib.isCenterAnchor(sliderOpts)) {
          dims.lx -= dims.outerLength / 2;
          xanchor = "center";
        }
        var yanchor = "top";
        if (Lib.isBottomAnchor(sliderOpts)) {
          dims.ly -= dims.height;
          yanchor = "bottom";
        }
        if (Lib.isMiddleAnchor(sliderOpts)) {
          dims.ly -= dims.height / 2;
          yanchor = "middle";
        }
        dims.outerLength = Math.ceil(dims.outerLength);
        dims.height = Math.ceil(dims.height);
        dims.lx = Math.round(dims.lx);
        dims.ly = Math.round(dims.ly);
        var marginOpts = {
          y: sliderOpts.y,
          b: dims.height * FROM_BR[yanchor],
          t: dims.height * FROM_TL[yanchor]
        };
        if (sliderOpts.lenmode === "fraction") {
          marginOpts.l = 0;
          marginOpts.xl = sliderOpts.x - sliderOpts.len * FROM_TL[xanchor];
          marginOpts.r = 0;
          marginOpts.xr = sliderOpts.x + sliderOpts.len * FROM_BR[xanchor];
        } else {
          marginOpts.x = sliderOpts.x;
          marginOpts.l = dims.outerLength * FROM_TL[xanchor];
          marginOpts.r = dims.outerLength * FROM_BR[xanchor];
        }
        Plots.autoMargin(gd, autoMarginId(sliderOpts), marginOpts);
      }
      function drawSlider(gd, sliderGroup, sliderOpts) {
        if (!(sliderOpts.steps[sliderOpts.active] || {}).visible) {
          sliderOpts.active = sliderOpts._visibleSteps[0]._index;
        }
        sliderGroup.call(drawCurrentValue, sliderOpts).call(drawRail, sliderOpts).call(drawLabelGroup, sliderOpts).call(drawTicks, sliderOpts).call(drawTouchRect, gd, sliderOpts).call(drawGrip, gd, sliderOpts);
        var dims = sliderOpts._dims;
        Drawing.setTranslate(sliderGroup, dims.lx + sliderOpts.pad.l, dims.ly + sliderOpts.pad.t);
        sliderGroup.call(setGripPosition, sliderOpts, false);
        sliderGroup.call(drawCurrentValue, sliderOpts);
      }
      function drawCurrentValue(sliderGroup, sliderOpts, valueOverride) {
        if (!sliderOpts.currentvalue.visible) return;
        var dims = sliderOpts._dims;
        var x0, textAnchor;
        switch (sliderOpts.currentvalue.xanchor) {
          case "right":
            x0 = dims.inputAreaLength - constants.currentValueInset - dims.currentValueMaxWidth;
            textAnchor = "left";
            break;
          case "center":
            x0 = dims.inputAreaLength * 0.5;
            textAnchor = "middle";
            break;
          default:
            x0 = constants.currentValueInset;
            textAnchor = "left";
        }
        var text = Lib.ensureSingle(sliderGroup, "text", constants.labelClass, function(s) {
          s.attr({
            "text-anchor": textAnchor,
            "data-notex": 1
          });
        });
        var str = sliderOpts.currentvalue.prefix ? sliderOpts.currentvalue.prefix : "";
        if (typeof valueOverride === "string") {
          str += valueOverride;
        } else {
          var curVal = sliderOpts.steps[sliderOpts.active].label;
          var _meta = sliderOpts._gd._fullLayout._meta;
          if (_meta) curVal = Lib.templateString(curVal, _meta);
          str += curVal;
        }
        if (sliderOpts.currentvalue.suffix) {
          str += sliderOpts.currentvalue.suffix;
        }
        text.call(Drawing.font, sliderOpts.currentvalue.font).text(str).call(svgTextUtils.convertToTspans, sliderOpts._gd);
        var lines = svgTextUtils.lineCount(text);
        var y0 = (dims.currentValueMaxLines + 1 - lines) * sliderOpts.currentvalue.font.size * LINE_SPACING;
        svgTextUtils.positionText(text, x0, y0);
        return text;
      }
      function drawGrip(sliderGroup, gd, sliderOpts) {
        var grip = Lib.ensureSingle(sliderGroup, "rect", constants.gripRectClass, function(s) {
          s.call(attachGripEvents, gd, sliderGroup, sliderOpts).style("pointer-events", "all");
        });
        grip.attr({
          width: constants.gripWidth,
          height: constants.gripHeight,
          rx: constants.gripRadius,
          ry: constants.gripRadius
        }).call(Color.stroke, sliderOpts.bordercolor).call(Color.fill, sliderOpts.bgcolor).style("stroke-width", sliderOpts.borderwidth + "px");
      }
      function drawLabel(item, data, sliderOpts) {
        var text = Lib.ensureSingle(item, "text", constants.labelClass, function(s) {
          s.attr({
            "text-anchor": "middle",
            "data-notex": 1
          });
        });
        var tx = data.step.label;
        var _meta = sliderOpts._gd._fullLayout._meta;
        if (_meta) tx = Lib.templateString(tx, _meta);
        text.call(Drawing.font, sliderOpts.font).text(tx).call(svgTextUtils.convertToTspans, sliderOpts._gd);
        return text;
      }
      function drawLabelGroup(sliderGroup, sliderOpts) {
        var labels = Lib.ensureSingle(sliderGroup, "g", constants.labelsClass);
        var dims = sliderOpts._dims;
        var labelItems = labels.selectAll("g." + constants.labelGroupClass).data(dims.labelSteps);
        labelItems.enter().append("g").classed(constants.labelGroupClass, true);
        labelItems.exit().remove();
        labelItems.each(function(d) {
          var item = d3.select(this);
          item.call(drawLabel, d, sliderOpts);
          Drawing.setTranslate(
            item,
            normalizedValueToPosition(sliderOpts, d.fraction),
            constants.tickOffset + sliderOpts.ticklen + // position is the baseline of the top line of text only, even
            // if the label spans multiple lines
            sliderOpts.font.size * LINE_SPACING + constants.labelOffset + dims.currentValueTotalHeight
          );
        });
      }
      function handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, doTransition) {
        var quantizedPosition = Math.round(normalizedPosition * (sliderOpts._stepCount - 1));
        var quantizedIndex = sliderOpts._visibleSteps[quantizedPosition]._index;
        if (quantizedIndex !== sliderOpts.active) {
          setActive(gd, sliderGroup, sliderOpts, quantizedIndex, true, doTransition);
        }
      }
      function setActive(gd, sliderGroup, sliderOpts, index, doCallback, doTransition) {
        var previousActive = sliderOpts.active;
        sliderOpts.active = index;
        arrayEditor(gd.layout, constants.name, sliderOpts).applyUpdate("active", index);
        var step = sliderOpts.steps[sliderOpts.active];
        sliderGroup.call(setGripPosition, sliderOpts, doTransition);
        sliderGroup.call(drawCurrentValue, sliderOpts);
        gd.emit("plotly_sliderchange", {
          slider: sliderOpts,
          step: sliderOpts.steps[sliderOpts.active],
          interaction: doCallback,
          previousActive
        });
        if (step && step.method && doCallback) {
          if (sliderGroup._nextMethod) {
            sliderGroup._nextMethod.step = step;
            sliderGroup._nextMethod.doCallback = doCallback;
            sliderGroup._nextMethod.doTransition = doTransition;
          } else {
            sliderGroup._nextMethod = { step, doCallback, doTransition };
            sliderGroup._nextMethodRaf = window.requestAnimationFrame(function() {
              var _step = sliderGroup._nextMethod.step;
              if (!_step.method) return;
              if (_step.execute) {
                Plots.executeAPICommand(gd, _step.method, _step.args);
              }
              sliderGroup._nextMethod = null;
              sliderGroup._nextMethodRaf = null;
            });
          }
        }
      }
      function attachGripEvents(item, gd, sliderGroup) {
        if (gd._context.staticPlot) return;
        var node = sliderGroup.node();
        var $gd = d3.select(gd);
        function getSliderOpts() {
          return sliderGroup.data()[0];
        }
        function mouseDownHandler() {
          var sliderOpts = getSliderOpts();
          gd.emit("plotly_sliderstart", { slider: sliderOpts });
          var grip = sliderGroup.select("." + constants.gripRectClass);
          d3.event.stopPropagation();
          d3.event.preventDefault();
          grip.call(Color.fill, sliderOpts.activebgcolor);
          var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);
          handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, true);
          sliderOpts._dragging = true;
          function mouseMoveHandler() {
            var sliderOpts2 = getSliderOpts();
            var normalizedPosition2 = positionToNormalizedValue(sliderOpts2, d3.mouse(node)[0]);
            handleInput(gd, sliderGroup, sliderOpts2, normalizedPosition2, false);
          }
          $gd.on("mousemove", mouseMoveHandler);
          $gd.on("touchmove", mouseMoveHandler);
          function mouseUpHandler() {
            var sliderOpts2 = getSliderOpts();
            sliderOpts2._dragging = false;
            grip.call(Color.fill, sliderOpts2.bgcolor);
            $gd.on("mouseup", null);
            $gd.on("mousemove", null);
            $gd.on("touchend", null);
            $gd.on("touchmove", null);
            gd.emit("plotly_sliderend", {
              slider: sliderOpts2,
              step: sliderOpts2.steps[sliderOpts2.active]
            });
          }
          $gd.on("mouseup", mouseUpHandler);
          $gd.on("touchend", mouseUpHandler);
        }
        item.on("mousedown", mouseDownHandler);
        item.on("touchstart", mouseDownHandler);
      }
      function drawTicks(sliderGroup, sliderOpts) {
        var tick = sliderGroup.selectAll("rect." + constants.tickRectClass).data(sliderOpts._visibleSteps);
        var dims = sliderOpts._dims;
        tick.enter().append("rect").classed(constants.tickRectClass, true);
        tick.exit().remove();
        tick.attr({
          width: sliderOpts.tickwidth + "px",
          "shape-rendering": "crispEdges"
        });
        tick.each(function(d, i) {
          var isMajor = i % dims.labelStride === 0;
          var item = d3.select(this);
          item.attr({ height: isMajor ? sliderOpts.ticklen : sliderOpts.minorticklen }).call(Color.fill, isMajor ? sliderOpts.tickcolor : sliderOpts.tickcolor);
          Drawing.setTranslate(
            item,
            normalizedValueToPosition(sliderOpts, i / (sliderOpts._stepCount - 1)) - 0.5 * sliderOpts.tickwidth,
            (isMajor ? constants.tickOffset : constants.minorTickOffset) + dims.currentValueTotalHeight
          );
        });
      }
      function computeLabelSteps(sliderOpts) {
        var dims = sliderOpts._dims;
        dims.labelSteps = [];
        var nsteps = sliderOpts._stepCount;
        for (var i = 0; i < nsteps; i += dims.labelStride) {
          dims.labelSteps.push({
            fraction: i / (nsteps - 1),
            step: sliderOpts._visibleSteps[i]
          });
        }
      }
      function setGripPosition(sliderGroup, sliderOpts, doTransition) {
        var grip = sliderGroup.select("rect." + constants.gripRectClass);
        var quantizedIndex = 0;
        for (var i = 0; i < sliderOpts._stepCount; i++) {
          if (sliderOpts._visibleSteps[i]._index === sliderOpts.active) {
            quantizedIndex = i;
            break;
          }
        }
        var x = normalizedValueToPosition(sliderOpts, quantizedIndex / (sliderOpts._stepCount - 1));
        if (sliderOpts._invokingCommand) return;
        var el = grip;
        if (doTransition && sliderOpts.transition.duration > 0) {
          el = el.transition().duration(sliderOpts.transition.duration).ease(sliderOpts.transition.easing);
        }
        el.attr("transform", strTranslate(x - constants.gripWidth * 0.5, sliderOpts._dims.currentValueTotalHeight));
      }
      function normalizedValueToPosition(sliderOpts, normalizedPosition) {
        var dims = sliderOpts._dims;
        return dims.inputAreaStart + constants.stepInset + (dims.inputAreaLength - 2 * constants.stepInset) * Math.min(1, Math.max(0, normalizedPosition));
      }
      function positionToNormalizedValue(sliderOpts, position) {
        var dims = sliderOpts._dims;
        return Math.min(1, Math.max(0, (position - constants.stepInset - dims.inputAreaStart) / (dims.inputAreaLength - 2 * constants.stepInset - 2 * dims.inputAreaStart)));
      }
      function drawTouchRect(sliderGroup, gd, sliderOpts) {
        var dims = sliderOpts._dims;
        var rect = Lib.ensureSingle(sliderGroup, "rect", constants.railTouchRectClass, function(s) {
          s.call(attachGripEvents, gd, sliderGroup, sliderOpts).style("pointer-events", "all");
        });
        rect.attr({
          width: dims.inputAreaLength,
          height: Math.max(dims.inputAreaWidth, constants.tickOffset + sliderOpts.ticklen + dims.labelHeight)
        }).call(Color.fill, sliderOpts.bgcolor).attr("opacity", 0);
        Drawing.setTranslate(rect, 0, dims.currentValueTotalHeight);
      }
      function drawRail(sliderGroup, sliderOpts) {
        var dims = sliderOpts._dims;
        var computedLength = dims.inputAreaLength - constants.railInset * 2;
        var rect = Lib.ensureSingle(sliderGroup, "rect", constants.railRectClass);
        rect.attr({
          width: computedLength,
          height: constants.railWidth,
          rx: constants.railRadius,
          ry: constants.railRadius,
          "shape-rendering": "crispEdges"
        }).call(Color.stroke, sliderOpts.bordercolor).call(Color.fill, sliderOpts.bgcolor).style("stroke-width", sliderOpts.borderwidth + "px");
        Drawing.setTranslate(
          rect,
          constants.railInset,
          (dims.inputAreaWidth - constants.railWidth) * 0.5 + dims.currentValueTotalHeight
        );
      }
    }
  });

  // src/components/sliders/index.js
  var require_sliders = __commonJS({
    "src/components/sliders/index.js"(exports, module) {
      "use strict";
      var constants = require_constants10();
      module.exports = {
        moduleType: "component",
        name: constants.name,
        layoutAttributes: require_attributes19(),
        supplyLayoutDefaults: require_defaults15(),
        draw: require_draw8()
      };
    }
  });

  // src/components/rangeslider/attributes.js
  var require_attributes20 = __commonJS({
    "src/components/rangeslider/attributes.js"(exports, module) {
      "use strict";
      var colorAttributes = require_attributes3();
      module.exports = {
        bgcolor: {
          valType: "color",
          dflt: colorAttributes.background,
          editType: "plot"
        },
        bordercolor: {
          valType: "color",
          dflt: colorAttributes.defaultLine,
          editType: "plot"
        },
        borderwidth: {
          valType: "integer",
          dflt: 0,
          min: 0,
          editType: "plot"
        },
        autorange: {
          valType: "boolean",
          dflt: true,
          editType: "calc",
          impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
        },
        range: {
          valType: "info_array",
          items: [
            { valType: "any", editType: "calc", impliedEdits: { "^autorange": false } },
            { valType: "any", editType: "calc", impliedEdits: { "^autorange": false } }
          ],
          editType: "calc",
          impliedEdits: { autorange: false }
        },
        thickness: {
          valType: "number",
          dflt: 0.15,
          min: 0,
          max: 1,
          editType: "plot"
        },
        visible: {
          valType: "boolean",
          dflt: true,
          editType: "calc"
        },
        editType: "calc"
      };
    }
  });

  // src/components/rangeslider/oppaxis_attributes.js
  var require_oppaxis_attributes = __commonJS({
    "src/components/rangeslider/oppaxis_attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        // not really a 'subplot' attribute container,
        // but this is the flag we use to denote attributes that
        // support yaxis, yaxis2, yaxis3, ... counters
        _isSubplotObj: true,
        rangemode: {
          valType: "enumerated",
          values: ["auto", "fixed", "match"],
          dflt: "match",
          editType: "calc"
        },
        range: {
          valType: "info_array",
          items: [
            { valType: "any", editType: "plot" },
            { valType: "any", editType: "plot" }
          ],
          editType: "plot"
        },
        editType: "calc"
      };
    }
  });

  // src/components/rangeslider/constants.js
  var require_constants11 = __commonJS({
    "src/components/rangeslider/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // attribute container name
        name: "rangeslider",
        // class names
        containerClassName: "rangeslider-container",
        bgClassName: "rangeslider-bg",
        rangePlotClassName: "rangeslider-rangeplot",
        maskMinClassName: "rangeslider-mask-min",
        maskMaxClassName: "rangeslider-mask-max",
        slideBoxClassName: "rangeslider-slidebox",
        grabberMinClassName: "rangeslider-grabber-min",
        grabAreaMinClassName: "rangeslider-grabarea-min",
        handleMinClassName: "rangeslider-handle-min",
        grabberMaxClassName: "rangeslider-grabber-max",
        grabAreaMaxClassName: "rangeslider-grabarea-max",
        handleMaxClassName: "rangeslider-handle-max",
        maskMinOppAxisClassName: "rangeslider-mask-min-opp-axis",
        maskMaxOppAxisClassName: "rangeslider-mask-max-opp-axis",
        // style constants
        maskColor: "rgba(0,0,0,0.4)",
        maskOppAxisColor: "rgba(0,0,0,0.2)",
        slideBoxFill: "transparent",
        slideBoxCursor: "ew-resize",
        grabAreaFill: "transparent",
        grabAreaCursor: "col-resize",
        grabAreaWidth: 10,
        handleWidth: 4,
        handleRadius: 1,
        handleStrokeWidth: 1,
        extraPad: 15
      };
    }
  });

  // src/components/rangeslider/helpers.js
  var require_helpers11 = __commonJS({
    "src/components/rangeslider/helpers.js"(exports) {
      "use strict";
      var axisIDs = require_axis_ids();
      var svgTextUtils = require_svg_text_utils();
      var constants = require_constants11();
      var LINE_SPACING = require_alignment().LINE_SPACING;
      var name = constants.name;
      function isVisible(ax) {
        var rangeSlider = ax && ax[name];
        return rangeSlider && rangeSlider.visible;
      }
      exports.isVisible = isVisible;
      exports.makeData = function(fullLayout) {
        var axes = axisIDs.list({ _fullLayout: fullLayout }, "x", true);
        var margin = fullLayout.margin;
        var rangeSliderData = [];
        for (var i = 0; i < axes.length; i++) {
          var ax = axes[i];
          if (isVisible(ax)) {
            rangeSliderData.push(ax);
            var opts = ax[name];
            opts._id = name + ax._id;
            opts._height = (fullLayout.height - margin.b - margin.t) * opts.thickness;
            opts._offsetShift = Math.floor(opts.borderwidth / 2);
          }
        }
        fullLayout._rangeSliderData = rangeSliderData;
      };
      exports.autoMarginOpts = function(gd, ax) {
        var fullLayout = gd._fullLayout;
        var opts = ax[name];
        var axLetter = ax._id.charAt(0);
        var bottomDepth = 0;
        var titleHeight = 0;
        if (ax.side === "bottom") {
          bottomDepth = ax._depth;
          if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {
            titleHeight = 1.5 * ax.title.font.size + 10 + opts._offsetShift;
            var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;
            titleHeight += extraLines * ax.title.font.size * LINE_SPACING;
          }
        }
        return {
          x: 0,
          y: ax._counterDomainMin,
          l: 0,
          r: 0,
          t: 0,
          b: opts._height + bottomDepth + Math.max(fullLayout.margin.b, titleHeight),
          pad: constants.extraPad + opts._offsetShift * 2
        };
      };
    }
  });

  // src/components/rangeslider/defaults.js
  var require_defaults16 = __commonJS({
    "src/components/rangeslider/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Template = require_plot_template();
      var axisIds = require_axis_ids();
      var attributes = require_attributes20();
      var oppAxisAttrs = require_oppaxis_attributes();
      module.exports = function handleDefaults(layoutIn, layoutOut, axName) {
        var axIn = layoutIn[axName];
        var axOut = layoutOut[axName];
        if (!(axIn.rangeslider || layoutOut._requestRangeslider[axOut._id])) return;
        if (!Lib.isPlainObject(axIn.rangeslider)) {
          axIn.rangeslider = {};
        }
        var containerIn = axIn.rangeslider;
        var containerOut = Template.newContainer(axOut, "rangeslider");
        function coerce(attr, dflt) {
          return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
        }
        var rangeContainerIn, rangeContainerOut;
        function coerceRange(attr, dflt) {
          return Lib.coerce(rangeContainerIn, rangeContainerOut, oppAxisAttrs, attr, dflt);
        }
        var visible = coerce("visible");
        if (!visible) return;
        coerce("bgcolor", layoutOut.plot_bgcolor);
        coerce("bordercolor");
        coerce("borderwidth");
        coerce("thickness");
        coerce("autorange", !axOut.isValidRange(containerIn.range));
        coerce("range");
        var subplots = layoutOut._subplots;
        if (subplots) {
          var yIds = subplots.cartesian.filter(function(subplotId) {
            return subplotId.substr(0, subplotId.indexOf("y")) === axisIds.name2id(axName);
          }).map(function(subplotId) {
            return subplotId.substr(subplotId.indexOf("y"), subplotId.length);
          });
          var yNames = Lib.simpleMap(yIds, axisIds.id2name);
          for (var i = 0; i < yNames.length; i++) {
            var yName = yNames[i];
            rangeContainerIn = containerIn[yName] || {};
            rangeContainerOut = Template.newContainer(containerOut, yName, "yaxis");
            var yAxOut = layoutOut[yName];
            var rangemodeDflt;
            if (rangeContainerIn.range && yAxOut.isValidRange(rangeContainerIn.range)) {
              rangemodeDflt = "fixed";
            }
            var rangeMode = coerceRange("rangemode", rangemodeDflt);
            if (rangeMode !== "match") {
              coerceRange("range", yAxOut.range.slice());
            }
          }
        }
        containerOut._input = containerIn;
      };
    }
  });

  // src/components/rangeslider/calc_autorange.js
  var require_calc_autorange3 = __commonJS({
    "src/components/rangeslider/calc_autorange.js"(exports, module) {
      "use strict";
      var listAxes = require_axis_ids().list;
      var getAutoRange = require_autorange().getAutoRange;
      var constants = require_constants11();
      module.exports = function calcAutorange(gd) {
        var axes = listAxes(gd, "x", true);
        for (var i = 0; i < axes.length; i++) {
          var ax = axes[i];
          var opts = ax[constants.name];
          if (opts && opts.visible && opts.autorange) {
            opts._input.autorange = true;
            opts._input.range = opts.range = getAutoRange(gd, ax);
          }
        }
      };
    }
  });

  // src/components/rangeslider/draw.js
  var require_draw9 = __commonJS({
    "src/components/rangeslider/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Plots = require_plots();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var Drawing = require_drawing();
      var Color = require_color();
      var Titles = require_titles();
      var Cartesian = require_cartesian();
      var axisIDs = require_axis_ids();
      var dragElement = require_dragelement();
      var setCursor = require_setcursor();
      var constants = require_constants11();
      module.exports = function(gd) {
        var fullLayout = gd._fullLayout;
        var rangeSliderData = fullLayout._rangeSliderData;
        for (var i = 0; i < rangeSliderData.length; i++) {
          var opts = rangeSliderData[i][constants.name];
          opts._clipId = opts._id + "-" + fullLayout._uid;
        }
        function keyFunction(axisOpts) {
          return axisOpts._name;
        }
        var rangeSliders = fullLayout._infolayer.selectAll("g." + constants.containerClassName).data(rangeSliderData, keyFunction);
        rangeSliders.exit().each(function(axisOpts) {
          var opts2 = axisOpts[constants.name];
          fullLayout._topdefs.select("#" + opts2._clipId).remove();
        }).remove();
        if (rangeSliderData.length === 0) return;
        rangeSliders.enter().append("g").classed(constants.containerClassName, true).attr("pointer-events", "all");
        rangeSliders.each(function(axisOpts) {
          var rangeSlider = d3.select(this);
          var opts2 = axisOpts[constants.name];
          var oppAxisOpts = fullLayout[axisIDs.id2name(axisOpts.anchor)];
          var oppAxisRangeOpts = opts2[axisIDs.id2name(axisOpts.anchor)];
          if (opts2.range) {
            var rng = Lib.simpleMap(opts2.range, axisOpts.r2l);
            var axRng = Lib.simpleMap(axisOpts.range, axisOpts.r2l);
            var newRng;
            if (axRng[0] < axRng[1]) {
              newRng = [
                Math.min(rng[0], axRng[0]),
                Math.max(rng[1], axRng[1])
              ];
            } else {
              newRng = [
                Math.max(rng[0], axRng[0]),
                Math.min(rng[1], axRng[1])
              ];
            }
            opts2.range = opts2._input.range = Lib.simpleMap(newRng, axisOpts.l2r);
          }
          axisOpts.cleanRange("rangeslider.range");
          var gs = fullLayout._size;
          var domain = axisOpts.domain;
          opts2._width = gs.w * (domain[1] - domain[0]);
          var x = Math.round(gs.l + gs.w * domain[0]);
          var y = Math.round(
            gs.t + gs.h * (1 - axisOpts._counterDomainMin) + (axisOpts.side === "bottom" ? axisOpts._depth : 0) + opts2._offsetShift + constants.extraPad
          );
          rangeSlider.attr("transform", strTranslate(x, y));
          opts2._rl = Lib.simpleMap(opts2.range, axisOpts.r2l);
          var rl0 = opts2._rl[0];
          var rl1 = opts2._rl[1];
          var drl = rl1 - rl0;
          opts2.p2d = function(v) {
            return v / opts2._width * drl + rl0;
          };
          opts2.d2p = function(v) {
            return (v - rl0) / drl * opts2._width;
          };
          if (axisOpts.rangebreaks) {
            var rsBreaks = axisOpts.locateBreaks(rl0, rl1);
            if (rsBreaks.length) {
              var j, brk;
              var lBreaks = 0;
              for (j = 0; j < rsBreaks.length; j++) {
                brk = rsBreaks[j];
                lBreaks += brk.max - brk.min;
              }
              var m2 = opts2._width / (rl1 - rl0 - lBreaks);
              var _B = [-m2 * rl0];
              for (j = 0; j < rsBreaks.length; j++) {
                brk = rsBreaks[j];
                _B.push(_B[_B.length - 1] - m2 * (brk.max - brk.min));
              }
              opts2.d2p = function(v) {
                var b = _B[0];
                for (var j2 = 0; j2 < rsBreaks.length; j2++) {
                  var brk2 = rsBreaks[j2];
                  if (v >= brk2.max) b = _B[j2 + 1];
                  else if (v < brk2.min) break;
                }
                return b + m2 * v;
              };
              for (j = 0; j < rsBreaks.length; j++) {
                brk = rsBreaks[j];
                brk.pmin = opts2.d2p(brk.min);
                brk.pmax = opts2.d2p(brk.max);
              }
              opts2.p2d = function(v) {
                var b = _B[0];
                for (var j2 = 0; j2 < rsBreaks.length; j2++) {
                  var brk2 = rsBreaks[j2];
                  if (v >= brk2.pmax) b = _B[j2 + 1];
                  else if (v < brk2.pmin) break;
                }
                return (v - b) / m2;
              };
            }
          }
          if (oppAxisRangeOpts.rangemode !== "match") {
            var range0OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[0]);
            var range1OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[1]);
            var distOppAxis = range1OppAxis - range0OppAxis;
            opts2.d2pOppAxis = function(v) {
              return (v - range0OppAxis) / distOppAxis * opts2._height;
            };
          }
          rangeSlider.call(drawBg, gd, axisOpts, opts2).call(addClipPath, gd, axisOpts, opts2).call(drawRangePlot, gd, axisOpts, opts2).call(drawMasks, gd, axisOpts, opts2, oppAxisRangeOpts).call(drawSlideBox, gd, axisOpts, opts2).call(drawGrabbers, gd, axisOpts, opts2);
          setupDragElement(rangeSlider, gd, axisOpts, opts2);
          setPixelRange(rangeSlider, gd, axisOpts, opts2, oppAxisOpts, oppAxisRangeOpts);
          if (axisOpts.side === "bottom") {
            Titles.draw(gd, axisOpts._id + "title", {
              propContainer: axisOpts,
              propName: axisOpts._name + ".title",
              placeholder: fullLayout._dfltTitle.x,
              attributes: {
                x: axisOpts._offset + axisOpts._length / 2,
                y: y + opts2._height + opts2._offsetShift + 10 + 1.5 * axisOpts.title.font.size,
                "text-anchor": "middle"
              }
            });
          }
        });
      };
      function eventX(event) {
        if (typeof event.clientX === "number") {
          return event.clientX;
        }
        if (event.touches && event.touches.length > 0) {
          return event.touches[0].clientX;
        }
        return 0;
      }
      function setupDragElement(rangeSlider, gd, axisOpts, opts) {
        if (gd._context.staticPlot) return;
        var slideBox = rangeSlider.select("rect." + constants.slideBoxClassName).node();
        var grabAreaMin = rangeSlider.select("rect." + constants.grabAreaMinClassName).node();
        var grabAreaMax = rangeSlider.select("rect." + constants.grabAreaMaxClassName).node();
        function mouseDownHandler() {
          var event = d3.event;
          var target = event.target;
          var startX = eventX(event);
          var offsetX = startX - rangeSlider.node().getBoundingClientRect().left;
          var minVal = opts.d2p(axisOpts._rl[0]);
          var maxVal = opts.d2p(axisOpts._rl[1]);
          var dragCover = dragElement.coverSlip();
          this.addEventListener("touchmove", mouseMove);
          this.addEventListener("touchend", mouseUp);
          dragCover.addEventListener("mousemove", mouseMove);
          dragCover.addEventListener("mouseup", mouseUp);
          function mouseMove(e) {
            var clientX = eventX(e);
            var delta = +clientX - startX;
            var pixelMin, pixelMax, cursor;
            switch (target) {
              case slideBox:
                cursor = "ew-resize";
                if (minVal + delta > axisOpts._length || maxVal + delta < 0) {
                  return;
                }
                pixelMin = minVal + delta;
                pixelMax = maxVal + delta;
                break;
              case grabAreaMin:
                cursor = "col-resize";
                if (minVal + delta > axisOpts._length) {
                  return;
                }
                pixelMin = minVal + delta;
                pixelMax = maxVal;
                break;
              case grabAreaMax:
                cursor = "col-resize";
                if (maxVal + delta < 0) {
                  return;
                }
                pixelMin = minVal;
                pixelMax = maxVal + delta;
                break;
              default:
                cursor = "ew-resize";
                pixelMin = offsetX;
                pixelMax = offsetX + delta;
                break;
            }
            if (pixelMax < pixelMin) {
              var tmp = pixelMax;
              pixelMax = pixelMin;
              pixelMin = tmp;
            }
            opts._pixelMin = pixelMin;
            opts._pixelMax = pixelMax;
            setCursor(d3.select(dragCover), cursor);
            setDataRange(rangeSlider, gd, axisOpts, opts);
          }
          function mouseUp() {
            dragCover.removeEventListener("mousemove", mouseMove);
            dragCover.removeEventListener("mouseup", mouseUp);
            this.removeEventListener("touchmove", mouseMove);
            this.removeEventListener("touchend", mouseUp);
            Lib.removeElement(dragCover);
          }
        }
        rangeSlider.on("mousedown", mouseDownHandler);
        rangeSlider.on("touchstart", mouseDownHandler);
      }
      function setDataRange(rangeSlider, gd, axisOpts, opts) {
        function clamp(v) {
          return axisOpts.l2r(Lib.constrain(v, opts._rl[0], opts._rl[1]));
        }
        var dataMin = clamp(opts.p2d(opts._pixelMin));
        var dataMax = clamp(opts.p2d(opts._pixelMax));
        window.requestAnimationFrame(function() {
          Registry.call("_guiRelayout", gd, axisOpts._name + ".range", [dataMin, dataMax]);
        });
      }
      function setPixelRange(rangeSlider, gd, axisOpts, opts, oppAxisOpts, oppAxisRangeOpts) {
        var hw2 = constants.handleWidth / 2;
        function clamp(v) {
          return Lib.constrain(v, 0, opts._width);
        }
        function clampOppAxis(v) {
          return Lib.constrain(v, 0, opts._height);
        }
        function clampHandle(v) {
          return Lib.constrain(v, -hw2, opts._width + hw2);
        }
        var pixelMin = clamp(opts.d2p(axisOpts._rl[0]));
        var pixelMax = clamp(opts.d2p(axisOpts._rl[1]));
        rangeSlider.select("rect." + constants.slideBoxClassName).attr("x", pixelMin).attr("width", pixelMax - pixelMin);
        rangeSlider.select("rect." + constants.maskMinClassName).attr("width", pixelMin);
        rangeSlider.select("rect." + constants.maskMaxClassName).attr("x", pixelMax).attr("width", opts._width - pixelMax);
        if (oppAxisRangeOpts.rangemode !== "match") {
          var pixelMinOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[1]));
          var pixelMaxOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[0]));
          rangeSlider.select("rect." + constants.maskMinOppAxisClassName).attr("x", pixelMin).attr("height", pixelMinOppAxis).attr("width", pixelMax - pixelMin);
          rangeSlider.select("rect." + constants.maskMaxOppAxisClassName).attr("x", pixelMin).attr("y", pixelMaxOppAxis).attr("height", opts._height - pixelMaxOppAxis).attr("width", pixelMax - pixelMin);
          rangeSlider.select("rect." + constants.slideBoxClassName).attr("y", pixelMinOppAxis).attr("height", pixelMaxOppAxis - pixelMinOppAxis);
        }
        var offset = 0.5;
        var xMin = Math.round(clampHandle(pixelMin - hw2)) - offset;
        var xMax = Math.round(clampHandle(pixelMax - hw2)) + offset;
        rangeSlider.select("g." + constants.grabberMinClassName).attr("transform", strTranslate(xMin, offset));
        rangeSlider.select("g." + constants.grabberMaxClassName).attr("transform", strTranslate(xMax, offset));
      }
      function drawBg(rangeSlider, gd, axisOpts, opts) {
        var bg = Lib.ensureSingle(rangeSlider, "rect", constants.bgClassName, function(s) {
          s.attr({
            x: 0,
            y: 0,
            "shape-rendering": "crispEdges"
          });
        });
        var borderCorrect = opts.borderwidth % 2 === 0 ? opts.borderwidth : opts.borderwidth - 1;
        var offsetShift = -opts._offsetShift;
        var lw = Drawing.crispRound(gd, opts.borderwidth);
        bg.attr({
          width: opts._width + borderCorrect,
          height: opts._height + borderCorrect,
          transform: strTranslate(offsetShift, offsetShift),
          "stroke-width": lw
        }).call(Color.stroke, opts.bordercolor).call(Color.fill, opts.bgcolor);
      }
      function addClipPath(rangeSlider, gd, axisOpts, opts) {
        var fullLayout = gd._fullLayout;
        var clipPath = Lib.ensureSingleById(fullLayout._topdefs, "clipPath", opts._clipId, function(s) {
          s.append("rect").attr({ x: 0, y: 0 });
        });
        clipPath.select("rect").attr({
          width: opts._width,
          height: opts._height
        });
      }
      function drawRangePlot(rangeSlider, gd, axisOpts, opts) {
        var calcData = gd.calcdata;
        var rangePlots = rangeSlider.selectAll("g." + constants.rangePlotClassName).data(axisOpts._subplotsWith, Lib.identity);
        rangePlots.enter().append("g").attr("class", function(id) {
          return constants.rangePlotClassName + " " + id;
        }).call(Drawing.setClipUrl, opts._clipId, gd);
        rangePlots.order();
        rangePlots.exit().remove();
        var mainplotinfo;
        rangePlots.each(function(id, i) {
          var plotgroup = d3.select(this);
          var isMainPlot = i === 0;
          var oppAxisOpts = axisIDs.getFromId(gd, id, "y");
          var oppAxisName = oppAxisOpts._name;
          var oppAxisRangeOpts = opts[oppAxisName];
          var mockFigure = {
            data: [],
            layout: {
              xaxis: {
                type: axisOpts.type,
                domain: [0, 1],
                range: opts.range.slice(),
                calendar: axisOpts.calendar
              },
              width: opts._width,
              height: opts._height,
              margin: { t: 0, b: 0, l: 0, r: 0 }
            },
            _context: gd._context
          };
          if (axisOpts.rangebreaks) {
            mockFigure.layout.xaxis.rangebreaks = axisOpts.rangebreaks;
          }
          mockFigure.layout[oppAxisName] = {
            type: oppAxisOpts.type,
            domain: [0, 1],
            range: oppAxisRangeOpts.rangemode !== "match" ? oppAxisRangeOpts.range.slice() : oppAxisOpts.range.slice(),
            calendar: oppAxisOpts.calendar
          };
          if (oppAxisOpts.rangebreaks) {
            mockFigure.layout[oppAxisName].rangebreaks = oppAxisOpts.rangebreaks;
          }
          Plots.supplyDefaults(mockFigure);
          var xa = mockFigure._fullLayout.xaxis;
          var ya = mockFigure._fullLayout[oppAxisName];
          xa.clearCalc();
          xa.setScale();
          ya.clearCalc();
          ya.setScale();
          var plotinfo = {
            id,
            plotgroup,
            xaxis: xa,
            yaxis: ya,
            isRangePlot: true
          };
          if (isMainPlot) mainplotinfo = plotinfo;
          else {
            plotinfo.mainplot = "xy";
            plotinfo.mainplotinfo = mainplotinfo;
          }
          Cartesian.rangePlot(gd, plotinfo, filterRangePlotCalcData(calcData, id));
        });
      }
      function filterRangePlotCalcData(calcData, subplotId) {
        var out = [];
        for (var i = 0; i < calcData.length; i++) {
          var calcTrace = calcData[i];
          var trace = calcTrace[0].trace;
          if (trace.xaxis + trace.yaxis === subplotId) {
            out.push(calcTrace);
          }
        }
        return out;
      }
      function drawMasks(rangeSlider, gd, axisOpts, opts, oppAxisRangeOpts) {
        var maskMin = Lib.ensureSingle(rangeSlider, "rect", constants.maskMinClassName, function(s) {
          s.attr({
            x: 0,
            y: 0,
            "shape-rendering": "crispEdges"
          });
        });
        maskMin.attr("height", opts._height).call(Color.fill, constants.maskColor);
        var maskMax = Lib.ensureSingle(rangeSlider, "rect", constants.maskMaxClassName, function(s) {
          s.attr({
            y: 0,
            "shape-rendering": "crispEdges"
          });
        });
        maskMax.attr("height", opts._height).call(Color.fill, constants.maskColor);
        if (oppAxisRangeOpts.rangemode !== "match") {
          var maskMinOppAxis = Lib.ensureSingle(rangeSlider, "rect", constants.maskMinOppAxisClassName, function(s) {
            s.attr({
              y: 0,
              "shape-rendering": "crispEdges"
            });
          });
          maskMinOppAxis.attr("width", opts._width).call(Color.fill, constants.maskOppAxisColor);
          var maskMaxOppAxis = Lib.ensureSingle(rangeSlider, "rect", constants.maskMaxOppAxisClassName, function(s) {
            s.attr({
              y: 0,
              "shape-rendering": "crispEdges"
            });
          });
          maskMaxOppAxis.attr("width", opts._width).style("border-top", constants.maskOppBorder).call(Color.fill, constants.maskOppAxisColor);
        }
      }
      function drawSlideBox(rangeSlider, gd, axisOpts, opts) {
        if (gd._context.staticPlot) return;
        var slideBox = Lib.ensureSingle(rangeSlider, "rect", constants.slideBoxClassName, function(s) {
          s.attr({
            y: 0,
            cursor: constants.slideBoxCursor,
            "shape-rendering": "crispEdges"
          });
        });
        slideBox.attr({
          height: opts._height,
          fill: constants.slideBoxFill
        });
      }
      function drawGrabbers(rangeSlider, gd, axisOpts, opts) {
        var grabberMin = Lib.ensureSingle(rangeSlider, "g", constants.grabberMinClassName);
        var grabberMax = Lib.ensureSingle(rangeSlider, "g", constants.grabberMaxClassName);
        var handleFixAttrs = {
          x: 0,
          width: constants.handleWidth,
          rx: constants.handleRadius,
          fill: Color.background,
          stroke: Color.defaultLine,
          "stroke-width": constants.handleStrokeWidth,
          "shape-rendering": "crispEdges"
        };
        var handleDynamicAttrs = {
          y: Math.round(opts._height / 4),
          height: Math.round(opts._height / 2)
        };
        var handleMin = Lib.ensureSingle(grabberMin, "rect", constants.handleMinClassName, function(s) {
          s.attr(handleFixAttrs);
        });
        handleMin.attr(handleDynamicAttrs);
        var handleMax = Lib.ensureSingle(grabberMax, "rect", constants.handleMaxClassName, function(s) {
          s.attr(handleFixAttrs);
        });
        handleMax.attr(handleDynamicAttrs);
        var grabAreaFixAttrs = {
          width: constants.grabAreaWidth,
          x: 0,
          y: 0,
          fill: constants.grabAreaFill,
          cursor: !gd._context.staticPlot ? constants.grabAreaCursor : void 0
        };
        var grabAreaMin = Lib.ensureSingle(grabberMin, "rect", constants.grabAreaMinClassName, function(s) {
          s.attr(grabAreaFixAttrs);
        });
        grabAreaMin.attr("height", opts._height);
        var grabAreaMax = Lib.ensureSingle(grabberMax, "rect", constants.grabAreaMaxClassName, function(s) {
          s.attr(grabAreaFixAttrs);
        });
        grabAreaMax.attr("height", opts._height);
      }
    }
  });

  // src/components/rangeslider/index.js
  var require_rangeslider = __commonJS({
    "src/components/rangeslider/index.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var attrs = require_attributes20();
      var oppAxisAttrs = require_oppaxis_attributes();
      var helpers = require_helpers11();
      module.exports = {
        moduleType: "component",
        name: "rangeslider",
        schema: {
          subplots: {
            xaxis: {
              rangeslider: Lib.extendFlat({}, attrs, {
                yaxis: oppAxisAttrs
              })
            }
          }
        },
        layoutAttributes: require_attributes20(),
        handleDefaults: require_defaults16(),
        calcAutorange: require_calc_autorange3(),
        draw: require_draw9(),
        isVisible: helpers.isVisible,
        makeData: helpers.makeData,
        autoMarginOpts: helpers.autoMarginOpts
      };
    }
  });

  // src/components/rangeselector/attributes.js
  var require_attributes21 = __commonJS({
    "src/components/rangeselector/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var colorAttrs = require_attributes3();
      var templatedArray = require_plot_template().templatedArray;
      var buttonAttrs = templatedArray("button", {
        visible: {
          valType: "boolean",
          dflt: true,
          editType: "plot"
        },
        step: {
          valType: "enumerated",
          values: ["month", "year", "day", "hour", "minute", "second", "all"],
          dflt: "month",
          editType: "plot"
        },
        stepmode: {
          valType: "enumerated",
          values: ["backward", "todate"],
          dflt: "backward",
          editType: "plot"
        },
        count: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "plot"
        },
        label: {
          valType: "string",
          editType: "plot"
        },
        editType: "plot"
      });
      module.exports = {
        visible: {
          valType: "boolean",
          editType: "plot"
        },
        buttons: buttonAttrs,
        x: {
          valType: "number",
          min: -2,
          max: 3,
          editType: "plot"
        },
        xanchor: {
          valType: "enumerated",
          values: ["auto", "left", "center", "right"],
          dflt: "left",
          editType: "plot"
        },
        y: {
          valType: "number",
          min: -2,
          max: 3,
          editType: "plot"
        },
        yanchor: {
          valType: "enumerated",
          values: ["auto", "top", "middle", "bottom"],
          dflt: "bottom",
          editType: "plot"
        },
        font: fontAttrs({
          editType: "plot"
        }),
        bgcolor: {
          valType: "color",
          dflt: colorAttrs.lightLine,
          editType: "plot"
        },
        activecolor: {
          valType: "color",
          editType: "plot"
        },
        bordercolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "plot"
        },
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: 0,
          editType: "plot"
        },
        editType: "plot"
      };
    }
  });

  // src/components/rangeselector/constants.js
  var require_constants12 = __commonJS({
    "src/components/rangeselector/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // 'y' position pad above counter axis domain
        yPad: 0.02,
        // minimum button width (regardless of text size)
        minButtonWidth: 30,
        // buttons rect radii
        rx: 3,
        ry: 3,
        // light fraction used to compute the 'activecolor' default
        lightAmount: 25,
        darkAmount: 10
      };
    }
  });

  // src/components/rangeselector/defaults.js
  var require_defaults17 = __commonJS({
    "src/components/rangeselector/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Color = require_color();
      var Template = require_plot_template();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes21();
      var constants = require_constants12();
      module.exports = function handleDefaults(containerIn, containerOut, layout, counterAxes, calendar) {
        var selectorIn = containerIn.rangeselector || {};
        var selectorOut = Template.newContainer(containerOut, "rangeselector");
        function coerce(attr, dflt) {
          return Lib.coerce(selectorIn, selectorOut, attributes, attr, dflt);
        }
        var buttons = handleArrayContainerDefaults(selectorIn, selectorOut, {
          name: "buttons",
          handleItemDefaults: buttonDefaults,
          calendar
        });
        var visible = coerce("visible", buttons.length > 0);
        if (visible) {
          var posDflt = getPosDflt(containerOut, layout, counterAxes);
          coerce("x", posDflt[0]);
          coerce("y", posDflt[1]);
          Lib.noneOrAll(containerIn, containerOut, ["x", "y"]);
          coerce("xanchor");
          coerce("yanchor");
          Lib.coerceFont(coerce, "font", layout.font);
          var bgColor = coerce("bgcolor");
          coerce("activecolor", Color.contrast(bgColor, constants.lightAmount, constants.darkAmount));
          coerce("bordercolor");
          coerce("borderwidth");
        }
      };
      function buttonDefaults(buttonIn, buttonOut, selectorOut, opts) {
        var calendar = opts.calendar;
        function coerce(attr, dflt) {
          return Lib.coerce(buttonIn, buttonOut, attributes.buttons, attr, dflt);
        }
        var visible = coerce("visible");
        if (visible) {
          var step = coerce("step");
          if (step !== "all") {
            if (calendar && calendar !== "gregorian" && (step === "month" || step === "year")) {
              buttonOut.stepmode = "backward";
            } else {
              coerce("stepmode");
            }
            coerce("count");
          }
          coerce("label");
        }
      }
      function getPosDflt(containerOut, layout, counterAxes) {
        var anchoredList = counterAxes.filter(function(ax) {
          return layout[ax].anchor === containerOut._id;
        });
        var posY = 0;
        for (var i = 0; i < anchoredList.length; i++) {
          var domain = layout[anchoredList[i]].domain;
          if (domain) posY = Math.max(domain[1], posY);
        }
        return [containerOut.domain[0], posY + constants.yPad];
      }
    }
  });

  // src/components/rangeselector/get_update_object.js
  var require_get_update_object = __commonJS({
    "src/components/rangeselector/get_update_object.js"(exports, module) {
      "use strict";
      var d3Time = require_d3_time();
      var titleCase = require_lib().titleCase;
      module.exports = function getUpdateObject(axisLayout, buttonLayout) {
        var axName = axisLayout._name;
        var update = {};
        if (buttonLayout.step === "all") {
          update[axName + ".autorange"] = true;
        } else {
          var xrange = getXRange(axisLayout, buttonLayout);
          update[axName + ".range[0]"] = xrange[0];
          update[axName + ".range[1]"] = xrange[1];
        }
        return update;
      };
      function getXRange(axisLayout, buttonLayout) {
        var currentRange = axisLayout.range;
        var base = new Date(axisLayout.r2l(currentRange[1]));
        var step = buttonLayout.step;
        var utcStep = d3Time["utc" + titleCase(step)];
        var count = buttonLayout.count;
        var range0;
        switch (buttonLayout.stepmode) {
          case "backward":
            range0 = axisLayout.l2r(+utcStep.offset(base, -count));
            break;
          case "todate":
            var base2 = utcStep.offset(base, -count);
            range0 = axisLayout.l2r(+utcStep.ceil(base2));
            break;
        }
        var range1 = currentRange[1];
        return [range0, range1];
      }
    }
  });

  // src/components/rangeselector/draw.js
  var require_draw10 = __commonJS({
    "src/components/rangeselector/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Plots = require_plots();
      var Color = require_color();
      var Drawing = require_drawing();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var svgTextUtils = require_svg_text_utils();
      var axisIds = require_axis_ids();
      var alignmentConstants = require_alignment();
      var LINE_SPACING = alignmentConstants.LINE_SPACING;
      var FROM_TL = alignmentConstants.FROM_TL;
      var FROM_BR = alignmentConstants.FROM_BR;
      var constants = require_constants12();
      var getUpdateObject = require_get_update_object();
      module.exports = function draw(gd) {
        var fullLayout = gd._fullLayout;
        var selectors = fullLayout._infolayer.selectAll(".rangeselector").data(makeSelectorData(gd), selectorKeyFunc);
        selectors.enter().append("g").classed("rangeselector", true);
        selectors.exit().remove();
        selectors.style({
          cursor: "pointer",
          "pointer-events": "all"
        });
        selectors.each(function(d) {
          var selector = d3.select(this);
          var axisLayout = d;
          var selectorLayout = axisLayout.rangeselector;
          var buttons = selector.selectAll("g.button").data(Lib.filterVisible(selectorLayout.buttons));
          buttons.enter().append("g").classed("button", true);
          buttons.exit().remove();
          buttons.each(function(d2) {
            var button = d3.select(this);
            var update = getUpdateObject(axisLayout, d2);
            d2._isActive = isActive(axisLayout, d2, update);
            button.call(drawButtonRect, selectorLayout, d2);
            button.call(drawButtonText, selectorLayout, d2, gd);
            button.on("click", function() {
              if (gd._dragged) return;
              Registry.call("_guiRelayout", gd, update);
            });
            button.on("mouseover", function() {
              d2._isHovered = true;
              button.call(drawButtonRect, selectorLayout, d2);
            });
            button.on("mouseout", function() {
              d2._isHovered = false;
              button.call(drawButtonRect, selectorLayout, d2);
            });
          });
          reposition(gd, buttons, selectorLayout, axisLayout._name, selector);
        });
      };
      function makeSelectorData(gd) {
        var axes = axisIds.list(gd, "x", true);
        var data = [];
        for (var i = 0; i < axes.length; i++) {
          var axis = axes[i];
          if (axis.rangeselector && axis.rangeselector.visible) {
            data.push(axis);
          }
        }
        return data;
      }
      function selectorKeyFunc(d) {
        return d._id;
      }
      function isActive(axisLayout, opts, update) {
        if (opts.step === "all") {
          return axisLayout.autorange === true;
        } else {
          var keys = Object.keys(update);
          return axisLayout.range[0] === update[keys[0]] && axisLayout.range[1] === update[keys[1]];
        }
      }
      function drawButtonRect(button, selectorLayout, d) {
        var rect = Lib.ensureSingle(button, "rect", "selector-rect", function(s) {
          s.attr("shape-rendering", "crispEdges");
        });
        rect.attr({
          rx: constants.rx,
          ry: constants.ry
        });
        rect.call(Color.stroke, selectorLayout.bordercolor).call(Color.fill, getFillColor(selectorLayout, d)).style("stroke-width", selectorLayout.borderwidth + "px");
      }
      function getFillColor(selectorLayout, d) {
        return d._isActive || d._isHovered ? selectorLayout.activecolor : selectorLayout.bgcolor;
      }
      function drawButtonText(button, selectorLayout, d, gd) {
        function textLayout(s) {
          svgTextUtils.convertToTspans(s, gd);
        }
        var text = Lib.ensureSingle(button, "text", "selector-text", function(s) {
          s.attr("text-anchor", "middle");
        });
        text.call(Drawing.font, selectorLayout.font).text(getLabel(d, gd._fullLayout._meta)).call(textLayout);
      }
      function getLabel(opts, _meta) {
        if (opts.label) {
          return _meta ? Lib.templateString(opts.label, _meta) : opts.label;
        }
        if (opts.step === "all") return "all";
        return opts.count + opts.step.charAt(0);
      }
      function reposition(gd, buttons, opts, axName, selector) {
        var width = 0;
        var height = 0;
        var borderWidth = opts.borderwidth;
        buttons.each(function() {
          var button = d3.select(this);
          var text = button.select(".selector-text");
          var tHeight = opts.font.size * LINE_SPACING;
          var hEff = Math.max(tHeight * svgTextUtils.lineCount(text), 16) + 3;
          height = Math.max(height, hEff);
        });
        buttons.each(function() {
          var button = d3.select(this);
          var rect = button.select(".selector-rect");
          var text = button.select(".selector-text");
          var tWidth = text.node() && Drawing.bBox(text.node()).width;
          var tHeight = opts.font.size * LINE_SPACING;
          var tLines = svgTextUtils.lineCount(text);
          var wEff = Math.max(tWidth + 10, constants.minButtonWidth);
          button.attr("transform", strTranslate(borderWidth + width, borderWidth));
          rect.attr({
            x: 0,
            y: 0,
            width: wEff,
            height
          });
          svgTextUtils.positionText(
            text,
            wEff / 2,
            height / 2 - (tLines - 1) * tHeight / 2 + 3
          );
          width += wEff + 5;
        });
        var graphSize = gd._fullLayout._size;
        var lx = graphSize.l + graphSize.w * opts.x;
        var ly = graphSize.t + graphSize.h * (1 - opts.y);
        var xanchor = "left";
        if (Lib.isRightAnchor(opts)) {
          lx -= width;
          xanchor = "right";
        }
        if (Lib.isCenterAnchor(opts)) {
          lx -= width / 2;
          xanchor = "center";
        }
        var yanchor = "top";
        if (Lib.isBottomAnchor(opts)) {
          ly -= height;
          yanchor = "bottom";
        }
        if (Lib.isMiddleAnchor(opts)) {
          ly -= height / 2;
          yanchor = "middle";
        }
        width = Math.ceil(width);
        height = Math.ceil(height);
        lx = Math.round(lx);
        ly = Math.round(ly);
        Plots.autoMargin(gd, axName + "-range-selector", {
          x: opts.x,
          y: opts.y,
          l: width * FROM_TL[xanchor],
          r: width * FROM_BR[xanchor],
          b: height * FROM_BR[yanchor],
          t: height * FROM_TL[yanchor]
        });
        selector.attr("transform", strTranslate(lx, ly));
      }
    }
  });

  // src/components/rangeselector/index.js
  var require_rangeselector = __commonJS({
    "src/components/rangeselector/index.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "component",
        name: "rangeselector",
        schema: {
          subplots: {
            xaxis: { rangeselector: require_attributes21() }
          }
        },
        layoutAttributes: require_attributes21(),
        handleDefaults: require_defaults17(),
        draw: require_draw10()
      };
    }
  });

  // src/plots/domain.js
  var require_domain = __commonJS({
    "src/plots/domain.js"(exports) {
      "use strict";
      var extendFlat = require_extend().extendFlat;
      exports.attributes = function(opts, extra) {
        opts = opts || {};
        extra = extra || {};
        var base = {
          valType: "info_array",
          editType: opts.editType,
          items: [
            { valType: "number", min: 0, max: 1, editType: opts.editType },
            { valType: "number", min: 0, max: 1, editType: opts.editType }
          ],
          dflt: [0, 1]
        };
        var namePart = opts.name ? opts.name + " " : "";
        var contPart = opts.trace ? "trace " : "subplot ";
        var descPart = extra.description ? " " + extra.description : "";
        var out = {
          x: extendFlat({}, base, {}),
          y: extendFlat({}, base, {}),
          editType: opts.editType
        };
        if (!opts.noGridCell) {
          out.row = {
            valType: "integer",
            min: 0,
            dflt: 0,
            editType: opts.editType
          };
          out.column = {
            valType: "integer",
            min: 0,
            dflt: 0,
            editType: opts.editType
          };
        }
        return out;
      };
      exports.defaults = function(containerOut, layout, coerce, dfltDomains) {
        var dfltX = dfltDomains && dfltDomains.x || [0, 1];
        var dfltY = dfltDomains && dfltDomains.y || [0, 1];
        var grid = layout.grid;
        if (grid) {
          var column = coerce("domain.column");
          if (column !== void 0) {
            if (column < grid.columns) dfltX = grid._domains.x[column];
            else delete containerOut.domain.column;
          }
          var row = coerce("domain.row");
          if (row !== void 0) {
            if (row < grid.rows) dfltY = grid._domains.y[row];
            else delete containerOut.domain.row;
          }
        }
        var x = coerce("domain.x", dfltX);
        var y = coerce("domain.y", dfltY);
        if (!(x[0] < x[1])) containerOut.domain.x = dfltX.slice();
        if (!(y[0] < y[1])) containerOut.domain.y = dfltY.slice();
      };
    }
  });

  // src/components/grid/index.js
  var require_grid = __commonJS({
    "src/components/grid/index.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var counterRegex = require_regex().counter;
      var domainAttrs = require_domain().attributes;
      var cartesianIdRegex = require_constants2().idRegex;
      var Template = require_plot_template();
      var gridAttrs = {
        rows: {
          valType: "integer",
          min: 1,
          editType: "plot"
        },
        roworder: {
          valType: "enumerated",
          values: ["top to bottom", "bottom to top"],
          dflt: "top to bottom",
          editType: "plot"
        },
        columns: {
          valType: "integer",
          min: 1,
          editType: "plot"
        },
        subplots: {
          valType: "info_array",
          freeLength: true,
          dimensions: 2,
          items: { valType: "enumerated", values: [counterRegex("xy").toString(), ""], editType: "plot" },
          editType: "plot"
        },
        xaxes: {
          valType: "info_array",
          freeLength: true,
          items: { valType: "enumerated", values: [cartesianIdRegex.x.toString(), ""], editType: "plot" },
          editType: "plot"
        },
        yaxes: {
          valType: "info_array",
          freeLength: true,
          items: { valType: "enumerated", values: [cartesianIdRegex.y.toString(), ""], editType: "plot" },
          editType: "plot"
        },
        pattern: {
          valType: "enumerated",
          values: ["independent", "coupled"],
          dflt: "coupled",
          editType: "plot"
        },
        xgap: {
          valType: "number",
          min: 0,
          max: 1,
          editType: "plot"
        },
        ygap: {
          valType: "number",
          min: 0,
          max: 1,
          editType: "plot"
        },
        domain: domainAttrs({ name: "grid", editType: "plot", noGridCell: true }, {}),
        xside: {
          valType: "enumerated",
          values: ["bottom", "bottom plot", "top plot", "top"],
          dflt: "bottom plot",
          editType: "plot"
        },
        yside: {
          valType: "enumerated",
          values: ["left", "left plot", "right plot", "right"],
          dflt: "left plot",
          editType: "plot"
        },
        editType: "plot"
      };
      function getAxes(layout, grid, axLetter) {
        var gridVal = grid[axLetter + "axes"];
        var splomVal = Object.keys((layout._splomAxes || {})[axLetter] || {});
        if (Array.isArray(gridVal)) return gridVal;
        if (splomVal.length) return splomVal;
      }
      function sizeDefaults(layoutIn, layoutOut) {
        var gridIn = layoutIn.grid || {};
        var xAxes = getAxes(layoutOut, gridIn, "x");
        var yAxes = getAxes(layoutOut, gridIn, "y");
        if (!layoutIn.grid && !xAxes && !yAxes) return;
        var hasSubplotGrid = Array.isArray(gridIn.subplots) && Array.isArray(gridIn.subplots[0]);
        var hasXaxes = Array.isArray(xAxes);
        var hasYaxes = Array.isArray(yAxes);
        var isSplomGenerated = hasXaxes && xAxes !== gridIn.xaxes && hasYaxes && yAxes !== gridIn.yaxes;
        var dfltRows, dfltColumns;
        if (hasSubplotGrid) {
          dfltRows = gridIn.subplots.length;
          dfltColumns = gridIn.subplots[0].length;
        } else {
          if (hasYaxes) dfltRows = yAxes.length;
          if (hasXaxes) dfltColumns = xAxes.length;
        }
        var gridOut = Template.newContainer(layoutOut, "grid");
        function coerce(attr, dflt) {
          return Lib.coerce(gridIn, gridOut, gridAttrs, attr, dflt);
        }
        var rows = coerce("rows", dfltRows);
        var columns = coerce("columns", dfltColumns);
        if (!(rows * columns > 1)) {
          delete layoutOut.grid;
          return;
        }
        if (!hasSubplotGrid && !hasXaxes && !hasYaxes) {
          var useDefaultSubplots = coerce("pattern") === "independent";
          if (useDefaultSubplots) hasSubplotGrid = true;
        }
        gridOut._hasSubplotGrid = hasSubplotGrid;
        var rowOrder = coerce("roworder");
        var reversed = rowOrder === "top to bottom";
        var dfltGapX = hasSubplotGrid ? 0.2 : 0.1;
        var dfltGapY = hasSubplotGrid ? 0.3 : 0.1;
        var dfltSideX, dfltSideY;
        if (isSplomGenerated && layoutOut._splomGridDflt) {
          dfltSideX = layoutOut._splomGridDflt.xside;
          dfltSideY = layoutOut._splomGridDflt.yside;
        }
        gridOut._domains = {
          x: fillGridPositions("x", coerce, dfltGapX, dfltSideX, columns),
          y: fillGridPositions("y", coerce, dfltGapY, dfltSideY, rows, reversed)
        };
      }
      function fillGridPositions(axLetter, coerce, dfltGap, dfltSide, len, reversed) {
        var dirGap = coerce(axLetter + "gap", dfltGap);
        var domain = coerce("domain." + axLetter);
        coerce(axLetter + "side", dfltSide);
        var out = new Array(len);
        var start = domain[0];
        var step = (domain[1] - start) / (len - dirGap);
        var cellDomain = step * (1 - dirGap);
        for (var i = 0; i < len; i++) {
          var cellStart = start + step * i;
          out[reversed ? len - 1 - i : i] = [cellStart, cellStart + cellDomain];
        }
        return out;
      }
      function contentDefaults(layoutIn, layoutOut) {
        var gridOut = layoutOut.grid;
        if (!gridOut || !gridOut._domains) return;
        var gridIn = layoutIn.grid || {};
        var subplots = layoutOut._subplots;
        var hasSubplotGrid = gridOut._hasSubplotGrid;
        var rows = gridOut.rows;
        var columns = gridOut.columns;
        var useDefaultSubplots = gridOut.pattern === "independent";
        var i, j, xId, yId, subplotId, subplotsOut, yPos;
        var axisMap = gridOut._axisMap = {};
        if (hasSubplotGrid) {
          var subplotsIn = gridIn.subplots || [];
          subplotsOut = gridOut.subplots = new Array(rows);
          var index = 1;
          for (i = 0; i < rows; i++) {
            var rowOut = subplotsOut[i] = new Array(columns);
            var rowIn = subplotsIn[i] || [];
            for (j = 0; j < columns; j++) {
              if (useDefaultSubplots) {
                subplotId = index === 1 ? "xy" : "x" + index + "y" + index;
                index++;
              } else subplotId = rowIn[j];
              rowOut[j] = "";
              if (subplots.cartesian.indexOf(subplotId) !== -1) {
                yPos = subplotId.indexOf("y");
                xId = subplotId.slice(0, yPos);
                yId = subplotId.slice(yPos);
                if (axisMap[xId] !== void 0 && axisMap[xId] !== j || axisMap[yId] !== void 0 && axisMap[yId] !== i) {
                  continue;
                }
                rowOut[j] = subplotId;
                axisMap[xId] = j;
                axisMap[yId] = i;
              }
            }
          }
        } else {
          var xAxes = getAxes(layoutOut, gridIn, "x");
          var yAxes = getAxes(layoutOut, gridIn, "y");
          gridOut.xaxes = fillGridAxes(xAxes, subplots.xaxis, columns, axisMap, "x");
          gridOut.yaxes = fillGridAxes(yAxes, subplots.yaxis, rows, axisMap, "y");
        }
        var anchors = gridOut._anchors = {};
        var reversed = gridOut.roworder === "top to bottom";
        for (var axisId in axisMap) {
          var axLetter = axisId.charAt(0);
          var side = gridOut[axLetter + "side"];
          var i0, inc, iFinal;
          if (side.length < 8) {
            anchors[axisId] = "free";
          } else if (axLetter === "x") {
            if (side.charAt(0) === "t" === reversed) {
              i0 = 0;
              inc = 1;
              iFinal = rows;
            } else {
              i0 = rows - 1;
              inc = -1;
              iFinal = -1;
            }
            if (hasSubplotGrid) {
              var column = axisMap[axisId];
              for (i = i0; i !== iFinal; i += inc) {
                subplotId = subplotsOut[i][column];
                if (!subplotId) continue;
                yPos = subplotId.indexOf("y");
                if (subplotId.slice(0, yPos) === axisId) {
                  anchors[axisId] = subplotId.slice(yPos);
                  break;
                }
              }
            } else {
              for (i = i0; i !== iFinal; i += inc) {
                yId = gridOut.yaxes[i];
                if (subplots.cartesian.indexOf(axisId + yId) !== -1) {
                  anchors[axisId] = yId;
                  break;
                }
              }
            }
          } else {
            if (side.charAt(0) === "l") {
              i0 = 0;
              inc = 1;
              iFinal = columns;
            } else {
              i0 = columns - 1;
              inc = -1;
              iFinal = -1;
            }
            if (hasSubplotGrid) {
              var row = axisMap[axisId];
              for (i = i0; i !== iFinal; i += inc) {
                subplotId = subplotsOut[row][i];
                if (!subplotId) continue;
                yPos = subplotId.indexOf("y");
                if (subplotId.slice(yPos) === axisId) {
                  anchors[axisId] = subplotId.slice(0, yPos);
                  break;
                }
              }
            } else {
              for (i = i0; i !== iFinal; i += inc) {
                xId = gridOut.xaxes[i];
                if (subplots.cartesian.indexOf(xId + axisId) !== -1) {
                  anchors[axisId] = xId;
                  break;
                }
              }
            }
          }
        }
      }
      function fillGridAxes(axesIn, axesAllowed, len, axisMap, axLetter) {
        var out = new Array(len);
        var i;
        function fillOneAxis(i2, axisId) {
          if (axesAllowed.indexOf(axisId) !== -1 && axisMap[axisId] === void 0) {
            out[i2] = axisId;
            axisMap[axisId] = i2;
          } else out[i2] = "";
        }
        if (Array.isArray(axesIn)) {
          for (i = 0; i < len; i++) {
            fillOneAxis(i, axesIn[i]);
          }
        } else {
          fillOneAxis(0, axLetter);
          for (i = 1; i < len; i++) {
            fillOneAxis(i, axLetter + (i + 1));
          }
        }
        return out;
      }
      module.exports = {
        moduleType: "component",
        name: "grid",
        schema: {
          layout: { grid: gridAttrs }
        },
        layoutAttributes: gridAttrs,
        sizeDefaults,
        contentDefaults
      };
    }
  });

  // src/components/errorbars/attributes.js
  var require_attributes22 = __commonJS({
    "src/components/errorbars/attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        visible: {
          valType: "boolean",
          editType: "calc"
        },
        type: {
          valType: "enumerated",
          values: ["percent", "constant", "sqrt", "data"],
          editType: "calc"
        },
        symmetric: {
          valType: "boolean",
          editType: "calc"
        },
        array: {
          valType: "data_array",
          editType: "calc"
        },
        arrayminus: {
          valType: "data_array",
          editType: "calc"
        },
        value: {
          valType: "number",
          min: 0,
          dflt: 10,
          editType: "calc"
        },
        valueminus: {
          valType: "number",
          min: 0,
          dflt: 10,
          editType: "calc"
        },
        traceref: {
          valType: "integer",
          min: 0,
          dflt: 0,
          editType: "style"
        },
        tracerefminus: {
          valType: "integer",
          min: 0,
          dflt: 0,
          editType: "style"
        },
        copy_ystyle: {
          valType: "boolean",
          editType: "plot"
        },
        copy_zstyle: {
          valType: "boolean",
          editType: "style"
        },
        color: {
          valType: "color",
          editType: "style"
        },
        thickness: {
          valType: "number",
          min: 0,
          dflt: 2,
          editType: "style"
        },
        width: {
          valType: "number",
          min: 0,
          editType: "plot"
        },
        editType: "calc"
      };
    }
  });

  // src/components/errorbars/defaults.js
  var require_defaults18 = __commonJS({
    "src/components/errorbars/defaults.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Registry = require_registry();
      var Lib = require_lib();
      var Template = require_plot_template();
      var attributes = require_attributes22();
      module.exports = function(traceIn, traceOut, defaultColor, opts) {
        var objName = "error_" + opts.axis;
        var containerOut = Template.newContainer(traceOut, objName);
        var containerIn = traceIn[objName] || {};
        function coerce(attr, dflt) {
          return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
        }
        var hasErrorBars = containerIn.array !== void 0 || containerIn.value !== void 0 || containerIn.type === "sqrt";
        var visible = coerce("visible", hasErrorBars);
        if (visible === false) return;
        var type = coerce("type", "array" in containerIn ? "data" : "percent");
        var symmetric = true;
        if (type !== "sqrt") {
          symmetric = coerce(
            "symmetric",
            !((type === "data" ? "arrayminus" : "valueminus") in containerIn)
          );
        }
        if (type === "data") {
          coerce("array");
          coerce("traceref");
          if (!symmetric) {
            coerce("arrayminus");
            coerce("tracerefminus");
          }
        } else if (type === "percent" || type === "constant") {
          coerce("value");
          if (!symmetric) coerce("valueminus");
        }
        var copyAttr = "copy_" + opts.inherit + "style";
        if (opts.inherit) {
          var inheritObj = traceOut["error_" + opts.inherit];
          if ((inheritObj || {}).visible) {
            coerce(copyAttr, !(containerIn.color || isNumeric(containerIn.thickness) || isNumeric(containerIn.width)));
          }
        }
        if (!opts.inherit || !containerOut[copyAttr]) {
          coerce("color", defaultColor);
          coerce("thickness");
          coerce("width", Registry.traceIs(traceOut, "gl3d") ? 0 : 4);
        }
      };
    }
  });

  // src/components/errorbars/compute_error.js
  var require_compute_error = __commonJS({
    "src/components/errorbars/compute_error.js"(exports, module) {
      "use strict";
      module.exports = function makeComputeError(opts) {
        var type = opts.type;
        var symmetric = opts.symmetric;
        if (type === "data") {
          var array = opts.array || [];
          if (symmetric) {
            return function computeError(dataPt, index) {
              var val = +array[index];
              return [val, val];
            };
          } else {
            var arrayminus = opts.arrayminus || [];
            return function computeError(dataPt, index) {
              var val = +array[index];
              var valMinus = +arrayminus[index];
              if (!isNaN(val) || !isNaN(valMinus)) {
                return [valMinus || 0, val || 0];
              }
              return [NaN, NaN];
            };
          }
        } else {
          var computeErrorValue = makeComputeErrorValue(type, opts.value);
          var computeErrorValueMinus = makeComputeErrorValue(type, opts.valueminus);
          if (symmetric || opts.valueminus === void 0) {
            return function computeError(dataPt) {
              var val = computeErrorValue(dataPt);
              return [val, val];
            };
          } else {
            return function computeError(dataPt) {
              return [
                computeErrorValueMinus(dataPt),
                computeErrorValue(dataPt)
              ];
            };
          }
        }
      };
      function makeComputeErrorValue(type, value) {
        if (type === "percent") {
          return function(dataPt) {
            return Math.abs(dataPt * value / 100);
          };
        }
        if (type === "constant") {
          return function() {
            return Math.abs(value);
          };
        }
        if (type === "sqrt") {
          return function(dataPt) {
            return Math.sqrt(Math.abs(dataPt));
          };
        }
      }
    }
  });

  // src/components/errorbars/calc.js
  var require_calc4 = __commonJS({
    "src/components/errorbars/calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Registry = require_registry();
      var Axes = require_axes();
      var Lib = require_lib();
      var makeComputeError = require_compute_error();
      module.exports = function calc(gd) {
        var calcdata = gd.calcdata;
        for (var i = 0; i < calcdata.length; i++) {
          var calcTrace = calcdata[i];
          var trace = calcTrace[0].trace;
          if (trace.visible === true && Registry.traceIs(trace, "errorBarsOK")) {
            var xa = Axes.getFromId(gd, trace.xaxis);
            var ya = Axes.getFromId(gd, trace.yaxis);
            calcOneAxis(calcTrace, trace, xa, "x");
            calcOneAxis(calcTrace, trace, ya, "y");
          }
        }
      };
      function calcOneAxis(calcTrace, trace, axis, coord) {
        var opts = trace["error_" + coord] || {};
        var isVisible = opts.visible && ["linear", "log"].indexOf(axis.type) !== -1;
        var vals = [];
        if (!isVisible) return;
        var computeError = makeComputeError(opts);
        for (var i = 0; i < calcTrace.length; i++) {
          var calcPt = calcTrace[i];
          var iIn = calcPt.i;
          if (iIn === void 0) iIn = i;
          else if (iIn === null) continue;
          var calcCoord = calcPt[coord];
          if (!isNumeric(axis.c2l(calcCoord))) continue;
          var errors = computeError(calcCoord, iIn);
          if (isNumeric(errors[0]) && isNumeric(errors[1])) {
            var shoe = calcPt[coord + "s"] = calcCoord - errors[0];
            var hat = calcPt[coord + "h"] = calcCoord + errors[1];
            vals.push(shoe, hat);
          }
        }
        var axId = axis._id;
        var baseExtremes = trace._extremes[axId];
        var extremes = Axes.findExtremes(
          axis,
          vals,
          Lib.extendFlat({ tozero: baseExtremes.opts.tozero }, { padded: true })
        );
        baseExtremes.min = baseExtremes.min.concat(extremes.min);
        baseExtremes.max = baseExtremes.max.concat(extremes.max);
      }
    }
  });

  // src/components/errorbars/plot.js
  var require_plot2 = __commonJS({
    "src/components/errorbars/plot.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var Drawing = require_drawing();
      var subTypes = require_subtypes();
      module.exports = function plot(gd, traces, plotinfo, transitionOpts) {
        var isNew;
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var hasAnimation = transitionOpts && transitionOpts.duration > 0;
        var isStatic = gd._context.staticPlot;
        traces.each(function(d) {
          var trace = d[0].trace;
          var xObj = trace.error_x || {};
          var yObj = trace.error_y || {};
          var keyFunc;
          if (trace.ids) {
            keyFunc = function(d2) {
              return d2.id;
            };
          }
          var sparse = subTypes.hasMarkers(trace) && trace.marker.maxdisplayed > 0;
          if (!yObj.visible && !xObj.visible) d = [];
          var errorbars = d3.select(this).selectAll("g.errorbar").data(d, keyFunc);
          errorbars.exit().remove();
          if (!d.length) return;
          if (!xObj.visible) errorbars.selectAll("path.xerror").remove();
          if (!yObj.visible) errorbars.selectAll("path.yerror").remove();
          errorbars.style("opacity", 1);
          var enter = errorbars.enter().append("g").classed("errorbar", true);
          if (hasAnimation) {
            enter.style("opacity", 0).transition().duration(transitionOpts.duration).style("opacity", 1);
          }
          Drawing.setClipUrl(errorbars, plotinfo.layerClipId, gd);
          errorbars.each(function(d2) {
            var errorbar = d3.select(this);
            var coords = errorCoords(d2, xa, ya);
            if (sparse && !d2.vis) return;
            var path;
            var yerror = errorbar.select("path.yerror");
            if (yObj.visible && isNumeric(coords.x) && isNumeric(coords.yh) && isNumeric(coords.ys)) {
              var yw = yObj.width;
              path = "M" + (coords.x - yw) + "," + coords.yh + "h" + 2 * yw + // hat
              "m-" + yw + ",0V" + coords.ys;
              if (!coords.noYS) path += "m-" + yw + ",0h" + 2 * yw;
              isNew = !yerror.size();
              if (isNew) {
                yerror = errorbar.append("path").style("vector-effect", isStatic ? "none" : "non-scaling-stroke").classed("yerror", true);
              } else if (hasAnimation) {
                yerror = yerror.transition().duration(transitionOpts.duration).ease(transitionOpts.easing);
              }
              yerror.attr("d", path);
            } else yerror.remove();
            var xerror = errorbar.select("path.xerror");
            if (xObj.visible && isNumeric(coords.y) && isNumeric(coords.xh) && isNumeric(coords.xs)) {
              var xw = (xObj.copy_ystyle ? yObj : xObj).width;
              path = "M" + coords.xh + "," + (coords.y - xw) + "v" + 2 * xw + // hat
              "m0,-" + xw + "H" + coords.xs;
              if (!coords.noXS) path += "m0,-" + xw + "v" + 2 * xw;
              isNew = !xerror.size();
              if (isNew) {
                xerror = errorbar.append("path").style("vector-effect", isStatic ? "none" : "non-scaling-stroke").classed("xerror", true);
              } else if (hasAnimation) {
                xerror = xerror.transition().duration(transitionOpts.duration).ease(transitionOpts.easing);
              }
              xerror.attr("d", path);
            } else xerror.remove();
          });
        });
      };
      function errorCoords(d, xa, ya) {
        var out = {
          x: xa.c2p(d.x),
          y: ya.c2p(d.y)
        };
        if (d.yh !== void 0) {
          out.yh = ya.c2p(d.yh);
          out.ys = ya.c2p(d.ys);
          if (!isNumeric(out.ys)) {
            out.noYS = true;
            out.ys = ya.c2p(d.ys, true);
          }
        }
        if (d.xh !== void 0) {
          out.xh = xa.c2p(d.xh);
          out.xs = xa.c2p(d.xs);
          if (!isNumeric(out.xs)) {
            out.noXS = true;
            out.xs = xa.c2p(d.xs, true);
          }
        }
        return out;
      }
    }
  });

  // src/components/errorbars/style.js
  var require_style3 = __commonJS({
    "src/components/errorbars/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Color = require_color();
      module.exports = function style(traces) {
        traces.each(function(d) {
          var trace = d[0].trace;
          var yObj = trace.error_y || {};
          var xObj = trace.error_x || {};
          var s = d3.select(this);
          s.selectAll("path.yerror").style("stroke-width", yObj.thickness + "px").call(Color.stroke, yObj.color);
          if (xObj.copy_ystyle) xObj = yObj;
          s.selectAll("path.xerror").style("stroke-width", xObj.thickness + "px").call(Color.stroke, xObj.color);
        });
      };
    }
  });

  // src/components/errorbars/index.js
  var require_errorbars = __commonJS({
    "src/components/errorbars/index.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var overrideAll = require_edit_types().overrideAll;
      var attributes = require_attributes22();
      var xyAttrs = {
        error_x: Lib.extendFlat({}, attributes),
        error_y: Lib.extendFlat({}, attributes)
      };
      delete xyAttrs.error_x.copy_zstyle;
      delete xyAttrs.error_y.copy_zstyle;
      delete xyAttrs.error_y.copy_ystyle;
      var xyzAttrs = {
        error_x: Lib.extendFlat({}, attributes),
        error_y: Lib.extendFlat({}, attributes),
        error_z: Lib.extendFlat({}, attributes)
      };
      delete xyzAttrs.error_x.copy_ystyle;
      delete xyzAttrs.error_y.copy_ystyle;
      delete xyzAttrs.error_z.copy_ystyle;
      delete xyzAttrs.error_z.copy_zstyle;
      module.exports = {
        moduleType: "component",
        name: "errorbars",
        schema: {
          traces: {
            scatter: xyAttrs,
            bar: xyAttrs,
            histogram: xyAttrs,
            scatter3d: overrideAll(xyzAttrs, "calc", "nested"),
            scattergl: overrideAll(xyAttrs, "calc", "nested")
          }
        },
        supplyDefaults: require_defaults18(),
        calc: require_calc4(),
        makeComputeError: require_compute_error(),
        plot: require_plot2(),
        style: require_style3(),
        hoverInfo
      };
      function hoverInfo(calcPoint, trace, hoverPoint) {
        if ((trace.error_y || {}).visible) {
          hoverPoint.yerr = calcPoint.yh - calcPoint.y;
          if (!trace.error_y.symmetric) hoverPoint.yerrneg = calcPoint.y - calcPoint.ys;
        }
        if ((trace.error_x || {}).visible) {
          hoverPoint.xerr = calcPoint.xh - calcPoint.x;
          if (!trace.error_x.symmetric) hoverPoint.xerrneg = calcPoint.x - calcPoint.xs;
        }
      }
    }
  });

  // src/components/colorbar/constants.js
  var require_constants13 = __commonJS({
    "src/components/colorbar/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        cn: {
          colorbar: "colorbar",
          cbbg: "cbbg",
          cbfill: "cbfill",
          cbfills: "cbfills",
          cbline: "cbline",
          cblines: "cblines",
          cbaxis: "cbaxis",
          cbtitleunshift: "cbtitleunshift",
          cbtitle: "cbtitle",
          cboutline: "cboutline",
          crisp: "crisp",
          jsPlaceholder: "js-placeholder"
        }
      };
    }
  });

  // src/components/colorbar/draw.js
  var require_draw11 = __commonJS({
    "src/components/colorbar/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var tinycolor = require_tinycolor();
      var Plots = require_plots();
      var Registry = require_registry();
      var Axes = require_axes();
      var dragElement = require_dragelement();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var extendFlat = require_extend().extendFlat;
      var setCursor = require_setcursor();
      var Drawing = require_drawing();
      var Color = require_color();
      var Titles = require_titles();
      var svgTextUtils = require_svg_text_utils();
      var flipScale = require_helpers().flipScale;
      var handleAxisDefaults = require_axis_defaults();
      var handleAxisPositionDefaults = require_position_defaults();
      var axisLayoutAttrs = require_layout_attributes4();
      var alignmentConstants = require_alignment();
      var LINE_SPACING = alignmentConstants.LINE_SPACING;
      var FROM_TL = alignmentConstants.FROM_TL;
      var FROM_BR = alignmentConstants.FROM_BR;
      var cn = require_constants13().cn;
      function draw(gd) {
        var fullLayout = gd._fullLayout;
        var colorBars = fullLayout._infolayer.selectAll("g." + cn.colorbar).data(makeColorBarData(gd), function(opts) {
          return opts._id;
        });
        colorBars.enter().append("g").attr("class", function(opts) {
          return opts._id;
        }).classed(cn.colorbar, true);
        colorBars.each(function(opts) {
          var g = d3.select(this);
          Lib.ensureSingle(g, "rect", cn.cbbg);
          Lib.ensureSingle(g, "g", cn.cbfills);
          Lib.ensureSingle(g, "g", cn.cblines);
          Lib.ensureSingle(g, "g", cn.cbaxis, function(s) {
            s.classed(cn.crisp, true);
          });
          Lib.ensureSingle(g, "g", cn.cbtitleunshift, function(s) {
            s.append("g").classed(cn.cbtitle, true);
          });
          Lib.ensureSingle(g, "rect", cn.cboutline);
          var done = drawColorBar(g, opts, gd);
          if (done && done.then) (gd._promises || []).push(done);
          if (gd._context.edits.colorbarPosition) {
            makeEditable(g, opts, gd);
          }
        });
        colorBars.exit().each(function(opts) {
          Plots.autoMargin(gd, opts._id);
        }).remove();
        colorBars.order();
      }
      function makeColorBarData(gd) {
        var fullLayout = gd._fullLayout;
        var calcdata = gd.calcdata;
        var out = [];
        var opts;
        var cont;
        var trace;
        var cbOpt;
        function initOpts(opts2) {
          return extendFlat(opts2, {
            // fillcolor can be a d3 scale, domain is z values, range is colors
            // or leave it out for no fill,
            // or set to a string constant for single-color fill
            _fillcolor: null,
            // line.color has the same options as fillcolor
            _line: { color: null, width: null, dash: null },
            // levels of lines to draw.
            // note that this DOES NOT determine the extent of the bar
            // that's given by the domain of fillcolor
            // (or line.color if no fillcolor domain)
            _levels: { start: null, end: null, size: null },
            // separate fill levels (for example, heatmap coloring of a
            // contour map) if this is omitted, fillcolors will be
            // evaluated halfway between levels
            _filllevels: null,
            // for continuous colorscales: fill with a gradient instead of explicit levels
            // value should be the colorscale [[0, c0], [v1, c1], ..., [1, cEnd]]
            _fillgradient: null,
            // when using a gradient, we need the data range specified separately
            _zrange: null
          });
        }
        function calcOpts() {
          if (typeof cbOpt.calc === "function") {
            cbOpt.calc(gd, trace, opts);
          } else {
            opts._fillgradient = cont.reversescale ? flipScale(cont.colorscale) : cont.colorscale;
            opts._zrange = [cont[cbOpt.min], cont[cbOpt.max]];
          }
        }
        for (var i = 0; i < calcdata.length; i++) {
          var cd = calcdata[i];
          trace = cd[0].trace;
          if (!trace._module) continue;
          var moduleOpts = trace._module.colorbar;
          if (trace.visible === true && moduleOpts) {
            var allowsMultiplotCbs = Array.isArray(moduleOpts);
            var cbOpts = allowsMultiplotCbs ? moduleOpts : [moduleOpts];
            for (var j = 0; j < cbOpts.length; j++) {
              cbOpt = cbOpts[j];
              var contName = cbOpt.container;
              cont = contName ? trace[contName] : trace;
              if (cont && cont.showscale) {
                opts = initOpts(cont.colorbar);
                opts._id = "cb" + trace.uid + (allowsMultiplotCbs && contName ? "-" + contName : "");
                opts._traceIndex = trace.index;
                opts._propPrefix = (contName ? contName + "." : "") + "colorbar.";
                opts._meta = trace._meta;
                calcOpts();
                out.push(opts);
              }
            }
          }
        }
        for (var k in fullLayout._colorAxes) {
          cont = fullLayout[k];
          if (cont.showscale) {
            var colorAxOpts = fullLayout._colorAxes[k];
            opts = initOpts(cont.colorbar);
            opts._id = "cb" + k;
            opts._propPrefix = k + ".colorbar.";
            opts._meta = fullLayout._meta;
            cbOpt = { min: "cmin", max: "cmax" };
            if (colorAxOpts[0] !== "heatmap") {
              trace = colorAxOpts[1];
              cbOpt.calc = trace._module.colorbar.calc;
            }
            calcOpts();
            out.push(opts);
          }
        }
        return out;
      }
      function drawColorBar(g, opts, gd) {
        var isVertical = opts.orientation === "v";
        var len = opts.len;
        var lenmode = opts.lenmode;
        var thickness = opts.thickness;
        var thicknessmode = opts.thicknessmode;
        var outlinewidth = opts.outlinewidth;
        var borderwidth = opts.borderwidth;
        var bgcolor = opts.bgcolor;
        var xanchor = opts.xanchor;
        var yanchor = opts.yanchor;
        var xpad = opts.xpad;
        var ypad = opts.ypad;
        var optsX = opts.x;
        var optsY = isVertical ? opts.y : 1 - opts.y;
        var isPaperY = opts.yref === "paper";
        var isPaperX = opts.xref === "paper";
        var fullLayout = gd._fullLayout;
        var gs = fullLayout._size;
        var fillColor = opts._fillcolor;
        var line = opts._line;
        var title = opts.title;
        var titleSide = title.side;
        var zrange = opts._zrange || d3.extent((typeof fillColor === "function" ? fillColor : line.color).domain());
        var lineColormap = typeof line.color === "function" ? line.color : function() {
          return line.color;
        };
        var fillColormap = typeof fillColor === "function" ? fillColor : function() {
          return fillColor;
        };
        var levelsIn = opts._levels;
        var levelsOut = calcLevels(gd, opts, zrange);
        var fillLevels = levelsOut.fill;
        var lineLevels = levelsOut.line;
        var thickPx = Math.round(thickness * (thicknessmode === "fraction" ? isVertical ? gs.w : gs.h : 1));
        var thickFrac = thickPx / (isVertical ? gs.w : gs.h);
        var lenPx = Math.round(len * (lenmode === "fraction" ? isVertical ? gs.h : gs.w : 1));
        var lenFrac = lenPx / (isVertical ? gs.h : gs.w);
        var posW = isPaperX ? gs.w : gd._fullLayout.width;
        var posH = isPaperY ? gs.h : gd._fullLayout.height;
        var uPx = Math.round(
          isVertical ? optsX * posW + xpad : optsY * posH + ypad
        );
        var xRatio = { center: 0.5, right: 1 }[xanchor] || 0;
        var yRatio = { top: 1, middle: 0.5 }[yanchor] || 0;
        var uFrac = isVertical ? optsX - xRatio * thickFrac : optsY - yRatio * thickFrac;
        var vFrac = isVertical ? optsY - yRatio * lenFrac : optsX - xRatio * lenFrac;
        var vPx = Math.round(
          isVertical ? posH * (1 - vFrac) : posW * vFrac
        );
        opts._lenFrac = lenFrac;
        opts._thickFrac = thickFrac;
        opts._uFrac = uFrac;
        opts._vFrac = vFrac;
        var ax = opts._axis = mockColorBarAxis(gd, opts, zrange);
        ax.position = thickFrac + (isVertical ? optsX + xpad / gs.w : optsY + ypad / gs.h);
        var topOrBottom = ["top", "bottom"].indexOf(titleSide) !== -1;
        if (isVertical && topOrBottom) {
          ax.title.side = titleSide;
          ax.titlex = optsX + xpad / gs.w;
          ax.titley = vFrac + (title.side === "top" ? lenFrac - ypad / gs.h : ypad / gs.h);
        }
        if (!isVertical && !topOrBottom) {
          ax.title.side = titleSide;
          ax.titley = optsY + ypad / gs.h;
          ax.titlex = vFrac + xpad / gs.w;
        }
        if (line.color && opts.tickmode === "auto") {
          ax.tickmode = "linear";
          ax.tick0 = levelsIn.start;
          var dtick = levelsIn.size;
          var autoNtick = Lib.constrain(lenPx / 50, 4, 15) + 1;
          var dtFactor = (zrange[1] - zrange[0]) / ((opts.nticks || autoNtick) * dtick);
          if (dtFactor > 1) {
            var dtexp = Math.pow(10, Math.floor(Math.log(dtFactor) / Math.LN10));
            dtick *= dtexp * Lib.roundUp(dtFactor / dtexp, [2, 5, 10]);
            if ((Math.abs(levelsIn.start) / levelsIn.size + 1e-6) % 1 < 2e-6) {
              ax.tick0 = 0;
            }
          }
          ax.dtick = dtick;
        }
        ax.domain = isVertical ? [
          vFrac + ypad / gs.h,
          vFrac + lenFrac - ypad / gs.h
        ] : [
          vFrac + xpad / gs.w,
          vFrac + lenFrac - xpad / gs.w
        ];
        ax.setScale();
        g.attr("transform", strTranslate(Math.round(gs.l), Math.round(gs.t)));
        var titleCont = g.select("." + cn.cbtitleunshift).attr("transform", strTranslate(-Math.round(gs.l), -Math.round(gs.t)));
        var ticklabelposition = ax.ticklabelposition;
        var titleFontSize = ax.title.font.size;
        var axLayer = g.select("." + cn.cbaxis);
        var titleEl;
        var titleHeight = 0;
        var titleWidth = 0;
        function drawTitle(titleClass, titleOpts) {
          var dfltTitleOpts = {
            propContainer: ax,
            propName: opts._propPrefix + "title",
            traceIndex: opts._traceIndex,
            _meta: opts._meta,
            placeholder: fullLayout._dfltTitle.colorbar,
            containerGroup: g.select("." + cn.cbtitle)
          };
          var otherClass = titleClass.charAt(0) === "h" ? titleClass.substr(1) : "h" + titleClass;
          g.selectAll("." + otherClass + ",." + otherClass + "-math-group").remove();
          Titles.draw(gd, titleClass, extendFlat(dfltTitleOpts, titleOpts || {}));
        }
        function drawDummyTitle() {
          if (isVertical && topOrBottom || !isVertical && !topOrBottom) {
            var x, y;
            if (titleSide === "top") {
              x = xpad + gs.l + posW * optsX;
              y = ypad + gs.t + posH * (1 - vFrac - lenFrac) + 3 + titleFontSize * 0.75;
            }
            if (titleSide === "bottom") {
              x = xpad + gs.l + posW * optsX;
              y = ypad + gs.t + posH * (1 - vFrac) - 3 - titleFontSize * 0.25;
            }
            if (titleSide === "right") {
              y = ypad + gs.t + posH * optsY + 3 + titleFontSize * 0.75;
              x = xpad + gs.l + posW * vFrac;
            }
            drawTitle(ax._id + "title", {
              attributes: { x, y, "text-anchor": isVertical ? "start" : "middle" }
            });
          }
        }
        function drawCbTitle() {
          if (isVertical && !topOrBottom || !isVertical && topOrBottom) {
            var pos = ax.position || 0;
            var mid = ax._offset + ax._length / 2;
            var x, y;
            if (titleSide === "right") {
              y = mid;
              x = gs.l + posW * pos + 10 + titleFontSize * (ax.showticklabels ? 1 : 0.5);
            } else {
              x = mid;
              if (titleSide === "bottom") {
                y = gs.t + posH * pos + 10 + (ticklabelposition.indexOf("inside") === -1 ? ax.tickfont.size : 0) + (ax.ticks !== "intside" ? opts.ticklen || 0 : 0);
              }
              if (titleSide === "top") {
                var nlines = title.text.split("<br>").length;
                y = gs.t + posH * pos + 10 - thickPx - LINE_SPACING * titleFontSize * nlines;
              }
            }
            drawTitle((isVertical ? (
              // the 'h' + is a hack to get around the fact that
              // convertToTspans rotates any 'y...' class by 90 degrees.
              // TODO: find a better way to control this.
              "h"
            ) : "v") + ax._id + "title", {
              avoid: {
                selection: d3.select(gd).selectAll("g." + ax._id + "tick"),
                side: titleSide,
                offsetTop: isVertical ? 0 : gs.t,
                offsetLeft: isVertical ? gs.l : 0,
                maxShift: isVertical ? fullLayout.width : fullLayout.height
              },
              attributes: { x, y, "text-anchor": "middle" },
              transform: { rotate: isVertical ? -90 : 0, offset: 0 }
            });
          }
        }
        function drawAxis() {
          if (!isVertical && !topOrBottom || isVertical && topOrBottom) {
            var titleGroup = g.select("." + cn.cbtitle);
            var titleText = titleGroup.select("text");
            var titleTrans = [-outlinewidth / 2, outlinewidth / 2];
            var mathJaxNode = titleGroup.select(".h" + ax._id + "title-math-group").node();
            var lineSize = 15.6;
            if (titleText.node()) {
              lineSize = parseInt(titleText.node().style.fontSize, 10) * LINE_SPACING;
            }
            var bb;
            if (mathJaxNode) {
              bb = Drawing.bBox(mathJaxNode);
              titleWidth = bb.width;
              titleHeight = bb.height;
              if (titleHeight > lineSize) {
                titleTrans[1] -= (titleHeight - lineSize) / 2;
              }
            } else if (titleText.node() && !titleText.classed(cn.jsPlaceholder)) {
              bb = Drawing.bBox(titleText.node());
              titleWidth = bb.width;
              titleHeight = bb.height;
            }
            if (isVertical) {
              if (titleHeight) {
                titleHeight += 5;
                if (titleSide === "top") {
                  ax.domain[1] -= titleHeight / gs.h;
                  titleTrans[1] *= -1;
                } else {
                  ax.domain[0] += titleHeight / gs.h;
                  var nlines = svgTextUtils.lineCount(titleText);
                  titleTrans[1] += (1 - nlines) * lineSize;
                }
                titleGroup.attr("transform", strTranslate(titleTrans[0], titleTrans[1]));
                ax.setScale();
              }
            } else {
              if (titleWidth) {
                if (titleSide === "right") {
                  ax.domain[0] += (titleWidth + titleFontSize / 2) / gs.w;
                }
                titleGroup.attr("transform", strTranslate(titleTrans[0], titleTrans[1]));
                ax.setScale();
              }
            }
          }
          g.selectAll("." + cn.cbfills + ",." + cn.cblines).attr(
            "transform",
            isVertical ? strTranslate(0, Math.round(gs.h * (1 - ax.domain[1]))) : strTranslate(Math.round(gs.w * ax.domain[0]), 0)
          );
          axLayer.attr(
            "transform",
            isVertical ? strTranslate(0, Math.round(-gs.t)) : strTranslate(Math.round(-gs.l), 0)
          );
          var fills = g.select("." + cn.cbfills).selectAll("rect." + cn.cbfill).attr("style", "").data(fillLevels);
          fills.enter().append("rect").classed(cn.cbfill, true).attr("style", "");
          fills.exit().remove();
          var zBounds = zrange.map(ax.c2p).map(Math.round).sort(function(a, b) {
            return a - b;
          });
          fills.each(function(d, i) {
            var z = [
              i === 0 ? zrange[0] : (fillLevels[i] + fillLevels[i - 1]) / 2,
              i === fillLevels.length - 1 ? zrange[1] : (fillLevels[i] + fillLevels[i + 1]) / 2
            ].map(ax.c2p).map(Math.round);
            if (isVertical) {
              z[1] = Lib.constrain(z[1] + (z[1] > z[0]) ? 1 : -1, zBounds[0], zBounds[1]);
            }
            var fillEl = d3.select(this).attr(isVertical ? "x" : "y", uPx).attr(isVertical ? "y" : "x", d3.min(z)).attr(isVertical ? "width" : "height", Math.max(thickPx, 2)).attr(isVertical ? "height" : "width", Math.max(d3.max(z) - d3.min(z), 2));
            if (opts._fillgradient) {
              Drawing.gradient(fillEl, gd, opts._id, isVertical ? "vertical" : "horizontalreversed", opts._fillgradient, "fill");
            } else {
              var colorString = fillColormap(d).replace("e-", "");
              fillEl.attr("fill", tinycolor(colorString).toHexString());
            }
          });
          var lines = g.select("." + cn.cblines).selectAll("path." + cn.cbline).data(line.color && line.width ? lineLevels : []);
          lines.enter().append("path").classed(cn.cbline, true);
          lines.exit().remove();
          lines.each(function(d) {
            var a = uPx;
            var b = Math.round(ax.c2p(d)) + line.width / 2 % 1;
            d3.select(this).attr(
              "d",
              "M" + (isVertical ? a + "," + b : b + "," + a) + (isVertical ? "h" : "v") + thickPx
            ).call(Drawing.lineGroupStyle, line.width, lineColormap(d), line.dash);
          });
          axLayer.selectAll("g." + ax._id + "tick,path").remove();
          var shift = uPx + thickPx + (outlinewidth || 0) / 2 - (opts.ticks === "outside" ? 1 : 0);
          var vals = Axes.calcTicks(ax);
          var tickSign = Axes.getTickSigns(ax)[2];
          Axes.drawTicks(gd, ax, {
            vals: ax.ticks === "inside" ? Axes.clipEnds(ax, vals) : vals,
            layer: axLayer,
            path: Axes.makeTickPath(ax, shift, tickSign),
            transFn: Axes.makeTransTickFn(ax)
          });
          return Axes.drawLabels(gd, ax, {
            vals,
            layer: axLayer,
            transFn: Axes.makeTransTickLabelFn(ax),
            labelFns: Axes.makeLabelFns(ax, shift)
          });
        }
        function positionCB() {
          var bb;
          var innerThickness = thickPx + outlinewidth / 2;
          if (ticklabelposition.indexOf("inside") === -1) {
            bb = Drawing.bBox(axLayer.node());
            innerThickness += isVertical ? bb.width : bb.height;
          }
          titleEl = titleCont.select("text");
          var titleWidth2 = 0;
          var topSideVertical = isVertical && titleSide === "top";
          var rightSideHorizontal = !isVertical && titleSide === "right";
          var moveY = 0;
          if (titleEl.node() && !titleEl.classed(cn.jsPlaceholder)) {
            var _titleHeight;
            var mathJaxNode = titleCont.select(".h" + ax._id + "title-math-group").node();
            if (mathJaxNode && (isVertical && topOrBottom || !isVertical && !topOrBottom)) {
              bb = Drawing.bBox(mathJaxNode);
              titleWidth2 = bb.width;
              _titleHeight = bb.height;
            } else {
              bb = Drawing.bBox(titleCont.node());
              titleWidth2 = bb.right - gs.l - (isVertical ? uPx : vPx);
              _titleHeight = bb.bottom - gs.t - (isVertical ? vPx : uPx);
              if (!isVertical && titleSide === "top") {
                innerThickness += bb.height;
                moveY = bb.height;
              }
            }
            if (rightSideHorizontal) {
              titleEl.attr("transform", strTranslate(titleWidth2 / 2 + titleFontSize / 2, 0));
              titleWidth2 *= 2;
            }
            innerThickness = Math.max(
              innerThickness,
              isVertical ? titleWidth2 : _titleHeight
            );
          }
          var outerThickness = (isVertical ? xpad : ypad) * 2 + innerThickness + borderwidth + outlinewidth / 2;
          var hColorbarMoveTitle = 0;
          if (!isVertical && title.text && yanchor === "bottom" && optsY <= 0) {
            hColorbarMoveTitle = outerThickness / 2;
            outerThickness += hColorbarMoveTitle;
            moveY += hColorbarMoveTitle;
          }
          fullLayout._hColorbarMoveTitle = hColorbarMoveTitle;
          fullLayout._hColorbarMoveCBTitle = moveY;
          var extraW = borderwidth + outlinewidth;
          var lx = (isVertical ? uPx : vPx) - extraW / 2 - (isVertical ? xpad : 0);
          var ly = (isVertical ? vPx : uPx) - (isVertical ? lenPx : ypad + moveY - hColorbarMoveTitle);
          g.select("." + cn.cbbg).attr("x", lx).attr("y", ly).attr(isVertical ? "width" : "height", Math.max(outerThickness - hColorbarMoveTitle, 2)).attr(isVertical ? "height" : "width", Math.max(lenPx + extraW, 2)).call(Color.fill, bgcolor).call(Color.stroke, opts.bordercolor).style("stroke-width", borderwidth);
          var moveX = rightSideHorizontal ? Math.max(titleWidth2 - 10, 0) : 0;
          g.selectAll("." + cn.cboutline).attr("x", (isVertical ? uPx : vPx + xpad) + moveX).attr("y", (isVertical ? vPx + ypad - lenPx : uPx) + (topSideVertical ? titleHeight : 0)).attr(isVertical ? "width" : "height", Math.max(thickPx, 2)).attr(isVertical ? "height" : "width", Math.max(lenPx - (isVertical ? 2 * ypad + titleHeight : 2 * xpad + moveX), 2)).call(Color.stroke, opts.outlinecolor).style({
            fill: "none",
            "stroke-width": outlinewidth
          });
          var xShift = isVertical ? xRatio * outerThickness : 0;
          var yShift = isVertical ? 0 : (1 - yRatio) * outerThickness - moveY;
          xShift = isPaperX ? gs.l - xShift : -xShift;
          yShift = isPaperY ? gs.t - yShift : -yShift;
          g.attr("transform", strTranslate(
            xShift,
            yShift
          ));
          if (!isVertical && (borderwidth || tinycolor(bgcolor).getAlpha() && !tinycolor.equals(fullLayout.paper_bgcolor, bgcolor))) {
            var tickLabels = axLayer.selectAll("text");
            var numTicks = tickLabels[0].length;
            var border = g.select("." + cn.cbbg).node();
            var oBb = Drawing.bBox(border);
            var oTr = Drawing.getTranslate(g);
            var TEXTPAD = 2;
            tickLabels.each(function(d, i) {
              var first = 0;
              var last = numTicks - 1;
              if (i === first || i === last) {
                var iBb = Drawing.bBox(this);
                var iTr = Drawing.getTranslate(this);
                var deltaX;
                if (i === last) {
                  var iRight = iBb.right + iTr.x;
                  var oRight = oBb.right + oTr.x + vPx - borderwidth - TEXTPAD + optsX;
                  deltaX = oRight - iRight;
                  if (deltaX > 0) deltaX = 0;
                } else if (i === first) {
                  var iLeft = iBb.left + iTr.x;
                  var oLeft = oBb.left + oTr.x + vPx + borderwidth + TEXTPAD;
                  deltaX = oLeft - iLeft;
                  if (deltaX < 0) deltaX = 0;
                }
                if (deltaX) {
                  if (numTicks < 3) {
                    this.setAttribute(
                      "transform",
                      "translate(" + deltaX + ",0) " + this.getAttribute("transform")
                    );
                  } else {
                    this.setAttribute("visibility", "hidden");
                  }
                }
              }
            });
          }
          var marginOpts = {};
          var lFrac = FROM_TL[xanchor];
          var rFrac = FROM_BR[xanchor];
          var tFrac = FROM_TL[yanchor];
          var bFrac = FROM_BR[yanchor];
          var extraThickness = outerThickness - thickPx;
          if (isVertical) {
            if (lenmode === "pixels") {
              marginOpts.y = optsY;
              marginOpts.t = lenPx * tFrac;
              marginOpts.b = lenPx * bFrac;
            } else {
              marginOpts.t = marginOpts.b = 0;
              marginOpts.yt = optsY + len * tFrac;
              marginOpts.yb = optsY - len * bFrac;
            }
            if (thicknessmode === "pixels") {
              marginOpts.x = optsX;
              marginOpts.l = outerThickness * lFrac;
              marginOpts.r = outerThickness * rFrac;
            } else {
              marginOpts.l = extraThickness * lFrac;
              marginOpts.r = extraThickness * rFrac;
              marginOpts.xl = optsX - thickness * lFrac;
              marginOpts.xr = optsX + thickness * rFrac;
            }
          } else {
            if (lenmode === "pixels") {
              marginOpts.x = optsX;
              marginOpts.l = lenPx * lFrac;
              marginOpts.r = lenPx * rFrac;
            } else {
              marginOpts.l = marginOpts.r = 0;
              marginOpts.xl = optsX + len * lFrac;
              marginOpts.xr = optsX - len * rFrac;
            }
            if (thicknessmode === "pixels") {
              marginOpts.y = 1 - optsY;
              marginOpts.t = outerThickness * tFrac;
              marginOpts.b = outerThickness * bFrac;
            } else {
              marginOpts.t = extraThickness * tFrac;
              marginOpts.b = extraThickness * bFrac;
              marginOpts.yt = optsY - thickness * tFrac;
              marginOpts.yb = optsY + thickness * bFrac;
            }
          }
          var sideY = opts.y < 0.5 ? "b" : "t";
          var sideX = opts.x < 0.5 ? "l" : "r";
          gd._fullLayout._reservedMargin[opts._id] = {};
          var possibleReservedMargins = {
            r: fullLayout.width - lx - xShift,
            l: lx + marginOpts.r,
            b: fullLayout.height - ly - yShift,
            t: ly + marginOpts.b
          };
          if (isPaperX && isPaperY) {
            Plots.autoMargin(gd, opts._id, marginOpts);
          } else if (isPaperX) {
            gd._fullLayout._reservedMargin[opts._id][sideY] = possibleReservedMargins[sideY];
          } else if (isPaperY) {
            gd._fullLayout._reservedMargin[opts._id][sideX] = possibleReservedMargins[sideX];
          } else {
            if (isVertical) {
              gd._fullLayout._reservedMargin[opts._id][sideX] = possibleReservedMargins[sideX];
            } else {
              gd._fullLayout._reservedMargin[opts._id][sideY] = possibleReservedMargins[sideY];
            }
          }
        }
        return Lib.syncOrAsync([
          Plots.previousPromises,
          drawDummyTitle,
          drawAxis,
          drawCbTitle,
          Plots.previousPromises,
          positionCB
        ], gd);
      }
      function makeEditable(g, opts, gd) {
        var isVertical = opts.orientation === "v";
        var fullLayout = gd._fullLayout;
        var gs = fullLayout._size;
        var t0, xf, yf;
        dragElement.init({
          element: g.node(),
          gd,
          prepFn: function() {
            t0 = g.attr("transform");
            setCursor(g);
          },
          moveFn: function(dx, dy) {
            g.attr("transform", t0 + strTranslate(dx, dy));
            xf = dragElement.align(
              (isVertical ? opts._uFrac : opts._vFrac) + dx / gs.w,
              isVertical ? opts._thickFrac : opts._lenFrac,
              0,
              1,
              opts.xanchor
            );
            yf = dragElement.align(
              (isVertical ? opts._vFrac : 1 - opts._uFrac) - dy / gs.h,
              isVertical ? opts._lenFrac : opts._thickFrac,
              0,
              1,
              opts.yanchor
            );
            var csr = dragElement.getCursor(xf, yf, opts.xanchor, opts.yanchor);
            setCursor(g, csr);
          },
          doneFn: function() {
            setCursor(g);
            if (xf !== void 0 && yf !== void 0) {
              var update = {};
              update[opts._propPrefix + "x"] = xf;
              update[opts._propPrefix + "y"] = yf;
              if (opts._traceIndex !== void 0) {
                Registry.call("_guiRestyle", gd, update, opts._traceIndex);
              } else {
                Registry.call("_guiRelayout", gd, update);
              }
            }
          }
        });
      }
      function calcLevels(gd, opts, zrange) {
        var levelsIn = opts._levels;
        var lineLevels = [];
        var fillLevels = [];
        var l;
        var i;
        var l0 = levelsIn.end + levelsIn.size / 100;
        var ls = levelsIn.size;
        var zr0 = 1.001 * zrange[0] - 1e-3 * zrange[1];
        var zr1 = 1.001 * zrange[1] - 1e-3 * zrange[0];
        for (i = 0; i < 1e5; i++) {
          l = levelsIn.start + i * ls;
          if (ls > 0 ? l >= l0 : l <= l0) break;
          if (l > zr0 && l < zr1) lineLevels.push(l);
        }
        if (opts._fillgradient) {
          fillLevels = [0];
        } else if (typeof opts._fillcolor === "function") {
          var fillLevelsIn = opts._filllevels;
          if (fillLevelsIn) {
            l0 = fillLevelsIn.end + fillLevelsIn.size / 100;
            ls = fillLevelsIn.size;
            for (i = 0; i < 1e5; i++) {
              l = fillLevelsIn.start + i * ls;
              if (ls > 0 ? l >= l0 : l <= l0) break;
              if (l > zrange[0] && l < zrange[1]) fillLevels.push(l);
            }
          } else {
            fillLevels = lineLevels.map(function(v) {
              return v - levelsIn.size / 2;
            });
            fillLevels.push(fillLevels[fillLevels.length - 1] + levelsIn.size);
          }
        } else if (opts._fillcolor && typeof opts._fillcolor === "string") {
          fillLevels = [0];
        }
        if (levelsIn.size < 0) {
          lineLevels.reverse();
          fillLevels.reverse();
        }
        return { line: lineLevels, fill: fillLevels };
      }
      function mockColorBarAxis(gd, opts, zrange) {
        var fullLayout = gd._fullLayout;
        var isVertical = opts.orientation === "v";
        var cbAxisIn = {
          type: "linear",
          range: zrange,
          tickmode: opts.tickmode,
          nticks: opts.nticks,
          tick0: opts.tick0,
          dtick: opts.dtick,
          tickvals: opts.tickvals,
          ticktext: opts.ticktext,
          ticks: opts.ticks,
          ticklen: opts.ticklen,
          tickwidth: opts.tickwidth,
          tickcolor: opts.tickcolor,
          showticklabels: opts.showticklabels,
          labelalias: opts.labelalias,
          ticklabelposition: opts.ticklabelposition,
          ticklabeloverflow: opts.ticklabeloverflow,
          ticklabelstep: opts.ticklabelstep,
          tickfont: opts.tickfont,
          tickangle: opts.tickangle,
          tickformat: opts.tickformat,
          exponentformat: opts.exponentformat,
          minexponent: opts.minexponent,
          separatethousands: opts.separatethousands,
          showexponent: opts.showexponent,
          showtickprefix: opts.showtickprefix,
          tickprefix: opts.tickprefix,
          showticksuffix: opts.showticksuffix,
          ticksuffix: opts.ticksuffix,
          title: opts.title,
          showline: true,
          anchor: "free",
          side: isVertical ? "right" : "bottom",
          position: 1
        };
        var letter = isVertical ? "y" : "x";
        var cbAxisOut = {
          type: "linear",
          _id: letter + opts._id
        };
        var axisOptions = {
          letter,
          font: fullLayout.font,
          noAutotickangles: letter === "y",
          noHover: true,
          noTickson: true,
          noTicklabelmode: true,
          noInsideRange: true,
          calendar: fullLayout.calendar
          // not really necessary (yet?)
        };
        function coerce(attr, dflt) {
          return Lib.coerce(cbAxisIn, cbAxisOut, axisLayoutAttrs, attr, dflt);
        }
        handleAxisDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions, fullLayout);
        handleAxisPositionDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions);
        return cbAxisOut;
      }
      module.exports = {
        draw
      };
    }
  });

  // src/components/colorbar/index.js
  var require_colorbar = __commonJS({
    "src/components/colorbar/index.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "component",
        name: "colorbar",
        attributes: require_attributes7(),
        supplyDefaults: require_defaults(),
        draw: require_draw11().draw,
        hasColorbar: require_has_colorbar()
      };
    }
  });

  // src/components/legend/index.js
  var require_legend = __commonJS({
    "src/components/legend/index.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "component",
        name: "legend",
        layoutAttributes: require_attributes9(),
        supplyLayoutDefaults: require_defaults3(),
        draw: require_draw(),
        style: require_style()
      };
    }
  });

  // src/locale-en.js
  var require_locale_en = __commonJS({
    "src/locale-en.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "locale",
        name: "en",
        dictionary: {
          "Click to enter Colorscale title": "Click to enter Colourscale title"
        },
        format: {
          days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          months: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
          ],
          shortMonths: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ],
          periods: ["AM", "PM"],
          dateTime: "%a %b %e %X %Y",
          date: "%d/%m/%Y",
          time: "%H:%M:%S",
          decimal: ".",
          thousands: ",",
          grouping: [3],
          currency: ["$", ""],
          year: "%Y",
          month: "%b %Y",
          dayMonth: "%b %-d",
          dayMonthYear: "%b %-d, %Y"
        }
      };
    }
  });

  // src/locale-en-us.js
  var require_locale_en_us = __commonJS({
    "src/locale-en-us.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "locale",
        name: "en-US",
        dictionary: {
          "Click to enter Colorscale title": "Click to enter Colorscale title"
        },
        format: {
          date: "%m/%d/%Y"
        }
      };
    }
  });

  // src/snapshot/cloneplot.js
  var require_cloneplot = __commonJS({
    "src/snapshot/cloneplot.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var extendFlat = Lib.extendFlat;
      var extendDeep = Lib.extendDeep;
      function cloneLayoutOverride(tileClass) {
        var override;
        switch (tileClass) {
          case "themes__thumb":
            override = {
              autosize: true,
              width: 150,
              height: 150,
              title: { text: "" },
              showlegend: false,
              margin: { l: 5, r: 5, t: 5, b: 5, pad: 0 },
              annotations: []
            };
            break;
          case "thumbnail":
            override = {
              title: { text: "" },
              hidesources: true,
              showlegend: false,
              borderwidth: 0,
              bordercolor: "",
              margin: { l: 1, r: 1, t: 1, b: 1, pad: 0 },
              annotations: []
            };
            break;
          default:
            override = {};
        }
        return override;
      }
      function keyIsAxis(keyName) {
        var types = ["xaxis", "yaxis", "zaxis"];
        return types.indexOf(keyName.slice(0, 5)) > -1;
      }
      module.exports = function clonePlot(graphObj, options) {
        var i;
        var oldData = graphObj.data;
        var oldLayout = graphObj.layout;
        var newData = extendDeep([], oldData);
        var newLayout = extendDeep({}, oldLayout, cloneLayoutOverride(options.tileClass));
        var context = graphObj._context || {};
        if (options.width) newLayout.width = options.width;
        if (options.height) newLayout.height = options.height;
        if (options.tileClass === "thumbnail" || options.tileClass === "themes__thumb") {
          newLayout.annotations = [];
          var keys = Object.keys(newLayout);
          for (i = 0; i < keys.length; i++) {
            if (keyIsAxis(keys[i])) {
              newLayout[keys[i]].title = { text: "" };
            }
          }
          for (i = 0; i < newData.length; i++) {
            var trace = newData[i];
            trace.showscale = false;
            if (trace.marker) trace.marker.showscale = false;
            if (Registry.traceIs(trace, "pie-like")) trace.textposition = "none";
          }
        }
        if (Array.isArray(options.annotations)) {
          for (i = 0; i < options.annotations.length; i++) {
            newLayout.annotations.push(options.annotations[i]);
          }
        }
        var sceneIds = Object.keys(newLayout).filter(function(key) {
          return key.match(/^scene\d*$/);
        });
        if (sceneIds.length) {
          var axesImageOverride = {};
          if (options.tileClass === "thumbnail") {
            axesImageOverride = {
              title: { text: "" },
              showaxeslabels: false,
              showticklabels: false,
              linetickenable: false
            };
          }
          for (i = 0; i < sceneIds.length; i++) {
            var scene = newLayout[sceneIds[i]];
            if (!scene.xaxis) {
              scene.xaxis = {};
            }
            if (!scene.yaxis) {
              scene.yaxis = {};
            }
            if (!scene.zaxis) {
              scene.zaxis = {};
            }
            extendFlat(scene.xaxis, axesImageOverride);
            extendFlat(scene.yaxis, axesImageOverride);
            extendFlat(scene.zaxis, axesImageOverride);
            scene._scene = null;
          }
        }
        var gd = document.createElement("div");
        if (options.tileClass) gd.className = options.tileClass;
        var plotTile = {
          gd,
          td: gd,
          // for external (image server) compatibility
          layout: newLayout,
          data: newData,
          config: {
            staticPlot: options.staticPlot === void 0 ? true : options.staticPlot,
            plotGlPixelRatio: options.plotGlPixelRatio === void 0 ? 2 : options.plotGlPixelRatio,
            displaylogo: options.displaylogo || false,
            showLink: options.showLink || false,
            showTips: options.showTips || false,
            mapboxAccessToken: context.mapboxAccessToken
          }
        };
        if (options.setBackground !== "transparent") {
          plotTile.config.setBackground = options.setBackground || "opaque";
        }
        plotTile.gd.defaultLayout = cloneLayoutOverride(options.tileClass);
        return plotTile;
      };
    }
  });

  // src/snapshot/toimage.js
  var require_toimage = __commonJS({
    "src/snapshot/toimage.js"(exports, module) {
      "use strict";
      var EventEmitter = require_events().EventEmitter;
      var Registry = require_registry();
      var Lib = require_lib();
      var helpers = require_helpers10();
      var clonePlot = require_cloneplot();
      var toSVG = require_tosvg();
      var svgToImg = require_svgtoimg();
      function toImage(gd, opts) {
        var ev = new EventEmitter();
        var clone = clonePlot(gd, { format: "png" });
        var clonedGd = clone.gd;
        clonedGd.style.position = "absolute";
        clonedGd.style.left = "-5000px";
        document.body.appendChild(clonedGd);
        function wait() {
          var delay = helpers.getDelay(clonedGd._fullLayout);
          setTimeout(function() {
            var svg = toSVG(clonedGd);
            var canvas = document.createElement("canvas");
            canvas.id = Lib.randstr();
            ev = svgToImg({
              format: opts.format,
              width: clonedGd._fullLayout.width,
              height: clonedGd._fullLayout.height,
              canvas,
              emitter: ev,
              svg
            });
            ev.clean = function() {
              if (clonedGd) document.body.removeChild(clonedGd);
            };
          }, delay);
        }
        var redrawFunc = helpers.getRedrawFunc(clonedGd);
        Registry.call("_doPlot", clonedGd, clone.data, clone.layout, clone.config).then(redrawFunc).then(wait).catch(function(err) {
          ev.emit("error", err);
        });
        return ev;
      }
      module.exports = toImage;
    }
  });

  // src/snapshot/index.js
  var require_snapshot = __commonJS({
    "src/snapshot/index.js"(exports, module) {
      "use strict";
      var helpers = require_helpers10();
      var Snapshot = {
        getDelay: helpers.getDelay,
        getRedrawFunc: helpers.getRedrawFunc,
        clone: require_cloneplot(),
        toSVG: require_tosvg(),
        svgToImg: require_svgtoimg(),
        toImage: require_toimage(),
        downloadImage: require_download()
      };
      module.exports = Snapshot;
    }
  });

  // src/core.js
  var require_core = __commonJS({
    "src/core.js"(exports) {
      "use strict";
      exports.version = require_version().version;
      require_npo_src();
      require_plotcss();
      var Registry = require_registry();
      var register = exports.register = Registry.register;
      var plotApi = require_plot_api2();
      var methodNames = Object.keys(plotApi);
      for (i = 0; i < methodNames.length; i++) {
        name = methodNames[i];
        if (name.charAt(0) !== "_") exports[name] = plotApi[name];
        register({
          moduleType: "apiMethod",
          name,
          fn: plotApi[name]
        });
      }
      var name;
      var i;
      register(require_scatter());
      register([
        require_annotations(),
        require_annotations3d(),
        require_selections(),
        require_shapes(),
        require_images(),
        require_updatemenus(),
        require_sliders(),
        require_rangeslider(),
        require_rangeselector(),
        require_grid(),
        require_errorbars(),
        require_colorscale(),
        require_colorbar(),
        require_legend(),
        // legend needs to come after shape | legend defaults depends on shapes
        require_fx(),
        // fx needs to come after legend | unified hover defaults depends on legends
        require_modebar2()
      ]);
      register([
        require_locale_en(),
        require_locale_en_us()
      ]);
      if (window.PlotlyLocales && Array.isArray(window.PlotlyLocales)) {
        register(window.PlotlyLocales);
        delete window.PlotlyLocales;
      }
      exports.Icons = require_ploticon();
      var Fx = require_fx();
      var Plots = require_plots();
      exports.Plots = {
        resize: Plots.resize,
        graphJson: Plots.graphJson,
        sendDataToCloud: Plots.sendDataToCloud
      };
      exports.Fx = {
        hover: Fx.hover,
        unhover: Fx.unhover,
        loneHover: Fx.loneHover,
        loneUnhover: Fx.loneUnhover
      };
      exports.Snapshot = require_snapshot();
      exports.PlotSchema = require_plot_schema();
    }
  });

  // lib/core.js
  var require_core2 = __commonJS({
    "lib/core.js"(exports, module) {
      "use strict";
      module.exports = require_core();
    }
  });

  // src/traces/scattergeo/attributes.js
  var require_attributes23 = __commonJS({
    "src/traces/scattergeo/attributes.js"(exports, module) {
      "use strict";
      var hovertemplateAttrs = require_template_attributes().hovertemplateAttrs;
      var texttemplateAttrs = require_template_attributes().texttemplateAttrs;
      var makeFillcolorAttr = require_fillcolor_attribute();
      var scatterAttrs = require_attributes12();
      var baseAttrs = require_attributes2();
      var colorAttributes = require_attributes8();
      var dash = require_attributes4().dash;
      var extendFlat = require_extend().extendFlat;
      var overrideAll = require_edit_types().overrideAll;
      var scatterMarkerAttrs = scatterAttrs.marker;
      var scatterLineAttrs = scatterAttrs.line;
      var scatterMarkerLineAttrs = scatterMarkerAttrs.line;
      module.exports = overrideAll({
        lon: {
          valType: "data_array"
        },
        lat: {
          valType: "data_array"
        },
        locations: {
          valType: "data_array"
        },
        locationmode: {
          valType: "enumerated",
          values: ["ISO-3", "USA-states", "country names", "geojson-id"],
          dflt: "ISO-3"
        },
        geojson: {
          valType: "any",
          editType: "calc"
        },
        featureidkey: {
          valType: "string",
          editType: "calc",
          dflt: "id"
        },
        mode: extendFlat({}, scatterAttrs.mode, { dflt: "markers" }),
        text: extendFlat({}, scatterAttrs.text, {}),
        texttemplate: texttemplateAttrs({ editType: "plot" }, {
          keys: ["lat", "lon", "location", "text"]
        }),
        hovertext: extendFlat({}, scatterAttrs.hovertext, {}),
        textfont: scatterAttrs.textfont,
        textposition: scatterAttrs.textposition,
        line: {
          color: scatterLineAttrs.color,
          width: scatterLineAttrs.width,
          dash
        },
        connectgaps: scatterAttrs.connectgaps,
        marker: extendFlat(
          {
            symbol: scatterMarkerAttrs.symbol,
            opacity: scatterMarkerAttrs.opacity,
            angle: scatterMarkerAttrs.angle,
            angleref: extendFlat({}, scatterMarkerAttrs.angleref, {
              values: ["previous", "up", "north"]
            }),
            standoff: scatterMarkerAttrs.standoff,
            size: scatterMarkerAttrs.size,
            sizeref: scatterMarkerAttrs.sizeref,
            sizemin: scatterMarkerAttrs.sizemin,
            sizemode: scatterMarkerAttrs.sizemode,
            colorbar: scatterMarkerAttrs.colorbar,
            line: extendFlat(
              {
                width: scatterMarkerLineAttrs.width
              },
              colorAttributes("marker.line")
            ),
            gradient: scatterMarkerAttrs.gradient
          },
          colorAttributes("marker")
        ),
        fill: {
          valType: "enumerated",
          values: ["none", "toself"],
          dflt: "none"
        },
        fillcolor: makeFillcolorAttr(),
        selected: scatterAttrs.selected,
        unselected: scatterAttrs.unselected,
        hoverinfo: extendFlat({}, baseAttrs.hoverinfo, {
          flags: ["lon", "lat", "location", "text", "name"]
        }),
        hovertemplate: hovertemplateAttrs()
      }, "calc", "nested");
    }
  });

  // src/traces/scattergeo/defaults.js
  var require_defaults19 = __commonJS({
    "src/traces/scattergeo/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var subTypes = require_subtypes();
      var handleMarkerDefaults = require_marker_defaults();
      var handleLineDefaults = require_line_defaults();
      var handleTextDefaults = require_text_defaults();
      var handleFillColorDefaults = require_fillcolor_defaults();
      var attributes = require_attributes23();
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        var locations = coerce("locations");
        var len;
        if (locations && locations.length) {
          var geojson = coerce("geojson");
          var locationmodeDflt;
          if (typeof geojson === "string" && geojson !== "" || Lib.isPlainObject(geojson)) {
            locationmodeDflt = "geojson-id";
          }
          var locationMode = coerce("locationmode", locationmodeDflt);
          if (locationMode === "geojson-id") {
            coerce("featureidkey");
          }
          len = locations.length;
        } else {
          var lon = coerce("lon") || [];
          var lat = coerce("lat") || [];
          len = Math.min(lon.length, lat.length);
        }
        if (!len) {
          traceOut.visible = false;
          return;
        }
        traceOut._length = len;
        coerce("text");
        coerce("hovertext");
        coerce("hovertemplate");
        coerce("mode");
        if (subTypes.hasMarkers(traceOut)) {
          handleMarkerDefaults(traceIn, traceOut, defaultColor, layout, coerce, { gradient: true });
        }
        if (subTypes.hasLines(traceOut)) {
          handleLineDefaults(traceIn, traceOut, defaultColor, layout, coerce);
          coerce("connectgaps");
        }
        if (subTypes.hasText(traceOut)) {
          coerce("texttemplate");
          handleTextDefaults(traceIn, traceOut, layout, coerce);
        }
        coerce("fill");
        if (traceOut.fill !== "none") {
          handleFillColorDefaults(traceIn, traceOut, defaultColor, coerce);
        }
        Lib.coerceSelectionMarkerOpacity(traceOut, coerce);
      };
    }
  });

  // src/traces/scattergeo/format_labels.js
  var require_format_labels2 = __commonJS({
    "src/traces/scattergeo/format_labels.js"(exports, module) {
      "use strict";
      var Axes = require_axes();
      module.exports = function formatLabels(cdi, trace, fullLayout) {
        var labels = {};
        var geo = fullLayout[trace.geo]._subplot;
        var ax = geo.mockAxis;
        var lonlat = cdi.lonlat;
        labels.lonLabel = Axes.tickText(ax, ax.c2l(lonlat[0]), true).text;
        labels.latLabel = Axes.tickText(ax, ax.c2l(lonlat[1]), true).text;
        return labels;
      };
    }
  });

  // src/traces/scattergeo/calc.js
  var require_calc5 = __commonJS({
    "src/traces/scattergeo/calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var BADNUM = require_numerical().BADNUM;
      var calcMarkerColorscale = require_colorscale_calc();
      var arraysToCalcdata = require_arrays_to_calcdata();
      var calcSelection = require_calc_selection();
      var isArrayOrTypedArray = require_lib().isArrayOrTypedArray;
      var _ = require_lib()._;
      function isNonBlankString(v) {
        return v && typeof v === "string";
      }
      module.exports = function calc(gd, trace) {
        var hasLocationData = isArrayOrTypedArray(trace.locations);
        var len = hasLocationData ? trace.locations.length : trace._length;
        var calcTrace = new Array(len);
        var isValidLoc;
        if (trace.geojson) {
          isValidLoc = function(v) {
            return isNonBlankString(v) || isNumeric(v);
          };
        } else {
          isValidLoc = isNonBlankString;
        }
        for (var i = 0; i < len; i++) {
          var calcPt = calcTrace[i] = {};
          if (hasLocationData) {
            var loc = trace.locations[i];
            calcPt.loc = isValidLoc(loc) ? loc : null;
          } else {
            var lon = trace.lon[i];
            var lat = trace.lat[i];
            if (isNumeric(lon) && isNumeric(lat)) calcPt.lonlat = [+lon, +lat];
            else calcPt.lonlat = [BADNUM, BADNUM];
          }
        }
        arraysToCalcdata(calcTrace, trace);
        calcMarkerColorscale(gd, trace);
        calcSelection(calcTrace, trace);
        if (len) {
          calcTrace[0].t = {
            labels: {
              lat: _(gd, "lat:") + " ",
              lon: _(gd, "lon:") + " "
            }
          };
        }
        return calcTrace;
      };
    }
  });

  // src/plots/geo/constants.js
  var require_constants14 = __commonJS({
    "src/plots/geo/constants.js"(exports) {
      "use strict";
      exports.projNames = {
        airy: "airy",
        aitoff: "aitoff",
        "albers usa": "albersUsa",
        albers: "albers",
        // 'armadillo': 'armadillo',
        august: "august",
        "azimuthal equal area": "azimuthalEqualArea",
        "azimuthal equidistant": "azimuthalEquidistant",
        baker: "baker",
        // 'berghaus': 'berghaus',
        bertin1953: "bertin1953",
        boggs: "boggs",
        bonne: "bonne",
        bottomley: "bottomley",
        bromley: "bromley",
        // 'chamberlin africa': 'chamberlinAfrica',
        // 'chamberlin': 'chamberlin',
        collignon: "collignon",
        "conic conformal": "conicConformal",
        "conic equal area": "conicEqualArea",
        "conic equidistant": "conicEquidistant",
        craig: "craig",
        craster: "craster",
        "cylindrical equal area": "cylindricalEqualArea",
        "cylindrical stereographic": "cylindricalStereographic",
        eckert1: "eckert1",
        eckert2: "eckert2",
        eckert3: "eckert3",
        eckert4: "eckert4",
        eckert5: "eckert5",
        eckert6: "eckert6",
        eisenlohr: "eisenlohr",
        "equal earth": "equalEarth",
        equirectangular: "equirectangular",
        fahey: "fahey",
        "foucaut sinusoidal": "foucautSinusoidal",
        foucaut: "foucaut",
        // 'gilbert': 'gilbert',
        // 'gingery': 'gingery',
        ginzburg4: "ginzburg4",
        ginzburg5: "ginzburg5",
        ginzburg6: "ginzburg6",
        ginzburg8: "ginzburg8",
        ginzburg9: "ginzburg9",
        gnomonic: "gnomonic",
        "gringorten quincuncial": "gringortenQuincuncial",
        gringorten: "gringorten",
        guyou: "guyou",
        // 'hammer retroazimuthal': 'hammerRetroazimuthal',
        hammer: "hammer",
        // 'healpix': 'healpix',
        hill: "hill",
        homolosine: "homolosine",
        hufnagel: "hufnagel",
        hyperelliptical: "hyperelliptical",
        // 'interrupted boggs': 'interruptedBoggs',
        // 'interrupted homolosine': 'interruptedHomolosine',
        // 'interrupted mollweide hemispheres': 'interruptedMollweideHemispheres',
        // 'interrupted mollweide': 'interruptedMollweide',
        // 'interrupted quartic authalic': 'interruptedQuarticAuthalic',
        // 'interrupted sinu mollweide': 'interruptedSinuMollweide',
        // 'interrupted sinusoidal': 'interruptedSinusoidal',
        kavrayskiy7: "kavrayskiy7",
        lagrange: "lagrange",
        larrivee: "larrivee",
        laskowski: "laskowski",
        // 'littrow': 'littrow',
        loximuthal: "loximuthal",
        mercator: "mercator",
        miller: "miller",
        // 'modified stereographic alaska': 'modifiedStereographicAlaska',
        // 'modified stereographic gs48': 'modifiedStereographicGs48',
        // 'modified stereographic gs50': 'modifiedStereographicGs50',
        // 'modified stereographic lee': 'modifiedStereographicLee',
        // 'modified stereographic miller': 'modifiedStereographicMiller',
        // 'modified stereographic': 'modifiedStereographic',
        mollweide: "mollweide",
        "mt flat polar parabolic": "mtFlatPolarParabolic",
        "mt flat polar quartic": "mtFlatPolarQuartic",
        "mt flat polar sinusoidal": "mtFlatPolarSinusoidal",
        "natural earth": "naturalEarth",
        "natural earth1": "naturalEarth1",
        "natural earth2": "naturalEarth2",
        "nell hammer": "nellHammer",
        nicolosi: "nicolosi",
        orthographic: "orthographic",
        patterson: "patterson",
        "peirce quincuncial": "peirceQuincuncial",
        polyconic: "polyconic",
        // 'polyhedral butterfly': 'polyhedralButterfly',
        // 'polyhedral collignon': 'polyhedralCollignon',
        // 'polyhedral waterman': 'polyhedralWaterman',
        "rectangular polyconic": "rectangularPolyconic",
        robinson: "robinson",
        satellite: "satellite",
        "sinu mollweide": "sinuMollweide",
        sinusoidal: "sinusoidal",
        stereographic: "stereographic",
        times: "times",
        "transverse mercator": "transverseMercator",
        // 'two point azimuthalUsa': 'twoPointAzimuthalUsa',
        // 'two point azimuthal': 'twoPointAzimuthal',
        // 'two point equidistantUsa': 'twoPointEquidistantUsa',
        // 'two point equidistant': 'twoPointEquidistant',
        "van der grinten": "vanDerGrinten",
        "van der grinten2": "vanDerGrinten2",
        "van der grinten3": "vanDerGrinten3",
        "van der grinten4": "vanDerGrinten4",
        wagner4: "wagner4",
        wagner6: "wagner6",
        // 'wagner7': 'wagner7',
        // 'wagner': 'wagner',
        wiechel: "wiechel",
        "winkel tripel": "winkel3",
        winkel3: "winkel3"
      };
      exports.axesNames = ["lonaxis", "lataxis"];
      exports.lonaxisSpan = {
        orthographic: 180,
        "azimuthal equal area": 360,
        "azimuthal equidistant": 360,
        "conic conformal": 180,
        gnomonic: 160,
        stereographic: 180,
        "transverse mercator": 180,
        "*": 360
      };
      exports.lataxisSpan = {
        "conic conformal": 150,
        stereographic: 179.5,
        "*": 180
      };
      exports.scopeDefaults = {
        world: {
          lonaxisRange: [-180, 180],
          lataxisRange: [-90, 90],
          projType: "equirectangular",
          projRotate: [0, 0, 0]
        },
        usa: {
          lonaxisRange: [-180, -50],
          lataxisRange: [15, 80],
          projType: "albers usa"
        },
        europe: {
          lonaxisRange: [-30, 60],
          lataxisRange: [30, 85],
          projType: "conic conformal",
          projRotate: [15, 0, 0],
          projParallels: [0, 60]
        },
        asia: {
          lonaxisRange: [22, 160],
          lataxisRange: [-15, 55],
          projType: "mercator",
          projRotate: [0, 0, 0]
        },
        africa: {
          lonaxisRange: [-30, 60],
          lataxisRange: [-40, 40],
          projType: "mercator",
          projRotate: [0, 0, 0]
        },
        "north america": {
          lonaxisRange: [-180, -45],
          lataxisRange: [5, 85],
          projType: "conic conformal",
          projRotate: [-100, 0, 0],
          projParallels: [29.5, 45.5]
        },
        "south america": {
          lonaxisRange: [-100, -30],
          lataxisRange: [-60, 15],
          projType: "mercator",
          projRotate: [0, 0, 0]
        }
      };
      exports.clipPad = 1e-3;
      exports.precision = 0.1;
      exports.landColor = "#F0DC82";
      exports.waterColor = "#3399FF";
      exports.locationmodeToLayer = {
        "ISO-3": "countries",
        "USA-states": "subunits",
        "country names": "countries"
      };
      exports.sphereSVG = { type: "Sphere" };
      exports.fillLayers = {
        ocean: 1,
        land: 1,
        lakes: 1
      };
      exports.lineLayers = {
        subunits: 1,
        countries: 1,
        coastlines: 1,
        rivers: 1,
        frame: 1
      };
      exports.layers = [
        "bg",
        "ocean",
        "land",
        "lakes",
        "subunits",
        "countries",
        "coastlines",
        "rivers",
        "lataxis",
        "lonaxis",
        "frame",
        "backplot",
        "frontplot"
      ];
      exports.layersForChoropleth = [
        "bg",
        "ocean",
        "land",
        "subunits",
        "countries",
        "coastlines",
        "lataxis",
        "lonaxis",
        "frame",
        "backplot",
        "rivers",
        "lakes",
        "frontplot"
      ];
      exports.layerNameToAdjective = {
        ocean: "ocean",
        land: "land",
        lakes: "lake",
        subunits: "subunit",
        countries: "country",
        coastlines: "coastline",
        rivers: "river",
        frame: "frame"
      };
    }
  });

  // node_modules/topojson-client/dist/topojson-client.js
  var require_topojson_client = __commonJS({
    "node_modules/topojson-client/dist/topojson-client.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && false ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.topojson = global2.topojson || {}));
      })(exports, function(exports2) {
        "use strict";
        function identity(x) {
          return x;
        }
        function transform(transform2) {
          if (transform2 == null) return identity;
          var x0, y0, kx = transform2.scale[0], ky = transform2.scale[1], dx = transform2.translate[0], dy = transform2.translate[1];
          return function(input, i) {
            if (!i) x0 = y0 = 0;
            var j = 2, n = input.length, output = new Array(n);
            output[0] = (x0 += input[0]) * kx + dx;
            output[1] = (y0 += input[1]) * ky + dy;
            while (j < n) output[j] = input[j], ++j;
            return output;
          };
        }
        function bbox(topology) {
          var t = transform(topology.transform), key, x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;
          function bboxPoint(p) {
            p = t(p);
            if (p[0] < x0) x0 = p[0];
            if (p[0] > x1) x1 = p[0];
            if (p[1] < y0) y0 = p[1];
            if (p[1] > y1) y1 = p[1];
          }
          function bboxGeometry(o) {
            switch (o.type) {
              case "GeometryCollection":
                o.geometries.forEach(bboxGeometry);
                break;
              case "Point":
                bboxPoint(o.coordinates);
                break;
              case "MultiPoint":
                o.coordinates.forEach(bboxPoint);
                break;
            }
          }
          topology.arcs.forEach(function(arc) {
            var i = -1, n = arc.length, p;
            while (++i < n) {
              p = t(arc[i], i);
              if (p[0] < x0) x0 = p[0];
              if (p[0] > x1) x1 = p[0];
              if (p[1] < y0) y0 = p[1];
              if (p[1] > y1) y1 = p[1];
            }
          });
          for (key in topology.objects) {
            bboxGeometry(topology.objects[key]);
          }
          return [x0, y0, x1, y1];
        }
        function reverse(array, n) {
          var t, j = array.length, i = j - n;
          while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
        }
        function feature(topology, o) {
          if (typeof o === "string") o = topology.objects[o];
          return o.type === "GeometryCollection" ? { type: "FeatureCollection", features: o.geometries.map(function(o2) {
            return feature$1(topology, o2);
          }) } : feature$1(topology, o);
        }
        function feature$1(topology, o) {
          var id = o.id, bbox2 = o.bbox, properties = o.properties == null ? {} : o.properties, geometry = object(topology, o);
          return id == null && bbox2 == null ? { type: "Feature", properties, geometry } : bbox2 == null ? { type: "Feature", id, properties, geometry } : { type: "Feature", id, bbox: bbox2, properties, geometry };
        }
        function object(topology, o) {
          var transformPoint = transform(topology.transform), arcs = topology.arcs;
          function arc(i, points) {
            if (points.length) points.pop();
            for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
              points.push(transformPoint(a[k], k));
            }
            if (i < 0) reverse(points, n);
          }
          function point(p) {
            return transformPoint(p);
          }
          function line(arcs2) {
            var points = [];
            for (var i = 0, n = arcs2.length; i < n; ++i) arc(arcs2[i], points);
            if (points.length < 2) points.push(points[0]);
            return points;
          }
          function ring(arcs2) {
            var points = line(arcs2);
            while (points.length < 4) points.push(points[0]);
            return points;
          }
          function polygon(arcs2) {
            return arcs2.map(ring);
          }
          function geometry(o2) {
            var type = o2.type, coordinates;
            switch (type) {
              case "GeometryCollection":
                return { type, geometries: o2.geometries.map(geometry) };
              case "Point":
                coordinates = point(o2.coordinates);
                break;
              case "MultiPoint":
                coordinates = o2.coordinates.map(point);
                break;
              case "LineString":
                coordinates = line(o2.arcs);
                break;
              case "MultiLineString":
                coordinates = o2.arcs.map(line);
                break;
              case "Polygon":
                coordinates = polygon(o2.arcs);
                break;
              case "MultiPolygon":
                coordinates = o2.arcs.map(polygon);
                break;
              default:
                return null;
            }
            return { type, coordinates };
          }
          return geometry(o);
        }
        function stitch(topology, arcs) {
          var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
          arcs.forEach(function(i, j) {
            var arc = topology.arcs[i < 0 ? ~i : i], t;
            if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
              t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
            }
          });
          arcs.forEach(function(i) {
            var e = ends(i), start = e[0], end = e[1], f, g;
            if (f = fragmentByEnd[start]) {
              delete fragmentByEnd[f.end];
              f.push(i);
              f.end = end;
              if (g = fragmentByStart[end]) {
                delete fragmentByStart[g.start];
                var fg = g === f ? f : f.concat(g);
                fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
              } else {
                fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
              }
            } else if (f = fragmentByStart[end]) {
              delete fragmentByStart[f.start];
              f.unshift(i);
              f.start = start;
              if (g = fragmentByEnd[start]) {
                delete fragmentByEnd[g.end];
                var gf = g === f ? f : g.concat(f);
                fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
              } else {
                fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
              }
            } else {
              f = [i];
              fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
            }
          });
          function ends(i) {
            var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
            if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) {
              p1[0] += dp[0], p1[1] += dp[1];
            });
            else p1 = arc[arc.length - 1];
            return i < 0 ? [p1, p0] : [p0, p1];
          }
          function flush(fragmentByEnd2, fragmentByStart2) {
            for (var k in fragmentByEnd2) {
              var f = fragmentByEnd2[k];
              delete fragmentByStart2[f.start];
              delete f.start;
              delete f.end;
              f.forEach(function(i) {
                stitchedArcs[i < 0 ? ~i : i] = 1;
              });
              fragments.push(f);
            }
          }
          flush(fragmentByEnd, fragmentByStart);
          flush(fragmentByStart, fragmentByEnd);
          arcs.forEach(function(i) {
            if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);
          });
          return fragments;
        }
        function mesh(topology) {
          return object(topology, meshArcs.apply(this, arguments));
        }
        function meshArcs(topology, object2, filter) {
          var arcs, i, n;
          if (arguments.length > 1) arcs = extractArcs(topology, object2, filter);
          else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
          return { type: "MultiLineString", arcs: stitch(topology, arcs) };
        }
        function extractArcs(topology, object2, filter) {
          var arcs = [], geomsByArc = [], geom;
          function extract0(i) {
            var j = i < 0 ? ~i : i;
            (geomsByArc[j] || (geomsByArc[j] = [])).push({ i, g: geom });
          }
          function extract1(arcs2) {
            arcs2.forEach(extract0);
          }
          function extract2(arcs2) {
            arcs2.forEach(extract1);
          }
          function extract3(arcs2) {
            arcs2.forEach(extract2);
          }
          function geometry(o) {
            switch (geom = o, o.type) {
              case "GeometryCollection":
                o.geometries.forEach(geometry);
                break;
              case "LineString":
                extract1(o.arcs);
                break;
              case "MultiLineString":
              case "Polygon":
                extract2(o.arcs);
                break;
              case "MultiPolygon":
                extract3(o.arcs);
                break;
            }
          }
          geometry(object2);
          geomsByArc.forEach(filter == null ? function(geoms) {
            arcs.push(geoms[0].i);
          } : function(geoms) {
            if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);
          });
          return arcs;
        }
        function planarRingArea(ring) {
          var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
          while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
          return Math.abs(area);
        }
        function merge(topology) {
          return object(topology, mergeArcs.apply(this, arguments));
        }
        function mergeArcs(topology, objects) {
          var polygonsByArc = {}, polygons = [], groups = [];
          objects.forEach(geometry);
          function geometry(o) {
            switch (o.type) {
              case "GeometryCollection":
                o.geometries.forEach(geometry);
                break;
              case "Polygon":
                extract(o.arcs);
                break;
              case "MultiPolygon":
                o.arcs.forEach(extract);
                break;
            }
          }
          function extract(polygon) {
            polygon.forEach(function(ring) {
              ring.forEach(function(arc) {
                (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
              });
            });
            polygons.push(polygon);
          }
          function area(ring) {
            return planarRingArea(object(topology, { type: "Polygon", arcs: [ring] }).coordinates[0]);
          }
          polygons.forEach(function(polygon) {
            if (!polygon._) {
              var group = [], neighbors2 = [polygon];
              polygon._ = 1;
              groups.push(group);
              while (polygon = neighbors2.pop()) {
                group.push(polygon);
                polygon.forEach(function(ring) {
                  ring.forEach(function(arc) {
                    polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon2) {
                      if (!polygon2._) {
                        polygon2._ = 1;
                        neighbors2.push(polygon2);
                      }
                    });
                  });
                });
              }
            }
          });
          polygons.forEach(function(polygon) {
            delete polygon._;
          });
          return {
            type: "MultiPolygon",
            arcs: groups.map(function(polygons2) {
              var arcs = [], n;
              polygons2.forEach(function(polygon) {
                polygon.forEach(function(ring) {
                  ring.forEach(function(arc) {
                    if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                      arcs.push(arc);
                    }
                  });
                });
              });
              arcs = stitch(topology, arcs);
              if ((n = arcs.length) > 1) {
                for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
                  if ((ki = area(arcs[i])) > k) {
                    t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
                  }
                }
              }
              return arcs;
            }).filter(function(arcs) {
              return arcs.length > 0;
            })
          };
        }
        function bisect(a, x) {
          var lo = 0, hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (a[mid] < x) lo = mid + 1;
            else hi = mid;
          }
          return lo;
        }
        function neighbors(objects) {
          var indexesByArc = {}, neighbors2 = objects.map(function() {
            return [];
          });
          function line(arcs, i2) {
            arcs.forEach(function(a) {
              if (a < 0) a = ~a;
              var o = indexesByArc[a];
              if (o) o.push(i2);
              else indexesByArc[a] = [i2];
            });
          }
          function polygon(arcs, i2) {
            arcs.forEach(function(arc) {
              line(arc, i2);
            });
          }
          function geometry(o, i2) {
            if (o.type === "GeometryCollection") o.geometries.forEach(function(o2) {
              geometry(o2, i2);
            });
            else if (o.type in geometryType) geometryType[o.type](o.arcs, i2);
          }
          var geometryType = {
            LineString: line,
            MultiLineString: polygon,
            Polygon: polygon,
            MultiPolygon: function(arcs, i2) {
              arcs.forEach(function(arc) {
                polygon(arc, i2);
              });
            }
          };
          objects.forEach(geometry);
          for (var i in indexesByArc) {
            for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
              for (var k = j + 1; k < m; ++k) {
                var ij = indexes[j], ik = indexes[k], n;
                if ((n = neighbors2[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
                if ((n = neighbors2[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
              }
            }
          }
          return neighbors2;
        }
        function untransform(transform2) {
          if (transform2 == null) return identity;
          var x0, y0, kx = transform2.scale[0], ky = transform2.scale[1], dx = transform2.translate[0], dy = transform2.translate[1];
          return function(input, i) {
            if (!i) x0 = y0 = 0;
            var j = 2, n = input.length, output = new Array(n), x1 = Math.round((input[0] - dx) / kx), y1 = Math.round((input[1] - dy) / ky);
            output[0] = x1 - x0, x0 = x1;
            output[1] = y1 - y0, y0 = y1;
            while (j < n) output[j] = input[j], ++j;
            return output;
          };
        }
        function quantize(topology, transform2) {
          if (topology.transform) throw new Error("already quantized");
          if (!transform2 || !transform2.scale) {
            if (!((n = Math.floor(transform2)) >= 2)) throw new Error("n must be \u22652");
            box = topology.bbox || bbox(topology);
            var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;
            transform2 = { scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0] };
          } else {
            box = topology.bbox;
          }
          var t = untransform(transform2), box, key, inputs = topology.objects, outputs = {};
          function quantizePoint(point) {
            return t(point);
          }
          function quantizeGeometry(input) {
            var output;
            switch (input.type) {
              case "GeometryCollection":
                output = { type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry) };
                break;
              case "Point":
                output = { type: "Point", coordinates: quantizePoint(input.coordinates) };
                break;
              case "MultiPoint":
                output = { type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint) };
                break;
              default:
                return input;
            }
            if (input.id != null) output.id = input.id;
            if (input.bbox != null) output.bbox = input.bbox;
            if (input.properties != null) output.properties = input.properties;
            return output;
          }
          function quantizeArc(input) {
            var i = 0, j = 1, n2 = input.length, p, output = new Array(n2);
            output[0] = t(input[0], 0);
            while (++i < n2) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p;
            if (j === 1) output[j++] = [0, 0];
            output.length = j;
            return output;
          }
          for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);
          return {
            type: "Topology",
            bbox: box,
            transform: transform2,
            objects: outputs,
            arcs: topology.arcs.map(quantizeArc)
          };
        }
        exports2.bbox = bbox;
        exports2.feature = feature;
        exports2.merge = merge;
        exports2.mergeArcs = mergeArcs;
        exports2.mesh = mesh;
        exports2.meshArcs = meshArcs;
        exports2.neighbors = neighbors;
        exports2.quantize = quantize;
        exports2.transform = transform;
        exports2.untransform = untransform;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // src/lib/topojson_utils.js
  var require_topojson_utils = __commonJS({
    "src/lib/topojson_utils.js"(exports, module) {
      "use strict";
      var topojsonUtils = module.exports = {};
      var locationmodeToLayer = require_constants14().locationmodeToLayer;
      var topojsonFeature = require_topojson_client().feature;
      topojsonUtils.getTopojsonName = function(geoLayout) {
        return [
          geoLayout.scope.replace(/ /g, "-"),
          "_",
          geoLayout.resolution.toString(),
          "m"
        ].join("");
      };
      topojsonUtils.getTopojsonPath = function(topojsonURL, topojsonName) {
        return topojsonURL + topojsonName + ".json";
      };
      topojsonUtils.getTopojsonFeatures = function(trace, topojson) {
        var layer = locationmodeToLayer[trace.locationmode];
        var obj = topojson.objects[layer];
        return topojsonFeature(topojson, obj).features;
      };
    }
  });

  // src/lib/geojson_utils.js
  var require_geojson_utils = __commonJS({
    "src/lib/geojson_utils.js"(exports) {
      "use strict";
      var BADNUM = require_numerical().BADNUM;
      exports.calcTraceToLineCoords = function(calcTrace) {
        var trace = calcTrace[0].trace;
        var connectgaps = trace.connectgaps;
        var coords = [];
        var lineString = [];
        for (var i = 0; i < calcTrace.length; i++) {
          var calcPt = calcTrace[i];
          var lonlat = calcPt.lonlat;
          if (lonlat[0] !== BADNUM) {
            lineString.push(lonlat);
          } else if (!connectgaps && lineString.length > 0) {
            coords.push(lineString);
            lineString = [];
          }
        }
        if (lineString.length > 0) {
          coords.push(lineString);
        }
        return coords;
      };
      exports.makeLine = function(coords) {
        if (coords.length === 1) {
          return {
            type: "LineString",
            coordinates: coords[0]
          };
        } else {
          return {
            type: "MultiLineString",
            coordinates: coords
          };
        }
      };
      exports.makePolygon = function(coords) {
        if (coords.length === 1) {
          return {
            type: "Polygon",
            coordinates: coords
          };
        } else {
          var _coords = new Array(coords.length);
          for (var i = 0; i < coords.length; i++) {
            _coords[i] = [coords[i]];
          }
          return {
            type: "MultiPolygon",
            coordinates: _coords
          };
        }
      };
      exports.makeBlank = function() {
        return {
          type: "Point",
          coordinates: []
        };
      };
    }
  });

  // node_modules/country-regex/index.js
  var require_country_regex = __commonJS({
    "node_modules/country-regex/index.js"(exports, module) {
      module.exports = {
        AFG: "afghan",
        ALA: "\\b\\wland",
        ALB: "albania",
        DZA: "algeria",
        ASM: "^(?=.*americ).*samoa",
        AND: "andorra",
        AGO: "angola",
        AIA: "anguill?a",
        ATA: "antarctica",
        ATG: "antigua",
        ARG: "argentin",
        ARM: "armenia",
        ABW: "^(?!.*bonaire).*\\baruba",
        AUS: "australia",
        AUT: "^(?!.*hungary).*austria|\\baustri.*\\bemp",
        AZE: "azerbaijan",
        BHS: "bahamas",
        BHR: "bahrain",
        BGD: "bangladesh|^(?=.*east).*paki?stan",
        BRB: "barbados",
        BLR: "belarus|byelo",
        BEL: "^(?!.*luxem).*belgium",
        BLZ: "belize|^(?=.*british).*honduras",
        BEN: "benin|dahome",
        BMU: "bermuda",
        BTN: "bhutan",
        BOL: "bolivia",
        BES: "^(?=.*bonaire).*eustatius|^(?=.*carib).*netherlands|\\bbes.?islands",
        BIH: "herzegovina|bosnia",
        BWA: "botswana|bechuana",
        BVT: "bouvet",
        BRA: "brazil",
        IOT: "british.?indian.?ocean",
        BRN: "brunei",
        BGR: "bulgaria",
        BFA: "burkina|\\bfaso|upper.?volta",
        BDI: "burundi",
        CPV: "verde",
        KHM: "cambodia|kampuchea|khmer",
        CMR: "cameroon",
        CAN: "canada",
        CYM: "cayman",
        CAF: "\\bcentral.african.republic",
        TCD: "\\bchad",
        CHL: "\\bchile",
        CHN: "^(?!.*\\bmac)(?!.*\\bhong)(?!.*\\btai)(?!.*\\brep).*china|^(?=.*peo)(?=.*rep).*china",
        CXR: "christmas",
        CCK: "\\bcocos|keeling",
        COL: "colombia",
        COM: "comoro",
        COG: "^(?!.*\\bdem)(?!.*\\bd[\\.]?r)(?!.*kinshasa)(?!.*zaire)(?!.*belg)(?!.*l.opoldville)(?!.*free).*\\bcongo",
        COK: "\\bcook",
        CRI: "costa.?rica",
        CIV: "ivoire|ivory",
        HRV: "croatia",
        CUB: "\\bcuba",
        CUW: "^(?!.*bonaire).*\\bcura(c|\xE7)ao",
        CYP: "cyprus",
        CSK: "czechoslovakia",
        CZE: "^(?=.*rep).*czech|czechia|bohemia",
        COD: "\\bdem.*congo|congo.*\\bdem|congo.*\\bd[\\.]?r|\\bd[\\.]?r.*congo|belgian.?congo|congo.?free.?state|kinshasa|zaire|l.opoldville|drc|droc|rdc",
        DNK: "denmark",
        DJI: "djibouti",
        DMA: "dominica(?!n)",
        DOM: "dominican.rep",
        ECU: "ecuador",
        EGY: "egypt",
        SLV: "el.?salvador",
        GNQ: "guine.*eq|eq.*guine|^(?=.*span).*guinea",
        ERI: "eritrea",
        EST: "estonia",
        ETH: "ethiopia|abyssinia",
        FLK: "falkland|malvinas",
        FRO: "faroe|faeroe",
        FJI: "fiji",
        FIN: "finland",
        FRA: "^(?!.*\\bdep)(?!.*martinique).*france|french.?republic|\\bgaul",
        GUF: "^(?=.*french).*guiana",
        PYF: "french.?polynesia|tahiti",
        ATF: "french.?southern",
        GAB: "gabon",
        GMB: "gambia",
        GEO: "^(?!.*south).*georgia",
        DDR: "german.?democratic.?republic|democratic.?republic.*germany|east.germany",
        DEU: "^(?!.*east).*germany|^(?=.*\\bfed.*\\brep).*german",
        GHA: "ghana|gold.?coast",
        GIB: "gibraltar",
        GRC: "greece|hellenic|hellas",
        GRL: "greenland",
        GRD: "grenada",
        GLP: "guadeloupe",
        GUM: "\\bguam",
        GTM: "guatemala",
        GGY: "guernsey",
        GIN: "^(?!.*eq)(?!.*span)(?!.*bissau)(?!.*portu)(?!.*new).*guinea",
        GNB: "bissau|^(?=.*portu).*guinea",
        GUY: "guyana|british.?guiana",
        HTI: "haiti",
        HMD: "heard.*mcdonald",
        VAT: "holy.?see|vatican|papal.?st",
        HND: "^(?!.*brit).*honduras",
        HKG: "hong.?kong",
        HUN: "^(?!.*austr).*hungary",
        ISL: "iceland",
        IND: "india(?!.*ocea)",
        IDN: "indonesia",
        IRN: "\\biran|persia",
        IRQ: "\\biraq|mesopotamia",
        IRL: "(^ireland)|(^republic.*ireland)",
        IMN: "^(?=.*isle).*\\bman",
        ISR: "israel",
        ITA: "italy",
        JAM: "jamaica",
        JPN: "japan",
        JEY: "jersey",
        JOR: "jordan",
        KAZ: "kazak",
        KEN: "kenya|british.?east.?africa|east.?africa.?prot",
        KIR: "kiribati",
        PRK: "^(?=.*democrat|people|north|d.*p.*.r).*\\bkorea|dprk|korea.*(d.*p.*r)",
        KWT: "kuwait",
        KGZ: "kyrgyz|kirghiz",
        LAO: "\\blaos?\\b",
        LVA: "latvia",
        LBN: "lebanon",
        LSO: "lesotho|basuto",
        LBR: "liberia",
        LBY: "libya",
        LIE: "liechtenstein",
        LTU: "lithuania",
        LUX: "^(?!.*belg).*luxem",
        MAC: "maca(o|u)",
        MDG: "madagascar|malagasy",
        MWI: "malawi|nyasa",
        MYS: "malaysia",
        MDV: "maldive",
        MLI: "\\bmali\\b",
        MLT: "\\bmalta",
        MHL: "marshall",
        MTQ: "martinique",
        MRT: "mauritania",
        MUS: "mauritius",
        MYT: "\\bmayotte",
        MEX: "\\bmexic",
        FSM: "fed.*micronesia|micronesia.*fed",
        MCO: "monaco",
        MNG: "mongolia",
        MNE: "^(?!.*serbia).*montenegro",
        MSR: "montserrat",
        MAR: "morocco|\\bmaroc",
        MOZ: "mozambique",
        MMR: "myanmar|burma",
        NAM: "namibia",
        NRU: "nauru",
        NPL: "nepal",
        NLD: "^(?!.*\\bant)(?!.*\\bcarib).*netherlands",
        ANT: "^(?=.*\\bant).*(nether|dutch)",
        NCL: "new.?caledonia",
        NZL: "new.?zealand",
        NIC: "nicaragua",
        NER: "\\bniger(?!ia)",
        NGA: "nigeria",
        NIU: "niue",
        NFK: "norfolk",
        MNP: "mariana",
        NOR: "norway",
        OMN: "\\boman|trucial",
        PAK: "^(?!.*east).*paki?stan",
        PLW: "palau",
        PSE: "palestin|\\bgaza|west.?bank",
        PAN: "panama",
        PNG: "papua|new.?guinea",
        PRY: "paraguay",
        PER: "peru",
        PHL: "philippines",
        PCN: "pitcairn",
        POL: "poland",
        PRT: "portugal",
        PRI: "puerto.?rico",
        QAT: "qatar",
        KOR: "^(?!.*d.*p.*r)(?!.*democrat)(?!.*people)(?!.*north).*\\bkorea(?!.*d.*p.*r)",
        MDA: "moldov|b(a|e)ssarabia",
        REU: "r(e|\xE9)union",
        ROU: "r(o|u|ou)mania",
        RUS: "\\brussia|soviet.?union|u\\.?s\\.?s\\.?r|socialist.?republics",
        RWA: "rwanda",
        BLM: "barth(e|\xE9)lemy",
        SHN: "helena",
        KNA: "kitts|\\bnevis",
        LCA: "\\blucia",
        MAF: "^(?=.*collectivity).*martin|^(?=.*france).*martin(?!ique)|^(?=.*french).*martin(?!ique)",
        SPM: "miquelon",
        VCT: "vincent",
        WSM: "^(?!.*amer).*samoa",
        SMR: "san.?marino",
        STP: "\\bs(a|\xE3)o.?tom(e|\xE9)",
        SAU: "\\bsa\\w*.?arabia",
        SEN: "senegal",
        SRB: "^(?!.*monte).*serbia",
        SYC: "seychell",
        SLE: "sierra",
        SGP: "singapore",
        SXM: "^(?!.*martin)(?!.*saba).*maarten",
        SVK: "^(?!.*cze).*slovak",
        SVN: "slovenia",
        SLB: "solomon",
        SOM: "somali",
        ZAF: "south.africa|s\\\\..?africa",
        SGS: "south.?georgia|sandwich",
        SSD: "\\bs\\w*.?sudan",
        ESP: "spain",
        LKA: "sri.?lanka|ceylon",
        SDN: "^(?!.*\\bs(?!u)).*sudan",
        SUR: "surinam|dutch.?guiana",
        SJM: "svalbard",
        SWZ: "swaziland",
        SWE: "sweden",
        CHE: "switz|swiss",
        SYR: "syria",
        TWN: "taiwan|taipei|formosa|^(?!.*peo)(?=.*rep).*china",
        TJK: "tajik",
        THA: "thailand|\\bsiam",
        MKD: "macedonia|fyrom",
        TLS: "^(?=.*leste).*timor|^(?=.*east).*timor",
        TGO: "togo",
        TKL: "tokelau",
        TON: "tonga",
        TTO: "trinidad|tobago",
        TUN: "tunisia",
        TUR: "turkey",
        TKM: "turkmen",
        TCA: "turks",
        TUV: "tuvalu",
        UGA: "uganda",
        UKR: "ukrain",
        ARE: "emirates|^u\\.?a\\.?e\\.?$|united.?arab.?em",
        GBR: "united.?kingdom|britain|^u\\.?k\\.?$",
        TZA: "tanzania",
        USA: "united.?states\\b(?!.*islands)|\\bu\\.?s\\.?a\\.?\\b|^\\s*u\\.?s\\.?\\b(?!.*islands)",
        UMI: "minor.?outlying.?is",
        URY: "uruguay",
        UZB: "uzbek",
        VUT: "vanuatu|new.?hebrides",
        VEN: "venezuela",
        VNM: "^(?!.*republic).*viet.?nam|^(?=.*socialist).*viet.?nam",
        VGB: "^(?=.*\\bu\\.?\\s?k).*virgin|^(?=.*brit).*virgin|^(?=.*kingdom).*virgin",
        VIR: "^(?=.*\\bu\\.?\\s?s).*virgin|^(?=.*states).*virgin",
        WLF: "futuna|wallis",
        ESH: "western.sahara",
        YEM: "^(?!.*arab)(?!.*north)(?!.*sana)(?!.*peo)(?!.*dem)(?!.*south)(?!.*aden)(?!.*\\bp\\.?d\\.?r).*yemen",
        YMD: "^(?=.*peo).*yemen|^(?!.*rep)(?=.*dem).*yemen|^(?=.*south).*yemen|^(?=.*aden).*yemen|^(?=.*\\bp\\.?d\\.?r).*yemen",
        YUG: "yugoslavia",
        ZMB: "zambia|northern.?rhodesia",
        EAZ: "zanzibar",
        ZWE: "zimbabwe|^(?!.*northern).*rhodesia"
      };
    }
  });

  // node_modules/@turf/helpers/dist/cjs/index.cjs
  var require_cjs = __commonJS({
    "node_modules/@turf/helpers/dist/cjs/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var earthRadius = 63710088e-1;
      var factors = {
        centimeters: earthRadius * 100,
        centimetres: earthRadius * 100,
        degrees: 360 / (2 * Math.PI),
        feet: earthRadius * 3.28084,
        inches: earthRadius * 39.37,
        kilometers: earthRadius / 1e3,
        kilometres: earthRadius / 1e3,
        meters: earthRadius,
        metres: earthRadius,
        miles: earthRadius / 1609.344,
        millimeters: earthRadius * 1e3,
        millimetres: earthRadius * 1e3,
        nauticalmiles: earthRadius / 1852,
        radians: 1,
        yards: earthRadius * 1.0936
      };
      var areaFactors = {
        acres: 247105e-9,
        centimeters: 1e4,
        centimetres: 1e4,
        feet: 10.763910417,
        hectares: 1e-4,
        inches: 1550.003100006,
        kilometers: 1e-6,
        kilometres: 1e-6,
        meters: 1,
        metres: 1,
        miles: 386e-9,
        nauticalmiles: 29155334959812285e-23,
        millimeters: 1e6,
        millimetres: 1e6,
        yards: 1.195990046
      };
      function feature(geom, properties, options = {}) {
        const feat = { type: "Feature" };
        if (options.id === 0 || options.id) {
          feat.id = options.id;
        }
        if (options.bbox) {
          feat.bbox = options.bbox;
        }
        feat.properties = properties || {};
        feat.geometry = geom;
        return feat;
      }
      function geometry(type, coordinates, _options = {}) {
        switch (type) {
          case "Point":
            return point(coordinates).geometry;
          case "LineString":
            return lineString(coordinates).geometry;
          case "Polygon":
            return polygon(coordinates).geometry;
          case "MultiPoint":
            return multiPoint(coordinates).geometry;
          case "MultiLineString":
            return multiLineString(coordinates).geometry;
          case "MultiPolygon":
            return multiPolygon(coordinates).geometry;
          default:
            throw new Error(type + " is invalid");
        }
      }
      function point(coordinates, properties, options = {}) {
        if (!coordinates) {
          throw new Error("coordinates is required");
        }
        if (!Array.isArray(coordinates)) {
          throw new Error("coordinates must be an Array");
        }
        if (coordinates.length < 2) {
          throw new Error("coordinates must be at least 2 numbers long");
        }
        if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
          throw new Error("coordinates must contain numbers");
        }
        const geom = {
          type: "Point",
          coordinates
        };
        return feature(geom, properties, options);
      }
      function points(coordinates, properties, options = {}) {
        return featureCollection(
          coordinates.map((coords) => {
            return point(coords, properties);
          }),
          options
        );
      }
      function polygon(coordinates, properties, options = {}) {
        for (const ring of coordinates) {
          if (ring.length < 4) {
            throw new Error(
              "Each LinearRing of a Polygon must have 4 or more Positions."
            );
          }
          if (ring[ring.length - 1].length !== ring[0].length) {
            throw new Error("First and last Position are not equivalent.");
          }
          for (let j = 0; j < ring[ring.length - 1].length; j++) {
            if (ring[ring.length - 1][j] !== ring[0][j]) {
              throw new Error("First and last Position are not equivalent.");
            }
          }
        }
        const geom = {
          type: "Polygon",
          coordinates
        };
        return feature(geom, properties, options);
      }
      function polygons(coordinates, properties, options = {}) {
        return featureCollection(
          coordinates.map((coords) => {
            return polygon(coords, properties);
          }),
          options
        );
      }
      function lineString(coordinates, properties, options = {}) {
        if (coordinates.length < 2) {
          throw new Error("coordinates must be an array of two or more positions");
        }
        const geom = {
          type: "LineString",
          coordinates
        };
        return feature(geom, properties, options);
      }
      function lineStrings(coordinates, properties, options = {}) {
        return featureCollection(
          coordinates.map((coords) => {
            return lineString(coords, properties);
          }),
          options
        );
      }
      function featureCollection(features, options = {}) {
        const fc = { type: "FeatureCollection" };
        if (options.id) {
          fc.id = options.id;
        }
        if (options.bbox) {
          fc.bbox = options.bbox;
        }
        fc.features = features;
        return fc;
      }
      function multiLineString(coordinates, properties, options = {}) {
        const geom = {
          type: "MultiLineString",
          coordinates
        };
        return feature(geom, properties, options);
      }
      function multiPoint(coordinates, properties, options = {}) {
        const geom = {
          type: "MultiPoint",
          coordinates
        };
        return feature(geom, properties, options);
      }
      function multiPolygon(coordinates, properties, options = {}) {
        const geom = {
          type: "MultiPolygon",
          coordinates
        };
        return feature(geom, properties, options);
      }
      function geometryCollection(geometries, properties, options = {}) {
        const geom = {
          type: "GeometryCollection",
          geometries
        };
        return feature(geom, properties, options);
      }
      function round(num, precision = 0) {
        if (precision && !(precision >= 0)) {
          throw new Error("precision must be a positive number");
        }
        const multiplier = Math.pow(10, precision || 0);
        return Math.round(num * multiplier) / multiplier;
      }
      function radiansToLength(radians, units = "kilometers") {
        const factor = factors[units];
        if (!factor) {
          throw new Error(units + " units is invalid");
        }
        return radians * factor;
      }
      function lengthToRadians(distance, units = "kilometers") {
        const factor = factors[units];
        if (!factor) {
          throw new Error(units + " units is invalid");
        }
        return distance / factor;
      }
      function lengthToDegrees(distance, units) {
        return radiansToDegrees(lengthToRadians(distance, units));
      }
      function bearingToAzimuth(bearing) {
        let angle = bearing % 360;
        if (angle < 0) {
          angle += 360;
        }
        return angle;
      }
      function azimuthToBearing(angle) {
        angle = angle % 360;
        if (angle > 0)
          return angle > 180 ? angle - 360 : angle;
        return angle < -180 ? angle + 360 : angle;
      }
      function radiansToDegrees(radians) {
        const degrees = radians % (2 * Math.PI);
        return degrees * 180 / Math.PI;
      }
      function degreesToRadians(degrees) {
        const radians = degrees % 360;
        return radians * Math.PI / 180;
      }
      function convertLength(length, originalUnit = "kilometers", finalUnit = "kilometers") {
        if (!(length >= 0)) {
          throw new Error("length must be a positive number");
        }
        return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
      }
      function convertArea(area, originalUnit = "meters", finalUnit = "kilometers") {
        if (!(area >= 0)) {
          throw new Error("area must be a positive number");
        }
        const startFactor = areaFactors[originalUnit];
        if (!startFactor) {
          throw new Error("invalid original units");
        }
        const finalFactor = areaFactors[finalUnit];
        if (!finalFactor) {
          throw new Error("invalid final units");
        }
        return area / startFactor * finalFactor;
      }
      function isNumber(num) {
        return !isNaN(num) && num !== null && !Array.isArray(num);
      }
      function isObject(input) {
        return input !== null && typeof input === "object" && !Array.isArray(input);
      }
      function validateBBox(bbox) {
        if (!bbox) {
          throw new Error("bbox is required");
        }
        if (!Array.isArray(bbox)) {
          throw new Error("bbox must be an Array");
        }
        if (bbox.length !== 4 && bbox.length !== 6) {
          throw new Error("bbox must be an Array of 4 or 6 numbers");
        }
        bbox.forEach((num) => {
          if (!isNumber(num)) {
            throw new Error("bbox must only contain numbers");
          }
        });
      }
      function validateId(id) {
        if (!id) {
          throw new Error("id is required");
        }
        if (["string", "number"].indexOf(typeof id) === -1) {
          throw new Error("id must be a number or a string");
        }
      }
      exports.areaFactors = areaFactors;
      exports.azimuthToBearing = azimuthToBearing;
      exports.bearingToAzimuth = bearingToAzimuth;
      exports.convertArea = convertArea;
      exports.convertLength = convertLength;
      exports.degreesToRadians = degreesToRadians;
      exports.earthRadius = earthRadius;
      exports.factors = factors;
      exports.feature = feature;
      exports.featureCollection = featureCollection;
      exports.geometry = geometry;
      exports.geometryCollection = geometryCollection;
      exports.isNumber = isNumber;
      exports.isObject = isObject;
      exports.lengthToDegrees = lengthToDegrees;
      exports.lengthToRadians = lengthToRadians;
      exports.lineString = lineString;
      exports.lineStrings = lineStrings;
      exports.multiLineString = multiLineString;
      exports.multiPoint = multiPoint;
      exports.multiPolygon = multiPolygon;
      exports.point = point;
      exports.points = points;
      exports.polygon = polygon;
      exports.polygons = polygons;
      exports.radiansToDegrees = radiansToDegrees;
      exports.radiansToLength = radiansToLength;
      exports.round = round;
      exports.validateBBox = validateBBox;
      exports.validateId = validateId;
    }
  });

  // node_modules/@turf/meta/dist/cjs/index.cjs
  var require_cjs2 = __commonJS({
    "node_modules/@turf/meta/dist/cjs/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var _helpers = require_cjs();
      function coordEach(geojson, callback, excludeWrapCoord) {
        if (geojson === null)
          return;
        var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
        for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
          geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
          for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
            var multiFeatureIndex = 0;
            var geometryIndex = 0;
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
            if (geometry === null)
              continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;
            wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
            switch (geomType) {
              case null:
                break;
              case "Point":
                if (callback(
                  coords,
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
                multiFeatureIndex++;
                break;
              case "LineString":
              case "MultiPoint":
                for (j = 0; j < coords.length; j++) {
                  if (callback(
                    coords[j],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false)
                    return false;
                  coordIndex++;
                  if (geomType === "MultiPoint")
                    multiFeatureIndex++;
                }
                if (geomType === "LineString")
                  multiFeatureIndex++;
                break;
              case "Polygon":
              case "MultiLineString":
                for (j = 0; j < coords.length; j++) {
                  for (k = 0; k < coords[j].length - wrapShrink; k++) {
                    if (callback(
                      coords[j][k],
                      coordIndex,
                      featureIndex,
                      multiFeatureIndex,
                      geometryIndex
                    ) === false)
                      return false;
                    coordIndex++;
                  }
                  if (geomType === "MultiLineString")
                    multiFeatureIndex++;
                  if (geomType === "Polygon")
                    geometryIndex++;
                }
                if (geomType === "Polygon")
                  multiFeatureIndex++;
                break;
              case "MultiPolygon":
                for (j = 0; j < coords.length; j++) {
                  geometryIndex = 0;
                  for (k = 0; k < coords[j].length; k++) {
                    for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                      if (callback(
                        coords[j][k][l],
                        coordIndex,
                        featureIndex,
                        multiFeatureIndex,
                        geometryIndex
                      ) === false)
                        return false;
                      coordIndex++;
                    }
                    geometryIndex++;
                  }
                  multiFeatureIndex++;
                }
                break;
              case "GeometryCollection":
                for (j = 0; j < geometry.geometries.length; j++)
                  if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)
                    return false;
                break;
              default:
                throw new Error("Unknown Geometry Type");
            }
          }
        }
      }
      function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
        var previousValue = initialValue;
        coordEach(
          geojson,
          function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
            if (coordIndex === 0 && initialValue === void 0)
              previousValue = currentCoord;
            else
              previousValue = callback(
                previousValue,
                currentCoord,
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              );
          },
          excludeWrapCoord
        );
        return previousValue;
      }
      function propEach(geojson, callback) {
        var i;
        switch (geojson.type) {
          case "FeatureCollection":
            for (i = 0; i < geojson.features.length; i++) {
              if (callback(geojson.features[i].properties, i) === false)
                break;
            }
            break;
          case "Feature":
            callback(geojson.properties, 0);
            break;
        }
      }
      function propReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        propEach(geojson, function(currentProperties, featureIndex) {
          if (featureIndex === 0 && initialValue === void 0)
            previousValue = currentProperties;
          else
            previousValue = callback(previousValue, currentProperties, featureIndex);
        });
        return previousValue;
      }
      function featureEach(geojson, callback) {
        if (geojson.type === "Feature") {
          callback(geojson, 0);
        } else if (geojson.type === "FeatureCollection") {
          for (var i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i], i) === false)
              break;
          }
        }
      }
      function featureReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        featureEach(geojson, function(currentFeature, featureIndex) {
          if (featureIndex === 0 && initialValue === void 0)
            previousValue = currentFeature;
          else
            previousValue = callback(previousValue, currentFeature, featureIndex);
        });
        return previousValue;
      }
      function coordAll(geojson) {
        var coords = [];
        coordEach(geojson, function(coord) {
          coords.push(coord);
        });
        return coords;
      }
      function geomEach(geojson, callback) {
        var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
        for (i = 0; i < stop; i++) {
          geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
          featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
          featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
          featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
          for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
            if (geometry === null) {
              if (callback(
                null,
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              ) === false)
                return false;
              continue;
            }
            switch (geometry.type) {
              case "Point":
              case "LineString":
              case "MultiPoint":
              case "Polygon":
              case "MultiLineString":
              case "MultiPolygon": {
                if (callback(
                  geometry,
                  featureIndex,
                  featureProperties,
                  featureBBox,
                  featureId
                ) === false)
                  return false;
                break;
              }
              case "GeometryCollection": {
                for (j = 0; j < geometry.geometries.length; j++) {
                  if (callback(
                    geometry.geometries[j],
                    featureIndex,
                    featureProperties,
                    featureBBox,
                    featureId
                  ) === false)
                    return false;
                }
                break;
              }
              default:
                throw new Error("Unknown Geometry Type");
            }
          }
          featureIndex++;
        }
      }
      function geomReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        geomEach(
          geojson,
          function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
            if (featureIndex === 0 && initialValue === void 0)
              previousValue = currentGeometry;
            else
              previousValue = callback(
                previousValue,
                currentGeometry,
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              );
          }
        );
        return previousValue;
      }
      function flattenEach(geojson, callback) {
        geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {
          var type = geometry === null ? null : geometry.type;
          switch (type) {
            case null:
            case "Point":
            case "LineString":
            case "Polygon":
              if (callback(
                _helpers.feature.call(void 0, geometry, properties, { bbox, id }),
                featureIndex,
                0
              ) === false)
                return false;
              return;
          }
          var geomType;
          switch (type) {
            case "MultiPoint":
              geomType = "Point";
              break;
            case "MultiLineString":
              geomType = "LineString";
              break;
            case "MultiPolygon":
              geomType = "Polygon";
              break;
          }
          for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
            var coordinate = geometry.coordinates[multiFeatureIndex];
            var geom = {
              type: geomType,
              coordinates: coordinate
            };
            if (callback(_helpers.feature.call(void 0, geom, properties), featureIndex, multiFeatureIndex) === false)
              return false;
          }
        });
      }
      function flattenReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        flattenEach(
          geojson,
          function(currentFeature, featureIndex, multiFeatureIndex) {
            if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)
              previousValue = currentFeature;
            else
              previousValue = callback(
                previousValue,
                currentFeature,
                featureIndex,
                multiFeatureIndex
              );
          }
        );
        return previousValue;
      }
      function segmentEach(geojson, callback) {
        flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
          var segmentIndex = 0;
          if (!feature2.geometry)
            return;
          var type = feature2.geometry.type;
          if (type === "Point" || type === "MultiPoint")
            return;
          var previousCoords;
          var previousFeatureIndex = 0;
          var previousMultiIndex = 0;
          var prevGeomIndex = 0;
          if (coordEach(
            feature2,
            function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
              if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
                previousCoords = currentCoord;
                previousFeatureIndex = featureIndex;
                previousMultiIndex = multiPartIndexCoord;
                prevGeomIndex = geometryIndex;
                segmentIndex = 0;
                return;
              }
              var currentSegment = _helpers.lineString.call(
                void 0,
                [previousCoords, currentCoord],
                feature2.properties
              );
              if (callback(
                currentSegment,
                featureIndex,
                multiFeatureIndex,
                geometryIndex,
                segmentIndex
              ) === false)
                return false;
              segmentIndex++;
              previousCoords = currentCoord;
            }
          ) === false)
            return false;
        });
      }
      function segmentReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        var started = false;
        segmentEach(
          geojson,
          function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
            if (started === false && initialValue === void 0)
              previousValue = currentSegment;
            else
              previousValue = callback(
                previousValue,
                currentSegment,
                featureIndex,
                multiFeatureIndex,
                geometryIndex,
                segmentIndex
              );
            started = true;
          }
        );
        return previousValue;
      }
      function lineEach(geojson, callback) {
        if (!geojson)
          throw new Error("geojson is required");
        flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
          if (feature2.geometry === null)
            return;
          var type = feature2.geometry.type;
          var coords = feature2.geometry.coordinates;
          switch (type) {
            case "LineString":
              if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)
                return false;
              break;
            case "Polygon":
              for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
                if (callback(
                  _helpers.lineString.call(void 0, coords[geometryIndex], feature2.properties),
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
              }
              break;
          }
        });
      }
      function lineReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        lineEach(
          geojson,
          function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
            if (featureIndex === 0 && initialValue === void 0)
              previousValue = currentLine;
            else
              previousValue = callback(
                previousValue,
                currentLine,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              );
          }
        );
        return previousValue;
      }
      function findSegment(geojson, options) {
        options = options || {};
        if (!_helpers.isObject.call(void 0, options))
          throw new Error("options is invalid");
        var featureIndex = options.featureIndex || 0;
        var multiFeatureIndex = options.multiFeatureIndex || 0;
        var geometryIndex = options.geometryIndex || 0;
        var segmentIndex = options.segmentIndex || 0;
        var properties = options.properties;
        var geometry;
        switch (geojson.type) {
          case "FeatureCollection":
            if (featureIndex < 0)
              featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
          case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            geometry = geojson;
            break;
          default:
            throw new Error("geojson is invalid");
        }
        if (geometry === null)
          return null;
        var coords = geometry.coordinates;
        switch (geometry.type) {
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
            if (segmentIndex < 0)
              segmentIndex = coords.length + segmentIndex - 1;
            return _helpers.lineString.call(
              void 0,
              [coords[segmentIndex], coords[segmentIndex + 1]],
              properties,
              options
            );
          case "Polygon":
            if (geometryIndex < 0)
              geometryIndex = coords.length + geometryIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
            return _helpers.lineString.call(
              void 0,
              [
                coords[geometryIndex][segmentIndex],
                coords[geometryIndex][segmentIndex + 1]
              ],
              properties,
              options
            );
          case "MultiLineString":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
            return _helpers.lineString.call(
              void 0,
              [
                coords[multiFeatureIndex][segmentIndex],
                coords[multiFeatureIndex][segmentIndex + 1]
              ],
              properties,
              options
            );
          case "MultiPolygon":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0)
              geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
            return _helpers.lineString.call(
              void 0,
              [
                coords[multiFeatureIndex][geometryIndex][segmentIndex],
                coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]
              ],
              properties,
              options
            );
        }
        throw new Error("geojson is invalid");
      }
      function findPoint(geojson, options) {
        options = options || {};
        if (!_helpers.isObject.call(void 0, options))
          throw new Error("options is invalid");
        var featureIndex = options.featureIndex || 0;
        var multiFeatureIndex = options.multiFeatureIndex || 0;
        var geometryIndex = options.geometryIndex || 0;
        var coordIndex = options.coordIndex || 0;
        var properties = options.properties;
        var geometry;
        switch (geojson.type) {
          case "FeatureCollection":
            if (featureIndex < 0)
              featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
          case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            geometry = geojson;
            break;
          default:
            throw new Error("geojson is invalid");
        }
        if (geometry === null)
          return null;
        var coords = geometry.coordinates;
        switch (geometry.type) {
          case "Point":
            return _helpers.point.call(void 0, coords, properties, options);
          case "MultiPoint":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            return _helpers.point.call(void 0, coords[multiFeatureIndex], properties, options);
          case "LineString":
            if (coordIndex < 0)
              coordIndex = coords.length + coordIndex;
            return _helpers.point.call(void 0, coords[coordIndex], properties, options);
          case "Polygon":
            if (geometryIndex < 0)
              geometryIndex = coords.length + geometryIndex;
            if (coordIndex < 0)
              coordIndex = coords[geometryIndex].length + coordIndex;
            return _helpers.point.call(void 0, coords[geometryIndex][coordIndex], properties, options);
          case "MultiLineString":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (coordIndex < 0)
              coordIndex = coords[multiFeatureIndex].length + coordIndex;
            return _helpers.point.call(void 0, coords[multiFeatureIndex][coordIndex], properties, options);
          case "MultiPolygon":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0)
              geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (coordIndex < 0)
              coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
            return _helpers.point.call(
              void 0,
              coords[multiFeatureIndex][geometryIndex][coordIndex],
              properties,
              options
            );
        }
        throw new Error("geojson is invalid");
      }
      exports.coordAll = coordAll;
      exports.coordEach = coordEach;
      exports.coordReduce = coordReduce;
      exports.featureEach = featureEach;
      exports.featureReduce = featureReduce;
      exports.findPoint = findPoint;
      exports.findSegment = findSegment;
      exports.flattenEach = flattenEach;
      exports.flattenReduce = flattenReduce;
      exports.geomEach = geomEach;
      exports.geomReduce = geomReduce;
      exports.lineEach = lineEach;
      exports.lineReduce = lineReduce;
      exports.propEach = propEach;
      exports.propReduce = propReduce;
      exports.segmentEach = segmentEach;
      exports.segmentReduce = segmentReduce;
    }
  });

  // node_modules/@turf/area/dist/cjs/index.cjs
  var require_cjs3 = __commonJS({
    "node_modules/@turf/area/dist/cjs/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var _helpers = require_cjs();
      var _meta = require_cjs2();
      function area(geojson) {
        return _meta.geomReduce.call(
          void 0,
          geojson,
          (value, geom) => {
            return value + calculateArea(geom);
          },
          0
        );
      }
      function calculateArea(geom) {
        let total = 0;
        let i;
        switch (geom.type) {
          case "Polygon":
            return polygonArea(geom.coordinates);
          case "MultiPolygon":
            for (i = 0; i < geom.coordinates.length; i++) {
              total += polygonArea(geom.coordinates[i]);
            }
            return total;
          case "Point":
          case "MultiPoint":
          case "LineString":
          case "MultiLineString":
            return 0;
        }
        return 0;
      }
      function polygonArea(coords) {
        let total = 0;
        if (coords && coords.length > 0) {
          total += Math.abs(ringArea(coords[0]));
          for (let i = 1; i < coords.length; i++) {
            total -= Math.abs(ringArea(coords[i]));
          }
        }
        return total;
      }
      var FACTOR = _helpers.earthRadius * _helpers.earthRadius / 2;
      var PI_OVER_180 = Math.PI / 180;
      function ringArea(coords) {
        const coordsLength = coords.length - 1;
        if (coordsLength <= 2)
          return 0;
        let total = 0;
        let i = 0;
        while (i < coordsLength) {
          const lower = coords[i];
          const middle = coords[i + 1 === coordsLength ? 0 : i + 1];
          const upper = coords[i + 2 >= coordsLength ? (i + 2) % coordsLength : i + 2];
          const lowerX = lower[0] * PI_OVER_180;
          const middleY = middle[1] * PI_OVER_180;
          const upperX = upper[0] * PI_OVER_180;
          total += (upperX - lowerX) * Math.sin(middleY);
          i++;
        }
        return total * FACTOR;
      }
      var turf_area_default = area;
      exports.area = area;
      exports.default = turf_area_default;
    }
  });

  // node_modules/@turf/centroid/dist/cjs/index.cjs
  var require_cjs4 = __commonJS({
    "node_modules/@turf/centroid/dist/cjs/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var _helpers = require_cjs();
      var _meta = require_cjs2();
      function centroid(geojson, options = {}) {
        let xSum = 0;
        let ySum = 0;
        let len = 0;
        _meta.coordEach.call(
          void 0,
          geojson,
          function(coord) {
            xSum += coord[0];
            ySum += coord[1];
            len++;
          },
          true
        );
        return _helpers.point.call(void 0, [xSum / len, ySum / len], options.properties);
      }
      var turf_centroid_default = centroid;
      exports.centroid = centroid;
      exports.default = turf_centroid_default;
    }
  });

  // node_modules/@turf/bbox/dist/cjs/index.cjs
  var require_cjs5 = __commonJS({
    "node_modules/@turf/bbox/dist/cjs/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var _meta = require_cjs2();
      function bbox(geojson, options = {}) {
        if (geojson.bbox != null && true !== options.recompute) {
          return geojson.bbox;
        }
        const result = [Infinity, Infinity, -Infinity, -Infinity];
        _meta.coordEach.call(void 0, geojson, (coord) => {
          if (result[0] > coord[0]) {
            result[0] = coord[0];
          }
          if (result[1] > coord[1]) {
            result[1] = coord[1];
          }
          if (result[2] < coord[0]) {
            result[2] = coord[0];
          }
          if (result[3] < coord[1]) {
            result[3] = coord[1];
          }
        });
        return result;
      }
      var turf_bbox_default = bbox;
      exports.bbox = bbox;
      exports.default = turf_bbox_default;
    }
  });

  // src/lib/geo_location_utils.js
  var require_geo_location_utils = __commonJS({
    "src/lib/geo_location_utils.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var countryRegex = require_country_regex();
      var { area: turfArea } = require_cjs3();
      var { centroid: turfCentroid } = require_cjs4();
      var { bbox: turfBbox } = require_cjs5();
      var identity = require_identity2();
      var loggers = require_loggers();
      var isPlainObject = require_is_plain_object();
      var nestedProperty = require_nested_property();
      var polygon = require_polygon();
      var countryIds = Object.keys(countryRegex);
      var locationmodeToIdFinder = {
        "ISO-3": identity,
        "USA-states": identity,
        "country names": countryNameToISO3
      };
      function countryNameToISO3(countryName) {
        for (var i = 0; i < countryIds.length; i++) {
          var iso3 = countryIds[i];
          var regex = new RegExp(countryRegex[iso3]);
          if (regex.test(countryName.trim().toLowerCase())) return iso3;
        }
        loggers.log("Unrecognized country name: " + countryName + ".");
        return false;
      }
      function locationToFeature(locationmode, location, features) {
        if (!location || typeof location !== "string") return false;
        var locationId = locationmodeToIdFinder[locationmode](location);
        var filteredFeatures;
        var f, i;
        if (locationId) {
          if (locationmode === "USA-states") {
            filteredFeatures = [];
            for (i = 0; i < features.length; i++) {
              f = features[i];
              if (f.properties && f.properties.gu && f.properties.gu === "USA") {
                filteredFeatures.push(f);
              }
            }
          } else {
            filteredFeatures = features;
          }
          for (i = 0; i < filteredFeatures.length; i++) {
            f = filteredFeatures[i];
            if (f.id === locationId) return f;
          }
          loggers.log([
            "Location with id",
            locationId,
            "does not have a matching topojson feature at this resolution."
          ].join(" "));
        }
        return false;
      }
      function feature2polygons(feature) {
        var geometry = feature.geometry;
        var coords = geometry.coordinates;
        var loc = feature.id;
        var polygons = [];
        var appendPolygon, j, k, m;
        function doesCrossAntiMerdian(pts) {
          for (var l = 0; l < pts.length - 1; l++) {
            if (pts[l][0] > 0 && pts[l + 1][0] < 0) return l;
          }
          return null;
        }
        if (loc === "RUS" || loc === "FJI") {
          appendPolygon = function(_pts) {
            var pts;
            if (doesCrossAntiMerdian(_pts) === null) {
              pts = _pts;
            } else {
              pts = new Array(_pts.length);
              for (m = 0; m < _pts.length; m++) {
                pts[m] = [
                  _pts[m][0] < 0 ? _pts[m][0] + 360 : _pts[m][0],
                  _pts[m][1]
                ];
              }
            }
            polygons.push(polygon.tester(pts));
          };
        } else if (loc === "ATA") {
          appendPolygon = function(pts) {
            var crossAntiMeridianIndex = doesCrossAntiMerdian(pts);
            if (crossAntiMeridianIndex === null) {
              return polygons.push(polygon.tester(pts));
            }
            var stitch = new Array(pts.length + 1);
            var si = 0;
            for (m = 0; m < pts.length; m++) {
              if (m > crossAntiMeridianIndex) {
                stitch[si++] = [pts[m][0] + 360, pts[m][1]];
              } else if (m === crossAntiMeridianIndex) {
                stitch[si++] = pts[m];
                stitch[si++] = [pts[m][0], -90];
              } else {
                stitch[si++] = pts[m];
              }
            }
            var tester = polygon.tester(stitch);
            tester.pts.pop();
            polygons.push(tester);
          };
        } else {
          appendPolygon = function(pts) {
            polygons.push(polygon.tester(pts));
          };
        }
        switch (geometry.type) {
          case "MultiPolygon":
            for (j = 0; j < coords.length; j++) {
              for (k = 0; k < coords[j].length; k++) {
                appendPolygon(coords[j][k]);
              }
            }
            break;
          case "Polygon":
            for (j = 0; j < coords.length; j++) {
              appendPolygon(coords[j]);
            }
            break;
        }
        return polygons;
      }
      function getTraceGeojson(trace) {
        var g = trace.geojson;
        var PlotlyGeoAssets2 = window.PlotlyGeoAssets || {};
        var geojsonIn = typeof g === "string" ? PlotlyGeoAssets2[g] : g;
        if (!isPlainObject(geojsonIn)) {
          loggers.error("Oops ... something went wrong when fetching " + g);
          return false;
        }
        return geojsonIn;
      }
      function extractTraceFeature(calcTrace) {
        var trace = calcTrace[0].trace;
        var geojsonIn = getTraceGeojson(trace);
        if (!geojsonIn) return false;
        var lookup = {};
        var featuresOut = [];
        var i;
        for (i = 0; i < trace._length; i++) {
          var cdi = calcTrace[i];
          if (cdi.loc || cdi.loc === 0) {
            lookup[cdi.loc] = cdi;
          }
        }
        function appendFeature(fIn) {
          var id = nestedProperty(fIn, trace.featureidkey || "id").get();
          var cdi2 = lookup[id];
          if (cdi2) {
            var geometry = fIn.geometry;
            if (geometry.type === "Polygon" || geometry.type === "MultiPolygon") {
              var fOut = {
                type: "Feature",
                id,
                geometry,
                properties: {}
              };
              if (fOut.geometry.coordinates.length > 0) {
                fOut.properties.ct = findCentroid(fOut);
              } else {
                fOut.properties.ct = [NaN, NaN];
              }
              cdi2.fIn = fIn;
              cdi2.fOut = fOut;
              featuresOut.push(fOut);
            } else {
              loggers.log([
                "Location",
                cdi2.loc,
                "does not have a valid GeoJSON geometry.",
                "Traces with locationmode *geojson-id* only support",
                "*Polygon* and *MultiPolygon* geometries."
              ].join(" "));
            }
          }
          delete lookup[id];
        }
        switch (geojsonIn.type) {
          case "FeatureCollection":
            var featuresIn = geojsonIn.features;
            for (i = 0; i < featuresIn.length; i++) {
              appendFeature(featuresIn[i]);
            }
            break;
          case "Feature":
            appendFeature(geojsonIn);
            break;
          default:
            loggers.warn([
              "Invalid GeoJSON type",
              (geojsonIn.type || "none") + ".",
              "Traces with locationmode *geojson-id* only support",
              "*FeatureCollection* and *Feature* types."
            ].join(" "));
            return false;
        }
        for (var loc in lookup) {
          loggers.log([
            "Location *" + loc + "*",
            "does not have a matching feature with id-key",
            "*" + trace.featureidkey + "*."
          ].join(" "));
        }
        return featuresOut;
      }
      function findCentroid(feature) {
        var geometry = feature.geometry;
        var poly;
        if (geometry.type === "MultiPolygon") {
          var coords = geometry.coordinates;
          var maxArea = 0;
          for (var i = 0; i < coords.length; i++) {
            var polyi = { type: "Polygon", coordinates: coords[i] };
            var area = turfArea(polyi);
            if (area > maxArea) {
              maxArea = area;
              poly = polyi;
            }
          }
        } else {
          poly = geometry;
        }
        return turfCentroid(poly).geometry.coordinates;
      }
      function fetchTraceGeoData(calcData) {
        var PlotlyGeoAssets2 = window.PlotlyGeoAssets || {};
        var promises = [];
        function fetch(url2) {
          return new Promise(function(resolve, reject) {
            d3.json(url2, function(err, d) {
              if (err) {
                delete PlotlyGeoAssets2[url2];
                var msg = err.status === 404 ? 'GeoJSON at URL "' + url2 + '" does not exist.' : "Unexpected error while fetching from " + url2;
                return reject(new Error(msg));
              }
              PlotlyGeoAssets2[url2] = d;
              return resolve(d);
            });
          });
        }
        function wait(url2) {
          return new Promise(function(resolve, reject) {
            var cnt = 0;
            var interval = setInterval(function() {
              if (PlotlyGeoAssets2[url2] && PlotlyGeoAssets2[url2] !== "pending") {
                clearInterval(interval);
                return resolve(PlotlyGeoAssets2[url2]);
              }
              if (cnt > 100) {
                clearInterval(interval);
                return reject("Unexpected error while fetching from " + url2);
              }
              cnt++;
            }, 50);
          });
        }
        for (var i = 0; i < calcData.length; i++) {
          var trace = calcData[i][0].trace;
          var url = trace.geojson;
          if (typeof url === "string") {
            if (!PlotlyGeoAssets2[url]) {
              PlotlyGeoAssets2[url] = "pending";
              promises.push(fetch(url));
            } else if (PlotlyGeoAssets2[url] === "pending") {
              promises.push(wait(url));
            }
          }
        }
        return promises;
      }
      function computeBbox(d) {
        return turfBbox(d);
      }
      module.exports = {
        locationToFeature,
        feature2polygons,
        getTraceGeojson,
        extractTraceFeature,
        fetchTraceGeoData,
        computeBbox
      };
    }
  });

  // src/traces/scattergeo/style.js
  var require_style4 = __commonJS({
    "src/traces/scattergeo/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Drawing = require_drawing();
      var Color = require_color();
      var scatterStyle = require_style2();
      var stylePoints = scatterStyle.stylePoints;
      var styleText = scatterStyle.styleText;
      module.exports = function style(gd, calcTrace) {
        if (calcTrace) styleTrace(gd, calcTrace);
      };
      function styleTrace(gd, calcTrace) {
        var trace = calcTrace[0].trace;
        var s = calcTrace[0].node3;
        s.style("opacity", calcTrace[0].trace.opacity);
        stylePoints(s, trace, gd);
        styleText(s, trace, gd);
        s.selectAll("path.js-line").style("fill", "none").each(function(d) {
          var path = d3.select(this);
          var trace2 = d.trace;
          var line = trace2.line || {};
          path.call(Color.stroke, line.color).call(Drawing.dashLine, line.dash || "", line.width || 0);
          if (trace2.fill !== "none") {
            path.call(Color.fill, trace2.fillcolor);
          }
        });
      }
    }
  });

  // src/traces/scattergeo/plot.js
  var require_plot3 = __commonJS({
    "src/traces/scattergeo/plot.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var getTopojsonFeatures = require_topojson_utils().getTopojsonFeatures;
      var geoJsonUtils = require_geojson_utils();
      var geoUtils = require_geo_location_utils();
      var findExtremes = require_autorange().findExtremes;
      var BADNUM = require_numerical().BADNUM;
      var calcMarkerSize = require_calc3().calcMarkerSize;
      var subTypes = require_subtypes();
      var style = require_style4();
      function plot(gd, geo, calcData) {
        var scatterLayer = geo.layers.frontplot.select(".scatterlayer");
        var gTraces = Lib.makeTraceGroups(scatterLayer, calcData, "trace scattergeo");
        function removeBADNUM(d, node) {
          if (d.lonlat[0] === BADNUM) {
            d3.select(node).remove();
          }
        }
        gTraces.selectAll("*").remove();
        gTraces.each(function(calcTrace) {
          var s = d3.select(this);
          var trace = calcTrace[0].trace;
          if (subTypes.hasLines(trace) || trace.fill !== "none") {
            var lineCoords = geoJsonUtils.calcTraceToLineCoords(calcTrace);
            var lineData = trace.fill !== "none" ? geoJsonUtils.makePolygon(lineCoords) : geoJsonUtils.makeLine(lineCoords);
            s.selectAll("path.js-line").data([{ geojson: lineData, trace }]).enter().append("path").classed("js-line", true).style("stroke-miterlimit", 2);
          }
          if (subTypes.hasMarkers(trace)) {
            s.selectAll("path.point").data(Lib.identity).enter().append("path").classed("point", true).each(function(calcPt) {
              removeBADNUM(calcPt, this);
            });
          }
          if (subTypes.hasText(trace)) {
            s.selectAll("g").data(Lib.identity).enter().append("g").append("text").each(function(calcPt) {
              removeBADNUM(calcPt, this);
            });
          }
          style(gd, calcTrace);
        });
      }
      function calcGeoJSON(calcTrace, fullLayout) {
        var trace = calcTrace[0].trace;
        var geoLayout = fullLayout[trace.geo];
        var geo = geoLayout._subplot;
        var len = trace._length;
        var i, calcPt;
        if (Lib.isArrayOrTypedArray(trace.locations)) {
          var locationmode = trace.locationmode;
          var features = locationmode === "geojson-id" ? geoUtils.extractTraceFeature(calcTrace) : getTopojsonFeatures(trace, geo.topojson);
          for (i = 0; i < len; i++) {
            calcPt = calcTrace[i];
            var feature = locationmode === "geojson-id" ? calcPt.fOut : geoUtils.locationToFeature(locationmode, calcPt.loc, features);
            calcPt.lonlat = feature ? feature.properties.ct : [BADNUM, BADNUM];
          }
        }
        var opts = { padded: true };
        var lonArray;
        var latArray;
        if (geoLayout.fitbounds === "geojson" && trace.locationmode === "geojson-id") {
          var bboxGeojson = geoUtils.computeBbox(geoUtils.getTraceGeojson(trace));
          lonArray = [bboxGeojson[0], bboxGeojson[2]];
          latArray = [bboxGeojson[1], bboxGeojson[3]];
        } else {
          lonArray = new Array(len);
          latArray = new Array(len);
          for (i = 0; i < len; i++) {
            calcPt = calcTrace[i];
            lonArray[i] = calcPt.lonlat[0];
            latArray[i] = calcPt.lonlat[1];
          }
          opts.ppad = calcMarkerSize(trace, len);
        }
        trace._extremes.lon = findExtremes(geoLayout.lonaxis._ax, lonArray, opts);
        trace._extremes.lat = findExtremes(geoLayout.lataxis._ax, latArray, opts);
      }
      module.exports = {
        calcGeoJSON,
        plot
      };
    }
  });

  // src/traces/scattergeo/hover.js
  var require_hover3 = __commonJS({
    "src/traces/scattergeo/hover.js"(exports, module) {
      "use strict";
      var Fx = require_fx();
      var BADNUM = require_numerical().BADNUM;
      var getTraceColor = require_get_trace_color();
      var fillText = require_lib().fillText;
      var attributes = require_attributes23();
      module.exports = function hoverPoints(pointData, xval, yval) {
        var cd = pointData.cd;
        var trace = cd[0].trace;
        var xa = pointData.xa;
        var ya = pointData.ya;
        var geo = pointData.subplot;
        var isLonLatOverEdges = geo.projection.isLonLatOverEdges;
        var project = geo.project;
        function distFn(d) {
          var lonlat2 = d.lonlat;
          if (lonlat2[0] === BADNUM) return Infinity;
          if (isLonLatOverEdges(lonlat2)) return Infinity;
          var pt = project(lonlat2);
          var px = project([xval, yval]);
          var dx = Math.abs(pt[0] - px[0]);
          var dy = Math.abs(pt[1] - px[1]);
          var rad2 = Math.max(3, d.mrc || 0);
          return Math.max(Math.sqrt(dx * dx + dy * dy) - rad2, 1 - 3 / rad2);
        }
        Fx.getClosest(cd, distFn, pointData);
        if (pointData.index === false) return;
        var di = cd[pointData.index];
        var lonlat = di.lonlat;
        var pos = [xa.c2p(lonlat), ya.c2p(lonlat)];
        var rad = di.mrc || 1;
        pointData.x0 = pos[0] - rad;
        pointData.x1 = pos[0] + rad;
        pointData.y0 = pos[1] - rad;
        pointData.y1 = pos[1] + rad;
        pointData.loc = di.loc;
        pointData.lon = lonlat[0];
        pointData.lat = lonlat[1];
        var fullLayout = {};
        fullLayout[trace.geo] = { _subplot: geo };
        var labels = trace._module.formatLabels(di, trace, fullLayout);
        pointData.lonLabel = labels.lonLabel;
        pointData.latLabel = labels.latLabel;
        pointData.color = getTraceColor(trace, di);
        pointData.extraText = getExtraText(trace, di, pointData, cd[0].t.labels);
        pointData.hovertemplate = trace.hovertemplate;
        return [pointData];
      };
      function getExtraText(trace, pt, pointData, labels) {
        if (trace.hovertemplate) return;
        var hoverinfo = pt.hi || trace.hoverinfo;
        var parts = hoverinfo === "all" ? attributes.hoverinfo.flags : hoverinfo.split("+");
        var hasLocation = parts.indexOf("location") !== -1 && Array.isArray(trace.locations);
        var hasLon = parts.indexOf("lon") !== -1;
        var hasLat = parts.indexOf("lat") !== -1;
        var hasText = parts.indexOf("text") !== -1;
        var text = [];
        function format(val) {
          return val + "\xB0";
        }
        if (hasLocation) {
          text.push(pt.loc);
        } else if (hasLon && hasLat) {
          text.push("(" + format(pointData.latLabel) + ", " + format(pointData.lonLabel) + ")");
        } else if (hasLon) {
          text.push(labels.lon + format(pointData.lonLabel));
        } else if (hasLat) {
          text.push(labels.lat + format(pointData.latLabel));
        }
        if (hasText) {
          fillText(pt, trace, text);
        }
        return text.join("<br>");
      }
    }
  });

  // src/traces/scattergeo/event_data.js
  var require_event_data = __commonJS({
    "src/traces/scattergeo/event_data.js"(exports, module) {
      "use strict";
      module.exports = function eventData(out, pt, trace, cd, pointNumber) {
        out.lon = pt.lon;
        out.lat = pt.lat;
        out.location = pt.loc ? pt.loc : null;
        var cdi = cd[pointNumber];
        if (cdi.fIn && cdi.fIn.properties) {
          out.properties = cdi.fIn.properties;
        }
        return out;
      };
    }
  });

  // src/traces/scattergeo/select.js
  var require_select3 = __commonJS({
    "src/traces/scattergeo/select.js"(exports, module) {
      "use strict";
      var subtypes = require_subtypes();
      var BADNUM = require_numerical().BADNUM;
      module.exports = function selectPoints(searchInfo, selectionTester) {
        var cd = searchInfo.cd;
        var xa = searchInfo.xaxis;
        var ya = searchInfo.yaxis;
        var selection = [];
        var trace = cd[0].trace;
        var di, lonlat, x, y, i;
        var hasOnlyLines = !subtypes.hasMarkers(trace) && !subtypes.hasText(trace);
        if (hasOnlyLines) return [];
        if (selectionTester === false) {
          for (i = 0; i < cd.length; i++) {
            cd[i].selected = 0;
          }
        } else {
          for (i = 0; i < cd.length; i++) {
            di = cd[i];
            lonlat = di.lonlat;
            if (lonlat[0] === BADNUM) continue;
            x = xa.c2p(lonlat);
            y = ya.c2p(lonlat);
            if (selectionTester.contains([x, y], null, i, searchInfo)) {
              selection.push({
                pointNumber: i,
                lon: lonlat[0],
                lat: lonlat[1]
              });
              di.selected = 1;
            } else {
              di.selected = 0;
            }
          }
        }
        return selection;
      };
    }
  });

  // node_modules/d3-array/dist/d3-array.js
  var require_d3_array = __commonJS({
    "node_modules/d3-array/dist/d3-array.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && false ? define(["exports"], factory) : factory(global2.d3 = global2.d3 || {});
      })(exports, function(exports2) {
        "use strict";
        function ascending(a, b) {
          return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
        }
        function bisector(compare) {
          if (compare.length === 1) compare = ascendingComparator(compare);
          return {
            left: function(a, x, lo, hi) {
              if (lo == null) lo = 0;
              if (hi == null) hi = a.length;
              while (lo < hi) {
                var mid = lo + hi >>> 1;
                if (compare(a[mid], x) < 0) lo = mid + 1;
                else hi = mid;
              }
              return lo;
            },
            right: function(a, x, lo, hi) {
              if (lo == null) lo = 0;
              if (hi == null) hi = a.length;
              while (lo < hi) {
                var mid = lo + hi >>> 1;
                if (compare(a[mid], x) > 0) hi = mid;
                else lo = mid + 1;
              }
              return lo;
            }
          };
        }
        function ascendingComparator(f) {
          return function(d, x) {
            return ascending(f(d), x);
          };
        }
        var ascendingBisect = bisector(ascending);
        var bisectRight = ascendingBisect.right;
        var bisectLeft = ascendingBisect.left;
        function pairs(array2, f) {
          if (f == null) f = pair;
          var i = 0, n = array2.length - 1, p = array2[0], pairs2 = new Array(n < 0 ? 0 : n);
          while (i < n) pairs2[i] = f(p, p = array2[++i]);
          return pairs2;
        }
        function pair(a, b) {
          return [a, b];
        }
        function cross(values0, values1, reduce) {
          var n0 = values0.length, n1 = values1.length, values = new Array(n0 * n1), i0, i1, i, value0;
          if (reduce == null) reduce = pair;
          for (i0 = i = 0; i0 < n0; ++i0) {
            for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
              values[i] = reduce(value0, values1[i1]);
            }
          }
          return values;
        }
        function descending(a, b) {
          return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
        }
        function number(x) {
          return x === null ? NaN : +x;
        }
        function variance(values, valueof) {
          var n = values.length, m = 0, i = -1, mean2 = 0, value, delta, sum2 = 0;
          if (valueof == null) {
            while (++i < n) {
              if (!isNaN(value = number(values[i]))) {
                delta = value - mean2;
                mean2 += delta / ++m;
                sum2 += delta * (value - mean2);
              }
            }
          } else {
            while (++i < n) {
              if (!isNaN(value = number(valueof(values[i], i, values)))) {
                delta = value - mean2;
                mean2 += delta / ++m;
                sum2 += delta * (value - mean2);
              }
            }
          }
          if (m > 1) return sum2 / (m - 1);
        }
        function deviation(array2, f) {
          var v = variance(array2, f);
          return v ? Math.sqrt(v) : v;
        }
        function extent(values, valueof) {
          var n = values.length, i = -1, value, min2, max2;
          if (valueof == null) {
            while (++i < n) {
              if ((value = values[i]) != null && value >= value) {
                min2 = max2 = value;
                while (++i < n) {
                  if ((value = values[i]) != null) {
                    if (min2 > value) min2 = value;
                    if (max2 < value) max2 = value;
                  }
                }
              }
            }
          } else {
            while (++i < n) {
              if ((value = valueof(values[i], i, values)) != null && value >= value) {
                min2 = max2 = value;
                while (++i < n) {
                  if ((value = valueof(values[i], i, values)) != null) {
                    if (min2 > value) min2 = value;
                    if (max2 < value) max2 = value;
                  }
                }
              }
            }
          }
          return [min2, max2];
        }
        var array = Array.prototype;
        var slice = array.slice;
        var map = array.map;
        function constant(x) {
          return function() {
            return x;
          };
        }
        function identity(x) {
          return x;
        }
        function range(start, stop, step) {
          start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
          var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range2 = new Array(n);
          while (++i < n) {
            range2[i] = start + i * step;
          }
          return range2;
        }
        var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
        function ticks(start, stop, count) {
          var reverse, i = -1, n, ticks2, step;
          stop = +stop, start = +start, count = +count;
          if (start === stop && count > 0) return [start];
          if (reverse = stop < start) n = start, start = stop, stop = n;
          if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];
          if (step > 0) {
            start = Math.ceil(start / step);
            stop = Math.floor(stop / step);
            ticks2 = new Array(n = Math.ceil(stop - start + 1));
            while (++i < n) ticks2[i] = (start + i) * step;
          } else {
            start = Math.floor(start * step);
            stop = Math.ceil(stop * step);
            ticks2 = new Array(n = Math.ceil(start - stop + 1));
            while (++i < n) ticks2[i] = (start - i) / step;
          }
          if (reverse) ticks2.reverse();
          return ticks2;
        }
        function tickIncrement(start, stop, count) {
          var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
          return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
        }
        function tickStep(start, stop, count) {
          var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
          if (error >= e10) step1 *= 10;
          else if (error >= e5) step1 *= 5;
          else if (error >= e2) step1 *= 2;
          return stop < start ? -step1 : step1;
        }
        function sturges(values) {
          return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
        }
        function histogram() {
          var value = identity, domain = extent, threshold = sturges;
          function histogram2(data) {
            var i, n = data.length, x, values = new Array(n);
            for (i = 0; i < n; ++i) {
              values[i] = value(data[i], i, data);
            }
            var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold(values, x0, x1);
            if (!Array.isArray(tz)) {
              tz = tickStep(x0, x1, tz);
              tz = range(Math.ceil(x0 / tz) * tz, x1, tz);
            }
            var m = tz.length;
            while (tz[0] <= x0) tz.shift(), --m;
            while (tz[m - 1] > x1) tz.pop(), --m;
            var bins = new Array(m + 1), bin;
            for (i = 0; i <= m; ++i) {
              bin = bins[i] = [];
              bin.x0 = i > 0 ? tz[i - 1] : x0;
              bin.x1 = i < m ? tz[i] : x1;
            }
            for (i = 0; i < n; ++i) {
              x = values[i];
              if (x0 <= x && x <= x1) {
                bins[bisectRight(tz, x, 0, m)].push(data[i]);
              }
            }
            return bins;
          }
          histogram2.value = function(_) {
            return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram2) : value;
          };
          histogram2.domain = function(_) {
            return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram2) : domain;
          };
          histogram2.thresholds = function(_) {
            return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram2) : threshold;
          };
          return histogram2;
        }
        function quantile(values, p, valueof) {
          if (valueof == null) valueof = number;
          if (!(n = values.length)) return;
          if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
          if (p >= 1) return +valueof(values[n - 1], n - 1, values);
          var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
          return value0 + (value1 - value0) * (i - i0);
        }
        function freedmanDiaconis(values, min2, max2) {
          values = map.call(values, number).sort(ascending);
          return Math.ceil((max2 - min2) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
        }
        function scott(values, min2, max2) {
          return Math.ceil((max2 - min2) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
        }
        function max(values, valueof) {
          var n = values.length, i = -1, value, max2;
          if (valueof == null) {
            while (++i < n) {
              if ((value = values[i]) != null && value >= value) {
                max2 = value;
                while (++i < n) {
                  if ((value = values[i]) != null && value > max2) {
                    max2 = value;
                  }
                }
              }
            }
          } else {
            while (++i < n) {
              if ((value = valueof(values[i], i, values)) != null && value >= value) {
                max2 = value;
                while (++i < n) {
                  if ((value = valueof(values[i], i, values)) != null && value > max2) {
                    max2 = value;
                  }
                }
              }
            }
          }
          return max2;
        }
        function mean(values, valueof) {
          var n = values.length, m = n, i = -1, value, sum2 = 0;
          if (valueof == null) {
            while (++i < n) {
              if (!isNaN(value = number(values[i]))) sum2 += value;
              else --m;
            }
          } else {
            while (++i < n) {
              if (!isNaN(value = number(valueof(values[i], i, values)))) sum2 += value;
              else --m;
            }
          }
          if (m) return sum2 / m;
        }
        function median(values, valueof) {
          var n = values.length, i = -1, value, numbers = [];
          if (valueof == null) {
            while (++i < n) {
              if (!isNaN(value = number(values[i]))) {
                numbers.push(value);
              }
            }
          } else {
            while (++i < n) {
              if (!isNaN(value = number(valueof(values[i], i, values)))) {
                numbers.push(value);
              }
            }
          }
          return quantile(numbers.sort(ascending), 0.5);
        }
        function merge(arrays) {
          var n = arrays.length, m, i = -1, j = 0, merged, array2;
          while (++i < n) j += arrays[i].length;
          merged = new Array(j);
          while (--n >= 0) {
            array2 = arrays[n];
            m = array2.length;
            while (--m >= 0) {
              merged[--j] = array2[m];
            }
          }
          return merged;
        }
        function min(values, valueof) {
          var n = values.length, i = -1, value, min2;
          if (valueof == null) {
            while (++i < n) {
              if ((value = values[i]) != null && value >= value) {
                min2 = value;
                while (++i < n) {
                  if ((value = values[i]) != null && min2 > value) {
                    min2 = value;
                  }
                }
              }
            }
          } else {
            while (++i < n) {
              if ((value = valueof(values[i], i, values)) != null && value >= value) {
                min2 = value;
                while (++i < n) {
                  if ((value = valueof(values[i], i, values)) != null && min2 > value) {
                    min2 = value;
                  }
                }
              }
            }
          }
          return min2;
        }
        function permute(array2, indexes) {
          var i = indexes.length, permutes = new Array(i);
          while (i--) permutes[i] = array2[indexes[i]];
          return permutes;
        }
        function scan(values, compare) {
          if (!(n = values.length)) return;
          var n, i = 0, j = 0, xi, xj = values[j];
          if (compare == null) compare = ascending;
          while (++i < n) {
            if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
              xj = xi, j = i;
            }
          }
          if (compare(xj, xj) === 0) return j;
        }
        function shuffle(array2, i0, i1) {
          var m = (i1 == null ? array2.length : i1) - (i0 = i0 == null ? 0 : +i0), t, i;
          while (m) {
            i = Math.random() * m-- | 0;
            t = array2[m + i0];
            array2[m + i0] = array2[i + i0];
            array2[i + i0] = t;
          }
          return array2;
        }
        function sum(values, valueof) {
          var n = values.length, i = -1, value, sum2 = 0;
          if (valueof == null) {
            while (++i < n) {
              if (value = +values[i]) sum2 += value;
            }
          } else {
            while (++i < n) {
              if (value = +valueof(values[i], i, values)) sum2 += value;
            }
          }
          return sum2;
        }
        function transpose(matrix) {
          if (!(n = matrix.length)) return [];
          for (var i = -1, m = min(matrix, length), transpose2 = new Array(m); ++i < m; ) {
            for (var j = -1, n, row = transpose2[i] = new Array(n); ++j < n; ) {
              row[j] = matrix[j][i];
            }
          }
          return transpose2;
        }
        function length(d) {
          return d.length;
        }
        function zip() {
          return transpose(arguments);
        }
        exports2.bisect = bisectRight;
        exports2.bisectRight = bisectRight;
        exports2.bisectLeft = bisectLeft;
        exports2.ascending = ascending;
        exports2.bisector = bisector;
        exports2.cross = cross;
        exports2.descending = descending;
        exports2.deviation = deviation;
        exports2.extent = extent;
        exports2.histogram = histogram;
        exports2.thresholdFreedmanDiaconis = freedmanDiaconis;
        exports2.thresholdScott = scott;
        exports2.thresholdSturges = sturges;
        exports2.max = max;
        exports2.mean = mean;
        exports2.median = median;
        exports2.merge = merge;
        exports2.min = min;
        exports2.pairs = pairs;
        exports2.permute = permute;
        exports2.quantile = quantile;
        exports2.range = range;
        exports2.scan = scan;
        exports2.shuffle = shuffle;
        exports2.sum = sum;
        exports2.ticks = ticks;
        exports2.tickIncrement = tickIncrement;
        exports2.tickStep = tickStep;
        exports2.transpose = transpose;
        exports2.variance = variance;
        exports2.zip = zip;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/d3-geo/dist/d3-geo.js
  var require_d3_geo = __commonJS({
    "node_modules/d3-geo/dist/d3-geo.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_array()) : typeof define === "function" && false ? define(["exports", "d3-array"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3));
      })(exports, function(exports2, d3Array) {
        "use strict";
        function adder() {
          return new Adder();
        }
        function Adder() {
          this.reset();
        }
        Adder.prototype = {
          constructor: Adder,
          reset: function() {
            this.s = // rounded value
            this.t = 0;
          },
          add: function(y) {
            add(temp, y, this.t);
            add(this, temp.s, this.s);
            if (this.s) this.t += temp.t;
            else this.s = temp.t;
          },
          valueOf: function() {
            return this.s;
          }
        };
        var temp = new Adder();
        function add(adder2, a, b) {
          var x = adder2.s = a + b, bv = x - a, av = x - bv;
          adder2.t = a - av + (b - bv);
        }
        var epsilon = 1e-6;
        var epsilon2 = 1e-12;
        var pi = Math.PI;
        var halfPi = pi / 2;
        var quarterPi = pi / 4;
        var tau = pi * 2;
        var degrees = 180 / pi;
        var radians = pi / 180;
        var abs = Math.abs;
        var atan = Math.atan;
        var atan2 = Math.atan2;
        var cos = Math.cos;
        var ceil = Math.ceil;
        var exp = Math.exp;
        var log = Math.log;
        var pow = Math.pow;
        var sin = Math.sin;
        var sign = Math.sign || function(x) {
          return x > 0 ? 1 : x < 0 ? -1 : 0;
        };
        var sqrt = Math.sqrt;
        var tan = Math.tan;
        function acos(x) {
          return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
        }
        function asin(x) {
          return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
        }
        function haversin(x) {
          return (x = sin(x / 2)) * x;
        }
        function noop() {
        }
        function streamGeometry(geometry, stream) {
          if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
            streamGeometryType[geometry.type](geometry, stream);
          }
        }
        var streamObjectType = {
          Feature: function(object2, stream) {
            streamGeometry(object2.geometry, stream);
          },
          FeatureCollection: function(object2, stream) {
            var features = object2.features, i = -1, n = features.length;
            while (++i < n) streamGeometry(features[i].geometry, stream);
          }
        };
        var streamGeometryType = {
          Sphere: function(object2, stream) {
            stream.sphere();
          },
          Point: function(object2, stream) {
            object2 = object2.coordinates;
            stream.point(object2[0], object2[1], object2[2]);
          },
          MultiPoint: function(object2, stream) {
            var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
            while (++i < n) object2 = coordinates2[i], stream.point(object2[0], object2[1], object2[2]);
          },
          LineString: function(object2, stream) {
            streamLine(object2.coordinates, stream, 0);
          },
          MultiLineString: function(object2, stream) {
            var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
            while (++i < n) streamLine(coordinates2[i], stream, 0);
          },
          Polygon: function(object2, stream) {
            streamPolygon(object2.coordinates, stream);
          },
          MultiPolygon: function(object2, stream) {
            var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
            while (++i < n) streamPolygon(coordinates2[i], stream);
          },
          GeometryCollection: function(object2, stream) {
            var geometries = object2.geometries, i = -1, n = geometries.length;
            while (++i < n) streamGeometry(geometries[i], stream);
          }
        };
        function streamLine(coordinates2, stream, closed) {
          var i = -1, n = coordinates2.length - closed, coordinate;
          stream.lineStart();
          while (++i < n) coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
          stream.lineEnd();
        }
        function streamPolygon(coordinates2, stream) {
          var i = -1, n = coordinates2.length;
          stream.polygonStart();
          while (++i < n) streamLine(coordinates2[i], stream, 1);
          stream.polygonEnd();
        }
        function geoStream(object2, stream) {
          if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
            streamObjectType[object2.type](object2, stream);
          } else {
            streamGeometry(object2, stream);
          }
        }
        var areaRingSum = adder();
        var areaSum = adder(), lambda00, phi00, lambda0, cosPhi0, sinPhi0;
        var areaStream = {
          point: noop,
          lineStart: noop,
          lineEnd: noop,
          polygonStart: function() {
            areaRingSum.reset();
            areaStream.lineStart = areaRingStart;
            areaStream.lineEnd = areaRingEnd;
          },
          polygonEnd: function() {
            var areaRing = +areaRingSum;
            areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
            this.lineStart = this.lineEnd = this.point = noop;
          },
          sphere: function() {
            areaSum.add(tau);
          }
        };
        function areaRingStart() {
          areaStream.point = areaPointFirst;
        }
        function areaRingEnd() {
          areaPoint(lambda00, phi00);
        }
        function areaPointFirst(lambda, phi) {
          areaStream.point = areaPoint;
          lambda00 = lambda, phi00 = phi;
          lambda *= radians, phi *= radians;
          lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
        }
        function areaPoint(lambda, phi) {
          lambda *= radians, phi *= radians;
          phi = phi / 2 + quarterPi;
          var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos(phi), sinPhi = sin(phi), k = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k * cos(adLambda), v = k * sdLambda * sin(adLambda);
          areaRingSum.add(atan2(v, u));
          lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
        }
        function area(object2) {
          areaSum.reset();
          geoStream(object2, areaStream);
          return areaSum * 2;
        }
        function spherical(cartesian2) {
          return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
        }
        function cartesian(spherical2) {
          var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
          return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
        }
        function cartesianDot(a, b) {
          return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        }
        function cartesianCross(a, b) {
          return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
        }
        function cartesianAddInPlace(a, b) {
          a[0] += b[0], a[1] += b[1], a[2] += b[2];
        }
        function cartesianScale(vector, k) {
          return [vector[0] * k, vector[1] * k, vector[2] * k];
        }
        function cartesianNormalizeInPlace(d) {
          var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
          d[0] /= l, d[1] /= l, d[2] /= l;
        }
        var lambda0$1, phi0, lambda1, phi1, lambda2, lambda00$1, phi00$1, p0, deltaSum = adder(), ranges, range;
        var boundsStream = {
          point: boundsPoint,
          lineStart: boundsLineStart,
          lineEnd: boundsLineEnd,
          polygonStart: function() {
            boundsStream.point = boundsRingPoint;
            boundsStream.lineStart = boundsRingStart;
            boundsStream.lineEnd = boundsRingEnd;
            deltaSum.reset();
            areaStream.polygonStart();
          },
          polygonEnd: function() {
            areaStream.polygonEnd();
            boundsStream.point = boundsPoint;
            boundsStream.lineStart = boundsLineStart;
            boundsStream.lineEnd = boundsLineEnd;
            if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
            else if (deltaSum > epsilon) phi1 = 90;
            else if (deltaSum < -epsilon) phi0 = -90;
            range[0] = lambda0$1, range[1] = lambda1;
          },
          sphere: function() {
            lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
          }
        };
        function boundsPoint(lambda, phi) {
          ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
          if (phi < phi0) phi0 = phi;
          if (phi > phi1) phi1 = phi;
        }
        function linePoint(lambda, phi) {
          var p = cartesian([lambda * radians, phi * radians]);
          if (p0) {
            var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
            cartesianNormalizeInPlace(inflection);
            inflection = spherical(inflection);
            var delta = lambda - lambda2, sign2 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign2, phii, antimeridian = abs(delta) > 180;
            if (antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
              phii = inflection[1] * degrees;
              if (phii > phi1) phi1 = phii;
            } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
              phii = -inflection[1] * degrees;
              if (phii < phi0) phi0 = phii;
            } else {
              if (phi < phi0) phi0 = phi;
              if (phi > phi1) phi1 = phi;
            }
            if (antimeridian) {
              if (lambda < lambda2) {
                if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
              } else {
                if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
              }
            } else {
              if (lambda1 >= lambda0$1) {
                if (lambda < lambda0$1) lambda0$1 = lambda;
                if (lambda > lambda1) lambda1 = lambda;
              } else {
                if (lambda > lambda2) {
                  if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
                } else {
                  if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
                }
              }
            }
          } else {
            ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
          }
          if (phi < phi0) phi0 = phi;
          if (phi > phi1) phi1 = phi;
          p0 = p, lambda2 = lambda;
        }
        function boundsLineStart() {
          boundsStream.point = linePoint;
        }
        function boundsLineEnd() {
          range[0] = lambda0$1, range[1] = lambda1;
          boundsStream.point = boundsPoint;
          p0 = null;
        }
        function boundsRingPoint(lambda, phi) {
          if (p0) {
            var delta = lambda - lambda2;
            deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
          } else {
            lambda00$1 = lambda, phi00$1 = phi;
          }
          areaStream.point(lambda, phi);
          linePoint(lambda, phi);
        }
        function boundsRingStart() {
          areaStream.lineStart();
        }
        function boundsRingEnd() {
          boundsRingPoint(lambda00$1, phi00$1);
          areaStream.lineEnd();
          if (abs(deltaSum) > epsilon) lambda0$1 = -(lambda1 = 180);
          range[0] = lambda0$1, range[1] = lambda1;
          p0 = null;
        }
        function angle(lambda02, lambda12) {
          return (lambda12 -= lambda02) < 0 ? lambda12 + 360 : lambda12;
        }
        function rangeCompare(a, b) {
          return a[0] - b[0];
        }
        function rangeContains(range2, x) {
          return range2[0] <= range2[1] ? range2[0] <= x && x <= range2[1] : x < range2[0] || range2[1] < x;
        }
        function bounds(feature) {
          var i, n, a, b, merged, deltaMax, delta;
          phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
          ranges = [];
          geoStream(feature, boundsStream);
          if (n = ranges.length) {
            ranges.sort(rangeCompare);
            for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
              b = ranges[i];
              if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
                if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
                if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
              } else {
                merged.push(a = b);
              }
            }
            for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
              b = merged[i];
              if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
            }
          }
          ranges = range = null;
          return lambda0$1 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0$1, phi0], [lambda1, phi1]];
        }
        var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00$2, phi00$2, x0, y0, z0;
        var centroidStream = {
          sphere: noop,
          point: centroidPoint,
          lineStart: centroidLineStart,
          lineEnd: centroidLineEnd,
          polygonStart: function() {
            centroidStream.lineStart = centroidRingStart;
            centroidStream.lineEnd = centroidRingEnd;
          },
          polygonEnd: function() {
            centroidStream.lineStart = centroidLineStart;
            centroidStream.lineEnd = centroidLineEnd;
          }
        };
        function centroidPoint(lambda, phi) {
          lambda *= radians, phi *= radians;
          var cosPhi = cos(phi);
          centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
        }
        function centroidPointCartesian(x, y, z) {
          ++W0;
          X0 += (x - X0) / W0;
          Y0 += (y - Y0) / W0;
          Z0 += (z - Z0) / W0;
        }
        function centroidLineStart() {
          centroidStream.point = centroidLinePointFirst;
        }
        function centroidLinePointFirst(lambda, phi) {
          lambda *= radians, phi *= radians;
          var cosPhi = cos(phi);
          x0 = cosPhi * cos(lambda);
          y0 = cosPhi * sin(lambda);
          z0 = sin(phi);
          centroidStream.point = centroidLinePoint;
          centroidPointCartesian(x0, y0, z0);
        }
        function centroidLinePoint(lambda, phi) {
          lambda *= radians, phi *= radians;
          var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
          W1 += w;
          X1 += w * (x0 + (x0 = x));
          Y1 += w * (y0 + (y0 = y));
          Z1 += w * (z0 + (z0 = z));
          centroidPointCartesian(x0, y0, z0);
        }
        function centroidLineEnd() {
          centroidStream.point = centroidPoint;
        }
        function centroidRingStart() {
          centroidStream.point = centroidRingPointFirst;
        }
        function centroidRingEnd() {
          centroidRingPoint(lambda00$2, phi00$2);
          centroidStream.point = centroidPoint;
        }
        function centroidRingPointFirst(lambda, phi) {
          lambda00$2 = lambda, phi00$2 = phi;
          lambda *= radians, phi *= radians;
          centroidStream.point = centroidRingPoint;
          var cosPhi = cos(phi);
          x0 = cosPhi * cos(lambda);
          y0 = cosPhi * sin(lambda);
          z0 = sin(phi);
          centroidPointCartesian(x0, y0, z0);
        }
        function centroidRingPoint(lambda, phi) {
          lambda *= radians, phi *= radians;
          var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = sqrt(cx * cx + cy * cy + cz * cz), w = asin(m), v = m && -w / m;
          X2 += v * cx;
          Y2 += v * cy;
          Z2 += v * cz;
          W1 += w;
          X1 += w * (x0 + (x0 = x));
          Y1 += w * (y0 + (y0 = y));
          Z1 += w * (z0 + (z0 = z));
          centroidPointCartesian(x0, y0, z0);
        }
        function centroid(object2) {
          W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
          geoStream(object2, centroidStream);
          var x = X2, y = Y2, z = Z2, m = x * x + y * y + z * z;
          if (m < epsilon2) {
            x = X1, y = Y1, z = Z1;
            if (W1 < epsilon) x = X0, y = Y0, z = Z0;
            m = x * x + y * y + z * z;
            if (m < epsilon2) return [NaN, NaN];
          }
          return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];
        }
        function constant(x) {
          return function() {
            return x;
          };
        }
        function compose(a, b) {
          function compose2(x, y) {
            return x = a(x, y), b(x[0], x[1]);
          }
          if (a.invert && b.invert) compose2.invert = function(x, y) {
            return x = b.invert(x, y), x && a.invert(x[0], x[1]);
          };
          return compose2;
        }
        function rotationIdentity(lambda, phi) {
          return [abs(lambda) > pi ? lambda + Math.round(-lambda / tau) * tau : lambda, phi];
        }
        rotationIdentity.invert = rotationIdentity;
        function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
          return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
        }
        function forwardRotationLambda(deltaLambda) {
          return function(lambda, phi) {
            return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
          };
        }
        function rotationLambda(deltaLambda) {
          var rotation2 = forwardRotationLambda(deltaLambda);
          rotation2.invert = forwardRotationLambda(-deltaLambda);
          return rotation2;
        }
        function rotationPhiGamma(deltaPhi, deltaGamma) {
          var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
          function rotation2(lambda, phi) {
            var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaPhi + x * sinDeltaPhi;
            return [
              atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
              asin(k * cosDeltaGamma + y * sinDeltaGamma)
            ];
          }
          rotation2.invert = function(lambda, phi) {
            var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaGamma - y * sinDeltaGamma;
            return [
              atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
              asin(k * cosDeltaPhi - x * sinDeltaPhi)
            ];
          };
          return rotation2;
        }
        function rotation(rotate) {
          rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);
          function forward(coordinates2) {
            coordinates2 = rotate(coordinates2[0] * radians, coordinates2[1] * radians);
            return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
          }
          forward.invert = function(coordinates2) {
            coordinates2 = rotate.invert(coordinates2[0] * radians, coordinates2[1] * radians);
            return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
          };
          return forward;
        }
        function circleStream(stream, radius, delta, direction, t0, t1) {
          if (!delta) return;
          var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;
          if (t0 == null) {
            t0 = radius + direction * tau;
            t1 = radius - step / 2;
          } else {
            t0 = circleRadius(cosRadius, t0);
            t1 = circleRadius(cosRadius, t1);
            if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
          }
          for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
            point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
            stream.point(point[0], point[1]);
          }
        }
        function circleRadius(cosRadius, point) {
          point = cartesian(point), point[0] -= cosRadius;
          cartesianNormalizeInPlace(point);
          var radius = acos(-point[1]);
          return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
        }
        function circle() {
          var center = constant([0, 0]), radius = constant(90), precision = constant(6), ring, rotate, stream = { point };
          function point(x, y) {
            ring.push(x = rotate(x, y));
            x[0] *= degrees, x[1] *= degrees;
          }
          function circle2() {
            var c = center.apply(this, arguments), r = radius.apply(this, arguments) * radians, p = precision.apply(this, arguments) * radians;
            ring = [];
            rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
            circleStream(stream, r, p, 1);
            c = { type: "Polygon", coordinates: [ring] };
            ring = rotate = null;
            return c;
          }
          circle2.center = function(_) {
            return arguments.length ? (center = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), circle2) : center;
          };
          circle2.radius = function(_) {
            return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), circle2) : radius;
          };
          circle2.precision = function(_) {
            return arguments.length ? (precision = typeof _ === "function" ? _ : constant(+_), circle2) : precision;
          };
          return circle2;
        }
        function clipBuffer() {
          var lines = [], line;
          return {
            point: function(x, y, m) {
              line.push([x, y, m]);
            },
            lineStart: function() {
              lines.push(line = []);
            },
            lineEnd: noop,
            rejoin: function() {
              if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
            },
            result: function() {
              var result = lines;
              lines = [];
              line = null;
              return result;
            }
          };
        }
        function pointEqual(a, b) {
          return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
        }
        function Intersection(point, points, other, entry) {
          this.x = point;
          this.z = points;
          this.o = other;
          this.e = entry;
          this.v = false;
          this.n = this.p = null;
        }
        function clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream) {
          var subject = [], clip2 = [], i, n;
          segments.forEach(function(segment) {
            if ((n2 = segment.length - 1) <= 0) return;
            var n2, p02 = segment[0], p1 = segment[n2], x;
            if (pointEqual(p02, p1)) {
              if (!p02[2] && !p1[2]) {
                stream.lineStart();
                for (i = 0; i < n2; ++i) stream.point((p02 = segment[i])[0], p02[1]);
                stream.lineEnd();
                return;
              }
              p1[0] += 2 * epsilon;
            }
            subject.push(x = new Intersection(p02, segment, null, true));
            clip2.push(x.o = new Intersection(p02, null, x, false));
            subject.push(x = new Intersection(p1, segment, null, false));
            clip2.push(x.o = new Intersection(p1, null, x, true));
          });
          if (!subject.length) return;
          clip2.sort(compareIntersection2);
          link(subject);
          link(clip2);
          for (i = 0, n = clip2.length; i < n; ++i) {
            clip2[i].e = startInside = !startInside;
          }
          var start = subject[0], points, point;
          while (1) {
            var current = start, isSubject = true;
            while (current.v) if ((current = current.n) === start) return;
            points = current.z;
            stream.lineStart();
            do {
              current.v = current.o.v = true;
              if (current.e) {
                if (isSubject) {
                  for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
                } else {
                  interpolate2(current.x, current.n.x, 1, stream);
                }
                current = current.n;
              } else {
                if (isSubject) {
                  points = current.p.z;
                  for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
                } else {
                  interpolate2(current.x, current.p.x, -1, stream);
                }
                current = current.p;
              }
              current = current.o;
              points = current.z;
              isSubject = !isSubject;
            } while (!current.v);
            stream.lineEnd();
          }
        }
        function link(array) {
          if (!(n = array.length)) return;
          var n, i = 0, a = array[0], b;
          while (++i < n) {
            a.n = b = array[i];
            b.p = a;
            a = b;
          }
          a.n = b = array[0];
          b.p = a;
        }
        var sum = adder();
        function longitude(point) {
          if (abs(point[0]) <= pi)
            return point[0];
          else
            return sign(point[0]) * ((abs(point[0]) + pi) % tau - pi);
        }
        function polygonContains(polygon, point) {
          var lambda = longitude(point), phi = point[1], sinPhi = sin(phi), normal = [sin(lambda), -cos(lambda), 0], angle2 = 0, winding = 0;
          sum.reset();
          if (sinPhi === 1) phi = halfPi + epsilon;
          else if (sinPhi === -1) phi = -halfPi - epsilon;
          for (var i = 0, n = polygon.length; i < n; ++i) {
            if (!(m = (ring = polygon[i]).length)) continue;
            var ring, m, point0 = ring[m - 1], lambda02 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi02 = sin(phi02), cosPhi02 = cos(phi02);
            for (var j = 0; j < m; ++j, lambda02 = lambda12, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
              var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi12), cosPhi1 = cos(phi12), delta = lambda12 - lambda02, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi, k = sinPhi02 * sinPhi1;
              sum.add(atan2(k * sign2 * sin(absDelta), cosPhi02 * cosPhi1 + k * cos(absDelta)));
              angle2 += antimeridian ? delta + sign2 * tau : delta;
              if (antimeridian ^ lambda02 >= lambda ^ lambda12 >= lambda) {
                var arc = cartesianCross(cartesian(point0), cartesian(point1));
                cartesianNormalizeInPlace(arc);
                var intersection = cartesianCross(normal, arc);
                cartesianNormalizeInPlace(intersection);
                var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
                if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
                  winding += antimeridian ^ delta >= 0 ? 1 : -1;
                }
              }
            }
          }
          return (angle2 < -epsilon || angle2 < epsilon && sum < -epsilon) ^ winding & 1;
        }
        function clip(pointVisible, clipLine2, interpolate2, start) {
          return function(sink) {
            var line = clipLine2(sink), ringBuffer = clipBuffer(), ringSink = clipLine2(ringBuffer), polygonStarted = false, polygon, segments, ring;
            var clip2 = {
              point,
              lineStart,
              lineEnd,
              polygonStart: function() {
                clip2.point = pointRing;
                clip2.lineStart = ringStart;
                clip2.lineEnd = ringEnd;
                segments = [];
                polygon = [];
              },
              polygonEnd: function() {
                clip2.point = point;
                clip2.lineStart = lineStart;
                clip2.lineEnd = lineEnd;
                segments = d3Array.merge(segments);
                var startInside = polygonContains(polygon, start);
                if (segments.length) {
                  if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
                  clipRejoin(segments, compareIntersection, startInside, interpolate2, sink);
                } else if (startInside) {
                  if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
                  sink.lineStart();
                  interpolate2(null, null, 1, sink);
                  sink.lineEnd();
                }
                if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
                segments = polygon = null;
              },
              sphere: function() {
                sink.polygonStart();
                sink.lineStart();
                interpolate2(null, null, 1, sink);
                sink.lineEnd();
                sink.polygonEnd();
              }
            };
            function point(lambda, phi) {
              if (pointVisible(lambda, phi)) sink.point(lambda, phi);
            }
            function pointLine(lambda, phi) {
              line.point(lambda, phi);
            }
            function lineStart() {
              clip2.point = pointLine;
              line.lineStart();
            }
            function lineEnd() {
              clip2.point = point;
              line.lineEnd();
            }
            function pointRing(lambda, phi) {
              ring.push([lambda, phi]);
              ringSink.point(lambda, phi);
            }
            function ringStart() {
              ringSink.lineStart();
              ring = [];
            }
            function ringEnd() {
              pointRing(ring[0][0], ring[0][1]);
              ringSink.lineEnd();
              var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point2;
              ring.pop();
              polygon.push(ring);
              ring = null;
              if (!n) return;
              if (clean & 1) {
                segment = ringSegments[0];
                if ((m = segment.length - 1) > 0) {
                  if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
                  sink.lineStart();
                  for (i = 0; i < m; ++i) sink.point((point2 = segment[i])[0], point2[1]);
                  sink.lineEnd();
                }
                return;
              }
              if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
              segments.push(ringSegments.filter(validSegment));
            }
            return clip2;
          };
        }
        function validSegment(segment) {
          return segment.length > 1;
        }
        function compareIntersection(a, b) {
          return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
        }
        var clipAntimeridian = clip(
          function() {
            return true;
          },
          clipAntimeridianLine,
          clipAntimeridianInterpolate,
          [-pi, -halfPi]
        );
        function clipAntimeridianLine(stream) {
          var lambda02 = NaN, phi02 = NaN, sign0 = NaN, clean;
          return {
            lineStart: function() {
              stream.lineStart();
              clean = 1;
            },
            point: function(lambda12, phi12) {
              var sign1 = lambda12 > 0 ? pi : -pi, delta = abs(lambda12 - lambda02);
              if (abs(delta - pi) < epsilon) {
                stream.point(lambda02, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi : -halfPi);
                stream.point(sign0, phi02);
                stream.lineEnd();
                stream.lineStart();
                stream.point(sign1, phi02);
                stream.point(lambda12, phi02);
                clean = 0;
              } else if (sign0 !== sign1 && delta >= pi) {
                if (abs(lambda02 - sign0) < epsilon) lambda02 -= sign0 * epsilon;
                if (abs(lambda12 - sign1) < epsilon) lambda12 -= sign1 * epsilon;
                phi02 = clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12);
                stream.point(sign0, phi02);
                stream.lineEnd();
                stream.lineStart();
                stream.point(sign1, phi02);
                clean = 0;
              }
              stream.point(lambda02 = lambda12, phi02 = phi12);
              sign0 = sign1;
            },
            lineEnd: function() {
              stream.lineEnd();
              lambda02 = phi02 = NaN;
            },
            clean: function() {
              return 2 - clean;
            }
          };
        }
        function clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12) {
          var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin(lambda02 - lambda12);
          return abs(sinLambda0Lambda1) > epsilon ? atan((sin(phi02) * (cosPhi1 = cos(phi12)) * sin(lambda12) - sin(phi12) * (cosPhi02 = cos(phi02)) * sin(lambda02)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
        }
        function clipAntimeridianInterpolate(from, to, direction, stream) {
          var phi;
          if (from == null) {
            phi = direction * halfPi;
            stream.point(-pi, phi);
            stream.point(0, phi);
            stream.point(pi, phi);
            stream.point(pi, 0);
            stream.point(pi, -phi);
            stream.point(0, -phi);
            stream.point(-pi, -phi);
            stream.point(-pi, 0);
            stream.point(-pi, phi);
          } else if (abs(from[0] - to[0]) > epsilon) {
            var lambda = from[0] < to[0] ? pi : -pi;
            phi = direction * lambda / 2;
            stream.point(-lambda, phi);
            stream.point(0, phi);
            stream.point(lambda, phi);
          } else {
            stream.point(to[0], to[1]);
          }
        }
        function clipCircle(radius) {
          var cr = cos(radius), delta = 6 * radians, smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon;
          function interpolate2(from, to, direction, stream) {
            circleStream(stream, radius, delta, direction, from, to);
          }
          function visible(lambda, phi) {
            return cos(lambda) * cos(phi) > cr;
          }
          function clipLine2(stream) {
            var point0, c0, v0, v00, clean;
            return {
              lineStart: function() {
                v00 = v0 = false;
                clean = 1;
              },
              point: function(lambda, phi) {
                var point1 = [lambda, phi], point2, v = visible(lambda, phi), c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
                if (!point0 && (v00 = v0 = v)) stream.lineStart();
                if (v !== v0) {
                  point2 = intersect(point0, point1);
                  if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
                    point1[2] = 1;
                }
                if (v !== v0) {
                  clean = 0;
                  if (v) {
                    stream.lineStart();
                    point2 = intersect(point1, point0);
                    stream.point(point2[0], point2[1]);
                  } else {
                    point2 = intersect(point0, point1);
                    stream.point(point2[0], point2[1], 2);
                    stream.lineEnd();
                  }
                  point0 = point2;
                } else if (notHemisphere && point0 && smallRadius ^ v) {
                  var t;
                  if (!(c & c0) && (t = intersect(point1, point0, true))) {
                    clean = 0;
                    if (smallRadius) {
                      stream.lineStart();
                      stream.point(t[0][0], t[0][1]);
                      stream.point(t[1][0], t[1][1]);
                      stream.lineEnd();
                    } else {
                      stream.point(t[1][0], t[1][1]);
                      stream.lineEnd();
                      stream.lineStart();
                      stream.point(t[0][0], t[0][1], 3);
                    }
                  }
                }
                if (v && (!point0 || !pointEqual(point0, point1))) {
                  stream.point(point1[0], point1[1]);
                }
                point0 = point1, v0 = v, c0 = c;
              },
              lineEnd: function() {
                if (v0) stream.lineEnd();
                point0 = null;
              },
              // Rejoin first and last segments if there were intersections and the first
              // and last points were visible.
              clean: function() {
                return clean | (v00 && v0) << 1;
              }
            };
          }
          function intersect(a, b, two) {
            var pa = cartesian(a), pb = cartesian(b);
            var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
            if (!determinant) return !two && a;
            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B = cartesianScale(n2, c2);
            cartesianAddInPlace(A, B);
            var u = n1xn2, w = cartesianDot(A, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A, A) - 1);
            if (t2 < 0) return;
            var t = sqrt(t2), q = cartesianScale(u, (-w - t) / uu);
            cartesianAddInPlace(q, A);
            q = spherical(q);
            if (!two) return q;
            var lambda02 = a[0], lambda12 = b[0], phi02 = a[1], phi12 = b[1], z;
            if (lambda12 < lambda02) z = lambda02, lambda02 = lambda12, lambda12 = z;
            var delta2 = lambda12 - lambda02, polar = abs(delta2 - pi) < epsilon, meridian = polar || delta2 < epsilon;
            if (!polar && phi12 < phi02) z = phi02, phi02 = phi12, phi12 = z;
            if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs(q[0] - lambda02) < epsilon ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi ^ (lambda02 <= q[0] && q[0] <= lambda12)) {
              var q1 = cartesianScale(u, (-w + t) / uu);
              cartesianAddInPlace(q1, A);
              return [q, spherical(q1)];
            }
          }
          function code(lambda, phi) {
            var r = smallRadius ? radius : pi - radius, code2 = 0;
            if (lambda < -r) code2 |= 1;
            else if (lambda > r) code2 |= 2;
            if (phi < -r) code2 |= 4;
            else if (phi > r) code2 |= 8;
            return code2;
          }
          return clip(visible, clipLine2, interpolate2, smallRadius ? [0, -radius] : [-pi, radius - pi]);
        }
        function clipLine(a, b, x02, y02, x12, y12) {
          var ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
          r = x02 - ax;
          if (!dx && r > 0) return;
          r /= dx;
          if (dx < 0) {
            if (r < t0) return;
            if (r < t1) t1 = r;
          } else if (dx > 0) {
            if (r > t1) return;
            if (r > t0) t0 = r;
          }
          r = x12 - ax;
          if (!dx && r < 0) return;
          r /= dx;
          if (dx < 0) {
            if (r > t1) return;
            if (r > t0) t0 = r;
          } else if (dx > 0) {
            if (r < t0) return;
            if (r < t1) t1 = r;
          }
          r = y02 - ay;
          if (!dy && r > 0) return;
          r /= dy;
          if (dy < 0) {
            if (r < t0) return;
            if (r < t1) t1 = r;
          } else if (dy > 0) {
            if (r > t1) return;
            if (r > t0) t0 = r;
          }
          r = y12 - ay;
          if (!dy && r < 0) return;
          r /= dy;
          if (dy < 0) {
            if (r > t1) return;
            if (r > t0) t0 = r;
          } else if (dy > 0) {
            if (r < t0) return;
            if (r < t1) t1 = r;
          }
          if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
          if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
          return true;
        }
        var clipMax = 1e9, clipMin = -clipMax;
        function clipRectangle(x02, y02, x12, y12) {
          function visible(x, y) {
            return x02 <= x && x <= x12 && y02 <= y && y <= y12;
          }
          function interpolate2(from, to, direction, stream) {
            var a = 0, a1 = 0;
            if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
              do
                stream.point(a === 0 || a === 3 ? x02 : x12, a > 1 ? y12 : y02);
              while ((a = (a + direction + 4) % 4) !== a1);
            } else {
              stream.point(to[0], to[1]);
            }
          }
          function corner(p, direction) {
            return abs(p[0] - x02) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x12) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y02) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
          }
          function compareIntersection2(a, b) {
            return comparePoint(a.x, b.x);
          }
          function comparePoint(a, b) {
            var ca = corner(a, 1), cb = corner(b, 1);
            return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
          }
          return function(stream) {
            var activeStream = stream, bufferStream = clipBuffer(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
            var clipStream = {
              point,
              lineStart,
              lineEnd,
              polygonStart,
              polygonEnd
            };
            function point(x, y) {
              if (visible(x, y)) activeStream.point(x, y);
            }
            function polygonInside() {
              var winding = 0;
              for (var i = 0, n = polygon.length; i < n; ++i) {
                for (var ring2 = polygon[i], j = 1, m = ring2.length, point2 = ring2[0], a0, a1, b0 = point2[0], b1 = point2[1]; j < m; ++j) {
                  a0 = b0, a1 = b1, point2 = ring2[j], b0 = point2[0], b1 = point2[1];
                  if (a1 <= y12) {
                    if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x02 - a0)) ++winding;
                  } else {
                    if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x02 - a0)) --winding;
                  }
                }
              }
              return winding;
            }
            function polygonStart() {
              activeStream = bufferStream, segments = [], polygon = [], clean = true;
            }
            function polygonEnd() {
              var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = d3Array.merge(segments)).length;
              if (cleanInside || visible2) {
                stream.polygonStart();
                if (cleanInside) {
                  stream.lineStart();
                  interpolate2(null, null, 1, stream);
                  stream.lineEnd();
                }
                if (visible2) {
                  clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream);
                }
                stream.polygonEnd();
              }
              activeStream = stream, segments = polygon = ring = null;
            }
            function lineStart() {
              clipStream.point = linePoint2;
              if (polygon) polygon.push(ring = []);
              first = true;
              v_ = false;
              x_ = y_ = NaN;
            }
            function lineEnd() {
              if (segments) {
                linePoint2(x__, y__);
                if (v__ && v_) bufferStream.rejoin();
                segments.push(bufferStream.result());
              }
              clipStream.point = point;
              if (v_) activeStream.lineEnd();
            }
            function linePoint2(x, y) {
              var v = visible(x, y);
              if (polygon) ring.push([x, y]);
              if (first) {
                x__ = x, y__ = y, v__ = v;
                first = false;
                if (v) {
                  activeStream.lineStart();
                  activeStream.point(x, y);
                }
              } else {
                if (v && v_) activeStream.point(x, y);
                else {
                  var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
                  if (clipLine(a, b, x02, y02, x12, y12)) {
                    if (!v_) {
                      activeStream.lineStart();
                      activeStream.point(a[0], a[1]);
                    }
                    activeStream.point(b[0], b[1]);
                    if (!v) activeStream.lineEnd();
                    clean = false;
                  } else if (v) {
                    activeStream.lineStart();
                    activeStream.point(x, y);
                    clean = false;
                  }
                }
              }
              x_ = x, y_ = y, v_ = v;
            }
            return clipStream;
          };
        }
        function extent() {
          var x02 = 0, y02 = 0, x12 = 960, y12 = 500, cache, cacheStream, clip2;
          return clip2 = {
            stream: function(stream) {
              return cache && cacheStream === stream ? cache : cache = clipRectangle(x02, y02, x12, y12)(cacheStream = stream);
            },
            extent: function(_) {
              return arguments.length ? (x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1], cache = cacheStream = null, clip2) : [[x02, y02], [x12, y12]];
            }
          };
        }
        var lengthSum = adder(), lambda0$2, sinPhi0$1, cosPhi0$1;
        var lengthStream = {
          sphere: noop,
          point: noop,
          lineStart: lengthLineStart,
          lineEnd: noop,
          polygonStart: noop,
          polygonEnd: noop
        };
        function lengthLineStart() {
          lengthStream.point = lengthPointFirst;
          lengthStream.lineEnd = lengthLineEnd;
        }
        function lengthLineEnd() {
          lengthStream.point = lengthStream.lineEnd = noop;
        }
        function lengthPointFirst(lambda, phi) {
          lambda *= radians, phi *= radians;
          lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);
          lengthStream.point = lengthPoint;
        }
        function lengthPoint(lambda, phi) {
          lambda *= radians, phi *= radians;
          var sinPhi = sin(phi), cosPhi = cos(phi), delta = abs(lambda - lambda0$2), cosDelta = cos(delta), sinDelta = sin(delta), x = cosPhi * sinDelta, y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta, z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
          lengthSum.add(atan2(sqrt(x * x + y * y), z));
          lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
        }
        function length(object2) {
          lengthSum.reset();
          geoStream(object2, lengthStream);
          return +lengthSum;
        }
        var coordinates = [null, null], object = { type: "LineString", coordinates };
        function distance(a, b) {
          coordinates[0] = a;
          coordinates[1] = b;
          return length(object);
        }
        var containsObjectType = {
          Feature: function(object2, point) {
            return containsGeometry(object2.geometry, point);
          },
          FeatureCollection: function(object2, point) {
            var features = object2.features, i = -1, n = features.length;
            while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
            return false;
          }
        };
        var containsGeometryType = {
          Sphere: function() {
            return true;
          },
          Point: function(object2, point) {
            return containsPoint(object2.coordinates, point);
          },
          MultiPoint: function(object2, point) {
            var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
            while (++i < n) if (containsPoint(coordinates2[i], point)) return true;
            return false;
          },
          LineString: function(object2, point) {
            return containsLine(object2.coordinates, point);
          },
          MultiLineString: function(object2, point) {
            var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
            while (++i < n) if (containsLine(coordinates2[i], point)) return true;
            return false;
          },
          Polygon: function(object2, point) {
            return containsPolygon(object2.coordinates, point);
          },
          MultiPolygon: function(object2, point) {
            var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
            while (++i < n) if (containsPolygon(coordinates2[i], point)) return true;
            return false;
          },
          GeometryCollection: function(object2, point) {
            var geometries = object2.geometries, i = -1, n = geometries.length;
            while (++i < n) if (containsGeometry(geometries[i], point)) return true;
            return false;
          }
        };
        function containsGeometry(geometry, point) {
          return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point) : false;
        }
        function containsPoint(coordinates2, point) {
          return distance(coordinates2, point) === 0;
        }
        function containsLine(coordinates2, point) {
          var ao, bo, ab;
          for (var i = 0, n = coordinates2.length; i < n; i++) {
            bo = distance(coordinates2[i], point);
            if (bo === 0) return true;
            if (i > 0) {
              ab = distance(coordinates2[i], coordinates2[i - 1]);
              if (ab > 0 && ao <= ab && bo <= ab && (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab)
                return true;
            }
            ao = bo;
          }
          return false;
        }
        function containsPolygon(coordinates2, point) {
          return !!polygonContains(coordinates2.map(ringRadians), pointRadians(point));
        }
        function ringRadians(ring) {
          return ring = ring.map(pointRadians), ring.pop(), ring;
        }
        function pointRadians(point) {
          return [point[0] * radians, point[1] * radians];
        }
        function contains(object2, point) {
          return (object2 && containsObjectType.hasOwnProperty(object2.type) ? containsObjectType[object2.type] : containsGeometry)(object2, point);
        }
        function graticuleX(y02, y12, dy) {
          var y = d3Array.range(y02, y12 - epsilon, dy).concat(y12);
          return function(x) {
            return y.map(function(y2) {
              return [x, y2];
            });
          };
        }
        function graticuleY(x02, x12, dx) {
          var x = d3Array.range(x02, x12 - epsilon, dx).concat(x12);
          return function(y) {
            return x.map(function(x2) {
              return [x2, y];
            });
          };
        }
        function graticule() {
          var x12, x02, X12, X02, y12, y02, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
          function graticule2() {
            return { type: "MultiLineString", coordinates: lines() };
          }
          function lines() {
            return d3Array.range(ceil(X02 / DX) * DX, X12, DX).map(X).concat(d3Array.range(ceil(Y02 / DY) * DY, Y12, DY).map(Y)).concat(d3Array.range(ceil(x02 / dx) * dx, x12, dx).filter(function(x2) {
              return abs(x2 % DX) > epsilon;
            }).map(x)).concat(d3Array.range(ceil(y02 / dy) * dy, y12, dy).filter(function(y2) {
              return abs(y2 % DY) > epsilon;
            }).map(y));
          }
          graticule2.lines = function() {
            return lines().map(function(coordinates2) {
              return { type: "LineString", coordinates: coordinates2 };
            });
          };
          graticule2.outline = function() {
            return {
              type: "Polygon",
              coordinates: [
                X(X02).concat(
                  Y(Y12).slice(1),
                  X(X12).reverse().slice(1),
                  Y(Y02).reverse().slice(1)
                )
              ]
            };
          };
          graticule2.extent = function(_) {
            if (!arguments.length) return graticule2.extentMinor();
            return graticule2.extentMajor(_).extentMinor(_);
          };
          graticule2.extentMajor = function(_) {
            if (!arguments.length) return [[X02, Y02], [X12, Y12]];
            X02 = +_[0][0], X12 = +_[1][0];
            Y02 = +_[0][1], Y12 = +_[1][1];
            if (X02 > X12) _ = X02, X02 = X12, X12 = _;
            if (Y02 > Y12) _ = Y02, Y02 = Y12, Y12 = _;
            return graticule2.precision(precision);
          };
          graticule2.extentMinor = function(_) {
            if (!arguments.length) return [[x02, y02], [x12, y12]];
            x02 = +_[0][0], x12 = +_[1][0];
            y02 = +_[0][1], y12 = +_[1][1];
            if (x02 > x12) _ = x02, x02 = x12, x12 = _;
            if (y02 > y12) _ = y02, y02 = y12, y12 = _;
            return graticule2.precision(precision);
          };
          graticule2.step = function(_) {
            if (!arguments.length) return graticule2.stepMinor();
            return graticule2.stepMajor(_).stepMinor(_);
          };
          graticule2.stepMajor = function(_) {
            if (!arguments.length) return [DX, DY];
            DX = +_[0], DY = +_[1];
            return graticule2;
          };
          graticule2.stepMinor = function(_) {
            if (!arguments.length) return [dx, dy];
            dx = +_[0], dy = +_[1];
            return graticule2;
          };
          graticule2.precision = function(_) {
            if (!arguments.length) return precision;
            precision = +_;
            x = graticuleX(y02, y12, 90);
            y = graticuleY(x02, x12, precision);
            X = graticuleX(Y02, Y12, 90);
            Y = graticuleY(X02, X12, precision);
            return graticule2;
          };
          return graticule2.extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]]).extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
        }
        function graticule10() {
          return graticule()();
        }
        function interpolate(a, b) {
          var x02 = a[0] * radians, y02 = a[1] * radians, x12 = b[0] * radians, y12 = b[1] * radians, cy0 = cos(y02), sy0 = sin(y02), cy1 = cos(y12), sy1 = sin(y12), kx0 = cy0 * cos(x02), ky0 = cy0 * sin(x02), kx1 = cy1 * cos(x12), ky1 = cy1 * sin(x12), d = 2 * asin(sqrt(haversin(y12 - y02) + cy0 * cy1 * haversin(x12 - x02))), k = sin(d);
          var interpolate2 = d ? function(t) {
            var B = sin(t *= d) / k, A = sin(d - t) / k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
            return [
              atan2(y, x) * degrees,
              atan2(z, sqrt(x * x + y * y)) * degrees
            ];
          } : function() {
            return [x02 * degrees, y02 * degrees];
          };
          interpolate2.distance = d;
          return interpolate2;
        }
        function identity(x) {
          return x;
        }
        var areaSum$1 = adder(), areaRingSum$1 = adder(), x00, y00, x0$1, y0$1;
        var areaStream$1 = {
          point: noop,
          lineStart: noop,
          lineEnd: noop,
          polygonStart: function() {
            areaStream$1.lineStart = areaRingStart$1;
            areaStream$1.lineEnd = areaRingEnd$1;
          },
          polygonEnd: function() {
            areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;
            areaSum$1.add(abs(areaRingSum$1));
            areaRingSum$1.reset();
          },
          result: function() {
            var area2 = areaSum$1 / 2;
            areaSum$1.reset();
            return area2;
          }
        };
        function areaRingStart$1() {
          areaStream$1.point = areaPointFirst$1;
        }
        function areaPointFirst$1(x, y) {
          areaStream$1.point = areaPoint$1;
          x00 = x0$1 = x, y00 = y0$1 = y;
        }
        function areaPoint$1(x, y) {
          areaRingSum$1.add(y0$1 * x - x0$1 * y);
          x0$1 = x, y0$1 = y;
        }
        function areaRingEnd$1() {
          areaPoint$1(x00, y00);
        }
        var x0$2 = Infinity, y0$2 = x0$2, x1 = -x0$2, y1 = x1;
        var boundsStream$1 = {
          point: boundsPoint$1,
          lineStart: noop,
          lineEnd: noop,
          polygonStart: noop,
          polygonEnd: noop,
          result: function() {
            var bounds2 = [[x0$2, y0$2], [x1, y1]];
            x1 = y1 = -(y0$2 = x0$2 = Infinity);
            return bounds2;
          }
        };
        function boundsPoint$1(x, y) {
          if (x < x0$2) x0$2 = x;
          if (x > x1) x1 = x;
          if (y < y0$2) y0$2 = y;
          if (y > y1) y1 = y;
        }
        var X0$1 = 0, Y0$1 = 0, Z0$1 = 0, X1$1 = 0, Y1$1 = 0, Z1$1 = 0, X2$1 = 0, Y2$1 = 0, Z2$1 = 0, x00$1, y00$1, x0$3, y0$3;
        var centroidStream$1 = {
          point: centroidPoint$1,
          lineStart: centroidLineStart$1,
          lineEnd: centroidLineEnd$1,
          polygonStart: function() {
            centroidStream$1.lineStart = centroidRingStart$1;
            centroidStream$1.lineEnd = centroidRingEnd$1;
          },
          polygonEnd: function() {
            centroidStream$1.point = centroidPoint$1;
            centroidStream$1.lineStart = centroidLineStart$1;
            centroidStream$1.lineEnd = centroidLineEnd$1;
          },
          result: function() {
            var centroid2 = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1] : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1] : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1] : [NaN, NaN];
            X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = X2$1 = Y2$1 = Z2$1 = 0;
            return centroid2;
          }
        };
        function centroidPoint$1(x, y) {
          X0$1 += x;
          Y0$1 += y;
          ++Z0$1;
        }
        function centroidLineStart$1() {
          centroidStream$1.point = centroidPointFirstLine;
        }
        function centroidPointFirstLine(x, y) {
          centroidStream$1.point = centroidPointLine;
          centroidPoint$1(x0$3 = x, y0$3 = y);
        }
        function centroidPointLine(x, y) {
          var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
          X1$1 += z * (x0$3 + x) / 2;
          Y1$1 += z * (y0$3 + y) / 2;
          Z1$1 += z;
          centroidPoint$1(x0$3 = x, y0$3 = y);
        }
        function centroidLineEnd$1() {
          centroidStream$1.point = centroidPoint$1;
        }
        function centroidRingStart$1() {
          centroidStream$1.point = centroidPointFirstRing;
        }
        function centroidRingEnd$1() {
          centroidPointRing(x00$1, y00$1);
        }
        function centroidPointFirstRing(x, y) {
          centroidStream$1.point = centroidPointRing;
          centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
        }
        function centroidPointRing(x, y) {
          var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
          X1$1 += z * (x0$3 + x) / 2;
          Y1$1 += z * (y0$3 + y) / 2;
          Z1$1 += z;
          z = y0$3 * x - x0$3 * y;
          X2$1 += z * (x0$3 + x);
          Y2$1 += z * (y0$3 + y);
          Z2$1 += z * 3;
          centroidPoint$1(x0$3 = x, y0$3 = y);
        }
        function PathContext(context) {
          this._context = context;
        }
        PathContext.prototype = {
          _radius: 4.5,
          pointRadius: function(_) {
            return this._radius = _, this;
          },
          polygonStart: function() {
            this._line = 0;
          },
          polygonEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._point = 0;
          },
          lineEnd: function() {
            if (this._line === 0) this._context.closePath();
            this._point = NaN;
          },
          point: function(x, y) {
            switch (this._point) {
              case 0: {
                this._context.moveTo(x, y);
                this._point = 1;
                break;
              }
              case 1: {
                this._context.lineTo(x, y);
                break;
              }
              default: {
                this._context.moveTo(x + this._radius, y);
                this._context.arc(x, y, this._radius, 0, tau);
                break;
              }
            }
          },
          result: noop
        };
        var lengthSum$1 = adder(), lengthRing, x00$2, y00$2, x0$4, y0$4;
        var lengthStream$1 = {
          point: noop,
          lineStart: function() {
            lengthStream$1.point = lengthPointFirst$1;
          },
          lineEnd: function() {
            if (lengthRing) lengthPoint$1(x00$2, y00$2);
            lengthStream$1.point = noop;
          },
          polygonStart: function() {
            lengthRing = true;
          },
          polygonEnd: function() {
            lengthRing = null;
          },
          result: function() {
            var length2 = +lengthSum$1;
            lengthSum$1.reset();
            return length2;
          }
        };
        function lengthPointFirst$1(x, y) {
          lengthStream$1.point = lengthPoint$1;
          x00$2 = x0$4 = x, y00$2 = y0$4 = y;
        }
        function lengthPoint$1(x, y) {
          x0$4 -= x, y0$4 -= y;
          lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
          x0$4 = x, y0$4 = y;
        }
        function PathString() {
          this._string = [];
        }
        PathString.prototype = {
          _radius: 4.5,
          _circle: circle$1(4.5),
          pointRadius: function(_) {
            if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
            return this;
          },
          polygonStart: function() {
            this._line = 0;
          },
          polygonEnd: function() {
            this._line = NaN;
          },
          lineStart: function() {
            this._point = 0;
          },
          lineEnd: function() {
            if (this._line === 0) this._string.push("Z");
            this._point = NaN;
          },
          point: function(x, y) {
            switch (this._point) {
              case 0: {
                this._string.push("M", x, ",", y);
                this._point = 1;
                break;
              }
              case 1: {
                this._string.push("L", x, ",", y);
                break;
              }
              default: {
                if (this._circle == null) this._circle = circle$1(this._radius);
                this._string.push("M", x, ",", y, this._circle);
                break;
              }
            }
          },
          result: function() {
            if (this._string.length) {
              var result = this._string.join("");
              this._string = [];
              return result;
            } else {
              return null;
            }
          }
        };
        function circle$1(radius) {
          return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
        }
        function index(projection2, context) {
          var pointRadius = 4.5, projectionStream, contextStream;
          function path(object2) {
            if (object2) {
              if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
              geoStream(object2, projectionStream(contextStream));
            }
            return contextStream.result();
          }
          path.area = function(object2) {
            geoStream(object2, projectionStream(areaStream$1));
            return areaStream$1.result();
          };
          path.measure = function(object2) {
            geoStream(object2, projectionStream(lengthStream$1));
            return lengthStream$1.result();
          };
          path.bounds = function(object2) {
            geoStream(object2, projectionStream(boundsStream$1));
            return boundsStream$1.result();
          };
          path.centroid = function(object2) {
            geoStream(object2, projectionStream(centroidStream$1));
            return centroidStream$1.result();
          };
          path.projection = function(_) {
            return arguments.length ? (projectionStream = _ == null ? (projection2 = null, identity) : (projection2 = _).stream, path) : projection2;
          };
          path.context = function(_) {
            if (!arguments.length) return context;
            contextStream = _ == null ? (context = null, new PathString()) : new PathContext(context = _);
            if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
            return path;
          };
          path.pointRadius = function(_) {
            if (!arguments.length) return pointRadius;
            pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
            return path;
          };
          return path.projection(projection2).context(context);
        }
        function transform(methods) {
          return {
            stream: transformer(methods)
          };
        }
        function transformer(methods) {
          return function(stream) {
            var s = new TransformStream();
            for (var key in methods) s[key] = methods[key];
            s.stream = stream;
            return s;
          };
        }
        function TransformStream() {
        }
        TransformStream.prototype = {
          constructor: TransformStream,
          point: function(x, y) {
            this.stream.point(x, y);
          },
          sphere: function() {
            this.stream.sphere();
          },
          lineStart: function() {
            this.stream.lineStart();
          },
          lineEnd: function() {
            this.stream.lineEnd();
          },
          polygonStart: function() {
            this.stream.polygonStart();
          },
          polygonEnd: function() {
            this.stream.polygonEnd();
          }
        };
        function fit(projection2, fitBounds, object2) {
          var clip2 = projection2.clipExtent && projection2.clipExtent();
          projection2.scale(150).translate([0, 0]);
          if (clip2 != null) projection2.clipExtent(null);
          geoStream(object2, projection2.stream(boundsStream$1));
          fitBounds(boundsStream$1.result());
          if (clip2 != null) projection2.clipExtent(clip2);
          return projection2;
        }
        function fitExtent(projection2, extent2, object2) {
          return fit(projection2, function(b) {
            var w = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent2[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent2[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
            projection2.scale(150 * k).translate([x, y]);
          }, object2);
        }
        function fitSize(projection2, size, object2) {
          return fitExtent(projection2, [[0, 0], size], object2);
        }
        function fitWidth(projection2, width, object2) {
          return fit(projection2, function(b) {
            var w = +width, k = w / (b[1][0] - b[0][0]), x = (w - k * (b[1][0] + b[0][0])) / 2, y = -k * b[0][1];
            projection2.scale(150 * k).translate([x, y]);
          }, object2);
        }
        function fitHeight(projection2, height, object2) {
          return fit(projection2, function(b) {
            var h = +height, k = h / (b[1][1] - b[0][1]), x = -k * b[0][0], y = (h - k * (b[1][1] + b[0][1])) / 2;
            projection2.scale(150 * k).translate([x, y]);
          }, object2);
        }
        var maxDepth = 16, cosMinDistance = cos(30 * radians);
        function resample(project, delta2) {
          return +delta2 ? resample$1(project, delta2) : resampleNone(project);
        }
        function resampleNone(project) {
          return transformer({
            point: function(x, y) {
              x = project(x, y);
              this.stream.point(x[0], x[1]);
            }
          });
        }
        function resample$1(project, delta2) {
          function resampleLineTo(x02, y02, lambda02, a0, b0, c0, x12, y12, lambda12, a1, b1, c1, depth, stream) {
            var dx = x12 - x02, dy = y12 - y02, d2 = dx * dx + dy * dy;
            if (d2 > 4 * delta2 && depth--) {
              var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = sqrt(a * a + b * b + c * c), phi2 = asin(c /= m), lambda22 = abs(abs(c) - 1) < epsilon || abs(lambda02 - lambda12) < epsilon ? (lambda02 + lambda12) / 2 : atan2(b, a), p = project(lambda22, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x02, dy2 = y2 - y02, dz = dy * dx2 - dx * dy2;
              if (dz * dz / d2 > delta2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                resampleLineTo(x02, y02, lambda02, a0, b0, c0, x2, y2, lambda22, a /= m, b /= m, c, depth, stream);
                stream.point(x2, y2);
                resampleLineTo(x2, y2, lambda22, a, b, c, x12, y12, lambda12, a1, b1, c1, depth, stream);
              }
            }
          }
          return function(stream) {
            var lambda002, x002, y002, a00, b00, c00, lambda02, x02, y02, a0, b0, c0;
            var resampleStream = {
              point,
              lineStart,
              lineEnd,
              polygonStart: function() {
                stream.polygonStart();
                resampleStream.lineStart = ringStart;
              },
              polygonEnd: function() {
                stream.polygonEnd();
                resampleStream.lineStart = lineStart;
              }
            };
            function point(x, y) {
              x = project(x, y);
              stream.point(x[0], x[1]);
            }
            function lineStart() {
              x02 = NaN;
              resampleStream.point = linePoint2;
              stream.lineStart();
            }
            function linePoint2(lambda, phi) {
              var c = cartesian([lambda, phi]), p = project(lambda, phi);
              resampleLineTo(x02, y02, lambda02, a0, b0, c0, x02 = p[0], y02 = p[1], lambda02 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
              stream.point(x02, y02);
            }
            function lineEnd() {
              resampleStream.point = point;
              stream.lineEnd();
            }
            function ringStart() {
              lineStart();
              resampleStream.point = ringPoint;
              resampleStream.lineEnd = ringEnd;
            }
            function ringPoint(lambda, phi) {
              linePoint2(lambda002 = lambda, phi), x002 = x02, y002 = y02, a00 = a0, b00 = b0, c00 = c0;
              resampleStream.point = linePoint2;
            }
            function ringEnd() {
              resampleLineTo(x02, y02, lambda02, a0, b0, c0, x002, y002, lambda002, a00, b00, c00, maxDepth, stream);
              resampleStream.lineEnd = lineEnd;
              lineEnd();
            }
            return resampleStream;
          };
        }
        var transformRadians = transformer({
          point: function(x, y) {
            this.stream.point(x * radians, y * radians);
          }
        });
        function transformRotate(rotate) {
          return transformer({
            point: function(x, y) {
              var r = rotate(x, y);
              return this.stream.point(r[0], r[1]);
            }
          });
        }
        function scaleTranslate(k, dx, dy, sx, sy) {
          function transform2(x, y) {
            x *= sx;
            y *= sy;
            return [dx + k * x, dy - k * y];
          }
          transform2.invert = function(x, y) {
            return [(x - dx) / k * sx, (dy - y) / k * sy];
          };
          return transform2;
        }
        function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
          var cosAlpha = cos(alpha), sinAlpha = sin(alpha), a = cosAlpha * k, b = sinAlpha * k, ai = cosAlpha / k, bi = sinAlpha / k, ci = (sinAlpha * dy - cosAlpha * dx) / k, fi = (sinAlpha * dx + cosAlpha * dy) / k;
          function transform2(x, y) {
            x *= sx;
            y *= sy;
            return [a * x - b * y + dx, dy - b * x - a * y];
          }
          transform2.invert = function(x, y) {
            return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
          };
          return transform2;
        }
        function projection(project) {
          return projectionMutator(function() {
            return project;
          })();
        }
        function projectionMutator(projectAt) {
          var project, k = 150, x = 480, y = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = clipAntimeridian, x02 = null, y02, x12, y12, postclip = identity, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
          function projection2(point) {
            return projectRotateTransform(point[0] * radians, point[1] * radians);
          }
          function invert(point) {
            point = projectRotateTransform.invert(point[0], point[1]);
            return point && [point[0] * degrees, point[1] * degrees];
          }
          projection2.stream = function(stream) {
            return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
          };
          projection2.preclip = function(_) {
            return arguments.length ? (preclip = _, theta = void 0, reset()) : preclip;
          };
          projection2.postclip = function(_) {
            return arguments.length ? (postclip = _, x02 = y02 = x12 = y12 = null, reset()) : postclip;
          };
          projection2.clipAngle = function(_) {
            return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
          };
          projection2.clipExtent = function(_) {
            return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity) : clipRectangle(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
          };
          projection2.scale = function(_) {
            return arguments.length ? (k = +_, recenter()) : k;
          };
          projection2.translate = function(_) {
            return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
          };
          projection2.center = function(_) {
            return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
          };
          projection2.rotate = function(_) {
            return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
          };
          projection2.angle = function(_) {
            return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
          };
          projection2.reflectX = function(_) {
            return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
          };
          projection2.reflectY = function(_) {
            return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
          };
          projection2.precision = function(_) {
            return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
          };
          projection2.fitExtent = function(extent2, object2) {
            return fitExtent(projection2, extent2, object2);
          };
          projection2.fitSize = function(size, object2) {
            return fitSize(projection2, size, object2);
          };
          projection2.fitWidth = function(width, object2) {
            return fitWidth(projection2, width, object2);
          };
          projection2.fitHeight = function(height, object2) {
            return fitHeight(projection2, height, object2);
          };
          function recenter() {
            var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)), transform2 = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], sx, sy, alpha);
            rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
            projectTransform = compose(project, transform2);
            projectRotateTransform = compose(rotate, projectTransform);
            projectResample = resample(projectTransform, delta2);
            return reset();
          }
          function reset() {
            cache = cacheStream = null;
            return projection2;
          }
          return function() {
            project = projectAt.apply(this, arguments);
            projection2.invert = project.invert && invert;
            return recenter();
          };
        }
        function conicProjection(projectAt) {
          var phi02 = 0, phi12 = pi / 3, m = projectionMutator(projectAt), p = m(phi02, phi12);
          p.parallels = function(_) {
            return arguments.length ? m(phi02 = _[0] * radians, phi12 = _[1] * radians) : [phi02 * degrees, phi12 * degrees];
          };
          return p;
        }
        function cylindricalEqualAreaRaw(phi02) {
          var cosPhi02 = cos(phi02);
          function forward(lambda, phi) {
            return [lambda * cosPhi02, sin(phi) / cosPhi02];
          }
          forward.invert = function(x, y) {
            return [x / cosPhi02, asin(y * cosPhi02)];
          };
          return forward;
        }
        function conicEqualAreaRaw(y02, y12) {
          var sy0 = sin(y02), n = (sy0 + sin(y12)) / 2;
          if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y02);
          var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;
          function project(x, y) {
            var r = sqrt(c - 2 * n * sin(y)) / n;
            return [r * sin(x *= n), r0 - r * cos(x)];
          }
          project.invert = function(x, y) {
            var r0y = r0 - y, l = atan2(x, abs(r0y)) * sign(r0y);
            if (r0y * n < 0)
              l -= pi * sign(x) * sign(r0y);
            return [l / n, asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
          };
          return project;
        }
        function conicEqualArea() {
          return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
        }
        function albers() {
          return conicEqualArea().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
        }
        function multiplex(streams) {
          var n = streams.length;
          return {
            point: function(x, y) {
              var i = -1;
              while (++i < n) streams[i].point(x, y);
            },
            sphere: function() {
              var i = -1;
              while (++i < n) streams[i].sphere();
            },
            lineStart: function() {
              var i = -1;
              while (++i < n) streams[i].lineStart();
            },
            lineEnd: function() {
              var i = -1;
              while (++i < n) streams[i].lineEnd();
            },
            polygonStart: function() {
              var i = -1;
              while (++i < n) streams[i].polygonStart();
            },
            polygonEnd: function() {
              var i = -1;
              while (++i < n) streams[i].polygonEnd();
            }
          };
        }
        function albersUsa() {
          var cache, cacheStream, lower48 = albers(), lower48Point, alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point, pointStream = { point: function(x, y) {
            point = [x, y];
          } };
          function albersUsa2(coordinates2) {
            var x = coordinates2[0], y = coordinates2[1];
            return point = null, (lower48Point.point(x, y), point) || (alaskaPoint.point(x, y), point) || (hawaiiPoint.point(x, y), point);
          }
          albersUsa2.invert = function(coordinates2) {
            var k = lower48.scale(), t = lower48.translate(), x = (coordinates2[0] - t[0]) / k, y = (coordinates2[1] - t[1]) / k;
            return (y >= 0.12 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates2);
          };
          albersUsa2.stream = function(stream) {
            return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
          };
          albersUsa2.precision = function(_) {
            if (!arguments.length) return lower48.precision();
            lower48.precision(_), alaska.precision(_), hawaii.precision(_);
            return reset();
          };
          albersUsa2.scale = function(_) {
            if (!arguments.length) return lower48.scale();
            lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
            return albersUsa2.translate(lower48.translate());
          };
          albersUsa2.translate = function(_) {
            if (!arguments.length) return lower48.translate();
            var k = lower48.scale(), x = +_[0], y = +_[1];
            lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);
            alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + epsilon, y + 0.12 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);
            hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);
            return reset();
          };
          albersUsa2.fitExtent = function(extent2, object2) {
            return fitExtent(albersUsa2, extent2, object2);
          };
          albersUsa2.fitSize = function(size, object2) {
            return fitSize(albersUsa2, size, object2);
          };
          albersUsa2.fitWidth = function(width, object2) {
            return fitWidth(albersUsa2, width, object2);
          };
          albersUsa2.fitHeight = function(height, object2) {
            return fitHeight(albersUsa2, height, object2);
          };
          function reset() {
            cache = cacheStream = null;
            return albersUsa2;
          }
          return albersUsa2.scale(1070);
        }
        function azimuthalRaw(scale) {
          return function(x, y) {
            var cx = cos(x), cy = cos(y), k = scale(cx * cy);
            return [
              k * cy * sin(x),
              k * sin(y)
            ];
          };
        }
        function azimuthalInvert(angle2) {
          return function(x, y) {
            var z = sqrt(x * x + y * y), c = angle2(z), sc = sin(c), cc = cos(c);
            return [
              atan2(x * sc, z * cc),
              asin(z && y * sc / z)
            ];
          };
        }
        var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
          return sqrt(2 / (1 + cxcy));
        });
        azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
          return 2 * asin(z / 2);
        });
        function azimuthalEqualArea() {
          return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
        }
        var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
          return (c = acos(c)) && c / sin(c);
        });
        azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
          return z;
        });
        function azimuthalEquidistant() {
          return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
        }
        function mercatorRaw(lambda, phi) {
          return [lambda, log(tan((halfPi + phi) / 2))];
        }
        mercatorRaw.invert = function(x, y) {
          return [x, 2 * atan(exp(y)) - halfPi];
        };
        function mercator() {
          return mercatorProjection(mercatorRaw).scale(961 / tau);
        }
        function mercatorProjection(project) {
          var m = projection(project), center = m.center, scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, x02 = null, y02, x12, y12;
          m.scale = function(_) {
            return arguments.length ? (scale(_), reclip()) : scale();
          };
          m.translate = function(_) {
            return arguments.length ? (translate(_), reclip()) : translate();
          };
          m.center = function(_) {
            return arguments.length ? (center(_), reclip()) : center();
          };
          m.clipExtent = function(_) {
            return arguments.length ? (_ == null ? x02 = y02 = x12 = y12 = null : (x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x02 == null ? null : [[x02, y02], [x12, y12]];
          };
          function reclip() {
            var k = pi * scale(), t = m(rotation(m.rotate()).invert([0, 0]));
            return clipExtent(x02 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x02), y02], [Math.min(t[0] + k, x12), y12]] : [[x02, Math.max(t[1] - k, y02)], [x12, Math.min(t[1] + k, y12)]]);
          }
          return reclip();
        }
        function tany(y) {
          return tan((halfPi + y) / 2);
        }
        function conicConformalRaw(y02, y12) {
          var cy0 = cos(y02), n = y02 === y12 ? sin(y02) : log(cy0 / cos(y12)) / log(tany(y12) / tany(y02)), f = cy0 * pow(tany(y02), n) / n;
          if (!n) return mercatorRaw;
          function project(x, y) {
            if (f > 0) {
              if (y < -halfPi + epsilon) y = -halfPi + epsilon;
            } else {
              if (y > halfPi - epsilon) y = halfPi - epsilon;
            }
            var r = f / pow(tany(y), n);
            return [r * sin(n * x), f - r * cos(n * x)];
          }
          project.invert = function(x, y) {
            var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy), l = atan2(x, abs(fy)) * sign(fy);
            if (fy * n < 0)
              l -= pi * sign(x) * sign(fy);
            return [l / n, 2 * atan(pow(f / r, 1 / n)) - halfPi];
          };
          return project;
        }
        function conicConformal() {
          return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
        }
        function equirectangularRaw(lambda, phi) {
          return [lambda, phi];
        }
        equirectangularRaw.invert = equirectangularRaw;
        function equirectangular() {
          return projection(equirectangularRaw).scale(152.63);
        }
        function conicEquidistantRaw(y02, y12) {
          var cy0 = cos(y02), n = y02 === y12 ? sin(y02) : (cy0 - cos(y12)) / (y12 - y02), g = cy0 / n + y02;
          if (abs(n) < epsilon) return equirectangularRaw;
          function project(x, y) {
            var gy = g - y, nx = n * x;
            return [gy * sin(nx), g - gy * cos(nx)];
          }
          project.invert = function(x, y) {
            var gy = g - y, l = atan2(x, abs(gy)) * sign(gy);
            if (gy * n < 0)
              l -= pi * sign(x) * sign(gy);
            return [l / n, g - sign(n) * sqrt(x * x + gy * gy)];
          };
          return project;
        }
        function conicEquidistant() {
          return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
        }
        var A1 = 1.340264, A2 = -0.081106, A3 = 893e-6, A4 = 3796e-6, M = sqrt(3) / 2, iterations = 12;
        function equalEarthRaw(lambda, phi) {
          var l = asin(M * sin(phi)), l2 = l * l, l6 = l2 * l2 * l2;
          return [
            lambda * cos(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
            l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
          ];
        }
        equalEarthRaw.invert = function(x, y) {
          var l = y, l2 = l * l, l6 = l2 * l2 * l2;
          for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
            fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
            fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
            l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
            if (abs(delta) < epsilon2) break;
          }
          return [
            M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos(l),
            asin(sin(l) / M)
          ];
        };
        function equalEarth() {
          return projection(equalEarthRaw).scale(177.158);
        }
        function gnomonicRaw(x, y) {
          var cy = cos(y), k = cos(x) * cy;
          return [cy * sin(x) / k, sin(y) / k];
        }
        gnomonicRaw.invert = azimuthalInvert(atan);
        function gnomonic() {
          return projection(gnomonicRaw).scale(144.049).clipAngle(60);
        }
        function identity$1() {
          var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x02 = null, y02, x12, y12, kx = 1, ky = 1, transform2 = transformer({
            point: function(x, y) {
              var p = projection2([x, y]);
              this.stream.point(p[0], p[1]);
            }
          }), postclip = identity, cache, cacheStream;
          function reset() {
            kx = k * sx;
            ky = k * sy;
            cache = cacheStream = null;
            return projection2;
          }
          function projection2(p) {
            var x = p[0] * kx, y = p[1] * ky;
            if (alpha) {
              var t = y * ca - x * sa;
              x = x * ca + y * sa;
              y = t;
            }
            return [x + tx, y + ty];
          }
          projection2.invert = function(p) {
            var x = p[0] - tx, y = p[1] - ty;
            if (alpha) {
              var t = y * ca + x * sa;
              x = x * ca - y * sa;
              y = t;
            }
            return [x / kx, y / ky];
          };
          projection2.stream = function(stream) {
            return cache && cacheStream === stream ? cache : cache = transform2(postclip(cacheStream = stream));
          };
          projection2.postclip = function(_) {
            return arguments.length ? (postclip = _, x02 = y02 = x12 = y12 = null, reset()) : postclip;
          };
          projection2.clipExtent = function(_) {
            return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity) : clipRectangle(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
          };
          projection2.scale = function(_) {
            return arguments.length ? (k = +_, reset()) : k;
          };
          projection2.translate = function(_) {
            return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
          };
          projection2.angle = function(_) {
            return arguments.length ? (alpha = _ % 360 * radians, sa = sin(alpha), ca = cos(alpha), reset()) : alpha * degrees;
          };
          projection2.reflectX = function(_) {
            return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
          };
          projection2.reflectY = function(_) {
            return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
          };
          projection2.fitExtent = function(extent2, object2) {
            return fitExtent(projection2, extent2, object2);
          };
          projection2.fitSize = function(size, object2) {
            return fitSize(projection2, size, object2);
          };
          projection2.fitWidth = function(width, object2) {
            return fitWidth(projection2, width, object2);
          };
          projection2.fitHeight = function(height, object2) {
            return fitHeight(projection2, height, object2);
          };
          return projection2;
        }
        function naturalEarth1Raw(lambda, phi) {
          var phi2 = phi * phi, phi4 = phi2 * phi2;
          return [
            lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi2 - 1529e-6 * phi4))),
            phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4)))
          ];
        }
        naturalEarth1Raw.invert = function(x, y) {
          var phi = y, i = 25, delta;
          do {
            var phi2 = phi * phi, phi4 = phi2 * phi2;
            phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4))) - y) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 5916e-6 * 11 * phi4)));
          } while (abs(delta) > epsilon && --i > 0);
          return [
            x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (3971e-6 - 1529e-6 * phi2)))),
            phi
          ];
        };
        function naturalEarth1() {
          return projection(naturalEarth1Raw).scale(175.295);
        }
        function orthographicRaw(x, y) {
          return [cos(y) * sin(x), sin(y)];
        }
        orthographicRaw.invert = azimuthalInvert(asin);
        function orthographic() {
          return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon);
        }
        function stereographicRaw(x, y) {
          var cy = cos(y), k = 1 + cos(x) * cy;
          return [cy * sin(x) / k, sin(y) / k];
        }
        stereographicRaw.invert = azimuthalInvert(function(z) {
          return 2 * atan(z);
        });
        function stereographic() {
          return projection(stereographicRaw).scale(250).clipAngle(142);
        }
        function transverseMercatorRaw(lambda, phi) {
          return [log(tan((halfPi + phi) / 2)), -lambda];
        }
        transverseMercatorRaw.invert = function(x, y) {
          return [-y, 2 * atan(exp(x)) - halfPi];
        };
        function transverseMercator() {
          var m = mercatorProjection(transverseMercatorRaw), center = m.center, rotate = m.rotate;
          m.center = function(_) {
            return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
          };
          m.rotate = function(_) {
            return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
          };
          return rotate([0, 0, 90]).scale(159.155);
        }
        exports2.geoAlbers = albers;
        exports2.geoAlbersUsa = albersUsa;
        exports2.geoArea = area;
        exports2.geoAzimuthalEqualArea = azimuthalEqualArea;
        exports2.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
        exports2.geoAzimuthalEquidistant = azimuthalEquidistant;
        exports2.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
        exports2.geoBounds = bounds;
        exports2.geoCentroid = centroid;
        exports2.geoCircle = circle;
        exports2.geoClipAntimeridian = clipAntimeridian;
        exports2.geoClipCircle = clipCircle;
        exports2.geoClipExtent = extent;
        exports2.geoClipRectangle = clipRectangle;
        exports2.geoConicConformal = conicConformal;
        exports2.geoConicConformalRaw = conicConformalRaw;
        exports2.geoConicEqualArea = conicEqualArea;
        exports2.geoConicEqualAreaRaw = conicEqualAreaRaw;
        exports2.geoConicEquidistant = conicEquidistant;
        exports2.geoConicEquidistantRaw = conicEquidistantRaw;
        exports2.geoContains = contains;
        exports2.geoDistance = distance;
        exports2.geoEqualEarth = equalEarth;
        exports2.geoEqualEarthRaw = equalEarthRaw;
        exports2.geoEquirectangular = equirectangular;
        exports2.geoEquirectangularRaw = equirectangularRaw;
        exports2.geoGnomonic = gnomonic;
        exports2.geoGnomonicRaw = gnomonicRaw;
        exports2.geoGraticule = graticule;
        exports2.geoGraticule10 = graticule10;
        exports2.geoIdentity = identity$1;
        exports2.geoInterpolate = interpolate;
        exports2.geoLength = length;
        exports2.geoMercator = mercator;
        exports2.geoMercatorRaw = mercatorRaw;
        exports2.geoNaturalEarth1 = naturalEarth1;
        exports2.geoNaturalEarth1Raw = naturalEarth1Raw;
        exports2.geoOrthographic = orthographic;
        exports2.geoOrthographicRaw = orthographicRaw;
        exports2.geoPath = index;
        exports2.geoProjection = projection;
        exports2.geoProjectionMutator = projectionMutator;
        exports2.geoRotation = rotation;
        exports2.geoStereographic = stereographic;
        exports2.geoStereographicRaw = stereographicRaw;
        exports2.geoStream = geoStream;
        exports2.geoTransform = transform;
        exports2.geoTransverseMercator = transverseMercator;
        exports2.geoTransverseMercatorRaw = transverseMercatorRaw;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/d3-geo-projection/dist/d3-geo-projection.js
  var require_d3_geo_projection = __commonJS({
    "node_modules/d3-geo-projection/dist/d3-geo-projection.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_geo(), require_d3_array()) : typeof define === "function" && false ? define(["exports", "d3-geo", "d3-array"], factory) : factory(global2.d3 = global2.d3 || {}, global2.d3, global2.d3);
      })(exports, function(exports2, d3Geo, d3Array) {
        "use strict";
        var abs = Math.abs;
        var atan = Math.atan;
        var atan2 = Math.atan2;
        var cos = Math.cos;
        var exp = Math.exp;
        var floor = Math.floor;
        var log = Math.log;
        var max = Math.max;
        var min = Math.min;
        var pow = Math.pow;
        var round = Math.round;
        var sign = Math.sign || function(x) {
          return x > 0 ? 1 : x < 0 ? -1 : 0;
        };
        var sin = Math.sin;
        var tan = Math.tan;
        var epsilon = 1e-6;
        var epsilon2 = 1e-12;
        var pi = Math.PI;
        var halfPi = pi / 2;
        var quarterPi = pi / 4;
        var sqrt1_2 = Math.SQRT1_2;
        var sqrt2 = sqrt(2);
        var sqrtPi = sqrt(pi);
        var tau = pi * 2;
        var degrees = 180 / pi;
        var radians = pi / 180;
        function sinci(x) {
          return x ? x / Math.sin(x) : 1;
        }
        function asin(x) {
          return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
        }
        function acos(x) {
          return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
        }
        function sqrt(x) {
          return x > 0 ? Math.sqrt(x) : 0;
        }
        function tanh(x) {
          x = exp(2 * x);
          return (x - 1) / (x + 1);
        }
        function sinh(x) {
          return (exp(x) - exp(-x)) / 2;
        }
        function cosh(x) {
          return (exp(x) + exp(-x)) / 2;
        }
        function arsinh(x) {
          return log(x + sqrt(x * x + 1));
        }
        function arcosh(x) {
          return log(x + sqrt(x * x - 1));
        }
        function airyRaw(beta) {
          var tanBeta_2 = tan(beta / 2), b = 2 * log(cos(beta / 2)) / (tanBeta_2 * tanBeta_2);
          function forward(x, y) {
            var cosx = cos(x), cosy = cos(y), siny = sin(y), cosz = cosy * cosx, k2 = -((1 - cosz ? log((1 + cosz) / 2) / (1 - cosz) : -0.5) + b / (1 + cosz));
            return [k2 * cosy * sin(x), k2 * siny];
          }
          forward.invert = function(x, y) {
            var r = sqrt(x * x + y * y), z = -beta / 2, i = 50, delta;
            if (!r) return [0, 0];
            do {
              var z_2 = z / 2, cosz_2 = cos(z_2), sinz_2 = sin(z_2), tanz_2 = sinz_2 / cosz_2, lnsecz_2 = -log(abs(cosz_2));
              z -= delta = (2 / tanz_2 * lnsecz_2 - b * tanz_2 - r) / (-lnsecz_2 / (sinz_2 * sinz_2) + 1 - b / (2 * cosz_2 * cosz_2)) * (cosz_2 < 0 ? 0.7 : 1);
            } while (abs(delta) > epsilon && --i > 0);
            var sinz = sin(z);
            return [atan2(x * sinz, r * cos(z)), asin(y * sinz / r)];
          };
          return forward;
        }
        function airy() {
          var beta = halfPi, m = d3Geo.geoProjectionMutator(airyRaw), p = m(beta);
          p.radius = function(_) {
            return arguments.length ? m(beta = _ * radians) : beta * degrees;
          };
          return p.scale(179.976).clipAngle(147);
        }
        function aitoffRaw(x, y) {
          var cosy = cos(y), sincia = sinci(acos(cosy * cos(x /= 2)));
          return [2 * cosy * sin(x) * sincia, sin(y) * sincia];
        }
        aitoffRaw.invert = function(x, y) {
          if (x * x + 4 * y * y > pi * pi + epsilon) return;
          var x12 = x, y12 = y, i = 25;
          do {
            var sinx = sin(x12), sinx_2 = sin(x12 / 2), cosx_2 = cos(x12 / 2), siny = sin(y12), cosy = cos(y12), sin_2y = sin(2 * y12), sin2y = siny * siny, cos2y = cosy * cosy, sin2x_2 = sinx_2 * sinx_2, c = 1 - cos2y * cosx_2 * cosx_2, e = c ? acos(cosy * cosx_2) * sqrt(f = 1 / c) : f = 0, f, fx = 2 * e * cosy * sinx_2 - x, fy = e * siny - y, dxdx = f * (cos2y * sin2x_2 + e * cosy * cosx_2 * sin2y), dxdy = f * (0.5 * sinx * sin_2y - e * 2 * siny * sinx_2), dydx = f * 0.25 * (sin_2y * sinx_2 - e * siny * cos2y * sinx), dydy = f * (sin2y * cosx_2 + e * sin2x_2 * cosy), z = dxdy * dydx - dydy * dxdx;
            if (!z) break;
            var dx = (fy * dxdy - fx * dydy) / z, dy = (fx * dydx - fy * dxdx) / z;
            x12 -= dx, y12 -= dy;
          } while ((abs(dx) > epsilon || abs(dy) > epsilon) && --i > 0);
          return [x12, y12];
        };
        function aitoff() {
          return d3Geo.geoProjection(aitoffRaw).scale(152.63);
        }
        function armadilloRaw(phi02) {
          var sinPhi0 = sin(phi02), cosPhi0 = cos(phi02), sPhi0 = phi02 >= 0 ? 1 : -1, tanPhi0 = tan(sPhi0 * phi02), k2 = (1 + sinPhi0 - cosPhi0) / 2;
          function forward(lambda, phi) {
            var cosPhi = cos(phi), cosLambda = cos(lambda /= 2);
            return [
              (1 + cosPhi) * sin(lambda),
              (sPhi0 * phi > -atan2(cosLambda, tanPhi0) - 1e-3 ? 0 : -sPhi0 * 10) + k2 + sin(phi) * cosPhi0 - (1 + cosPhi) * sinPhi0 * cosLambda
              // TODO D3 core should allow null or [NaN, NaN] to be returned.
            ];
          }
          forward.invert = function(x, y) {
            var lambda = 0, phi = 0, i = 50;
            do {
              var cosLambda = cos(lambda), sinLambda = sin(lambda), cosPhi = cos(phi), sinPhi = sin(phi), A2 = 1 + cosPhi, fx = A2 * sinLambda - x, fy = k2 + sinPhi * cosPhi0 - A2 * sinPhi0 * cosLambda - y, dxdLambda = A2 * cosLambda / 2, dxdPhi = -sinLambda * sinPhi, dydLambda = sinPhi0 * A2 * sinLambda / 2, dydPhi = cosPhi0 * cosPhi + sinPhi0 * cosLambda * sinPhi, denominator = dxdPhi * dydLambda - dydPhi * dxdLambda, dLambda = (fy * dxdPhi - fx * dydPhi) / denominator / 2, dPhi = (fx * dydLambda - fy * dxdLambda) / denominator;
              if (abs(dPhi) > 2) dPhi /= 2;
              lambda -= dLambda, phi -= dPhi;
            } while ((abs(dLambda) > epsilon || abs(dPhi) > epsilon) && --i > 0);
            return sPhi0 * phi > -atan2(cos(lambda), tanPhi0) - 1e-3 ? [lambda * 2, phi] : null;
          };
          return forward;
        }
        function armadillo() {
          var phi02 = 20 * radians, sPhi0 = phi02 >= 0 ? 1 : -1, tanPhi0 = tan(sPhi0 * phi02), m = d3Geo.geoProjectionMutator(armadilloRaw), p = m(phi02), stream_ = p.stream;
          p.parallel = function(_) {
            if (!arguments.length) return phi02 * degrees;
            tanPhi0 = tan((sPhi0 = (phi02 = _ * radians) >= 0 ? 1 : -1) * phi02);
            return m(phi02);
          };
          p.stream = function(stream) {
            var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream)), precision = p.precision();
            p.rotate(rotate);
            rotateStream.sphere = function() {
              sphereStream.polygonStart(), sphereStream.lineStart();
              for (var lambda = sPhi0 * -180; sPhi0 * lambda < 180; lambda += sPhi0 * 90)
                sphereStream.point(lambda, sPhi0 * 90);
              if (phi02) while (sPhi0 * (lambda -= 3 * sPhi0 * precision) >= -180) {
                sphereStream.point(lambda, sPhi0 * -atan2(cos(lambda * radians / 2), tanPhi0) * degrees);
              }
              sphereStream.lineEnd(), sphereStream.polygonEnd();
            };
            return rotateStream;
          };
          return p.scale(218.695).center([0, 28.0974]);
        }
        function augustRaw(lambda, phi) {
          var tanPhi = tan(phi / 2), k2 = sqrt(1 - tanPhi * tanPhi), c = 1 + k2 * cos(lambda /= 2), x = sin(lambda) * k2 / c, y = tanPhi / c, x2 = x * x, y2 = y * y;
          return [
            4 / 3 * x * (3 + x2 - 3 * y2),
            4 / 3 * y * (3 + 3 * x2 - y2)
          ];
        }
        augustRaw.invert = function(x, y) {
          x *= 3 / 8, y *= 3 / 8;
          if (!x && abs(y) > 1) return null;
          var x2 = x * x, y2 = y * y, s = 1 + x2 + y2, sin3Eta = sqrt((s - sqrt(s * s - 4 * y * y)) / 2), eta = asin(sin3Eta) / 3, xi = sin3Eta ? arcosh(abs(y / sin3Eta)) / 3 : arsinh(abs(x)) / 3, cosEta = cos(eta), coshXi = cosh(xi), d = coshXi * coshXi - cosEta * cosEta;
          return [
            sign(x) * 2 * atan2(sinh(xi) * cosEta, 0.25 - d),
            sign(y) * 2 * atan2(coshXi * sin(eta), 0.25 + d)
          ];
        };
        function august() {
          return d3Geo.geoProjection(augustRaw).scale(66.1603);
        }
        var sqrt8 = sqrt(8), phi0 = log(1 + sqrt2);
        function bakerRaw(lambda, phi) {
          var phi02 = abs(phi);
          return phi02 < quarterPi ? [lambda, log(tan(quarterPi + phi / 2))] : [lambda * cos(phi02) * (2 * sqrt2 - 1 / sin(phi02)), sign(phi) * (2 * sqrt2 * (phi02 - quarterPi) - log(tan(phi02 / 2)))];
        }
        bakerRaw.invert = function(x, y) {
          if ((y02 = abs(y)) < phi0) return [x, 2 * atan(exp(y)) - halfPi];
          var phi = quarterPi, i = 25, delta, y02;
          do {
            var cosPhi_2 = cos(phi / 2), tanPhi_2 = tan(phi / 2);
            phi -= delta = (sqrt8 * (phi - quarterPi) - log(tanPhi_2) - y02) / (sqrt8 - cosPhi_2 * cosPhi_2 / (2 * tanPhi_2));
          } while (abs(delta) > epsilon2 && --i > 0);
          return [x / (cos(phi) * (sqrt8 - 1 / sin(phi))), sign(y) * phi];
        };
        function baker() {
          return d3Geo.geoProjection(bakerRaw).scale(112.314);
        }
        function berghausRaw(lobes2) {
          var k2 = 2 * pi / lobes2;
          function forward(lambda, phi) {
            var p = d3Geo.geoAzimuthalEquidistantRaw(lambda, phi);
            if (abs(lambda) > halfPi) {
              var theta = atan2(p[1], p[0]), r = sqrt(p[0] * p[0] + p[1] * p[1]), theta0 = k2 * round((theta - halfPi) / k2) + halfPi, alpha = atan2(sin(theta -= theta0), 2 - cos(theta));
              theta = theta0 + asin(pi / r * sin(alpha)) - alpha;
              p[0] = r * cos(theta);
              p[1] = r * sin(theta);
            }
            return p;
          }
          forward.invert = function(x, y) {
            var r = sqrt(x * x + y * y);
            if (r > halfPi) {
              var theta = atan2(y, x), theta0 = k2 * round((theta - halfPi) / k2) + halfPi, s = theta > theta0 ? -1 : 1, A2 = r * cos(theta0 - theta), cotAlpha = 1 / tan(s * acos((A2 - pi) / sqrt(pi * (pi - 2 * A2) + r * r)));
              theta = theta0 + 2 * atan((cotAlpha + s * sqrt(cotAlpha * cotAlpha - 3)) / 3);
              x = r * cos(theta), y = r * sin(theta);
            }
            return d3Geo.geoAzimuthalEquidistantRaw.invert(x, y);
          };
          return forward;
        }
        function berghaus() {
          var lobes2 = 5, m = d3Geo.geoProjectionMutator(berghausRaw), p = m(lobes2), projectionStream = p.stream, epsilon$$1 = 0.01, cr = -cos(epsilon$$1 * radians), sr = sin(epsilon$$1 * radians);
          p.lobes = function(_) {
            return arguments.length ? m(lobes2 = +_) : lobes2;
          };
          p.stream = function(stream) {
            var rotate = p.rotate(), rotateStream = projectionStream(stream), sphereStream = (p.rotate([0, 0]), projectionStream(stream));
            p.rotate(rotate);
            rotateStream.sphere = function() {
              sphereStream.polygonStart(), sphereStream.lineStart();
              for (var i = 0, delta = 360 / lobes2, delta0 = 2 * pi / lobes2, phi = 90 - 180 / lobes2, phi02 = halfPi; i < lobes2; ++i, phi -= delta, phi02 -= delta0) {
                sphereStream.point(atan2(sr * cos(phi02), cr) * degrees, asin(sr * sin(phi02)) * degrees);
                if (phi < -90) {
                  sphereStream.point(-90, -180 - phi - epsilon$$1);
                  sphereStream.point(-90, -180 - phi + epsilon$$1);
                } else {
                  sphereStream.point(90, phi + epsilon$$1);
                  sphereStream.point(90, phi - epsilon$$1);
                }
              }
              sphereStream.lineEnd(), sphereStream.polygonEnd();
            };
            return rotateStream;
          };
          return p.scale(87.8076).center([0, 17.1875]).clipAngle(180 - 1e-3);
        }
        function hammerRaw(A2, B2) {
          if (arguments.length < 2) B2 = A2;
          if (B2 === 1) return d3Geo.geoAzimuthalEqualAreaRaw;
          if (B2 === Infinity) return hammerQuarticAuthalicRaw;
          function forward(lambda, phi) {
            var coordinates = d3Geo.geoAzimuthalEqualAreaRaw(lambda / B2, phi);
            coordinates[0] *= A2;
            return coordinates;
          }
          forward.invert = function(x, y) {
            var coordinates = d3Geo.geoAzimuthalEqualAreaRaw.invert(x / A2, y);
            coordinates[0] *= B2;
            return coordinates;
          };
          return forward;
        }
        function hammerQuarticAuthalicRaw(lambda, phi) {
          return [
            lambda * cos(phi) / cos(phi /= 2),
            2 * sin(phi)
          ];
        }
        hammerQuarticAuthalicRaw.invert = function(x, y) {
          var phi = 2 * asin(y / 2);
          return [
            x * cos(phi / 2) / cos(phi),
            phi
          ];
        };
        function hammer() {
          var B2 = 2, m = d3Geo.geoProjectionMutator(hammerRaw), p = m(B2);
          p.coefficient = function(_) {
            if (!arguments.length) return B2;
            return m(B2 = +_);
          };
          return p.scale(169.529);
        }
        function solve(f, y, x) {
          var steps = 100, delta, f0, f1;
          x = x === void 0 ? 0 : +x;
          y = +y;
          do {
            f0 = f(x);
            f1 = f(x + epsilon);
            if (f0 === f1) f1 = f0 + epsilon;
            x -= delta = -1 * epsilon * (f0 - y) / (f0 - f1);
          } while (steps-- > 0 && abs(delta) > epsilon);
          return steps < 0 ? NaN : x;
        }
        function solve2d(f, MAX_ITERATIONS, eps) {
          if (MAX_ITERATIONS === void 0) MAX_ITERATIONS = 40;
          if (eps === void 0) eps = epsilon2;
          return function(x, y, a, b) {
            var err2, da, db;
            a = a === void 0 ? 0 : +a;
            b = b === void 0 ? 0 : +b;
            for (var i = 0; i < MAX_ITERATIONS; i++) {
              var p = f(a, b), tx = p[0] - x, ty = p[1] - y;
              if (abs(tx) < eps && abs(ty) < eps) break;
              var h = tx * tx + ty * ty;
              if (h > err2) {
                a -= da /= 2;
                b -= db /= 2;
                continue;
              }
              err2 = h;
              var ea = (a > 0 ? -1 : 1) * eps, eb = (b > 0 ? -1 : 1) * eps, pa = f(a + ea, b), pb = f(a, b + eb), dxa = (pa[0] - p[0]) / ea, dya = (pa[1] - p[1]) / ea, dxb = (pb[0] - p[0]) / eb, dyb = (pb[1] - p[1]) / eb, D = dyb * dxa - dya * dxb, l = (abs(D) < 0.5 ? 0.5 : 1) / D;
              da = (ty * dxb - tx * dyb) * l;
              db = (tx * dya - ty * dxa) * l;
              a += da;
              b += db;
              if (abs(da) < eps && abs(db) < eps) break;
            }
            return [a, b];
          };
        }
        function bertin1953Raw() {
          var hammer$$1 = hammerRaw(1.68, 2), fu = 1.4, k2 = 12;
          function forward(lambda, phi) {
            if (lambda + phi < -fu) {
              var u = (lambda - phi + 1.6) * (lambda + phi + fu) / 8;
              lambda += u;
              phi -= 0.8 * u * sin(phi + pi / 2);
            }
            var r = hammer$$1(lambda, phi);
            var d = (1 - cos(lambda * phi)) / k2;
            if (r[1] < 0) {
              r[0] *= 1 + d;
            }
            if (r[1] > 0) {
              r[1] *= 1 + d / 1.5 * r[0] * r[0];
            }
            return r;
          }
          forward.invert = solve2d(forward);
          return forward;
        }
        function bertin() {
          return d3Geo.geoProjection(bertin1953Raw()).rotate([-16.5, -42]).scale(176.57).center([7.93, 0.09]);
        }
        function mollweideBromleyTheta(cp, phi) {
          var cpsinPhi = cp * sin(phi), i = 30, delta;
          do
            phi -= delta = (phi + sin(phi) - cpsinPhi) / (1 + cos(phi));
          while (abs(delta) > epsilon && --i > 0);
          return phi / 2;
        }
        function mollweideBromleyRaw(cx, cy, cp) {
          function forward(lambda, phi) {
            return [cx * lambda * cos(phi = mollweideBromleyTheta(cp, phi)), cy * sin(phi)];
          }
          forward.invert = function(x, y) {
            return y = asin(y / cy), [x / (cx * cos(y)), asin((2 * y + sin(2 * y)) / cp)];
          };
          return forward;
        }
        var mollweideRaw = mollweideBromleyRaw(sqrt2 / halfPi, sqrt2, pi);
        function mollweide() {
          return d3Geo.geoProjection(mollweideRaw).scale(169.529);
        }
        var k = 2.00276, w = 1.11072;
        function boggsRaw(lambda, phi) {
          var theta = mollweideBromleyTheta(pi, phi);
          return [k * lambda / (1 / cos(phi) + w / cos(theta)), (phi + sqrt2 * sin(theta)) / k];
        }
        boggsRaw.invert = function(x, y) {
          var ky = k * y, theta = y < 0 ? -quarterPi : quarterPi, i = 25, delta, phi;
          do {
            phi = ky - sqrt2 * sin(theta);
            theta -= delta = (sin(2 * theta) + 2 * theta - pi * sin(phi)) / (2 * cos(2 * theta) + 2 + pi * cos(phi) * sqrt2 * cos(theta));
          } while (abs(delta) > epsilon && --i > 0);
          phi = ky - sqrt2 * sin(theta);
          return [x * (1 / cos(phi) + w / cos(theta)) / k, phi];
        };
        function boggs() {
          return d3Geo.geoProjection(boggsRaw).scale(160.857);
        }
        function parallel1(projectAt) {
          var phi02 = 0, m = d3Geo.geoProjectionMutator(projectAt), p = m(phi02);
          p.parallel = function(_) {
            return arguments.length ? m(phi02 = _ * radians) : phi02 * degrees;
          };
          return p;
        }
        function sinusoidalRaw(lambda, phi) {
          return [lambda * cos(phi), phi];
        }
        sinusoidalRaw.invert = function(x, y) {
          return [x / cos(y), y];
        };
        function sinusoidal() {
          return d3Geo.geoProjection(sinusoidalRaw).scale(152.63);
        }
        function bonneRaw(phi02) {
          if (!phi02) return sinusoidalRaw;
          var cotPhi0 = 1 / tan(phi02);
          function forward(lambda, phi) {
            var rho = cotPhi0 + phi02 - phi, e = rho ? lambda * cos(phi) / rho : rho;
            return [rho * sin(e), cotPhi0 - rho * cos(e)];
          }
          forward.invert = function(x, y) {
            var rho = sqrt(x * x + (y = cotPhi0 - y) * y), phi = cotPhi0 + phi02 - rho;
            return [rho / cos(phi) * atan2(x, y), phi];
          };
          return forward;
        }
        function bonne() {
          return parallel1(bonneRaw).scale(123.082).center([0, 26.1441]).parallel(45);
        }
        function bottomleyRaw(sinPsi) {
          function forward(lambda, phi) {
            var rho = halfPi - phi, eta = rho ? lambda * sinPsi * sin(rho) / rho : rho;
            return [rho * sin(eta) / sinPsi, halfPi - rho * cos(eta)];
          }
          forward.invert = function(x, y) {
            var x12 = x * sinPsi, y12 = halfPi - y, rho = sqrt(x12 * x12 + y12 * y12), eta = atan2(x12, y12);
            return [(rho ? rho / sin(rho) : 1) * eta / sinPsi, halfPi - rho];
          };
          return forward;
        }
        function bottomley() {
          var sinPsi = 0.5, m = d3Geo.geoProjectionMutator(bottomleyRaw), p = m(sinPsi);
          p.fraction = function(_) {
            return arguments.length ? m(sinPsi = +_) : sinPsi;
          };
          return p.scale(158.837);
        }
        var bromleyRaw = mollweideBromleyRaw(1, 4 / pi, pi);
        function bromley() {
          return d3Geo.geoProjection(bromleyRaw).scale(152.63);
        }
        function distance(dPhi, c1, s1, c2, s2, dLambda) {
          var cosdLambda = cos(dLambda), r;
          if (abs(dPhi) > 1 || abs(dLambda) > 1) {
            r = acos(s1 * s2 + c1 * c2 * cosdLambda);
          } else {
            var sindPhi = sin(dPhi / 2), sindLambda = sin(dLambda / 2);
            r = 2 * asin(sqrt(sindPhi * sindPhi + c1 * c2 * sindLambda * sindLambda));
          }
          return abs(r) > epsilon ? [r, atan2(c2 * sin(dLambda), c1 * s2 - s1 * c2 * cosdLambda)] : [0, 0];
        }
        function angle(b, c, a) {
          return acos((b * b + c * c - a * a) / (2 * b * c));
        }
        function longitude(lambda) {
          return lambda - 2 * pi * floor((lambda + pi) / (2 * pi));
        }
        function chamberlinRaw(p0, p1, p2) {
          var points2 = [
            [p0[0], p0[1], sin(p0[1]), cos(p0[1])],
            [p1[0], p1[1], sin(p1[1]), cos(p1[1])],
            [p2[0], p2[1], sin(p2[1]), cos(p2[1])]
          ];
          for (var a = points2[2], b, i = 0; i < 3; ++i, a = b) {
            b = points2[i];
            a.v = distance(b[1] - a[1], a[3], a[2], b[3], b[2], b[0] - a[0]);
            a.point = [0, 0];
          }
          var beta0 = angle(points2[0].v[0], points2[2].v[0], points2[1].v[0]), beta1 = angle(points2[0].v[0], points2[1].v[0], points2[2].v[0]), beta2 = pi - beta0;
          points2[2].point[1] = 0;
          points2[0].point[0] = -(points2[1].point[0] = points2[0].v[0] / 2);
          var mean = [
            points2[2].point[0] = points2[0].point[0] + points2[2].v[0] * cos(beta0),
            2 * (points2[0].point[1] = points2[1].point[1] = points2[2].v[0] * sin(beta0))
          ];
          function forward(lambda, phi) {
            var sinPhi = sin(phi), cosPhi = cos(phi), v = new Array(3), i2;
            for (i2 = 0; i2 < 3; ++i2) {
              var p = points2[i2];
              v[i2] = distance(phi - p[1], p[3], p[2], cosPhi, sinPhi, lambda - p[0]);
              if (!v[i2][0]) return p.point;
              v[i2][1] = longitude(v[i2][1] - p.v[1]);
            }
            var point = mean.slice();
            for (i2 = 0; i2 < 3; ++i2) {
              var j = i2 == 2 ? 0 : i2 + 1;
              var a2 = angle(points2[i2].v[0], v[i2][0], v[j][0]);
              if (v[i2][1] < 0) a2 = -a2;
              if (!i2) {
                point[0] += v[i2][0] * cos(a2);
                point[1] -= v[i2][0] * sin(a2);
              } else if (i2 == 1) {
                a2 = beta1 - a2;
                point[0] -= v[i2][0] * cos(a2);
                point[1] -= v[i2][0] * sin(a2);
              } else {
                a2 = beta2 - a2;
                point[0] += v[i2][0] * cos(a2);
                point[1] += v[i2][0] * sin(a2);
              }
            }
            point[0] /= 3, point[1] /= 3;
            return point;
          }
          return forward;
        }
        function pointRadians(p) {
          return p[0] *= radians, p[1] *= radians, p;
        }
        function chamberlinAfrica() {
          return chamberlin([0, 22], [45, 22], [22.5, -22]).scale(380).center([22.5, 2]);
        }
        function chamberlin(p0, p1, p2) {
          var c = d3Geo.geoCentroid({ type: "MultiPoint", coordinates: [p0, p1, p2] }), R = [-c[0], -c[1]], r = d3Geo.geoRotation(R), f = chamberlinRaw(pointRadians(r(p0)), pointRadians(r(p1)), pointRadians(r(p2)));
          f.invert = solve2d(f);
          var p = d3Geo.geoProjection(f).rotate(R), center = p.center;
          delete p.rotate;
          p.center = function(_) {
            return arguments.length ? center(r(_)) : r.invert(center());
          };
          return p.clipAngle(90);
        }
        function collignonRaw(lambda, phi) {
          var alpha = sqrt(1 - sin(phi));
          return [2 / sqrtPi * lambda * alpha, sqrtPi * (1 - alpha)];
        }
        collignonRaw.invert = function(x, y) {
          var lambda = (lambda = y / sqrtPi - 1) * lambda;
          return [lambda > 0 ? x * sqrt(pi / lambda) / 2 : 0, asin(1 - lambda)];
        };
        function collignon() {
          return d3Geo.geoProjection(collignonRaw).scale(95.6464).center([0, 30]);
        }
        function craigRaw(phi02) {
          var tanPhi0 = tan(phi02);
          function forward(lambda, phi) {
            return [lambda, (lambda ? lambda / sin(lambda) : 1) * (sin(phi) * cos(lambda) - tanPhi0 * cos(phi))];
          }
          forward.invert = tanPhi0 ? function(x, y) {
            if (x) y *= sin(x) / x;
            var cosLambda = cos(x);
            return [x, 2 * atan2(sqrt(cosLambda * cosLambda + tanPhi0 * tanPhi0 - y * y) - cosLambda, tanPhi0 - y)];
          } : function(x, y) {
            return [x, asin(x ? y * tan(x) / x : y)];
          };
          return forward;
        }
        function craig() {
          return parallel1(craigRaw).scale(249.828).clipAngle(90);
        }
        var sqrt3 = sqrt(3);
        function crasterRaw(lambda, phi) {
          return [sqrt3 * lambda * (2 * cos(2 * phi / 3) - 1) / sqrtPi, sqrt3 * sqrtPi * sin(phi / 3)];
        }
        crasterRaw.invert = function(x, y) {
          var phi = 3 * asin(y / (sqrt3 * sqrtPi));
          return [sqrtPi * x / (sqrt3 * (2 * cos(2 * phi / 3) - 1)), phi];
        };
        function craster() {
          return d3Geo.geoProjection(crasterRaw).scale(156.19);
        }
        function cylindricalEqualAreaRaw(phi02) {
          var cosPhi0 = cos(phi02);
          function forward(lambda, phi) {
            return [lambda * cosPhi0, sin(phi) / cosPhi0];
          }
          forward.invert = function(x, y) {
            return [x / cosPhi0, asin(y * cosPhi0)];
          };
          return forward;
        }
        function cylindricalEqualArea() {
          return parallel1(cylindricalEqualAreaRaw).parallel(38.58).scale(195.044);
        }
        function cylindricalStereographicRaw(phi02) {
          var cosPhi0 = cos(phi02);
          function forward(lambda, phi) {
            return [lambda * cosPhi0, (1 + cosPhi0) * tan(phi / 2)];
          }
          forward.invert = function(x, y) {
            return [x / cosPhi0, atan(y / (1 + cosPhi0)) * 2];
          };
          return forward;
        }
        function cylindricalStereographic() {
          return parallel1(cylindricalStereographicRaw).scale(124.75);
        }
        function eckert1Raw(lambda, phi) {
          var alpha = sqrt(8 / (3 * pi));
          return [
            alpha * lambda * (1 - abs(phi) / pi),
            alpha * phi
          ];
        }
        eckert1Raw.invert = function(x, y) {
          var alpha = sqrt(8 / (3 * pi)), phi = y / alpha;
          return [
            x / (alpha * (1 - abs(phi) / pi)),
            phi
          ];
        };
        function eckert1() {
          return d3Geo.geoProjection(eckert1Raw).scale(165.664);
        }
        function eckert2Raw(lambda, phi) {
          var alpha = sqrt(4 - 3 * sin(abs(phi)));
          return [
            2 / sqrt(6 * pi) * lambda * alpha,
            sign(phi) * sqrt(2 * pi / 3) * (2 - alpha)
          ];
        }
        eckert2Raw.invert = function(x, y) {
          var alpha = 2 - abs(y) / sqrt(2 * pi / 3);
          return [
            x * sqrt(6 * pi) / (2 * alpha),
            sign(y) * asin((4 - alpha * alpha) / 3)
          ];
        };
        function eckert2() {
          return d3Geo.geoProjection(eckert2Raw).scale(165.664);
        }
        function eckert3Raw(lambda, phi) {
          var k2 = sqrt(pi * (4 + pi));
          return [
            2 / k2 * lambda * (1 + sqrt(1 - 4 * phi * phi / (pi * pi))),
            4 / k2 * phi
          ];
        }
        eckert3Raw.invert = function(x, y) {
          var k2 = sqrt(pi * (4 + pi)) / 2;
          return [
            x * k2 / (1 + sqrt(1 - y * y * (4 + pi) / (4 * pi))),
            y * k2 / 2
          ];
        };
        function eckert3() {
          return d3Geo.geoProjection(eckert3Raw).scale(180.739);
        }
        function eckert4Raw(lambda, phi) {
          var k2 = (2 + halfPi) * sin(phi);
          phi /= 2;
          for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon; i++) {
            var cosPhi = cos(phi);
            phi -= delta = (phi + sin(phi) * (cosPhi + 2) - k2) / (2 * cosPhi * (1 + cosPhi));
          }
          return [
            2 / sqrt(pi * (4 + pi)) * lambda * (1 + cos(phi)),
            2 * sqrt(pi / (4 + pi)) * sin(phi)
          ];
        }
        eckert4Raw.invert = function(x, y) {
          var A2 = y * sqrt((4 + pi) / pi) / 2, k2 = asin(A2), c = cos(k2);
          return [
            x / (2 / sqrt(pi * (4 + pi)) * (1 + c)),
            asin((k2 + A2 * (c + 2)) / (2 + halfPi))
          ];
        };
        function eckert4() {
          return d3Geo.geoProjection(eckert4Raw).scale(180.739);
        }
        function eckert5Raw(lambda, phi) {
          return [
            lambda * (1 + cos(phi)) / sqrt(2 + pi),
            2 * phi / sqrt(2 + pi)
          ];
        }
        eckert5Raw.invert = function(x, y) {
          var k2 = sqrt(2 + pi), phi = y * k2 / 2;
          return [
            k2 * x / (1 + cos(phi)),
            phi
          ];
        };
        function eckert5() {
          return d3Geo.geoProjection(eckert5Raw).scale(173.044);
        }
        function eckert6Raw(lambda, phi) {
          var k2 = (1 + halfPi) * sin(phi);
          for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon; i++) {
            phi -= delta = (phi + sin(phi) - k2) / (1 + cos(phi));
          }
          k2 = sqrt(2 + pi);
          return [
            lambda * (1 + cos(phi)) / k2,
            2 * phi / k2
          ];
        }
        eckert6Raw.invert = function(x, y) {
          var j = 1 + halfPi, k2 = sqrt(j / 2);
          return [
            x * 2 * k2 / (1 + cos(y *= k2)),
            asin((y + sin(y)) / j)
          ];
        };
        function eckert6() {
          return d3Geo.geoProjection(eckert6Raw).scale(173.044);
        }
        var eisenlohrK = 3 + 2 * sqrt2;
        function eisenlohrRaw(lambda, phi) {
          var s0 = sin(lambda /= 2), c0 = cos(lambda), k2 = sqrt(cos(phi)), c1 = cos(phi /= 2), t = sin(phi) / (c1 + sqrt2 * c0 * k2), c = sqrt(2 / (1 + t * t)), v = sqrt((sqrt2 * c1 + (c0 + s0) * k2) / (sqrt2 * c1 + (c0 - s0) * k2));
          return [
            eisenlohrK * (c * (v - 1 / v) - 2 * log(v)),
            eisenlohrK * (c * t * (v + 1 / v) - 2 * atan(t))
          ];
        }
        eisenlohrRaw.invert = function(x, y) {
          if (!(p = augustRaw.invert(x / 1.2, y * 1.065))) return null;
          var lambda = p[0], phi = p[1], i = 20, p;
          x /= eisenlohrK, y /= eisenlohrK;
          do {
            var _0 = lambda / 2, _1 = phi / 2, s0 = sin(_0), c0 = cos(_0), s1 = sin(_1), c1 = cos(_1), cos1 = cos(phi), k2 = sqrt(cos1), t = s1 / (c1 + sqrt2 * c0 * k2), t2 = t * t, c = sqrt(2 / (1 + t2)), v0 = sqrt2 * c1 + (c0 + s0) * k2, v1 = sqrt2 * c1 + (c0 - s0) * k2, v2 = v0 / v1, v = sqrt(v2), vm1v = v - 1 / v, vp1v = v + 1 / v, fx = c * vm1v - 2 * log(v) - x, fy = c * t * vp1v - 2 * atan(t) - y, deltatDeltaLambda = s1 && sqrt1_2 * k2 * s0 * t2 / s1, deltatDeltaPhi = (sqrt2 * c0 * c1 + k2) / (2 * (c1 + sqrt2 * c0 * k2) * (c1 + sqrt2 * c0 * k2) * k2), deltacDeltat = -0.5 * t * c * c * c, deltacDeltaLambda = deltacDeltat * deltatDeltaLambda, deltacDeltaPhi = deltacDeltat * deltatDeltaPhi, A2 = (A2 = 2 * c1 + sqrt2 * k2 * (c0 - s0)) * A2 * v, deltavDeltaLambda = (sqrt2 * c0 * c1 * k2 + cos1) / A2, deltavDeltaPhi = -(sqrt2 * s0 * s1) / (k2 * A2), deltaxDeltaLambda = vm1v * deltacDeltaLambda - 2 * deltavDeltaLambda / v + c * (deltavDeltaLambda + deltavDeltaLambda / v2), deltaxDeltaPhi = vm1v * deltacDeltaPhi - 2 * deltavDeltaPhi / v + c * (deltavDeltaPhi + deltavDeltaPhi / v2), deltayDeltaLambda = t * vp1v * deltacDeltaLambda - 2 * deltatDeltaLambda / (1 + t2) + c * vp1v * deltatDeltaLambda + c * t * (deltavDeltaLambda - deltavDeltaLambda / v2), deltayDeltaPhi = t * vp1v * deltacDeltaPhi - 2 * deltatDeltaPhi / (1 + t2) + c * vp1v * deltatDeltaPhi + c * t * (deltavDeltaPhi - deltavDeltaPhi / v2), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
            if (!denominator) break;
            var deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
            lambda -= deltaLambda;
            phi = max(-halfPi, min(halfPi, phi - deltaPhi));
          } while ((abs(deltaLambda) > epsilon || abs(deltaPhi) > epsilon) && --i > 0);
          return abs(abs(phi) - halfPi) < epsilon ? [0, phi] : i && [lambda, phi];
        };
        function eisenlohr() {
          return d3Geo.geoProjection(eisenlohrRaw).scale(62.5271);
        }
        var faheyK = cos(35 * radians);
        function faheyRaw(lambda, phi) {
          var t = tan(phi / 2);
          return [lambda * faheyK * sqrt(1 - t * t), (1 + faheyK) * t];
        }
        faheyRaw.invert = function(x, y) {
          var t = y / (1 + faheyK);
          return [x && x / (faheyK * sqrt(1 - t * t)), 2 * atan(t)];
        };
        function fahey() {
          return d3Geo.geoProjection(faheyRaw).scale(137.152);
        }
        function foucautRaw(lambda, phi) {
          var k2 = phi / 2, cosk = cos(k2);
          return [2 * lambda / sqrtPi * cos(phi) * cosk * cosk, sqrtPi * tan(k2)];
        }
        foucautRaw.invert = function(x, y) {
          var k2 = atan(y / sqrtPi), cosk = cos(k2), phi = 2 * k2;
          return [x * sqrtPi / 2 / (cos(phi) * cosk * cosk), phi];
        };
        function foucaut() {
          return d3Geo.geoProjection(foucautRaw).scale(135.264);
        }
        function foucautSinusoidalRaw(alpha) {
          var beta = 1 - alpha, equatorial = raw(pi, 0)[0] - raw(-pi, 0)[0], polar = raw(0, halfPi)[1] - raw(0, -halfPi)[1], ratio = sqrt(2 * polar / equatorial);
          function raw(lambda, phi) {
            var cosphi = cos(phi), sinphi = sin(phi);
            return [
              cosphi / (beta + alpha * cosphi) * lambda,
              beta * phi + alpha * sinphi
            ];
          }
          function forward(lambda, phi) {
            var p = raw(lambda, phi);
            return [p[0] * ratio, p[1] / ratio];
          }
          function forwardMeridian(phi) {
            return forward(0, phi)[1];
          }
          forward.invert = function(x, y) {
            var phi = solve(forwardMeridian, y), lambda = x / ratio * (alpha + beta / cos(phi));
            return [lambda, phi];
          };
          return forward;
        }
        function foucautSinusoidal() {
          var alpha = 0.5, m = d3Geo.geoProjectionMutator(foucautSinusoidalRaw), p = m(alpha);
          p.alpha = function(_) {
            return arguments.length ? m(alpha = +_) : alpha;
          };
          return p.scale(168.725);
        }
        function gilbertForward(point) {
          return [point[0] / 2, asin(tan(point[1] / 2 * radians)) * degrees];
        }
        function gilbertInvert(point) {
          return [point[0] * 2, 2 * atan(sin(point[1] * radians)) * degrees];
        }
        function gilbert(projectionType) {
          if (projectionType == null) projectionType = d3Geo.geoOrthographic;
          var projection = projectionType(), equirectangular = d3Geo.geoEquirectangular().scale(degrees).precision(0).clipAngle(null).translate([0, 0]);
          function gilbert2(point) {
            return projection(gilbertForward(point));
          }
          if (projection.invert) gilbert2.invert = function(point) {
            return gilbertInvert(projection.invert(point));
          };
          gilbert2.stream = function(stream) {
            var s1 = projection.stream(stream), s0 = equirectangular.stream({
              point: function(lambda, phi) {
                s1.point(lambda / 2, asin(tan(-phi / 2 * radians)) * degrees);
              },
              lineStart: function() {
                s1.lineStart();
              },
              lineEnd: function() {
                s1.lineEnd();
              },
              polygonStart: function() {
                s1.polygonStart();
              },
              polygonEnd: function() {
                s1.polygonEnd();
              }
            });
            s0.sphere = s1.sphere;
            return s0;
          };
          function property(name) {
            gilbert2[name] = function() {
              return arguments.length ? (projection[name].apply(projection, arguments), gilbert2) : projection[name]();
            };
          }
          gilbert2.rotate = function(_) {
            return arguments.length ? (equirectangular.rotate(_), gilbert2) : equirectangular.rotate();
          };
          gilbert2.center = function(_) {
            return arguments.length ? (projection.center(gilbertForward(_)), gilbert2) : gilbertInvert(projection.center());
          };
          property("angle");
          property("clipAngle");
          property("clipExtent");
          property("fitExtent");
          property("fitHeight");
          property("fitSize");
          property("fitWidth");
          property("scale");
          property("translate");
          property("precision");
          return gilbert2.scale(249.5);
        }
        function gingeryRaw(rho, n) {
          var k2 = 2 * pi / n, rho2 = rho * rho;
          function forward(lambda, phi) {
            var p = d3Geo.geoAzimuthalEquidistantRaw(lambda, phi), x = p[0], y = p[1], r2 = x * x + y * y;
            if (r2 > rho2) {
              var r = sqrt(r2), theta = atan2(y, x), theta0 = k2 * round(theta / k2), alpha = theta - theta0, rhoCosAlpha = rho * cos(alpha), k_ = (rho * sin(alpha) - alpha * sin(rhoCosAlpha)) / (halfPi - rhoCosAlpha), s_ = gingeryLength(alpha, k_), e = (pi - rho) / gingeryIntegrate(s_, rhoCosAlpha, pi);
              x = r;
              var i = 50, delta;
              do {
                x -= delta = (rho + gingeryIntegrate(s_, rhoCosAlpha, x) * e - r) / (s_(x) * e);
              } while (abs(delta) > epsilon && --i > 0);
              y = alpha * sin(x);
              if (x < halfPi) y -= k_ * (x - halfPi);
              var s = sin(theta0), c = cos(theta0);
              p[0] = x * c - y * s;
              p[1] = x * s + y * c;
            }
            return p;
          }
          forward.invert = function(x, y) {
            var r2 = x * x + y * y;
            if (r2 > rho2) {
              var r = sqrt(r2), theta = atan2(y, x), theta0 = k2 * round(theta / k2), dTheta = theta - theta0;
              x = r * cos(dTheta);
              y = r * sin(dTheta);
              var x_halfPi = x - halfPi, sinx = sin(x), alpha = y / sinx, delta = x < halfPi ? Infinity : 0, i = 10;
              while (true) {
                var rhosinAlpha = rho * sin(alpha), rhoCosAlpha = rho * cos(alpha), sinRhoCosAlpha = sin(rhoCosAlpha), halfPi_RhoCosAlpha = halfPi - rhoCosAlpha, k_ = (rhosinAlpha - alpha * sinRhoCosAlpha) / halfPi_RhoCosAlpha, s_ = gingeryLength(alpha, k_);
                if (abs(delta) < epsilon2 || !--i) break;
                alpha -= delta = (alpha * sinx - k_ * x_halfPi - y) / (sinx - x_halfPi * 2 * (halfPi_RhoCosAlpha * (rhoCosAlpha + alpha * rhosinAlpha * cos(rhoCosAlpha) - sinRhoCosAlpha) - rhosinAlpha * (rhosinAlpha - alpha * sinRhoCosAlpha)) / (halfPi_RhoCosAlpha * halfPi_RhoCosAlpha));
              }
              r = rho + gingeryIntegrate(s_, rhoCosAlpha, x) * (pi - rho) / gingeryIntegrate(s_, rhoCosAlpha, pi);
              theta = theta0 + alpha;
              x = r * cos(theta);
              y = r * sin(theta);
            }
            return d3Geo.geoAzimuthalEquidistantRaw.invert(x, y);
          };
          return forward;
        }
        function gingeryLength(alpha, k2) {
          return function(x) {
            var y_ = alpha * cos(x);
            if (x < halfPi) y_ -= k2;
            return sqrt(1 + y_ * y_);
          };
        }
        function gingeryIntegrate(f, a, b) {
          var n = 50, h = (b - a) / n, s = f(a) + f(b);
          for (var i = 1, x = a; i < n; ++i) s += 2 * f(x += h);
          return s * 0.5 * h;
        }
        function gingery() {
          var n = 6, rho = 30 * radians, cRho = cos(rho), sRho = sin(rho), m = d3Geo.geoProjectionMutator(gingeryRaw), p = m(rho, n), stream_ = p.stream, epsilon$$1 = 0.01, cr = -cos(epsilon$$1 * radians), sr = sin(epsilon$$1 * radians);
          p.radius = function(_) {
            if (!arguments.length) return rho * degrees;
            cRho = cos(rho = _ * radians);
            sRho = sin(rho);
            return m(rho, n);
          };
          p.lobes = function(_) {
            if (!arguments.length) return n;
            return m(rho, n = +_);
          };
          p.stream = function(stream) {
            var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));
            p.rotate(rotate);
            rotateStream.sphere = function() {
              sphereStream.polygonStart(), sphereStream.lineStart();
              for (var i = 0, delta = 2 * pi / n, phi = 0; i < n; ++i, phi -= delta) {
                sphereStream.point(atan2(sr * cos(phi), cr) * degrees, asin(sr * sin(phi)) * degrees);
                sphereStream.point(atan2(sRho * cos(phi - delta / 2), cRho) * degrees, asin(sRho * sin(phi - delta / 2)) * degrees);
              }
              sphereStream.lineEnd(), sphereStream.polygonEnd();
            };
            return rotateStream;
          };
          return p.rotate([90, -40]).scale(91.7095).clipAngle(180 - 1e-3);
        }
        function ginzburgPolyconicRaw(a, b, c, d, e, f, g, h) {
          if (arguments.length < 8) h = 0;
          function forward(lambda, phi) {
            if (!phi) return [a * lambda / pi, 0];
            var phi2 = phi * phi, xB = a + phi2 * (b + phi2 * (c + phi2 * d)), yB = phi * (e - 1 + phi2 * (f - h + phi2 * g)), m = (xB * xB + yB * yB) / (2 * yB), alpha = lambda * asin(xB / m) / pi;
            return [m * sin(alpha), phi * (1 + phi2 * h) + m * (1 - cos(alpha))];
          }
          forward.invert = function(x, y) {
            var lambda = pi * x / a, phi = y, deltaLambda, deltaPhi, i = 50;
            do {
              var phi2 = phi * phi, xB = a + phi2 * (b + phi2 * (c + phi2 * d)), yB = phi * (e - 1 + phi2 * (f - h + phi2 * g)), p = xB * xB + yB * yB, q = 2 * yB, m = p / q, m2 = m * m, dAlphadLambda = asin(xB / m) / pi, alpha = lambda * dAlphadLambda, xB2 = xB * xB, dxBdPhi = (2 * b + phi2 * (4 * c + phi2 * 6 * d)) * phi, dyBdPhi = e + phi2 * (3 * f + phi2 * 5 * g), dpdPhi = 2 * (xB * dxBdPhi + yB * (dyBdPhi - 1)), dqdPhi = 2 * (dyBdPhi - 1), dmdPhi = (dpdPhi * q - p * dqdPhi) / (q * q), cosAlpha = cos(alpha), sinAlpha = sin(alpha), mcosAlpha = m * cosAlpha, msinAlpha = m * sinAlpha, dAlphadPhi = lambda / pi * (1 / sqrt(1 - xB2 / m2)) * (dxBdPhi * m - xB * dmdPhi) / m2, fx = msinAlpha - x, fy = phi * (1 + phi2 * h) + m - mcosAlpha - y, deltaxDeltaPhi = dmdPhi * sinAlpha + mcosAlpha * dAlphadPhi, deltaxDeltaLambda = mcosAlpha * dAlphadLambda, deltayDeltaPhi = 1 + dmdPhi - (dmdPhi * cosAlpha - msinAlpha * dAlphadPhi), deltayDeltaLambda = msinAlpha * dAlphadLambda, denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
              if (!denominator) break;
              lambda -= deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator;
              phi -= deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
            } while ((abs(deltaLambda) > epsilon || abs(deltaPhi) > epsilon) && --i > 0);
            return [lambda, phi];
          };
          return forward;
        }
        var ginzburg4Raw = ginzburgPolyconicRaw(2.8284, -1.6988, 0.75432, -0.18071, 1.76003, -0.38914, 0.042555);
        function ginzburg4() {
          return d3Geo.geoProjection(ginzburg4Raw).scale(149.995);
        }
        var ginzburg5Raw = ginzburgPolyconicRaw(2.583819, -0.835827, 0.170354, -0.038094, 1.543313, -0.411435, 0.082742);
        function ginzburg5() {
          return d3Geo.geoProjection(ginzburg5Raw).scale(153.93);
        }
        var ginzburg6Raw = ginzburgPolyconicRaw(5 / 6 * pi, -0.62636, -0.0344, 0, 1.3493, -0.05524, 0, 0.045);
        function ginzburg6() {
          return d3Geo.geoProjection(ginzburg6Raw).scale(130.945);
        }
        function ginzburg8Raw(lambda, phi) {
          var lambda2 = lambda * lambda, phi2 = phi * phi;
          return [
            lambda * (1 - 0.162388 * phi2) * (0.87 - 952426e-9 * lambda2 * lambda2),
            phi * (1 + phi2 / 12)
          ];
        }
        ginzburg8Raw.invert = function(x, y) {
          var lambda = x, phi = y, i = 50, delta;
          do {
            var phi2 = phi * phi;
            phi -= delta = (phi * (1 + phi2 / 12) - y) / (1 + phi2 / 4);
          } while (abs(delta) > epsilon && --i > 0);
          i = 50;
          x /= 1 - 0.162388 * phi2;
          do {
            var lambda4 = (lambda4 = lambda * lambda) * lambda4;
            lambda -= delta = (lambda * (0.87 - 952426e-9 * lambda4) - x) / (0.87 - 476213e-8 * lambda4);
          } while (abs(delta) > epsilon && --i > 0);
          return [lambda, phi];
        };
        function ginzburg8() {
          return d3Geo.geoProjection(ginzburg8Raw).scale(131.747);
        }
        var ginzburg9Raw = ginzburgPolyconicRaw(2.6516, -0.76534, 0.19123, -0.047094, 1.36289, -0.13965, 0.031762);
        function ginzburg9() {
          return d3Geo.geoProjection(ginzburg9Raw).scale(131.087);
        }
        function squareRaw(project) {
          var dx = project(halfPi, 0)[0] - project(-halfPi, 0)[0];
          function projectSquare(lambda, phi) {
            var s = lambda > 0 ? -0.5 : 0.5, point = project(lambda + s * pi, phi);
            point[0] -= s * dx;
            return point;
          }
          if (project.invert) projectSquare.invert = function(x, y) {
            var s = x > 0 ? -0.5 : 0.5, location = project.invert(x + s * dx, y), lambda = location[0] - s * pi;
            if (lambda < -pi) lambda += 2 * pi;
            else if (lambda > pi) lambda -= 2 * pi;
            location[0] = lambda;
            return location;
          };
          return projectSquare;
        }
        function gringortenRaw(lambda, phi) {
          var sLambda = sign(lambda), sPhi = sign(phi), cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(sPhi * phi);
          lambda = abs(atan2(y, z));
          phi = asin(x);
          if (abs(lambda - halfPi) > epsilon) lambda %= halfPi;
          var point = gringortenHexadecant(lambda > pi / 4 ? halfPi - lambda : lambda, phi);
          if (lambda > pi / 4) z = point[0], point[0] = -point[1], point[1] = -z;
          return point[0] *= sLambda, point[1] *= -sPhi, point;
        }
        gringortenRaw.invert = function(x, y) {
          if (abs(x) > 1) x = sign(x) * 2 - x;
          if (abs(y) > 1) y = sign(y) * 2 - y;
          var sx = sign(x), sy = sign(y), x02 = -sx * x, y02 = -sy * y, t = y02 / x02 < 1, p = gringortenHexadecantInvert(t ? y02 : x02, t ? x02 : y02), lambda = p[0], phi = p[1], cosPhi = cos(phi);
          if (t) lambda = -halfPi - lambda;
          return [sx * (atan2(sin(lambda) * cosPhi, -sin(phi)) + pi), sy * asin(cos(lambda) * cosPhi)];
        };
        function gringortenHexadecant(lambda, phi) {
          if (phi === halfPi) return [0, 0];
          var sinPhi = sin(phi), r = sinPhi * sinPhi, r2 = r * r, j = 1 + r2, k2 = 1 + 3 * r2, q = 1 - r2, z = asin(1 / sqrt(j)), v = q + r * j * z, p2 = (1 - sinPhi) / v, p = sqrt(p2), a2 = p2 * j, a = sqrt(a2), h = p * q, x, i;
          if (lambda === 0) return [0, -(h + r * a)];
          var cosPhi = cos(phi), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r + z * k2) * drdPhi, dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v), dpdPhi = 0.5 * dp2dPhi / p, dhdPhi = q * dpdPhi - 2 * r * p * drdPhi, dra2dPhi = r * j * dp2dPhi + p2 * k2 * drdPhi, mu = -secPhi * drdPhi, nu = -secPhi * dra2dPhi, zeta = -2 * secPhi * dhdPhi, lambda1 = 4 * lambda / pi, delta;
          if (lambda > 0.222 * pi || phi < pi / 4 && lambda > 0.175 * pi) {
            x = (h + r * sqrt(a2 * (1 + r2) - h * h)) / (1 + r2);
            if (lambda > pi / 4) return [x, x];
            var x12 = x, x02 = 0.5 * x;
            x = 0.5 * (x02 + x12), i = 50;
            do {
              var g = sqrt(a2 - x * x), f = x * (zeta + mu * g) + nu * asin(x / a) - lambda1;
              if (!f) break;
              if (f < 0) x02 = x;
              else x12 = x;
              x = 0.5 * (x02 + x12);
            } while (abs(x12 - x02) > epsilon && --i > 0);
          } else {
            x = epsilon, i = 25;
            do {
              var x2 = x * x, g2 = sqrt(a2 - x2), zetaMug = zeta + mu * g2, f2 = x * zetaMug + nu * asin(x / a) - lambda1, df = zetaMug + (nu - mu * x2) / g2;
              x -= delta = g2 ? f2 / df : 0;
            } while (abs(delta) > epsilon && --i > 0);
          }
          return [x, -h - r * sqrt(a2 - x * x)];
        }
        function gringortenHexadecantInvert(x, y) {
          var x02 = 0, x12 = 1, r = 0.5, i = 50;
          while (true) {
            var r2 = r * r, sinPhi = sqrt(r), z = asin(1 / sqrt(1 + r2)), v = 1 - r2 + r * (1 + r2) * z, p2 = (1 - sinPhi) / v, p = sqrt(p2), a2 = p2 * (1 + r2), h = p * (1 - r2), g2 = a2 - x * x, g = sqrt(g2), y02 = y + h + r * g;
            if (abs(x12 - x02) < epsilon2 || --i === 0 || y02 === 0) break;
            if (y02 > 0) x02 = r;
            else x12 = r;
            r = 0.5 * (x02 + x12);
          }
          if (!i) return null;
          var phi = asin(sinPhi), cosPhi = cos(phi), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r + z * (1 + 3 * r2)) * drdPhi, dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v), dpdPhi = 0.5 * dp2dPhi / p, dhdPhi = (1 - r2) * dpdPhi - 2 * r * p * drdPhi, zeta = -2 * secPhi * dhdPhi, mu = -secPhi * drdPhi, nu = -secPhi * (r * (1 + r2) * dp2dPhi + p2 * (1 + 3 * r2) * drdPhi);
          return [pi / 4 * (x * (zeta + mu * g) + nu * asin(x / sqrt(a2))), phi];
        }
        function gringorten() {
          return d3Geo.geoProjection(squareRaw(gringortenRaw)).scale(239.75);
        }
        function ellipticJi(u, v, m) {
          var a, b, c;
          if (!u) {
            b = ellipticJ(v, 1 - m);
            return [
              [0, b[0] / b[1]],
              [1 / b[1], 0],
              [b[2] / b[1], 0]
            ];
          }
          a = ellipticJ(u, m);
          if (!v) return [[a[0], 0], [a[1], 0], [a[2], 0]];
          b = ellipticJ(v, 1 - m);
          c = b[1] * b[1] + m * a[0] * a[0] * b[0] * b[0];
          return [
            [a[0] * b[2] / c, a[1] * a[2] * b[0] * b[1] / c],
            [a[1] * b[1] / c, -a[0] * a[2] * b[0] * b[2] / c],
            [a[2] * b[1] * b[2] / c, -m * a[0] * a[1] * b[0] / c]
          ];
        }
        function ellipticJ(u, m) {
          var ai, b, phi, t, twon;
          if (m < epsilon) {
            t = sin(u);
            b = cos(u);
            ai = m * (u - t * b) / 4;
            return [
              t - ai * b,
              b + ai * t,
              1 - m * t * t / 2,
              u - ai
            ];
          }
          if (m >= 1 - epsilon) {
            ai = (1 - m) / 4;
            b = cosh(u);
            t = tanh(u);
            phi = 1 / b;
            twon = b * sinh(u);
            return [
              t + ai * (twon - u) / (b * b),
              phi - ai * t * phi * (twon - u),
              phi + ai * t * phi * (twon + u),
              2 * atan(exp(u)) - halfPi + ai * (twon - u) / b
            ];
          }
          var a = [1, 0, 0, 0, 0, 0, 0, 0, 0], c = [sqrt(m), 0, 0, 0, 0, 0, 0, 0, 0], i = 0;
          b = sqrt(1 - m);
          twon = 1;
          while (abs(c[i] / a[i]) > epsilon && i < 8) {
            ai = a[i++];
            c[i] = (ai - b) / 2;
            a[i] = (ai + b) / 2;
            b = sqrt(ai * b);
            twon *= 2;
          }
          phi = twon * a[i] * u;
          do {
            t = c[i] * sin(b = phi) / a[i];
            phi = (asin(t) + phi) / 2;
          } while (--i);
          return [sin(phi), t = cos(phi), t / cos(phi - b), phi];
        }
        function ellipticFi(phi, psi, m) {
          var r = abs(phi), i = abs(psi), sinhPsi = sinh(i);
          if (r) {
            var cscPhi = 1 / sin(r), cotPhi2 = 1 / (tan(r) * tan(r)), b = -(cotPhi2 + m * (sinhPsi * sinhPsi * cscPhi * cscPhi) - 1 + m), c = (m - 1) * cotPhi2, cotLambda2 = (-b + sqrt(b * b - 4 * c)) / 2;
            return [
              ellipticF(atan(1 / sqrt(cotLambda2)), m) * sign(phi),
              ellipticF(atan(sqrt((cotLambda2 / cotPhi2 - 1) / m)), 1 - m) * sign(psi)
            ];
          }
          return [
            0,
            ellipticF(atan(sinhPsi), 1 - m) * sign(psi)
          ];
        }
        function ellipticF(phi, m) {
          if (!m) return phi;
          if (m === 1) return log(tan(phi / 2 + quarterPi));
          var a = 1, b = sqrt(1 - m), c = sqrt(m);
          for (var i = 0; abs(c) > epsilon; i++) {
            if (phi % pi) {
              var dPhi = atan(b * tan(phi) / a);
              if (dPhi < 0) dPhi += pi;
              phi += dPhi + ~~(phi / pi) * pi;
            } else phi += phi;
            c = (a + b) / 2;
            b = sqrt(a * b);
            c = ((a = c) - b) / 2;
          }
          return phi / (pow(2, i) * a);
        }
        function guyouRaw(lambda, phi) {
          var k_ = (sqrt2 - 1) / (sqrt2 + 1), k2 = sqrt(1 - k_ * k_), K2 = ellipticF(halfPi, k2 * k2), f = -1, psi = log(tan(pi / 4 + abs(phi) / 2)), r = exp(f * psi) / sqrt(k_), at = guyouComplexAtan(r * cos(f * lambda), r * sin(f * lambda)), t = ellipticFi(at[0], at[1], k2 * k2);
          return [-t[1], (phi >= 0 ? 1 : -1) * (0.5 * K2 - t[0])];
        }
        function guyouComplexAtan(x, y) {
          var x2 = x * x, y_1 = y + 1, t = 1 - x2 - y * y;
          return [
            0.5 * ((x >= 0 ? halfPi : -halfPi) - atan2(t, 2 * x)),
            -0.25 * log(t * t + 4 * x2) + 0.5 * log(y_1 * y_1 + x2)
          ];
        }
        function guyouComplexDivide(a, b) {
          var denominator = b[0] * b[0] + b[1] * b[1];
          return [
            (a[0] * b[0] + a[1] * b[1]) / denominator,
            (a[1] * b[0] - a[0] * b[1]) / denominator
          ];
        }
        guyouRaw.invert = function(x, y) {
          var k_ = (sqrt2 - 1) / (sqrt2 + 1), k2 = sqrt(1 - k_ * k_), K2 = ellipticF(halfPi, k2 * k2), f = -1, j = ellipticJi(0.5 * K2 - y, -x, k2 * k2), tn = guyouComplexDivide(j[0], j[1]), lambda = atan2(tn[1], tn[0]) / f;
          return [
            lambda,
            2 * atan(exp(0.5 / f * log(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - halfPi
          ];
        };
        function guyou() {
          return d3Geo.geoProjection(squareRaw(guyouRaw)).scale(151.496);
        }
        function hammerRetroazimuthalRaw(phi02) {
          var sinPhi0 = sin(phi02), cosPhi0 = cos(phi02), rotate = hammerRetroazimuthalRotation(phi02);
          rotate.invert = hammerRetroazimuthalRotation(-phi02);
          function forward(lambda, phi) {
            var p = rotate(lambda, phi);
            lambda = p[0], phi = p[1];
            var sinPhi = sin(phi), cosPhi = cos(phi), cosLambda = cos(lambda), z = acos(sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosLambda), sinz = sin(z), K2 = abs(sinz) > epsilon ? z / sinz : 1;
            return [
              K2 * cosPhi0 * sin(lambda),
              (abs(lambda) > halfPi ? K2 : -K2) * (sinPhi0 * cosPhi - cosPhi0 * sinPhi * cosLambda)
            ];
          }
          forward.invert = function(x, y) {
            var rho = sqrt(x * x + y * y), sinz = -sin(rho), cosz = cos(rho), a = rho * cosz, b = -y * sinz, c = rho * sinPhi0, d = sqrt(a * a + b * b - c * c), phi = atan2(a * c + b * d, b * c - a * d), lambda = (rho > halfPi ? -1 : 1) * atan2(x * sinz, rho * cos(phi) * cosz + y * sin(phi) * sinz);
            return rotate.invert(lambda, phi);
          };
          return forward;
        }
        function hammerRetroazimuthalRotation(phi02) {
          var sinPhi0 = sin(phi02), cosPhi0 = cos(phi02);
          return function(lambda, phi) {
            var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi);
            return [
              atan2(y, x * cosPhi0 - z * sinPhi0),
              asin(z * cosPhi0 + x * sinPhi0)
            ];
          };
        }
        function hammerRetroazimuthal() {
          var phi02 = 0, m = d3Geo.geoProjectionMutator(hammerRetroazimuthalRaw), p = m(phi02), rotate_ = p.rotate, stream_ = p.stream, circle = d3Geo.geoCircle();
          p.parallel = function(_) {
            if (!arguments.length) return phi02 * degrees;
            var r = p.rotate();
            return m(phi02 = _ * radians).rotate(r);
          };
          p.rotate = function(_) {
            if (!arguments.length) return _ = rotate_.call(p), _[1] += phi02 * degrees, _;
            rotate_.call(p, [_[0], _[1] - phi02 * degrees]);
            circle.center([-_[0], -_[1]]);
            return p;
          };
          p.stream = function(stream) {
            stream = stream_(stream);
            stream.sphere = function() {
              stream.polygonStart();
              var epsilon$$1 = 0.01, ring = circle.radius(90 - epsilon$$1)().coordinates[0], n = ring.length - 1, i = -1, p2;
              stream.lineStart();
              while (++i < n) stream.point((p2 = ring[i])[0], p2[1]);
              stream.lineEnd();
              ring = circle.radius(90 + epsilon$$1)().coordinates[0];
              n = ring.length - 1;
              stream.lineStart();
              while (--i >= 0) stream.point((p2 = ring[i])[0], p2[1]);
              stream.lineEnd();
              stream.polygonEnd();
            };
            return stream;
          };
          return p.scale(79.4187).parallel(45).clipAngle(180 - 1e-3);
        }
        var K = 3, healpixParallel = asin(1 - 1 / K) * degrees, healpixLambert = cylindricalEqualAreaRaw(0);
        function healpixRaw(H) {
          var phi02 = healpixParallel * radians, dx = collignonRaw(pi, phi02)[0] - collignonRaw(-pi, phi02)[0], y02 = healpixLambert(0, phi02)[1], y12 = collignonRaw(0, phi02)[1], dy1 = sqrtPi - y12, k2 = tau / H, w2 = 4 / tau, h = y02 + dy1 * dy1 * 4 / tau;
          function forward(lambda, phi) {
            var point, phi2 = abs(phi);
            if (phi2 > phi02) {
              var i = min(H - 1, max(0, floor((lambda + pi) / k2)));
              lambda += pi * (H - 1) / H - i * k2;
              point = collignonRaw(lambda, phi2);
              point[0] = point[0] * tau / dx - tau * (H - 1) / (2 * H) + i * tau / H;
              point[1] = y02 + (point[1] - y12) * 4 * dy1 / tau;
              if (phi < 0) point[1] = -point[1];
            } else {
              point = healpixLambert(lambda, phi);
            }
            point[0] *= w2, point[1] /= h;
            return point;
          }
          forward.invert = function(x, y) {
            x /= w2, y *= h;
            var y2 = abs(y);
            if (y2 > y02) {
              var i = min(H - 1, max(0, floor((x + pi) / k2)));
              x = (x + pi * (H - 1) / H - i * k2) * dx / tau;
              var point = collignonRaw.invert(x, 0.25 * (y2 - y02) * tau / dy1 + y12);
              point[0] -= pi * (H - 1) / H - i * k2;
              if (y < 0) point[1] = -point[1];
              return point;
            }
            return healpixLambert.invert(x, y);
          };
          return forward;
        }
        function sphereTop(x, i) {
          return [x, i & 1 ? 90 - epsilon : healpixParallel];
        }
        function sphereBottom(x, i) {
          return [x, i & 1 ? -90 + epsilon : -healpixParallel];
        }
        function sphereNudge(d) {
          return [d[0] * (1 - epsilon), d[1]];
        }
        function sphere(step) {
          var c = [].concat(
            d3Array.range(-180, 180 + step / 2, step).map(sphereTop),
            d3Array.range(180, -180 - step / 2, -step).map(sphereBottom)
          );
          return {
            type: "Polygon",
            coordinates: [step === 180 ? c.map(sphereNudge) : c]
          };
        }
        function healpix() {
          var H = 4, m = d3Geo.geoProjectionMutator(healpixRaw), p = m(H), stream_ = p.stream;
          p.lobes = function(_) {
            return arguments.length ? m(H = +_) : H;
          };
          p.stream = function(stream) {
            var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));
            p.rotate(rotate);
            rotateStream.sphere = function() {
              d3Geo.geoStream(sphere(180 / H), sphereStream);
            };
            return rotateStream;
          };
          return p.scale(239.75);
        }
        function hillRaw(K2) {
          var L = 1 + K2, sinBt = sin(1 / L), Bt = asin(sinBt), A2 = 2 * sqrt(pi / (B2 = pi + 4 * Bt * L)), B2, rho0 = 0.5 * A2 * (L + sqrt(K2 * (2 + K2))), K22 = K2 * K2, L2 = L * L;
          function forward(lambda, phi) {
            var t = 1 - sin(phi), rho, omega;
            if (t && t < 2) {
              var theta = halfPi - phi, i = 25, delta;
              do {
                var sinTheta = sin(theta), cosTheta = cos(theta), Bt_Bt1 = Bt + atan2(sinTheta, L - cosTheta), C = 1 + L2 - 2 * L * cosTheta;
                theta -= delta = (theta - K22 * Bt - L * sinTheta + C * Bt_Bt1 - 0.5 * t * B2) / (2 * L * sinTheta * Bt_Bt1);
              } while (abs(delta) > epsilon2 && --i > 0);
              rho = A2 * sqrt(C);
              omega = lambda * Bt_Bt1 / pi;
            } else {
              rho = A2 * (K2 + t);
              omega = lambda * Bt / pi;
            }
            return [
              rho * sin(omega),
              rho0 - rho * cos(omega)
            ];
          }
          forward.invert = function(x, y) {
            var rho2 = x * x + (y -= rho0) * y, cosTheta = (1 + L2 - rho2 / (A2 * A2)) / (2 * L), theta = acos(cosTheta), sinTheta = sin(theta), Bt_Bt1 = Bt + atan2(sinTheta, L - cosTheta);
            return [
              asin(x / sqrt(rho2)) * pi / Bt_Bt1,
              asin(1 - 2 * (theta - K22 * Bt - L * sinTheta + (1 + L2 - 2 * L * cosTheta) * Bt_Bt1) / B2)
            ];
          };
          return forward;
        }
        function hill() {
          var K2 = 1, m = d3Geo.geoProjectionMutator(hillRaw), p = m(K2);
          p.ratio = function(_) {
            return arguments.length ? m(K2 = +_) : K2;
          };
          return p.scale(167.774).center([0, 18.67]);
        }
        var sinuMollweidePhi = 0.7109889596207567;
        var sinuMollweideY = 0.0528035274542;
        function sinuMollweideRaw(lambda, phi) {
          return phi > -sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi), lambda[1] += sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi);
        }
        sinuMollweideRaw.invert = function(x, y) {
          return y > -sinuMollweidePhi ? mollweideRaw.invert(x, y - sinuMollweideY) : sinusoidalRaw.invert(x, y);
        };
        function sinuMollweide() {
          return d3Geo.geoProjection(sinuMollweideRaw).rotate([-20, -55]).scale(164.263).center([0, -5.4036]);
        }
        function homolosineRaw(lambda, phi) {
          return abs(phi) > sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi), lambda[1] -= phi > 0 ? sinuMollweideY : -sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi);
        }
        homolosineRaw.invert = function(x, y) {
          return abs(y) > sinuMollweidePhi ? mollweideRaw.invert(x, y + (y > 0 ? sinuMollweideY : -sinuMollweideY)) : sinusoidalRaw.invert(x, y);
        };
        function homolosine() {
          return d3Geo.geoProjection(homolosineRaw).scale(152.63);
        }
        function hufnagelRaw(a, b, psiMax, ratio) {
          var k2 = sqrt(
            4 * pi / (2 * psiMax + (1 + a - b / 2) * sin(2 * psiMax) + (a + b) / 2 * sin(4 * psiMax) + b / 2 * sin(6 * psiMax))
          ), c = sqrt(
            ratio * sin(psiMax) * sqrt((1 + a * cos(2 * psiMax) + b * cos(4 * psiMax)) / (1 + a + b))
          ), M = psiMax * mapping(1);
          function radius(psi) {
            return sqrt(1 + a * cos(2 * psi) + b * cos(4 * psi));
          }
          function mapping(t) {
            var psi = t * psiMax;
            return (2 * psi + (1 + a - b / 2) * sin(2 * psi) + (a + b) / 2 * sin(4 * psi) + b / 2 * sin(6 * psi)) / psiMax;
          }
          function inversemapping(psi) {
            return radius(psi) * sin(psi);
          }
          var forward = function(lambda, phi) {
            var psi = psiMax * solve(mapping, M * sin(phi) / psiMax, phi / pi);
            if (isNaN(psi)) psi = psiMax * sign(phi);
            var kr = k2 * radius(psi);
            return [kr * c * lambda / pi * cos(psi), kr / c * sin(psi)];
          };
          forward.invert = function(x, y) {
            var psi = solve(inversemapping, y * c / k2);
            return [
              x * pi / (cos(psi) * k2 * c * radius(psi)),
              asin(psiMax * mapping(psi / psiMax) / M)
            ];
          };
          if (psiMax === 0) {
            k2 = sqrt(ratio / pi);
            forward = function(lambda, phi) {
              return [lambda * k2, sin(phi) / k2];
            };
            forward.invert = function(x, y) {
              return [x / k2, asin(y * k2)];
            };
          }
          return forward;
        }
        function hufnagel() {
          var a = 1, b = 0, psiMax = 45 * radians, ratio = 2, mutate = d3Geo.geoProjectionMutator(hufnagelRaw), projection = mutate(a, b, psiMax, ratio);
          projection.a = function(_) {
            return arguments.length ? mutate(a = +_, b, psiMax, ratio) : a;
          };
          projection.b = function(_) {
            return arguments.length ? mutate(a, b = +_, psiMax, ratio) : b;
          };
          projection.psiMax = function(_) {
            return arguments.length ? mutate(a, b, psiMax = +_ * radians, ratio) : psiMax * degrees;
          };
          projection.ratio = function(_) {
            return arguments.length ? mutate(a, b, psiMax, ratio = +_) : ratio;
          };
          return projection.scale(180.739);
        }
        function adsimp(f, a, b, fa, fm, fb, V0, tol, maxdepth, depth, state) {
          if (state.nanEncountered) {
            return NaN;
          }
          var h, f1, f2, sl, sr, s2, m, V1, V2, err;
          h = b - a;
          f1 = f(a + h * 0.25);
          f2 = f(b - h * 0.25);
          if (isNaN(f1)) {
            state.nanEncountered = true;
            return;
          }
          if (isNaN(f2)) {
            state.nanEncountered = true;
            return;
          }
          sl = h * (fa + 4 * f1 + fm) / 12;
          sr = h * (fm + 4 * f2 + fb) / 12;
          s2 = sl + sr;
          err = (s2 - V0) / 15;
          if (depth > maxdepth) {
            state.maxDepthCount++;
            return s2 + err;
          } else if (Math.abs(err) < tol) {
            return s2 + err;
          } else {
            m = a + h * 0.5;
            V1 = adsimp(f, a, m, fa, f1, fm, sl, tol * 0.5, maxdepth, depth + 1, state);
            if (isNaN(V1)) {
              state.nanEncountered = true;
              return NaN;
            }
            V2 = adsimp(f, m, b, fm, f2, fb, sr, tol * 0.5, maxdepth, depth + 1, state);
            if (isNaN(V2)) {
              state.nanEncountered = true;
              return NaN;
            }
            return V1 + V2;
          }
        }
        function integrate(f, a, b, tol, maxdepth) {
          var state = {
            maxDepthCount: 0,
            nanEncountered: false
          };
          if (tol === void 0) {
            tol = 1e-8;
          }
          if (maxdepth === void 0) {
            maxdepth = 20;
          }
          var fa = f(a);
          var fm = f(0.5 * (a + b));
          var fb = f(b);
          var V0 = (fa + 4 * fm + fb) * (b - a) / 6;
          var result = adsimp(f, a, b, fa, fm, fb, V0, tol, maxdepth, 1, state);
          return result;
        }
        function hyperellipticalRaw(alpha, k2, gamma) {
          function elliptic(f) {
            return alpha + (1 - alpha) * pow(1 - pow(f, k2), 1 / k2);
          }
          function z(f) {
            return integrate(elliptic, 0, f, 1e-4);
          }
          var G = 1 / z(1), n = 1e3, m = (1 + 1e-8) * G, approx = [];
          for (var i = 0; i <= n; i++)
            approx.push(z(i / n) * m);
          function Y(sinphi) {
            var rmin = 0, rmax = n, r = n >> 1;
            do {
              if (approx[r] > sinphi) rmax = r;
              else rmin = r;
              r = rmin + rmax >> 1;
            } while (r > rmin);
            var u = approx[r + 1] - approx[r];
            if (u) u = (sinphi - approx[r + 1]) / u;
            return (r + 1 + u) / n;
          }
          var ratio = 2 * Y(1) / pi * G / gamma;
          var forward = function(lambda, phi) {
            var y = Y(abs(sin(phi))), x = elliptic(y) * lambda;
            y /= ratio;
            return [x, phi >= 0 ? y : -y];
          };
          forward.invert = function(x, y) {
            var phi;
            y *= ratio;
            if (abs(y) < 1) phi = sign(y) * asin(z(abs(y)) * G);
            return [x / elliptic(abs(y)), phi];
          };
          return forward;
        }
        function hyperelliptical() {
          var alpha = 0, k2 = 2.5, gamma = 1.183136, m = d3Geo.geoProjectionMutator(hyperellipticalRaw), p = m(alpha, k2, gamma);
          p.alpha = function(_) {
            return arguments.length ? m(alpha = +_, k2, gamma) : alpha;
          };
          p.k = function(_) {
            return arguments.length ? m(alpha, k2 = +_, gamma) : k2;
          };
          p.gamma = function(_) {
            return arguments.length ? m(alpha, k2, gamma = +_) : gamma;
          };
          return p.scale(152.63);
        }
        function pointEqual(a, b) {
          return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
        }
        function interpolateLine(coordinates, m) {
          var i = -1, n = coordinates.length, p0 = coordinates[0], p1, dx, dy, resampled = [];
          while (++i < n) {
            p1 = coordinates[i];
            dx = (p1[0] - p0[0]) / m;
            dy = (p1[1] - p0[1]) / m;
            for (var j = 0; j < m; ++j) resampled.push([p0[0] + j * dx, p0[1] + j * dy]);
            p0 = p1;
          }
          resampled.push(p1);
          return resampled;
        }
        function interpolateSphere(lobes2) {
          var coordinates = [], lobe, lambda0, phi02, phi1, lambda2, phi2, i, n = lobes2[0].length;
          for (i = 0; i < n; ++i) {
            lobe = lobes2[0][i];
            lambda0 = lobe[0][0], phi02 = lobe[0][1], phi1 = lobe[1][1];
            lambda2 = lobe[2][0], phi2 = lobe[2][1];
            coordinates.push(interpolateLine([
              [lambda0 + epsilon, phi02 + epsilon],
              [lambda0 + epsilon, phi1 - epsilon],
              [lambda2 - epsilon, phi1 - epsilon],
              [lambda2 - epsilon, phi2 + epsilon]
            ], 30));
          }
          for (i = lobes2[1].length - 1; i >= 0; --i) {
            lobe = lobes2[1][i];
            lambda0 = lobe[0][0], phi02 = lobe[0][1], phi1 = lobe[1][1];
            lambda2 = lobe[2][0], phi2 = lobe[2][1];
            coordinates.push(interpolateLine([
              [lambda2 - epsilon, phi2 - epsilon],
              [lambda2 - epsilon, phi1 + epsilon],
              [lambda0 + epsilon, phi1 + epsilon],
              [lambda0 + epsilon, phi02 - epsilon]
            ], 30));
          }
          return {
            type: "Polygon",
            coordinates: [d3Array.merge(coordinates)]
          };
        }
        function interrupt(project, lobes2, inverse2) {
          var sphere2, bounds;
          function forward(lambda, phi) {
            var sign$$1 = phi < 0 ? -1 : 1, lobe = lobes2[+(phi < 0)];
            for (var i = 0, n = lobe.length - 1; i < n && lambda > lobe[i][2][0]; ++i) ;
            var p2 = project(lambda - lobe[i][1][0], phi);
            p2[0] += project(lobe[i][1][0], sign$$1 * phi > sign$$1 * lobe[i][0][1] ? lobe[i][0][1] : phi)[0];
            return p2;
          }
          if (inverse2) {
            forward.invert = inverse2(forward);
          } else if (project.invert) {
            forward.invert = function(x, y) {
              var bound = bounds[+(y < 0)], lobe = lobes2[+(y < 0)];
              for (var i = 0, n = bound.length; i < n; ++i) {
                var b = bound[i];
                if (b[0][0] <= x && x < b[1][0] && b[0][1] <= y && y < b[1][1]) {
                  var p2 = project.invert(x - project(lobe[i][1][0], 0)[0], y);
                  p2[0] += lobe[i][1][0];
                  return pointEqual(forward(p2[0], p2[1]), [x, y]) ? p2 : null;
                }
              }
            };
          }
          var p = d3Geo.geoProjection(forward), stream_ = p.stream;
          p.stream = function(stream) {
            var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));
            p.rotate(rotate);
            rotateStream.sphere = function() {
              d3Geo.geoStream(sphere2, sphereStream);
            };
            return rotateStream;
          };
          p.lobes = function(_) {
            if (!arguments.length) return lobes2.map(function(lobe) {
              return lobe.map(function(l) {
                return [
                  [l[0][0] * degrees, l[0][1] * degrees],
                  [l[1][0] * degrees, l[1][1] * degrees],
                  [l[2][0] * degrees, l[2][1] * degrees]
                ];
              });
            });
            sphere2 = interpolateSphere(_);
            lobes2 = _.map(function(lobe) {
              return lobe.map(function(l) {
                return [
                  [l[0][0] * radians, l[0][1] * radians],
                  [l[1][0] * radians, l[1][1] * radians],
                  [l[2][0] * radians, l[2][1] * radians]
                ];
              });
            });
            bounds = lobes2.map(function(lobe) {
              return lobe.map(function(l) {
                var x02 = project(l[0][0], l[0][1])[0], x12 = project(l[2][0], l[2][1])[0], y02 = project(l[1][0], l[0][1])[1], y12 = project(l[1][0], l[1][1])[1], t;
                if (y02 > y12) t = y02, y02 = y12, y12 = t;
                return [[x02, y02], [x12, y12]];
              });
            });
            return p;
          };
          if (lobes2 != null) p.lobes(lobes2);
          return p;
        }
        var lobes = [[
          // northern hemisphere
          [[-180, 0], [-100, 90], [-40, 0]],
          [[-40, 0], [30, 90], [180, 0]]
        ], [
          // southern hemisphere
          [[-180, 0], [-160, -90], [-100, 0]],
          [[-100, 0], [-60, -90], [-20, 0]],
          [[-20, 0], [20, -90], [80, 0]],
          [[80, 0], [140, -90], [180, 0]]
        ]];
        function boggs$1() {
          return interrupt(boggsRaw, lobes).scale(160.857);
        }
        var lobes$1 = [[
          // northern hemisphere
          [[-180, 0], [-100, 90], [-40, 0]],
          [[-40, 0], [30, 90], [180, 0]]
        ], [
          // southern hemisphere
          [[-180, 0], [-160, -90], [-100, 0]],
          [[-100, 0], [-60, -90], [-20, 0]],
          [[-20, 0], [20, -90], [80, 0]],
          [[80, 0], [140, -90], [180, 0]]
        ]];
        function homolosine$1() {
          return interrupt(homolosineRaw, lobes$1).scale(152.63);
        }
        var lobes$2 = [[
          // northern hemisphere
          [[-180, 0], [-100, 90], [-40, 0]],
          [[-40, 0], [30, 90], [180, 0]]
        ], [
          // southern hemisphere
          [[-180, 0], [-160, -90], [-100, 0]],
          [[-100, 0], [-60, -90], [-20, 0]],
          [[-20, 0], [20, -90], [80, 0]],
          [[80, 0], [140, -90], [180, 0]]
        ]];
        function mollweide$1() {
          return interrupt(mollweideRaw, lobes$2).scale(169.529);
        }
        var lobes$3 = [[
          // northern hemisphere
          [[-180, 0], [-90, 90], [0, 0]],
          [[0, 0], [90, 90], [180, 0]]
        ], [
          // southern hemisphere
          [[-180, 0], [-90, -90], [0, 0]],
          [[0, 0], [90, -90], [180, 0]]
        ]];
        function mollweideHemispheres() {
          return interrupt(mollweideRaw, lobes$3).scale(169.529).rotate([20, 0]);
        }
        var lobes$4 = [[
          // northern hemisphere
          [[-180, 35], [-30, 90], [0, 35]],
          [[0, 35], [30, 90], [180, 35]]
        ], [
          // southern hemisphere
          [[-180, -10], [-102, -90], [-65, -10]],
          [[-65, -10], [5, -90], [77, -10]],
          [[77, -10], [103, -90], [180, -10]]
        ]];
        function sinuMollweide$1() {
          return interrupt(sinuMollweideRaw, lobes$4, solve2d).rotate([-20, -55]).scale(164.263).center([0, -5.4036]);
        }
        var lobes$5 = [[
          // northern hemisphere
          [[-180, 0], [-110, 90], [-40, 0]],
          [[-40, 0], [0, 90], [40, 0]],
          [[40, 0], [110, 90], [180, 0]]
        ], [
          // southern hemisphere
          [[-180, 0], [-110, -90], [-40, 0]],
          [[-40, 0], [0, -90], [40, 0]],
          [[40, 0], [110, -90], [180, 0]]
        ]];
        function sinusoidal$1() {
          return interrupt(sinusoidalRaw, lobes$5).scale(152.63).rotate([-20, 0]);
        }
        function kavrayskiy7Raw(lambda, phi) {
          return [3 / tau * lambda * sqrt(pi * pi / 3 - phi * phi), phi];
        }
        kavrayskiy7Raw.invert = function(x, y) {
          return [tau / 3 * x / sqrt(pi * pi / 3 - y * y), y];
        };
        function kavrayskiy7() {
          return d3Geo.geoProjection(kavrayskiy7Raw).scale(158.837);
        }
        function lagrangeRaw(n) {
          function forward(lambda, phi) {
            if (abs(abs(phi) - halfPi) < epsilon) return [0, phi < 0 ? -2 : 2];
            var sinPhi = sin(phi), v = pow((1 + sinPhi) / (1 - sinPhi), n / 2), c = 0.5 * (v + 1 / v) + cos(lambda *= n);
            return [
              2 * sin(lambda) / c,
              (v - 1 / v) / c
            ];
          }
          forward.invert = function(x, y) {
            var y02 = abs(y);
            if (abs(y02 - 2) < epsilon) return x ? null : [0, sign(y) * halfPi];
            if (y02 > 2) return null;
            x /= 2, y /= 2;
            var x2 = x * x, y2 = y * y, t = 2 * y / (1 + x2 + y2);
            t = pow((1 + t) / (1 - t), 1 / n);
            return [
              atan2(2 * x, 1 - x2 - y2) / n,
              asin((t - 1) / (t + 1))
            ];
          };
          return forward;
        }
        function lagrange() {
          var n = 0.5, m = d3Geo.geoProjectionMutator(lagrangeRaw), p = m(n);
          p.spacing = function(_) {
            return arguments.length ? m(n = +_) : n;
          };
          return p.scale(124.75);
        }
        var pi_sqrt2 = pi / sqrt2;
        function larriveeRaw(lambda, phi) {
          return [
            lambda * (1 + sqrt(cos(phi))) / 2,
            phi / (cos(phi / 2) * cos(lambda / 6))
          ];
        }
        larriveeRaw.invert = function(x, y) {
          var x02 = abs(x), y02 = abs(y), lambda = epsilon, phi = halfPi;
          if (y02 < pi_sqrt2) phi *= y02 / pi_sqrt2;
          else lambda += 6 * acos(pi_sqrt2 / y02);
          for (var i = 0; i < 25; i++) {
            var sinPhi = sin(phi), sqrtcosPhi = sqrt(cos(phi)), sinPhi_2 = sin(phi / 2), cosPhi_2 = cos(phi / 2), sinLambda_6 = sin(lambda / 6), cosLambda_6 = cos(lambda / 6), f0 = 0.5 * lambda * (1 + sqrtcosPhi) - x02, f1 = phi / (cosPhi_2 * cosLambda_6) - y02, df0dPhi = sqrtcosPhi ? -0.25 * lambda * sinPhi / sqrtcosPhi : 0, df0dLambda = 0.5 * (1 + sqrtcosPhi), df1dPhi = (1 + 0.5 * phi * sinPhi_2 / cosPhi_2) / (cosPhi_2 * cosLambda_6), df1dLambda = phi / cosPhi_2 * (sinLambda_6 / 6) / (cosLambda_6 * cosLambda_6), denom = df0dPhi * df1dLambda - df1dPhi * df0dLambda, dPhi = (f0 * df1dLambda - f1 * df0dLambda) / denom, dLambda = (f1 * df0dPhi - f0 * df1dPhi) / denom;
            phi -= dPhi;
            lambda -= dLambda;
            if (abs(dPhi) < epsilon && abs(dLambda) < epsilon) break;
          }
          return [x < 0 ? -lambda : lambda, y < 0 ? -phi : phi];
        };
        function larrivee() {
          return d3Geo.geoProjection(larriveeRaw).scale(97.2672);
        }
        function laskowskiRaw(lambda, phi) {
          var lambda2 = lambda * lambda, phi2 = phi * phi;
          return [
            lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)),
            phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 199025e-9) + phi2 * (0.0998909 + phi2 * -0.0491032))
          ];
        }
        laskowskiRaw.invert = function(x, y) {
          var lambda = sign(x) * pi, phi = y / 2, i = 50;
          do {
            var lambda2 = lambda * lambda, phi2 = phi * phi, lambdaPhi = lambda * phi, fx = lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)) - x, fy = phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 199025e-9) + phi2 * (0.0998909 + phi2 * -0.0491032)) - y, deltaxDeltaLambda = 0.975534 - phi2 * (0.119161 + 3 * lambda2 * 0.0143059 + phi2 * 0.0547009), deltaxDeltaPhi = -lambdaPhi * (2 * 0.119161 + 4 * 0.0547009 * phi2 + 2 * 0.0143059 * lambda2), deltayDeltaLambda = lambdaPhi * (2 * 0.0802894 + 4 * 199025e-9 * lambda2 + 2 * -0.02855 * phi2), deltayDeltaPhi = 1.00384 + lambda2 * (0.0802894 + 199025e-9 * lambda2) + phi2 * (3 * (0.0998909 - 0.02855 * lambda2) - 5 * 0.0491032 * phi2), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda, deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
            lambda -= deltaLambda, phi -= deltaPhi;
          } while ((abs(deltaLambda) > epsilon || abs(deltaPhi) > epsilon) && --i > 0);
          return i && [lambda, phi];
        };
        function laskowski() {
          return d3Geo.geoProjection(laskowskiRaw).scale(139.98);
        }
        function littrowRaw(lambda, phi) {
          return [
            sin(lambda) / cos(phi),
            tan(phi) * cos(lambda)
          ];
        }
        littrowRaw.invert = function(x, y) {
          var x2 = x * x, y2 = y * y, y2_1 = y2 + 1, x2_y2_1 = x2 + y2_1, cosPhi = x ? sqrt1_2 * sqrt((x2_y2_1 - sqrt(x2_y2_1 * x2_y2_1 - 4 * x2)) / x2) : 1 / sqrt(y2_1);
          return [
            asin(x * cosPhi),
            sign(y) * acos(cosPhi)
          ];
        };
        function littrow() {
          return d3Geo.geoProjection(littrowRaw).scale(144.049).clipAngle(90 - 1e-3);
        }
        function loximuthalRaw(phi02) {
          var cosPhi0 = cos(phi02), tanPhi0 = tan(quarterPi + phi02 / 2);
          function forward(lambda, phi) {
            var y = phi - phi02, x = abs(y) < epsilon ? lambda * cosPhi0 : abs(x = quarterPi + phi / 2) < epsilon || abs(abs(x) - halfPi) < epsilon ? 0 : lambda * y / log(tan(x) / tanPhi0);
            return [x, y];
          }
          forward.invert = function(x, y) {
            var lambda, phi = y + phi02;
            return [
              abs(y) < epsilon ? x / cosPhi0 : abs(lambda = quarterPi + phi / 2) < epsilon || abs(abs(lambda) - halfPi) < epsilon ? 0 : x * log(tan(lambda) / tanPhi0) / y,
              phi
            ];
          };
          return forward;
        }
        function loximuthal() {
          return parallel1(loximuthalRaw).parallel(40).scale(158.837);
        }
        function millerRaw(lambda, phi) {
          return [lambda, 1.25 * log(tan(quarterPi + 0.4 * phi))];
        }
        millerRaw.invert = function(x, y) {
          return [x, 2.5 * atan(exp(0.8 * y)) - 0.625 * pi];
        };
        function miller() {
          return d3Geo.geoProjection(millerRaw).scale(108.318);
        }
        function modifiedStereographicRaw(C) {
          var m = C.length - 1;
          function forward(lambda, phi) {
            var cosPhi = cos(phi), k2 = 2 / (1 + cosPhi * cos(lambda)), zr = k2 * cosPhi * sin(lambda), zi = k2 * sin(phi), i = m, w2 = C[i], ar = w2[0], ai = w2[1], t;
            while (--i >= 0) {
              w2 = C[i];
              ar = w2[0] + zr * (t = ar) - zi * ai;
              ai = w2[1] + zr * ai + zi * t;
            }
            ar = zr * (t = ar) - zi * ai;
            ai = zr * ai + zi * t;
            return [ar, ai];
          }
          forward.invert = function(x, y) {
            var i = 20, zr = x, zi = y;
            do {
              var j = m, w2 = C[j], ar = w2[0], ai = w2[1], br = 0, bi = 0, t;
              while (--j >= 0) {
                w2 = C[j];
                br = ar + zr * (t = br) - zi * bi;
                bi = ai + zr * bi + zi * t;
                ar = w2[0] + zr * (t = ar) - zi * ai;
                ai = w2[1] + zr * ai + zi * t;
              }
              br = ar + zr * (t = br) - zi * bi;
              bi = ai + zr * bi + zi * t;
              ar = zr * (t = ar) - zi * ai - x;
              ai = zr * ai + zi * t - y;
              var denominator = br * br + bi * bi, deltar, deltai;
              zr -= deltar = (ar * br + ai * bi) / denominator;
              zi -= deltai = (ai * br - ar * bi) / denominator;
            } while (abs(deltar) + abs(deltai) > epsilon * epsilon && --i > 0);
            if (i) {
              var rho = sqrt(zr * zr + zi * zi), c = 2 * atan(rho * 0.5), sinc = sin(c);
              return [atan2(zr * sinc, rho * cos(c)), rho ? asin(zi * sinc / rho) : 0];
            }
          };
          return forward;
        }
        var alaska = [[0.9972523, 0], [52513e-7, -41175e-7], [74606e-7, 48125e-7], [-0.0153783, -0.1968253], [0.0636871, -0.1408027], [0.3660976, -0.2937382]], gs48 = [[0.98879, 0], [0, 0], [-0.050909, 0], [0, 0], [0.075528, 0]], gs50 = [[0.984299, 0], [0.0211642, 37608e-7], [-0.1036018, -0.0575102], [-0.0329095, -0.0320119], [0.0499471, 0.1223335], [0.026046, 0.0899805], [7388e-7, -0.1435792], [75848e-7, -0.1334108], [-0.0216473, 0.0776645], [-0.0225161, 0.0853673]], miller$1 = [[0.9245, 0], [0, 0], [0.01943, 0]], lee = [[0.721316, 0], [0, 0], [-881625e-8, -617325e-8]];
        function modifiedStereographicAlaska() {
          return modifiedStereographic(alaska, [152, -64]).scale(1400).center([-160.908, 62.4864]).clipAngle(30).angle(7.8);
        }
        function modifiedStereographicGs48() {
          return modifiedStereographic(gs48, [95, -38]).scale(1e3).clipAngle(55).center([-96.5563, 38.8675]);
        }
        function modifiedStereographicGs50() {
          return modifiedStereographic(gs50, [120, -45]).scale(359.513).clipAngle(55).center([-117.474, 53.0628]);
        }
        function modifiedStereographicMiller() {
          return modifiedStereographic(miller$1, [-20, -18]).scale(209.091).center([20, 16.7214]).clipAngle(82);
        }
        function modifiedStereographicLee() {
          return modifiedStereographic(lee, [165, 10]).scale(250).clipAngle(130).center([-165, -10]);
        }
        function modifiedStereographic(coefficients, rotate) {
          var p = d3Geo.geoProjection(modifiedStereographicRaw(coefficients)).rotate(rotate).clipAngle(90), r = d3Geo.geoRotation(rotate), center = p.center;
          delete p.rotate;
          p.center = function(_) {
            return arguments.length ? center(r(_)) : r.invert(center());
          };
          return p;
        }
        var sqrt6 = sqrt(6), sqrt7 = sqrt(7);
        function mtFlatPolarParabolicRaw(lambda, phi) {
          var theta = asin(7 * sin(phi) / (3 * sqrt6));
          return [
            sqrt6 * lambda * (2 * cos(2 * theta / 3) - 1) / sqrt7,
            9 * sin(theta / 3) / sqrt7
          ];
        }
        mtFlatPolarParabolicRaw.invert = function(x, y) {
          var theta = 3 * asin(y * sqrt7 / 9);
          return [
            x * sqrt7 / (sqrt6 * (2 * cos(2 * theta / 3) - 1)),
            asin(sin(theta) * 3 * sqrt6 / 7)
          ];
        };
        function mtFlatPolarParabolic() {
          return d3Geo.geoProjection(mtFlatPolarParabolicRaw).scale(164.859);
        }
        function mtFlatPolarQuarticRaw(lambda, phi) {
          var k2 = (1 + sqrt1_2) * sin(phi), theta = phi;
          for (var i = 0, delta; i < 25; i++) {
            theta -= delta = (sin(theta / 2) + sin(theta) - k2) / (0.5 * cos(theta / 2) + cos(theta));
            if (abs(delta) < epsilon) break;
          }
          return [
            lambda * (1 + 2 * cos(theta) / cos(theta / 2)) / (3 * sqrt2),
            2 * sqrt(3) * sin(theta / 2) / sqrt(2 + sqrt2)
          ];
        }
        mtFlatPolarQuarticRaw.invert = function(x, y) {
          var sinTheta_2 = y * sqrt(2 + sqrt2) / (2 * sqrt(3)), theta = 2 * asin(sinTheta_2);
          return [
            3 * sqrt2 * x / (1 + 2 * cos(theta) / cos(theta / 2)),
            asin((sinTheta_2 + sin(theta)) / (1 + sqrt1_2))
          ];
        };
        function mtFlatPolarQuartic() {
          return d3Geo.geoProjection(mtFlatPolarQuarticRaw).scale(188.209);
        }
        function mtFlatPolarSinusoidalRaw(lambda, phi) {
          var A2 = sqrt(6 / (4 + pi)), k2 = (1 + pi / 4) * sin(phi), theta = phi / 2;
          for (var i = 0, delta; i < 25; i++) {
            theta -= delta = (theta / 2 + sin(theta) - k2) / (0.5 + cos(theta));
            if (abs(delta) < epsilon) break;
          }
          return [
            A2 * (0.5 + cos(theta)) * lambda / 1.5,
            A2 * theta
          ];
        }
        mtFlatPolarSinusoidalRaw.invert = function(x, y) {
          var A2 = sqrt(6 / (4 + pi)), theta = y / A2;
          if (abs(abs(theta) - halfPi) < epsilon) theta = theta < 0 ? -halfPi : halfPi;
          return [
            1.5 * x / (A2 * (0.5 + cos(theta))),
            asin((theta / 2 + sin(theta)) / (1 + pi / 4))
          ];
        };
        function mtFlatPolarSinusoidal() {
          return d3Geo.geoProjection(mtFlatPolarSinusoidalRaw).scale(166.518);
        }
        function naturalEarth2Raw(lambda, phi) {
          var phi2 = phi * phi, phi4 = phi2 * phi2, phi6 = phi2 * phi4;
          return [
            lambda * (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 331e-5 * phi6)),
            phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 396e-5 * phi4))
          ];
        }
        naturalEarth2Raw.invert = function(x, y) {
          var phi = y, i = 25, delta, phi2, phi4, phi6;
          do {
            phi2 = phi * phi;
            phi4 = phi2 * phi2;
            phi -= delta = (phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 396e-5 * phi4)) - y) / (1.01183 + phi4 * phi4 * (9 * -0.02625 + 11 * 0.01926 * phi2 + 13 * -396e-5 * phi4));
          } while (abs(delta) > epsilon2 && --i > 0);
          phi2 = phi * phi;
          phi4 = phi2 * phi2;
          phi6 = phi2 * phi4;
          return [
            x / (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 331e-5 * phi6)),
            phi
          ];
        };
        function naturalEarth2() {
          return d3Geo.geoProjection(naturalEarth2Raw).scale(175.295);
        }
        function nellHammerRaw(lambda, phi) {
          return [
            lambda * (1 + cos(phi)) / 2,
            2 * (phi - tan(phi / 2))
          ];
        }
        nellHammerRaw.invert = function(x, y) {
          var p = y / 2;
          for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon; ++i) {
            var c = cos(y / 2);
            y -= delta = (y - tan(y / 2) - p) / (1 - 0.5 / (c * c));
          }
          return [
            2 * x / (1 + cos(y)),
            y
          ];
        };
        function nellHammer() {
          return d3Geo.geoProjection(nellHammerRaw).scale(152.63);
        }
        var lobes$6 = [[
          // northern hemisphere
          [[-180, 0], [-90, 90], [0, 0]],
          [[0, 0], [90, 90], [180, 0]]
        ], [
          // southern hemisphere
          [[-180, 0], [-90, -90], [0, 0]],
          [[0, 0], [90, -90], [180, 0]]
        ]];
        function quarticAuthalic() {
          return interrupt(hammerRaw(Infinity), lobes$6).rotate([20, 0]).scale(152.63);
        }
        function nicolosiRaw(lambda, phi) {
          var sinPhi = sin(phi), q = cos(phi), s = sign(lambda);
          if (lambda === 0 || abs(phi) === halfPi) return [0, phi];
          else if (phi === 0) return [lambda, 0];
          else if (abs(lambda) === halfPi) return [lambda * q, halfPi * sinPhi];
          var b = pi / (2 * lambda) - 2 * lambda / pi, c = 2 * phi / pi, d = (1 - c * c) / (sinPhi - c);
          var b2 = b * b, d2 = d * d, b2d2 = 1 + b2 / d2, d2b2 = 1 + d2 / b2;
          var M = (b * sinPhi / d - b / 2) / b2d2, N = (d2 * sinPhi / b2 + d / 2) / d2b2, m = M * M + q * q / b2d2, n = N * N - (d2 * sinPhi * sinPhi / b2 + d * sinPhi - 1) / d2b2;
          return [
            halfPi * (M + sqrt(m) * s),
            halfPi * (N + sqrt(n < 0 ? 0 : n) * sign(-phi * b) * s)
          ];
        }
        nicolosiRaw.invert = function(x, y) {
          x /= halfPi;
          y /= halfPi;
          var x2 = x * x, y2 = y * y, x2y2 = x2 + y2, pi2 = pi * pi;
          return [
            x ? (x2y2 - 1 + sqrt((1 - x2y2) * (1 - x2y2) + 4 * x2)) / (2 * x) * halfPi : 0,
            solve(function(phi) {
              return x2y2 * (pi * sin(phi) - 2 * phi) * pi + 4 * phi * phi * (y - sin(phi)) + 2 * pi * phi - pi2 * y;
            }, 0)
          ];
        };
        function nicolosi() {
          return d3Geo.geoProjection(nicolosiRaw).scale(127.267);
        }
        var pattersonK1 = 1.0148, pattersonK2 = 0.23185, pattersonK3 = -0.14499, pattersonK4 = 0.02406, pattersonC1 = pattersonK1, pattersonC2 = 5 * pattersonK2, pattersonC3 = 7 * pattersonK3, pattersonC4 = 9 * pattersonK4, pattersonYmax = 1.790857183;
        function pattersonRaw(lambda, phi) {
          var phi2 = phi * phi;
          return [
            lambda,
            phi * (pattersonK1 + phi2 * phi2 * (pattersonK2 + phi2 * (pattersonK3 + pattersonK4 * phi2)))
          ];
        }
        pattersonRaw.invert = function(x, y) {
          if (y > pattersonYmax) y = pattersonYmax;
          else if (y < -pattersonYmax) y = -pattersonYmax;
          var yc = y, delta;
          do {
            var y2 = yc * yc;
            yc -= delta = (yc * (pattersonK1 + y2 * y2 * (pattersonK2 + y2 * (pattersonK3 + pattersonK4 * y2))) - y) / (pattersonC1 + y2 * y2 * (pattersonC2 + y2 * (pattersonC3 + pattersonC4 * y2)));
          } while (abs(delta) > epsilon);
          return [x, yc];
        };
        function patterson() {
          return d3Geo.geoProjection(pattersonRaw).scale(139.319);
        }
        function polyconicRaw(lambda, phi) {
          if (abs(phi) < epsilon) return [lambda, 0];
          var tanPhi = tan(phi), k2 = lambda * sin(phi);
          return [
            sin(k2) / tanPhi,
            phi + (1 - cos(k2)) / tanPhi
          ];
        }
        polyconicRaw.invert = function(x, y) {
          if (abs(y) < epsilon) return [x, 0];
          var k2 = x * x + y * y, phi = y * 0.5, i = 10, delta;
          do {
            var tanPhi = tan(phi), secPhi = 1 / cos(phi), j = k2 - 2 * y * phi + phi * phi;
            phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi);
          } while (abs(delta) > epsilon && --i > 0);
          tanPhi = tan(phi);
          return [
            (abs(y) < abs(phi + 1 / tanPhi) ? asin(x * tanPhi) : sign(y) * sign(x) * (acos(abs(x * tanPhi)) + halfPi)) / sin(phi),
            phi
          ];
        };
        function polyconic() {
          return d3Geo.geoProjection(polyconicRaw).scale(103.74);
        }
        function matrix(a, b) {
          var u = subtract(a[1], a[0]), v = subtract(b[1], b[0]), phi = angle$1(u, v), s = length(u) / length(v);
          return multiply([
            1,
            0,
            a[0][0],
            0,
            1,
            a[0][1]
          ], multiply([
            s,
            0,
            0,
            0,
            s,
            0
          ], multiply([
            cos(phi),
            sin(phi),
            0,
            -sin(phi),
            cos(phi),
            0
          ], [
            1,
            0,
            -b[0][0],
            0,
            1,
            -b[0][1]
          ])));
        }
        function inverse(m) {
          var k2 = 1 / (m[0] * m[4] - m[1] * m[3]);
          return [
            k2 * m[4],
            -k2 * m[1],
            k2 * (m[1] * m[5] - m[2] * m[4]),
            -k2 * m[3],
            k2 * m[0],
            k2 * (m[2] * m[3] - m[0] * m[5])
          ];
        }
        function multiply(a, b) {
          return [
            a[0] * b[0] + a[1] * b[3],
            a[0] * b[1] + a[1] * b[4],
            a[0] * b[2] + a[1] * b[5] + a[2],
            a[3] * b[0] + a[4] * b[3],
            a[3] * b[1] + a[4] * b[4],
            a[3] * b[2] + a[4] * b[5] + a[5]
          ];
        }
        function subtract(a, b) {
          return [a[0] - b[0], a[1] - b[1]];
        }
        function length(v) {
          return sqrt(v[0] * v[0] + v[1] * v[1]);
        }
        function angle$1(a, b) {
          return atan2(a[0] * b[1] - a[1] * b[0], a[0] * b[0] + a[1] * b[1]);
        }
        function polyhedral(root, face, r) {
          recurse(root, { transform: null });
          function recurse(node, parent) {
            node.edges = faceEdges(node.face);
            if (parent.face) {
              var shared = node.shared = sharedEdge(node.face, parent.face), m = matrix(shared.map(parent.project), shared.map(node.project));
              node.transform = parent.transform ? multiply(parent.transform, m) : m;
              var edges = parent.edges;
              for (var i = 0, n = edges.length; i < n; ++i) {
                if (pointEqual$1(shared[0], edges[i][1]) && pointEqual$1(shared[1], edges[i][0])) edges[i] = node;
                if (pointEqual$1(shared[0], edges[i][0]) && pointEqual$1(shared[1], edges[i][1])) edges[i] = node;
              }
              edges = node.edges;
              for (i = 0, n = edges.length; i < n; ++i) {
                if (pointEqual$1(shared[0], edges[i][0]) && pointEqual$1(shared[1], edges[i][1])) edges[i] = parent;
                if (pointEqual$1(shared[0], edges[i][1]) && pointEqual$1(shared[1], edges[i][0])) edges[i] = parent;
              }
            } else {
              node.transform = parent.transform;
            }
            if (node.children) {
              node.children.forEach(function(child) {
                recurse(child, node);
              });
            }
            return node;
          }
          function forward(lambda, phi) {
            var node = face(lambda, phi), point = node.project([lambda * degrees, phi * degrees]), t;
            if (t = node.transform) {
              return [
                t[0] * point[0] + t[1] * point[1] + t[2],
                -(t[3] * point[0] + t[4] * point[1] + t[5])
              ];
            }
            point[1] = -point[1];
            return point;
          }
          if (hasInverse(root)) forward.invert = function(x, y) {
            var coordinates = faceInvert(root, [x, -y]);
            return coordinates && (coordinates[0] *= radians, coordinates[1] *= radians, coordinates);
          };
          function faceInvert(node, coordinates) {
            var invert = node.project.invert, t = node.transform, point = coordinates;
            if (t) {
              t = inverse(t);
              point = [
                t[0] * point[0] + t[1] * point[1] + t[2],
                t[3] * point[0] + t[4] * point[1] + t[5]
              ];
            }
            if (invert && node === faceDegrees(p = invert(point))) return p;
            var p, children = node.children;
            for (var i = 0, n = children && children.length; i < n; ++i) {
              if (p = faceInvert(children[i], coordinates)) return p;
            }
          }
          function faceDegrees(coordinates) {
            return face(coordinates[0] * radians, coordinates[1] * radians);
          }
          var proj = d3Geo.geoProjection(forward), stream_ = proj.stream;
          proj.stream = function(stream) {
            var rotate = proj.rotate(), rotateStream = stream_(stream), sphereStream = (proj.rotate([0, 0]), stream_(stream));
            proj.rotate(rotate);
            rotateStream.sphere = function() {
              sphereStream.polygonStart();
              sphereStream.lineStart();
              outline(sphereStream, root);
              sphereStream.lineEnd();
              sphereStream.polygonEnd();
            };
            return rotateStream;
          };
          return proj.angle(r == null ? -30 : r * degrees);
        }
        function outline(stream, node, parent) {
          var point, edges = node.edges, n = edges.length, edge, multiPoint = { type: "MultiPoint", coordinates: node.face }, notPoles = node.face.filter(function(d) {
            return abs(d[1]) !== 90;
          }), b = d3Geo.geoBounds({ type: "MultiPoint", coordinates: notPoles }), inside = false, j = -1, dx = b[1][0] - b[0][0];
          var c = dx === 180 || dx === 360 ? [(b[0][0] + b[1][0]) / 2, (b[0][1] + b[1][1]) / 2] : d3Geo.geoCentroid(multiPoint);
          if (parent) while (++j < n) {
            if (edges[j] === parent) break;
          }
          ++j;
          for (var i = 0; i < n; ++i) {
            edge = edges[(i + j) % n];
            if (Array.isArray(edge)) {
              if (!inside) {
                stream.point((point = d3Geo.geoInterpolate(edge[0], c)(epsilon))[0], point[1]);
                inside = true;
              }
              stream.point((point = d3Geo.geoInterpolate(edge[1], c)(epsilon))[0], point[1]);
            } else {
              inside = false;
              if (edge !== parent) outline(stream, edge, node);
            }
          }
        }
        function pointEqual$1(a, b) {
          return a && b && a[0] === b[0] && a[1] === b[1];
        }
        function sharedEdge(a, b) {
          var x, y, n = a.length, found = null;
          for (var i = 0; i < n; ++i) {
            x = a[i];
            for (var j = b.length; --j >= 0; ) {
              y = b[j];
              if (x[0] === y[0] && x[1] === y[1]) {
                if (found) return [found, x];
                found = x;
              }
            }
          }
        }
        function faceEdges(face) {
          var n = face.length, edges = [];
          for (var a = face[n - 1], i = 0; i < n; ++i) edges.push([a, a = face[i]]);
          return edges;
        }
        function hasInverse(node) {
          return node.project.invert || node.children && node.children.some(hasInverse);
        }
        var octahedron = [
          [0, 90],
          [-90, 0],
          [0, 0],
          [90, 0],
          [180, 0],
          [0, -90]
        ];
        var octahedron$1 = [
          [0, 2, 1],
          [0, 3, 2],
          [5, 1, 2],
          [5, 2, 3],
          [0, 1, 4],
          [0, 4, 3],
          [5, 4, 1],
          [5, 3, 4]
        ].map(function(face) {
          return face.map(function(i) {
            return octahedron[i];
          });
        });
        function butterfly(faceProjection) {
          faceProjection = faceProjection || function(face) {
            var c = d3Geo.geoCentroid({ type: "MultiPoint", coordinates: face });
            return d3Geo.geoGnomonic().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);
          };
          var faces = octahedron$1.map(function(face) {
            return { face, project: faceProjection(face) };
          });
          [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function(d, i) {
            var node = faces[d];
            node && (node.children || (node.children = [])).push(faces[i]);
          });
          return polyhedral(faces[0], function(lambda, phi) {
            return faces[lambda < -pi / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < pi / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5];
          }).angle(-30).scale(101.858).center([0, 45]);
        }
        var kx = 2 / sqrt(3);
        function collignonK(a, b) {
          var p = collignonRaw(a, b);
          return [p[0] * kx, p[1]];
        }
        collignonK.invert = function(x, y) {
          return collignonRaw.invert(x / kx, y);
        };
        function collignon$1(faceProjection) {
          faceProjection = faceProjection || function(face) {
            var c = d3Geo.geoCentroid({ type: "MultiPoint", coordinates: face });
            return d3Geo.geoProjection(collignonK).translate([0, 0]).scale(1).rotate(c[1] > 0 ? [-c[0], 0] : [180 - c[0], 180]);
          };
          var faces = octahedron$1.map(function(face) {
            return { face, project: faceProjection(face) };
          });
          [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function(d, i) {
            var node = faces[d];
            node && (node.children || (node.children = [])).push(faces[i]);
          });
          return polyhedral(faces[0], function(lambda, phi) {
            return faces[lambda < -pi / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < pi / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5];
          }).angle(-30).scale(121.906).center([0, 48.5904]);
        }
        function waterman(faceProjection) {
          faceProjection = faceProjection || function(face2) {
            var c = face2.length === 6 ? d3Geo.geoCentroid({ type: "MultiPoint", coordinates: face2 }) : face2[0];
            return d3Geo.geoGnomonic().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);
          };
          var w5 = octahedron$1.map(function(face2) {
            var xyz = face2.map(cartesian), n = xyz.length, a = xyz[n - 1], b, hexagon = [];
            for (var i = 0; i < n; ++i) {
              b = xyz[i];
              hexagon.push(spherical([
                a[0] * 0.9486832980505138 + b[0] * 0.31622776601683794,
                a[1] * 0.9486832980505138 + b[1] * 0.31622776601683794,
                a[2] * 0.9486832980505138 + b[2] * 0.31622776601683794
              ]), spherical([
                b[0] * 0.9486832980505138 + a[0] * 0.31622776601683794,
                b[1] * 0.9486832980505138 + a[1] * 0.31622776601683794,
                b[2] * 0.9486832980505138 + a[2] * 0.31622776601683794
              ]));
              a = b;
            }
            return hexagon;
          });
          var cornerNormals = [];
          var parents = [-1, 0, 0, 1, 0, 1, 4, 5];
          w5.forEach(function(hexagon, j) {
            var face2 = octahedron$1[j], n = face2.length, normals = cornerNormals[j] = [];
            for (var i = 0; i < n; ++i) {
              w5.push([
                face2[i],
                hexagon[(i * 2 + 2) % (2 * n)],
                hexagon[(i * 2 + 1) % (2 * n)]
              ]);
              parents.push(j);
              normals.push(cross(
                cartesian(hexagon[(i * 2 + 2) % (2 * n)]),
                cartesian(hexagon[(i * 2 + 1) % (2 * n)])
              ));
            }
          });
          var faces = w5.map(function(face2) {
            return {
              project: faceProjection(face2),
              face: face2
            };
          });
          parents.forEach(function(d, i) {
            var parent = faces[d];
            parent && (parent.children || (parent.children = [])).push(faces[i]);
          });
          function face(lambda, phi) {
            var cosphi = cos(phi), p = [cosphi * cos(lambda), cosphi * sin(lambda), sin(phi)];
            var hexagon = lambda < -pi / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < pi / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5;
            var n = cornerNormals[hexagon];
            return faces[dot(n[0], p) < 0 ? 8 + 3 * hexagon : dot(n[1], p) < 0 ? 8 + 3 * hexagon + 1 : dot(n[2], p) < 0 ? 8 + 3 * hexagon + 2 : hexagon];
          }
          return polyhedral(faces[0], face).angle(-30).scale(110.625).center([0, 45]);
        }
        function dot(a, b) {
          for (var i = 0, n = a.length, s = 0; i < n; ++i) s += a[i] * b[i];
          return s;
        }
        function cross(a, b) {
          return [
            a[1] * b[2] - a[2] * b[1],
            a[2] * b[0] - a[0] * b[2],
            a[0] * b[1] - a[1] * b[0]
          ];
        }
        function spherical(cartesian2) {
          return [
            atan2(cartesian2[1], cartesian2[0]) * degrees,
            asin(max(-1, min(1, cartesian2[2]))) * degrees
          ];
        }
        function cartesian(coordinates) {
          var lambda = coordinates[0] * radians, phi = coordinates[1] * radians, cosphi = cos(phi);
          return [
            cosphi * cos(lambda),
            cosphi * sin(lambda),
            sin(phi)
          ];
        }
        function noop() {
        }
        function clockwise(ring) {
          if ((n = ring.length) < 4) return false;
          var i = 0, n, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
          while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
          return area <= 0;
        }
        function contains(ring, point) {
          var x = point[0], y = point[1], contains2 = false;
          for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
            var pi2 = ring[i], xi = pi2[0], yi = pi2[1], pj = ring[j], xj = pj[0], yj = pj[1];
            if (yi > y ^ yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains2 = !contains2;
          }
          return contains2;
        }
        function index(object, projection) {
          var stream = projection.stream, project;
          if (!stream) throw new Error("invalid projection");
          switch (object && object.type) {
            case "Feature":
              project = projectFeature;
              break;
            case "FeatureCollection":
              project = projectFeatureCollection;
              break;
            default:
              project = projectGeometry;
              break;
          }
          return project(object, stream);
        }
        function projectFeatureCollection(o, stream) {
          return {
            type: "FeatureCollection",
            features: o.features.map(function(f) {
              return projectFeature(f, stream);
            })
          };
        }
        function projectFeature(o, stream) {
          return {
            type: "Feature",
            id: o.id,
            properties: o.properties,
            geometry: projectGeometry(o.geometry, stream)
          };
        }
        function projectGeometryCollection(o, stream) {
          return {
            type: "GeometryCollection",
            geometries: o.geometries.map(function(o2) {
              return projectGeometry(o2, stream);
            })
          };
        }
        function projectGeometry(o, stream) {
          if (!o) return null;
          if (o.type === "GeometryCollection") return projectGeometryCollection(o, stream);
          var sink;
          switch (o.type) {
            case "Point":
              sink = sinkPoint;
              break;
            case "MultiPoint":
              sink = sinkPoint;
              break;
            case "LineString":
              sink = sinkLine;
              break;
            case "MultiLineString":
              sink = sinkLine;
              break;
            case "Polygon":
              sink = sinkPolygon;
              break;
            case "MultiPolygon":
              sink = sinkPolygon;
              break;
            case "Sphere":
              sink = sinkPolygon;
              break;
            default:
              return null;
          }
          d3Geo.geoStream(o, stream(sink));
          return sink.result();
        }
        var points = [], lines = [];
        var sinkPoint = {
          point: function(x, y) {
            points.push([x, y]);
          },
          result: function() {
            var result = !points.length ? null : points.length < 2 ? { type: "Point", coordinates: points[0] } : { type: "MultiPoint", coordinates: points };
            points = [];
            return result;
          }
        };
        var sinkLine = {
          lineStart: noop,
          point: function(x, y) {
            points.push([x, y]);
          },
          lineEnd: function() {
            if (points.length) lines.push(points), points = [];
          },
          result: function() {
            var result = !lines.length ? null : lines.length < 2 ? { type: "LineString", coordinates: lines[0] } : { type: "MultiLineString", coordinates: lines };
            lines = [];
            return result;
          }
        };
        var sinkPolygon = {
          polygonStart: noop,
          lineStart: noop,
          point: function(x, y) {
            points.push([x, y]);
          },
          lineEnd: function() {
            var n = points.length;
            if (n) {
              do
                points.push(points[0].slice());
              while (++n < 4);
              lines.push(points), points = [];
            }
          },
          polygonEnd: noop,
          result: function() {
            if (!lines.length) return null;
            var polygons = [], holes = [];
            lines.forEach(function(ring) {
              if (clockwise(ring)) polygons.push([ring]);
              else holes.push(ring);
            });
            holes.forEach(function(hole) {
              var point = hole[0];
              polygons.some(function(polygon) {
                if (contains(polygon[0], point)) {
                  polygon.push(hole);
                  return true;
                }
              }) || polygons.push([hole]);
            });
            lines = [];
            return !polygons.length ? null : polygons.length > 1 ? { type: "MultiPolygon", coordinates: polygons } : { type: "Polygon", coordinates: polygons[0] };
          }
        };
        function quincuncial(project) {
          var dx = project(halfPi, 0)[0] - project(-halfPi, 0)[0];
          function projectQuincuncial(lambda, phi) {
            var t = abs(lambda) < halfPi, p = project(t ? lambda : lambda > 0 ? lambda - pi : lambda + pi, phi), x = (p[0] - p[1]) * sqrt1_2, y = (p[0] + p[1]) * sqrt1_2;
            if (t) return [x, y];
            var d = dx * sqrt1_2, s = x > 0 ^ y > 0 ? -1 : 1;
            return [s * x - sign(y) * d, s * y - sign(x) * d];
          }
          if (project.invert) projectQuincuncial.invert = function(x02, y02) {
            var x = (x02 + y02) * sqrt1_2, y = (y02 - x02) * sqrt1_2, t = abs(x) < 0.5 * dx && abs(y) < 0.5 * dx;
            if (!t) {
              var d = dx * sqrt1_2, s = x > 0 ^ y > 0 ? -1 : 1, x12 = -s * x02 + (y > 0 ? 1 : -1) * d, y12 = -s * y02 + (x > 0 ? 1 : -1) * d;
              x = (-x12 - y12) * sqrt1_2;
              y = (x12 - y12) * sqrt1_2;
            }
            var p = project.invert(x, y);
            if (!t) p[0] += x > 0 ? pi : -pi;
            return p;
          };
          return d3Geo.geoProjection(projectQuincuncial).rotate([-90, -90, 45]).clipAngle(180 - 1e-3);
        }
        function gringorten$1() {
          return quincuncial(gringortenRaw).scale(176.423);
        }
        function peirce() {
          return quincuncial(guyouRaw).scale(111.48);
        }
        function quantize(input, digits) {
          if (!(0 <= (digits = +digits) && digits <= 20)) throw new Error("invalid digits");
          function quantizePoint(input2) {
            var n = input2.length, i = 2, output2 = new Array(n);
            output2[0] = +input2[0].toFixed(digits);
            output2[1] = +input2[1].toFixed(digits);
            while (i < n) output2[i] = input2[i], ++i;
            return output2;
          }
          function quantizePoints(input2) {
            return input2.map(quantizePoint);
          }
          function quantizePointsNoDuplicates(input2) {
            var point0 = quantizePoint(input2[0]);
            var output2 = [point0];
            for (var i = 1; i < input2.length; i++) {
              var point = quantizePoint(input2[i]);
              if (point.length > 2 || point[0] != point0[0] || point[1] != point0[1]) {
                output2.push(point);
                point0 = point;
              }
            }
            if (output2.length === 1 && input2.length > 1) {
              output2.push(quantizePoint(input2[input2.length - 1]));
            }
            return output2;
          }
          function quantizePolygon(input2) {
            return input2.map(quantizePointsNoDuplicates);
          }
          function quantizeGeometry(input2) {
            if (input2 == null) return input2;
            var output2;
            switch (input2.type) {
              case "GeometryCollection":
                output2 = { type: "GeometryCollection", geometries: input2.geometries.map(quantizeGeometry) };
                break;
              case "Point":
                output2 = { type: "Point", coordinates: quantizePoint(input2.coordinates) };
                break;
              case "MultiPoint":
                output2 = { type: input2.type, coordinates: quantizePoints(input2.coordinates) };
                break;
              case "LineString":
                output2 = { type: input2.type, coordinates: quantizePointsNoDuplicates(input2.coordinates) };
                break;
              case "MultiLineString":
              case "Polygon":
                output2 = { type: input2.type, coordinates: quantizePolygon(input2.coordinates) };
                break;
              case "MultiPolygon":
                output2 = { type: "MultiPolygon", coordinates: input2.coordinates.map(quantizePolygon) };
                break;
              default:
                return input2;
            }
            if (input2.bbox != null) output2.bbox = input2.bbox;
            return output2;
          }
          function quantizeFeature(input2) {
            var output2 = { type: "Feature", properties: input2.properties, geometry: quantizeGeometry(input2.geometry) };
            if (input2.id != null) output2.id = input2.id;
            if (input2.bbox != null) output2.bbox = input2.bbox;
            return output2;
          }
          if (input != null) switch (input.type) {
            case "Feature":
              return quantizeFeature(input);
            case "FeatureCollection": {
              var output = { type: "FeatureCollection", features: input.features.map(quantizeFeature) };
              if (input.bbox != null) output.bbox = input.bbox;
              return output;
            }
            default:
              return quantizeGeometry(input);
          }
          return input;
        }
        function rectangularPolyconicRaw(phi02) {
          var sinPhi0 = sin(phi02);
          function forward(lambda, phi) {
            var A2 = sinPhi0 ? tan(lambda * sinPhi0 / 2) / sinPhi0 : lambda / 2;
            if (!phi) return [2 * A2, -phi02];
            var E = 2 * atan(A2 * sin(phi)), cotPhi = 1 / tan(phi);
            return [
              sin(E) * cotPhi,
              phi + (1 - cos(E)) * cotPhi - phi02
            ];
          }
          forward.invert = function(x, y) {
            if (abs(y += phi02) < epsilon) return [sinPhi0 ? 2 * atan(sinPhi0 * x / 2) / sinPhi0 : x, 0];
            var k2 = x * x + y * y, phi = 0, i = 10, delta;
            do {
              var tanPhi = tan(phi), secPhi = 1 / cos(phi), j = k2 - 2 * y * phi + phi * phi;
              phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi);
            } while (abs(delta) > epsilon && --i > 0);
            var E = x * (tanPhi = tan(phi)), A2 = tan(abs(y) < abs(phi + 1 / tanPhi) ? asin(E) * 0.5 : acos(E) * 0.5 + pi / 4) / sin(phi);
            return [
              sinPhi0 ? 2 * atan(sinPhi0 * A2) / sinPhi0 : 2 * A2,
              phi
            ];
          };
          return forward;
        }
        function rectangularPolyconic() {
          return parallel1(rectangularPolyconicRaw).scale(131.215);
        }
        var K$1 = [
          [0.9986, -0.062],
          [1, 0],
          [0.9986, 0.062],
          [0.9954, 0.124],
          [0.99, 0.186],
          [0.9822, 0.248],
          [0.973, 0.31],
          [0.96, 0.372],
          [0.9427, 0.434],
          [0.9216, 0.4958],
          [0.8962, 0.5571],
          [0.8679, 0.6176],
          [0.835, 0.6769],
          [0.7986, 0.7346],
          [0.7597, 0.7903],
          [0.7186, 0.8435],
          [0.6732, 0.8936],
          [0.6213, 0.9394],
          [0.5722, 0.9761],
          [0.5322, 1]
        ];
        K$1.forEach(function(d) {
          d[1] *= 1.0144;
        });
        function robinsonRaw(lambda, phi) {
          var i = min(18, abs(phi) * 36 / pi), i0 = floor(i), di = i - i0, ax = (k2 = K$1[i0])[0], ay = k2[1], bx = (k2 = K$1[++i0])[0], by = k2[1], cx = (k2 = K$1[min(19, ++i0)])[0], cy = k2[1], k2;
          return [
            lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
            (phi > 0 ? halfPi : -halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)
          ];
        }
        robinsonRaw.invert = function(x, y) {
          var yy = y / halfPi, phi = yy * 90, i = min(18, abs(phi / 5)), i0 = max(0, floor(i));
          do {
            var ay = K$1[i0][1], by = K$1[i0 + 1][1], cy = K$1[min(19, i0 + 2)][1], u = cy - ay, v = cy - 2 * by + ay, t = 2 * (abs(yy) - by) / u, c = v / u, di = t * (1 - c * t * (1 - 2 * c * t));
            if (di >= 0 || i0 === 1) {
              phi = (y >= 0 ? 5 : -5) * (di + i);
              var j = 50, delta;
              do {
                i = min(18, abs(phi) / 5);
                i0 = floor(i);
                di = i - i0;
                ay = K$1[i0][1];
                by = K$1[i0 + 1][1];
                cy = K$1[min(19, i0 + 2)][1];
                phi -= (delta = (y >= 0 ? halfPi : -halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * degrees;
              } while (abs(delta) > epsilon2 && --j > 0);
              break;
            }
          } while (--i0 >= 0);
          var ax = K$1[i0][0], bx = K$1[i0 + 1][0], cx = K$1[min(19, i0 + 2)][0];
          return [
            x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
            phi * radians
          ];
        };
        function robinson() {
          return d3Geo.geoProjection(robinsonRaw).scale(152.63);
        }
        function satelliteVerticalRaw(P) {
          function forward(lambda, phi) {
            var cosPhi = cos(phi), k2 = (P - 1) / (P - cosPhi * cos(lambda));
            return [
              k2 * cosPhi * sin(lambda),
              k2 * sin(phi)
            ];
          }
          forward.invert = function(x, y) {
            var rho2 = x * x + y * y, rho = sqrt(rho2), sinc = (P - sqrt(1 - rho2 * (P + 1) / (P - 1))) / ((P - 1) / rho + rho / (P - 1));
            return [
              atan2(x * sinc, rho * sqrt(1 - sinc * sinc)),
              rho ? asin(y * sinc / rho) : 0
            ];
          };
          return forward;
        }
        function satelliteRaw(P, omega) {
          var vertical = satelliteVerticalRaw(P);
          if (!omega) return vertical;
          var cosOmega = cos(omega), sinOmega = sin(omega);
          function forward(lambda, phi) {
            var coordinates = vertical(lambda, phi), y = coordinates[1], A2 = y * sinOmega / (P - 1) + cosOmega;
            return [
              coordinates[0] * cosOmega / A2,
              y / A2
            ];
          }
          forward.invert = function(x, y) {
            var k2 = (P - 1) / (P - 1 - y * sinOmega);
            return vertical.invert(k2 * x, k2 * y * cosOmega);
          };
          return forward;
        }
        function satellite() {
          var distance2 = 2, omega = 0, m = d3Geo.geoProjectionMutator(satelliteRaw), p = m(distance2, omega);
          p.distance = function(_) {
            if (!arguments.length) return distance2;
            return m(distance2 = +_, omega);
          };
          p.tilt = function(_) {
            if (!arguments.length) return omega * degrees;
            return m(distance2, omega = _ * radians);
          };
          return p.scale(432.147).clipAngle(acos(1 / distance2) * degrees - 1e-6);
        }
        var epsilon$1 = 1e-4, epsilonInverse = 1e4, x0 = -180, x0e = x0 + epsilon$1, x1 = 180, x1e = x1 - epsilon$1, y0 = -90, y0e = y0 + epsilon$1, y1 = 90, y1e = y1 - epsilon$1;
        function nonempty(coordinates) {
          return coordinates.length > 0;
        }
        function quantize$1(x) {
          return Math.floor(x * epsilonInverse) / epsilonInverse;
        }
        function normalizePoint(y) {
          return y === y0 || y === y1 ? [0, y] : [x0, quantize$1(y)];
        }
        function clampPoint(p) {
          var x = p[0], y = p[1], clamped = false;
          if (x <= x0e) x = x0, clamped = true;
          else if (x >= x1e) x = x1, clamped = true;
          if (y <= y0e) y = y0, clamped = true;
          else if (y >= y1e) y = y1, clamped = true;
          return clamped ? [x, y] : p;
        }
        function clampPoints(points2) {
          return points2.map(clampPoint);
        }
        function extractFragments(rings, polygon, fragments) {
          for (var j = 0, m = rings.length; j < m; ++j) {
            var ring = rings[j].slice();
            fragments.push({ index: -1, polygon, ring });
            for (var i = 0, n = ring.length; i < n; ++i) {
              var point = ring[i], x = point[0], y = point[1];
              if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {
                ring[i] = clampPoint(point);
                for (var k2 = i + 1; k2 < n; ++k2) {
                  var pointk = ring[k2], xk = pointk[0], yk = pointk[1];
                  if (xk > x0e && xk < x1e && yk > y0e && yk < y1e) break;
                }
                if (k2 === i + 1) continue;
                if (i) {
                  var fragmentBefore = { index: -1, polygon, ring: ring.slice(0, i + 1) };
                  fragmentBefore.ring[fragmentBefore.ring.length - 1] = normalizePoint(y);
                  fragments[fragments.length - 1] = fragmentBefore;
                } else fragments.pop();
                if (k2 >= n) break;
                fragments.push({ index: -1, polygon, ring: ring = ring.slice(k2 - 1) });
                ring[0] = normalizePoint(ring[0][1]);
                i = -1;
                n = ring.length;
              }
            }
          }
        }
        function stitchFragments(fragments) {
          var i, n = fragments.length;
          var fragmentByStart = {}, fragmentByEnd = {}, fragment, start, startFragment, end, endFragment;
          for (i = 0; i < n; ++i) {
            fragment = fragments[i];
            start = fragment.ring[0];
            end = fragment.ring[fragment.ring.length - 1];
            if (start[0] === end[0] && start[1] === end[1]) {
              fragment.polygon.push(fragment.ring);
              fragments[i] = null;
              continue;
            }
            fragment.index = i;
            fragmentByStart[start] = fragmentByEnd[end] = fragment;
          }
          for (i = 0; i < n; ++i) {
            fragment = fragments[i];
            if (fragment) {
              start = fragment.ring[0];
              end = fragment.ring[fragment.ring.length - 1];
              startFragment = fragmentByEnd[start];
              endFragment = fragmentByStart[end];
              delete fragmentByStart[start];
              delete fragmentByEnd[end];
              if (start[0] === end[0] && start[1] === end[1]) {
                fragment.polygon.push(fragment.ring);
                continue;
              }
              if (startFragment) {
                delete fragmentByEnd[start];
                delete fragmentByStart[startFragment.ring[0]];
                startFragment.ring.pop();
                fragments[startFragment.index] = null;
                fragment = { index: -1, polygon: startFragment.polygon, ring: startFragment.ring.concat(fragment.ring) };
                if (startFragment === endFragment) {
                  fragment.polygon.push(fragment.ring);
                } else {
                  fragment.index = n++;
                  fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);
                }
              } else if (endFragment) {
                delete fragmentByStart[end];
                delete fragmentByEnd[endFragment.ring[endFragment.ring.length - 1]];
                fragment.ring.pop();
                fragment = { index: n++, polygon: endFragment.polygon, ring: fragment.ring.concat(endFragment.ring) };
                fragments[endFragment.index] = null;
                fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);
              } else {
                fragment.ring.push(fragment.ring[0]);
                fragment.polygon.push(fragment.ring);
              }
            }
          }
        }
        function stitchFeature(input) {
          var output = { type: "Feature", geometry: stitchGeometry(input.geometry) };
          if (input.id != null) output.id = input.id;
          if (input.bbox != null) output.bbox = input.bbox;
          if (input.properties != null) output.properties = input.properties;
          return output;
        }
        function stitchGeometry(input) {
          if (input == null) return input;
          var output, fragments, i, n;
          switch (input.type) {
            case "GeometryCollection":
              output = { type: "GeometryCollection", geometries: input.geometries.map(stitchGeometry) };
              break;
            case "Point":
              output = { type: "Point", coordinates: clampPoint(input.coordinates) };
              break;
            case "MultiPoint":
            case "LineString":
              output = { type: input.type, coordinates: clampPoints(input.coordinates) };
              break;
            case "MultiLineString":
              output = { type: "MultiLineString", coordinates: input.coordinates.map(clampPoints) };
              break;
            case "Polygon": {
              var polygon = [];
              extractFragments(input.coordinates, polygon, fragments = []);
              stitchFragments(fragments);
              output = { type: "Polygon", coordinates: polygon };
              break;
            }
            case "MultiPolygon": {
              fragments = [], i = -1, n = input.coordinates.length;
              var polygons = new Array(n);
              while (++i < n) extractFragments(input.coordinates[i], polygons[i] = [], fragments);
              stitchFragments(fragments);
              output = { type: "MultiPolygon", coordinates: polygons.filter(nonempty) };
              break;
            }
            default:
              return input;
          }
          if (input.bbox != null) output.bbox = input.bbox;
          return output;
        }
        function stitch(input) {
          if (input == null) return input;
          switch (input.type) {
            case "Feature":
              return stitchFeature(input);
            case "FeatureCollection": {
              var output = { type: "FeatureCollection", features: input.features.map(stitchFeature) };
              if (input.bbox != null) output.bbox = input.bbox;
              return output;
            }
            default:
              return stitchGeometry(input);
          }
        }
        function timesRaw(lambda, phi) {
          var t = tan(phi / 2), s = sin(quarterPi * t);
          return [
            lambda * (0.74482 - 0.34588 * s * s),
            1.70711 * t
          ];
        }
        timesRaw.invert = function(x, y) {
          var t = y / 1.70711, s = sin(quarterPi * t);
          return [
            x / (0.74482 - 0.34588 * s * s),
            2 * atan(t)
          ];
        };
        function times() {
          return d3Geo.geoProjection(timesRaw).scale(146.153);
        }
        function twoPoint(raw, p0, p1) {
          var i = d3Geo.geoInterpolate(p0, p1), o = i(0.5), a = d3Geo.geoRotation([-o[0], -o[1]])(p0), b = i.distance / 2, y = -asin(sin(a[1] * radians) / sin(b)), R = [-o[0], -o[1], -(a[0] > 0 ? pi - y : y) * degrees], p = d3Geo.geoProjection(raw(b)).rotate(R), r = d3Geo.geoRotation(R), center = p.center;
          delete p.rotate;
          p.center = function(_) {
            return arguments.length ? center(r(_)) : r.invert(center());
          };
          return p.clipAngle(90);
        }
        function twoPointAzimuthalRaw(d) {
          var cosd = cos(d);
          function forward(lambda, phi) {
            var coordinates = d3Geo.geoGnomonicRaw(lambda, phi);
            coordinates[0] *= cosd;
            return coordinates;
          }
          forward.invert = function(x, y) {
            return d3Geo.geoGnomonicRaw.invert(x / cosd, y);
          };
          return forward;
        }
        function twoPointAzimuthalUsa() {
          return twoPointAzimuthal([-158, 21.5], [-77, 39]).clipAngle(60).scale(400);
        }
        function twoPointAzimuthal(p0, p1) {
          return twoPoint(twoPointAzimuthalRaw, p0, p1);
        }
        function twoPointEquidistantRaw(z0) {
          if (!(z0 *= 2)) return d3Geo.geoAzimuthalEquidistantRaw;
          var lambdaa = -z0 / 2, lambdab = -lambdaa, z02 = z0 * z0, tanLambda0 = tan(lambdab), S = 0.5 / sin(lambdab);
          function forward(lambda, phi) {
            var za = acos(cos(phi) * cos(lambda - lambdaa)), zb = acos(cos(phi) * cos(lambda - lambdab)), ys = phi < 0 ? -1 : 1;
            za *= za, zb *= zb;
            return [
              (za - zb) / (2 * z0),
              ys * sqrt(4 * z02 * zb - (z02 - za + zb) * (z02 - za + zb)) / (2 * z0)
            ];
          }
          forward.invert = function(x, y) {
            var y2 = y * y, cosza = cos(sqrt(y2 + (t = x + lambdaa) * t)), coszb = cos(sqrt(y2 + (t = x + lambdab) * t)), t, d;
            return [
              atan2(d = cosza - coszb, t = (cosza + coszb) * tanLambda0),
              (y < 0 ? -1 : 1) * acos(sqrt(t * t + d * d) * S)
            ];
          };
          return forward;
        }
        function twoPointEquidistantUsa() {
          return twoPointEquidistant([-158, 21.5], [-77, 39]).clipAngle(130).scale(122.571);
        }
        function twoPointEquidistant(p0, p1) {
          return twoPoint(twoPointEquidistantRaw, p0, p1);
        }
        function vanDerGrintenRaw(lambda, phi) {
          if (abs(phi) < epsilon) return [lambda, 0];
          var sinTheta = abs(phi / halfPi), theta = asin(sinTheta);
          if (abs(lambda) < epsilon || abs(abs(phi) - halfPi) < epsilon) return [0, sign(phi) * pi * tan(theta / 2)];
          var cosTheta = cos(theta), A2 = abs(pi / lambda - lambda / pi) / 2, A22 = A2 * A2, G = cosTheta / (sinTheta + cosTheta - 1), P = G * (2 / sinTheta - 1), P2 = P * P, P2_A2 = P2 + A22, G_P2 = G - P2, Q = A22 + G;
          return [
            sign(lambda) * pi * (A2 * G_P2 + sqrt(A22 * G_P2 * G_P2 - P2_A2 * (G * G - P2))) / P2_A2,
            sign(phi) * pi * (P * Q - A2 * sqrt((A22 + 1) * P2_A2 - Q * Q)) / P2_A2
          ];
        }
        vanDerGrintenRaw.invert = function(x, y) {
          if (abs(y) < epsilon) return [x, 0];
          if (abs(x) < epsilon) return [0, halfPi * sin(2 * atan(y / pi))];
          var x2 = (x /= pi) * x, y2 = (y /= pi) * y, x2_y2 = x2 + y2, z = x2_y2 * x2_y2, c1 = -abs(y) * (1 + x2_y2), c2 = c1 - 2 * y2 + x2, c3 = -2 * c1 + 1 + 2 * y2 + z, d = y2 / c3 + (2 * c2 * c2 * c2 / (c3 * c3 * c3) - 9 * c1 * c2 / (c3 * c3)) / 27, a1 = (c1 - c2 * c2 / (3 * c3)) / c3, m1 = 2 * sqrt(-a1 / 3), theta1 = acos(3 * d / (a1 * m1)) / 3;
          return [
            pi * (x2_y2 - 1 + sqrt(1 + 2 * (x2 - y2) + z)) / (2 * x),
            sign(y) * pi * (-m1 * cos(theta1 + pi / 3) - c2 / (3 * c3))
          ];
        };
        function vanDerGrinten() {
          return d3Geo.geoProjection(vanDerGrintenRaw).scale(79.4183);
        }
        function vanDerGrinten2Raw(lambda, phi) {
          if (abs(phi) < epsilon) return [lambda, 0];
          var sinTheta = abs(phi / halfPi), theta = asin(sinTheta);
          if (abs(lambda) < epsilon || abs(abs(phi) - halfPi) < epsilon) return [0, sign(phi) * pi * tan(theta / 2)];
          var cosTheta = cos(theta), A2 = abs(pi / lambda - lambda / pi) / 2, A22 = A2 * A2, x12 = cosTheta * (sqrt(1 + A22) - A2 * cosTheta) / (1 + A22 * sinTheta * sinTheta);
          return [
            sign(lambda) * pi * x12,
            sign(phi) * pi * sqrt(1 - x12 * (2 * A2 + x12))
          ];
        }
        vanDerGrinten2Raw.invert = function(x, y) {
          if (!x) return [0, halfPi * sin(2 * atan(y / pi))];
          var x12 = abs(x / pi), A2 = (1 - x12 * x12 - (y /= pi) * y) / (2 * x12), A22 = A2 * A2, B2 = sqrt(A22 + 1);
          return [
            sign(x) * pi * (B2 - A2),
            sign(y) * halfPi * sin(2 * atan2(sqrt((1 - 2 * A2 * x12) * (A2 + B2) - x12), sqrt(B2 + A2 + x12)))
          ];
        };
        function vanDerGrinten2() {
          return d3Geo.geoProjection(vanDerGrinten2Raw).scale(79.4183);
        }
        function vanDerGrinten3Raw(lambda, phi) {
          if (abs(phi) < epsilon) return [lambda, 0];
          var sinTheta = phi / halfPi, theta = asin(sinTheta);
          if (abs(lambda) < epsilon || abs(abs(phi) - halfPi) < epsilon) return [0, pi * tan(theta / 2)];
          var A2 = (pi / lambda - lambda / pi) / 2, y12 = sinTheta / (1 + cos(theta));
          return [
            pi * (sign(lambda) * sqrt(A2 * A2 + 1 - y12 * y12) - A2),
            pi * y12
          ];
        }
        vanDerGrinten3Raw.invert = function(x, y) {
          if (!y) return [x, 0];
          var y12 = y / pi, A2 = (pi * pi * (1 - y12 * y12) - x * x) / (2 * pi * x);
          return [
            x ? pi * (sign(x) * sqrt(A2 * A2 + 1) - A2) : 0,
            halfPi * sin(2 * atan(y12))
          ];
        };
        function vanDerGrinten3() {
          return d3Geo.geoProjection(vanDerGrinten3Raw).scale(79.4183);
        }
        function vanDerGrinten4Raw(lambda, phi) {
          if (!phi) return [lambda, 0];
          var phi02 = abs(phi);
          if (!lambda || phi02 === halfPi) return [0, phi];
          var B2 = phi02 / halfPi, B22 = B2 * B2, C = (8 * B2 - B22 * (B22 + 2) - 5) / (2 * B22 * (B2 - 1)), C2 = C * C, BC = B2 * C, B_C2 = B22 + C2 + 2 * BC, B_3C = B2 + 3 * C, lambda0 = lambda / halfPi, lambda1 = lambda0 + 1 / lambda0, D = sign(abs(lambda) - halfPi) * sqrt(lambda1 * lambda1 - 4), D2 = D * D, F = B_C2 * (B22 + C2 * D2 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C2) + 12 * BC * C2 + 4 * C2 * C2), x12 = (D * (B_C2 + C2 - 1) + 2 * sqrt(F)) / (4 * B_C2 + D2);
          return [
            sign(lambda) * halfPi * x12,
            sign(phi) * halfPi * sqrt(1 + D * abs(x12) - x12 * x12)
          ];
        }
        vanDerGrinten4Raw.invert = function(x, y) {
          var delta;
          if (!x || !y) return [x, y];
          y /= pi;
          var x12 = sign(x) * x / halfPi, D = (x12 * x12 - 1 + 4 * y * y) / abs(x12), D2 = D * D, B2 = 2 * y, i = 50;
          do {
            var B22 = B2 * B2, C = (8 * B2 - B22 * (B22 + 2) - 5) / (2 * B22 * (B2 - 1)), C_ = (3 * B2 - B22 * B2 - 10) / (2 * B22 * B2), C2 = C * C, BC = B2 * C, B_C = B2 + C, B_C2 = B_C * B_C, B_3C = B2 + 3 * C, F = B_C2 * (B22 + C2 * D2 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C2) + C2 * (12 * BC + 4 * C2)), F_ = -2 * B_C * (4 * BC * C2 + (1 - 4 * B22 + 3 * B22 * B22) * (1 + C_) + C2 * (-6 + 14 * B22 - D2 + (-8 + 8 * B22 - 2 * D2) * C_) + BC * (-8 + 12 * B22 + (-10 + 10 * B22 - D2) * C_)), sqrtF = sqrt(F), f = D * (B_C2 + C2 - 1) + 2 * sqrtF - x12 * (4 * B_C2 + D2), f_ = D * (2 * C * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D * (-1 + C2 + B_C2) + 2 * sqrtF) * (1 + C_) / (D2 + 4 * B_C2);
            B2 -= delta = f / f_;
          } while (delta > epsilon && --i > 0);
          return [
            sign(x) * (sqrt(D * D + 4) + D) * pi / 4,
            halfPi * B2
          ];
        };
        function vanDerGrinten4() {
          return d3Geo.geoProjection(vanDerGrinten4Raw).scale(127.16);
        }
        function wagnerFormula(cx, cy, m1, m2, n) {
          function forward(lambda, phi) {
            var s = m1 * sin(m2 * phi), c0 = sqrt(1 - s * s), c1 = sqrt(2 / (1 + c0 * cos(lambda *= n)));
            return [
              cx * c0 * c1 * sin(lambda),
              cy * s * c1
            ];
          }
          forward.invert = function(x, y) {
            var t1 = x / cx, t2 = y / cy, p = sqrt(t1 * t1 + t2 * t2), c = 2 * asin(p / 2);
            return [
              atan2(x * tan(c), cx * p) / n,
              p && asin(y * sin(c) / (cy * m1 * p)) / m2
            ];
          };
          return forward;
        }
        function wagnerRaw(poleline, parallels, inflation, ratio) {
          var phi1 = pi / 3;
          poleline = max(poleline, epsilon);
          parallels = max(parallels, epsilon);
          poleline = min(poleline, halfPi);
          parallels = min(parallels, pi - epsilon);
          inflation = max(inflation, 0);
          inflation = min(inflation, 100 - epsilon);
          ratio = max(ratio, epsilon);
          var vinflation = inflation / 100 + 1;
          var vratio = ratio / 100;
          var m2 = acos(vinflation * cos(phi1)) / phi1, m1 = sin(poleline) / sin(m2 * halfPi), n = parallels / pi, k2 = sqrt(vratio * sin(poleline / 2) / sin(parallels / 2)), cx = k2 / sqrt(n * m1 * m2), cy = 1 / (k2 * sqrt(n * m1 * m2));
          return wagnerFormula(cx, cy, m1, m2, n);
        }
        function wagner() {
          var poleline = 65 * radians, parallels = 60 * radians, inflation = 20, ratio = 200, mutate = d3Geo.geoProjectionMutator(wagnerRaw), projection = mutate(poleline, parallels, inflation, ratio);
          projection.poleline = function(_) {
            return arguments.length ? mutate(poleline = +_ * radians, parallels, inflation, ratio) : poleline * degrees;
          };
          projection.parallels = function(_) {
            return arguments.length ? mutate(poleline, parallels = +_ * radians, inflation, ratio) : parallels * degrees;
          };
          projection.inflation = function(_) {
            return arguments.length ? mutate(poleline, parallels, inflation = +_, ratio) : inflation;
          };
          projection.ratio = function(_) {
            return arguments.length ? mutate(poleline, parallels, inflation, ratio = +_) : ratio;
          };
          return projection.scale(163.775);
        }
        function wagner7() {
          return wagner().poleline(65).parallels(60).inflation(0).ratio(200).scale(172.633);
        }
        var A = 4 * pi + 3 * sqrt(3), B = 2 * sqrt(2 * pi * sqrt(3) / A);
        var wagner4Raw = mollweideBromleyRaw(B * sqrt(3) / pi, B, A / 6);
        function wagner4() {
          return d3Geo.geoProjection(wagner4Raw).scale(176.84);
        }
        function wagner6Raw(lambda, phi) {
          return [lambda * sqrt(1 - 3 * phi * phi / (pi * pi)), phi];
        }
        wagner6Raw.invert = function(x, y) {
          return [x / sqrt(1 - 3 * y * y / (pi * pi)), y];
        };
        function wagner6() {
          return d3Geo.geoProjection(wagner6Raw).scale(152.63);
        }
        function wiechelRaw(lambda, phi) {
          var cosPhi = cos(phi), sinPhi = cos(lambda) * cosPhi, sin1_Phi = 1 - sinPhi, cosLambda = cos(lambda = atan2(sin(lambda) * cosPhi, -sin(phi))), sinLambda = sin(lambda);
          cosPhi = sqrt(1 - sinPhi * sinPhi);
          return [
            sinLambda * cosPhi - cosLambda * sin1_Phi,
            -cosLambda * cosPhi - sinLambda * sin1_Phi
          ];
        }
        wiechelRaw.invert = function(x, y) {
          var w2 = (x * x + y * y) / -2, k2 = sqrt(-w2 * (2 + w2)), b = y * w2 + x * k2, a = x * w2 - y * k2, D = sqrt(a * a + b * b);
          return [
            atan2(k2 * b, D * (1 + w2)),
            D ? -asin(k2 * a / D) : 0
          ];
        };
        function wiechel() {
          return d3Geo.geoProjection(wiechelRaw).rotate([0, -90, 45]).scale(124.75).clipAngle(180 - 1e-3);
        }
        function winkel3Raw(lambda, phi) {
          var coordinates = aitoffRaw(lambda, phi);
          return [
            (coordinates[0] + lambda / halfPi) / 2,
            (coordinates[1] + phi) / 2
          ];
        }
        winkel3Raw.invert = function(x, y) {
          var lambda = x, phi = y, i = 25;
          do {
            var cosphi = cos(phi), sinphi = sin(phi), sin_2phi = sin(2 * phi), sin2phi = sinphi * sinphi, cos2phi = cosphi * cosphi, sinlambda = sin(lambda), coslambda_2 = cos(lambda / 2), sinlambda_2 = sin(lambda / 2), sin2lambda_2 = sinlambda_2 * sinlambda_2, C = 1 - cos2phi * coslambda_2 * coslambda_2, E = C ? acos(cosphi * coslambda_2) * sqrt(F = 1 / C) : F = 0, F, fx = 0.5 * (2 * E * cosphi * sinlambda_2 + lambda / halfPi) - x, fy = 0.5 * (E * sinphi + phi) - y, dxdlambda = 0.5 * F * (cos2phi * sin2lambda_2 + E * cosphi * coslambda_2 * sin2phi) + 0.5 / halfPi, dxdphi = F * (sinlambda * sin_2phi / 4 - E * sinphi * sinlambda_2), dydlambda = 0.125 * F * (sin_2phi * sinlambda_2 - E * sinphi * cos2phi * sinlambda), dydphi = 0.5 * F * (sin2phi * coslambda_2 + E * sin2lambda_2 * cosphi) + 0.5, denominator = dxdphi * dydlambda - dydphi * dxdlambda, dlambda = (fy * dxdphi - fx * dydphi) / denominator, dphi = (fx * dydlambda - fy * dxdlambda) / denominator;
            lambda -= dlambda, phi -= dphi;
          } while ((abs(dlambda) > epsilon || abs(dphi) > epsilon) && --i > 0);
          return [lambda, phi];
        };
        function winkel3() {
          return d3Geo.geoProjection(winkel3Raw).scale(158.837);
        }
        exports2.geoNaturalEarth = d3Geo.geoNaturalEarth1;
        exports2.geoNaturalEarthRaw = d3Geo.geoNaturalEarth1Raw;
        exports2.geoAiry = airy;
        exports2.geoAiryRaw = airyRaw;
        exports2.geoAitoff = aitoff;
        exports2.geoAitoffRaw = aitoffRaw;
        exports2.geoArmadillo = armadillo;
        exports2.geoArmadilloRaw = armadilloRaw;
        exports2.geoAugust = august;
        exports2.geoAugustRaw = augustRaw;
        exports2.geoBaker = baker;
        exports2.geoBakerRaw = bakerRaw;
        exports2.geoBerghaus = berghaus;
        exports2.geoBerghausRaw = berghausRaw;
        exports2.geoBertin1953 = bertin;
        exports2.geoBertin1953Raw = bertin1953Raw;
        exports2.geoBoggs = boggs;
        exports2.geoBoggsRaw = boggsRaw;
        exports2.geoBonne = bonne;
        exports2.geoBonneRaw = bonneRaw;
        exports2.geoBottomley = bottomley;
        exports2.geoBottomleyRaw = bottomleyRaw;
        exports2.geoBromley = bromley;
        exports2.geoBromleyRaw = bromleyRaw;
        exports2.geoChamberlin = chamberlin;
        exports2.geoChamberlinRaw = chamberlinRaw;
        exports2.geoChamberlinAfrica = chamberlinAfrica;
        exports2.geoCollignon = collignon;
        exports2.geoCollignonRaw = collignonRaw;
        exports2.geoCraig = craig;
        exports2.geoCraigRaw = craigRaw;
        exports2.geoCraster = craster;
        exports2.geoCrasterRaw = crasterRaw;
        exports2.geoCylindricalEqualArea = cylindricalEqualArea;
        exports2.geoCylindricalEqualAreaRaw = cylindricalEqualAreaRaw;
        exports2.geoCylindricalStereographic = cylindricalStereographic;
        exports2.geoCylindricalStereographicRaw = cylindricalStereographicRaw;
        exports2.geoEckert1 = eckert1;
        exports2.geoEckert1Raw = eckert1Raw;
        exports2.geoEckert2 = eckert2;
        exports2.geoEckert2Raw = eckert2Raw;
        exports2.geoEckert3 = eckert3;
        exports2.geoEckert3Raw = eckert3Raw;
        exports2.geoEckert4 = eckert4;
        exports2.geoEckert4Raw = eckert4Raw;
        exports2.geoEckert5 = eckert5;
        exports2.geoEckert5Raw = eckert5Raw;
        exports2.geoEckert6 = eckert6;
        exports2.geoEckert6Raw = eckert6Raw;
        exports2.geoEisenlohr = eisenlohr;
        exports2.geoEisenlohrRaw = eisenlohrRaw;
        exports2.geoFahey = fahey;
        exports2.geoFaheyRaw = faheyRaw;
        exports2.geoFoucaut = foucaut;
        exports2.geoFoucautRaw = foucautRaw;
        exports2.geoFoucautSinusoidal = foucautSinusoidal;
        exports2.geoFoucautSinusoidalRaw = foucautSinusoidalRaw;
        exports2.geoGilbert = gilbert;
        exports2.geoGingery = gingery;
        exports2.geoGingeryRaw = gingeryRaw;
        exports2.geoGinzburg4 = ginzburg4;
        exports2.geoGinzburg4Raw = ginzburg4Raw;
        exports2.geoGinzburg5 = ginzburg5;
        exports2.geoGinzburg5Raw = ginzburg5Raw;
        exports2.geoGinzburg6 = ginzburg6;
        exports2.geoGinzburg6Raw = ginzburg6Raw;
        exports2.geoGinzburg8 = ginzburg8;
        exports2.geoGinzburg8Raw = ginzburg8Raw;
        exports2.geoGinzburg9 = ginzburg9;
        exports2.geoGinzburg9Raw = ginzburg9Raw;
        exports2.geoGringorten = gringorten;
        exports2.geoGringortenRaw = gringortenRaw;
        exports2.geoGuyou = guyou;
        exports2.geoGuyouRaw = guyouRaw;
        exports2.geoHammer = hammer;
        exports2.geoHammerRaw = hammerRaw;
        exports2.geoHammerRetroazimuthal = hammerRetroazimuthal;
        exports2.geoHammerRetroazimuthalRaw = hammerRetroazimuthalRaw;
        exports2.geoHealpix = healpix;
        exports2.geoHealpixRaw = healpixRaw;
        exports2.geoHill = hill;
        exports2.geoHillRaw = hillRaw;
        exports2.geoHomolosine = homolosine;
        exports2.geoHomolosineRaw = homolosineRaw;
        exports2.geoHufnagel = hufnagel;
        exports2.geoHufnagelRaw = hufnagelRaw;
        exports2.geoHyperelliptical = hyperelliptical;
        exports2.geoHyperellipticalRaw = hyperellipticalRaw;
        exports2.geoInterrupt = interrupt;
        exports2.geoInterruptedBoggs = boggs$1;
        exports2.geoInterruptedHomolosine = homolosine$1;
        exports2.geoInterruptedMollweide = mollweide$1;
        exports2.geoInterruptedMollweideHemispheres = mollweideHemispheres;
        exports2.geoInterruptedSinuMollweide = sinuMollweide$1;
        exports2.geoInterruptedSinusoidal = sinusoidal$1;
        exports2.geoKavrayskiy7 = kavrayskiy7;
        exports2.geoKavrayskiy7Raw = kavrayskiy7Raw;
        exports2.geoLagrange = lagrange;
        exports2.geoLagrangeRaw = lagrangeRaw;
        exports2.geoLarrivee = larrivee;
        exports2.geoLarriveeRaw = larriveeRaw;
        exports2.geoLaskowski = laskowski;
        exports2.geoLaskowskiRaw = laskowskiRaw;
        exports2.geoLittrow = littrow;
        exports2.geoLittrowRaw = littrowRaw;
        exports2.geoLoximuthal = loximuthal;
        exports2.geoLoximuthalRaw = loximuthalRaw;
        exports2.geoMiller = miller;
        exports2.geoMillerRaw = millerRaw;
        exports2.geoModifiedStereographic = modifiedStereographic;
        exports2.geoModifiedStereographicRaw = modifiedStereographicRaw;
        exports2.geoModifiedStereographicAlaska = modifiedStereographicAlaska;
        exports2.geoModifiedStereographicGs48 = modifiedStereographicGs48;
        exports2.geoModifiedStereographicGs50 = modifiedStereographicGs50;
        exports2.geoModifiedStereographicMiller = modifiedStereographicMiller;
        exports2.geoModifiedStereographicLee = modifiedStereographicLee;
        exports2.geoMollweide = mollweide;
        exports2.geoMollweideRaw = mollweideRaw;
        exports2.geoMtFlatPolarParabolic = mtFlatPolarParabolic;
        exports2.geoMtFlatPolarParabolicRaw = mtFlatPolarParabolicRaw;
        exports2.geoMtFlatPolarQuartic = mtFlatPolarQuartic;
        exports2.geoMtFlatPolarQuarticRaw = mtFlatPolarQuarticRaw;
        exports2.geoMtFlatPolarSinusoidal = mtFlatPolarSinusoidal;
        exports2.geoMtFlatPolarSinusoidalRaw = mtFlatPolarSinusoidalRaw;
        exports2.geoNaturalEarth2 = naturalEarth2;
        exports2.geoNaturalEarth2Raw = naturalEarth2Raw;
        exports2.geoNellHammer = nellHammer;
        exports2.geoNellHammerRaw = nellHammerRaw;
        exports2.geoInterruptedQuarticAuthalic = quarticAuthalic;
        exports2.geoNicolosi = nicolosi;
        exports2.geoNicolosiRaw = nicolosiRaw;
        exports2.geoPatterson = patterson;
        exports2.geoPattersonRaw = pattersonRaw;
        exports2.geoPolyconic = polyconic;
        exports2.geoPolyconicRaw = polyconicRaw;
        exports2.geoPolyhedral = polyhedral;
        exports2.geoPolyhedralButterfly = butterfly;
        exports2.geoPolyhedralCollignon = collignon$1;
        exports2.geoPolyhedralWaterman = waterman;
        exports2.geoProject = index;
        exports2.geoGringortenQuincuncial = gringorten$1;
        exports2.geoPeirceQuincuncial = peirce;
        exports2.geoPierceQuincuncial = peirce;
        exports2.geoQuantize = quantize;
        exports2.geoQuincuncial = quincuncial;
        exports2.geoRectangularPolyconic = rectangularPolyconic;
        exports2.geoRectangularPolyconicRaw = rectangularPolyconicRaw;
        exports2.geoRobinson = robinson;
        exports2.geoRobinsonRaw = robinsonRaw;
        exports2.geoSatellite = satellite;
        exports2.geoSatelliteRaw = satelliteRaw;
        exports2.geoSinuMollweide = sinuMollweide;
        exports2.geoSinuMollweideRaw = sinuMollweideRaw;
        exports2.geoSinusoidal = sinusoidal;
        exports2.geoSinusoidalRaw = sinusoidalRaw;
        exports2.geoStitch = stitch;
        exports2.geoTimes = times;
        exports2.geoTimesRaw = timesRaw;
        exports2.geoTwoPointAzimuthal = twoPointAzimuthal;
        exports2.geoTwoPointAzimuthalRaw = twoPointAzimuthalRaw;
        exports2.geoTwoPointAzimuthalUsa = twoPointAzimuthalUsa;
        exports2.geoTwoPointEquidistant = twoPointEquidistant;
        exports2.geoTwoPointEquidistantRaw = twoPointEquidistantRaw;
        exports2.geoTwoPointEquidistantUsa = twoPointEquidistantUsa;
        exports2.geoVanDerGrinten = vanDerGrinten;
        exports2.geoVanDerGrintenRaw = vanDerGrintenRaw;
        exports2.geoVanDerGrinten2 = vanDerGrinten2;
        exports2.geoVanDerGrinten2Raw = vanDerGrinten2Raw;
        exports2.geoVanDerGrinten3 = vanDerGrinten3;
        exports2.geoVanDerGrinten3Raw = vanDerGrinten3Raw;
        exports2.geoVanDerGrinten4 = vanDerGrinten4;
        exports2.geoVanDerGrinten4Raw = vanDerGrinten4Raw;
        exports2.geoWagner = wagner;
        exports2.geoWagner7 = wagner7;
        exports2.geoWagnerRaw = wagnerRaw;
        exports2.geoWagner4 = wagner4;
        exports2.geoWagner4Raw = wagner4Raw;
        exports2.geoWagner6 = wagner6;
        exports2.geoWagner6Raw = wagner6Raw;
        exports2.geoWiechel = wiechel;
        exports2.geoWiechelRaw = wiechelRaw;
        exports2.geoWinkel3 = winkel3;
        exports2.geoWinkel3Raw = winkel3Raw;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // src/plots/geo/zoom.js
  var require_zoom = __commonJS({
    "src/plots/geo/zoom.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var Registry = require_registry();
      var radians = Math.PI / 180;
      var degrees = 180 / Math.PI;
      var zoomstartStyle = { cursor: "pointer" };
      var zoomendStyle = { cursor: "auto" };
      function createGeoZoom(geo, geoLayout) {
        var projection = geo.projection;
        var zoomConstructor;
        if (geoLayout._isScoped) {
          zoomConstructor = zoomScoped;
        } else if (geoLayout._isClipped) {
          zoomConstructor = zoomClipped;
        } else {
          zoomConstructor = zoomNonClipped;
        }
        return zoomConstructor(geo, projection);
      }
      module.exports = createGeoZoom;
      function initZoom(geo, projection) {
        return d3.behavior.zoom().translate(projection.translate()).scale(projection.scale());
      }
      function sync(geo, projection, cb) {
        var id = geo.id;
        var gd = geo.graphDiv;
        var layout = gd.layout;
        var userOpts = layout[id];
        var fullLayout = gd._fullLayout;
        var fullOpts = fullLayout[id];
        var preGUI = {};
        var eventData = {};
        function set(propStr, val) {
          preGUI[id + "." + propStr] = Lib.nestedProperty(userOpts, propStr).get();
          Registry.call("_storeDirectGUIEdit", layout, fullLayout._preGUI, preGUI);
          var fullNp = Lib.nestedProperty(fullOpts, propStr);
          if (fullNp.get() !== val) {
            fullNp.set(val);
            Lib.nestedProperty(userOpts, propStr).set(val);
            eventData[id + "." + propStr] = val;
          }
        }
        cb(set);
        set("projection.scale", projection.scale() / geo.fitScale);
        set("fitbounds", false);
        gd.emit("plotly_relayout", eventData);
      }
      function zoomScoped(geo, projection) {
        var zoom = initZoom(geo, projection);
        function handleZoomstart() {
          d3.select(this).style(zoomstartStyle);
        }
        function handleZoom() {
          projection.scale(d3.event.scale).translate(d3.event.translate);
          geo.render(true);
          var center = projection.invert(geo.midPt);
          geo.graphDiv.emit("plotly_relayouting", {
            "geo.projection.scale": projection.scale() / geo.fitScale,
            "geo.center.lon": center[0],
            "geo.center.lat": center[1]
          });
        }
        function syncCb(set) {
          var center = projection.invert(geo.midPt);
          set("center.lon", center[0]);
          set("center.lat", center[1]);
        }
        function handleZoomend() {
          d3.select(this).style(zoomendStyle);
          sync(geo, projection, syncCb);
        }
        zoom.on("zoomstart", handleZoomstart).on("zoom", handleZoom).on("zoomend", handleZoomend);
        return zoom;
      }
      function zoomNonClipped(geo, projection) {
        var zoom = initZoom(geo, projection);
        var INSIDETOLORANCEPXS = 2;
        var mouse0, rotate0, translate0, lastRotate, zoomPoint, mouse1, rotate1, point1, didZoom;
        function position2(x) {
          return projection.invert(x);
        }
        function outside(x) {
          var pos = position2(x);
          if (!pos) return true;
          var pt = projection(pos);
          return Math.abs(pt[0] - x[0]) > INSIDETOLORANCEPXS || Math.abs(pt[1] - x[1]) > INSIDETOLORANCEPXS;
        }
        function handleZoomstart() {
          d3.select(this).style(zoomstartStyle);
          mouse0 = d3.mouse(this);
          rotate0 = projection.rotate();
          translate0 = projection.translate();
          lastRotate = rotate0;
          zoomPoint = position2(mouse0);
        }
        function handleZoom() {
          mouse1 = d3.mouse(this);
          if (outside(mouse0)) {
            zoom.scale(projection.scale());
            zoom.translate(projection.translate());
            return;
          }
          projection.scale(d3.event.scale);
          projection.translate([translate0[0], d3.event.translate[1]]);
          if (!zoomPoint) {
            mouse0 = mouse1;
            zoomPoint = position2(mouse0);
          } else if (position2(mouse1)) {
            point1 = position2(mouse1);
            rotate1 = [lastRotate[0] + (point1[0] - zoomPoint[0]), rotate0[1], rotate0[2]];
            projection.rotate(rotate1);
            lastRotate = rotate1;
          }
          didZoom = true;
          geo.render(true);
          var rotate = projection.rotate();
          var center = projection.invert(geo.midPt);
          geo.graphDiv.emit("plotly_relayouting", {
            "geo.projection.scale": projection.scale() / geo.fitScale,
            "geo.center.lon": center[0],
            "geo.center.lat": center[1],
            "geo.projection.rotation.lon": -rotate[0]
          });
        }
        function handleZoomend() {
          d3.select(this).style(zoomendStyle);
          if (didZoom) sync(geo, projection, syncCb);
        }
        function syncCb(set) {
          var rotate = projection.rotate();
          var center = projection.invert(geo.midPt);
          set("projection.rotation.lon", -rotate[0]);
          set("center.lon", center[0]);
          set("center.lat", center[1]);
        }
        zoom.on("zoomstart", handleZoomstart).on("zoom", handleZoom).on("zoomend", handleZoomend);
        return zoom;
      }
      function zoomClipped(geo, projection) {
        var view = { r: projection.rotate(), k: projection.scale() };
        var zoom = initZoom(geo, projection);
        var event = d3eventDispatch(zoom, "zoomstart", "zoom", "zoomend");
        var zooming = 0;
        var zoomOn = zoom.on;
        var zoomPoint;
        zoom.on("zoomstart", function() {
          d3.select(this).style(zoomstartStyle);
          var mouse0 = d3.mouse(this);
          var rotate0 = projection.rotate();
          var lastRotate = rotate0;
          var translate0 = projection.translate();
          var q = quaternionFromEuler(rotate0);
          zoomPoint = position(projection, mouse0);
          zoomOn.call(zoom, "zoom", function() {
            var mouse1 = d3.mouse(this);
            projection.scale(view.k = d3.event.scale);
            if (!zoomPoint) {
              mouse0 = mouse1;
              zoomPoint = position(projection, mouse0);
            } else if (position(projection, mouse1)) {
              projection.rotate(rotate0).translate(translate0);
              var point1 = position(projection, mouse1);
              var between = rotateBetween(zoomPoint, point1);
              var newEuler = eulerFromQuaternion(multiply(q, between));
              var rotateAngles = view.r = unRoll(newEuler, zoomPoint, lastRotate);
              if (!isFinite(rotateAngles[0]) || !isFinite(rotateAngles[1]) || !isFinite(rotateAngles[2])) {
                rotateAngles = lastRotate;
              }
              projection.rotate(rotateAngles);
              lastRotate = rotateAngles;
            }
            zoomed(event.of(this, arguments));
          });
          zoomstarted(event.of(this, arguments));
        }).on("zoomend", function() {
          d3.select(this).style(zoomendStyle);
          zoomOn.call(zoom, "zoom", null);
          zoomended(event.of(this, arguments));
          sync(geo, projection, syncCb);
        }).on("zoom.redraw", function() {
          geo.render(true);
          var _rotate = projection.rotate();
          geo.graphDiv.emit("plotly_relayouting", {
            "geo.projection.scale": projection.scale() / geo.fitScale,
            "geo.projection.rotation.lon": -_rotate[0],
            "geo.projection.rotation.lat": -_rotate[1]
          });
        });
        function zoomstarted(dispatch) {
          if (!zooming++) dispatch({ type: "zoomstart" });
        }
        function zoomed(dispatch) {
          dispatch({ type: "zoom" });
        }
        function zoomended(dispatch) {
          if (!--zooming) dispatch({ type: "zoomend" });
        }
        function syncCb(set) {
          var _rotate = projection.rotate();
          set("projection.rotation.lon", -_rotate[0]);
          set("projection.rotation.lat", -_rotate[1]);
        }
        return d3.rebind(zoom, event, "on");
      }
      function position(projection, point) {
        var spherical = projection.invert(point);
        return spherical && isFinite(spherical[0]) && isFinite(spherical[1]) && cartesian(spherical);
      }
      function quaternionFromEuler(euler) {
        var lambda = 0.5 * euler[0] * radians;
        var phi = 0.5 * euler[1] * radians;
        var gamma = 0.5 * euler[2] * radians;
        var sinLambda = Math.sin(lambda);
        var cosLambda = Math.cos(lambda);
        var sinPhi = Math.sin(phi);
        var cosPhi = Math.cos(phi);
        var sinGamma = Math.sin(gamma);
        var cosGamma = Math.cos(gamma);
        return [
          cosLambda * cosPhi * cosGamma + sinLambda * sinPhi * sinGamma,
          sinLambda * cosPhi * cosGamma - cosLambda * sinPhi * sinGamma,
          cosLambda * sinPhi * cosGamma + sinLambda * cosPhi * sinGamma,
          cosLambda * cosPhi * sinGamma - sinLambda * sinPhi * cosGamma
        ];
      }
      function multiply(a, b) {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];
        var b0 = b[0];
        var b1 = b[1];
        var b2 = b[2];
        var b3 = b[3];
        return [
          a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3,
          a0 * b1 + a1 * b0 + a2 * b3 - a3 * b2,
          a0 * b2 - a1 * b3 + a2 * b0 + a3 * b1,
          a0 * b3 + a1 * b2 - a2 * b1 + a3 * b0
        ];
      }
      function rotateBetween(a, b) {
        if (!a || !b) return;
        var axis = cross(a, b);
        var norm = Math.sqrt(dot(axis, axis));
        var halfgamma = 0.5 * Math.acos(Math.max(-1, Math.min(1, dot(a, b))));
        var k = Math.sin(halfgamma) / norm;
        return norm && [Math.cos(halfgamma), axis[2] * k, -axis[1] * k, axis[0] * k];
      }
      function unRoll(rotateAngles, pt, lastRotate) {
        var ptRotated = rotateCartesian(pt, 2, rotateAngles[0]);
        ptRotated = rotateCartesian(ptRotated, 1, rotateAngles[1]);
        ptRotated = rotateCartesian(ptRotated, 0, rotateAngles[2] - lastRotate[2]);
        var x = pt[0];
        var y = pt[1];
        var z = pt[2];
        var f = ptRotated[0];
        var g = ptRotated[1];
        var h = ptRotated[2];
        var theta = Math.atan2(y, x) * degrees;
        var a = Math.sqrt(x * x + y * y);
        var b;
        var newYaw1;
        if (Math.abs(g) > a) {
          newYaw1 = (g > 0 ? 90 : -90) - theta;
          b = 0;
        } else {
          newYaw1 = Math.asin(g / a) * degrees - theta;
          b = Math.sqrt(a * a - g * g);
        }
        var newYaw2 = 180 - newYaw1 - 2 * theta;
        var newPitch1 = (Math.atan2(h, f) - Math.atan2(z, b)) * degrees;
        var newPitch2 = (Math.atan2(h, f) - Math.atan2(z, -b)) * degrees;
        var dist1 = angleDistance(lastRotate[0], lastRotate[1], newYaw1, newPitch1);
        var dist2 = angleDistance(lastRotate[0], lastRotate[1], newYaw2, newPitch2);
        if (dist1 <= dist2) return [newYaw1, newPitch1, lastRotate[2]];
        else return [newYaw2, newPitch2, lastRotate[2]];
      }
      function angleDistance(yaw0, pitch0, yaw1, pitch1) {
        var dYaw = angleMod(yaw1 - yaw0);
        var dPitch = angleMod(pitch1 - pitch0);
        return Math.sqrt(dYaw * dYaw + dPitch * dPitch);
      }
      function angleMod(angle) {
        return (angle % 360 + 540) % 360 - 180;
      }
      function rotateCartesian(vector, axis, angle) {
        var angleRads = angle * radians;
        var vectorOut = vector.slice();
        var ax1 = axis === 0 ? 1 : 0;
        var ax2 = axis === 2 ? 1 : 2;
        var cosa = Math.cos(angleRads);
        var sina = Math.sin(angleRads);
        vectorOut[ax1] = vector[ax1] * cosa - vector[ax2] * sina;
        vectorOut[ax2] = vector[ax2] * cosa + vector[ax1] * sina;
        return vectorOut;
      }
      function eulerFromQuaternion(q) {
        return [
          Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * degrees,
          Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * degrees,
          Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * degrees
        ];
      }
      function cartesian(spherical) {
        var lambda = spherical[0] * radians;
        var phi = spherical[1] * radians;
        var cosPhi = Math.cos(phi);
        return [
          cosPhi * Math.cos(lambda),
          cosPhi * Math.sin(lambda),
          Math.sin(phi)
        ];
      }
      function dot(a, b) {
        var s = 0;
        for (var i = 0, n = a.length; i < n; ++i) s += a[i] * b[i];
        return s;
      }
      function cross(a, b) {
        return [
          a[1] * b[2] - a[2] * b[1],
          a[2] * b[0] - a[0] * b[2],
          a[0] * b[1] - a[1] * b[0]
        ];
      }
      function d3eventDispatch(target) {
        var i = 0;
        var n = arguments.length;
        var argumentz = [];
        while (++i < n) argumentz.push(arguments[i]);
        var dispatch = d3.dispatch.apply(null, argumentz);
        dispatch.of = function(thiz, argumentz2) {
          return function(e1) {
            var e0;
            try {
              e0 = e1.sourceEvent = d3.event;
              e1.target = target;
              d3.event = e1;
              dispatch[e1.type].apply(thiz, argumentz2);
            } finally {
              d3.event = e0;
            }
          };
        };
        return dispatch;
      }
    }
  });

  // src/plots/geo/geo.js
  var require_geo = __commonJS({
    "src/plots/geo/geo.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var geo = require_d3_geo();
      var geoPath = geo.geoPath;
      var geoDistance = geo.geoDistance;
      var geoProjection = require_d3_geo_projection();
      var Registry = require_registry();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var Color = require_color();
      var Drawing = require_drawing();
      var Fx = require_fx();
      var Plots = require_plots();
      var Axes = require_axes();
      var getAutoRange = require_autorange().getAutoRange;
      var dragElement = require_dragelement();
      var prepSelect = require_selections().prepSelect;
      var clearOutline = require_selections().clearOutline;
      var selectOnClick = require_selections().selectOnClick;
      var createGeoZoom = require_zoom();
      var constants = require_constants14();
      var geoUtils = require_geo_location_utils();
      var topojsonUtils = require_topojson_utils();
      var topojsonFeature = require_topojson_client().feature;
      function Geo(opts) {
        this.id = opts.id;
        this.graphDiv = opts.graphDiv;
        this.container = opts.container;
        this.topojsonURL = opts.topojsonURL;
        this.isStatic = opts.staticPlot;
        this.topojsonName = null;
        this.topojson = null;
        this.projection = null;
        this.scope = null;
        this.viewInitial = null;
        this.fitScale = null;
        this.bounds = null;
        this.midPt = null;
        this.hasChoropleth = false;
        this.traceHash = {};
        this.layers = {};
        this.basePaths = {};
        this.dataPaths = {};
        this.dataPoints = {};
        this.clipDef = null;
        this.clipRect = null;
        this.bgRect = null;
        this.makeFramework();
      }
      var proto = Geo.prototype;
      module.exports = function createGeo(opts) {
        return new Geo(opts);
      };
      proto.plot = function(geoCalcData, fullLayout, promises, replot) {
        var _this = this;
        if (replot) return _this.update(geoCalcData, fullLayout, true);
        _this._geoCalcData = geoCalcData;
        _this._fullLayout = fullLayout;
        var geoLayout = fullLayout[this.id];
        var geoPromises = [];
        var needsTopojson = false;
        for (var k in constants.layerNameToAdjective) {
          if (k !== "frame" && geoLayout["show" + k]) {
            needsTopojson = true;
            break;
          }
        }
        var hasMarkerAngles = false;
        for (var i = 0; i < geoCalcData.length; i++) {
          var trace = geoCalcData[0][0].trace;
          trace._geo = _this;
          if (trace.locationmode) {
            needsTopojson = true;
          }
          var marker = trace.marker;
          if (marker) {
            var angle = marker.angle;
            var angleref = marker.angleref;
            if (angle || angleref === "north" || angleref === "previous") hasMarkerAngles = true;
          }
        }
        this._hasMarkerAngles = hasMarkerAngles;
        if (needsTopojson) {
          var topojsonNameNew = topojsonUtils.getTopojsonName(geoLayout);
          if (_this.topojson === null || topojsonNameNew !== _this.topojsonName) {
            _this.topojsonName = topojsonNameNew;
            if (PlotlyGeoAssets.topojson[_this.topojsonName] === void 0) {
              geoPromises.push(_this.fetchTopojson());
            }
          }
        }
        geoPromises = geoPromises.concat(geoUtils.fetchTraceGeoData(geoCalcData));
        promises.push(new Promise(function(resolve, reject) {
          Promise.all(geoPromises).then(function() {
            _this.topojson = PlotlyGeoAssets.topojson[_this.topojsonName];
            _this.update(geoCalcData, fullLayout);
            resolve();
          }).catch(reject);
        }));
      };
      proto.fetchTopojson = function() {
        var _this = this;
        var topojsonPath = topojsonUtils.getTopojsonPath(_this.topojsonURL, _this.topojsonName);
        return new Promise(function(resolve, reject) {
          d3.json(topojsonPath, function(err, topojson) {
            if (err) {
              if (err.status === 404) {
                return reject(new Error([
                  "plotly.js could not find topojson file at",
                  topojsonPath + ".",
                  "Make sure the *topojsonURL* plot config option",
                  "is set properly."
                ].join(" ")));
              } else {
                return reject(new Error([
                  "unexpected error while fetching topojson file at",
                  topojsonPath
                ].join(" ")));
              }
            }
            PlotlyGeoAssets.topojson[_this.topojsonName] = topojson;
            resolve();
          });
        });
      };
      proto.update = function(geoCalcData, fullLayout, replot) {
        var geoLayout = fullLayout[this.id];
        this.hasChoropleth = false;
        for (var i = 0; i < geoCalcData.length; i++) {
          var calcTrace = geoCalcData[i];
          var trace = calcTrace[0].trace;
          if (trace.type === "choropleth") {
            this.hasChoropleth = true;
          }
          if (trace.visible === true && trace._length > 0) {
            trace._module.calcGeoJSON(calcTrace, fullLayout);
          }
        }
        if (!replot) {
          var hasInvalidBounds = this.updateProjection(geoCalcData, fullLayout);
          if (hasInvalidBounds) return;
          if (!this.viewInitial || this.scope !== geoLayout.scope) {
            this.saveViewInitial(geoLayout);
          }
        }
        this.scope = geoLayout.scope;
        this.updateBaseLayers(fullLayout, geoLayout);
        this.updateDims(fullLayout, geoLayout);
        this.updateFx(fullLayout, geoLayout);
        Plots.generalUpdatePerTraceModule(this.graphDiv, this, geoCalcData, geoLayout);
        var scatterLayer = this.layers.frontplot.select(".scatterlayer");
        this.dataPoints.point = scatterLayer.selectAll(".point");
        this.dataPoints.text = scatterLayer.selectAll("text");
        this.dataPaths.line = scatterLayer.selectAll(".js-line");
        var choroplethLayer = this.layers.backplot.select(".choroplethlayer");
        this.dataPaths.choropleth = choroplethLayer.selectAll("path");
        this._render();
      };
      proto.updateProjection = function(geoCalcData, fullLayout) {
        var gd = this.graphDiv;
        var geoLayout = fullLayout[this.id];
        var gs = fullLayout._size;
        var domain = geoLayout.domain;
        var projLayout = geoLayout.projection;
        var lonaxis = geoLayout.lonaxis;
        var lataxis = geoLayout.lataxis;
        var axLon = lonaxis._ax;
        var axLat = lataxis._ax;
        var projection = this.projection = getProjection(geoLayout);
        var extent = [[
          gs.l + gs.w * domain.x[0],
          gs.t + gs.h * (1 - domain.y[1])
        ], [
          gs.l + gs.w * domain.x[1],
          gs.t + gs.h * (1 - domain.y[0])
        ]];
        var center = geoLayout.center || {};
        var rotation = projLayout.rotation || {};
        var lonaxisRange = lonaxis.range || [];
        var lataxisRange = lataxis.range || [];
        if (geoLayout.fitbounds) {
          axLon._length = extent[1][0] - extent[0][0];
          axLat._length = extent[1][1] - extent[0][1];
          axLon.range = getAutoRange(gd, axLon);
          axLat.range = getAutoRange(gd, axLat);
          var midLon = (axLon.range[0] + axLon.range[1]) / 2;
          var midLat = (axLat.range[0] + axLat.range[1]) / 2;
          if (geoLayout._isScoped) {
            center = { lon: midLon, lat: midLat };
          } else if (geoLayout._isClipped) {
            center = { lon: midLon, lat: midLat };
            rotation = { lon: midLon, lat: midLat, roll: rotation.roll };
            var projType = projLayout.type;
            var lonHalfSpan = constants.lonaxisSpan[projType] / 2 || 180;
            var latHalfSpan = constants.lataxisSpan[projType] / 2 || 90;
            lonaxisRange = [midLon - lonHalfSpan, midLon + lonHalfSpan];
            lataxisRange = [midLat - latHalfSpan, midLat + latHalfSpan];
          } else {
            center = { lon: midLon, lat: midLat };
            rotation = { lon: midLon, lat: rotation.lat, roll: rotation.roll };
          }
        }
        projection.center([center.lon - rotation.lon, center.lat - rotation.lat]).rotate([-rotation.lon, -rotation.lat, rotation.roll]).parallels(projLayout.parallels);
        var rangeBox = makeRangeBox(lonaxisRange, lataxisRange);
        projection.fitExtent(extent, rangeBox);
        var b = this.bounds = projection.getBounds(rangeBox);
        var s = this.fitScale = projection.scale();
        var t = projection.translate();
        if (geoLayout.fitbounds) {
          var b2 = projection.getBounds(makeRangeBox(axLon.range, axLat.range));
          var k2 = Math.min(
            (b[1][0] - b[0][0]) / (b2[1][0] - b2[0][0]),
            (b[1][1] - b[0][1]) / (b2[1][1] - b2[0][1])
          );
          if (isFinite(k2)) {
            projection.scale(k2 * s);
          } else {
            Lib.warn("Something went wrong during" + this.id + "fitbounds computations.");
          }
        } else {
          projection.scale(projLayout.scale * s);
        }
        var midPt = this.midPt = [
          (b[0][0] + b[1][0]) / 2,
          (b[0][1] + b[1][1]) / 2
        ];
        projection.translate([t[0] + (midPt[0] - t[0]), t[1] + (midPt[1] - t[1])]).clipExtent(b);
        if (geoLayout._isAlbersUsa) {
          var centerPx = projection([center.lon, center.lat]);
          var tt = projection.translate();
          projection.translate([
            tt[0] - (centerPx[0] - tt[0]),
            tt[1] - (centerPx[1] - tt[1])
          ]);
        }
      };
      proto.updateBaseLayers = function(fullLayout, geoLayout) {
        var _this = this;
        var topojson = _this.topojson;
        var layers = _this.layers;
        var basePaths = _this.basePaths;
        function isAxisLayer(d) {
          return d === "lonaxis" || d === "lataxis";
        }
        function isLineLayer(d) {
          return Boolean(constants.lineLayers[d]);
        }
        function isFillLayer(d) {
          return Boolean(constants.fillLayers[d]);
        }
        var allLayers = this.hasChoropleth ? constants.layersForChoropleth : constants.layers;
        var layerData = allLayers.filter(function(d) {
          return isLineLayer(d) || isFillLayer(d) ? geoLayout["show" + d] : isAxisLayer(d) ? geoLayout[d].showgrid : true;
        });
        var join = _this.framework.selectAll(".layer").data(layerData, String);
        join.exit().each(function(d) {
          delete layers[d];
          delete basePaths[d];
          d3.select(this).remove();
        });
        join.enter().append("g").attr("class", function(d) {
          return "layer " + d;
        }).each(function(d) {
          var layer = layers[d] = d3.select(this);
          if (d === "bg") {
            _this.bgRect = layer.append("rect").style("pointer-events", "all");
          } else if (isAxisLayer(d)) {
            basePaths[d] = layer.append("path").style("fill", "none");
          } else if (d === "backplot") {
            layer.append("g").classed("choroplethlayer", true);
          } else if (d === "frontplot") {
            layer.append("g").classed("scatterlayer", true);
          } else if (isLineLayer(d)) {
            basePaths[d] = layer.append("path").style("fill", "none").style("stroke-miterlimit", 2);
          } else if (isFillLayer(d)) {
            basePaths[d] = layer.append("path").style("stroke", "none");
          }
        });
        join.order();
        join.each(function(d) {
          var path = basePaths[d];
          var adj = constants.layerNameToAdjective[d];
          if (d === "frame") {
            path.datum(constants.sphereSVG);
          } else if (isLineLayer(d) || isFillLayer(d)) {
            path.datum(topojsonFeature(topojson, topojson.objects[d]));
          } else if (isAxisLayer(d)) {
            path.datum(makeGraticule(d, geoLayout, fullLayout)).call(Color.stroke, geoLayout[d].gridcolor).call(Drawing.dashLine, geoLayout[d].griddash, geoLayout[d].gridwidth);
          }
          if (isLineLayer(d)) {
            path.call(Color.stroke, geoLayout[adj + "color"]).call(Drawing.dashLine, "", geoLayout[adj + "width"]);
          } else if (isFillLayer(d)) {
            path.call(Color.fill, geoLayout[adj + "color"]);
          }
        });
      };
      proto.updateDims = function(fullLayout, geoLayout) {
        var b = this.bounds;
        var hFrameWidth = (geoLayout.framewidth || 0) / 2;
        var l = b[0][0] - hFrameWidth;
        var t = b[0][1] - hFrameWidth;
        var w = b[1][0] - l + hFrameWidth;
        var h = b[1][1] - t + hFrameWidth;
        Drawing.setRect(this.clipRect, l, t, w, h);
        this.bgRect.call(Drawing.setRect, l, t, w, h).call(Color.fill, geoLayout.bgcolor);
        this.xaxis._offset = l;
        this.xaxis._length = w;
        this.yaxis._offset = t;
        this.yaxis._length = h;
      };
      proto.updateFx = function(fullLayout, geoLayout) {
        var _this = this;
        var gd = _this.graphDiv;
        var bgRect = _this.bgRect;
        var dragMode = fullLayout.dragmode;
        var clickMode = fullLayout.clickmode;
        if (_this.isStatic) return;
        function zoomReset() {
          var viewInitial = _this.viewInitial;
          var updateObj = {};
          for (var k in viewInitial) {
            updateObj[_this.id + "." + k] = viewInitial[k];
          }
          Registry.call("_guiRelayout", gd, updateObj);
          gd.emit("plotly_doubleclick", null);
        }
        function invert(lonlat) {
          return _this.projection.invert([
            lonlat[0] + _this.xaxis._offset,
            lonlat[1] + _this.yaxis._offset
          ]);
        }
        var fillRangeItems = function(eventData, poly) {
          if (poly.isRect) {
            var ranges = eventData.range = {};
            ranges[_this.id] = [
              invert([poly.xmin, poly.ymin]),
              invert([poly.xmax, poly.ymax])
            ];
          } else {
            var dataPts = eventData.lassoPoints = {};
            dataPts[_this.id] = poly.map(invert);
          }
        };
        var dragOptions = {
          element: _this.bgRect.node(),
          gd,
          plotinfo: {
            id: _this.id,
            xaxis: _this.xaxis,
            yaxis: _this.yaxis,
            fillRangeItems
          },
          xaxes: [_this.xaxis],
          yaxes: [_this.yaxis],
          subplot: _this.id,
          clickFn: function(numClicks) {
            if (numClicks === 2) {
              clearOutline(gd);
            }
          }
        };
        if (dragMode === "pan") {
          bgRect.node().onmousedown = null;
          bgRect.call(createGeoZoom(_this, geoLayout));
          bgRect.on("dblclick.zoom", zoomReset);
          if (!gd._context._scrollZoom.geo) {
            bgRect.on("wheel.zoom", null);
          }
        } else if (dragMode === "select" || dragMode === "lasso") {
          bgRect.on(".zoom", null);
          dragOptions.prepFn = function(e, startX, startY) {
            prepSelect(e, startX, startY, dragOptions, dragMode);
          };
          dragElement.init(dragOptions);
        }
        bgRect.on("mousemove", function() {
          var lonlat = _this.projection.invert(Lib.getPositionFromD3Event());
          if (!lonlat) {
            return dragElement.unhover(gd, d3.event);
          }
          _this.xaxis.p2c = function() {
            return lonlat[0];
          };
          _this.yaxis.p2c = function() {
            return lonlat[1];
          };
          Fx.hover(gd, d3.event, _this.id);
        });
        bgRect.on("mouseout", function() {
          if (gd._dragging) return;
          dragElement.unhover(gd, d3.event);
        });
        bgRect.on("click", function() {
          if (dragMode !== "select" && dragMode !== "lasso") {
            if (clickMode.indexOf("select") > -1) {
              selectOnClick(
                d3.event,
                gd,
                [_this.xaxis],
                [_this.yaxis],
                _this.id,
                dragOptions
              );
            }
            if (clickMode.indexOf("event") > -1) {
              Fx.click(gd, d3.event);
            }
          }
        });
      };
      proto.makeFramework = function() {
        var _this = this;
        var gd = _this.graphDiv;
        var fullLayout = gd._fullLayout;
        var clipId = "clip" + fullLayout._uid + _this.id;
        _this.clipDef = fullLayout._clips.append("clipPath").attr("id", clipId);
        _this.clipRect = _this.clipDef.append("rect");
        _this.framework = d3.select(_this.container).append("g").attr("class", "geo " + _this.id).call(Drawing.setClipUrl, clipId, gd);
        _this.project = function(v) {
          var px = _this.projection(v);
          return px ? [px[0] - _this.xaxis._offset, px[1] - _this.yaxis._offset] : [null, null];
        };
        _this.xaxis = {
          _id: "x",
          c2p: function(v) {
            return _this.project(v)[0];
          }
        };
        _this.yaxis = {
          _id: "y",
          c2p: function(v) {
            return _this.project(v)[1];
          }
        };
        _this.mockAxis = {
          type: "linear",
          showexponent: "all",
          exponentformat: "B"
        };
        Axes.setConvert(_this.mockAxis, fullLayout);
      };
      proto.saveViewInitial = function(geoLayout) {
        var center = geoLayout.center || {};
        var projLayout = geoLayout.projection;
        var rotation = projLayout.rotation || {};
        this.viewInitial = {
          fitbounds: geoLayout.fitbounds,
          "projection.scale": projLayout.scale
        };
        var extra;
        if (geoLayout._isScoped) {
          extra = {
            "center.lon": center.lon,
            "center.lat": center.lat
          };
        } else if (geoLayout._isClipped) {
          extra = {
            "projection.rotation.lon": rotation.lon,
            "projection.rotation.lat": rotation.lat
          };
        } else {
          extra = {
            "center.lon": center.lon,
            "center.lat": center.lat,
            "projection.rotation.lon": rotation.lon
          };
        }
        Lib.extendFlat(this.viewInitial, extra);
      };
      proto.render = function(mayRedrawOnUpdates) {
        if (this._hasMarkerAngles && mayRedrawOnUpdates) {
          this.plot(this._geoCalcData, this._fullLayout, [], true);
        } else {
          this._render();
        }
      };
      proto._render = function() {
        var projection = this.projection;
        var pathFn = projection.getPath();
        var k;
        function translatePoints(d) {
          var lonlatPx = projection(d.lonlat);
          return lonlatPx ? strTranslate(lonlatPx[0], lonlatPx[1]) : null;
        }
        function hideShowPoints(d) {
          return projection.isLonLatOverEdges(d.lonlat) ? "none" : null;
        }
        for (k in this.basePaths) {
          this.basePaths[k].attr("d", pathFn);
        }
        for (k in this.dataPaths) {
          this.dataPaths[k].attr("d", function(d) {
            return pathFn(d.geojson);
          });
        }
        for (k in this.dataPoints) {
          this.dataPoints[k].attr("display", hideShowPoints).attr("transform", translatePoints);
        }
      };
      function getProjection(geoLayout) {
        var projLayout = geoLayout.projection;
        var projType = projLayout.type;
        var projName = constants.projNames[projType];
        projName = "geo" + Lib.titleCase(projName);
        var projFn = geo[projName] || geoProjection[projName];
        var projection = projFn();
        var clipAngle = geoLayout._isSatellite ? Math.acos(1 / projLayout.distance) * 180 / Math.PI : geoLayout._isClipped ? constants.lonaxisSpan[projType] / 2 : null;
        var methods = ["center", "rotate", "parallels", "clipExtent"];
        var dummyFn = function(_) {
          return _ ? projection : [];
        };
        for (var i = 0; i < methods.length; i++) {
          var m = methods[i];
          if (typeof projection[m] !== "function") {
            projection[m] = dummyFn;
          }
        }
        projection.isLonLatOverEdges = function(lonlat) {
          if (projection(lonlat) === null) {
            return true;
          }
          if (clipAngle) {
            var r = projection.rotate();
            var angle = geoDistance(lonlat, [-r[0], -r[1]]);
            var maxAngle = clipAngle * Math.PI / 180;
            return angle > maxAngle;
          } else {
            return false;
          }
        };
        projection.getPath = function() {
          return geoPath().projection(projection);
        };
        projection.getBounds = function(object) {
          return projection.getPath().bounds(object);
        };
        projection.precision(constants.precision);
        if (geoLayout._isSatellite) {
          projection.tilt(projLayout.tilt).distance(projLayout.distance);
        }
        if (clipAngle) {
          projection.clipAngle(clipAngle - constants.clipPad);
        }
        return projection;
      }
      function makeGraticule(axisName, geoLayout, fullLayout) {
        var epsilon = 1e-6;
        var precision = 2.5;
        var axLayout = geoLayout[axisName];
        var scopeDefaults = constants.scopeDefaults[geoLayout.scope];
        var rng;
        var oppRng;
        var coordFn;
        if (axisName === "lonaxis") {
          rng = scopeDefaults.lonaxisRange;
          oppRng = scopeDefaults.lataxisRange;
          coordFn = function(v2, l2) {
            return [v2, l2];
          };
        } else if (axisName === "lataxis") {
          rng = scopeDefaults.lataxisRange;
          oppRng = scopeDefaults.lonaxisRange;
          coordFn = function(v2, l2) {
            return [l2, v2];
          };
        }
        var dummyAx = {
          type: "linear",
          range: [rng[0], rng[1] - epsilon],
          tick0: axLayout.tick0,
          dtick: axLayout.dtick
        };
        Axes.setConvert(dummyAx, fullLayout);
        var vals = Axes.calcTicks(dummyAx);
        if (!geoLayout.isScoped && axisName === "lonaxis") {
          vals.pop();
        }
        var len = vals.length;
        var coords = new Array(len);
        for (var i = 0; i < len; i++) {
          var v = vals[i].x;
          var line = coords[i] = [];
          for (var l = oppRng[0]; l < oppRng[1] + precision; l += precision) {
            line.push(coordFn(v, l));
          }
        }
        return {
          type: "MultiLineString",
          coordinates: coords
        };
      }
      function makeRangeBox(lon, lat) {
        var clipPad = constants.clipPad;
        var lon0 = lon[0] + clipPad;
        var lon1 = lon[1] - clipPad;
        var lat0 = lat[0] + clipPad;
        var lat1 = lat[1] - clipPad;
        if (lon0 > 0 && lon1 < 0) lon1 += 360;
        var dlon4 = (lon1 - lon0) / 4;
        return {
          type: "Polygon",
          coordinates: [[
            [lon0, lat0],
            [lon0, lat1],
            [lon0 + dlon4, lat1],
            [lon0 + 2 * dlon4, lat1],
            [lon0 + 3 * dlon4, lat1],
            [lon1, lat1],
            [lon1, lat0],
            [lon1 - dlon4, lat0],
            [lon1 - 2 * dlon4, lat0],
            [lon1 - 3 * dlon4, lat0],
            [lon0, lat0]
          ]]
        };
      }
    }
  });

  // src/plots/geo/layout_attributes.js
  var require_layout_attributes6 = __commonJS({
    "src/plots/geo/layout_attributes.js"(exports, module) {
      "use strict";
      var colorAttrs = require_attributes3();
      var domainAttrs = require_domain().attributes;
      var dash = require_attributes4().dash;
      var constants = require_constants14();
      var overrideAll = require_edit_types().overrideAll;
      var sortObjectKeys = require_sort_object_keys();
      var geoAxesAttrs = {
        range: {
          valType: "info_array",
          items: [
            { valType: "number" },
            { valType: "number" }
          ]
        },
        showgrid: {
          valType: "boolean",
          dflt: false
        },
        tick0: {
          valType: "number",
          dflt: 0
        },
        dtick: {
          valType: "number"
        },
        gridcolor: {
          valType: "color",
          dflt: colorAttrs.lightLine
        },
        gridwidth: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        griddash: dash
      };
      var attrs = module.exports = overrideAll({
        domain: domainAttrs({ name: "geo" }, {}),
        fitbounds: {
          valType: "enumerated",
          values: [false, "locations", "geojson"],
          dflt: false,
          editType: "plot"
        },
        resolution: {
          valType: "enumerated",
          values: [110, 50],
          dflt: 110,
          coerceNumber: true
        },
        scope: {
          valType: "enumerated",
          values: sortObjectKeys(constants.scopeDefaults),
          dflt: "world"
        },
        projection: {
          type: {
            valType: "enumerated",
            values: sortObjectKeys(constants.projNames)
          },
          rotation: {
            lon: {
              valType: "number"
            },
            lat: {
              valType: "number"
            },
            roll: {
              valType: "number"
            }
          },
          tilt: {
            valType: "number",
            dflt: 0
          },
          distance: {
            valType: "number",
            min: 1.001,
            dflt: 2
          },
          parallels: {
            valType: "info_array",
            items: [
              { valType: "number" },
              { valType: "number" }
            ]
          },
          scale: {
            valType: "number",
            min: 0,
            dflt: 1
          }
        },
        center: {
          lon: {
            valType: "number"
          },
          lat: {
            valType: "number"
          }
        },
        visible: {
          valType: "boolean",
          dflt: true
        },
        showcoastlines: {
          valType: "boolean"
        },
        coastlinecolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine
        },
        coastlinewidth: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        showland: {
          valType: "boolean",
          dflt: false
        },
        landcolor: {
          valType: "color",
          dflt: constants.landColor
        },
        showocean: {
          valType: "boolean",
          dflt: false
        },
        oceancolor: {
          valType: "color",
          dflt: constants.waterColor
        },
        showlakes: {
          valType: "boolean",
          dflt: false
        },
        lakecolor: {
          valType: "color",
          dflt: constants.waterColor
        },
        showrivers: {
          valType: "boolean",
          dflt: false
        },
        rivercolor: {
          valType: "color",
          dflt: constants.waterColor
        },
        riverwidth: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        showcountries: {
          valType: "boolean"
        },
        countrycolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine
        },
        countrywidth: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        showsubunits: {
          valType: "boolean"
        },
        subunitcolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine
        },
        subunitwidth: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        showframe: {
          valType: "boolean"
        },
        framecolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine
        },
        framewidth: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        bgcolor: {
          valType: "color",
          dflt: colorAttrs.background
        },
        lonaxis: geoAxesAttrs,
        lataxis: geoAxesAttrs
      }, "plot", "from-root");
      attrs.uirevision = {
        valType: "any",
        editType: "none"
      };
    }
  });

  // src/plots/subplot_defaults.js
  var require_subplot_defaults = __commonJS({
    "src/plots/subplot_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Template = require_plot_template();
      var handleDomainDefaults = require_domain().defaults;
      module.exports = function handleSubplotDefaults(layoutIn, layoutOut, fullData, opts) {
        var subplotType = opts.type;
        var subplotAttributes = opts.attributes;
        var handleDefaults = opts.handleDefaults;
        var partition = opts.partition || "x";
        var ids = layoutOut._subplots[subplotType];
        var idsLength = ids.length;
        var baseId = idsLength && ids[0].replace(/\d+$/, "");
        var subplotLayoutIn, subplotLayoutOut;
        function coerce(attr, dflt) {
          return Lib.coerce(subplotLayoutIn, subplotLayoutOut, subplotAttributes, attr, dflt);
        }
        for (var i = 0; i < idsLength; i++) {
          var id = ids[i];
          if (layoutIn[id]) subplotLayoutIn = layoutIn[id];
          else subplotLayoutIn = layoutIn[id] = {};
          subplotLayoutOut = Template.newContainer(layoutOut, id, baseId);
          if (!opts.noUirevision) coerce("uirevision", layoutOut.uirevision);
          var dfltDomains = {};
          dfltDomains[partition] = [i / idsLength, (i + 1) / idsLength];
          handleDomainDefaults(subplotLayoutOut, layoutOut, coerce, dfltDomains);
          opts.id = id;
          handleDefaults(subplotLayoutIn, subplotLayoutOut, coerce, opts);
        }
      };
    }
  });

  // src/plots/geo/layout_defaults.js
  var require_layout_defaults5 = __commonJS({
    "src/plots/geo/layout_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleSubplotDefaults = require_subplot_defaults();
      var getSubplotData = require_get_data().getSubplotData;
      var constants = require_constants14();
      var layoutAttributes = require_layout_attributes6();
      var axesNames = constants.axesNames;
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {
        handleSubplotDefaults(layoutIn, layoutOut, fullData, {
          type: "geo",
          attributes: layoutAttributes,
          handleDefaults: handleGeoDefaults,
          fullData,
          partition: "y"
        });
      };
      function handleGeoDefaults(geoLayoutIn, geoLayoutOut, coerce, opts) {
        var subplotData = getSubplotData(opts.fullData, "geo", opts.id);
        var traceIndices = subplotData.map(function(t) {
          return t.index;
        });
        var resolution = coerce("resolution");
        var scope = coerce("scope");
        var scopeParams = constants.scopeDefaults[scope];
        var projType = coerce("projection.type", scopeParams.projType);
        var isAlbersUsa = geoLayoutOut._isAlbersUsa = projType === "albers usa";
        if (isAlbersUsa) scope = geoLayoutOut.scope = "usa";
        var isScoped = geoLayoutOut._isScoped = scope !== "world";
        var isSatellite = geoLayoutOut._isSatellite = projType === "satellite";
        var isConic = geoLayoutOut._isConic = projType.indexOf("conic") !== -1 || projType === "albers";
        var isClipped = geoLayoutOut._isClipped = !!constants.lonaxisSpan[projType];
        if (geoLayoutIn.visible === false) {
          var newTemplate = Lib.extendDeep({}, geoLayoutOut._template);
          newTemplate.showcoastlines = false;
          newTemplate.showcountries = false;
          newTemplate.showframe = false;
          newTemplate.showlakes = false;
          newTemplate.showland = false;
          newTemplate.showocean = false;
          newTemplate.showrivers = false;
          newTemplate.showsubunits = false;
          if (newTemplate.lonaxis) newTemplate.lonaxis.showgrid = false;
          if (newTemplate.lataxis) newTemplate.lataxis.showgrid = false;
          geoLayoutOut._template = newTemplate;
        }
        var visible = coerce("visible");
        var show;
        for (var i = 0; i < axesNames.length; i++) {
          var axisName = axesNames[i];
          var dtickDflt = [30, 10][i];
          var rangeDflt;
          if (isScoped) {
            rangeDflt = scopeParams[axisName + "Range"];
          } else {
            var dfltSpans = constants[axisName + "Span"];
            var hSpan = (dfltSpans[projType] || dfltSpans["*"]) / 2;
            var rot = coerce(
              "projection.rotation." + axisName.substr(0, 3),
              scopeParams.projRotate[i]
            );
            rangeDflt = [rot - hSpan, rot + hSpan];
          }
          var range = coerce(axisName + ".range", rangeDflt);
          coerce(axisName + ".tick0");
          coerce(axisName + ".dtick", dtickDflt);
          show = coerce(axisName + ".showgrid", !visible ? false : void 0);
          if (show) {
            coerce(axisName + ".gridcolor");
            coerce(axisName + ".gridwidth");
            coerce(axisName + ".griddash");
          }
          geoLayoutOut[axisName]._ax = {
            type: "linear",
            _id: axisName.slice(0, 3),
            _traceIndices: traceIndices,
            setScale: Lib.identity,
            c2l: Lib.identity,
            r2l: Lib.identity,
            autorange: true,
            range: range.slice(),
            _m: 1,
            _input: {}
          };
        }
        var lonRange = geoLayoutOut.lonaxis.range;
        var latRange = geoLayoutOut.lataxis.range;
        var lon0 = lonRange[0];
        var lon1 = lonRange[1];
        if (lon0 > 0 && lon1 < 0) lon1 += 360;
        var centerLon = (lon0 + lon1) / 2;
        var projLon;
        if (!isAlbersUsa) {
          var dfltProjRotate = isScoped ? scopeParams.projRotate : [centerLon, 0, 0];
          projLon = coerce("projection.rotation.lon", dfltProjRotate[0]);
          coerce("projection.rotation.lat", dfltProjRotate[1]);
          coerce("projection.rotation.roll", dfltProjRotate[2]);
          show = coerce("showcoastlines", !isScoped && visible);
          if (show) {
            coerce("coastlinecolor");
            coerce("coastlinewidth");
          }
          show = coerce("showocean", !visible ? false : void 0);
          if (show) coerce("oceancolor");
        }
        var centerLonDflt;
        var centerLatDflt;
        if (isAlbersUsa) {
          centerLonDflt = -96.6;
          centerLatDflt = 38.7;
        } else {
          centerLonDflt = isScoped ? centerLon : projLon;
          centerLatDflt = (latRange[0] + latRange[1]) / 2;
        }
        coerce("center.lon", centerLonDflt);
        coerce("center.lat", centerLatDflt);
        if (isSatellite) {
          coerce("projection.tilt");
          coerce("projection.distance");
        }
        if (isConic) {
          var dfltProjParallels = scopeParams.projParallels || [0, 60];
          coerce("projection.parallels", dfltProjParallels);
        }
        coerce("projection.scale");
        show = coerce("showland", !visible ? false : void 0);
        if (show) coerce("landcolor");
        show = coerce("showlakes", !visible ? false : void 0);
        if (show) coerce("lakecolor");
        show = coerce("showrivers", !visible ? false : void 0);
        if (show) {
          coerce("rivercolor");
          coerce("riverwidth");
        }
        show = coerce("showcountries", isScoped && scope !== "usa" && visible);
        if (show) {
          coerce("countrycolor");
          coerce("countrywidth");
        }
        if (scope === "usa" || scope === "north america" && resolution === 50) {
          coerce("showsubunits", visible);
          coerce("subunitcolor");
          coerce("subunitwidth");
        }
        if (!isScoped) {
          show = coerce("showframe", visible);
          if (show) {
            coerce("framecolor");
            coerce("framewidth");
          }
        }
        coerce("bgcolor");
        var fitBounds = coerce("fitbounds");
        if (fitBounds) {
          delete geoLayoutOut.projection.scale;
          if (isScoped) {
            delete geoLayoutOut.center.lon;
            delete geoLayoutOut.center.lat;
          } else if (isClipped) {
            delete geoLayoutOut.center.lon;
            delete geoLayoutOut.center.lat;
            delete geoLayoutOut.projection.rotation.lon;
            delete geoLayoutOut.projection.rotation.lat;
            delete geoLayoutOut.lonaxis.range;
            delete geoLayoutOut.lataxis.range;
          } else {
            delete geoLayoutOut.center.lon;
            delete geoLayoutOut.center.lat;
            delete geoLayoutOut.projection.rotation.lon;
          }
        }
      }
    }
  });

  // src/plots/geo/index.js
  var require_geo2 = __commonJS({
    "src/plots/geo/index.js"(exports, module) {
      "use strict";
      var getSubplotCalcData = require_get_data().getSubplotCalcData;
      var counterRegex = require_lib().counterRegex;
      var createGeo = require_geo();
      var GEO = "geo";
      var counter = counterRegex(GEO);
      var attributes = {};
      attributes[GEO] = {
        valType: "subplotid",
        dflt: GEO,
        editType: "calc"
      };
      function plotGeo(gd) {
        var fullLayout = gd._fullLayout;
        var calcData = gd.calcdata;
        var geoIds = fullLayout._subplots[GEO];
        for (var i = 0; i < geoIds.length; i++) {
          var geoId = geoIds[i];
          var geoCalcData = getSubplotCalcData(calcData, GEO, geoId);
          var geoLayout = fullLayout[geoId];
          var geo = geoLayout._subplot;
          if (!geo) {
            geo = createGeo({
              id: geoId,
              graphDiv: gd,
              container: fullLayout._geolayer.node(),
              topojsonURL: gd._context.topojsonURL,
              staticPlot: gd._context.staticPlot
            });
            fullLayout[geoId]._subplot = geo;
          }
          geo.plot(geoCalcData, fullLayout, gd._promises);
        }
      }
      function clean(newFullData, newFullLayout, oldFullData, oldFullLayout) {
        var oldGeoKeys = oldFullLayout._subplots[GEO] || [];
        for (var i = 0; i < oldGeoKeys.length; i++) {
          var oldGeoKey = oldGeoKeys[i];
          var oldGeo = oldFullLayout[oldGeoKey]._subplot;
          if (!newFullLayout[oldGeoKey] && !!oldGeo) {
            oldGeo.framework.remove();
            oldGeo.clipDef.remove();
          }
        }
      }
      function updateFx(gd) {
        var fullLayout = gd._fullLayout;
        var subplotIds = fullLayout._subplots[GEO];
        for (var i = 0; i < subplotIds.length; i++) {
          var subplotLayout = fullLayout[subplotIds[i]];
          var subplotObj = subplotLayout._subplot;
          subplotObj.updateFx(fullLayout, subplotLayout);
        }
      }
      module.exports = {
        attr: GEO,
        name: GEO,
        idRoot: GEO,
        idRegex: counter,
        attrRegex: counter,
        attributes,
        layoutAttributes: require_layout_attributes6(),
        supplyLayoutDefaults: require_layout_defaults5(),
        plot: plotGeo,
        updateFx,
        clean
      };
    }
  });

  // src/traces/scattergeo/index.js
  var require_scattergeo = __commonJS({
    "src/traces/scattergeo/index.js"(exports, module) {
      "use strict";
      module.exports = {
        attributes: require_attributes23(),
        supplyDefaults: require_defaults19(),
        colorbar: require_marker_colorbar(),
        formatLabels: require_format_labels2(),
        calc: require_calc5(),
        calcGeoJSON: require_plot3().calcGeoJSON,
        plot: require_plot3().plot,
        style: require_style4(),
        styleOnSelect: require_style2().styleOnSelect,
        hoverPoints: require_hover3(),
        eventData: require_event_data(),
        selectPoints: require_select3(),
        moduleType: "trace",
        name: "scattergeo",
        basePlotModule: require_geo2(),
        categories: ["geo", "symbols", "showLegend", "scatter-like"],
        meta: {}
      };
    }
  });

  // lib/scattergeo.js
  var require_scattergeo2 = __commonJS({
    "lib/scattergeo.js"(exports, module) {
      "use strict";
      module.exports = require_scattergeo();
    }
  });

  // src/traces/choropleth/attributes.js
  var require_attributes24 = __commonJS({
    "src/traces/choropleth/attributes.js"(exports, module) {
      "use strict";
      var hovertemplateAttrs = require_template_attributes().hovertemplateAttrs;
      var scatterGeoAttrs = require_attributes23();
      var colorScaleAttrs = require_attributes8();
      var baseAttrs = require_attributes2();
      var defaultLine = require_attributes3().defaultLine;
      var extendFlat = require_extend().extendFlat;
      var scatterGeoMarkerLineAttrs = scatterGeoAttrs.marker.line;
      module.exports = extendFlat(
        {
          locations: {
            valType: "data_array",
            editType: "calc"
          },
          locationmode: scatterGeoAttrs.locationmode,
          z: {
            valType: "data_array",
            editType: "calc"
          },
          geojson: extendFlat({}, scatterGeoAttrs.geojson, {}),
          featureidkey: scatterGeoAttrs.featureidkey,
          text: extendFlat({}, scatterGeoAttrs.text, {}),
          hovertext: extendFlat({}, scatterGeoAttrs.hovertext, {}),
          marker: {
            line: {
              color: extendFlat({}, scatterGeoMarkerLineAttrs.color, { dflt: defaultLine }),
              width: extendFlat({}, scatterGeoMarkerLineAttrs.width, { dflt: 1 }),
              editType: "calc"
            },
            opacity: {
              valType: "number",
              arrayOk: true,
              min: 0,
              max: 1,
              dflt: 1,
              editType: "style"
            },
            editType: "calc"
          },
          selected: {
            marker: {
              opacity: scatterGeoAttrs.selected.marker.opacity,
              editType: "plot"
            },
            editType: "plot"
          },
          unselected: {
            marker: {
              opacity: scatterGeoAttrs.unselected.marker.opacity,
              editType: "plot"
            },
            editType: "plot"
          },
          hoverinfo: extendFlat({}, baseAttrs.hoverinfo, {
            editType: "calc",
            flags: ["location", "z", "text", "name"]
          }),
          hovertemplate: hovertemplateAttrs(),
          showlegend: extendFlat({}, baseAttrs.showlegend, { dflt: false })
        },
        colorScaleAttrs("", {
          cLetter: "z",
          editTypeOverride: "calc"
        })
      );
    }
  });

  // src/traces/choropleth/defaults.js
  var require_defaults20 = __commonJS({
    "src/traces/choropleth/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var colorscaleDefaults = require_defaults2();
      var attributes = require_attributes24();
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        var locations = coerce("locations");
        var z = coerce("z");
        if (!(locations && locations.length && Lib.isArrayOrTypedArray(z) && z.length)) {
          traceOut.visible = false;
          return;
        }
        traceOut._length = Math.min(locations.length, z.length);
        var geojson = coerce("geojson");
        var locationmodeDflt;
        if (typeof geojson === "string" && geojson !== "" || Lib.isPlainObject(geojson)) {
          locationmodeDflt = "geojson-id";
        }
        var locationMode = coerce("locationmode", locationmodeDflt);
        if (locationMode === "geojson-id") {
          coerce("featureidkey");
        }
        coerce("text");
        coerce("hovertext");
        coerce("hovertemplate");
        var mlw = coerce("marker.line.width");
        if (mlw) coerce("marker.line.color");
        coerce("marker.opacity");
        colorscaleDefaults(traceIn, traceOut, layout, coerce, { prefix: "", cLetter: "z" });
        Lib.coerceSelectionMarkerOpacity(traceOut, coerce);
      };
    }
  });

  // src/traces/heatmap/colorbar.js
  var require_colorbar2 = __commonJS({
    "src/traces/heatmap/colorbar.js"(exports, module) {
      "use strict";
      module.exports = {
        min: "zmin",
        max: "zmax"
      };
    }
  });

  // src/traces/choropleth/calc.js
  var require_calc6 = __commonJS({
    "src/traces/choropleth/calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var BADNUM = require_numerical().BADNUM;
      var colorscaleCalc = require_calc();
      var arraysToCalcdata = require_arrays_to_calcdata();
      var calcSelection = require_calc_selection();
      function isNonBlankString(v) {
        return v && typeof v === "string";
      }
      module.exports = function calc(gd, trace) {
        var len = trace._length;
        var calcTrace = new Array(len);
        var isValidLoc;
        if (trace.geojson) {
          isValidLoc = function(v) {
            return isNonBlankString(v) || isNumeric(v);
          };
        } else {
          isValidLoc = isNonBlankString;
        }
        for (var i = 0; i < len; i++) {
          var calcPt = calcTrace[i] = {};
          var loc = trace.locations[i];
          var z = trace.z[i];
          if (isValidLoc(loc) && isNumeric(z)) {
            calcPt.loc = loc;
            calcPt.z = z;
          } else {
            calcPt.loc = null;
            calcPt.z = BADNUM;
          }
          calcPt.index = i;
        }
        arraysToCalcdata(calcTrace, trace);
        colorscaleCalc(gd, trace, {
          vals: trace.z,
          containerStr: "",
          cLetter: "z"
        });
        calcSelection(calcTrace, trace);
        return calcTrace;
      };
    }
  });

  // src/traces/choropleth/style.js
  var require_style5 = __commonJS({
    "src/traces/choropleth/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Color = require_color();
      var Drawing = require_drawing();
      var Colorscale = require_colorscale();
      function style(gd, calcTrace) {
        if (calcTrace) styleTrace(gd, calcTrace);
      }
      function styleTrace(gd, calcTrace) {
        var trace = calcTrace[0].trace;
        var s = calcTrace[0].node3;
        var locs = s.selectAll(".choroplethlocation");
        var marker = trace.marker || {};
        var markerLine = marker.line || {};
        var sclFunc = Colorscale.makeColorScaleFuncFromTrace(trace);
        locs.each(function(d) {
          d3.select(this).attr("fill", sclFunc(d.z)).call(Color.stroke, d.mlc || markerLine.color).call(Drawing.dashLine, "", d.mlw || markerLine.width || 0).style("opacity", marker.opacity);
        });
        Drawing.selectedPointStyle(locs, trace);
      }
      function styleOnSelect(gd, calcTrace) {
        var s = calcTrace[0].node3;
        var trace = calcTrace[0].trace;
        if (trace.selectedpoints) {
          Drawing.selectedPointStyle(s.selectAll(".choroplethlocation"), trace);
        } else {
          styleTrace(gd, calcTrace);
        }
      }
      module.exports = {
        style,
        styleOnSelect
      };
    }
  });

  // src/traces/choropleth/plot.js
  var require_plot4 = __commonJS({
    "src/traces/choropleth/plot.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var geoUtils = require_geo_location_utils();
      var getTopojsonFeatures = require_topojson_utils().getTopojsonFeatures;
      var findExtremes = require_autorange().findExtremes;
      var style = require_style5().style;
      function plot(gd, geo, calcData) {
        var choroplethLayer = geo.layers.backplot.select(".choroplethlayer");
        Lib.makeTraceGroups(choroplethLayer, calcData, "trace choropleth").each(function(calcTrace) {
          var sel = d3.select(this);
          var paths = sel.selectAll("path.choroplethlocation").data(Lib.identity);
          paths.enter().append("path").classed("choroplethlocation", true);
          paths.exit().remove();
          style(gd, calcTrace);
        });
      }
      function calcGeoJSON(calcTrace, fullLayout) {
        var trace = calcTrace[0].trace;
        var geoLayout = fullLayout[trace.geo];
        var geo = geoLayout._subplot;
        var locationmode = trace.locationmode;
        var len = trace._length;
        var features = locationmode === "geojson-id" ? geoUtils.extractTraceFeature(calcTrace) : getTopojsonFeatures(trace, geo.topojson);
        var lonArray = [];
        var latArray = [];
        for (var i = 0; i < len; i++) {
          var calcPt = calcTrace[i];
          var feature = locationmode === "geojson-id" ? calcPt.fOut : geoUtils.locationToFeature(locationmode, calcPt.loc, features);
          if (feature) {
            calcPt.geojson = feature;
            calcPt.ct = feature.properties.ct;
            calcPt._polygons = geoUtils.feature2polygons(feature);
            var bboxFeature = geoUtils.computeBbox(feature);
            lonArray.push(bboxFeature[0], bboxFeature[2]);
            latArray.push(bboxFeature[1], bboxFeature[3]);
          } else {
            calcPt.geojson = null;
          }
        }
        if (geoLayout.fitbounds === "geojson" && locationmode === "geojson-id") {
          var bboxGeojson = geoUtils.computeBbox(geoUtils.getTraceGeojson(trace));
          lonArray = [bboxGeojson[0], bboxGeojson[2]];
          latArray = [bboxGeojson[1], bboxGeojson[3]];
        }
        var opts = { padded: true };
        trace._extremes.lon = findExtremes(geoLayout.lonaxis._ax, lonArray, opts);
        trace._extremes.lat = findExtremes(geoLayout.lataxis._ax, latArray, opts);
      }
      module.exports = {
        calcGeoJSON,
        plot
      };
    }
  });

  // src/traces/choropleth/hover.js
  var require_hover4 = __commonJS({
    "src/traces/choropleth/hover.js"(exports, module) {
      "use strict";
      var Axes = require_axes();
      var attributes = require_attributes24();
      var fillText = require_lib().fillText;
      module.exports = function hoverPoints(pointData, xval, yval) {
        var cd = pointData.cd;
        var trace = cd[0].trace;
        var geo = pointData.subplot;
        var pt, i, j, isInside;
        var xy = [xval, yval];
        var altXy = [xval + 360, yval];
        for (i = 0; i < cd.length; i++) {
          pt = cd[i];
          isInside = false;
          if (pt._polygons) {
            for (j = 0; j < pt._polygons.length; j++) {
              if (pt._polygons[j].contains(xy)) {
                isInside = !isInside;
              }
              if (pt._polygons[j].contains(altXy)) {
                isInside = !isInside;
              }
            }
            if (isInside) break;
          }
        }
        if (!isInside || !pt) return;
        pointData.x0 = pointData.x1 = pointData.xa.c2p(pt.ct);
        pointData.y0 = pointData.y1 = pointData.ya.c2p(pt.ct);
        pointData.index = pt.index;
        pointData.location = pt.loc;
        pointData.z = pt.z;
        pointData.zLabel = Axes.tickText(geo.mockAxis, geo.mockAxis.c2l(pt.z), "hover").text;
        pointData.hovertemplate = pt.hovertemplate;
        makeHoverInfo(pointData, trace, pt);
        return [pointData];
      };
      function makeHoverInfo(pointData, trace, pt) {
        if (trace.hovertemplate) return;
        var hoverinfo = pt.hi || trace.hoverinfo;
        var loc = String(pt.loc);
        var parts = hoverinfo === "all" ? attributes.hoverinfo.flags : hoverinfo.split("+");
        var hasName = parts.indexOf("name") !== -1;
        var hasLocation = parts.indexOf("location") !== -1;
        var hasZ = parts.indexOf("z") !== -1;
        var hasText = parts.indexOf("text") !== -1;
        var hasIdAsNameLabel = !hasName && hasLocation;
        var text = [];
        if (hasIdAsNameLabel) {
          pointData.nameOverride = loc;
        } else {
          if (hasName) pointData.nameOverride = trace.name;
          if (hasLocation) text.push(loc);
        }
        if (hasZ) {
          text.push(pointData.zLabel);
        }
        if (hasText) {
          fillText(pt, trace, text);
        }
        pointData.extraText = text.join("<br>");
      }
    }
  });

  // src/traces/choropleth/event_data.js
  var require_event_data2 = __commonJS({
    "src/traces/choropleth/event_data.js"(exports, module) {
      "use strict";
      module.exports = function eventData(out, pt, trace, cd, pointNumber) {
        out.location = pt.location;
        out.z = pt.z;
        var cdi = cd[pointNumber];
        if (cdi.fIn && cdi.fIn.properties) {
          out.properties = cdi.fIn.properties;
        }
        out.ct = cdi.ct;
        return out;
      };
    }
  });

  // src/traces/choropleth/select.js
  var require_select4 = __commonJS({
    "src/traces/choropleth/select.js"(exports, module) {
      "use strict";
      module.exports = function selectPoints(searchInfo, selectionTester) {
        var cd = searchInfo.cd;
        var xa = searchInfo.xaxis;
        var ya = searchInfo.yaxis;
        var selection = [];
        var i, di, ct, x, y;
        if (selectionTester === false) {
          for (i = 0; i < cd.length; i++) {
            cd[i].selected = 0;
          }
        } else {
          for (i = 0; i < cd.length; i++) {
            di = cd[i];
            ct = di.ct;
            if (!ct) continue;
            x = xa.c2p(ct);
            y = ya.c2p(ct);
            if (selectionTester.contains([x, y], null, i, searchInfo)) {
              selection.push({
                pointNumber: i,
                lon: ct[0],
                lat: ct[1]
              });
              di.selected = 1;
            } else {
              di.selected = 0;
            }
          }
        }
        return selection;
      };
    }
  });

  // src/traces/choropleth/index.js
  var require_choropleth = __commonJS({
    "src/traces/choropleth/index.js"(exports, module) {
      "use strict";
      module.exports = {
        attributes: require_attributes24(),
        supplyDefaults: require_defaults20(),
        colorbar: require_colorbar2(),
        calc: require_calc6(),
        calcGeoJSON: require_plot4().calcGeoJSON,
        plot: require_plot4().plot,
        style: require_style5().style,
        styleOnSelect: require_style5().styleOnSelect,
        hoverPoints: require_hover4(),
        eventData: require_event_data2(),
        selectPoints: require_select4(),
        moduleType: "trace",
        name: "choropleth",
        basePlotModule: require_geo2(),
        categories: ["geo", "noOpacity", "showLegend"],
        meta: {}
      };
    }
  });

  // lib/choropleth.js
  var require_choropleth2 = __commonJS({
    "lib/choropleth.js"(exports, module) {
      "use strict";
      module.exports = require_choropleth();
    }
  });

  // node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "node_modules/object-assign/index.js"(exports, module) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);
          for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
              to[key] = from[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }
  });

  // node_modules/world-calendars/dist/main.js
  var require_main = __commonJS({
    "node_modules/world-calendars/dist/main.js"(exports, module) {
      var assign = require_object_assign();
      function Calendars() {
        this.regionalOptions = [];
        this.regionalOptions[""] = {
          invalidCalendar: "Calendar {0} not found",
          invalidDate: "Invalid {0} date",
          invalidMonth: "Invalid {0} month",
          invalidYear: "Invalid {0} year",
          differentCalendars: "Cannot mix {0} and {1} dates"
        };
        this.local = this.regionalOptions[""];
        this.calendars = {};
        this._localCals = {};
      }
      assign(Calendars.prototype, {
        /** Obtain a calendar implementation and localisation.
            @memberof Calendars
            @param [name='gregorian'] {string} The name of the calendar, e.g. 'gregorian', 'persian', 'islamic'.
            @param [language=''] {string} The language code to use for localisation (default is English).
            @return {Calendar} The calendar and localisation.
            @throws Error if calendar not found. */
        instance: function(name, language) {
          name = (name || "gregorian").toLowerCase();
          language = language || "";
          var cal = this._localCals[name + "-" + language];
          if (!cal && this.calendars[name]) {
            cal = new this.calendars[name](language);
            this._localCals[name + "-" + language] = cal;
          }
          if (!cal) {
            throw (this.local.invalidCalendar || this.regionalOptions[""].invalidCalendar).replace(/\{0\}/, name);
          }
          return cal;
        },
        /** Create a new date - for today if no other parameters given.
            @memberof Calendars
            @param year {CDate|number} The date to copy or the year for the date.
            @param [month] {number} The month for the date.
            @param [day] {number} The day for the date.
            @param [calendar='gregorian'] {BaseCalendar|string} The underlying calendar or the name of the calendar.
            @param [language=''] {string} The language to use for localisation (default English).
            @return {CDate} The new date.
            @throws Error if an invalid date. */
        newDate: function(year, month, day, calendar, language) {
          calendar = (year != null && year.year ? year.calendar() : typeof calendar === "string" ? this.instance(calendar, language) : calendar) || this.instance();
          return calendar.newDate(year, month, day);
        },
        /** A simple digit substitution function for localising numbers via the Calendar digits option.
            @member Calendars
            @param digits {string[]} The substitute digits, for 0 through 9.
            @return {function} The substitution function. */
        substituteDigits: function(digits) {
          return function(value) {
            return (value + "").replace(/[0-9]/g, function(digit) {
              return digits[digit];
            });
          };
        },
        /** Digit substitution function for localising Chinese style numbers via the Calendar digits option.
            @member Calendars
            @param digits {string[]} The substitute digits, for 0 through 9.
            @param powers {string[]} The characters denoting powers of 10, i.e. 1, 10, 100, 1000.
            @return {function} The substitution function. */
        substituteChineseDigits: function(digits, powers) {
          return function(value) {
            var localNumber = "";
            var power = 0;
            while (value > 0) {
              var units = value % 10;
              localNumber = (units === 0 ? "" : digits[units] + powers[power]) + localNumber;
              power++;
              value = Math.floor(value / 10);
            }
            if (localNumber.indexOf(digits[1] + powers[1]) === 0) {
              localNumber = localNumber.substr(1);
            }
            return localNumber || digits[0];
          };
        }
      });
      function CDate(calendar, year, month, day) {
        this._calendar = calendar;
        this._year = year;
        this._month = month;
        this._day = day;
        if (this._calendar._validateLevel === 0 && !this._calendar.isValid(this._year, this._month, this._day)) {
          throw (_exports.local.invalidDate || _exports.regionalOptions[""].invalidDate).replace(/\{0\}/, this._calendar.local.name);
        }
      }
      function pad(value, length) {
        value = "" + value;
        return "000000".substring(0, length - value.length) + value;
      }
      assign(CDate.prototype, {
        /** Create a new date.
            @memberof CDate
            @param [year] {CDate|number} The date to copy or the year for the date (default this date).
            @param [month] {number} The month for the date.
            @param [day] {number} The day for the date.
            @return {CDate} The new date.
            @throws Error if an invalid date. */
        newDate: function(year, month, day) {
          return this._calendar.newDate(year == null ? this : year, month, day);
        },
        /** Set or retrieve the year for this date.
            @memberof CDate
            @param [year] {number} The year for the date.
            @return {number|CDate} The date's year (if no parameter) or the updated date.
            @throws Error if an invalid date. */
        year: function(year) {
          return arguments.length === 0 ? this._year : this.set(year, "y");
        },
        /** Set or retrieve the month for this date.
            @memberof CDate
            @param [month] {number} The month for the date.
            @return {number|CDate} The date's month (if no parameter) or the updated date.
            @throws Error if an invalid date. */
        month: function(month) {
          return arguments.length === 0 ? this._month : this.set(month, "m");
        },
        /** Set or retrieve the day for this date.
            @memberof CDate
            @param [day] {number} The day for the date.
            @return {number|CData} The date's day (if no parameter) or the updated date.
            @throws Error if an invalid date. */
        day: function(day) {
          return arguments.length === 0 ? this._day : this.set(day, "d");
        },
        /** Set new values for this date.
            @memberof CDate
            @param year {number} The year for the date.
            @param month {number} The month for the date.
            @param day {number} The day for the date.
            @return {CDate} The updated date.
            @throws Error if an invalid date. */
        date: function(year, month, day) {
          if (!this._calendar.isValid(year, month, day)) {
            throw (_exports.local.invalidDate || _exports.regionalOptions[""].invalidDate).replace(/\{0\}/, this._calendar.local.name);
          }
          this._year = year;
          this._month = month;
          this._day = day;
          return this;
        },
        /** Determine whether this date is in a leap year.
            @memberof CDate
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not. */
        leapYear: function() {
          return this._calendar.leapYear(this);
        },
        /** Retrieve the epoch designator for this date, e.g. BCE or CE.
            @memberof CDate
            @return {string} The current epoch. */
        epoch: function() {
          return this._calendar.epoch(this);
        },
        /** Format the year, if not a simple sequential number.
            @memberof CDate
            @return {string} The formatted year. */
        formatYear: function() {
          return this._calendar.formatYear(this);
        },
        /** Retrieve the month of the year for this date,
            i.e. the month's position within a numbered year.
            @memberof CDate
            @return {number} The month of the year: <code>minMonth</code> to months per year. */
        monthOfYear: function() {
          return this._calendar.monthOfYear(this);
        },
        /** Retrieve the week of the year for this date.
            @memberof CDate
            @return {number} The week of the year: 1 to weeks per year. */
        weekOfYear: function() {
          return this._calendar.weekOfYear(this);
        },
        /** Retrieve the number of days in the year for this date.
            @memberof CDate
            @return {number} The number of days in this year. */
        daysInYear: function() {
          return this._calendar.daysInYear(this);
        },
        /** Retrieve the day of the year for this date.
            @memberof CDate
            @return {number} The day of the year: 1 to days per year. */
        dayOfYear: function() {
          return this._calendar.dayOfYear(this);
        },
        /** Retrieve the number of days in the month for this date.
            @memberof CDate
            @return {number} The number of days. */
        daysInMonth: function() {
          return this._calendar.daysInMonth(this);
        },
        /** Retrieve the day of the week for this date.
            @memberof CDate
            @return {number} The day of the week: 0 to number of days - 1. */
        dayOfWeek: function() {
          return this._calendar.dayOfWeek(this);
        },
        /** Determine whether this date is a week day.
            @memberof CDate
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not. */
        weekDay: function() {
          return this._calendar.weekDay(this);
        },
        /** Retrieve additional information about this date.
            @memberof CDate
            @return {object} Additional information - contents depends on calendar. */
        extraInfo: function() {
          return this._calendar.extraInfo(this);
        },
        /** Add period(s) to a date.
            @memberof CDate
            @param offset {number} The number of periods to adjust by.
            @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
            @return {CDate} The updated date. */
        add: function(offset, period) {
          return this._calendar.add(this, offset, period);
        },
        /** Set a portion of the date.
            @memberof CDate
            @param value {number} The new value for the period.
            @param period {string} One of 'y' for year, 'm' for month, 'd' for day.
            @return {CDate} The updated date.
            @throws Error if not a valid date. */
        set: function(value, period) {
          return this._calendar.set(this, value, period);
        },
        /** Compare this date to another date.
            @memberof CDate
            @param date {CDate} The other date.
            @return {number} -1 if this date is before the other date,
                    0 if they are equal, or +1 if this date is after the other date. */
        compareTo: function(date) {
          if (this._calendar.name !== date._calendar.name) {
            throw (_exports.local.differentCalendars || _exports.regionalOptions[""].differentCalendars).replace(/\{0\}/, this._calendar.local.name).replace(/\{1\}/, date._calendar.local.name);
          }
          var c = this._year !== date._year ? this._year - date._year : this._month !== date._month ? this.monthOfYear() - date.monthOfYear() : this._day - date._day;
          return c === 0 ? 0 : c < 0 ? -1 : 1;
        },
        /** Retrieve the calendar backing this date.
            @memberof CDate
            @return {BaseCalendar} The calendar implementation. */
        calendar: function() {
          return this._calendar;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof CDate
            @return {number} The equivalent Julian date. */
        toJD: function() {
          return this._calendar.toJD(this);
        },
        /** Create a new date from a Julian date.
            @memberof CDate
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          return this._calendar.fromJD(jd);
        },
        /** Convert this date to a standard (Gregorian) JavaScript Date.
            @memberof CDate
            @return {Date} The equivalent JavaScript date. */
        toJSDate: function() {
          return this._calendar.toJSDate(this);
        },
        /** Create a new date from a standard (Gregorian) JavaScript Date.
            @memberof CDate
            @param jsd {Date} The JavaScript date to convert.
            @return {CDate} The equivalent date. */
        fromJSDate: function(jsd) {
          return this._calendar.fromJSDate(jsd);
        },
        /** Convert to a string for display.
            @memberof CDate
            @return {string} This date as a string. */
        toString: function() {
          return (this.year() < 0 ? "-" : "") + pad(Math.abs(this.year()), 4) + "-" + pad(this.month(), 2) + "-" + pad(this.day(), 2);
        }
      });
      function BaseCalendar() {
        this.shortYearCutoff = "+10";
      }
      assign(BaseCalendar.prototype, {
        _validateLevel: 0,
        // "Stack" to turn validation on/off
        /** Create a new date within this calendar - today if no parameters given.
            @memberof BaseCalendar
            @param year {CDate|number} The date to duplicate or the year for the date.
            @param [month] {number} The month for the date.
            @param [day] {number} The day for the date.
            @return {CDate} The new date.
            @throws Error if not a valid date or a different calendar used. */
        newDate: function(year, month, day) {
          if (year == null) {
            return this.today();
          }
          if (year.year) {
            this._validate(
              year,
              month,
              day,
              _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
            );
            day = year.day();
            month = year.month();
            year = year.year();
          }
          return new CDate(this, year, month, day);
        },
        /** Create a new date for today.
            @memberof BaseCalendar
            @return {CDate} Today's date. */
        today: function() {
          return this.fromJSDate(/* @__PURE__ */ new Date());
        },
        /** Retrieve the epoch designator for this date.
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {string} The current epoch.
            @throws Error if an invalid year or a different calendar used. */
        epoch: function(year) {
          var date = this._validate(
            year,
            this.minMonth,
            this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[""].invalidYear
          );
          return date.year() < 0 ? this.local.epochs[0] : this.local.epochs[1];
        },
        /** Format the year, if not a simple sequential number
            @memberof BaseCalendar
            @param year {CDate|number} The date to format or the year to format.
            @return {string} The formatted year.
            @throws Error if an invalid year or a different calendar used. */
        formatYear: function(year) {
          var date = this._validate(
            year,
            this.minMonth,
            this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[""].invalidYear
          );
          return (date.year() < 0 ? "-" : "") + pad(Math.abs(date.year()), 4);
        },
        /** Retrieve the number of months in a year.
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(
            year,
            this.minMonth,
            this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[""].invalidYear
          );
          return 12;
        },
        /** Calculate the month's ordinal position within the year -
            for those calendars that don't start at month 1!
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param month {number} The month to examine.
            @return {number} The ordinal position, starting from <code>minMonth</code>.
            @throws Error if an invalid year/month or a different calendar used. */
        monthOfYear: function(year, month) {
          var date = this._validate(
            year,
            month,
            this.minDay,
            _exports.local.invalidMonth || _exports.regionalOptions[""].invalidMonth
          );
          return (date.month() + this.monthsInYear(date) - this.firstMonth) % this.monthsInYear(date) + this.minMonth;
        },
        /** Calculate actual month from ordinal position, starting from minMonth.
            @memberof BaseCalendar
            @param year {number} The year to examine.
            @param ord {number} The month's ordinal position.
            @return {number} The month's number.
            @throws Error if an invalid year/month. */
        fromMonthOfYear: function(year, ord) {
          var m = (ord + this.firstMonth - 2 * this.minMonth) % this.monthsInYear(year) + this.minMonth;
          this._validate(
            year,
            m,
            this.minDay,
            _exports.local.invalidMonth || _exports.regionalOptions[""].invalidMonth
          );
          return m;
        },
        /** Retrieve the number of days in a year.
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          var date = this._validate(
            year,
            this.minMonth,
            this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[""].invalidYear
          );
          return this.leapYear(date) ? 366 : 365;
        },
        /** Retrieve the day of the year for a date.
            @memberof BaseCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The day of the year.
            @throws Error if an invalid date or a different calendar used. */
        dayOfYear: function(year, month, day) {
          var date = this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          return date.toJD() - this.newDate(
            date.year(),
            this.fromMonthOfYear(date.year(), this.minMonth),
            this.minDay
          ).toJD() + 1;
        },
        /** Retrieve the number of days in a week.
            @memberof BaseCalendar
            @return {number} The number of days. */
        daysInWeek: function() {
          return 7;
        },
        /** Retrieve the day of the week for a date.
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The day of the week: 0 to number of days - 1.
            @throws Error if an invalid date or a different calendar used. */
        dayOfWeek: function(year, month, day) {
          var date = this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          return (Math.floor(this.toJD(date)) + 2) % this.daysInWeek();
        },
        /** Retrieve additional information about a date.
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {object} Additional information - contents depends on calendar.
            @throws Error if an invalid date or a different calendar used. */
        extraInfo: function(year, month, day) {
          this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          return {};
        },
        /** Add period(s) to a date.
            Cater for no year zero.
            @memberof BaseCalendar
            @param date {CDate} The starting date.
            @param offset {number} The number of periods to adjust by.
            @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
            @return {CDate} The updated date.
            @throws Error if a different calendar used. */
        add: function(date, offset, period) {
          this._validate(
            date,
            this.minMonth,
            this.minDay,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          return this._correctAdd(date, this._add(date, offset, period), offset, period);
        },
        /** Add period(s) to a date.
            @memberof BaseCalendar
            @private
            @param date {CDate} The starting date.
            @param offset {number} The number of periods to adjust by.
            @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
            @return {CDate} The updated date. */
        _add: function(date, offset, period) {
          this._validateLevel++;
          if (period === "d" || period === "w") {
            var jd = date.toJD() + offset * (period === "w" ? this.daysInWeek() : 1);
            var d = date.calendar().fromJD(jd);
            this._validateLevel--;
            return [d.year(), d.month(), d.day()];
          }
          try {
            var y = date.year() + (period === "y" ? offset : 0);
            var m = date.monthOfYear() + (period === "m" ? offset : 0);
            var d = date.day();
            var resyncYearMonth = function(calendar) {
              while (m < calendar.minMonth) {
                y--;
                m += calendar.monthsInYear(y);
              }
              var yearMonths = calendar.monthsInYear(y);
              while (m > yearMonths - 1 + calendar.minMonth) {
                y++;
                m -= yearMonths;
                yearMonths = calendar.monthsInYear(y);
              }
            };
            if (period === "y") {
              if (date.month() !== this.fromMonthOfYear(y, m)) {
                m = this.newDate(y, date.month(), this.minDay).monthOfYear();
              }
              m = Math.min(m, this.monthsInYear(y));
              d = Math.min(d, this.daysInMonth(y, this.fromMonthOfYear(y, m)));
            } else if (period === "m") {
              resyncYearMonth(this);
              d = Math.min(d, this.daysInMonth(y, this.fromMonthOfYear(y, m)));
            }
            var ymd = [y, this.fromMonthOfYear(y, m), d];
            this._validateLevel--;
            return ymd;
          } catch (e) {
            this._validateLevel--;
            throw e;
          }
        },
        /** Correct a candidate date after adding period(s) to a date.
            Handle no year zero if necessary.
            @memberof BaseCalendar
            @private
            @param date {CDate} The starting date.
            @param ymd {number[]} The added date.
            @param offset {number} The number of periods to adjust by.
            @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
            @return {CDate} The updated date. */
        _correctAdd: function(date, ymd, offset, period) {
          if (!this.hasYearZero && (period === "y" || period === "m")) {
            if (ymd[0] === 0 || // In year zero
            date.year() > 0 !== ymd[0] > 0) {
              var adj = {
                y: [1, 1, "y"],
                m: [1, this.monthsInYear(-1), "m"],
                w: [this.daysInWeek(), this.daysInYear(-1), "d"],
                d: [1, this.daysInYear(-1), "d"]
              }[period];
              var dir = offset < 0 ? -1 : 1;
              ymd = this._add(date, offset * adj[0] + dir * adj[1], adj[2]);
            }
          }
          return date.date(ymd[0], ymd[1], ymd[2]);
        },
        /** Set a portion of the date.
            @memberof BaseCalendar
            @param date {CDate} The starting date.
            @param value {number} The new value for the period.
            @param period {string} One of 'y' for year, 'm' for month, 'd' for day.
            @return {CDate} The updated date.
            @throws Error if an invalid date or a different calendar used. */
        set: function(date, value, period) {
          this._validate(
            date,
            this.minMonth,
            this.minDay,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          var y = period === "y" ? value : date.year();
          var m = period === "m" ? value : date.month();
          var d = period === "d" ? value : date.day();
          if (period === "y" || period === "m") {
            d = Math.min(d, this.daysInMonth(y, m));
          }
          return date.date(y, m, d);
        },
        /** Determine whether a date is valid for this calendar.
            @memberof BaseCalendar
            @param year {number} The year to examine.
            @param month {number} The month to examine.
            @param day {number} The day to examine.
            @return {boolean} <code>true</code> if a valid date, <code>false</code> if not. */
        isValid: function(year, month, day) {
          this._validateLevel++;
          var valid = this.hasYearZero || year !== 0;
          if (valid) {
            var date = this.newDate(year, month, this.minDay);
            valid = month >= this.minMonth && month - this.minMonth < this.monthsInYear(date) && (day >= this.minDay && day - this.minDay < this.daysInMonth(date));
          }
          this._validateLevel--;
          return valid;
        },
        /** Convert the date to a standard (Gregorian) JavaScript Date.
            @memberof BaseCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {Date} The equivalent JavaScript date.
            @throws Error if an invalid date or a different calendar used. */
        toJSDate: function(year, month, day) {
          var date = this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          return _exports.instance().fromJD(this.toJD(date)).toJSDate();
        },
        /** Convert the date from a standard (Gregorian) JavaScript Date.
            @memberof BaseCalendar
            @param jsd {Date} The JavaScript date.
            @return {CDate} The equivalent calendar date. */
        fromJSDate: function(jsd) {
          return this.fromJD(_exports.instance().fromJSDate(jsd).toJD());
        },
        /** Check that a candidate date is from the same calendar and is valid.
            @memberof BaseCalendar
            @private
            @param year {CDate|number} The date to validate or the year to validate.
            @param [month] {number} The month to validate.
            @param [day] {number} The day to validate.
            @param error {string} Rrror message if invalid.
            @throws Error if different calendars used or invalid date. */
        _validate: function(year, month, day, error) {
          if (year.year) {
            if (this._validateLevel === 0 && this.name !== year.calendar().name) {
              throw (_exports.local.differentCalendars || _exports.regionalOptions[""].differentCalendars).replace(/\{0\}/, this.local.name).replace(/\{1\}/, year.calendar().local.name);
            }
            return year;
          }
          try {
            this._validateLevel++;
            if (this._validateLevel === 1 && !this.isValid(year, month, day)) {
              throw error.replace(/\{0\}/, this.local.name);
            }
            var date = this.newDate(year, month, day);
            this._validateLevel--;
            return date;
          } catch (e) {
            this._validateLevel--;
            throw e;
          }
        }
      });
      function GregorianCalendar(language) {
        this.local = this.regionalOptions[language] || this.regionalOptions[""];
      }
      GregorianCalendar.prototype = new BaseCalendar();
      assign(GregorianCalendar.prototype, {
        /** The calendar name.
            @memberof GregorianCalendar */
        name: "Gregorian",
        /** Julian date of start of Gregorian epoch: 1 January 0001 CE.
           @memberof GregorianCalendar */
        jdEpoch: 17214255e-1,
        /** Days per month in a common year.
           @memberof GregorianCalendar */
        daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
           @memberof GregorianCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof GregorianCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof GregorianCalendar */
        firstMonth: 1,
        /** The minimum day number.
           @memberof GregorianCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof GregorianCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Gregorian",
            epochs: ["BCE", "CE"],
            monthNames: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "mm/dd/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(
            year,
            this.minMonth,
            this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[""].invalidYear
          );
          var year = date.year() + (date.year() < 0 ? 1 : 0);
          return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        },
        /** Determine the week of the year for a date - ISO 8601.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year, starting from 1.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(4 - (checkDate.dayOfWeek() || 7), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(
            year,
            month,
            this.minDay,
            _exports.local.invalidMonth || _exports.regionalOptions[""].invalidMonth
          );
          return this.daysPerMonth[date.month() - 1] + (date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          year = date.year();
          month = date.month();
          day = date.day();
          if (year < 0) {
            year++;
          }
          if (month < 3) {
            month += 12;
            year--;
          }
          var a = Math.floor(year / 100);
          var b = 2 - a + Math.floor(a / 4);
          return Math.floor(365.25 * (year + 4716)) + Math.floor(30.6001 * (month + 1)) + day + b - 1524.5;
        },
        /** Create a new date from a Julian date.
            @memberof GregorianCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var z = Math.floor(jd + 0.5);
          var a = Math.floor((z - 186721625e-2) / 36524.25);
          a = z + 1 + a - Math.floor(a / 4);
          var b = a + 1524;
          var c = Math.floor((b - 122.1) / 365.25);
          var d = Math.floor(365.25 * c);
          var e = Math.floor((b - d) / 30.6001);
          var day = b - d - Math.floor(e * 30.6001);
          var month = e - (e > 13.5 ? 13 : 1);
          var year = c - (month > 2.5 ? 4716 : 4715);
          if (year <= 0) {
            year--;
          }
          return this.newDate(year, month, day);
        },
        /** Convert this date to a standard (Gregorian) JavaScript Date.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {Date} The equivalent JavaScript date.
            @throws Error if an invalid date or a different calendar used. */
        toJSDate: function(year, month, day) {
          var date = this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          var jsd = new Date(date.year(), date.month() - 1, date.day());
          jsd.setHours(0);
          jsd.setMinutes(0);
          jsd.setSeconds(0);
          jsd.setMilliseconds(0);
          jsd.setHours(jsd.getHours() > 12 ? jsd.getHours() + 2 : 0);
          return jsd;
        },
        /** Create a new date from a standard (Gregorian) JavaScript Date.
            @memberof GregorianCalendar
            @param jsd {Date} The JavaScript date to convert.
            @return {CDate} The equivalent date. */
        fromJSDate: function(jsd) {
          return this.newDate(jsd.getFullYear(), jsd.getMonth() + 1, jsd.getDate());
        }
      });
      var _exports = module.exports = new Calendars();
      _exports.cdate = CDate;
      _exports.baseCalendar = BaseCalendar;
      _exports.calendars.gregorian = GregorianCalendar;
    }
  });

  // node_modules/world-calendars/dist/plus.js
  var require_plus = __commonJS({
    "node_modules/world-calendars/dist/plus.js"() {
      var assign = require_object_assign();
      var main = require_main();
      assign(main.regionalOptions[""], {
        invalidArguments: "Invalid arguments",
        invalidFormat: "Cannot format a date from another calendar",
        missingNumberAt: "Missing number at position {0}",
        unknownNameAt: "Unknown name at position {0}",
        unexpectedLiteralAt: "Unexpected literal at position {0}",
        unexpectedText: "Additional text found at end"
      });
      main.local = main.regionalOptions[""];
      assign(main.cdate.prototype, {
        /** Format this date.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof CDate
            @param [format] {string} The date format to use (see <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a>).
            @param [settings] {object} Options for the <code>formatDate</code> function.
            @return {string} The formatted date. */
        formatDate: function(format, settings) {
          if (typeof format !== "string") {
            settings = format;
            format = "";
          }
          return this._calendar.formatDate(format || "", this, settings);
        }
      });
      assign(main.baseCalendar.prototype, {
        UNIX_EPOCH: main.instance().newDate(1970, 1, 1).toJD(),
        SECS_PER_DAY: 24 * 60 * 60,
        TICKS_EPOCH: main.instance().jdEpoch,
        // 1 January 0001 CE
        TICKS_PER_DAY: 24 * 60 * 60 * 1e7,
        /** Date form for ATOM (RFC 3339/ISO 8601).
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        ATOM: "yyyy-mm-dd",
        /** Date form for cookies.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        COOKIE: "D, dd M yyyy",
        /** Date form for full date.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        FULL: "DD, MM d, yyyy",
        /** Date form for ISO 8601.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        ISO_8601: "yyyy-mm-dd",
        /** Date form for Julian date.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        JULIAN: "J",
        /** Date form for RFC 822.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RFC_822: "D, d M yy",
        /** Date form for RFC 850.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RFC_850: "DD, dd-M-yy",
        /** Date form for RFC 1036.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RFC_1036: "D, d M yy",
        /** Date form for RFC 1123.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RFC_1123: "D, d M yyyy",
        /** Date form for RFC 2822.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RFC_2822: "D, d M yyyy",
        /** Date form for RSS (RFC 822).
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RSS: "D, d M yy",
        /** Date form for Windows ticks.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        TICKS: "!",
        /** Date form for Unix timestamp.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        TIMESTAMP: "@",
        /** Date form for W3c (ISO 8601).
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        W3C: "yyyy-mm-dd",
        /** Format a date object into a string value.
            The format can be combinations of the following:
            <ul>
            <li>d  - day of month (no leading zero)</li>
            <li>dd - day of month (two digit)</li>
            <li>o  - day of year (no leading zeros)</li>
            <li>oo - day of year (three digit)</li>
            <li>D  - day name short</li>
            <li>DD - day name long</li>
            <li>w  - week of year (no leading zero)</li>
            <li>ww - week of year (two digit)</li>
            <li>m  - month of year (no leading zero)</li>
            <li>mm - month of year (two digit)</li>
            <li>M  - month name short</li>
            <li>MM - month name long</li>
            <li>yy - year (two digit)</li>
            <li>yyyy - year (four digit)</li>
            <li>YYYY - formatted year</li>
            <li>J  - Julian date (days since January 1, 4713 BCE Greenwich noon)</li>
            <li>@  - Unix timestamp (s since 01/01/1970)</li>
            <li>!  - Windows ticks (100ns since 01/01/0001)</li>
            <li>'...' - literal text</li>
            <li>'' - single quote</li>
            </ul>
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar
            @param [format] {string} The desired format of the date (defaults to calendar format).
            @param date {CDate} The date value to format.
            @param [settings] {object} Addition options, whose attributes include:
            @property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
            @property [dayNames] {string[]} Names of the days from Sunday.
            @property [monthNamesShort] {string[]} Abbreviated names of the months.
            @property [monthNames] {string[]} Names of the months.
            @property [calculateWeek] {CalendarsPickerCalculateWeek} Function that determines week of the year.
            @property [localNumbers=false] {boolean} <code>true</code> to localise numbers (if available),
                      <code>false</code> to use normal Arabic numerals.
            @return {string} The date in the above format.
            @throws Errors if the date is from a different calendar. */
        formatDate: function(format, date, settings) {
          if (typeof format !== "string") {
            settings = date;
            date = format;
            format = "";
          }
          if (!date) {
            return "";
          }
          if (date.calendar() !== this) {
            throw main.local.invalidFormat || main.regionalOptions[""].invalidFormat;
          }
          format = format || this.local.dateFormat;
          settings = settings || {};
          var dayNamesShort = settings.dayNamesShort || this.local.dayNamesShort;
          var dayNames = settings.dayNames || this.local.dayNames;
          var monthNumbers = settings.monthNumbers || this.local.monthNumbers;
          var monthNamesShort = settings.monthNamesShort || this.local.monthNamesShort;
          var monthNames = settings.monthNames || this.local.monthNames;
          var calculateWeek = settings.calculateWeek || this.local.calculateWeek;
          var doubled = function(match, step) {
            var matches = 1;
            while (iFormat + matches < format.length && format.charAt(iFormat + matches) === match) {
              matches++;
            }
            iFormat += matches - 1;
            return Math.floor(matches / (step || 1)) > 1;
          };
          var formatNumber = function(match, value, len, step) {
            var num = "" + value;
            if (doubled(match, step)) {
              while (num.length < len) {
                num = "0" + num;
              }
            }
            return num;
          };
          var formatName = function(match, value, shortNames, longNames) {
            return doubled(match) ? longNames[value] : shortNames[value];
          };
          var calendar = this;
          var formatMonth = function(date2) {
            return typeof monthNumbers === "function" ? monthNumbers.call(calendar, date2, doubled("m")) : localiseNumbers(formatNumber("m", date2.month(), 2));
          };
          var formatMonthName = function(date2, useLongName) {
            if (useLongName) {
              return typeof monthNames === "function" ? monthNames.call(calendar, date2) : monthNames[date2.month() - calendar.minMonth];
            } else {
              return typeof monthNamesShort === "function" ? monthNamesShort.call(calendar, date2) : monthNamesShort[date2.month() - calendar.minMonth];
            }
          };
          var digits = this.local.digits;
          var localiseNumbers = function(value) {
            return settings.localNumbers && digits ? digits(value) : value;
          };
          var output = "";
          var literal = false;
          for (var iFormat = 0; iFormat < format.length; iFormat++) {
            if (literal) {
              if (format.charAt(iFormat) === "'" && !doubled("'")) {
                literal = false;
              } else {
                output += format.charAt(iFormat);
              }
            } else {
              switch (format.charAt(iFormat)) {
                case "d":
                  output += localiseNumbers(formatNumber("d", date.day(), 2));
                  break;
                case "D":
                  output += formatName(
                    "D",
                    date.dayOfWeek(),
                    dayNamesShort,
                    dayNames
                  );
                  break;
                case "o":
                  output += formatNumber("o", date.dayOfYear(), 3);
                  break;
                case "w":
                  output += formatNumber("w", date.weekOfYear(), 2);
                  break;
                case "m":
                  output += formatMonth(date);
                  break;
                case "M":
                  output += formatMonthName(date, doubled("M"));
                  break;
                case "y":
                  output += doubled("y", 2) ? date.year() : (date.year() % 100 < 10 ? "0" : "") + date.year() % 100;
                  break;
                case "Y":
                  doubled("Y", 2);
                  output += date.formatYear();
                  break;
                case "J":
                  output += date.toJD();
                  break;
                case "@":
                  output += (date.toJD() - this.UNIX_EPOCH) * this.SECS_PER_DAY;
                  break;
                case "!":
                  output += (date.toJD() - this.TICKS_EPOCH) * this.TICKS_PER_DAY;
                  break;
                case "'":
                  if (doubled("'")) {
                    output += "'";
                  } else {
                    literal = true;
                  }
                  break;
                default:
                  output += format.charAt(iFormat);
              }
            }
          }
          return output;
        },
        /** Parse a string value into a date object.
            See <a href="#formatDate"><code>formatDate</code></a> for the possible formats, plus:
            <ul>
            <li>* - ignore rest of string</li>
            </ul>
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar
            @param format {string} The expected format of the date ('' for default calendar format).
            @param value {string} The date in the above format.
            @param [settings] {object} Additional options whose attributes include:
            @property [shortYearCutoff] {number} The cutoff year for determining the century.
            @property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
            @property [dayNames] {string[]} Names of the days from Sunday.
            @property [monthNamesShort] {string[]} Abbreviated names of the months.
            @property [monthNames] {string[]} Names of the months.
            @return {CDate} The extracted date value or <code>null</code> if value is blank.
            @throws Errors if the format and/or value are missing,
                    if the value doesn't match the format, or if the date is invalid. */
        parseDate: function(format, value, settings) {
          if (value == null) {
            throw main.local.invalidArguments || main.regionalOptions[""].invalidArguments;
          }
          value = typeof value === "object" ? value.toString() : value + "";
          if (value === "") {
            return null;
          }
          format = format || this.local.dateFormat;
          settings = settings || {};
          var shortYearCutoff = settings.shortYearCutoff || this.shortYearCutoff;
          shortYearCutoff = typeof shortYearCutoff !== "string" ? shortYearCutoff : this.today().year() % 100 + parseInt(shortYearCutoff, 10);
          var dayNamesShort = settings.dayNamesShort || this.local.dayNamesShort;
          var dayNames = settings.dayNames || this.local.dayNames;
          var parseMonth = settings.parseMonth || this.local.parseMonth;
          var monthNumbers = settings.monthNumbers || this.local.monthNumbers;
          var monthNamesShort = settings.monthNamesShort || this.local.monthNamesShort;
          var monthNames = settings.monthNames || this.local.monthNames;
          var jd = -1;
          var year = -1;
          var month = -1;
          var day = -1;
          var doy = -1;
          var shortYear = false;
          var literal = false;
          var doubled = function(match, step) {
            var matches = 1;
            while (iFormat + matches < format.length && format.charAt(iFormat + matches) === match) {
              matches++;
            }
            iFormat += matches - 1;
            return Math.floor(matches / (step || 1)) > 1;
          };
          var getNumber = function(match, step) {
            var isDoubled = doubled(match, step);
            var size = [2, 3, isDoubled ? 4 : 2, isDoubled ? 4 : 2, 10, 11, 20]["oyYJ@!".indexOf(match) + 1];
            var digits = new RegExp("^-?\\d{1," + size + "}");
            var num = value.substring(iValue).match(digits);
            if (!num) {
              throw (main.local.missingNumberAt || main.regionalOptions[""].missingNumberAt).replace(/\{0\}/, iValue);
            }
            iValue += num[0].length;
            return parseInt(num[0], 10);
          };
          var calendar = this;
          var getMonthNumber = function() {
            if (typeof monthNumbers === "function") {
              doubled("m");
              var month2 = monthNumbers.call(calendar, value.substring(iValue));
              iValue += month2.length;
              return month2;
            }
            return getNumber("m");
          };
          var getName = function(match, shortNames, longNames, step) {
            var names = doubled(match, step) ? longNames : shortNames;
            for (var i = 0; i < names.length; i++) {
              if (value.substr(iValue, names[i].length).toLowerCase() === names[i].toLowerCase()) {
                iValue += names[i].length;
                return i + calendar.minMonth;
              }
            }
            throw (main.local.unknownNameAt || main.regionalOptions[""].unknownNameAt).replace(/\{0\}/, iValue);
          };
          var getMonthName = function() {
            if (typeof monthNames === "function") {
              var month2 = doubled("M") ? monthNames.call(calendar, value.substring(iValue)) : monthNamesShort.call(calendar, value.substring(iValue));
              iValue += month2.length;
              return month2;
            }
            return getName("M", monthNamesShort, monthNames);
          };
          var checkLiteral = function() {
            if (value.charAt(iValue) !== format.charAt(iFormat)) {
              throw (main.local.unexpectedLiteralAt || main.regionalOptions[""].unexpectedLiteralAt).replace(/\{0\}/, iValue);
            }
            iValue++;
          };
          var iValue = 0;
          for (var iFormat = 0; iFormat < format.length; iFormat++) {
            if (literal) {
              if (format.charAt(iFormat) === "'" && !doubled("'")) {
                literal = false;
              } else {
                checkLiteral();
              }
            } else {
              switch (format.charAt(iFormat)) {
                case "d":
                  day = getNumber("d");
                  break;
                case "D":
                  getName("D", dayNamesShort, dayNames);
                  break;
                case "o":
                  doy = getNumber("o");
                  break;
                case "w":
                  getNumber("w");
                  break;
                case "m":
                  month = getMonthNumber();
                  break;
                case "M":
                  month = getMonthName();
                  break;
                case "y":
                  var iSave = iFormat;
                  shortYear = !doubled("y", 2);
                  iFormat = iSave;
                  year = getNumber("y", 2);
                  break;
                case "Y":
                  year = getNumber("Y", 2);
                  break;
                case "J":
                  jd = getNumber("J") + 0.5;
                  if (value.charAt(iValue) === ".") {
                    iValue++;
                    getNumber("J");
                  }
                  break;
                case "@":
                  jd = getNumber("@") / this.SECS_PER_DAY + this.UNIX_EPOCH;
                  break;
                case "!":
                  jd = getNumber("!") / this.TICKS_PER_DAY + this.TICKS_EPOCH;
                  break;
                case "*":
                  iValue = value.length;
                  break;
                case "'":
                  if (doubled("'")) {
                    checkLiteral();
                  } else {
                    literal = true;
                  }
                  break;
                default:
                  checkLiteral();
              }
            }
          }
          if (iValue < value.length) {
            throw main.local.unexpectedText || main.regionalOptions[""].unexpectedText;
          }
          if (year === -1) {
            year = this.today().year();
          } else if (year < 100 && shortYear) {
            year += shortYearCutoff === -1 ? 1900 : this.today().year() - this.today().year() % 100 - (year <= shortYearCutoff ? 0 : 100);
          }
          if (typeof month === "string") {
            month = parseMonth.call(this, year, month);
          }
          if (doy > -1) {
            month = 1;
            day = doy;
            for (var dim = this.daysInMonth(year, month); day > dim; dim = this.daysInMonth(year, month)) {
              month++;
              day -= dim;
            }
          }
          return jd > -1 ? this.fromJD(jd) : this.newDate(year, month, day);
        },
        /** A date may be specified as an exact value or a relative one.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar
            @param dateSpec {CDate|number|string} The date as an object or string in the given format or
                    an offset - numeric days from today, or string amounts and periods, e.g. '+1m +2w'.
            @param defaultDate {CDate} The date to use if no other supplied, may be <code>null</code>.
            @param currentDate {CDate} The current date as a possible basis for relative dates,
                    if <code>null</code> today is used (optional)
            @param [dateFormat] {string} The expected date format - see <a href="#formatDate"><code>formatDate</code></a>.
            @param [settings] {object} Additional options whose attributes include:
            @property [shortYearCutoff] {number} The cutoff year for determining the century.
            @property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
            @property [dayNames] {string[]} Names of the days from Sunday.
            @property [monthNamesShort] {string[]} Abbreviated names of the months.
            @property [monthNames] {string[]} Names of the months.
            @return {CDate} The decoded date. */
        determineDate: function(dateSpec, defaultDate, currentDate, dateFormat, settings) {
          if (currentDate && typeof currentDate !== "object") {
            settings = dateFormat;
            dateFormat = currentDate;
            currentDate = null;
          }
          if (typeof dateFormat !== "string") {
            settings = dateFormat;
            dateFormat = "";
          }
          var calendar = this;
          var offsetString = function(offset) {
            try {
              return calendar.parseDate(dateFormat, offset, settings);
            } catch (e) {
            }
            offset = offset.toLowerCase();
            var date = (offset.match(/^c/) && currentDate ? currentDate.newDate() : null) || calendar.today();
            var pattern = /([+-]?[0-9]+)\s*(d|w|m|y)?/g;
            var matches = pattern.exec(offset);
            while (matches) {
              date.add(parseInt(matches[1], 10), matches[2] || "d");
              matches = pattern.exec(offset);
            }
            return date;
          };
          defaultDate = defaultDate ? defaultDate.newDate() : null;
          dateSpec = dateSpec == null ? defaultDate : typeof dateSpec === "string" ? offsetString(dateSpec) : typeof dateSpec === "number" ? isNaN(dateSpec) || dateSpec === Infinity || dateSpec === -Infinity ? defaultDate : calendar.today().add(dateSpec, "d") : calendar.newDate(dateSpec);
          return dateSpec;
        }
      });
    }
  });

  // node_modules/world-calendars/dist/calendars/chinese.js
  var require_chinese = __commonJS({
    "node_modules/world-calendars/dist/calendars/chinese.js"() {
      var main = require_main();
      var assign = require_object_assign();
      var gregorianCalendar = main.instance();
      function ChineseCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      ChineseCalendar.prototype = new main.baseCalendar();
      assign(ChineseCalendar.prototype, {
        /** The calendar name.
            @memberof ChineseCalendar */
        name: "Chinese",
        /** Julian date of start of Gregorian epoch: 1 January 0001 CE.
           @memberof GregorianCalendar */
        jdEpoch: 17214255e-1,
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof ChineseCalendar */
        hasYearZero: false,
        /** The minimum month number.
            This calendar uses month indices to account for intercalary months. 
            @memberof ChineseCalendar */
        minMonth: 0,
        /** The first month in the year.
            This calendar uses month indices to account for intercalary months. 
            @memberof ChineseCalendar */
        firstMonth: 0,
        /** The minimum day number.
            @memberof ChineseCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof ChineseCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Chinese",
            epochs: ["BEC", "EC"],
            monthNumbers: function(date, padded) {
              if (typeof date === "string") {
                var match = date.match(MONTH_NUMBER_REGEXP);
                return match ? match[0] : "";
              }
              var year = this._validateYear(date);
              var monthIndex = date.month();
              var month = "" + this.toChineseMonth(year, monthIndex);
              if (padded && month.length < 2) {
                month = "0" + month;
              }
              if (this.isIntercalaryMonth(year, monthIndex)) {
                month += "i";
              }
              return month;
            },
            monthNames: function(date) {
              if (typeof date === "string") {
                var match = date.match(MONTH_NAME_REGEXP);
                return match ? match[0] : "";
              }
              var year = this._validateYear(date);
              var monthIndex = date.month();
              var month = this.toChineseMonth(year, monthIndex);
              var monthName = [
                "\u4E00\u6708",
                "\u4E8C\u6708",
                "\u4E09\u6708",
                "\u56DB\u6708",
                "\u4E94\u6708",
                "\u516D\u6708",
                "\u4E03\u6708",
                "\u516B\u6708",
                "\u4E5D\u6708",
                "\u5341\u6708",
                "\u5341\u4E00\u6708",
                "\u5341\u4E8C\u6708"
              ][month - 1];
              if (this.isIntercalaryMonth(year, monthIndex)) {
                monthName = "\u95F0" + monthName;
              }
              return monthName;
            },
            monthNamesShort: function(date) {
              if (typeof date === "string") {
                var match = date.match(MONTH_SHORT_NAME_REGEXP);
                return match ? match[0] : "";
              }
              var year = this._validateYear(date);
              var monthIndex = date.month();
              var month = this.toChineseMonth(year, monthIndex);
              var monthName = [
                "\u4E00",
                "\u4E8C",
                "\u4E09",
                "\u56DB",
                "\u4E94",
                "\u516D",
                "\u4E03",
                "\u516B",
                "\u4E5D",
                "\u5341",
                "\u5341\u4E00",
                "\u5341\u4E8C"
              ][month - 1];
              if (this.isIntercalaryMonth(year, monthIndex)) {
                monthName = "\u95F0" + monthName;
              }
              return monthName;
            },
            parseMonth: function(year, monthString) {
              year = this._validateYear(year);
              var month = parseInt(monthString);
              var isIntercalary;
              if (!isNaN(month)) {
                var i = monthString[monthString.length - 1];
                isIntercalary = i === "i" || i === "I";
              } else {
                if (monthString[0] === "\u95F0") {
                  isIntercalary = true;
                  monthString = monthString.substring(1);
                }
                if (monthString[monthString.length - 1] === "\u6708") {
                  monthString = monthString.substring(0, monthString.length - 1);
                }
                month = 1 + [
                  "\u4E00",
                  "\u4E8C",
                  "\u4E09",
                  "\u56DB",
                  "\u4E94",
                  "\u516D",
                  "\u4E03",
                  "\u516B",
                  "\u4E5D",
                  "\u5341",
                  "\u5341\u4E00",
                  "\u5341\u4E8C"
                ].indexOf(monthString);
              }
              var monthIndex = this.toMonthIndex(year, month, isIntercalary);
              return monthIndex;
            },
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 1,
            isRTL: false
          }
        },
        /** Check that a candidate date is from the same calendar and is valid.
            @memberof BaseCalendar
            @private
            @param year {CDate|number} The date or the year to validate.
            @param error {string} Error message if invalid.
            @return {number} The year.
            @throws Error if year out of range. */
        _validateYear: function(year, error) {
          if (year.year) {
            year = year.year();
          }
          if (typeof year !== "number" || year < 1888 || year > 2111) {
            throw error.replace(/\{0\}/, this.local.name);
          }
          return year;
        },
        /** Retrieve the month index (i.e. accounting for intercalary months).
            @memberof ChineseCalendar
            @param year {number} The year.
            @param month {number} The month (1 for first month).
            @param [isIntercalary=false] {boolean} If month is intercalary.
            @return {number} The month index (0 for first month).
            @throws Error if an invalid month/year or a different calendar used. */
        toMonthIndex: function(year, month, isIntercalary) {
          var intercalaryMonth = this.intercalaryMonth(year);
          var invalidIntercalaryMonth = isIntercalary && month !== intercalaryMonth;
          if (invalidIntercalaryMonth || month < 1 || month > 12) {
            throw main.local.invalidMonth.replace(/\{0\}/, this.local.name);
          }
          var monthIndex;
          if (!intercalaryMonth) {
            monthIndex = month - 1;
          } else if (!isIntercalary && month <= intercalaryMonth) {
            monthIndex = month - 1;
          } else {
            monthIndex = month;
          }
          return monthIndex;
        },
        /** Retrieve the month (i.e. accounting for intercalary months).
            @memberof ChineseCalendar
            @param year {CDate|number} The date or the year to examine.
            @param monthIndex {number} The month index (0 for first month).
            @return {number} The month (1 for first month).
            @throws Error if an invalid month/year or a different calendar used. */
        toChineseMonth: function(year, monthIndex) {
          if (year.year) {
            year = year.year();
            monthIndex = year.month();
          }
          var intercalaryMonth = this.intercalaryMonth(year);
          var maxMonthIndex = intercalaryMonth ? 12 : 11;
          if (monthIndex < 0 || monthIndex > maxMonthIndex) {
            throw main.local.invalidMonth.replace(/\{0\}/, this.local.name);
          }
          var month;
          if (!intercalaryMonth) {
            month = monthIndex + 1;
          } else if (monthIndex < intercalaryMonth) {
            month = monthIndex + 1;
          } else {
            month = monthIndex;
          }
          return month;
        },
        /** Determine the intercalary month of a year (if any).
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The intercalary month number, or 0 if none.
            @throws Error if an invalid year or a different calendar used. */
        intercalaryMonth: function(year) {
          year = this._validateYear(year);
          var monthDaysTable = LUNAR_MONTH_DAYS[year - LUNAR_MONTH_DAYS[0]];
          var intercalaryMonth = monthDaysTable >> 13;
          return intercalaryMonth;
        },
        /** Determine whether this date is an intercalary month.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [monthIndex] {number} The month index to examine.
            @return {boolean} <code>true</code> if this is an intercalary month, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        isIntercalaryMonth: function(year, monthIndex) {
          if (year.year) {
            year = year.year();
            monthIndex = year.month();
          }
          var intercalaryMonth = this.intercalaryMonth(year);
          return !!intercalaryMonth && intercalaryMonth === monthIndex;
        },
        /** Determine whether this date is in a leap year.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          return this.intercalaryMonth(year) !== 0;
        },
        /** Determine the week of the year for a date - ISO 8601.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [monthIndex] {number} The month index to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, monthIndex, day) {
          var validatedYear = this._validateYear(year, main.local.invalidyear);
          var packedDate = CHINESE_NEW_YEAR[validatedYear - CHINESE_NEW_YEAR[0]];
          var y = packedDate >> 9 & 4095;
          var m = packedDate >> 5 & 15;
          var d = packedDate & 31;
          var firstThursday;
          firstThursday = gregorianCalendar.newDate(y, m, d);
          firstThursday.add(4 - (firstThursday.dayOfWeek() || 7), "d");
          var offset = this.toJD(year, monthIndex, day) - firstThursday.toJD();
          return 1 + Math.floor(offset / 7);
        },
        /** Retrieve the number of months in a year.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          return this.leapYear(year) ? 13 : 12;
        },
        /** Retrieve the number of days in a month.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [monthIndex] {number} The month index.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, monthIndex) {
          if (year.year) {
            monthIndex = year.month();
            year = year.year();
          }
          year = this._validateYear(year);
          var monthDaysTable = LUNAR_MONTH_DAYS[year - LUNAR_MONTH_DAYS[0]];
          var intercalaryMonth = monthDaysTable >> 13;
          var maxMonthIndex = intercalaryMonth ? 12 : 11;
          if (monthIndex > maxMonthIndex) {
            throw main.local.invalidMonth.replace(/\{0\}/, this.local.name);
          }
          var daysInMonth = monthDaysTable & 1 << 12 - monthIndex ? 30 : 29;
          return daysInMonth;
        },
        /** Determine whether this date is a week day.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [monthIndex] {number} The month index to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, monthIndex, day) {
          return (this.dayOfWeek(year, monthIndex, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [monthIndex] {number} The month index to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, monthIndex, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = this._validateYear(date.year());
          monthIndex = date.month();
          day = date.day();
          var isIntercalary = this.isIntercalaryMonth(year, monthIndex);
          var month = this.toChineseMonth(year, monthIndex);
          var solar = toSolar(year, month, day, isIntercalary);
          return gregorianCalendar.toJD(solar.year, solar.month, solar.day);
        },
        /** Create a new date from a Julian date.
            @memberof ChineseCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var date = gregorianCalendar.fromJD(jd);
          var lunar = toLunar(date.year(), date.month(), date.day());
          var monthIndex = this.toMonthIndex(
            lunar.year,
            lunar.month,
            lunar.isIntercalary
          );
          return this.newDate(lunar.year, monthIndex, lunar.day);
        },
        /** Create a new date from a string.
            @memberof ChineseCalendar
            @param dateString {string} String representing a Chinese date
            @return {CDate} The new date.
            @throws Error if an invalid date. */
        fromString: function(dateString) {
          var match = dateString.match(DATE_REGEXP);
          var year = this._validateYear(+match[1]);
          var month = +match[2];
          var isIntercalary = !!match[3];
          var monthIndex = this.toMonthIndex(year, month, isIntercalary);
          var day = +match[4];
          return this.newDate(year, monthIndex, day);
        },
        /** Add period(s) to a date.
            Cater for no year zero.
            @memberof ChineseCalendar
            @param date {CDate} The starting date.
            @param offset {number} The number of periods to adjust by.
            @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
            @return {CDate} The updated date.
            @throws Error if a different calendar used. */
        add: function(date, offset, period) {
          var year = date.year();
          var monthIndex = date.month();
          var isIntercalary = this.isIntercalaryMonth(year, monthIndex);
          var month = this.toChineseMonth(year, monthIndex);
          var cdate = Object.getPrototypeOf(ChineseCalendar.prototype).add.call(this, date, offset, period);
          if (period === "y") {
            var resultYear = cdate.year();
            var resultMonthIndex = cdate.month();
            var resultCanBeIntercalaryMonth = this.isIntercalaryMonth(resultYear, month);
            var correctedMonthIndex = isIntercalary && resultCanBeIntercalaryMonth ? this.toMonthIndex(resultYear, month, true) : this.toMonthIndex(resultYear, month, false);
            if (correctedMonthIndex !== resultMonthIndex) {
              cdate.month(correctedMonthIndex);
            }
          }
          return cdate;
        }
      });
      var DATE_REGEXP = /^\s*(-?\d\d\d\d|\d\d)[-/](\d?\d)([iI]?)[-/](\d?\d)/m;
      var MONTH_NUMBER_REGEXP = /^\d?\d[iI]?/m;
      var MONTH_NAME_REGEXP = /^闰?十?[一二三四五六七八九]?月/m;
      var MONTH_SHORT_NAME_REGEXP = /^闰?十?[一二三四五六七八九]?/m;
      main.calendars.chinese = ChineseCalendar;
      var LUNAR_MONTH_DAYS = [
        1887,
        5780,
        5802,
        19157,
        2742,
        50359,
        1198,
        2646,
        46378,
        7466,
        3412,
        30122,
        5482,
        67949,
        2396,
        5294,
        43597,
        6732,
        6954,
        36181,
        2772,
        4954,
        18781,
        2396,
        54427,
        5274,
        6730,
        47781,
        5800,
        6868,
        21210,
        4790,
        59703,
        2350,
        5270,
        46667,
        3402,
        3496,
        38325,
        1388,
        4782,
        18735,
        2350,
        52374,
        6804,
        7498,
        44457,
        2906,
        1388,
        29294,
        4700,
        63789,
        6442,
        6804,
        56138,
        5802,
        2772,
        38235,
        1210,
        4698,
        22827,
        5418,
        63125,
        3476,
        5802,
        43701,
        2484,
        5302,
        27223,
        2646,
        70954,
        7466,
        3412,
        54698,
        5482,
        2412,
        38062,
        5294,
        2636,
        32038,
        6954,
        60245,
        2772,
        4826,
        43357,
        2394,
        5274,
        39501,
        6730,
        72357,
        5800,
        5844,
        53978,
        4790,
        2358,
        38039,
        5270,
        87627,
        3402,
        3496,
        54708,
        5484,
        4782,
        43311,
        2350,
        3222,
        27978,
        7498,
        68965,
        2904,
        5484,
        45677,
        4700,
        6444,
        39573,
        6804,
        6986,
        19285,
        2772,
        62811,
        1210,
        4698,
        47403,
        5418,
        5780,
        38570,
        5546,
        76469,
        2420,
        5302,
        51799,
        2646,
        5414,
        36501,
        3412,
        5546,
        18869,
        2412,
        54446,
        5276,
        6732,
        48422,
        6822,
        2900,
        28010,
        4826,
        92509,
        2394,
        5274,
        55883,
        6730,
        6820,
        47956,
        5812,
        2778,
        18779,
        2358,
        62615,
        5270,
        5450,
        46757,
        3492,
        5556,
        27318,
        4718,
        67887,
        2350,
        3222,
        52554,
        7498,
        3428,
        38252,
        5468,
        4700,
        31022,
        6444,
        64149,
        6804,
        6986,
        43861,
        2772,
        5338,
        35421,
        2650,
        70955,
        5418,
        5780,
        54954,
        5546,
        2740,
        38074,
        5302,
        2646,
        29991,
        3366,
        61011,
        3412,
        5546,
        43445,
        2412,
        5294,
        35406,
        6732,
        72998,
        6820,
        6996,
        52586,
        2778,
        2396,
        38045,
        5274,
        6698,
        23333,
        6820,
        64338,
        5812,
        2746,
        43355,
        2358,
        5270,
        39499,
        5450,
        79525,
        3492,
        5548
      ];
      var CHINESE_NEW_YEAR = [
        1887,
        966732,
        967231,
        967733,
        968265,
        968766,
        969297,
        969798,
        970298,
        970829,
        971330,
        971830,
        972362,
        972863,
        973395,
        973896,
        974397,
        974928,
        975428,
        975929,
        976461,
        976962,
        977462,
        977994,
        978494,
        979026,
        979526,
        980026,
        980558,
        981059,
        981559,
        982091,
        982593,
        983124,
        983624,
        984124,
        984656,
        985157,
        985656,
        986189,
        986690,
        987191,
        987722,
        988222,
        988753,
        989254,
        989754,
        990286,
        990788,
        991288,
        991819,
        992319,
        992851,
        993352,
        993851,
        994383,
        994885,
        995385,
        995917,
        996418,
        996918,
        997450,
        997949,
        998481,
        998982,
        999483,
        1000014,
        1000515,
        1001016,
        1001548,
        1002047,
        1002578,
        1003080,
        1003580,
        1004111,
        1004613,
        1005113,
        1005645,
        1006146,
        1006645,
        1007177,
        1007678,
        1008209,
        1008710,
        1009211,
        1009743,
        1010243,
        1010743,
        1011275,
        1011775,
        1012306,
        1012807,
        1013308,
        1013840,
        1014341,
        1014841,
        1015373,
        1015874,
        1016404,
        1016905,
        1017405,
        1017937,
        1018438,
        1018939,
        1019471,
        1019972,
        1020471,
        1021002,
        1021503,
        1022035,
        1022535,
        1023036,
        1023568,
        1024069,
        1024568,
        1025100,
        1025601,
        1026102,
        1026633,
        1027133,
        1027666,
        1028167,
        1028666,
        1029198,
        1029699,
        1030199,
        1030730,
        1031231,
        1031763,
        1032264,
        1032764,
        1033296,
        1033797,
        1034297,
        1034828,
        1035329,
        1035830,
        1036362,
        1036861,
        1037393,
        1037894,
        1038394,
        1038925,
        1039427,
        1039927,
        1040459,
        1040959,
        1041491,
        1041992,
        1042492,
        1043023,
        1043524,
        1044024,
        1044556,
        1045057,
        1045558,
        1046090,
        1046590,
        1047121,
        1047622,
        1048122,
        1048654,
        1049154,
        1049655,
        1050187,
        1050689,
        1051219,
        1051720,
        1052220,
        1052751,
        1053252,
        1053752,
        1054284,
        1054786,
        1055285,
        1055817,
        1056317,
        1056849,
        1057349,
        1057850,
        1058382,
        1058883,
        1059383,
        1059915,
        1060415,
        1060947,
        1061447,
        1061947,
        1062479,
        1062981,
        1063480,
        1064012,
        1064514,
        1065014,
        1065545,
        1066045,
        1066577,
        1067078,
        1067578,
        1068110,
        1068611,
        1069112,
        1069642,
        1070142,
        1070674,
        1071175,
        1071675,
        1072207,
        1072709,
        1073209,
        1073740,
        1074241,
        1074741,
        1075273,
        1075773,
        1076305,
        1076807,
        1077308,
        1077839,
        1078340,
        1078840,
        1079372,
        1079871,
        1080403,
        1080904
      ];
      function toLunar(yearOrDate, monthOrResult, day, result) {
        var solarDate;
        var lunarDate;
        if (typeof yearOrDate === "object") {
          solarDate = yearOrDate;
          lunarDate = monthOrResult || {};
        } else {
          var isValidYear = typeof yearOrDate === "number" && yearOrDate >= 1888 && yearOrDate <= 2111;
          if (!isValidYear)
            throw new Error("Solar year outside range 1888-2111");
          var isValidMonth = typeof monthOrResult === "number" && monthOrResult >= 1 && monthOrResult <= 12;
          if (!isValidMonth)
            throw new Error("Solar month outside range 1 - 12");
          var isValidDay = typeof day === "number" && day >= 1 && day <= 31;
          if (!isValidDay)
            throw new Error("Solar day outside range 1 - 31");
          solarDate = {
            year: yearOrDate,
            month: monthOrResult,
            day
          };
          lunarDate = result || {};
        }
        var chineseNewYearPackedDate = CHINESE_NEW_YEAR[solarDate.year - CHINESE_NEW_YEAR[0]];
        var packedDate = solarDate.year << 9 | solarDate.month << 5 | solarDate.day;
        lunarDate.year = packedDate >= chineseNewYearPackedDate ? solarDate.year : solarDate.year - 1;
        chineseNewYearPackedDate = CHINESE_NEW_YEAR[lunarDate.year - CHINESE_NEW_YEAR[0]];
        var y = chineseNewYearPackedDate >> 9 & 4095;
        var m = chineseNewYearPackedDate >> 5 & 15;
        var d = chineseNewYearPackedDate & 31;
        var daysFromNewYear;
        var chineseNewYearJSDate = new Date(y, m - 1, d);
        var jsDate = new Date(solarDate.year, solarDate.month - 1, solarDate.day);
        daysFromNewYear = Math.round(
          (jsDate - chineseNewYearJSDate) / (24 * 3600 * 1e3)
        );
        var monthDaysTable = LUNAR_MONTH_DAYS[lunarDate.year - LUNAR_MONTH_DAYS[0]];
        var i;
        for (i = 0; i < 13; i++) {
          var daysInMonth = monthDaysTable & 1 << 12 - i ? 30 : 29;
          if (daysFromNewYear < daysInMonth) {
            break;
          }
          daysFromNewYear -= daysInMonth;
        }
        var intercalaryMonth = monthDaysTable >> 13;
        if (!intercalaryMonth || i < intercalaryMonth) {
          lunarDate.isIntercalary = false;
          lunarDate.month = 1 + i;
        } else if (i === intercalaryMonth) {
          lunarDate.isIntercalary = true;
          lunarDate.month = i;
        } else {
          lunarDate.isIntercalary = false;
          lunarDate.month = i;
        }
        lunarDate.day = 1 + daysFromNewYear;
        return lunarDate;
      }
      function toSolar(yearOrDate, monthOrResult, day, isIntercalaryOrResult, result) {
        var solarDate;
        var lunarDate;
        if (typeof yearOrDate === "object") {
          lunarDate = yearOrDate;
          solarDate = monthOrResult || {};
        } else {
          var isValidYear = typeof yearOrDate === "number" && yearOrDate >= 1888 && yearOrDate <= 2111;
          if (!isValidYear)
            throw new Error("Lunar year outside range 1888-2111");
          var isValidMonth = typeof monthOrResult === "number" && monthOrResult >= 1 && monthOrResult <= 12;
          if (!isValidMonth)
            throw new Error("Lunar month outside range 1 - 12");
          var isValidDay = typeof day === "number" && day >= 1 && day <= 30;
          if (!isValidDay)
            throw new Error("Lunar day outside range 1 - 30");
          var isIntercalary;
          if (typeof isIntercalaryOrResult === "object") {
            isIntercalary = false;
            solarDate = isIntercalaryOrResult;
          } else {
            isIntercalary = !!isIntercalaryOrResult;
            solarDate = result || {};
          }
          lunarDate = {
            year: yearOrDate,
            month: monthOrResult,
            day,
            isIntercalary
          };
        }
        var daysFromNewYear;
        daysFromNewYear = lunarDate.day - 1;
        var monthDaysTable = LUNAR_MONTH_DAYS[lunarDate.year - LUNAR_MONTH_DAYS[0]];
        var intercalaryMonth = monthDaysTable >> 13;
        var monthsFromNewYear;
        if (!intercalaryMonth) {
          monthsFromNewYear = lunarDate.month - 1;
        } else if (lunarDate.month > intercalaryMonth) {
          monthsFromNewYear = lunarDate.month;
        } else if (lunarDate.isIntercalary) {
          monthsFromNewYear = lunarDate.month;
        } else {
          monthsFromNewYear = lunarDate.month - 1;
        }
        for (var i = 0; i < monthsFromNewYear; i++) {
          var daysInMonth = monthDaysTable & 1 << 12 - i ? 30 : 29;
          daysFromNewYear += daysInMonth;
        }
        var packedDate = CHINESE_NEW_YEAR[lunarDate.year - CHINESE_NEW_YEAR[0]];
        var y = packedDate >> 9 & 4095;
        var m = packedDate >> 5 & 15;
        var d = packedDate & 31;
        var jsDate = new Date(y, m - 1, d + daysFromNewYear);
        solarDate.year = jsDate.getFullYear();
        solarDate.month = 1 + jsDate.getMonth();
        solarDate.day = jsDate.getDate();
        return solarDate;
      }
    }
  });

  // node_modules/world-calendars/dist/calendars/coptic.js
  var require_coptic = __commonJS({
    "node_modules/world-calendars/dist/calendars/coptic.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function CopticCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      CopticCalendar.prototype = new main.baseCalendar();
      assign(CopticCalendar.prototype, {
        /** The calendar name.
            @memberof CopticCalendar */
        name: "Coptic",
        /** Julian date of start of Coptic epoch: 29 August 284 CE (Gregorian).
            @memberof CopticCalendar */
        jdEpoch: 18250295e-1,
        /** Days per month in a common year.
            @memberof CopticCalendar */
        daysPerMonth: [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 5],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof CopticCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof CopticCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof CopticCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof CopticCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof CopticCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Coptic",
            epochs: ["BAM", "AM"],
            monthNames: [
              "Thout",
              "Paopi",
              "Hathor",
              "Koiak",
              "Tobi",
              "Meshir",
              "Paremhat",
              "Paremoude",
              "Pashons",
              "Paoni",
              "Epip",
              "Mesori",
              "Pi Kogi Enavot"
            ],
            monthNamesShort: [
              "Tho",
              "Pao",
              "Hath",
              "Koi",
              "Tob",
              "Mesh",
              "Pat",
              "Pad",
              "Pash",
              "Pao",
              "Epi",
              "Meso",
              "PiK"
            ],
            dayNames: ["Tkyriaka", "Pesnau", "Pshoment", "Peftoou", "Ptiou", "Psoou", "Psabbaton"],
            dayNamesShort: ["Tky", "Pes", "Psh", "Pef", "Pti", "Pso", "Psa"],
            dayNamesMin: ["Tk", "Pes", "Psh", "Pef", "Pt", "Pso", "Psa"],
            digits: null,
            dateFormat: "dd/mm/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof CopticCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = date.year() + (date.year() < 0 ? 1 : 0);
          return year % 4 === 3 || year % 4 === -1;
        },
        /** Retrieve the number of months in a year.
            @memberof CopticCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(
            year,
            this.minMonth,
            this.minDay,
            main.local.invalidYear || main.regionalOptions[""].invalidYear
          );
          return 13;
        },
        /** Determine the week of the year for a date.
            @memberof CopticCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number) the month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof CopticCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 13 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof CopticCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param month {number} The month to examine.
            @param day {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof CopticCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number) the month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          if (year < 0) {
            year++;
          }
          return date.day() + (date.month() - 1) * 30 + (year - 1) * 365 + Math.floor(year / 4) + this.jdEpoch - 1;
        },
        /** Create a new date from a Julian date.
            @memberof CopticCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var c = Math.floor(jd) + 0.5 - this.jdEpoch;
          var year = Math.floor((c - Math.floor((c + 366) / 1461)) / 365) + 1;
          if (year <= 0) {
            year--;
          }
          c = Math.floor(jd) + 0.5 - this.newDate(year, 1, 1).toJD();
          var month = Math.floor(c / 30) + 1;
          var day = c - (month - 1) * 30 + 1;
          return this.newDate(year, month, day);
        }
      });
      main.calendars.coptic = CopticCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/discworld.js
  var require_discworld = __commonJS({
    "node_modules/world-calendars/dist/calendars/discworld.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function DiscworldCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      DiscworldCalendar.prototype = new main.baseCalendar();
      assign(DiscworldCalendar.prototype, {
        /** The calendar name.
            @memberof DiscworldCalendar */
        name: "Discworld",
        /** Julian date of start of Discworld epoch: 1 January 0001 CE.
            @memberof DiscworldCalendar */
        jdEpoch: 17214255e-1,
        /** Days per month in a common year.
            @memberof DiscworldCalendar */
        daysPerMonth: [16, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof DiscworldCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof DiscworldCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof DiscworldCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof DiscworldCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof DiscworldCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Discworld",
            epochs: ["BUC", "UC"],
            monthNames: [
              "Ick",
              "Offle",
              "February",
              "March",
              "April",
              "May",
              "June",
              "Grune",
              "August",
              "Spune",
              "Sektober",
              "Ember",
              "December"
            ],
            monthNamesShort: ["Ick", "Off", "Feb", "Mar", "Apr", "May", "Jun", "Gru", "Aug", "Spu", "Sek", "Emb", "Dec"],
            dayNames: ["Sunday", "Octeday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Oct", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Oc", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 2,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return false;
        },
        /** Retrieve the number of months in a year.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return 13;
        },
        /** Retrieve the number of days in a year.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return 400;
        },
        /** Determine the week of the year for a date.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 8) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1];
        },
        /** Retrieve the number of days in a week.
            @memberof DiscworldCalendar
            @return {number} The number of days. */
        daysInWeek: function() {
          return 8;
        },
        /** Retrieve the day of the week for a date.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The day of the week: 0 to number of days - 1.
            @throws Error if an invalid date or a different calendar used. */
        dayOfWeek: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          return (date.day() + 1) % 8;
        },
        /** Determine whether this date is a week day.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          var dow = this.dayOfWeek(year, month, day);
          return dow >= 2 && dow <= 6;
        },
        /** Retrieve additional information about a date.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {object} Additional information - contents depends on calendar.
            @throws Error if an invalid date or a different calendar used. */
        extraInfo: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          return { century: centuries[Math.floor((date.year() - 1) / 100) + 1] || "" };
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year() + (date.year() < 0 ? 1 : 0);
          month = date.month();
          day = date.day();
          return day + (month > 1 ? 16 : 0) + (month > 2 ? (month - 2) * 32 : 0) + (year - 1) * 400 + this.jdEpoch - 1;
        },
        /** Create a new date from a Julian date.
            @memberof DiscworldCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd + 0.5) - Math.floor(this.jdEpoch) - 1;
          var year = Math.floor(jd / 400) + 1;
          jd -= (year - 1) * 400;
          jd += jd > 15 ? 16 : 0;
          var month = Math.floor(jd / 32) + 1;
          var day = jd - (month - 1) * 32 + 1;
          return this.newDate(year <= 0 ? year - 1 : year, month, day);
        }
      });
      var centuries = {
        20: "Fruitbat",
        21: "Anchovy"
      };
      main.calendars.discworld = DiscworldCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/ethiopian.js
  var require_ethiopian = __commonJS({
    "node_modules/world-calendars/dist/calendars/ethiopian.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function EthiopianCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      EthiopianCalendar.prototype = new main.baseCalendar();
      assign(EthiopianCalendar.prototype, {
        /** The calendar name.
            @memberof EthiopianCalendar */
        name: "Ethiopian",
        /** Julian date of start of Ethiopian epoch: 27 August 8 CE (Gregorian).
            @memberof EthiopianCalendar */
        jdEpoch: 17242205e-1,
        /** Days per month in a common year.
            @memberof EthiopianCalendar */
        daysPerMonth: [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 5],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof EthiopianCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof EthiopianCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof EthiopianCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof EthiopianCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof EthiopianCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Ethiopian",
            epochs: ["BEE", "EE"],
            monthNames: [
              "Meskerem",
              "Tikemet",
              "Hidar",
              "Tahesas",
              "Tir",
              "Yekatit",
              "Megabit",
              "Miazia",
              "Genbot",
              "Sene",
              "Hamle",
              "Nehase",
              "Pagume"
            ],
            monthNamesShort: [
              "Mes",
              "Tik",
              "Hid",
              "Tah",
              "Tir",
              "Yek",
              "Meg",
              "Mia",
              "Gen",
              "Sen",
              "Ham",
              "Neh",
              "Pag"
            ],
            dayNames: ["Ehud", "Segno", "Maksegno", "Irob", "Hamus", "Arb", "Kidame"],
            dayNamesShort: ["Ehu", "Seg", "Mak", "Iro", "Ham", "Arb", "Kid"],
            dayNamesMin: ["Eh", "Se", "Ma", "Ir", "Ha", "Ar", "Ki"],
            digits: null,
            dateFormat: "dd/mm/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = date.year() + (date.year() < 0 ? 1 : 0);
          return year % 4 === 3 || year % 4 === -1;
        },
        /** Retrieve the number of months in a year.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(
            year,
            this.minMonth,
            this.minDay,
            main.local.invalidYear || main.regionalOptions[""].invalidYear
          );
          return 13;
        },
        /** Determine the week of the year for a date.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 13 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          if (year < 0) {
            year++;
          }
          return date.day() + (date.month() - 1) * 30 + (year - 1) * 365 + Math.floor(year / 4) + this.jdEpoch - 1;
        },
        /** Create a new date from a Julian date.
            @memberof EthiopianCalendar
            @param jd {number} the Julian date to convert.
            @return {CDate} the equivalent date. */
        fromJD: function(jd) {
          var c = Math.floor(jd) + 0.5 - this.jdEpoch;
          var year = Math.floor((c - Math.floor((c + 366) / 1461)) / 365) + 1;
          if (year <= 0) {
            year--;
          }
          c = Math.floor(jd) + 0.5 - this.newDate(year, 1, 1).toJD();
          var month = Math.floor(c / 30) + 1;
          var day = c - (month - 1) * 30 + 1;
          return this.newDate(year, month, day);
        }
      });
      main.calendars.ethiopian = EthiopianCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/hebrew.js
  var require_hebrew = __commonJS({
    "node_modules/world-calendars/dist/calendars/hebrew.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function HebrewCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      HebrewCalendar.prototype = new main.baseCalendar();
      assign(HebrewCalendar.prototype, {
        /** The calendar name.
            @memberof HebrewCalendar */
        name: "Hebrew",
        /** Julian date of start of Hebrew epoch: 7 October 3761 BCE.
            @memberof HebrewCalendar */
        jdEpoch: 347995.5,
        /** Days per month in a common year.
            @memberof HebrewCalendar */
        daysPerMonth: [30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 29],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof HebrewCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof HebrewCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof HebrewCalendar */
        firstMonth: 7,
        /** The minimum day number.
            @memberof HebrewCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof HebrewCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Hebrew",
            epochs: ["BAM", "AM"],
            monthNames: [
              "Nisan",
              "Iyar",
              "Sivan",
              "Tammuz",
              "Av",
              "Elul",
              "Tishrei",
              "Cheshvan",
              "Kislev",
              "Tevet",
              "Shevat",
              "Adar",
              "Adar II"
            ],
            monthNamesShort: ["Nis", "Iya", "Siv", "Tam", "Av", "Elu", "Tis", "Che", "Kis", "Tev", "She", "Ada", "Ad2"],
            dayNames: ["Yom Rishon", "Yom Sheni", "Yom Shlishi", "Yom Revi'i", "Yom Chamishi", "Yom Shishi", "Yom Shabbat"],
            dayNamesShort: ["Ris", "She", "Shl", "Rev", "Cha", "Shi", "Sha"],
            dayNamesMin: ["Ri", "She", "Shl", "Re", "Ch", "Shi", "Sha"],
            digits: null,
            dateFormat: "dd/mm/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return this._leapYear(date.year());
        },
        /** Determine whether this date is in a leap year.
            @memberof HebrewCalendar
            @private
            @param year {number} The year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        _leapYear: function(year) {
          year = year < 0 ? year + 1 : year;
          return mod(year * 7 + 1, 19) < 7;
        },
        /** Retrieve the number of months in a year.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return this._leapYear(year.year ? year.year() : year) ? 13 : 12;
        },
        /** Determine the week of the year for a date.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a year.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          year = date.year();
          return this.toJD(year === -1 ? 1 : year + 1, 7, 1) - this.toJD(year, 7, 1);
        },
        /** Retrieve the number of days in a month.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          if (year.year) {
            month = year.month();
            year = year.year();
          }
          this._validate(year, month, this.minDay, main.local.invalidMonth);
          return month === 12 && this.leapYear(year) ? 30 : (
            // Adar I
            month === 8 && mod(this.daysInYear(year), 10) === 5 ? 30 : (
              // Cheshvan in shlemah year
              month === 9 && mod(this.daysInYear(year), 10) === 3 ? 29 : (
                // Kislev in chaserah year
                this.daysPerMonth[month - 1]
              )
            )
          );
        },
        /** Determine whether this date is a week day.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return this.dayOfWeek(year, month, day) !== 6;
        },
        /** Retrieve additional information about a date - year type.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {object} Additional information - contents depends on calendar.
            @throws Error if an invalid date or a different calendar used. */
        extraInfo: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          return { yearType: (this.leapYear(date) ? "embolismic" : "common") + " " + ["deficient", "regular", "complete"][this.daysInYear(date) % 10 - 3] };
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof HebrewCalendar
            @param year {CDate)|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          month = date.month();
          day = date.day();
          var adjYear = year <= 0 ? year + 1 : year;
          var jd = this.jdEpoch + this._delay1(adjYear) + this._delay2(adjYear) + day + 1;
          if (month < 7) {
            for (var m = 7; m <= this.monthsInYear(year); m++) {
              jd += this.daysInMonth(year, m);
            }
            for (var m = 1; m < month; m++) {
              jd += this.daysInMonth(year, m);
            }
          } else {
            for (var m = 7; m < month; m++) {
              jd += this.daysInMonth(year, m);
            }
          }
          return jd;
        },
        /** Test for delay of start of new year and to avoid
            Sunday, Wednesday, or Friday as start of the new year.
            @memberof HebrewCalendar
            @private
            @param year {number} The year to examine.
            @return {number} The days to offset by. */
        _delay1: function(year) {
          var months = Math.floor((235 * year - 234) / 19);
          var parts = 12084 + 13753 * months;
          var day = months * 29 + Math.floor(parts / 25920);
          if (mod(3 * (day + 1), 7) < 3) {
            day++;
          }
          return day;
        },
        /** Check for delay in start of new year due to length of adjacent years.
            @memberof HebrewCalendar
            @private
            @param year {number} The year to examine.
            @return {number} The days to offset by. */
        _delay2: function(year) {
          var last = this._delay1(year - 1);
          var present = this._delay1(year);
          var next = this._delay1(year + 1);
          return next - present === 356 ? 2 : present - last === 382 ? 1 : 0;
        },
        /** Create a new date from a Julian date.
            @memberof HebrewCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd) + 0.5;
          var year = Math.floor((jd - this.jdEpoch) * 98496 / 35975351) - 1;
          while (jd >= this.toJD(year === -1 ? 1 : year + 1, 7, 1)) {
            year++;
          }
          var month = jd < this.toJD(year, 1, 1) ? 7 : 1;
          while (jd > this.toJD(year, month, this.daysInMonth(year, month))) {
            month++;
          }
          var day = jd - this.toJD(year, month, 1) + 1;
          return this.newDate(year, month, day);
        }
      });
      function mod(a, b) {
        return a - b * Math.floor(a / b);
      }
      main.calendars.hebrew = HebrewCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/islamic.js
  var require_islamic = __commonJS({
    "node_modules/world-calendars/dist/calendars/islamic.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function IslamicCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      IslamicCalendar.prototype = new main.baseCalendar();
      assign(IslamicCalendar.prototype, {
        /** The calendar name.
            @memberof IslamicCalendar */
        name: "Islamic",
        /** Julian date of start of Islamic epoch: 16 July 622 CE.
            @memberof IslamicCalendar */
        jdEpoch: 19484395e-1,
        /** Days per month in a common year.
            @memberof IslamicCalendar */
        daysPerMonth: [30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof IslamicCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof IslamicCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof IslamicCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof IslamicCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof IslamicCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Islamic",
            epochs: ["BH", "AH"],
            monthNames: [
              "Muharram",
              "Safar",
              "Rabi' al-awwal",
              "Rabi' al-thani",
              "Jumada al-awwal",
              "Jumada al-thani",
              "Rajab",
              "Sha'aban",
              "Ramadan",
              "Shawwal",
              "Dhu al-Qi'dah",
              "Dhu al-Hijjah"
            ],
            monthNamesShort: ["Muh", "Saf", "Rab1", "Rab2", "Jum1", "Jum2", "Raj", "Sha'", "Ram", "Shaw", "DhuQ", "DhuH"],
            dayNames: [
              "Yawm al-ahad",
              "Yawm al-ithnayn",
              "Yawm ath-thulaathaa'",
              "Yawm al-arbi'aa'",
              "Yawm al-kham\u012Bs",
              "Yawm al-jum'a",
              "Yawm as-sabt"
            ],
            dayNamesShort: ["Aha", "Ith", "Thu", "Arb", "Kha", "Jum", "Sab"],
            dayNamesMin: ["Ah", "It", "Th", "Ar", "Kh", "Ju", "Sa"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 6,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return (date.year() * 11 + 14) % 30 < 11;
        },
        /** Determine the week of the year for a date.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a year.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          return this.leapYear(year) ? 355 : 354;
        },
        /** Retrieve the number of days in a month.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 12 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return this.dayOfWeek(year, month, day) !== 5;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          month = date.month();
          day = date.day();
          year = year <= 0 ? year + 1 : year;
          return day + Math.ceil(29.5 * (month - 1)) + (year - 1) * 354 + Math.floor((3 + 11 * year) / 30) + this.jdEpoch - 1;
        },
        /** Create a new date from a Julian date.
            @memberof IslamicCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd) + 0.5;
          var year = Math.floor((30 * (jd - this.jdEpoch) + 10646) / 10631);
          year = year <= 0 ? year - 1 : year;
          var month = Math.min(12, Math.ceil((jd - 29 - this.toJD(year, 1, 1)) / 29.5) + 1);
          var day = jd - this.toJD(year, month, 1) + 1;
          return this.newDate(year, month, day);
        }
      });
      main.calendars.islamic = IslamicCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/julian.js
  var require_julian = __commonJS({
    "node_modules/world-calendars/dist/calendars/julian.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function JulianCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      JulianCalendar.prototype = new main.baseCalendar();
      assign(JulianCalendar.prototype, {
        /** The calendar name.
            @memberof JulianCalendar */
        name: "Julian",
        /** Julian date of start of Julian epoch: 1 January 0001 AD = 30 December 0001 BCE.
            @memberof JulianCalendar */
        jdEpoch: 17214235e-1,
        /** Days per month in a common year.
            @memberof JulianCalendar */
        daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof JulianCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof JulianCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof JulianCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof JulianCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof JulianCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Julian",
            epochs: ["BC", "AD"],
            monthNames: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "mm/dd/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof JulianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = date.year() < 0 ? date.year() + 1 : date.year();
          return year % 4 === 0;
        },
        /** Determine the week of the year for a date - ISO 8601.
            @memberof JulianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(4 - (checkDate.dayOfWeek() || 7), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof JulianCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof JulianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} True if a week day, false if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof JulianCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          month = date.month();
          day = date.day();
          if (year < 0) {
            year++;
          }
          if (month <= 2) {
            year--;
            month += 12;
          }
          return Math.floor(365.25 * (year + 4716)) + Math.floor(30.6001 * (month + 1)) + day - 1524.5;
        },
        /** Create a new date from a Julian date.
            @memberof JulianCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var a = Math.floor(jd + 0.5);
          var b = a + 1524;
          var c = Math.floor((b - 122.1) / 365.25);
          var d = Math.floor(365.25 * c);
          var e = Math.floor((b - d) / 30.6001);
          var month = e - Math.floor(e < 14 ? 1 : 13);
          var year = c - Math.floor(month > 2 ? 4716 : 4715);
          var day = b - d - Math.floor(30.6001 * e);
          if (year <= 0) {
            year--;
          }
          return this.newDate(year, month, day);
        }
      });
      main.calendars.julian = JulianCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/mayan.js
  var require_mayan = __commonJS({
    "node_modules/world-calendars/dist/calendars/mayan.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function MayanCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      MayanCalendar.prototype = new main.baseCalendar();
      assign(MayanCalendar.prototype, {
        /** The calendar name.
            @memberof MayanCalendar */
        name: "Mayan",
        /** Julian date of start of Mayan epoch: 11 August 3114 BCE.
            @memberof MayanCalendar */
        jdEpoch: 584282.5,
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof MayanCalendar */
        hasYearZero: true,
        /** The minimum month number.
            @memberof MayanCalendar */
        minMonth: 0,
        /** The first month in the year.
            @memberof MayanCalendar */
        firstMonth: 0,
        /** The minimum day number.
            @memberof MayanCalendar */
        minDay: 0,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof MayanCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left.
            @property haabMonths {string[]} The names of the Haab months.
            @property tzolkinMonths {string[]} The names of the Tzolkin months. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Mayan",
            epochs: ["", ""],
            monthNames: [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "10",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "17"
            ],
            monthNamesShort: [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "10",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "17"
            ],
            dayNames: [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "10",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "17",
              "18",
              "19"
            ],
            dayNamesShort: [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "10",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "17",
              "18",
              "19"
            ],
            dayNamesMin: [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "10",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "17",
              "18",
              "19"
            ],
            digits: null,
            dateFormat: "YYYY.m.d",
            firstDay: 0,
            isRTL: false,
            haabMonths: [
              "Pop",
              "Uo",
              "Zip",
              "Zotz",
              "Tzec",
              "Xul",
              "Yaxkin",
              "Mol",
              "Chen",
              "Yax",
              "Zac",
              "Ceh",
              "Mac",
              "Kankin",
              "Muan",
              "Pax",
              "Kayab",
              "Cumku",
              "Uayeb"
            ],
            tzolkinMonths: [
              "Imix",
              "Ik",
              "Akbal",
              "Kan",
              "Chicchan",
              "Cimi",
              "Manik",
              "Lamat",
              "Muluc",
              "Oc",
              "Chuen",
              "Eb",
              "Ben",
              "Ix",
              "Men",
              "Cib",
              "Caban",
              "Etznab",
              "Cauac",
              "Ahau"
            ]
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return false;
        },
        /** Format the year, if not a simple sequential number.
            @memberof MayanCalendar
            @param year {CDate|number} The date to format or the year to format.
            @return {string} The formatted year.
            @throws Error if an invalid year or a different calendar used. */
        formatYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          year = date.year();
          var baktun = Math.floor(year / 400);
          year = year % 400;
          year += year < 0 ? 400 : 0;
          var katun = Math.floor(year / 20);
          return baktun + "." + katun + "." + year % 20;
        },
        /** Convert from the formatted year back to a single number.
            @memberof MayanCalendar
            @param years {string} The year as n.n.n.
            @return {number} The sequential year.
            @throws Error if an invalid value is supplied. */
        forYear: function(years) {
          years = years.split(".");
          if (years.length < 3) {
            throw "Invalid Mayan year";
          }
          var year = 0;
          for (var i = 0; i < years.length; i++) {
            var y = parseInt(years[i], 10);
            if (Math.abs(y) > 19 || i > 0 && y < 0) {
              throw "Invalid Mayan year";
            }
            year = year * 20 + y;
          }
          return year;
        },
        /** Retrieve the number of months in a year.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return 18;
        },
        /** Determine the week of the year for a date.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          this._validate(year, month, day, main.local.invalidDate);
          return 0;
        },
        /** Retrieve the number of days in a year.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return 360;
        },
        /** Retrieve the number of days in a month.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          this._validate(year, month, this.minDay, main.local.invalidMonth);
          return 20;
        },
        /** Retrieve the number of days in a week.
            @memberof MayanCalendar
            @return {number} The number of days. */
        daysInWeek: function() {
          return 5;
        },
        /** Retrieve the day of the week for a date.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The day of the week: 0 to number of days - 1.
            @throws Error if an invalid date or a different calendar used. */
        dayOfWeek: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          return date.day();
        },
        /** Determine whether this date is a week day.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          this._validate(year, month, day, main.local.invalidDate);
          return true;
        },
        /** Retrieve additional information about a date - Haab and Tzolkin equivalents.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {object} Additional information - contents depends on calendar.
            @throws Error if an invalid date or a different calendar used. */
        extraInfo: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          var jd = date.toJD();
          var haab = this._toHaab(jd);
          var tzolkin = this._toTzolkin(jd);
          return {
            haabMonthName: this.local.haabMonths[haab[0] - 1],
            haabMonth: haab[0],
            haabDay: haab[1],
            tzolkinDayName: this.local.tzolkinMonths[tzolkin[0] - 1],
            tzolkinDay: tzolkin[0],
            tzolkinTrecena: tzolkin[1]
          };
        },
        /** Retrieve Haab date from a Julian date.
            @memberof MayanCalendar
            @private
            @param jd  {number} The Julian date.
            @return {number[]} Corresponding Haab month and day. */
        _toHaab: function(jd) {
          jd -= this.jdEpoch;
          var day = mod(jd + 8 + (18 - 1) * 20, 365);
          return [Math.floor(day / 20) + 1, mod(day, 20)];
        },
        /** Retrieve Tzolkin date from a Julian date.
            @memberof MayanCalendar
            @private
            @param jd {number} The Julian date.
            @return {number[]} Corresponding Tzolkin day and trecena. */
        _toTzolkin: function(jd) {
          jd -= this.jdEpoch;
          return [amod(jd + 20, 20), amod(jd + 4, 13)];
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof MayanCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          return date.day() + date.month() * 20 + date.year() * 360 + this.jdEpoch;
        },
        /** Create a new date from a Julian date.
            @memberof MayanCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd) + 0.5 - this.jdEpoch;
          var year = Math.floor(jd / 360);
          jd = jd % 360;
          jd += jd < 0 ? 360 : 0;
          var month = Math.floor(jd / 20);
          var day = jd % 20;
          return this.newDate(year, month, day);
        }
      });
      function mod(a, b) {
        return a - b * Math.floor(a / b);
      }
      function amod(a, b) {
        return mod(a - 1, b) + 1;
      }
      main.calendars.mayan = MayanCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/nanakshahi.js
  var require_nanakshahi = __commonJS({
    "node_modules/world-calendars/dist/calendars/nanakshahi.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function NanakshahiCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      NanakshahiCalendar.prototype = new main.baseCalendar();
      var gregorian = main.instance("gregorian");
      assign(NanakshahiCalendar.prototype, {
        /** The calendar name.
            @memberof NanakshahiCalendar */
        name: "Nanakshahi",
        /** Julian date of start of Nanakshahi epoch: 14 March 1469 CE.
            @memberof NanakshahiCalendar */
        jdEpoch: 22576735e-1,
        /** Days per month in a common year.
            @memberof NanakshahiCalendar */
        daysPerMonth: [31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 30, 30],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof NanakshahiCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof NanakshahiCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof NanakshahiCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof NanakshahiCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof NanakshahiCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Nanakshahi",
            epochs: ["BN", "AN"],
            monthNames: [
              "Chet",
              "Vaisakh",
              "Jeth",
              "Harh",
              "Sawan",
              "Bhadon",
              "Assu",
              "Katak",
              "Maghar",
              "Poh",
              "Magh",
              "Phagun"
            ],
            monthNamesShort: ["Che", "Vai", "Jet", "Har", "Saw", "Bha", "Ass", "Kat", "Mgr", "Poh", "Mgh", "Pha"],
            dayNames: ["Somvaar", "Mangalvar", "Budhvaar", "Veervaar", "Shukarvaar", "Sanicharvaar", "Etvaar"],
            dayNamesShort: ["Som", "Mangal", "Budh", "Veer", "Shukar", "Sanichar", "Et"],
            dayNamesMin: ["So", "Ma", "Bu", "Ve", "Sh", "Sa", "Et"],
            digits: null,
            dateFormat: "dd-mm-yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof NanakshahiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(
            year,
            this.minMonth,
            this.minDay,
            main.local.invalidYear || main.regionalOptions[""].invalidYear
          );
          return gregorian.leapYear(date.year() + (date.year() < 1 ? 1 : 0) + 1469);
        },
        /** Determine the week of the year for a date.
            @memberof NanakshahiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(1 - (checkDate.dayOfWeek() || 7), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof NanakshahiCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 12 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof NanakshahiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof NanakshahiCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidMonth);
          var year = date.year();
          if (year < 0) {
            year++;
          }
          var doy = date.day();
          for (var m = 1; m < date.month(); m++) {
            doy += this.daysPerMonth[m - 1];
          }
          return doy + gregorian.toJD(year + 1468, 3, 13);
        },
        /** Create a new date from a Julian date.
            @memberof NanakshahiCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd + 0.5);
          var year = Math.floor((jd - (this.jdEpoch - 1)) / 366);
          while (jd >= this.toJD(year + 1, 1, 1)) {
            year++;
          }
          var day = jd - Math.floor(this.toJD(year, 1, 1) + 0.5) + 1;
          var month = 1;
          while (day > this.daysInMonth(year, month)) {
            day -= this.daysInMonth(year, month);
            month++;
          }
          return this.newDate(year, month, day);
        }
      });
      main.calendars.nanakshahi = NanakshahiCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/nepali.js
  var require_nepali = __commonJS({
    "node_modules/world-calendars/dist/calendars/nepali.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function NepaliCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      NepaliCalendar.prototype = new main.baseCalendar();
      assign(NepaliCalendar.prototype, {
        /** The calendar name.
            @memberof NepaliCalendar */
        name: "Nepali",
        /** Julian date of start of Nepali epoch: 14 April 57 BCE.
            @memberof NepaliCalendar */
        jdEpoch: 17007095e-1,
        /** Days per month in a common year.
            @memberof NepaliCalendar */
        daysPerMonth: [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof NepaliCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof NepaliCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof NepaliCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof NepaliCalendar */
        minDay: 1,
        /** The number of days in the year.
            @memberof NepaliCalendar */
        daysPerYear: 365,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof NepaliCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Nepali",
            epochs: ["BBS", "ABS"],
            monthNames: [
              "Baisakh",
              "Jestha",
              "Ashadh",
              "Shrawan",
              "Bhadra",
              "Ashwin",
              "Kartik",
              "Mangsir",
              "Paush",
              "Mangh",
              "Falgun",
              "Chaitra"
            ],
            monthNamesShort: ["Bai", "Je", "As", "Shra", "Bha", "Ash", "Kar", "Mang", "Pau", "Ma", "Fal", "Chai"],
            dayNames: ["Aaitabaar", "Sombaar", "Manglbaar", "Budhabaar", "Bihibaar", "Shukrabaar", "Shanibaar"],
            dayNamesShort: ["Aaita", "Som", "Mangl", "Budha", "Bihi", "Shukra", "Shani"],
            dayNamesMin: ["Aai", "So", "Man", "Bu", "Bi", "Shu", "Sha"],
            digits: null,
            dateFormat: "dd/mm/yyyy",
            firstDay: 1,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof NepaliCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          return this.daysInYear(year) !== this.daysPerYear;
        },
        /** Determine the week of the year for a date.
            @memberof NepaliCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a year.
            @memberof NepaliCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          year = date.year();
          if (typeof this.NEPALI_CALENDAR_DATA[year] === "undefined") {
            return this.daysPerYear;
          }
          var daysPerYear = 0;
          for (var month_number = this.minMonth; month_number <= 12; month_number++) {
            daysPerYear += this.NEPALI_CALENDAR_DATA[year][month_number];
          }
          return daysPerYear;
        },
        /** Retrieve the number of days in a month.
            @memberof NepaliCalendar
            @param year {CDate|number| The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          if (year.year) {
            month = year.month();
            year = year.year();
          }
          this._validate(year, month, this.minDay, main.local.invalidMonth);
          return typeof this.NEPALI_CALENDAR_DATA[year] === "undefined" ? this.daysPerMonth[month - 1] : this.NEPALI_CALENDAR_DATA[year][month];
        },
        /** Determine whether this date is a week day.
            @memberof NepaliCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return this.dayOfWeek(year, month, day) !== 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof NepaliCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(nepaliYear, nepaliMonth, nepaliDay) {
          var date = this._validate(nepaliYear, nepaliMonth, nepaliDay, main.local.invalidDate);
          nepaliYear = date.year();
          nepaliMonth = date.month();
          nepaliDay = date.day();
          var gregorianCalendar = main.instance();
          var gregorianDayOfYear = 0;
          var nepaliMonthToCheck = nepaliMonth;
          var nepaliYearToCheck = nepaliYear;
          this._createMissingCalendarData(nepaliYear);
          var gregorianYear = nepaliYear - (nepaliMonthToCheck > 9 || nepaliMonthToCheck === 9 && nepaliDay >= this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][0] ? 56 : 57);
          if (nepaliMonth !== 9) {
            gregorianDayOfYear = nepaliDay;
            nepaliMonthToCheck--;
          }
          while (nepaliMonthToCheck !== 9) {
            if (nepaliMonthToCheck <= 0) {
              nepaliMonthToCheck = 12;
              nepaliYearToCheck--;
            }
            gregorianDayOfYear += this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][nepaliMonthToCheck];
            nepaliMonthToCheck--;
          }
          if (nepaliMonth === 9) {
            gregorianDayOfYear += nepaliDay - this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][0];
            if (gregorianDayOfYear < 0) {
              gregorianDayOfYear += gregorianCalendar.daysInYear(gregorianYear);
            }
          } else {
            gregorianDayOfYear += this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][9] - this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][0];
          }
          return gregorianCalendar.newDate(gregorianYear, 1, 1).add(gregorianDayOfYear, "d").toJD();
        },
        /** Create a new date from a Julian date.
            @memberof NepaliCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var gregorianCalendar = main.instance();
          var gregorianDate = gregorianCalendar.fromJD(jd);
          var gregorianYear = gregorianDate.year();
          var gregorianDayOfYear = gregorianDate.dayOfYear();
          var nepaliYear = gregorianYear + 56;
          this._createMissingCalendarData(nepaliYear);
          var nepaliMonth = 9;
          var dayOfFirstJanInPaush = this.NEPALI_CALENDAR_DATA[nepaliYear][0];
          var daysSinceJanFirstToEndOfNepaliMonth = this.NEPALI_CALENDAR_DATA[nepaliYear][nepaliMonth] - dayOfFirstJanInPaush + 1;
          while (gregorianDayOfYear > daysSinceJanFirstToEndOfNepaliMonth) {
            nepaliMonth++;
            if (nepaliMonth > 12) {
              nepaliMonth = 1;
              nepaliYear++;
            }
            daysSinceJanFirstToEndOfNepaliMonth += this.NEPALI_CALENDAR_DATA[nepaliYear][nepaliMonth];
          }
          var nepaliDayOfMonth = this.NEPALI_CALENDAR_DATA[nepaliYear][nepaliMonth] - (daysSinceJanFirstToEndOfNepaliMonth - gregorianDayOfYear);
          return this.newDate(nepaliYear, nepaliMonth, nepaliDayOfMonth);
        },
        /** Creates missing data in the NEPALI_CALENDAR_DATA table.
            This data will not be correct but just give an estimated result. Mostly -/+ 1 day
            @private
            @param nepaliYear {number} The missing year number. */
        _createMissingCalendarData: function(nepaliYear) {
          var tmp_calendar_data = this.daysPerMonth.slice(0);
          tmp_calendar_data.unshift(17);
          for (var nepaliYearToCreate = nepaliYear - 1; nepaliYearToCreate < nepaliYear + 2; nepaliYearToCreate++) {
            if (typeof this.NEPALI_CALENDAR_DATA[nepaliYearToCreate] === "undefined") {
              this.NEPALI_CALENDAR_DATA[nepaliYearToCreate] = tmp_calendar_data;
            }
          }
        },
        NEPALI_CALENDAR_DATA: {
          // These data are from http://www.ashesh.com.np
          1970: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1971: [18, 31, 31, 32, 31, 32, 30, 30, 29, 30, 29, 30, 30],
          1972: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          1973: [19, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          1974: [19, 31, 31, 32, 30, 31, 31, 30, 29, 30, 29, 30, 30],
          1975: [18, 31, 31, 32, 32, 30, 31, 30, 29, 30, 29, 30, 30],
          1976: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          1977: [18, 31, 32, 31, 32, 31, 31, 29, 30, 29, 30, 29, 31],
          1978: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1979: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          1980: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          1981: [18, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          1982: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1983: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          1984: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          1985: [18, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          1986: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1987: [18, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          1988: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          1989: [18, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          1990: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1991: [18, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          // These data are from http://nepalicalendar.rat32.com/index.php
          1992: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          1993: [18, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          1994: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1995: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          1996: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          1997: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1998: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1999: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2e3: [17, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2001: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2002: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2003: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2004: [17, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2005: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2006: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2007: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2008: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 29, 31],
          2009: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2010: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2011: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2012: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          2013: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2014: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2015: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2016: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          2017: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2018: [18, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2019: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2020: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2021: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2022: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          2023: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2024: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2025: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2026: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2027: [17, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2028: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2029: [18, 31, 31, 32, 31, 32, 30, 30, 29, 30, 29, 30, 30],
          2030: [17, 31, 32, 31, 32, 31, 30, 30, 30, 30, 30, 30, 31],
          2031: [17, 31, 32, 31, 32, 31, 31, 31, 31, 31, 31, 31, 31],
          2032: [17, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32],
          2033: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2034: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2035: [17, 30, 32, 31, 32, 31, 31, 29, 30, 30, 29, 29, 31],
          2036: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2037: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2038: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2039: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          2040: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2041: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2042: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2043: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          2044: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2045: [18, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2046: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2047: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2048: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2049: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          2050: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2051: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2052: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2053: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          2054: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2055: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 30, 29, 30],
          2056: [17, 31, 31, 32, 31, 32, 30, 30, 29, 30, 29, 30, 30],
          2057: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2058: [17, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2059: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2060: [17, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2061: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2062: [17, 30, 32, 31, 32, 31, 31, 29, 30, 29, 30, 29, 31],
          2063: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2064: [17, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2065: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2066: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 29, 31],
          2067: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2068: [17, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2069: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2070: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          2071: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2072: [17, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2073: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2074: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2075: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2076: [16, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          2077: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2078: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2079: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2080: [16, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          // These data are from http://www.ashesh.com.np/nepali-calendar/
          2081: [17, 31, 31, 32, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2082: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2083: [17, 31, 31, 32, 31, 31, 30, 30, 30, 29, 30, 30, 30],
          2084: [17, 31, 31, 32, 31, 31, 30, 30, 30, 29, 30, 30, 30],
          2085: [17, 31, 32, 31, 32, 31, 31, 30, 30, 29, 30, 30, 30],
          2086: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2087: [16, 31, 31, 32, 31, 31, 31, 30, 30, 29, 30, 30, 30],
          2088: [16, 30, 31, 32, 32, 30, 31, 30, 30, 29, 30, 30, 30],
          2089: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2090: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2091: [16, 31, 31, 32, 31, 31, 31, 30, 30, 29, 30, 30, 30],
          2092: [16, 31, 31, 32, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2093: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2094: [17, 31, 31, 32, 31, 31, 30, 30, 30, 29, 30, 30, 30],
          2095: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 30, 30, 30],
          2096: [17, 30, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2097: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2098: [17, 31, 31, 32, 31, 31, 31, 29, 30, 29, 30, 30, 31],
          2099: [17, 31, 31, 32, 31, 31, 31, 30, 29, 29, 30, 30, 30],
          2100: [17, 31, 32, 31, 32, 30, 31, 30, 29, 30, 29, 30, 30]
        }
      });
      main.calendars.nepali = NepaliCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/persian.js
  var require_persian = __commonJS({
    "node_modules/world-calendars/dist/calendars/persian.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function PersianCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      PersianCalendar.prototype = new main.baseCalendar();
      assign(PersianCalendar.prototype, {
        /** The calendar name.
            @memberof PersianCalendar */
        name: "Persian",
        /** Julian date of start of Persian epoch: 19 March 622 CE.
            @memberof PersianCalendar */
        jdEpoch: 19483205e-1,
        /** Days per month in a common year.
            @memberof PersianCalendar */
        daysPerMonth: [31, 31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 29],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof PersianCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof PersianCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof PersianCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof PersianCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof PersianCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Persian",
            epochs: ["BP", "AP"],
            monthNames: [
              "Farvardin",
              "Ordibehesht",
              "Khordad",
              "Tir",
              "Mordad",
              "Shahrivar",
              "Mehr",
              "Aban",
              "Azar",
              "Day",
              "Bahman",
              "Esfand"
            ],
            monthNamesShort: ["Far", "Ord", "Kho", "Tir", "Mor", "Sha", "Meh", "Aba", "Aza", "Day", "Bah", "Esf"],
            dayNames: ["Yekshambe", "Doshambe", "Seshambe", "Ch\xE6harshambe", "Panjshambe", "Jom'e", "Shambe"],
            dayNamesShort: ["Yek", "Do", "Se", "Ch\xE6", "Panj", "Jom", "Sha"],
            dayNamesMin: ["Ye", "Do", "Se", "Ch", "Pa", "Jo", "Sh"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 6,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof PersianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return ((date.year() - (date.year() > 0 ? 474 : 473)) % 2820 + 474 + 38) * 682 % 2816 < 682;
        },
        /** Determine the week of the year for a date.
            @memberof PersianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-((checkDate.dayOfWeek() + 1) % 7), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof PersianCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 12 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof PersianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return this.dayOfWeek(year, month, day) !== 5;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof PersianCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          month = date.month();
          day = date.day();
          var epBase = year - (year >= 0 ? 474 : 473);
          var epYear = 474 + mod(epBase, 2820);
          return day + (month <= 7 ? (month - 1) * 31 : (month - 1) * 30 + 6) + Math.floor((epYear * 682 - 110) / 2816) + (epYear - 1) * 365 + Math.floor(epBase / 2820) * 1029983 + this.jdEpoch - 1;
        },
        /** Create a new date from a Julian date.
            @memberof PersianCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd) + 0.5;
          var depoch = jd - this.toJD(475, 1, 1);
          var cycle = Math.floor(depoch / 1029983);
          var cyear = mod(depoch, 1029983);
          var ycycle = 2820;
          if (cyear !== 1029982) {
            var aux1 = Math.floor(cyear / 366);
            var aux2 = mod(cyear, 366);
            ycycle = Math.floor((2134 * aux1 + 2816 * aux2 + 2815) / 1028522) + aux1 + 1;
          }
          var year = ycycle + 2820 * cycle + 474;
          year = year <= 0 ? year - 1 : year;
          var yday = jd - this.toJD(year, 1, 1) + 1;
          var month = yday <= 186 ? Math.ceil(yday / 31) : Math.ceil((yday - 6) / 30);
          var day = jd - this.toJD(year, month, 1) + 1;
          return this.newDate(year, month, day);
        }
      });
      function mod(a, b) {
        return a - b * Math.floor(a / b);
      }
      main.calendars.persian = PersianCalendar;
      main.calendars.jalali = PersianCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/taiwan.js
  var require_taiwan = __commonJS({
    "node_modules/world-calendars/dist/calendars/taiwan.js"() {
      var main = require_main();
      var assign = require_object_assign();
      var gregorianCalendar = main.instance();
      function TaiwanCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      TaiwanCalendar.prototype = new main.baseCalendar();
      assign(TaiwanCalendar.prototype, {
        /** The calendar name.
            @memberof TaiwanCalendar */
        name: "Taiwan",
        /** Julian date of start of Taiwan epoch: 1 January 1912 CE (Gregorian).
            @memberof TaiwanCalendar */
        jdEpoch: 24194025e-1,
        /** Difference in years between Taiwan and Gregorian calendars.
            @memberof TaiwanCalendar */
        yearsOffset: 1911,
        /** Days per month in a common year.
            @memberof TaiwanCalendar */
        daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof TaiwanCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof TaiwanCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof TaiwanCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof TaiwanCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof TaiwanCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Taiwan",
            epochs: ["BROC", "ROC"],
            monthNames: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 1,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof TaiwanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.leapYear(year);
        },
        /** Determine the week of the year for a date - ISO 8601.
            @memberof TaiwanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.weekOfYear(year, date.month(), date.day());
        },
        /** Retrieve the number of days in a month.
            @memberof TaiwanCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof TaiwanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof TaiwanCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.toJD(year, date.month(), date.day());
        },
        /** Create a new date from a Julian date.
            @memberof TaiwanCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var date = gregorianCalendar.fromJD(jd);
          var year = this._g2tYear(date.year());
          return this.newDate(year, date.month(), date.day());
        },
        /** Convert Taiwanese to Gregorian year.
            @memberof TaiwanCalendar
            @private
            @param year {number} The Taiwanese year.
            @return {number} The corresponding Gregorian year. */
        _t2gYear: function(year) {
          return year + this.yearsOffset + (year >= -this.yearsOffset && year <= -1 ? 1 : 0);
        },
        /** Convert Gregorian to Taiwanese year.
            @memberof TaiwanCalendar
            @private
            @param year {number} The Gregorian year.
            @return {number} The corresponding Taiwanese year. */
        _g2tYear: function(year) {
          return year - this.yearsOffset - (year >= 1 && year <= this.yearsOffset ? 1 : 0);
        }
      });
      main.calendars.taiwan = TaiwanCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/thai.js
  var require_thai = __commonJS({
    "node_modules/world-calendars/dist/calendars/thai.js"() {
      var main = require_main();
      var assign = require_object_assign();
      var gregorianCalendar = main.instance();
      function ThaiCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      ThaiCalendar.prototype = new main.baseCalendar();
      assign(ThaiCalendar.prototype, {
        /** The calendar name.
            @memberof ThaiCalendar */
        name: "Thai",
        /** Julian date of start of Thai epoch: 1 January 543 BCE (Gregorian).
            @memberof ThaiCalendar */
        jdEpoch: 15230985e-1,
        /** Difference in years between Thai and Gregorian calendars.
            @memberof ThaiCalendar */
        yearsOffset: 543,
        /** Days per month in a common year.
            @memberof ThaiCalendar */
        daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof ThaiCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof ThaiCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof ThaiCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof ThaiCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof ThaiCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Thai",
            epochs: ["BBE", "BE"],
            monthNames: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "dd/mm/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof ThaiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.leapYear(year);
        },
        /** Determine the week of the year for a date - ISO 8601.
            @memberof ThaiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.weekOfYear(year, date.month(), date.day());
        },
        /** Retrieve the number of days in a month.
            @memberof ThaiCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof ThaiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof ThaiCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.toJD(year, date.month(), date.day());
        },
        /** Create a new date from a Julian date.
            @memberof ThaiCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var date = gregorianCalendar.fromJD(jd);
          var year = this._g2tYear(date.year());
          return this.newDate(year, date.month(), date.day());
        },
        /** Convert Thai to Gregorian year.
            @memberof ThaiCalendar
            @private
            @param year {number} The Thai year.
            @return {number} The corresponding Gregorian year. */
        _t2gYear: function(year) {
          return year - this.yearsOffset - (year >= 1 && year <= this.yearsOffset ? 1 : 0);
        },
        /** Convert Gregorian to Thai year.
            @memberof ThaiCalendar
            @private
            @param year {number} The Gregorian year.
            @return {number} The corresponding Thai year. */
        _g2tYear: function(year) {
          return year + this.yearsOffset + (year >= -this.yearsOffset && year <= -1 ? 1 : 0);
        }
      });
      main.calendars.thai = ThaiCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/ummalqura.js
  var require_ummalqura = __commonJS({
    "node_modules/world-calendars/dist/calendars/ummalqura.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function UmmAlQuraCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      UmmAlQuraCalendar.prototype = new main.baseCalendar();
      assign(UmmAlQuraCalendar.prototype, {
        /** The calendar name.
            @memberof UmmAlQuraCalendar */
        name: "UmmAlQura",
        //jdEpoch: 1948440, // Julian date of start of UmmAlQura epoch: 14 March 1937 CE
        //daysPerMonth: // Days per month in a common year, replaced by a method.
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof UmmAlQuraCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof UmmAlQuraCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof UmmAlQuraCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof UmmAlQuraCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof UmmAlQuraCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Umm al-Qura",
            epochs: ["BH", "AH"],
            monthNames: [
              "Al-Muharram",
              "Safar",
              "Rabi' al-awwal",
              "Rabi' Al-Thani",
              "Jumada Al-Awwal",
              "Jumada Al-Thani",
              "Rajab",
              "Sha'aban",
              "Ramadan",
              "Shawwal",
              "Dhu al-Qi'dah",
              "Dhu al-Hijjah"
            ],
            monthNamesShort: ["Muh", "Saf", "Rab1", "Rab2", "Jum1", "Jum2", "Raj", "Sha'", "Ram", "Shaw", "DhuQ", "DhuH"],
            dayNames: ["Yawm al-Ahad", "Yawm al-Ithnain", "Yawm al-Thal\u0101th\u0101\u2019", "Yawm al-Arba\u2018\u0101\u2019", "Yawm al-Kham\u012Bs", "Yawm al-Jum\u2018a", "Yawm al-Sabt"],
            dayNamesMin: ["Ah", "Ith", "Th", "Ar", "Kh", "Ju", "Sa"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 6,
            isRTL: true
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return this.daysInYear(date.year()) === 355;
        },
        /** Determine the week of the year for a date.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a year.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          var daysCount = 0;
          for (var i = 1; i <= 12; i++) {
            daysCount += this.daysInMonth(year, i);
          }
          return daysCount;
        },
        /** Retrieve the number of days in a month.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          var mcjdn = date.toJD() - 24e5 + 0.5;
          var index = 0;
          for (var i = 0; i < ummalqura_dat.length; i++) {
            if (ummalqura_dat[i] > mcjdn) {
              return ummalqura_dat[index] - ummalqura_dat[index - 1];
            }
            index++;
          }
          return 30;
        },
        /** Determine whether this date is a week day.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return this.dayOfWeek(year, month, day) !== 5;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          var index = 12 * (date.year() - 1) + date.month() - 15292;
          var mcjdn = date.day() + ummalqura_dat[index - 1] - 1;
          return mcjdn + 24e5 - 0.5;
        },
        /** Create a new date from a Julian date.
            @memberof UmmAlQuraCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var mcjdn = jd - 24e5 + 0.5;
          var index = 0;
          for (var i = 0; i < ummalqura_dat.length; i++) {
            if (ummalqura_dat[i] > mcjdn) break;
            index++;
          }
          var lunation = index + 15292;
          var ii = Math.floor((lunation - 1) / 12);
          var year = ii + 1;
          var month = lunation - 12 * ii;
          var day = mcjdn - ummalqura_dat[index - 1] + 1;
          return this.newDate(year, month, day);
        },
        /** Determine whether a date is valid for this calendar.
            @memberof UmmAlQuraCalendar
            @param year {number} The year to examine.
            @param month {number} The month to examine.
            @param day {number} The day to examine.
            @return {boolean} <code>true</code> if a valid date, <code>false</code> if not. */
        isValid: function(year, month, day) {
          var valid = main.baseCalendar.prototype.isValid.apply(this, arguments);
          if (valid) {
            year = year.year != null ? year.year : year;
            valid = year >= 1276 && year <= 1500;
          }
          return valid;
        },
        /** Check that a candidate date is from the same calendar and is valid.
            @memberof UmmAlQuraCalendar
            @private
            @param year {CDate|number} The date to validate or the year to validate.
            @param month {number} The month to validate.
            @param day {number} The day to validate.
            @param error {string} Error message if invalid.
            @throws Error if different calendars used or invalid date. */
        _validate: function(year, month, day, error) {
          var date = main.baseCalendar.prototype._validate.apply(this, arguments);
          if (date.year < 1276 || date.year > 1500) {
            throw error.replace(/\{0\}/, this.local.name);
          }
          return date;
        }
      });
      main.calendars.ummalqura = UmmAlQuraCalendar;
      var ummalqura_dat = [
        20,
        50,
        79,
        109,
        138,
        168,
        197,
        227,
        256,
        286,
        315,
        345,
        374,
        404,
        433,
        463,
        492,
        522,
        551,
        581,
        611,
        641,
        670,
        700,
        729,
        759,
        788,
        818,
        847,
        877,
        906,
        936,
        965,
        995,
        1024,
        1054,
        1083,
        1113,
        1142,
        1172,
        1201,
        1231,
        1260,
        1290,
        1320,
        1350,
        1379,
        1409,
        1438,
        1468,
        1497,
        1527,
        1556,
        1586,
        1615,
        1645,
        1674,
        1704,
        1733,
        1763,
        1792,
        1822,
        1851,
        1881,
        1910,
        1940,
        1969,
        1999,
        2028,
        2058,
        2087,
        2117,
        2146,
        2176,
        2205,
        2235,
        2264,
        2294,
        2323,
        2353,
        2383,
        2413,
        2442,
        2472,
        2501,
        2531,
        2560,
        2590,
        2619,
        2649,
        2678,
        2708,
        2737,
        2767,
        2796,
        2826,
        2855,
        2885,
        2914,
        2944,
        2973,
        3003,
        3032,
        3062,
        3091,
        3121,
        3150,
        3180,
        3209,
        3239,
        3268,
        3298,
        3327,
        3357,
        3386,
        3416,
        3446,
        3476,
        3505,
        3535,
        3564,
        3594,
        3623,
        3653,
        3682,
        3712,
        3741,
        3771,
        3800,
        3830,
        3859,
        3889,
        3918,
        3948,
        3977,
        4007,
        4036,
        4066,
        4095,
        4125,
        4155,
        4185,
        4214,
        4244,
        4273,
        4303,
        4332,
        4362,
        4391,
        4421,
        4450,
        4480,
        4509,
        4539,
        4568,
        4598,
        4627,
        4657,
        4686,
        4716,
        4745,
        4775,
        4804,
        4834,
        4863,
        4893,
        4922,
        4952,
        4981,
        5011,
        5040,
        5070,
        5099,
        5129,
        5158,
        5188,
        5218,
        5248,
        5277,
        5307,
        5336,
        5366,
        5395,
        5425,
        5454,
        5484,
        5513,
        5543,
        5572,
        5602,
        5631,
        5661,
        5690,
        5720,
        5749,
        5779,
        5808,
        5838,
        5867,
        5897,
        5926,
        5956,
        5985,
        6015,
        6044,
        6074,
        6103,
        6133,
        6162,
        6192,
        6221,
        6251,
        6281,
        6311,
        6340,
        6370,
        6399,
        6429,
        6458,
        6488,
        6517,
        6547,
        6576,
        6606,
        6635,
        6665,
        6694,
        6724,
        6753,
        6783,
        6812,
        6842,
        6871,
        6901,
        6930,
        6960,
        6989,
        7019,
        7048,
        7078,
        7107,
        7137,
        7166,
        7196,
        7225,
        7255,
        7284,
        7314,
        7344,
        7374,
        7403,
        7433,
        7462,
        7492,
        7521,
        7551,
        7580,
        7610,
        7639,
        7669,
        7698,
        7728,
        7757,
        7787,
        7816,
        7846,
        7875,
        7905,
        7934,
        7964,
        7993,
        8023,
        8053,
        8083,
        8112,
        8142,
        8171,
        8201,
        8230,
        8260,
        8289,
        8319,
        8348,
        8378,
        8407,
        8437,
        8466,
        8496,
        8525,
        8555,
        8584,
        8614,
        8643,
        8673,
        8702,
        8732,
        8761,
        8791,
        8821,
        8850,
        8880,
        8909,
        8938,
        8968,
        8997,
        9027,
        9056,
        9086,
        9115,
        9145,
        9175,
        9205,
        9234,
        9264,
        9293,
        9322,
        9352,
        9381,
        9410,
        9440,
        9470,
        9499,
        9529,
        9559,
        9589,
        9618,
        9648,
        9677,
        9706,
        9736,
        9765,
        9794,
        9824,
        9853,
        9883,
        9913,
        9943,
        9972,
        10002,
        10032,
        10061,
        10090,
        10120,
        10149,
        10178,
        10208,
        10237,
        10267,
        10297,
        10326,
        10356,
        10386,
        10415,
        10445,
        10474,
        10504,
        10533,
        10562,
        10592,
        10621,
        10651,
        10680,
        10710,
        10740,
        10770,
        10799,
        10829,
        10858,
        10888,
        10917,
        10947,
        10976,
        11005,
        11035,
        11064,
        11094,
        11124,
        11153,
        11183,
        11213,
        11242,
        11272,
        11301,
        11331,
        11360,
        11389,
        11419,
        11448,
        11478,
        11507,
        11537,
        11567,
        11596,
        11626,
        11655,
        11685,
        11715,
        11744,
        11774,
        11803,
        11832,
        11862,
        11891,
        11921,
        11950,
        11980,
        12010,
        12039,
        12069,
        12099,
        12128,
        12158,
        12187,
        12216,
        12246,
        12275,
        12304,
        12334,
        12364,
        12393,
        12423,
        12453,
        12483,
        12512,
        12542,
        12571,
        12600,
        12630,
        12659,
        12688,
        12718,
        12747,
        12777,
        12807,
        12837,
        12866,
        12896,
        12926,
        12955,
        12984,
        13014,
        13043,
        13072,
        13102,
        13131,
        13161,
        13191,
        13220,
        13250,
        13280,
        13310,
        13339,
        13368,
        13398,
        13427,
        13456,
        13486,
        13515,
        13545,
        13574,
        13604,
        13634,
        13664,
        13693,
        13723,
        13752,
        13782,
        13811,
        13840,
        13870,
        13899,
        13929,
        13958,
        13988,
        14018,
        14047,
        14077,
        14107,
        14136,
        14166,
        14195,
        14224,
        14254,
        14283,
        14313,
        14342,
        14372,
        14401,
        14431,
        14461,
        14490,
        14520,
        14550,
        14579,
        14609,
        14638,
        14667,
        14697,
        14726,
        14756,
        14785,
        14815,
        14844,
        14874,
        14904,
        14933,
        14963,
        14993,
        15021,
        15051,
        15081,
        15110,
        15140,
        15169,
        15199,
        15228,
        15258,
        15287,
        15317,
        15347,
        15377,
        15406,
        15436,
        15465,
        15494,
        15524,
        15553,
        15582,
        15612,
        15641,
        15671,
        15701,
        15731,
        15760,
        15790,
        15820,
        15849,
        15878,
        15908,
        15937,
        15966,
        15996,
        16025,
        16055,
        16085,
        16114,
        16144,
        16174,
        16204,
        16233,
        16262,
        16292,
        16321,
        16350,
        16380,
        16409,
        16439,
        16468,
        16498,
        16528,
        16558,
        16587,
        16617,
        16646,
        16676,
        16705,
        16734,
        16764,
        16793,
        16823,
        16852,
        16882,
        16912,
        16941,
        16971,
        17001,
        17030,
        17060,
        17089,
        17118,
        17148,
        17177,
        17207,
        17236,
        17266,
        17295,
        17325,
        17355,
        17384,
        17414,
        17444,
        17473,
        17502,
        17532,
        17561,
        17591,
        17620,
        17650,
        17679,
        17709,
        17738,
        17768,
        17798,
        17827,
        17857,
        17886,
        17916,
        17945,
        17975,
        18004,
        18034,
        18063,
        18093,
        18122,
        18152,
        18181,
        18211,
        18241,
        18270,
        18300,
        18330,
        18359,
        18388,
        18418,
        18447,
        18476,
        18506,
        18535,
        18565,
        18595,
        18625,
        18654,
        18684,
        18714,
        18743,
        18772,
        18802,
        18831,
        18860,
        18890,
        18919,
        18949,
        18979,
        19008,
        19038,
        19068,
        19098,
        19127,
        19156,
        19186,
        19215,
        19244,
        19274,
        19303,
        19333,
        19362,
        19392,
        19422,
        19452,
        19481,
        19511,
        19540,
        19570,
        19599,
        19628,
        19658,
        19687,
        19717,
        19746,
        19776,
        19806,
        19836,
        19865,
        19895,
        19924,
        19954,
        19983,
        20012,
        20042,
        20071,
        20101,
        20130,
        20160,
        20190,
        20219,
        20249,
        20279,
        20308,
        20338,
        20367,
        20396,
        20426,
        20455,
        20485,
        20514,
        20544,
        20573,
        20603,
        20633,
        20662,
        20692,
        20721,
        20751,
        20780,
        20810,
        20839,
        20869,
        20898,
        20928,
        20957,
        20987,
        21016,
        21046,
        21076,
        21105,
        21135,
        21164,
        21194,
        21223,
        21253,
        21282,
        21312,
        21341,
        21371,
        21400,
        21430,
        21459,
        21489,
        21519,
        21548,
        21578,
        21607,
        21637,
        21666,
        21696,
        21725,
        21754,
        21784,
        21813,
        21843,
        21873,
        21902,
        21932,
        21962,
        21991,
        22021,
        22050,
        22080,
        22109,
        22138,
        22168,
        22197,
        22227,
        22256,
        22286,
        22316,
        22346,
        22375,
        22405,
        22434,
        22464,
        22493,
        22522,
        22552,
        22581,
        22611,
        22640,
        22670,
        22700,
        22730,
        22759,
        22789,
        22818,
        22848,
        22877,
        22906,
        22936,
        22965,
        22994,
        23024,
        23054,
        23083,
        23113,
        23143,
        23173,
        23202,
        23232,
        23261,
        23290,
        23320,
        23349,
        23379,
        23408,
        23438,
        23467,
        23497,
        23527,
        23556,
        23586,
        23616,
        23645,
        23674,
        23704,
        23733,
        23763,
        23792,
        23822,
        23851,
        23881,
        23910,
        23940,
        23970,
        23999,
        24029,
        24058,
        24088,
        24117,
        24147,
        24176,
        24206,
        24235,
        24265,
        24294,
        24324,
        24353,
        24383,
        24413,
        24442,
        24472,
        24501,
        24531,
        24560,
        24590,
        24619,
        24648,
        24678,
        24707,
        24737,
        24767,
        24796,
        24826,
        24856,
        24885,
        24915,
        24944,
        24974,
        25003,
        25032,
        25062,
        25091,
        25121,
        25150,
        25180,
        25210,
        25240,
        25269,
        25299,
        25328,
        25358,
        25387,
        25416,
        25446,
        25475,
        25505,
        25534,
        25564,
        25594,
        25624,
        25653,
        25683,
        25712,
        25742,
        25771,
        25800,
        25830,
        25859,
        25888,
        25918,
        25948,
        25977,
        26007,
        26037,
        26067,
        26096,
        26126,
        26155,
        26184,
        26214,
        26243,
        26272,
        26302,
        26332,
        26361,
        26391,
        26421,
        26451,
        26480,
        26510,
        26539,
        26568,
        26598,
        26627,
        26656,
        26686,
        26715,
        26745,
        26775,
        26805,
        26834,
        26864,
        26893,
        26923,
        26952,
        26982,
        27011,
        27041,
        27070,
        27099,
        27129,
        27159,
        27188,
        27218,
        27248,
        27277,
        27307,
        27336,
        27366,
        27395,
        27425,
        27454,
        27484,
        27513,
        27542,
        27572,
        27602,
        27631,
        27661,
        27691,
        27720,
        27750,
        27779,
        27809,
        27838,
        27868,
        27897,
        27926,
        27956,
        27985,
        28015,
        28045,
        28074,
        28104,
        28134,
        28163,
        28193,
        28222,
        28252,
        28281,
        28310,
        28340,
        28369,
        28399,
        28428,
        28458,
        28488,
        28517,
        28547,
        28577,
        // From 1356
        28607,
        28636,
        28665,
        28695,
        28724,
        28754,
        28783,
        28813,
        28843,
        28872,
        28901,
        28931,
        28960,
        28990,
        29019,
        29049,
        29078,
        29108,
        29137,
        29167,
        29196,
        29226,
        29255,
        29285,
        29315,
        29345,
        29375,
        29404,
        29434,
        29463,
        29492,
        29522,
        29551,
        29580,
        29610,
        29640,
        29669,
        29699,
        29729,
        29759,
        29788,
        29818,
        29847,
        29876,
        29906,
        29935,
        29964,
        29994,
        30023,
        30053,
        30082,
        30112,
        30141,
        30171,
        30200,
        30230,
        30259,
        30289,
        30318,
        30348,
        30378,
        30408,
        30437,
        30467,
        30496,
        30526,
        30555,
        30585,
        30614,
        30644,
        30673,
        30703,
        30732,
        30762,
        30791,
        30821,
        30850,
        30880,
        30909,
        30939,
        30968,
        30998,
        31027,
        31057,
        31086,
        31116,
        31145,
        31175,
        31204,
        31234,
        31263,
        31293,
        31322,
        31352,
        31381,
        31411,
        31441,
        31471,
        31500,
        31530,
        31559,
        31589,
        31618,
        31648,
        31676,
        31706,
        31736,
        31766,
        31795,
        31825,
        31854,
        31884,
        31913,
        31943,
        31972,
        32002,
        32031,
        32061,
        32090,
        32120,
        32150,
        32180,
        32209,
        32239,
        32268,
        32298,
        32327,
        32357,
        32386,
        32416,
        32445,
        32475,
        32504,
        32534,
        32563,
        32593,
        32622,
        32652,
        32681,
        32711,
        32740,
        32770,
        32799,
        32829,
        32858,
        32888,
        32917,
        32947,
        32976,
        33006,
        33035,
        33065,
        33094,
        33124,
        33153,
        33183,
        33213,
        33243,
        33272,
        33302,
        33331,
        33361,
        33390,
        33420,
        33450,
        33479,
        33509,
        33539,
        33568,
        33598,
        33627,
        33657,
        33686,
        33716,
        33745,
        33775,
        33804,
        33834,
        33863,
        33893,
        33922,
        33952,
        33981,
        34011,
        34040,
        34069,
        34099,
        34128,
        34158,
        34187,
        34217,
        34247,
        34277,
        34306,
        34336,
        34365,
        34395,
        34424,
        34454,
        34483,
        34512,
        34542,
        34571,
        34601,
        34631,
        34660,
        34690,
        34719,
        34749,
        34778,
        34808,
        34837,
        34867,
        34896,
        34926,
        34955,
        34985,
        35015,
        35044,
        35074,
        35103,
        35133,
        35162,
        35192,
        35222,
        35251,
        35280,
        35310,
        35340,
        35370,
        35399,
        35429,
        35458,
        35488,
        35517,
        35547,
        35576,
        35605,
        35635,
        35665,
        35694,
        35723,
        35753,
        35782,
        35811,
        35841,
        35871,
        35901,
        35930,
        35960,
        35989,
        36019,
        36048,
        36078,
        36107,
        36136,
        36166,
        36195,
        36225,
        36254,
        36284,
        36314,
        36343,
        36373,
        36403,
        36433,
        36462,
        36492,
        36521,
        36551,
        36580,
        36610,
        36639,
        36669,
        36698,
        36728,
        36757,
        36786,
        36816,
        36845,
        36875,
        36904,
        36934,
        36963,
        36993,
        37022,
        37052,
        37081,
        37111,
        37141,
        37170,
        37200,
        37229,
        37259,
        37288,
        37318,
        37347,
        37377,
        37406,
        37436,
        37465,
        37495,
        37524,
        37554,
        37584,
        37613,
        37643,
        37672,
        37701,
        37731,
        37760,
        37790,
        37819,
        37849,
        37878,
        37908,
        37938,
        37967,
        37997,
        38027,
        38056,
        38085,
        38115,
        38144,
        38174,
        38203,
        38233,
        38262,
        38292,
        38322,
        38351,
        38381,
        38410,
        38440,
        38469,
        38499,
        38528,
        38558,
        38587,
        38617,
        38646,
        38676,
        38705,
        38735,
        38764,
        38794,
        38823,
        38853,
        38882,
        38912,
        38941,
        38971,
        39001,
        39030,
        39059,
        39089,
        39118,
        39148,
        39178,
        39208,
        39237,
        39267,
        39297,
        39326,
        39355,
        39385,
        39414,
        39444,
        39473,
        39503,
        39532,
        39562,
        39592,
        39621,
        39650,
        39680,
        39709,
        39739,
        39768,
        39798,
        39827,
        39857,
        39886,
        39916,
        39946,
        39975,
        40005,
        40035,
        40064,
        40094,
        40123,
        40153,
        40182,
        40212,
        40241,
        40271,
        40300,
        40330,
        40359,
        40389,
        40418,
        40448,
        40477,
        40507,
        40536,
        40566,
        40595,
        40625,
        40655,
        40685,
        40714,
        40744,
        40773,
        40803,
        40832,
        40862,
        40892,
        40921,
        40951,
        40980,
        41009,
        41039,
        41068,
        41098,
        41127,
        41157,
        41186,
        41216,
        41245,
        41275,
        41304,
        41334,
        41364,
        41393,
        41422,
        41452,
        41481,
        41511,
        41540,
        41570,
        41599,
        41629,
        41658,
        41688,
        41718,
        41748,
        41777,
        41807,
        41836,
        41865,
        41894,
        41924,
        41953,
        41983,
        42012,
        42042,
        42072,
        42102,
        42131,
        42161,
        42190,
        42220,
        42249,
        42279,
        42308,
        42337,
        42367,
        42397,
        42426,
        42456,
        42485,
        42515,
        42545,
        42574,
        42604,
        42633,
        42662,
        42692,
        42721,
        42751,
        42780,
        42810,
        42839,
        42869,
        42899,
        42929,
        42958,
        42988,
        43017,
        43046,
        43076,
        43105,
        43135,
        43164,
        43194,
        43223,
        43253,
        43283,
        43312,
        43342,
        43371,
        43401,
        43430,
        43460,
        43489,
        43519,
        43548,
        43578,
        43607,
        43637,
        43666,
        43696,
        43726,
        43755,
        43785,
        43814,
        43844,
        43873,
        43903,
        43932,
        43962,
        43991,
        44021,
        44050,
        44080,
        44109,
        44139,
        44169,
        44198,
        44228,
        44258,
        44287,
        44317,
        44346,
        44375,
        44405,
        44434,
        44464,
        44493,
        44523,
        44553,
        44582,
        44612,
        44641,
        44671,
        44700,
        44730,
        44759,
        44788,
        44818,
        44847,
        44877,
        44906,
        44936,
        44966,
        44996,
        45025,
        45055,
        45084,
        45114,
        45143,
        45172,
        45202,
        45231,
        45261,
        45290,
        45320,
        45350,
        45380,
        45409,
        45439,
        45468,
        45498,
        45527,
        45556,
        45586,
        45615,
        45644,
        45674,
        45704,
        45733,
        45763,
        45793,
        45823,
        45852,
        45882,
        45911,
        45940,
        45970,
        45999,
        46028,
        46058,
        46088,
        46117,
        46147,
        46177,
        46206,
        46236,
        46265,
        46295,
        46324,
        46354,
        46383,
        46413,
        46442,
        46472,
        46501,
        46531,
        46560,
        46590,
        46620,
        46649,
        46679,
        46708,
        46738,
        46767,
        46797,
        46826,
        46856,
        46885,
        46915,
        46944,
        46974,
        47003,
        47033,
        47063,
        47092,
        47122,
        47151,
        47181,
        47210,
        47240,
        47269,
        47298,
        47328,
        47357,
        47387,
        47417,
        47446,
        47476,
        47506,
        47535,
        47565,
        47594,
        47624,
        47653,
        47682,
        47712,
        47741,
        47771,
        47800,
        47830,
        47860,
        47890,
        47919,
        47949,
        47978,
        48008,
        48037,
        48066,
        48096,
        48125,
        48155,
        48184,
        48214,
        48244,
        48273,
        48303,
        48333,
        48362,
        48392,
        48421,
        48450,
        48480,
        48509,
        48538,
        48568,
        48598,
        48627,
        48657,
        48687,
        48717,
        48746,
        48776,
        48805,
        48834,
        48864,
        48893,
        48922,
        48952,
        48982,
        49011,
        49041,
        49071,
        49100,
        49130,
        49160,
        49189,
        49218,
        49248,
        49277,
        49306,
        49336,
        49365,
        49395,
        49425,
        49455,
        49484,
        49514,
        49543,
        49573,
        49602,
        49632,
        49661,
        49690,
        49720,
        49749,
        49779,
        49809,
        49838,
        49868,
        49898,
        49927,
        49957,
        49986,
        50016,
        50045,
        50075,
        50104,
        50133,
        50163,
        50192,
        50222,
        50252,
        50281,
        50311,
        50340,
        50370,
        50400,
        50429,
        50459,
        50488,
        50518,
        50547,
        50576,
        50606,
        50635,
        50665,
        50694,
        50724,
        50754,
        50784,
        50813,
        50843,
        50872,
        50902,
        50931,
        50960,
        50990,
        51019,
        51049,
        51078,
        51108,
        51138,
        51167,
        51197,
        51227,
        51256,
        51286,
        51315,
        51345,
        51374,
        51403,
        51433,
        51462,
        51492,
        51522,
        51552,
        51582,
        51611,
        51641,
        51670,
        51699,
        51729,
        51758,
        51787,
        51816,
        51846,
        51876,
        51906,
        51936,
        51965,
        51995,
        52025,
        52054,
        52083,
        52113,
        52142,
        52171,
        52200,
        52230,
        52260,
        52290,
        52319,
        52349,
        52379,
        52408,
        52438,
        52467,
        52497,
        52526,
        52555,
        52585,
        52614,
        52644,
        52673,
        52703,
        52733,
        52762,
        52792,
        52822,
        52851,
        52881,
        52910,
        52939,
        52969,
        52998,
        53028,
        53057,
        53087,
        53116,
        53146,
        53176,
        53205,
        53235,
        53264,
        53294,
        53324,
        53353,
        53383,
        53412,
        53441,
        53471,
        53500,
        53530,
        53559,
        53589,
        53619,
        53648,
        53678,
        53708,
        53737,
        53767,
        53796,
        53825,
        53855,
        53884,
        53913,
        53943,
        53973,
        54003,
        54032,
        54062,
        54092,
        54121,
        54151,
        54180,
        54209,
        54239,
        54268,
        54297,
        54327,
        54357,
        54387,
        54416,
        54446,
        54476,
        54505,
        54535,
        54564,
        54593,
        54623,
        54652,
        54681,
        54711,
        54741,
        54770,
        54800,
        54830,
        54859,
        54889,
        54919,
        54948,
        54977,
        55007,
        55036,
        55066,
        55095,
        55125,
        55154,
        55184,
        55213,
        55243,
        55273,
        55302,
        55332,
        55361,
        55391,
        55420,
        55450,
        55479,
        55508,
        55538,
        55567,
        55597,
        55627,
        55657,
        55686,
        55716,
        55745,
        55775,
        55804,
        55834,
        55863,
        55892,
        55922,
        55951,
        55981,
        56011,
        56040,
        56070,
        56100,
        56129,
        56159,
        56188,
        56218,
        56247,
        56276,
        56306,
        56335,
        56365,
        56394,
        56424,
        56454,
        56483,
        56513,
        56543,
        56572,
        56601,
        56631,
        56660,
        56690,
        56719,
        56749,
        56778,
        56808,
        56837,
        56867,
        56897,
        56926,
        56956,
        56985,
        57015,
        57044,
        57074,
        57103,
        57133,
        57162,
        57192,
        57221,
        57251,
        57280,
        57310,
        57340,
        57369,
        57399,
        57429,
        57458,
        57487,
        57517,
        57546,
        57576,
        57605,
        57634,
        57664,
        57694,
        57723,
        57753,
        57783,
        57813,
        57842,
        57871,
        57901,
        57930,
        57959,
        57989,
        58018,
        58048,
        58077,
        58107,
        58137,
        58167,
        58196,
        58226,
        58255,
        58285,
        58314,
        58343,
        58373,
        58402,
        58432,
        58461,
        58491,
        58521,
        58551,
        58580,
        58610,
        58639,
        58669,
        58698,
        58727,
        58757,
        58786,
        58816,
        58845,
        58875,
        58905,
        58934,
        58964,
        58994,
        59023,
        59053,
        59082,
        59111,
        59141,
        59170,
        59200,
        59229,
        59259,
        59288,
        59318,
        59348,
        59377,
        59407,
        59436,
        59466,
        59495,
        59525,
        59554,
        59584,
        59613,
        59643,
        59672,
        59702,
        59731,
        59761,
        59791,
        59820,
        59850,
        59879,
        59909,
        59939,
        59968,
        59997,
        60027,
        60056,
        60086,
        60115,
        60145,
        60174,
        60204,
        60234,
        60264,
        60293,
        60323,
        60352,
        60381,
        60411,
        60440,
        60469,
        60499,
        60528,
        60558,
        60588,
        60618,
        60648,
        60677,
        60707,
        60736,
        60765,
        60795,
        60824,
        60853,
        60883,
        60912,
        60942,
        60972,
        61002,
        61031,
        61061,
        61090,
        61120,
        61149,
        61179,
        61208,
        61237,
        61267,
        61296,
        61326,
        61356,
        61385,
        61415,
        61445,
        61474,
        61504,
        61533,
        61563,
        61592,
        61621,
        61651,
        61680,
        61710,
        61739,
        61769,
        61799,
        61828,
        61858,
        61888,
        61917,
        61947,
        61976,
        62006,
        62035,
        62064,
        62094,
        62123,
        62153,
        62182,
        62212,
        62242,
        62271,
        62301,
        62331,
        62360,
        62390,
        62419,
        62448,
        62478,
        62507,
        62537,
        62566,
        62596,
        62625,
        62655,
        62685,
        62715,
        62744,
        62774,
        62803,
        62832,
        62862,
        62891,
        62921,
        62950,
        62980,
        63009,
        63039,
        63069,
        63099,
        63128,
        63157,
        63187,
        63216,
        63246,
        63275,
        63305,
        63334,
        63363,
        63393,
        63423,
        63453,
        63482,
        63512,
        63541,
        63571,
        63600,
        63630,
        63659,
        63689,
        63718,
        63747,
        63777,
        63807,
        63836,
        63866,
        63895,
        63925,
        63955,
        63984,
        64014,
        64043,
        64073,
        64102,
        64131,
        64161,
        64190,
        64220,
        64249,
        64279,
        64309,
        64339,
        64368,
        64398,
        64427,
        64457,
        64486,
        64515,
        64545,
        64574,
        64603,
        64633,
        64663,
        64692,
        64722,
        64752,
        64782,
        64811,
        64841,
        64870,
        64899,
        64929,
        64958,
        64987,
        65017,
        65047,
        65076,
        65106,
        65136,
        65166,
        65195,
        65225,
        65254,
        65283,
        65313,
        65342,
        65371,
        65401,
        65431,
        65460,
        65490,
        65520,
        65549,
        65579,
        65608,
        65638,
        65667,
        65697,
        65726,
        65755,
        65785,
        65815,
        65844,
        65874,
        65903,
        65933,
        65963,
        65992,
        66022,
        66051,
        66081,
        66110,
        66140,
        66169,
        66199,
        66228,
        66258,
        66287,
        66317,
        66346,
        66376,
        66405,
        66435,
        66465,
        66494,
        66524,
        66553,
        66583,
        66612,
        66641,
        66671,
        66700,
        66730,
        66760,
        66789,
        66819,
        66849,
        66878,
        66908,
        66937,
        66967,
        66996,
        67025,
        67055,
        67084,
        67114,
        67143,
        67173,
        67203,
        67233,
        67262,
        67292,
        67321,
        67351,
        67380,
        67409,
        67439,
        67468,
        67497,
        67527,
        67557,
        67587,
        67617,
        67646,
        67676,
        67705,
        67735,
        67764,
        67793,
        67823,
        67852,
        67882,
        67911,
        67941,
        67971,
        68e3,
        68030,
        68060,
        68089,
        68119,
        68148,
        68177,
        68207,
        68236,
        68266,
        68295,
        68325,
        68354,
        68384,
        68414,
        68443,
        68473,
        68502,
        68532,
        68561,
        68591,
        68620,
        68650,
        68679,
        68708,
        68738,
        68768,
        68797,
        68827,
        68857,
        68886,
        68916,
        68946,
        68975,
        69004,
        69034,
        69063,
        69092,
        69122,
        69152,
        69181,
        69211,
        69240,
        69270,
        69300,
        69330,
        69359,
        69388,
        69418,
        69447,
        69476,
        69506,
        69535,
        69565,
        69595,
        69624,
        69654,
        69684,
        69713,
        69743,
        69772,
        69802,
        69831,
        69861,
        69890,
        69919,
        69949,
        69978,
        70008,
        70038,
        70067,
        70097,
        70126,
        70156,
        70186,
        70215,
        70245,
        70274,
        70303,
        70333,
        70362,
        70392,
        70421,
        70451,
        70481,
        70510,
        70540,
        70570,
        70599,
        70629,
        70658,
        70687,
        70717,
        70746,
        70776,
        70805,
        70835,
        70864,
        70894,
        70924,
        70954,
        70983,
        71013,
        71042,
        71071,
        71101,
        71130,
        71159,
        71189,
        71218,
        71248,
        71278,
        71308,
        71337,
        71367,
        71397,
        71426,
        71455,
        71485,
        71514,
        71543,
        71573,
        71602,
        71632,
        71662,
        71691,
        71721,
        71751,
        71781,
        71810,
        71839,
        71869,
        71898,
        71927,
        71957,
        71986,
        72016,
        72046,
        72075,
        72105,
        72135,
        72164,
        72194,
        72223,
        72253,
        72282,
        72311,
        72341,
        72370,
        72400,
        72429,
        72459,
        72489,
        72518,
        72548,
        72577,
        72607,
        72637,
        72666,
        72695,
        72725,
        72754,
        72784,
        72813,
        72843,
        72872,
        72902,
        72931,
        72961,
        72991,
        73020,
        73050,
        73080,
        73109,
        73139,
        73168,
        73197,
        73227,
        73256,
        73286,
        73315,
        73345,
        73375,
        73404,
        73434,
        73464,
        73493,
        73523,
        73552,
        73581,
        73611,
        73640,
        73669,
        73699,
        73729,
        73758,
        73788,
        73818,
        73848,
        73877,
        73907,
        73936,
        73965,
        73995,
        74024,
        74053,
        74083,
        74113,
        74142,
        74172,
        74202,
        74231,
        74261,
        74291,
        74320,
        74349,
        74379,
        74408,
        74437,
        74467,
        74497,
        74526,
        74556,
        74586,
        74615,
        74645,
        74675,
        74704,
        74733,
        74763,
        74792,
        74822,
        74851,
        74881,
        74910,
        74940,
        74969,
        74999,
        75029,
        75058,
        75088,
        75117,
        75147,
        75176,
        75206,
        75235,
        75264,
        75294,
        75323,
        75353,
        75383,
        75412,
        75442,
        75472,
        75501,
        75531,
        75560,
        75590,
        75619,
        75648,
        75678,
        75707,
        75737,
        75766,
        75796,
        75826,
        75856,
        75885,
        75915,
        75944,
        75974,
        76003,
        76032,
        76062,
        76091,
        76121,
        76150,
        76180,
        76210,
        76239,
        76269,
        76299,
        76328,
        76358,
        76387,
        76416,
        76446,
        76475,
        76505,
        76534,
        76564,
        76593,
        76623,
        76653,
        76682,
        76712,
        76741,
        76771,
        76801,
        76830,
        76859,
        76889,
        76918,
        76948,
        76977,
        77007,
        77036,
        77066,
        77096,
        77125,
        77155,
        77185,
        77214,
        77243,
        77273,
        77302,
        77332,
        77361,
        77390,
        77420,
        77450,
        77479,
        77509,
        77539,
        77569,
        77598,
        77627,
        77657,
        77686,
        77715,
        77745,
        77774,
        77804,
        77833,
        77863,
        77893,
        77923,
        77952,
        77982,
        78011,
        78041,
        78070,
        78099,
        78129,
        78158,
        78188,
        78217,
        78247,
        78277,
        78307,
        78336,
        78366,
        78395,
        78425,
        78454,
        78483,
        78513,
        78542,
        78572,
        78601,
        78631,
        78661,
        78690,
        78720,
        78750,
        78779,
        78808,
        78838,
        78867,
        78897,
        78926,
        78956,
        78985,
        79015,
        79044,
        79074,
        79104,
        79133,
        79163,
        79192,
        79222,
        79251,
        79281,
        79310,
        79340,
        79369,
        79399,
        79428,
        79458,
        79487,
        79517,
        79546,
        79576,
        79606,
        79635,
        79665,
        79695,
        79724,
        79753,
        79783,
        79812,
        79841,
        79871,
        79900,
        79930,
        79960,
        79990
      ];
    }
  });

  // src/components/calendars/calendars.js
  var require_calendars = __commonJS({
    "src/components/calendars/calendars.js"(exports, module) {
      "use strict";
      module.exports = require_main();
      require_plus();
      require_chinese();
      require_coptic();
      require_discworld();
      require_ethiopian();
      require_hebrew();
      require_islamic();
      require_julian();
      require_mayan();
      require_nanakshahi();
      require_nepali();
      require_persian();
      require_taiwan();
      require_thai();
      require_ummalqura();
    }
  });

  // src/components/calendars/index.js
  var require_calendars2 = __commonJS({
    "src/components/calendars/index.js"(exports, module) {
      "use strict";
      var calendars = require_calendars();
      var Lib = require_lib();
      var constants = require_numerical();
      var EPOCHJD = constants.EPOCHJD;
      var ONEDAY = constants.ONEDAY;
      var attributes = {
        valType: "enumerated",
        values: Lib.sortObjectKeys(calendars.calendars),
        editType: "calc",
        dflt: "gregorian"
      };
      var handleDefaults = function(contIn, contOut, attr, dflt) {
        var attrs = {};
        attrs[attr] = attributes;
        return Lib.coerce(contIn, contOut, attrs, attr, dflt);
      };
      var handleTraceDefaults = function(traceIn, traceOut, coords, layout) {
        for (var i = 0; i < coords.length; i++) {
          handleDefaults(traceIn, traceOut, coords[i] + "calendar", layout.calendar);
        }
      };
      var CANONICAL_TICK = {
        chinese: "2000-01-01",
        coptic: "2000-01-01",
        discworld: "2000-01-01",
        ethiopian: "2000-01-01",
        hebrew: "5000-01-01",
        islamic: "1000-01-01",
        julian: "2000-01-01",
        mayan: "5000-01-01",
        nanakshahi: "1000-01-01",
        nepali: "2000-01-01",
        persian: "1000-01-01",
        jalali: "1000-01-01",
        taiwan: "1000-01-01",
        thai: "2000-01-01",
        ummalqura: "1400-01-01"
      };
      var CANONICAL_SUNDAY = {
        chinese: "2000-01-02",
        coptic: "2000-01-03",
        discworld: "2000-01-03",
        ethiopian: "2000-01-05",
        hebrew: "5000-01-01",
        islamic: "1000-01-02",
        julian: "2000-01-03",
        mayan: "5000-01-01",
        nanakshahi: "1000-01-05",
        nepali: "2000-01-05",
        persian: "1000-01-01",
        jalali: "1000-01-01",
        taiwan: "1000-01-04",
        thai: "2000-01-04",
        ummalqura: "1400-01-06"
      };
      var DFLTRANGE = {
        chinese: ["2000-01-01", "2001-01-01"],
        coptic: ["1700-01-01", "1701-01-01"],
        discworld: ["1800-01-01", "1801-01-01"],
        ethiopian: ["2000-01-01", "2001-01-01"],
        hebrew: ["5700-01-01", "5701-01-01"],
        islamic: ["1400-01-01", "1401-01-01"],
        julian: ["2000-01-01", "2001-01-01"],
        mayan: ["5200-01-01", "5201-01-01"],
        nanakshahi: ["0500-01-01", "0501-01-01"],
        nepali: ["2000-01-01", "2001-01-01"],
        persian: ["1400-01-01", "1401-01-01"],
        jalali: ["1400-01-01", "1401-01-01"],
        taiwan: ["0100-01-01", "0101-01-01"],
        thai: ["2500-01-01", "2501-01-01"],
        ummalqura: ["1400-01-01", "1401-01-01"]
      };
      var UNKNOWN = "##";
      var d3ToWorldCalendars = {
        d: { 0: "dd", "-": "d" },
        // 2-digit or unpadded day of month
        e: { 0: "d", "-": "d" },
        // alternate, always unpadded day of month
        a: { 0: "D", "-": "D" },
        // short weekday name
        A: { 0: "DD", "-": "DD" },
        // full weekday name
        j: { 0: "oo", "-": "o" },
        // 3-digit or unpadded day of the year
        W: { 0: "ww", "-": "w" },
        // 2-digit or unpadded week of the year (Monday first)
        m: { 0: "mm", "-": "m" },
        // 2-digit or unpadded month number
        b: { 0: "M", "-": "M" },
        // short month name
        B: { 0: "MM", "-": "MM" },
        // full month name
        y: { 0: "yy", "-": "yy" },
        // 2-digit year (map unpadded to zero-padded)
        Y: { 0: "yyyy", "-": "yyyy" },
        // 4-digit year (map unpadded to zero-padded)
        U: UNKNOWN,
        // Sunday-first week of the year
        w: UNKNOWN,
        // day of the week [0(sunday),6]
        // combined format, we replace the date part with the world-calendar version
        // and the %X stays there for d3 to handle with time parts
        c: { 0: "D M d %X yyyy", "-": "D M d %X yyyy" },
        x: { 0: "mm/dd/yyyy", "-": "mm/dd/yyyy" }
      };
      function worldCalFmt(fmt, x, calendar) {
        var dateJD = Math.floor((x + 0.05) / ONEDAY) + EPOCHJD;
        var cDate = getCal(calendar).fromJD(dateJD);
        var i = 0;
        var modifier, directive, directiveLen, directiveObj, replacementPart;
        while ((i = fmt.indexOf("%", i)) !== -1) {
          modifier = fmt.charAt(i + 1);
          if (modifier === "0" || modifier === "-" || modifier === "_") {
            directiveLen = 3;
            directive = fmt.charAt(i + 2);
            if (modifier === "_") modifier = "-";
          } else {
            directive = modifier;
            modifier = "0";
            directiveLen = 2;
          }
          directiveObj = d3ToWorldCalendars[directive];
          if (!directiveObj) {
            i += directiveLen;
          } else {
            if (directiveObj === UNKNOWN) replacementPart = UNKNOWN;
            else replacementPart = cDate.formatDate(directiveObj[modifier]);
            fmt = fmt.substr(0, i) + replacementPart + fmt.substr(i + directiveLen);
            i += replacementPart.length;
          }
        }
        return fmt;
      }
      var allCals = {};
      function getCal(calendar) {
        var calendarObj = allCals[calendar];
        if (calendarObj) return calendarObj;
        calendarObj = allCals[calendar] = calendars.instance(calendar);
        return calendarObj;
      }
      function makeAttrs(description) {
        return Lib.extendFlat({}, attributes, { description });
      }
      function makeTraceAttrsDescription(coord) {
        return "Sets the calendar system to use with `" + coord + "` date data.";
      }
      var xAttrs = {
        xcalendar: makeAttrs(makeTraceAttrsDescription("x"))
      };
      var xyAttrs = Lib.extendFlat({}, xAttrs, {
        ycalendar: makeAttrs(makeTraceAttrsDescription("y"))
      });
      var xyzAttrs = Lib.extendFlat({}, xyAttrs, {
        zcalendar: makeAttrs(makeTraceAttrsDescription("z"))
      });
      var axisAttrs = makeAttrs([
        "Sets the calendar system to use for `range` and `tick0`",
        "if this is a date axis. This does not set the calendar for",
        "interpreting data on this axis, that's specified in the trace",
        "or via the global `layout.calendar`"
      ].join(" "));
      module.exports = {
        moduleType: "component",
        name: "calendars",
        schema: {
          traces: {
            scatter: xyAttrs,
            bar: xyAttrs,
            box: xyAttrs,
            heatmap: xyAttrs,
            contour: xyAttrs,
            histogram: xyAttrs,
            histogram2d: xyAttrs,
            histogram2dcontour: xyAttrs,
            scatter3d: xyzAttrs,
            surface: xyzAttrs,
            mesh3d: xyzAttrs,
            scattergl: xyAttrs,
            ohlc: xAttrs,
            candlestick: xAttrs
          },
          layout: {
            calendar: makeAttrs([
              "Sets the default calendar system to use for interpreting and",
              "displaying dates throughout the plot."
            ].join(" "))
          },
          subplots: {
            xaxis: { calendar: axisAttrs },
            yaxis: { calendar: axisAttrs },
            scene: {
              xaxis: { calendar: axisAttrs },
              // TODO: it's actually redundant to include yaxis and zaxis here
              // because in the scene attributes these are the same object so merging
              // into one merges into them all. However, I left them in for parity with
              // cartesian, where yaxis is unused until we Plotschema.get() when we
              // use its presence or absence to determine whether to delete attributes
              // from yaxis if they only apply to x (rangeselector/rangeslider)
              yaxis: { calendar: axisAttrs },
              zaxis: { calendar: axisAttrs }
            },
            polar: {
              radialaxis: { calendar: axisAttrs }
            }
          }
        },
        layoutAttributes: attributes,
        handleDefaults,
        handleTraceDefaults,
        CANONICAL_SUNDAY,
        CANONICAL_TICK,
        DFLTRANGE,
        getCal,
        worldCalFmt
      };
    }
  });

  // lib/calendars.js
  var require_calendars3 = __commonJS({
    "lib/calendars.js"(exports, module) {
      "use strict";
      module.exports = require_calendars2();
    }
  });

  // lib/index-geo.js
  var require_index_geo = __commonJS({
    "lib/index-geo.js"(exports, module) {
      var Plotly = require_core2();
      Plotly.register([
        // traces
        require_scattergeo2(),
        require_choropleth2(),
        // components
        require_calendars3()
      ]);
      module.exports = Plotly;
    }
  });
  return require_index_geo();
})();
/*! Bundled license information:

native-promise-only/lib/npo.src.js:
  (*! Native Promise Only
      v0.8.1 (c) Kyle Simpson
      MIT License: http://getify.mit-license.org
  *)

polybooljs/index.js:
  (*
   * @copyright 2016 Sean Connelly (@voidqk), http://syntheti.cc
   * @license MIT
   * @preserve Project Home: https://github.com/voidqk/polybooljs
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
*/

window.Plotly = Plotly;
return Plotly;
}));